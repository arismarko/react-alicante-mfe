/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "async-pages_itemcatalogue_js";
exports.ids = ["async-pages_itemcatalogue_js"];
exports.modules = {

/***/ "./node_modules/.prisma/client/index.js":
/*!**********************************************!*\
  !*** ./node_modules/.prisma/client/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientRustPanicError,\n  PrismaClientInitializationError,\n  PrismaClientValidationError,\n  NotFoundError,\n  decompressFromBase64,\n  getPrismaClient,\n  sqltag,\n  empty,\n  join,\n  raw,\n  Decimal,\n  Debug,\n  objectEnumValues,\n  makeStrictEnum\n} = __webpack_require__(/*! @prisma/client/runtime/index */ \"./node_modules/@prisma/client/runtime/index.js\")\n\n\nconst Prisma = {}\n\nexports.Prisma = Prisma\n\n/**\n * Prisma Client JS version: 4.3.1\n * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b\n */\nPrisma.prismaVersion = {\n  client: \"4.3.1\",\n  engine: \"c875e43600dfe042452e0b868f7a48b817b9640b\"\n}\n\nPrisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;\nPrisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError\nPrisma.PrismaClientRustPanicError = PrismaClientRustPanicError\nPrisma.PrismaClientInitializationError = PrismaClientInitializationError\nPrisma.PrismaClientValidationError = PrismaClientValidationError\nPrisma.NotFoundError = NotFoundError\nPrisma.Decimal = Decimal\n\n/**\n * Re-export of sql-template-tag\n */\nPrisma.sql = sqltag\nPrisma.empty = empty\nPrisma.join = join\nPrisma.raw = raw\nPrisma.validator = () => (val) => val\n\n/**\n * Shorthand utilities for JSON filtering\n */\nPrisma.DbNull = objectEnumValues.instances.DbNull\nPrisma.JsonNull = objectEnumValues.instances.JsonNull\nPrisma.AnyNull = objectEnumValues.instances.AnyNull\n\nPrisma.NullTypes = {\n  DbNull: objectEnumValues.classes.DbNull,\n  JsonNull: objectEnumValues.classes.JsonNull,\n  AnyNull: objectEnumValues.classes.AnyNull\n}\n\n\n  const path = __webpack_require__(/*! path */ \"path\")\n\nconst { findSync } = __webpack_require__(/*! @prisma/client/runtime */ \"./node_modules/@prisma/client/runtime/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\n// some frameworks or bundlers replace or totally remove __dirname\nconst hasDirname =  true && __dirname !== '/'\n\n// will work in most cases, ie. if the client has not been bundled\nconst regularDirname = hasDirname && fs.existsSync(path.join(__dirname, 'schema.prisma')) && __dirname\n\n// if the client has been bundled, we need to look for the folders\nconst foundDirname = !regularDirname && findSync(process.cwd(), [\n    \"node_modules/.prisma/client\",\n    \".prisma/client\",\n], ['d'], ['d'], 1)[0]\n\nconst dirname = regularDirname || foundDirname || __dirname\n\n/**\n * Enums\n */\n// Based on\n// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nfunction makeEnum(x) { return x; }\n\nexports.Prisma.ProductScalarFieldEnum = makeEnum({\n  id: 'id',\n  name: 'name',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n});\n\nexports.Prisma.QueryMode = makeEnum({\n  default: 'default',\n  insensitive: 'insensitive'\n});\n\nexports.Prisma.SortOrder = makeEnum({\n  asc: 'asc',\n  desc: 'desc'\n});\n\nexports.Prisma.StoreScalarFieldEnum = makeEnum({\n  id: 'id',\n  title: 'title',\n  location: 'location'\n});\n\nexports.Prisma.TransactionIsolationLevel = makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n});\n\n\nexports.Prisma.ModelName = makeEnum({\n  Store: 'Store',\n  Product: 'Product'\n});\n\nconst dmmfString = \"{\\\"datamodel\\\":{\\\"enums\\\":[],\\\"models\\\":[{\\\"name\\\":\\\"Store\\\",\\\"dbName\\\":null,\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":true,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"String\\\",\\\"default\\\":{\\\"name\\\":\\\"cuid\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":false,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"products\\\",\\\"kind\\\":\\\"object\\\",\\\"isList\\\":true,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"Product\\\",\\\"relationName\\\":\\\"ProductToStore\\\",\\\"relationFromFields\\\":[],\\\"relationToFields\\\":[\\\"id\\\"],\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false}],\\\"primaryKey\\\":null,\\\"uniqueFields\\\":[],\\\"uniqueIndexes\\\":[],\\\"isGenerated\\\":false},{\\\"name\\\":\\\"Product\\\",\\\"dbName\\\":null,\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":true,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"String\\\",\\\"default\\\":{\\\"name\\\":\\\"cuid\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":false,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"DateTime\\\",\\\"default\\\":{\\\"name\\\":\\\"now\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"DateTime\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":true},{\\\"name\\\":\\\"stores\\\",\\\"kind\\\":\\\"object\\\",\\\"isList\\\":true,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"Store\\\",\\\"relationName\\\":\\\"ProductToStore\\\",\\\"relationFromFields\\\":[],\\\"relationToFields\\\":[\\\"id\\\"],\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false}],\\\"primaryKey\\\":null,\\\"uniqueFields\\\":[],\\\"uniqueIndexes\\\":[],\\\"isGenerated\\\":false}],\\\"types\\\":[]},\\\"mappings\\\":{\\\"modelOperations\\\":[{\\\"model\\\":\\\"Store\\\",\\\"plural\\\":\\\"stores\\\",\\\"findUnique\\\":\\\"findUniqueStore\\\",\\\"findFirst\\\":\\\"findFirstStore\\\",\\\"findMany\\\":\\\"findManyStore\\\",\\\"create\\\":\\\"createOneStore\\\",\\\"createMany\\\":\\\"createManyStore\\\",\\\"delete\\\":\\\"deleteOneStore\\\",\\\"update\\\":\\\"updateOneStore\\\",\\\"deleteMany\\\":\\\"deleteManyStore\\\",\\\"updateMany\\\":\\\"updateManyStore\\\",\\\"upsert\\\":\\\"upsertOneStore\\\",\\\"aggregate\\\":\\\"aggregateStore\\\",\\\"groupBy\\\":\\\"groupByStore\\\"},{\\\"model\\\":\\\"Product\\\",\\\"plural\\\":\\\"products\\\",\\\"findUnique\\\":\\\"findUniqueProduct\\\",\\\"findFirst\\\":\\\"findFirstProduct\\\",\\\"findMany\\\":\\\"findManyProduct\\\",\\\"create\\\":\\\"createOneProduct\\\",\\\"createMany\\\":\\\"createManyProduct\\\",\\\"delete\\\":\\\"deleteOneProduct\\\",\\\"update\\\":\\\"updateOneProduct\\\",\\\"deleteMany\\\":\\\"deleteManyProduct\\\",\\\"updateMany\\\":\\\"updateManyProduct\\\",\\\"upsert\\\":\\\"upsertOneProduct\\\",\\\"aggregate\\\":\\\"aggregateProduct\\\",\\\"groupBy\\\":\\\"groupByProduct\\\"}],\\\"otherOperations\\\":{\\\"read\\\":[],\\\"write\\\":[\\\"executeRaw\\\",\\\"queryRaw\\\"]}}}\"\nconst dmmf = JSON.parse(dmmfString)\nexports.Prisma.dmmf = JSON.parse(dmmfString)\n\n/**\n * Create the Client\n */\nconst config = {\n  \"generator\": {\n    \"name\": \"client\",\n    \"provider\": {\n      \"fromEnvVar\": null,\n      \"value\": \"prisma-client-js\"\n    },\n    \"output\": {\n      \"value\": \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/node_modules/@prisma/client\",\n      \"fromEnvVar\": null\n    },\n    \"config\": {\n      \"engineType\": \"library\"\n    },\n    \"binaryTargets\": [],\n    \"previewFeatures\": []\n  },\n  \"relativeEnvPaths\": {\n    \"rootEnvPath\": \"../../../.env\",\n    \"schemaEnvPath\": \"../../../.env\"\n  },\n  \"relativePath\": \"../../../prisma\",\n  \"clientVersion\": \"4.3.1\",\n  \"engineVersion\": \"c875e43600dfe042452e0b868f7a48b817b9640b\",\n  \"datasourceNames\": [\n    \"db\"\n  ],\n  \"activeProvider\": \"postgresql\",\n  \"dataProxy\": false\n}\nconfig.document = dmmf\nconfig.dirname = dirname\n\n\n\n\nconst { warnEnvConflicts } = __webpack_require__(/*! @prisma/client/runtime/index */ \"./node_modules/@prisma/client/runtime/index.js\")\n\nwarnEnvConflicts({\n    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(dirname, config.relativeEnvPaths.rootEnvPath),\n    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(dirname, config.relativeEnvPaths.schemaEnvPath)\n})\n\nconst PrismaClient = getPrismaClient(config)\nexports.PrismaClient = PrismaClient\nObject.assign(exports, Prisma)\n\npath.join(__dirname, \"libquery_engine-darwin-arm64.dylib.node\");\npath.join(process.cwd(), \"node_modules/.prisma/client/libquery_engine-darwin-arm64.dylib.node\")\npath.join(__dirname, \"schema.prisma\");\npath.join(process.cwd(), \"node_modules/.prisma/client/schema.prisma\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLG9GQUE4Qjs7O0FBRzFDOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxlQUFlLG1CQUFPLENBQUMsa0JBQU07O0FBRTdCLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsOEVBQXdCO0FBQ3JELFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QjtBQUNBLG1CQUFtQixLQUFnQzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOztBQUVELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCLGVBQWUsMEJBQTBCLGdEQUFnRCx5TEFBeUwsOEJBQThCLDZDQUE2QyxFQUFFLDZOQUE2TixFQUFFLGlPQUFpTyxFQUFFLDRUQUE0VCxxRkFBcUYsRUFBRSxrREFBa0QseUxBQXlMLDhCQUE4Qiw2Q0FBNkMsRUFBRSw2TkFBNk4sRUFBRSxtTUFBbU0sNkJBQTZCLDZDQUE2QyxFQUFFLGtPQUFrTyxFQUFFLHdUQUF3VCxxRkFBcUYsZUFBZSxlQUFlLHNCQUFzQiw0YUFBNGEsRUFBRSx3Y0FBd2MsdUJBQXVCLHNEQUFzRDtBQUN2bEg7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxvRkFBOEI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGVtY2F0YWxvZ3VlLy4vbm9kZV9tb2R1bGVzLy5wcmlzbWEvY2xpZW50L2luZGV4LmpzPzNlYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IHtcbiAgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLFxuICBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLFxuICBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIGRlY29tcHJlc3NGcm9tQmFzZTY0LFxuICBnZXRQcmlzbWFDbGllbnQsXG4gIHNxbHRhZyxcbiAgZW1wdHksXG4gIGpvaW4sXG4gIHJhdyxcbiAgRGVjaW1hbCxcbiAgRGVidWcsXG4gIG9iamVjdEVudW1WYWx1ZXMsXG4gIG1ha2VTdHJpY3RFbnVtXG59ID0gcmVxdWlyZSgnQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleCcpXG5cblxuY29uc3QgUHJpc21hID0ge31cblxuZXhwb3J0cy5QcmlzbWEgPSBQcmlzbWFcblxuLyoqXG4gKiBQcmlzbWEgQ2xpZW50IEpTIHZlcnNpb246IDQuMy4xXG4gKiBRdWVyeSBFbmdpbmUgdmVyc2lvbjogYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYlxuICovXG5QcmlzbWEucHJpc21hVmVyc2lvbiA9IHtcbiAgY2xpZW50OiBcIjQuMy4xXCIsXG4gIGVuZ2luZTogXCJjODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiXCJcbn1cblxuUHJpc21hLlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yID0gUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3I7XG5QcmlzbWEuUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvciA9IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcblByaXNtYS5QcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvciA9IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXG5QcmlzbWEuUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciA9IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcblByaXNtYS5QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3JcblByaXNtYS5Ob3RGb3VuZEVycm9yID0gTm90Rm91bmRFcnJvclxuUHJpc21hLkRlY2ltYWwgPSBEZWNpbWFsXG5cbi8qKlxuICogUmUtZXhwb3J0IG9mIHNxbC10ZW1wbGF0ZS10YWdcbiAqL1xuUHJpc21hLnNxbCA9IHNxbHRhZ1xuUHJpc21hLmVtcHR5ID0gZW1wdHlcblByaXNtYS5qb2luID0gam9pblxuUHJpc21hLnJhdyA9IHJhd1xuUHJpc21hLnZhbGlkYXRvciA9ICgpID0+ICh2YWwpID0+IHZhbFxuXG4vKipcbiAqIFNob3J0aGFuZCB1dGlsaXRpZXMgZm9yIEpTT04gZmlsdGVyaW5nXG4gKi9cblByaXNtYS5EYk51bGwgPSBvYmplY3RFbnVtVmFsdWVzLmluc3RhbmNlcy5EYk51bGxcblByaXNtYS5Kc29uTnVsbCA9IG9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzLkpzb25OdWxsXG5QcmlzbWEuQW55TnVsbCA9IG9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzLkFueU51bGxcblxuUHJpc21hLk51bGxUeXBlcyA9IHtcbiAgRGJOdWxsOiBvYmplY3RFbnVtVmFsdWVzLmNsYXNzZXMuRGJOdWxsLFxuICBKc29uTnVsbDogb2JqZWN0RW51bVZhbHVlcy5jbGFzc2VzLkpzb25OdWxsLFxuICBBbnlOdWxsOiBvYmplY3RFbnVtVmFsdWVzLmNsYXNzZXMuQW55TnVsbFxufVxuXG5cbiAgY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCB7IGZpbmRTeW5jIH0gPSByZXF1aXJlKCdAcHJpc21hL2NsaWVudC9ydW50aW1lJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuXG4vLyBzb21lIGZyYW1ld29ya3Mgb3IgYnVuZGxlcnMgcmVwbGFjZSBvciB0b3RhbGx5IHJlbW92ZSBfX2Rpcm5hbWVcbmNvbnN0IGhhc0Rpcm5hbWUgPSB0eXBlb2YgX19kaXJuYW1lICE9PSAndW5kZWZpbmVkJyAmJiBfX2Rpcm5hbWUgIT09ICcvJ1xuXG4vLyB3aWxsIHdvcmsgaW4gbW9zdCBjYXNlcywgaWUuIGlmIHRoZSBjbGllbnQgaGFzIG5vdCBiZWVuIGJ1bmRsZWRcbmNvbnN0IHJlZ3VsYXJEaXJuYW1lID0gaGFzRGlybmFtZSAmJiBmcy5leGlzdHNTeW5jKHBhdGguam9pbihfX2Rpcm5hbWUsICdzY2hlbWEucHJpc21hJykpICYmIF9fZGlybmFtZVxuXG4vLyBpZiB0aGUgY2xpZW50IGhhcyBiZWVuIGJ1bmRsZWQsIHdlIG5lZWQgdG8gbG9vayBmb3IgdGhlIGZvbGRlcnNcbmNvbnN0IGZvdW5kRGlybmFtZSA9ICFyZWd1bGFyRGlybmFtZSAmJiBmaW5kU3luYyhwcm9jZXNzLmN3ZCgpLCBbXG4gICAgXCJub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnRcIixcbiAgICBcIi5wcmlzbWEvY2xpZW50XCIsXG5dLCBbJ2QnXSwgWydkJ10sIDEpWzBdXG5cbmNvbnN0IGRpcm5hbWUgPSByZWd1bGFyRGlybmFtZSB8fCBmb3VuZERpcm5hbWUgfHwgX19kaXJuYW1lXG5cbi8qKlxuICogRW51bXNcbiAqL1xuLy8gQmFzZWQgb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE5MiNpc3N1ZWNvbW1lbnQtMjYxNzIwMjc1XG5mdW5jdGlvbiBtYWtlRW51bSh4KSB7IHJldHVybiB4OyB9XG5cbmV4cG9ydHMuUHJpc21hLlByb2R1Y3RTY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIGNyZWF0ZWRBdDogJ2NyZWF0ZWRBdCcsXG4gIHVwZGF0ZWRBdDogJ3VwZGF0ZWRBdCdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5RdWVyeU1vZGUgPSBtYWtlRW51bSh7XG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgaW5zZW5zaXRpdmU6ICdpbnNlbnNpdGl2ZSdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5Tb3J0T3JkZXIgPSBtYWtlRW51bSh7XG4gIGFzYzogJ2FzYycsXG4gIGRlc2M6ICdkZXNjJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLlN0b3JlU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIGxvY2F0aW9uOiAnbG9jYXRpb24nXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuVHJhbnNhY3Rpb25Jc29sYXRpb25MZXZlbCA9IG1ha2VTdHJpY3RFbnVtKHtcbiAgUmVhZFVuY29tbWl0dGVkOiAnUmVhZFVuY29tbWl0dGVkJyxcbiAgUmVhZENvbW1pdHRlZDogJ1JlYWRDb21taXR0ZWQnLFxuICBSZXBlYXRhYmxlUmVhZDogJ1JlcGVhdGFibGVSZWFkJyxcbiAgU2VyaWFsaXphYmxlOiAnU2VyaWFsaXphYmxlJ1xufSk7XG5cblxuZXhwb3J0cy5QcmlzbWEuTW9kZWxOYW1lID0gbWFrZUVudW0oe1xuICBTdG9yZTogJ1N0b3JlJyxcbiAgUHJvZHVjdDogJ1Byb2R1Y3QnXG59KTtcblxuY29uc3QgZG1tZlN0cmluZyA9IFwie1xcXCJkYXRhbW9kZWxcXFwiOntcXFwiZW51bXNcXFwiOltdLFxcXCJtb2RlbHNcXFwiOlt7XFxcIm5hbWVcXFwiOlxcXCJTdG9yZVxcXCIsXFxcImRiTmFtZVxcXCI6bnVsbCxcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOltdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInRpdGxlXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImxvY2F0aW9uXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOmZhbHNlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJwcm9kdWN0c1xcXCIsXFxcImtpbmRcXFwiOlxcXCJvYmplY3RcXFwiLFxcXCJpc0xpc3RcXFwiOnRydWUsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiUHJvZHVjdFxcXCIsXFxcInJlbGF0aW9uTmFtZVxcXCI6XFxcIlByb2R1Y3RUb1N0b3JlXFxcIixcXFwicmVsYXRpb25Gcm9tRmllbGRzXFxcIjpbXSxcXFwicmVsYXRpb25Ub0ZpZWxkc1xcXCI6W1xcXCJpZFxcXCJdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX1dLFxcXCJwcmltYXJ5S2V5XFxcIjpudWxsLFxcXCJ1bmlxdWVGaWVsZHNcXFwiOltdLFxcXCJ1bmlxdWVJbmRleGVzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJQcm9kdWN0XFxcIixcXFwiZGJOYW1lXFxcIjpudWxsLFxcXCJmaWVsZHNcXFwiOlt7XFxcIm5hbWVcXFwiOlxcXCJpZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOnRydWUsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJjdWlkXFxcIixcXFwiYXJnc1xcXCI6W119LFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwibmFtZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjpmYWxzZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwiY3JlYXRlZEF0XFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcImRlZmF1bHRcXFwiOntcXFwibmFtZVxcXCI6XFxcIm5vd1xcXCIsXFxcImFyZ3NcXFwiOltdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInVwZGF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIkRhdGVUaW1lXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6dHJ1ZX0se1xcXCJuYW1lXFxcIjpcXFwic3RvcmVzXFxcIixcXFwia2luZFxcXCI6XFxcIm9iamVjdFxcXCIsXFxcImlzTGlzdFxcXCI6dHJ1ZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdG9yZVxcXCIsXFxcInJlbGF0aW9uTmFtZVxcXCI6XFxcIlByb2R1Y3RUb1N0b3JlXFxcIixcXFwicmVsYXRpb25Gcm9tRmllbGRzXFxcIjpbXSxcXFwicmVsYXRpb25Ub0ZpZWxkc1xcXCI6W1xcXCJpZFxcXCJdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX1dLFxcXCJwcmltYXJ5S2V5XFxcIjpudWxsLFxcXCJ1bmlxdWVGaWVsZHNcXFwiOltdLFxcXCJ1bmlxdWVJbmRleGVzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlfV0sXFxcInR5cGVzXFxcIjpbXX0sXFxcIm1hcHBpbmdzXFxcIjp7XFxcIm1vZGVsT3BlcmF0aW9uc1xcXCI6W3tcXFwibW9kZWxcXFwiOlxcXCJTdG9yZVxcXCIsXFxcInBsdXJhbFxcXCI6XFxcInN0b3Jlc1xcXCIsXFxcImZpbmRVbmlxdWVcXFwiOlxcXCJmaW5kVW5pcXVlU3RvcmVcXFwiLFxcXCJmaW5kRmlyc3RcXFwiOlxcXCJmaW5kRmlyc3RTdG9yZVxcXCIsXFxcImZpbmRNYW55XFxcIjpcXFwiZmluZE1hbnlTdG9yZVxcXCIsXFxcImNyZWF0ZVxcXCI6XFxcImNyZWF0ZU9uZVN0b3JlXFxcIixcXFwiY3JlYXRlTWFueVxcXCI6XFxcImNyZWF0ZU1hbnlTdG9yZVxcXCIsXFxcImRlbGV0ZVxcXCI6XFxcImRlbGV0ZU9uZVN0b3JlXFxcIixcXFwidXBkYXRlXFxcIjpcXFwidXBkYXRlT25lU3RvcmVcXFwiLFxcXCJkZWxldGVNYW55XFxcIjpcXFwiZGVsZXRlTWFueVN0b3JlXFxcIixcXFwidXBkYXRlTWFueVxcXCI6XFxcInVwZGF0ZU1hbnlTdG9yZVxcXCIsXFxcInVwc2VydFxcXCI6XFxcInVwc2VydE9uZVN0b3JlXFxcIixcXFwiYWdncmVnYXRlXFxcIjpcXFwiYWdncmVnYXRlU3RvcmVcXFwiLFxcXCJncm91cEJ5XFxcIjpcXFwiZ3JvdXBCeVN0b3JlXFxcIn0se1xcXCJtb2RlbFxcXCI6XFxcIlByb2R1Y3RcXFwiLFxcXCJwbHVyYWxcXFwiOlxcXCJwcm9kdWN0c1xcXCIsXFxcImZpbmRVbmlxdWVcXFwiOlxcXCJmaW5kVW5pcXVlUHJvZHVjdFxcXCIsXFxcImZpbmRGaXJzdFxcXCI6XFxcImZpbmRGaXJzdFByb2R1Y3RcXFwiLFxcXCJmaW5kTWFueVxcXCI6XFxcImZpbmRNYW55UHJvZHVjdFxcXCIsXFxcImNyZWF0ZVxcXCI6XFxcImNyZWF0ZU9uZVByb2R1Y3RcXFwiLFxcXCJjcmVhdGVNYW55XFxcIjpcXFwiY3JlYXRlTWFueVByb2R1Y3RcXFwiLFxcXCJkZWxldGVcXFwiOlxcXCJkZWxldGVPbmVQcm9kdWN0XFxcIixcXFwidXBkYXRlXFxcIjpcXFwidXBkYXRlT25lUHJvZHVjdFxcXCIsXFxcImRlbGV0ZU1hbnlcXFwiOlxcXCJkZWxldGVNYW55UHJvZHVjdFxcXCIsXFxcInVwZGF0ZU1hbnlcXFwiOlxcXCJ1cGRhdGVNYW55UHJvZHVjdFxcXCIsXFxcInVwc2VydFxcXCI6XFxcInVwc2VydE9uZVByb2R1Y3RcXFwiLFxcXCJhZ2dyZWdhdGVcXFwiOlxcXCJhZ2dyZWdhdGVQcm9kdWN0XFxcIixcXFwiZ3JvdXBCeVxcXCI6XFxcImdyb3VwQnlQcm9kdWN0XFxcIn1dLFxcXCJvdGhlck9wZXJhdGlvbnNcXFwiOntcXFwicmVhZFxcXCI6W10sXFxcIndyaXRlXFxcIjpbXFxcImV4ZWN1dGVSYXdcXFwiLFxcXCJxdWVyeVJhd1xcXCJdfX19XCJcbmNvbnN0IGRtbWYgPSBKU09OLnBhcnNlKGRtbWZTdHJpbmcpXG5leHBvcnRzLlByaXNtYS5kbW1mID0gSlNPTi5wYXJzZShkbW1mU3RyaW5nKVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgQ2xpZW50XG4gKi9cbmNvbnN0IGNvbmZpZyA9IHtcbiAgXCJnZW5lcmF0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcImNsaWVudFwiLFxuICAgIFwicHJvdmlkZXJcIjoge1xuICAgICAgXCJmcm9tRW52VmFyXCI6IG51bGwsXG4gICAgICBcInZhbHVlXCI6IFwicHJpc21hLWNsaWVudC1qc1wiXG4gICAgfSxcbiAgICBcIm91dHB1dFwiOiB7XG4gICAgICBcInZhbHVlXCI6IFwiL1VzZXJzL2FyaXN0b3NtYXJrb2dpYW5uYWtpcy9Qcm9qZWN0cy9jb25mZXJlbmNlL2FsaWNhbnRlLW1pY3JvZnJvbnRlbmRzLWRlbW8yL2l0ZW1jYXRhbG9ndWUvbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50XCIsXG4gICAgICBcImZyb21FbnZWYXJcIjogbnVsbFxuICAgIH0sXG4gICAgXCJjb25maWdcIjoge1xuICAgICAgXCJlbmdpbmVUeXBlXCI6IFwibGlicmFyeVwiXG4gICAgfSxcbiAgICBcImJpbmFyeVRhcmdldHNcIjogW10sXG4gICAgXCJwcmV2aWV3RmVhdHVyZXNcIjogW11cbiAgfSxcbiAgXCJyZWxhdGl2ZUVudlBhdGhzXCI6IHtcbiAgICBcInJvb3RFbnZQYXRoXCI6IFwiLi4vLi4vLi4vLmVudlwiLFxuICAgIFwic2NoZW1hRW52UGF0aFwiOiBcIi4uLy4uLy4uLy5lbnZcIlxuICB9LFxuICBcInJlbGF0aXZlUGF0aFwiOiBcIi4uLy4uLy4uL3ByaXNtYVwiLFxuICBcImNsaWVudFZlcnNpb25cIjogXCI0LjMuMVwiLFxuICBcImVuZ2luZVZlcnNpb25cIjogXCJjODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiXCIsXG4gIFwiZGF0YXNvdXJjZU5hbWVzXCI6IFtcbiAgICBcImRiXCJcbiAgXSxcbiAgXCJhY3RpdmVQcm92aWRlclwiOiBcInBvc3RncmVzcWxcIixcbiAgXCJkYXRhUHJveHlcIjogZmFsc2Vcbn1cbmNvbmZpZy5kb2N1bWVudCA9IGRtbWZcbmNvbmZpZy5kaXJuYW1lID0gZGlybmFtZVxuXG5cblxuXG5jb25zdCB7IHdhcm5FbnZDb25mbGljdHMgfSA9IHJlcXVpcmUoJ0BwcmlzbWEvY2xpZW50L3J1bnRpbWUvaW5kZXgnKVxuXG53YXJuRW52Q29uZmxpY3RzKHtcbiAgICByb290RW52UGF0aDogY29uZmlnLnJlbGF0aXZlRW52UGF0aHMucm9vdEVudlBhdGggJiYgcGF0aC5yZXNvbHZlKGRpcm5hbWUsIGNvbmZpZy5yZWxhdGl2ZUVudlBhdGhzLnJvb3RFbnZQYXRoKSxcbiAgICBzY2hlbWFFbnZQYXRoOiBjb25maWcucmVsYXRpdmVFbnZQYXRocy5zY2hlbWFFbnZQYXRoICYmIHBhdGgucmVzb2x2ZShkaXJuYW1lLCBjb25maWcucmVsYXRpdmVFbnZQYXRocy5zY2hlbWFFbnZQYXRoKVxufSlcblxuY29uc3QgUHJpc21hQ2xpZW50ID0gZ2V0UHJpc21hQ2xpZW50KGNvbmZpZylcbmV4cG9ydHMuUHJpc21hQ2xpZW50ID0gUHJpc21hQ2xpZW50XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIFByaXNtYSlcblxucGF0aC5qb2luKF9fZGlybmFtZSwgXCJsaWJxdWVyeV9lbmdpbmUtZGFyd2luLWFybTY0LmR5bGliLm5vZGVcIik7XG5wYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgXCJub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvbGlicXVlcnlfZW5naW5lLWRhcndpbi1hcm02NC5keWxpYi5ub2RlXCIpXG5wYXRoLmpvaW4oX19kaXJuYW1lLCBcInNjaGVtYS5wcmlzbWFcIik7XG5wYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgXCJub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvc2NoZW1hLnByaXNtYVwiKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.prisma/client/index.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@prisma/client/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n  ...__webpack_require__(/*! .prisma/client/index */ \"./node_modules/.prisma/client/index.js\"),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxLQUFLLG1CQUFPLENBQUMsb0VBQXNCO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRlbWNhdGFsb2d1ZS8uL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9pbmRleC5qcz8zMWI1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAuLi5yZXF1aXJlKCcucHJpc21hL2NsaWVudC9pbmRleCcpLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/index.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/runtime/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// ../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js\nvar require_lz_string = __commonJS({\n  \"../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js\"(exports, module2) {\n    var LZString = function() {\n      var f = String.fromCharCode;\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n      var baseReverseDic = {};\n      function getBaseValue(alphabet, character) {\n        if (!baseReverseDic[alphabet]) {\n          baseReverseDic[alphabet] = {};\n          for (var i = 0; i < alphabet.length; i++) {\n            baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n          }\n        }\n        return baseReverseDic[alphabet][character];\n      }\n      __name(getBaseValue, \"getBaseValue\");\n      var LZString2 = {\n        compressToBase64: function(input) {\n          if (input == null)\n            return \"\";\n          var res = LZString2._compress(input, 6, function(a) {\n            return keyStrBase64.charAt(a);\n          });\n          switch (res.length % 4) {\n            default:\n            case 0:\n              return res;\n            case 1:\n              return res + \"===\";\n            case 2:\n              return res + \"==\";\n            case 3:\n              return res + \"=\";\n          }\n        },\n        decompressFromBase64: function(input) {\n          if (input == null)\n            return \"\";\n          if (input == \"\")\n            return null;\n          return LZString2._decompress(input.length, 32, function(index) {\n            return getBaseValue(keyStrBase64, input.charAt(index));\n          });\n        },\n        compressToUTF16: function(input) {\n          if (input == null)\n            return \"\";\n          return LZString2._compress(input, 15, function(a) {\n            return f(a + 32);\n          }) + \" \";\n        },\n        decompressFromUTF16: function(compressed) {\n          if (compressed == null)\n            return \"\";\n          if (compressed == \"\")\n            return null;\n          return LZString2._decompress(compressed.length, 16384, function(index) {\n            return compressed.charCodeAt(index) - 32;\n          });\n        },\n        compressToUint8Array: function(uncompressed) {\n          var compressed = LZString2.compress(uncompressed);\n          var buf = new Uint8Array(compressed.length * 2);\n          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {\n            var current_value = compressed.charCodeAt(i);\n            buf[i * 2] = current_value >>> 8;\n            buf[i * 2 + 1] = current_value % 256;\n          }\n          return buf;\n        },\n        decompressFromUint8Array: function(compressed) {\n          if (compressed === null || compressed === void 0) {\n            return LZString2.decompress(compressed);\n          } else {\n            var buf = new Array(compressed.length / 2);\n            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {\n              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];\n            }\n            var result = [];\n            buf.forEach(function(c) {\n              result.push(f(c));\n            });\n            return LZString2.decompress(result.join(\"\"));\n          }\n        },\n        compressToEncodedURIComponent: function(input) {\n          if (input == null)\n            return \"\";\n          return LZString2._compress(input, 6, function(a) {\n            return keyStrUriSafe.charAt(a);\n          });\n        },\n        decompressFromEncodedURIComponent: function(input) {\n          if (input == null)\n            return \"\";\n          if (input == \"\")\n            return null;\n          input = input.replace(/ /g, \"+\");\n          return LZString2._decompress(input.length, 32, function(index) {\n            return getBaseValue(keyStrUriSafe, input.charAt(index));\n          });\n        },\n        compress: function(uncompressed) {\n          return LZString2._compress(uncompressed, 16, function(a) {\n            return f(a);\n          });\n        },\n        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {\n          if (uncompressed == null)\n            return \"\";\n          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = \"\", context_wc = \"\", context_w = \"\", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;\n          for (ii = 0; ii < uncompressed.length; ii += 1) {\n            context_c = uncompressed.charAt(ii);\n            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {\n              context_dictionary[context_c] = context_dictSize++;\n              context_dictionaryToCreate[context_c] = true;\n            }\n            context_wc = context_w + context_c;\n            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {\n              context_w = context_wc;\n            } else {\n              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n                if (context_w.charCodeAt(0) < 256) {\n                  for (i = 0; i < context_numBits; i++) {\n                    context_data_val = context_data_val << 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                  }\n                  value = context_w.charCodeAt(0);\n                  for (i = 0; i < 8; i++) {\n                    context_data_val = context_data_val << 1 | value & 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = value >> 1;\n                  }\n                } else {\n                  value = 1;\n                  for (i = 0; i < context_numBits; i++) {\n                    context_data_val = context_data_val << 1 | value;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = 0;\n                  }\n                  value = context_w.charCodeAt(0);\n                  for (i = 0; i < 16; i++) {\n                    context_data_val = context_data_val << 1 | value & 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = value >> 1;\n                  }\n                }\n                context_enlargeIn--;\n                if (context_enlargeIn == 0) {\n                  context_enlargeIn = Math.pow(2, context_numBits);\n                  context_numBits++;\n                }\n                delete context_dictionaryToCreate[context_w];\n              } else {\n                value = context_dictionary[context_w];\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              }\n              context_enlargeIn--;\n              if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n              }\n              context_dictionary[context_wc] = context_dictSize++;\n              context_w = String(context_c);\n            }\n          }\n          if (context_w !== \"\") {\n            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n              if (context_w.charCodeAt(0) < 256) {\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 8; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              } else {\n                value = 1;\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1 | value;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = 0;\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 16; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              }\n              context_enlargeIn--;\n              if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n              }\n              delete context_dictionaryToCreate[context_w];\n            } else {\n              value = context_dictionary[context_w];\n              for (i = 0; i < context_numBits; i++) {\n                context_data_val = context_data_val << 1 | value & 1;\n                if (context_data_position == bitsPerChar - 1) {\n                  context_data_position = 0;\n                  context_data.push(getCharFromInt(context_data_val));\n                  context_data_val = 0;\n                } else {\n                  context_data_position++;\n                }\n                value = value >> 1;\n              }\n            }\n            context_enlargeIn--;\n            if (context_enlargeIn == 0) {\n              context_enlargeIn = Math.pow(2, context_numBits);\n              context_numBits++;\n            }\n          }\n          value = 2;\n          for (i = 0; i < context_numBits; i++) {\n            context_data_val = context_data_val << 1 | value & 1;\n            if (context_data_position == bitsPerChar - 1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n          while (true) {\n            context_data_val = context_data_val << 1;\n            if (context_data_position == bitsPerChar - 1) {\n              context_data.push(getCharFromInt(context_data_val));\n              break;\n            } else\n              context_data_position++;\n          }\n          return context_data.join(\"\");\n        },\n        decompress: function(compressed) {\n          if (compressed == null)\n            return \"\";\n          if (compressed == \"\")\n            return null;\n          return LZString2._decompress(compressed.length, 32768, function(index) {\n            return compressed.charCodeAt(index);\n          });\n        },\n        _decompress: function(length, resetValue, getNextValue) {\n          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = \"\", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };\n          for (i = 0; i < 3; i += 1) {\n            dictionary[i] = i;\n          }\n          bits = 0;\n          maxpower = Math.pow(2, 2);\n          power = 1;\n          while (power != maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb > 0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          switch (next = bits) {\n            case 0:\n              bits = 0;\n              maxpower = Math.pow(2, 8);\n              power = 1;\n              while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                  data.position = resetValue;\n                  data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n              }\n              c = f(bits);\n              break;\n            case 1:\n              bits = 0;\n              maxpower = Math.pow(2, 16);\n              power = 1;\n              while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                  data.position = resetValue;\n                  data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n              }\n              c = f(bits);\n              break;\n            case 2:\n              return \"\";\n          }\n          dictionary[3] = c;\n          w = c;\n          result.push(c);\n          while (true) {\n            if (data.index > length) {\n              return \"\";\n            }\n            bits = 0;\n            maxpower = Math.pow(2, numBits);\n            power = 1;\n            while (power != maxpower) {\n              resb = data.val & data.position;\n              data.position >>= 1;\n              if (data.position == 0) {\n                data.position = resetValue;\n                data.val = getNextValue(data.index++);\n              }\n              bits |= (resb > 0 ? 1 : 0) * power;\n              power <<= 1;\n            }\n            switch (c = bits) {\n              case 0:\n                bits = 0;\n                maxpower = Math.pow(2, 8);\n                power = 1;\n                while (power != maxpower) {\n                  resb = data.val & data.position;\n                  data.position >>= 1;\n                  if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                  }\n                  bits |= (resb > 0 ? 1 : 0) * power;\n                  power <<= 1;\n                }\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n              case 1:\n                bits = 0;\n                maxpower = Math.pow(2, 16);\n                power = 1;\n                while (power != maxpower) {\n                  resb = data.val & data.position;\n                  data.position >>= 1;\n                  if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                  }\n                  bits |= (resb > 0 ? 1 : 0) * power;\n                  power <<= 1;\n                }\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n              case 2:\n                return result.join(\"\");\n            }\n            if (enlargeIn == 0) {\n              enlargeIn = Math.pow(2, numBits);\n              numBits++;\n            }\n            if (dictionary[c]) {\n              entry = dictionary[c];\n            } else {\n              if (c === dictSize) {\n                entry = w + w.charAt(0);\n              } else {\n                return null;\n              }\n            }\n            result.push(entry);\n            dictionary[dictSize++] = w + entry.charAt(0);\n            enlargeIn--;\n            w = entry;\n            if (enlargeIn == 0) {\n              enlargeIn = Math.pow(2, numBits);\n              numBits++;\n            }\n          }\n        }\n      };\n      return LZString2;\n    }();\n    if (false) {} else if (typeof module2 !== \"undefined\" && module2 != null) {\n      module2.exports = LZString;\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js\nvar require_color_name = __commonJS({\n  \"../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      \"aliceblue\": [240, 248, 255],\n      \"antiquewhite\": [250, 235, 215],\n      \"aqua\": [0, 255, 255],\n      \"aquamarine\": [127, 255, 212],\n      \"azure\": [240, 255, 255],\n      \"beige\": [245, 245, 220],\n      \"bisque\": [255, 228, 196],\n      \"black\": [0, 0, 0],\n      \"blanchedalmond\": [255, 235, 205],\n      \"blue\": [0, 0, 255],\n      \"blueviolet\": [138, 43, 226],\n      \"brown\": [165, 42, 42],\n      \"burlywood\": [222, 184, 135],\n      \"cadetblue\": [95, 158, 160],\n      \"chartreuse\": [127, 255, 0],\n      \"chocolate\": [210, 105, 30],\n      \"coral\": [255, 127, 80],\n      \"cornflowerblue\": [100, 149, 237],\n      \"cornsilk\": [255, 248, 220],\n      \"crimson\": [220, 20, 60],\n      \"cyan\": [0, 255, 255],\n      \"darkblue\": [0, 0, 139],\n      \"darkcyan\": [0, 139, 139],\n      \"darkgoldenrod\": [184, 134, 11],\n      \"darkgray\": [169, 169, 169],\n      \"darkgreen\": [0, 100, 0],\n      \"darkgrey\": [169, 169, 169],\n      \"darkkhaki\": [189, 183, 107],\n      \"darkmagenta\": [139, 0, 139],\n      \"darkolivegreen\": [85, 107, 47],\n      \"darkorange\": [255, 140, 0],\n      \"darkorchid\": [153, 50, 204],\n      \"darkred\": [139, 0, 0],\n      \"darksalmon\": [233, 150, 122],\n      \"darkseagreen\": [143, 188, 143],\n      \"darkslateblue\": [72, 61, 139],\n      \"darkslategray\": [47, 79, 79],\n      \"darkslategrey\": [47, 79, 79],\n      \"darkturquoise\": [0, 206, 209],\n      \"darkviolet\": [148, 0, 211],\n      \"deeppink\": [255, 20, 147],\n      \"deepskyblue\": [0, 191, 255],\n      \"dimgray\": [105, 105, 105],\n      \"dimgrey\": [105, 105, 105],\n      \"dodgerblue\": [30, 144, 255],\n      \"firebrick\": [178, 34, 34],\n      \"floralwhite\": [255, 250, 240],\n      \"forestgreen\": [34, 139, 34],\n      \"fuchsia\": [255, 0, 255],\n      \"gainsboro\": [220, 220, 220],\n      \"ghostwhite\": [248, 248, 255],\n      \"gold\": [255, 215, 0],\n      \"goldenrod\": [218, 165, 32],\n      \"gray\": [128, 128, 128],\n      \"green\": [0, 128, 0],\n      \"greenyellow\": [173, 255, 47],\n      \"grey\": [128, 128, 128],\n      \"honeydew\": [240, 255, 240],\n      \"hotpink\": [255, 105, 180],\n      \"indianred\": [205, 92, 92],\n      \"indigo\": [75, 0, 130],\n      \"ivory\": [255, 255, 240],\n      \"khaki\": [240, 230, 140],\n      \"lavender\": [230, 230, 250],\n      \"lavenderblush\": [255, 240, 245],\n      \"lawngreen\": [124, 252, 0],\n      \"lemonchiffon\": [255, 250, 205],\n      \"lightblue\": [173, 216, 230],\n      \"lightcoral\": [240, 128, 128],\n      \"lightcyan\": [224, 255, 255],\n      \"lightgoldenrodyellow\": [250, 250, 210],\n      \"lightgray\": [211, 211, 211],\n      \"lightgreen\": [144, 238, 144],\n      \"lightgrey\": [211, 211, 211],\n      \"lightpink\": [255, 182, 193],\n      \"lightsalmon\": [255, 160, 122],\n      \"lightseagreen\": [32, 178, 170],\n      \"lightskyblue\": [135, 206, 250],\n      \"lightslategray\": [119, 136, 153],\n      \"lightslategrey\": [119, 136, 153],\n      \"lightsteelblue\": [176, 196, 222],\n      \"lightyellow\": [255, 255, 224],\n      \"lime\": [0, 255, 0],\n      \"limegreen\": [50, 205, 50],\n      \"linen\": [250, 240, 230],\n      \"magenta\": [255, 0, 255],\n      \"maroon\": [128, 0, 0],\n      \"mediumaquamarine\": [102, 205, 170],\n      \"mediumblue\": [0, 0, 205],\n      \"mediumorchid\": [186, 85, 211],\n      \"mediumpurple\": [147, 112, 219],\n      \"mediumseagreen\": [60, 179, 113],\n      \"mediumslateblue\": [123, 104, 238],\n      \"mediumspringgreen\": [0, 250, 154],\n      \"mediumturquoise\": [72, 209, 204],\n      \"mediumvioletred\": [199, 21, 133],\n      \"midnightblue\": [25, 25, 112],\n      \"mintcream\": [245, 255, 250],\n      \"mistyrose\": [255, 228, 225],\n      \"moccasin\": [255, 228, 181],\n      \"navajowhite\": [255, 222, 173],\n      \"navy\": [0, 0, 128],\n      \"oldlace\": [253, 245, 230],\n      \"olive\": [128, 128, 0],\n      \"olivedrab\": [107, 142, 35],\n      \"orange\": [255, 165, 0],\n      \"orangered\": [255, 69, 0],\n      \"orchid\": [218, 112, 214],\n      \"palegoldenrod\": [238, 232, 170],\n      \"palegreen\": [152, 251, 152],\n      \"paleturquoise\": [175, 238, 238],\n      \"palevioletred\": [219, 112, 147],\n      \"papayawhip\": [255, 239, 213],\n      \"peachpuff\": [255, 218, 185],\n      \"peru\": [205, 133, 63],\n      \"pink\": [255, 192, 203],\n      \"plum\": [221, 160, 221],\n      \"powderblue\": [176, 224, 230],\n      \"purple\": [128, 0, 128],\n      \"rebeccapurple\": [102, 51, 153],\n      \"red\": [255, 0, 0],\n      \"rosybrown\": [188, 143, 143],\n      \"royalblue\": [65, 105, 225],\n      \"saddlebrown\": [139, 69, 19],\n      \"salmon\": [250, 128, 114],\n      \"sandybrown\": [244, 164, 96],\n      \"seagreen\": [46, 139, 87],\n      \"seashell\": [255, 245, 238],\n      \"sienna\": [160, 82, 45],\n      \"silver\": [192, 192, 192],\n      \"skyblue\": [135, 206, 235],\n      \"slateblue\": [106, 90, 205],\n      \"slategray\": [112, 128, 144],\n      \"slategrey\": [112, 128, 144],\n      \"snow\": [255, 250, 250],\n      \"springgreen\": [0, 255, 127],\n      \"steelblue\": [70, 130, 180],\n      \"tan\": [210, 180, 140],\n      \"teal\": [0, 128, 128],\n      \"thistle\": [216, 191, 216],\n      \"tomato\": [255, 99, 71],\n      \"turquoise\": [64, 224, 208],\n      \"violet\": [238, 130, 238],\n      \"wheat\": [245, 222, 179],\n      \"white\": [255, 255, 255],\n      \"whitesmoke\": [245, 245, 245],\n      \"yellow\": [255, 255, 0],\n      \"yellowgreen\": [154, 205, 50]\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js\nvar require_conversions = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js\"(exports, module2) {\n    var cssKeywords = require_color_name();\n    var reverseKeywords = {};\n    for (const key of Object.keys(cssKeywords)) {\n      reverseKeywords[cssKeywords[key]] = key;\n    }\n    var convert = {\n      rgb: { channels: 3, labels: \"rgb\" },\n      hsl: { channels: 3, labels: \"hsl\" },\n      hsv: { channels: 3, labels: \"hsv\" },\n      hwb: { channels: 3, labels: \"hwb\" },\n      cmyk: { channels: 4, labels: \"cmyk\" },\n      xyz: { channels: 3, labels: \"xyz\" },\n      lab: { channels: 3, labels: \"lab\" },\n      lch: { channels: 3, labels: \"lch\" },\n      hex: { channels: 1, labels: [\"hex\"] },\n      keyword: { channels: 1, labels: [\"keyword\"] },\n      ansi16: { channels: 1, labels: [\"ansi16\"] },\n      ansi256: { channels: 1, labels: [\"ansi256\"] },\n      hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n      apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n      gray: { channels: 1, labels: [\"gray\"] }\n    };\n    module2.exports = convert;\n    for (const model of Object.keys(convert)) {\n      if (!(\"channels\" in convert[model])) {\n        throw new Error(\"missing channels property: \" + model);\n      }\n      if (!(\"labels\" in convert[model])) {\n        throw new Error(\"missing channel labels property: \" + model);\n      }\n      if (convert[model].labels.length !== convert[model].channels) {\n        throw new Error(\"channel and label counts mismatch: \" + model);\n      }\n      const { channels, labels } = convert[model];\n      delete convert[model].channels;\n      delete convert[model].labels;\n      Object.defineProperty(convert[model], \"channels\", { value: channels });\n      Object.defineProperty(convert[model], \"labels\", { value: labels });\n    }\n    convert.rgb.hsl = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const min2 = Math.min(r, g, b);\n      const max2 = Math.max(r, g, b);\n      const delta = max2 - min2;\n      let h;\n      let s;\n      if (max2 === min2) {\n        h = 0;\n      } else if (r === max2) {\n        h = (g - b) / delta;\n      } else if (g === max2) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max2) {\n        h = 4 + (r - g) / delta;\n      }\n      h = Math.min(h * 60, 360);\n      if (h < 0) {\n        h += 360;\n      }\n      const l = (min2 + max2) / 2;\n      if (max2 === min2) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max2 + min2);\n      } else {\n        s = delta / (2 - max2 - min2);\n      }\n      return [h, s * 100, l * 100];\n    };\n    convert.rgb.hsv = function(rgb) {\n      let rdif;\n      let gdif;\n      let bdif;\n      let h;\n      let s;\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const v = Math.max(r, g, b);\n      const diff = v - Math.min(r, g, b);\n      const diffc = /* @__PURE__ */ __name(function(c) {\n        return (v - c) / 6 / diff + 1 / 2;\n      }, \"diffc\");\n      if (diff === 0) {\n        h = 0;\n        s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n      return [\n        h * 360,\n        s * 100,\n        v * 100\n      ];\n    };\n    convert.rgb.hwb = function(rgb) {\n      const r = rgb[0];\n      const g = rgb[1];\n      let b = rgb[2];\n      const h = convert.rgb.hsl(rgb)[0];\n      const w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n    convert.rgb.cmyk = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const k = Math.min(1 - r, 1 - g, 1 - b);\n      const c = (1 - r - k) / (1 - k) || 0;\n      const m = (1 - g - k) / (1 - k) || 0;\n      const y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    function comparativeDistance(x, y) {\n      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;\n    }\n    __name(comparativeDistance, \"comparativeDistance\");\n    convert.rgb.keyword = function(rgb) {\n      const reversed = reverseKeywords[rgb];\n      if (reversed) {\n        return reversed;\n      }\n      let currentClosestDistance = Infinity;\n      let currentClosestKeyword;\n      for (const keyword of Object.keys(cssKeywords)) {\n        const value = cssKeywords[keyword];\n        const distance = comparativeDistance(rgb, value);\n        if (distance < currentClosestDistance) {\n          currentClosestDistance = distance;\n          currentClosestKeyword = keyword;\n        }\n      }\n      return currentClosestKeyword;\n    };\n    convert.keyword.rgb = function(keyword) {\n      return cssKeywords[keyword];\n    };\n    convert.rgb.xyz = function(rgb) {\n      let r = rgb[0] / 255;\n      let g = rgb[1] / 255;\n      let b = rgb[2] / 255;\n      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;\n      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;\n      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;\n      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n    convert.rgb.lab = function(rgb) {\n      const xyz = convert.rgb.xyz(rgb);\n      let x = xyz[0];\n      let y = xyz[1];\n      let z = xyz[2];\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n      const l = 116 * y - 16;\n      const a = 500 * (x - y);\n      const b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.hsl.rgb = function(hsl) {\n      const h = hsl[0] / 360;\n      const s = hsl[1] / 100;\n      const l = hsl[2] / 100;\n      let t2;\n      let t3;\n      let val;\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n      const t1 = 2 * l - t2;\n      const rgb = [0, 0, 0];\n      for (let i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n        if (t3 < 0) {\n          t3++;\n        }\n        if (t3 > 1) {\n          t3--;\n        }\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n        rgb[i] = val * 255;\n      }\n      return rgb;\n    };\n    convert.hsl.hsv = function(hsl) {\n      const h = hsl[0];\n      let s = hsl[1] / 100;\n      let l = hsl[2] / 100;\n      let smin = s;\n      const lmin = Math.max(l, 0.01);\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      const v = (l + s) / 2;\n      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n    convert.hsv.rgb = function(hsv) {\n      const h = hsv[0] / 60;\n      const s = hsv[1] / 100;\n      let v = hsv[2] / 100;\n      const hi = Math.floor(h) % 6;\n      const f = h - Math.floor(h);\n      const p = 255 * v * (1 - s);\n      const q = 255 * v * (1 - s * f);\n      const t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n        case 1:\n          return [q, v, p];\n        case 2:\n          return [p, v, t];\n        case 3:\n          return [p, q, v];\n        case 4:\n          return [t, p, v];\n        case 5:\n          return [v, p, q];\n      }\n    };\n    convert.hsv.hsl = function(hsv) {\n      const h = hsv[0];\n      const s = hsv[1] / 100;\n      const v = hsv[2] / 100;\n      const vmin = Math.max(v, 0.01);\n      let sl;\n      let l;\n      l = (2 - s) * v;\n      const lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    };\n    convert.hwb.rgb = function(hwb) {\n      const h = hwb[0] / 360;\n      let wh = hwb[1] / 100;\n      let bl = hwb[2] / 100;\n      const ratio = wh + bl;\n      let f;\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n      const i = Math.floor(6 * h);\n      const v = 1 - bl;\n      f = 6 * h - i;\n      if ((i & 1) !== 0) {\n        f = 1 - f;\n      }\n      const n = wh + f * (v - wh);\n      let r;\n      let g;\n      let b;\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.cmyk.rgb = function(cmyk) {\n      const c = cmyk[0] / 100;\n      const m = cmyk[1] / 100;\n      const y = cmyk[2] / 100;\n      const k = cmyk[3] / 100;\n      const r = 1 - Math.min(1, c * (1 - k) + k);\n      const g = 1 - Math.min(1, m * (1 - k) + k);\n      const b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.rgb = function(xyz) {\n      const x = xyz[0] / 100;\n      const y = xyz[1] / 100;\n      const z = xyz[2] / 100;\n      let r;\n      let g;\n      let b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.204 + z * 1.057;\n      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;\n      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;\n      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.lab = function(xyz) {\n      let x = xyz[0];\n      let y = xyz[1];\n      let z = xyz[2];\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n      const l = 116 * y - 16;\n      const a = 500 * (x - y);\n      const b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.lab.xyz = function(lab) {\n      const l = lab[0];\n      const a = lab[1];\n      const b = lab[2];\n      let x;\n      let y;\n      let z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      const y2 = y ** 3;\n      const x2 = x ** 3;\n      const z2 = z ** 3;\n      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n    convert.lab.lch = function(lab) {\n      const l = lab[0];\n      const a = lab[1];\n      const b = lab[2];\n      let h;\n      const hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n      if (h < 0) {\n        h += 360;\n      }\n      const c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n    convert.lch.lab = function(lch) {\n      const l = lch[0];\n      const c = lch[1];\n      const h = lch[2];\n      const hr = h / 360 * 2 * Math.PI;\n      const a = c * Math.cos(hr);\n      const b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n    convert.rgb.ansi16 = function(args, saturation = null) {\n      const [r, g, b] = args;\n      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;\n      value = Math.round(value / 50);\n      if (value === 0) {\n        return 30;\n      }\n      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n      if (value === 2) {\n        ansi += 60;\n      }\n      return ansi;\n    };\n    convert.hsv.ansi16 = function(args) {\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n    convert.rgb.ansi256 = function(args) {\n      const r = args[0];\n      const g = args[1];\n      const b = args[2];\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n        if (r > 248) {\n          return 231;\n        }\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n    convert.ansi16.rgb = function(args) {\n      let color = args % 10;\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n      const mult = (~~(args > 50) + 1) * 0.5;\n      const r = (color & 1) * mult * 255;\n      const g = (color >> 1 & 1) * mult * 255;\n      const b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n    convert.ansi256.rgb = function(args) {\n      if (args >= 232) {\n        const c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n      args -= 16;\n      let rem;\n      const r = Math.floor(args / 36) / 5 * 255;\n      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      const b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n    convert.rgb.hex = function(args) {\n      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);\n      const string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.hex.rgb = function(args) {\n      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n      if (!match) {\n        return [0, 0, 0];\n      }\n      let colorString = match[0];\n      if (match[0].length === 3) {\n        colorString = colorString.split(\"\").map((char) => {\n          return char + char;\n        }).join(\"\");\n      }\n      const integer = parseInt(colorString, 16);\n      const r = integer >> 16 & 255;\n      const g = integer >> 8 & 255;\n      const b = integer & 255;\n      return [r, g, b];\n    };\n    convert.rgb.hcg = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const max2 = Math.max(Math.max(r, g), b);\n      const min2 = Math.min(Math.min(r, g), b);\n      const chroma = max2 - min2;\n      let grayscale;\n      let hue;\n      if (chroma < 1) {\n        grayscale = min2 / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max2 === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max2 === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma;\n      }\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n    convert.hsl.hcg = function(hsl) {\n      const s = hsl[1] / 100;\n      const l = hsl[2] / 100;\n      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);\n      let f = 0;\n      if (c < 1) {\n        f = (l - 0.5 * c) / (1 - c);\n      }\n      return [hsl[0], c * 100, f * 100];\n    };\n    convert.hsv.hcg = function(hsv) {\n      const s = hsv[1] / 100;\n      const v = hsv[2] / 100;\n      const c = s * v;\n      let f = 0;\n      if (c < 1) {\n        f = (v - c) / (1 - c);\n      }\n      return [hsv[0], c * 100, f * 100];\n    };\n    convert.hcg.rgb = function(hcg) {\n      const h = hcg[0] / 360;\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      if (c === 0) {\n        return [g * 255, g * 255, g * 255];\n      }\n      const pure = [0, 0, 0];\n      const hi = h % 1 * 6;\n      const v = hi % 1;\n      const w = 1 - v;\n      let mg = 0;\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n      mg = (1 - c) * g;\n      return [\n        (c * pure[0] + mg) * 255,\n        (c * pure[1] + mg) * 255,\n        (c * pure[2] + mg) * 255\n      ];\n    };\n    convert.hcg.hsv = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const v = c + g * (1 - c);\n      let f = 0;\n      if (v > 0) {\n        f = c / v;\n      }\n      return [hcg[0], f * 100, v * 100];\n    };\n    convert.hcg.hsl = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const l = g * (1 - c) + 0.5 * c;\n      let s = 0;\n      if (l > 0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1) {\n        s = c / (2 * (1 - l));\n      }\n      return [hcg[0], s * 100, l * 100];\n    };\n    convert.hcg.hwb = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const v = c + g * (1 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n    convert.hwb.hcg = function(hwb) {\n      const w = hwb[1] / 100;\n      const b = hwb[2] / 100;\n      const v = 1 - b;\n      const c = v - w;\n      let g = 0;\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n      return [hwb[0], c * 100, g * 100];\n    };\n    convert.apple.rgb = function(apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n    convert.rgb.apple = function(rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n    convert.gray.rgb = function(args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n    convert.gray.hsl = function(args) {\n      return [0, 0, args[0]];\n    };\n    convert.gray.hsv = convert.gray.hsl;\n    convert.gray.hwb = function(gray) {\n      return [0, 100, gray[0]];\n    };\n    convert.gray.cmyk = function(gray) {\n      return [0, 0, 0, gray[0]];\n    };\n    convert.gray.lab = function(gray) {\n      return [gray[0], 0, 0];\n    };\n    convert.gray.hex = function(gray) {\n      const val = Math.round(gray[0] / 100 * 255) & 255;\n      const integer = (val << 16) + (val << 8) + val;\n      const string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.rgb.gray = function(rgb) {\n      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js\nvar require_route = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js\"(exports, module2) {\n    var conversions = require_conversions();\n    function buildGraph() {\n      const graph = {};\n      const models = Object.keys(conversions);\n      for (let len = models.length, i = 0; i < len; i++) {\n        graph[models[i]] = {\n          distance: -1,\n          parent: null\n        };\n      }\n      return graph;\n    }\n    __name(buildGraph, \"buildGraph\");\n    function deriveBFS(fromModel) {\n      const graph = buildGraph();\n      const queue = [fromModel];\n      graph[fromModel].distance = 0;\n      while (queue.length) {\n        const current = queue.pop();\n        const adjacents = Object.keys(conversions[current]);\n        for (let len = adjacents.length, i = 0; i < len; i++) {\n          const adjacent = adjacents[i];\n          const node = graph[adjacent];\n          if (node.distance === -1) {\n            node.distance = graph[current].distance + 1;\n            node.parent = current;\n            queue.unshift(adjacent);\n          }\n        }\n      }\n      return graph;\n    }\n    __name(deriveBFS, \"deriveBFS\");\n    function link(from, to) {\n      return function(args) {\n        return to(from(args));\n      };\n    }\n    __name(link, \"link\");\n    function wrapConversion(toModel, graph) {\n      const path7 = [graph[toModel].parent, toModel];\n      let fn = conversions[graph[toModel].parent][toModel];\n      let cur = graph[toModel].parent;\n      while (graph[cur].parent) {\n        path7.unshift(graph[cur].parent);\n        fn = link(conversions[graph[cur].parent][cur], fn);\n        cur = graph[cur].parent;\n      }\n      fn.conversion = path7;\n      return fn;\n    }\n    __name(wrapConversion, \"wrapConversion\");\n    module2.exports = function(fromModel) {\n      const graph = deriveBFS(fromModel);\n      const conversion = {};\n      const models = Object.keys(graph);\n      for (let len = models.length, i = 0; i < len; i++) {\n        const toModel = models[i];\n        const node = graph[toModel];\n        if (node.parent === null) {\n          continue;\n        }\n        conversion[toModel] = wrapConversion(toModel, graph);\n      }\n      return conversion;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js\nvar require_color_convert = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js\"(exports, module2) {\n    var conversions = require_conversions();\n    var route = require_route();\n    var convert = {};\n    var models = Object.keys(conversions);\n    function wrapRaw(fn) {\n      const wrappedFn = /* @__PURE__ */ __name(function(...args) {\n        const arg0 = args[0];\n        if (arg0 === void 0 || arg0 === null) {\n          return arg0;\n        }\n        if (arg0.length > 1) {\n          args = arg0;\n        }\n        return fn(args);\n      }, \"wrappedFn\");\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    __name(wrapRaw, \"wrapRaw\");\n    function wrapRounded(fn) {\n      const wrappedFn = /* @__PURE__ */ __name(function(...args) {\n        const arg0 = args[0];\n        if (arg0 === void 0 || arg0 === null) {\n          return arg0;\n        }\n        if (arg0.length > 1) {\n          args = arg0;\n        }\n        const result = fn(args);\n        if (typeof result === \"object\") {\n          for (let len = result.length, i = 0; i < len; i++) {\n            result[i] = Math.round(result[i]);\n          }\n        }\n        return result;\n      }, \"wrappedFn\");\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    __name(wrapRounded, \"wrapRounded\");\n    models.forEach((fromModel) => {\n      convert[fromModel] = {};\n      Object.defineProperty(convert[fromModel], \"channels\", { value: conversions[fromModel].channels });\n      Object.defineProperty(convert[fromModel], \"labels\", { value: conversions[fromModel].labels });\n      const routes = route(fromModel);\n      const routeModels = Object.keys(routes);\n      routeModels.forEach((toModel) => {\n        const fn = routes[toModel];\n        convert[fromModel][toModel] = wrapRounded(fn);\n        convert[fromModel][toModel].raw = wrapRaw(fn);\n      });\n    });\n    module2.exports = convert;\n  }\n});\n\n// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js\nvar require_ansi_styles = __commonJS({\n  \"../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js\"(exports, module2) {\n    \"use strict\";\n    var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const code = fn(...args);\n      return `\\x1B[${code + offset}m`;\n    }, \"wrapAnsi16\");\n    var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const code = fn(...args);\n      return `\\x1B[${38 + offset};5;${code}m`;\n    }, \"wrapAnsi256\");\n    var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const rgb = fn(...args);\n      return `\\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n    }, \"wrapAnsi16m\");\n    var ansi2ansi = /* @__PURE__ */ __name((n) => n, \"ansi2ansi\");\n    var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], \"rgb2rgb\");\n    var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {\n      Object.defineProperty(object, property, {\n        get: () => {\n          const value = get();\n          Object.defineProperty(object, property, {\n            value,\n            enumerable: true,\n            configurable: true\n          });\n          return value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }, \"setLazyProperty\");\n    var colorConvert;\n    var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {\n      if (colorConvert === void 0) {\n        colorConvert = require_color_convert();\n      }\n      const offset = isBackground ? 10 : 0;\n      const styles = {};\n      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n        const name = sourceSpace === \"ansi16\" ? \"ansi\" : sourceSpace;\n        if (sourceSpace === targetSpace) {\n          styles[name] = wrap(identity2, offset);\n        } else if (typeof suite === \"object\") {\n          styles[name] = wrap(suite[targetSpace], offset);\n        }\n      }\n      return styles;\n    }, \"makeDynamicStyles\");\n    function assembleStyles() {\n      const codes = /* @__PURE__ */ new Map();\n      const styles = {\n        modifier: {\n          reset: [0, 0],\n          bold: [1, 22],\n          dim: [2, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          hidden: [8, 28],\n          strikethrough: [9, 29]\n        },\n        color: {\n          black: [30, 39],\n          red: [31, 39],\n          green: [32, 39],\n          yellow: [33, 39],\n          blue: [34, 39],\n          magenta: [35, 39],\n          cyan: [36, 39],\n          white: [37, 39],\n          blackBright: [90, 39],\n          redBright: [91, 39],\n          greenBright: [92, 39],\n          yellowBright: [93, 39],\n          blueBright: [94, 39],\n          magentaBright: [95, 39],\n          cyanBright: [96, 39],\n          whiteBright: [97, 39]\n        },\n        bgColor: {\n          bgBlack: [40, 49],\n          bgRed: [41, 49],\n          bgGreen: [42, 49],\n          bgYellow: [43, 49],\n          bgBlue: [44, 49],\n          bgMagenta: [45, 49],\n          bgCyan: [46, 49],\n          bgWhite: [47, 49],\n          bgBlackBright: [100, 49],\n          bgRedBright: [101, 49],\n          bgGreenBright: [102, 49],\n          bgYellowBright: [103, 49],\n          bgBlueBright: [104, 49],\n          bgMagentaBright: [105, 49],\n          bgCyanBright: [106, 49],\n          bgWhiteBright: [107, 49]\n        }\n      };\n      styles.color.gray = styles.color.blackBright;\n      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n      styles.color.grey = styles.color.blackBright;\n      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n      for (const [groupName, group] of Object.entries(styles)) {\n        for (const [styleName, style] of Object.entries(group)) {\n          styles[styleName] = {\n            open: `\\x1B[${style[0]}m`,\n            close: `\\x1B[${style[1]}m`\n          };\n          group[styleName] = styles[styleName];\n          codes.set(style[0], style[1]);\n        }\n        Object.defineProperty(styles, groupName, {\n          value: group,\n          enumerable: false\n        });\n      }\n      Object.defineProperty(styles, \"codes\", {\n        value: codes,\n        enumerable: false\n      });\n      styles.color.close = \"\\x1B[39m\";\n      styles.bgColor.close = \"\\x1B[49m\";\n      setLazyProperty(styles.color, \"ansi\", () => makeDynamicStyles(wrapAnsi16, \"ansi16\", ansi2ansi, false));\n      setLazyProperty(styles.color, \"ansi256\", () => makeDynamicStyles(wrapAnsi256, \"ansi256\", ansi2ansi, false));\n      setLazyProperty(styles.color, \"ansi16m\", () => makeDynamicStyles(wrapAnsi16m, \"rgb\", rgb2rgb, false));\n      setLazyProperty(styles.bgColor, \"ansi\", () => makeDynamicStyles(wrapAnsi16, \"ansi16\", ansi2ansi, true));\n      setLazyProperty(styles.bgColor, \"ansi256\", () => makeDynamicStyles(wrapAnsi256, \"ansi256\", ansi2ansi, true));\n      setLazyProperty(styles.bgColor, \"ansi16m\", () => makeDynamicStyles(wrapAnsi16m, \"rgb\", rgb2rgb, true));\n      return styles;\n    }\n    __name(assembleStyles, \"assembleStyles\");\n    Object.defineProperty(module2, \"exports\", {\n      enumerable: true,\n      get: assembleStyles\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js\nvar require_has_flag = __commonJS({\n  \"../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (flag, argv = process.argv) => {\n      const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n      const position = argv.indexOf(prefix + flag);\n      const terminatorPosition = argv.indexOf(\"--\");\n      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js\nvar require_supports_color = __commonJS({\n  \"../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js\"(exports, module2) {\n    \"use strict\";\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var tty = __webpack_require__(/*! tty */ \"tty\");\n    var hasFlag = require_has_flag();\n    var { env: env2 } = process;\n    var forceColor;\n    if (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\") || hasFlag(\"color=never\")) {\n      forceColor = 0;\n    } else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {\n      forceColor = 1;\n    }\n    if (\"FORCE_COLOR\" in env2) {\n      if (env2.FORCE_COLOR === \"true\") {\n        forceColor = 1;\n      } else if (env2.FORCE_COLOR === \"false\") {\n        forceColor = 0;\n      } else {\n        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);\n      }\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    __name(translateLevel, \"translateLevel\");\n    function supportsColor(haveStream, streamIsTTY) {\n      if (forceColor === 0) {\n        return 0;\n      }\n      if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {\n        return 3;\n      }\n      if (hasFlag(\"color=256\")) {\n        return 2;\n      }\n      if (haveStream && !streamIsTTY && forceColor === void 0) {\n        return 0;\n      }\n      const min2 = forceColor || 0;\n      if (env2.TERM === \"dumb\") {\n        return min2;\n      }\n      if (process.platform === \"win32\") {\n        const osRelease = os3.release().split(\".\");\n        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if (\"CI\" in env2) {\n        if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\", \"BUILDKITE\"].some((sign2) => sign2 in env2) || env2.CI_NAME === \"codeship\") {\n          return 1;\n        }\n        return min2;\n      }\n      if (\"TEAMCITY_VERSION\" in env2) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env2.COLORTERM === \"truecolor\") {\n        return 3;\n      }\n      if (\"TERM_PROGRAM\" in env2) {\n        const version = parseInt((env2.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n        switch (env2.TERM_PROGRAM) {\n          case \"iTerm.app\":\n            return version >= 3 ? 3 : 2;\n          case \"Apple_Terminal\":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env2.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {\n        return 1;\n      }\n      if (\"COLORTERM\" in env2) {\n        return 1;\n      }\n      return min2;\n    }\n    __name(supportsColor, \"supportsColor\");\n    function getSupportLevel(stream2) {\n      const level = supportsColor(stream2, stream2 && stream2.isTTY);\n      return translateLevel(level);\n    }\n    __name(getSupportLevel, \"getSupportLevel\");\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: translateLevel(supportsColor(true, tty.isatty(1))),\n      stderr: translateLevel(supportsColor(true, tty.isatty(2)))\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js\nvar require_util = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js\"(exports, module2) {\n    \"use strict\";\n    var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {\n      let index = string.indexOf(substring);\n      if (index === -1) {\n        return string;\n      }\n      const substringLength = substring.length;\n      let endIndex = 0;\n      let returnValue = \"\";\n      do {\n        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n        endIndex = index + substringLength;\n        index = string.indexOf(substring, endIndex);\n      } while (index !== -1);\n      returnValue += string.substr(endIndex);\n      return returnValue;\n    }, \"stringReplaceAll\");\n    var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {\n      let endIndex = 0;\n      let returnValue = \"\";\n      do {\n        const gotCR = string[index - 1] === \"\\r\";\n        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? \"\\r\\n\" : \"\\n\") + postfix;\n        endIndex = index + 1;\n        index = string.indexOf(\"\\n\", endIndex);\n      } while (index !== -1);\n      returnValue += string.substr(endIndex);\n      return returnValue;\n    }, \"stringEncaseCRLFWithFirstIndex\");\n    module2.exports = {\n      stringReplaceAll,\n      stringEncaseCRLFWithFirstIndex\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js\nvar require_templates = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js\"(exports, module2) {\n    \"use strict\";\n    var TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n    var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n    var STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n    var ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n    var ESCAPES = /* @__PURE__ */ new Map([\n      [\"n\", \"\\n\"],\n      [\"r\", \"\\r\"],\n      [\"t\", \"\t\"],\n      [\"b\", \"\\b\"],\n      [\"f\", \"\\f\"],\n      [\"v\", \"\\v\"],\n      [\"0\", \"\\0\"],\n      [\"\\\\\", \"\\\\\"],\n      [\"e\", \"\\x1B\"],\n      [\"a\", \"\\x07\"]\n    ]);\n    function unescape(c) {\n      const u = c[0] === \"u\";\n      const bracket = c[1] === \"{\";\n      if (u && !bracket && c.length === 5 || c[0] === \"x\" && c.length === 3) {\n        return String.fromCharCode(parseInt(c.slice(1), 16));\n      }\n      if (u && bracket) {\n        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n      }\n      return ESCAPES.get(c) || c;\n    }\n    __name(unescape, \"unescape\");\n    function parseArguments(name, arguments_) {\n      const results = [];\n      const chunks = arguments_.trim().split(/\\s*,\\s*/g);\n      let matches;\n      for (const chunk of chunks) {\n        const number = Number(chunk);\n        if (!Number.isNaN(number)) {\n          results.push(number);\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n        } else {\n          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n        }\n      }\n      return results;\n    }\n    __name(parseArguments, \"parseArguments\");\n    function parseStyle(style) {\n      STYLE_REGEX.lastIndex = 0;\n      const results = [];\n      let matches;\n      while ((matches = STYLE_REGEX.exec(style)) !== null) {\n        const name = matches[1];\n        if (matches[2]) {\n          const args = parseArguments(name, matches[2]);\n          results.push([name].concat(args));\n        } else {\n          results.push([name]);\n        }\n      }\n      return results;\n    }\n    __name(parseStyle, \"parseStyle\");\n    function buildStyle(chalk12, styles) {\n      const enabled = {};\n      for (const layer of styles) {\n        for (const style of layer.styles) {\n          enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n      }\n      let current = chalk12;\n      for (const [styleName, styles2] of Object.entries(enabled)) {\n        if (!Array.isArray(styles2)) {\n          continue;\n        }\n        if (!(styleName in current)) {\n          throw new Error(`Unknown Chalk style: ${styleName}`);\n        }\n        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];\n      }\n      return current;\n    }\n    __name(buildStyle, \"buildStyle\");\n    module2.exports = (chalk12, temporary) => {\n      const styles = [];\n      const chunks = [];\n      let chunk = [];\n      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n        if (escapeCharacter) {\n          chunk.push(unescape(escapeCharacter));\n        } else if (style) {\n          const string = chunk.join(\"\");\n          chunk = [];\n          chunks.push(styles.length === 0 ? string : buildStyle(chalk12, styles)(string));\n          styles.push({ inverse, styles: parseStyle(style) });\n        } else if (close) {\n          if (styles.length === 0) {\n            throw new Error(\"Found extraneous } in Chalk template literal\");\n          }\n          chunks.push(buildStyle(chalk12, styles)(chunk.join(\"\")));\n          chunk = [];\n          styles.pop();\n        } else {\n          chunk.push(character);\n        }\n      });\n      chunks.push(chunk.join(\"\"));\n      if (styles.length > 0) {\n        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? \"\" : \"s\"} (\\`}\\`)`;\n        throw new Error(errMessage);\n      }\n      return chunks.join(\"\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js\nvar require_source = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js\"(exports, module2) {\n    \"use strict\";\n    var ansiStyles = require_ansi_styles();\n    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();\n    var {\n      stringReplaceAll,\n      stringEncaseCRLFWithFirstIndex\n    } = require_util();\n    var { isArray: isArray2 } = Array;\n    var levelMapping = [\n      \"ansi\",\n      \"ansi\",\n      \"ansi256\",\n      \"ansi16m\"\n    ];\n    var styles = /* @__PURE__ */ Object.create(null);\n    var applyOptions = /* @__PURE__ */ __name((object, options = {}) => {\n      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n        throw new Error(\"The `level` option should be an integer from 0 to 3\");\n      }\n      const colorLevel = stdoutColor ? stdoutColor.level : 0;\n      object.level = options.level === void 0 ? colorLevel : options.level;\n    }, \"applyOptions\");\n    var ChalkClass = class {\n      constructor(options) {\n        return chalkFactory(options);\n      }\n    };\n    __name(ChalkClass, \"ChalkClass\");\n    var chalkFactory = /* @__PURE__ */ __name((options) => {\n      const chalk13 = {};\n      applyOptions(chalk13, options);\n      chalk13.template = (...arguments_) => chalkTag(chalk13.template, ...arguments_);\n      Object.setPrototypeOf(chalk13, Chalk.prototype);\n      Object.setPrototypeOf(chalk13.template, chalk13);\n      chalk13.template.constructor = () => {\n        throw new Error(\"`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.\");\n      };\n      chalk13.template.Instance = ChalkClass;\n      return chalk13.template;\n    }, \"chalkFactory\");\n    function Chalk(options) {\n      return chalkFactory(options);\n    }\n    __name(Chalk, \"Chalk\");\n    for (const [styleName, style] of Object.entries(ansiStyles)) {\n      styles[styleName] = {\n        get() {\n          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n          Object.defineProperty(this, styleName, { value: builder });\n          return builder;\n        }\n      };\n    }\n    styles.visible = {\n      get() {\n        const builder = createBuilder(this, this._styler, true);\n        Object.defineProperty(this, \"visible\", { value: builder });\n        return builder;\n      }\n    };\n    var usedModels = [\"rgb\", \"hex\", \"keyword\", \"hsl\", \"hsv\", \"hwb\", \"ansi\", \"ansi256\"];\n    for (const model of usedModels) {\n      styles[model] = {\n        get() {\n          const { level } = this;\n          return function(...arguments_) {\n            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n            return createBuilder(this, styler, this._isEmpty);\n          };\n        }\n      };\n    }\n    for (const model of usedModels) {\n      const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);\n      styles[bgModel] = {\n        get() {\n          const { level } = this;\n          return function(...arguments_) {\n            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n            return createBuilder(this, styler, this._isEmpty);\n          };\n        }\n      };\n    }\n    var proto = Object.defineProperties(() => {\n    }, {\n      ...styles,\n      level: {\n        enumerable: true,\n        get() {\n          return this._generator.level;\n        },\n        set(level) {\n          this._generator.level = level;\n        }\n      }\n    });\n    var createStyler = /* @__PURE__ */ __name((open, close, parent) => {\n      let openAll;\n      let closeAll;\n      if (parent === void 0) {\n        openAll = open;\n        closeAll = close;\n      } else {\n        openAll = parent.openAll + open;\n        closeAll = close + parent.closeAll;\n      }\n      return {\n        open,\n        close,\n        openAll,\n        closeAll,\n        parent\n      };\n    }, \"createStyler\");\n    var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {\n      const builder = /* @__PURE__ */ __name((...arguments_) => {\n        if (isArray2(arguments_[0]) && isArray2(arguments_[0].raw)) {\n          return applyStyle(builder, chalkTag(builder, ...arguments_));\n        }\n        return applyStyle(builder, arguments_.length === 1 ? \"\" + arguments_[0] : arguments_.join(\" \"));\n      }, \"builder\");\n      Object.setPrototypeOf(builder, proto);\n      builder._generator = self2;\n      builder._styler = _styler;\n      builder._isEmpty = _isEmpty;\n      return builder;\n    }, \"createBuilder\");\n    var applyStyle = /* @__PURE__ */ __name((self2, string) => {\n      if (self2.level <= 0 || !string) {\n        return self2._isEmpty ? \"\" : string;\n      }\n      let styler = self2._styler;\n      if (styler === void 0) {\n        return string;\n      }\n      const { openAll, closeAll } = styler;\n      if (string.indexOf(\"\\x1B\") !== -1) {\n        while (styler !== void 0) {\n          string = stringReplaceAll(string, styler.close, styler.open);\n          styler = styler.parent;\n        }\n      }\n      const lfIndex = string.indexOf(\"\\n\");\n      if (lfIndex !== -1) {\n        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n      }\n      return openAll + string + closeAll;\n    }, \"applyStyle\");\n    var template;\n    var chalkTag = /* @__PURE__ */ __name((chalk13, ...strings) => {\n      const [firstString] = strings;\n      if (!isArray2(firstString) || !isArray2(firstString.raw)) {\n        return strings.join(\" \");\n      }\n      const arguments_ = strings.slice(1);\n      const parts = [firstString.raw[0]];\n      for (let i = 1; i < firstString.length; i++) {\n        parts.push(\n          String(arguments_[i - 1]).replace(/[{}\\\\]/g, \"\\\\$&\"),\n          String(firstString.raw[i])\n        );\n      }\n      if (template === void 0) {\n        template = require_templates();\n      }\n      return template(chalk13, parts.join(\"\"));\n    }, \"chalkTag\");\n    Object.defineProperties(Chalk.prototype, styles);\n    var chalk12 = Chalk();\n    chalk12.supportsColor = stdoutColor;\n    chalk12.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });\n    chalk12.stderr.supportsColor = stderrColor;\n    module2.exports = chalk12;\n  }\n});\n\n// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js\nvar require_indent_string = __commonJS({\n  \"../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (string, count2 = 1, options) => {\n      options = {\n        indent: \" \",\n        includeEmptyLines: false,\n        ...options\n      };\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          `Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n        );\n      }\n      if (typeof count2 !== \"number\") {\n        throw new TypeError(\n          `Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count2}\\``\n        );\n      }\n      if (typeof options.indent !== \"string\") {\n        throw new TypeError(\n          `Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n        );\n      }\n      if (count2 === 0) {\n        return string;\n      }\n      const regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n      return string.replace(regex, options.indent.repeat(count2));\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js\nvar require_js_levenshtein = __commonJS({\n  \"../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function() {\n      function _min(d0, d1, d2, bx, ay) {\n        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n      }\n      __name(_min, \"_min\");\n      return function(a, b) {\n        if (a === b) {\n          return 0;\n        }\n        if (a.length > b.length) {\n          var tmp = a;\n          a = b;\n          b = tmp;\n        }\n        var la = a.length;\n        var lb = b.length;\n        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n          la--;\n          lb--;\n        }\n        var offset = 0;\n        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n          offset++;\n        }\n        la -= offset;\n        lb -= offset;\n        if (la === 0 || lb < 3) {\n          return lb;\n        }\n        var x = 0;\n        var y;\n        var d0;\n        var d1;\n        var d2;\n        var d3;\n        var dd;\n        var dy;\n        var ay;\n        var bx0;\n        var bx1;\n        var bx2;\n        var bx3;\n        var vector = [];\n        for (y = 0; y < la; y++) {\n          vector.push(y + 1);\n          vector.push(a.charCodeAt(offset + y));\n        }\n        var len = vector.length - 1;\n        for (; x < lb - 3; ) {\n          bx0 = b.charCodeAt(offset + (d0 = x));\n          bx1 = b.charCodeAt(offset + (d1 = x + 1));\n          bx2 = b.charCodeAt(offset + (d2 = x + 2));\n          bx3 = b.charCodeAt(offset + (d3 = x + 3));\n          dd = x += 4;\n          for (y = 0; y < len; y += 2) {\n            dy = vector[y];\n            ay = vector[y + 1];\n            d0 = _min(dy, d0, d1, bx0, ay);\n            d1 = _min(d0, d1, d2, bx1, ay);\n            d2 = _min(d1, d2, d3, bx2, ay);\n            dd = _min(d2, d3, dd, bx3, ay);\n            vector[y] = dd;\n            d3 = d2;\n            d2 = d1;\n            d1 = d0;\n            d0 = dy;\n          }\n        }\n        for (; x < lb; ) {\n          bx0 = b.charCodeAt(offset + (d0 = x));\n          dd = ++x;\n          for (y = 0; y < len; y += 2) {\n            dy = vector[y];\n            vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n            d0 = dy;\n          }\n        }\n        return dd;\n      };\n    }();\n  }\n});\n\n// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\"(exports, module2) {\n    var s = 1e3;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    module2.exports = function(val, options) {\n      options = options || {};\n      var type = typeof val;\n      if (type === \"string\" && val.length > 0) {\n        return parse2(val);\n      } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse2(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type = (match[2] || \"ms\").toLowerCase();\n      switch (type) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    __name(parse2, \"parse\");\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    __name(fmtShort, \"fmtShort\");\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    __name(fmtLong, \"fmtLong\");\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    __name(plural, \"plural\");\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js\"(exports, module2) {\n    function setup(env2) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env2).forEach((key) => {\n        createDebug[key] = env2[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      __name(selectColor, \"selectColor\");\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug13(...args) {\n          if (!debug13.enabled) {\n            return;\n          }\n          const self2 = debug13;\n          const curr = Number(new Date());\n          const ms = curr - (prevTime || curr);\n          self2.diff = ms;\n          self2.prev = prevTime;\n          self2.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format2];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self2, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self2, args);\n          const logFn = self2.log || createDebug.log;\n          logFn.apply(self2, args);\n        }\n        __name(debug13, \"debug\");\n        debug13.namespace = namespace;\n        debug13.useColors = createDebug.useColors();\n        debug13.color = createDebug.selectColor(namespace);\n        debug13.extend = extend;\n        debug13.destroy = createDebug.destroy;\n        Object.defineProperty(debug13, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v) => {\n            enableOverride = v;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug13);\n        }\n        return debug13;\n      }\n      __name(createDebug, \"createDebug\");\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      __name(extend, \"extend\");\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      __name(enable, \"enable\");\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      __name(disable, \"disable\");\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      __name(enabled, \"enabled\");\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      __name(toNamespace, \"toNamespace\");\n      function coerce(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      __name(coerce, \"coerce\");\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      __name(destroy, \"destroy\");\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    __name(setup, \"setup\");\n    module2.exports = setup;\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js\"(exports, module2) {\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    __name(useColors, \"useColors\");\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module2.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c);\n    }\n    __name(formatArgs, \"formatArgs\");\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error2) {\n      }\n    }\n    __name(save, \"save\");\n    function load() {\n      let r;\n      try {\n        r = exports.storage.getItem(\"debug\");\n      } catch (error2) {\n      }\n      if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n      }\n      return r;\n    }\n    __name(load, \"load\");\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error2) {\n      }\n    }\n    __name(localstorage, \"localstorage\");\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.j = function(v) {\n      try {\n        return JSON.stringify(v);\n      } catch (error2) {\n        return \"[UnexpectedJSONParseError]: \" + error2.message;\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js\nvar require_node = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js\"(exports, module2) {\n    var tty = __webpack_require__(/*! tty */ \"tty\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    exports.init = init;\n    exports.log = log4;\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.destroy = util2.deprecate(\n      () => {\n      },\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    );\n    exports.colors = [6, 2, 3, 4, 5, 1];\n    try {\n      const supportsColor = require_supports_color();\n      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n          20,\n          21,\n          26,\n          27,\n          32,\n          33,\n          38,\n          39,\n          40,\n          41,\n          42,\n          43,\n          44,\n          45,\n          56,\n          57,\n          62,\n          63,\n          68,\n          69,\n          74,\n          75,\n          76,\n          77,\n          78,\n          79,\n          80,\n          81,\n          92,\n          93,\n          98,\n          99,\n          112,\n          113,\n          128,\n          129,\n          134,\n          135,\n          148,\n          149,\n          160,\n          161,\n          162,\n          163,\n          164,\n          165,\n          166,\n          167,\n          168,\n          169,\n          170,\n          171,\n          172,\n          173,\n          178,\n          179,\n          184,\n          185,\n          196,\n          197,\n          198,\n          199,\n          200,\n          201,\n          202,\n          203,\n          204,\n          205,\n          206,\n          207,\n          208,\n          209,\n          214,\n          215,\n          220,\n          221\n        ];\n      }\n    } catch (error2) {\n    }\n    exports.inspectOpts = Object.keys(process.env).filter((key) => {\n      return /^debug_/i.test(key);\n    }).reduce((obj, key) => {\n      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {\n        return k.toUpperCase();\n      });\n      let val = process.env[key];\n      if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n      } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n      } else if (val === \"null\") {\n        val = null;\n      } else {\n        val = Number(val);\n      }\n      obj[prop] = val;\n      return obj;\n    }, {});\n    function useColors() {\n      return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n    }\n    __name(useColors, \"useColors\");\n    function formatArgs(args) {\n      const { namespace: name, useColors: useColors2 } = this;\n      if (useColors2) {\n        const c = this.color;\n        const colorCode = \"\\x1B[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\x1B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module2.exports.humanize(this.diff) + \"\\x1B[0m\");\n      } else {\n        args[0] = getDate() + name + \" \" + args[0];\n      }\n    }\n    __name(formatArgs, \"formatArgs\");\n    function getDate() {\n      if (exports.inspectOpts.hideDate) {\n        return \"\";\n      }\n      return new Date().toISOString() + \" \";\n    }\n    __name(getDate, \"getDate\");\n    function log4(...args) {\n      return process.stderr.write(util2.format(...args) + \"\\n\");\n    }\n    __name(log4, \"log\");\n    function save(namespaces) {\n      if (namespaces) {\n        process.env.DEBUG = namespaces;\n      } else {\n        delete process.env.DEBUG;\n      }\n    }\n    __name(save, \"save\");\n    function load() {\n      return process.env.DEBUG;\n    }\n    __name(load, \"load\");\n    function init(debug13) {\n      debug13.inspectOpts = {};\n      const keys2 = Object.keys(exports.inspectOpts);\n      for (let i = 0; i < keys2.length; i++) {\n        debug13.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];\n      }\n    }\n    __name(init, \"init\");\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.o = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts).split(\"\\n\").map((str) => str.trim()).join(\" \");\n    };\n    formatters.O = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js\nvar require_src = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js\"(exports, module2) {\n    if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n      module2.exports = require_browser();\n    } else {\n      module2.exports = require_node();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js\nvar require_windows = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js\"(exports, module2) {\n    module2.exports = isexe;\n    isexe.sync = sync;\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    function checkPathExt(path7, options) {\n      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;\n      if (!pathext) {\n        return true;\n      }\n      pathext = pathext.split(\";\");\n      if (pathext.indexOf(\"\") !== -1) {\n        return true;\n      }\n      for (var i = 0; i < pathext.length; i++) {\n        var p = pathext[i].toLowerCase();\n        if (p && path7.substr(-p.length).toLowerCase() === p) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(checkPathExt, \"checkPathExt\");\n    function checkStat(stat, path7, options) {\n      if (!stat.isSymbolicLink() && !stat.isFile()) {\n        return false;\n      }\n      return checkPathExt(path7, options);\n    }\n    __name(checkStat, \"checkStat\");\n    function isexe(path7, options, cb) {\n      fs11.stat(path7, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, path7, options));\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      return checkStat(fs11.statSync(path7), path7, options);\n    }\n    __name(sync, \"sync\");\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js\nvar require_mode = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js\"(exports, module2) {\n    module2.exports = isexe;\n    isexe.sync = sync;\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    function isexe(path7, options, cb) {\n      fs11.stat(path7, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, options));\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      return checkStat(fs11.statSync(path7), options);\n    }\n    __name(sync, \"sync\");\n    function checkStat(stat, options) {\n      return stat.isFile() && checkMode(stat, options);\n    }\n    __name(checkStat, \"checkStat\");\n    function checkMode(stat, options) {\n      var mod2 = stat.mode;\n      var uid = stat.uid;\n      var gid = stat.gid;\n      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();\n      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();\n      var u = parseInt(\"100\", 8);\n      var g = parseInt(\"010\", 8);\n      var o = parseInt(\"001\", 8);\n      var ug = u | g;\n      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;\n      return ret;\n    }\n    __name(checkMode, \"checkMode\");\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js\nvar require_isexe = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js\"(exports, module2) {\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var core;\n    if (process.platform === \"win32\" || global.TESTING_WINDOWS) {\n      core = require_windows();\n    } else {\n      core = require_mode();\n    }\n    module2.exports = isexe;\n    isexe.sync = sync;\n    function isexe(path7, options, cb) {\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n      if (!cb) {\n        if (typeof Promise !== \"function\") {\n          throw new TypeError(\"callback not provided\");\n        }\n        return new Promise(function(resolve, reject) {\n          isexe(path7, options || {}, function(er, is) {\n            if (er) {\n              reject(er);\n            } else {\n              resolve(is);\n            }\n          });\n        });\n      }\n      core(path7, options || {}, function(er, is) {\n        if (er) {\n          if (er.code === \"EACCES\" || options && options.ignoreErrors) {\n            er = null;\n            is = false;\n          }\n        }\n        cb(er, is);\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      try {\n        return core.sync(path7, options || {});\n      } catch (er) {\n        if (options && options.ignoreErrors || er.code === \"EACCES\") {\n          return false;\n        } else {\n          throw er;\n        }\n      }\n    }\n    __name(sync, \"sync\");\n  }\n});\n\n// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js\nvar require_which = __commonJS({\n  \"../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js\"(exports, module2) {\n    var isWindows = process.platform === \"win32\" || process.env.OSTYPE === \"cygwin\" || process.env.OSTYPE === \"msys\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var COLON = isWindows ? \";\" : \":\";\n    var isexe = require_isexe();\n    var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: \"ENOENT\" }), \"getNotFoundError\");\n    var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {\n      const colon = opt.colon || COLON;\n      const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [\"\"] : [\n        ...isWindows ? [process.cwd()] : [],\n        ...(opt.path || process.env.PATH || \"\").split(colon)\n      ];\n      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || \".EXE;.CMD;.BAT;.COM\" : \"\";\n      const pathExt = isWindows ? pathExtExe.split(colon) : [\"\"];\n      if (isWindows) {\n        if (cmd.indexOf(\".\") !== -1 && pathExt[0] !== \"\")\n          pathExt.unshift(\"\");\n      }\n      return {\n        pathEnv,\n        pathExt,\n        pathExtExe\n      };\n    }, \"getPathInfo\");\n    var which = /* @__PURE__ */ __name((cmd, opt, cb) => {\n      if (typeof opt === \"function\") {\n        cb = opt;\n        opt = {};\n      }\n      if (!opt)\n        opt = {};\n      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n      const found = [];\n      const step = /* @__PURE__ */ __name((i) => new Promise((resolve, reject) => {\n        if (i === pathEnv.length)\n          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path7.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        resolve(subStep(p, i, 0));\n      }), \"step\");\n      const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve, reject) => {\n        if (ii === pathExt.length)\n          return resolve(step(i + 1));\n        const ext = pathExt[ii];\n        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n          if (!er && is) {\n            if (opt.all)\n              found.push(p + ext);\n            else\n              return resolve(p + ext);\n          }\n          return resolve(subStep(p, i, ii + 1));\n        });\n      }), \"subStep\");\n      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);\n    }, \"which\");\n    var whichSync = /* @__PURE__ */ __name((cmd, opt) => {\n      opt = opt || {};\n      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n      const found = [];\n      for (let i = 0; i < pathEnv.length; i++) {\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path7.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        for (let j = 0; j < pathExt.length; j++) {\n          const cur = p + pathExt[j];\n          try {\n            const is = isexe.sync(cur, { pathExt: pathExtExe });\n            if (is) {\n              if (opt.all)\n                found.push(cur);\n              else\n                return cur;\n            }\n          } catch (ex) {\n          }\n        }\n      }\n      if (opt.all && found.length)\n        return found;\n      if (opt.nothrow)\n        return null;\n      throw getNotFoundError(cmd);\n    }, \"whichSync\");\n    module2.exports = which;\n    which.sync = whichSync;\n  }\n});\n\n// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js\nvar require_path_key = __commonJS({\n  \"../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js\"(exports, module2) {\n    \"use strict\";\n    var pathKey = /* @__PURE__ */ __name((options = {}) => {\n      const environment = options.env || process.env;\n      const platform3 = options.platform || process.platform;\n      if (platform3 !== \"win32\") {\n        return \"PATH\";\n      }\n      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === \"PATH\") || \"Path\";\n    }, \"pathKey\");\n    module2.exports = pathKey;\n    module2.exports.default = pathKey;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js\nvar require_resolveCommand = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var which = require_which();\n    var getPathKey = require_path_key();\n    function resolveCommandAttempt(parsed, withoutPathExt) {\n      const env2 = parsed.options.env || process.env;\n      const cwd = process.cwd();\n      const hasCustomCwd = parsed.options.cwd != null;\n      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;\n      if (shouldSwitchCwd) {\n        try {\n          process.chdir(parsed.options.cwd);\n        } catch (err) {\n        }\n      }\n      let resolved;\n      try {\n        resolved = which.sync(parsed.command, {\n          path: env2[getPathKey({ env: env2 })],\n          pathExt: withoutPathExt ? path7.delimiter : void 0\n        });\n      } catch (e) {\n      } finally {\n        if (shouldSwitchCwd) {\n          process.chdir(cwd);\n        }\n      }\n      if (resolved) {\n        resolved = path7.resolve(hasCustomCwd ? parsed.options.cwd : \"\", resolved);\n      }\n      return resolved;\n    }\n    __name(resolveCommandAttempt, \"resolveCommandAttempt\");\n    function resolveCommand(parsed) {\n      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n    }\n    __name(resolveCommand, \"resolveCommand\");\n    module2.exports = resolveCommand;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js\nvar require_escape = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js\"(exports, module2) {\n    \"use strict\";\n    var metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n    function escapeCommand(arg2) {\n      arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      return arg2;\n    }\n    __name(escapeCommand, \"escapeCommand\");\n    function escapeArgument(arg2, doubleEscapeMetaChars) {\n      arg2 = `${arg2}`;\n      arg2 = arg2.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n      arg2 = arg2.replace(/(\\\\*)$/, \"$1$1\");\n      arg2 = `\"${arg2}\"`;\n      arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      if (doubleEscapeMetaChars) {\n        arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      }\n      return arg2;\n    }\n    __name(escapeArgument, \"escapeArgument\");\n    module2.exports.command = escapeCommand;\n    module2.exports.argument = escapeArgument;\n  }\n});\n\n// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js\nvar require_shebang_regex = __commonJS({\n  \"../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = /^#!(.*)/;\n  }\n});\n\n// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js\nvar require_shebang_command = __commonJS({\n  \"../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js\"(exports, module2) {\n    \"use strict\";\n    var shebangRegex = require_shebang_regex();\n    module2.exports = (string = \"\") => {\n      const match = string.match(shebangRegex);\n      if (!match) {\n        return null;\n      }\n      const [path7, argument] = match[0].replace(/#! ?/, \"\").split(\" \");\n      const binary = path7.split(\"/\").pop();\n      if (binary === \"env\") {\n        return argument;\n      }\n      return argument ? `${binary} ${argument}` : binary;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js\nvar require_readShebang = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js\"(exports, module2) {\n    \"use strict\";\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var shebangCommand = require_shebang_command();\n    function readShebang(command) {\n      const size = 150;\n      const buffer = Buffer.alloc(size);\n      let fd;\n      try {\n        fd = fs11.openSync(command, \"r\");\n        fs11.readSync(fd, buffer, 0, size, 0);\n        fs11.closeSync(fd);\n      } catch (e) {\n      }\n      return shebangCommand(buffer.toString());\n    }\n    __name(readShebang, \"readShebang\");\n    module2.exports = readShebang;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js\nvar require_parse = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var resolveCommand = require_resolveCommand();\n    var escape = require_escape();\n    var readShebang = require_readShebang();\n    var isWin = process.platform === \"win32\";\n    var isExecutableRegExp = /\\.(?:com|exe)$/i;\n    var isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n    function detectShebang(parsed) {\n      parsed.file = resolveCommand(parsed);\n      const shebang = parsed.file && readShebang(parsed.file);\n      if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        return resolveCommand(parsed);\n      }\n      return parsed.file;\n    }\n    __name(detectShebang, \"detectShebang\");\n    function parseNonShell(parsed) {\n      if (!isWin) {\n        return parsed;\n      }\n      const commandFile = detectShebang(parsed);\n      const needsShell = !isExecutableRegExp.test(commandFile);\n      if (parsed.options.forceShell || needsShell) {\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n        parsed.command = path7.normalize(parsed.command);\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));\n        const shellCommand = [parsed.command].concat(parsed.args).join(\" \");\n        parsed.args = [\"/d\", \"/s\", \"/c\", `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || \"cmd.exe\";\n        parsed.options.windowsVerbatimArguments = true;\n      }\n      return parsed;\n    }\n    __name(parseNonShell, \"parseNonShell\");\n    function parse2(command, args, options) {\n      if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n      }\n      args = args ? args.slice(0) : [];\n      options = Object.assign({}, options);\n      const parsed = {\n        command,\n        args,\n        options,\n        file: void 0,\n        original: {\n          command,\n          args\n        }\n      };\n      return options.shell ? parsed : parseNonShell(parsed);\n    }\n    __name(parse2, \"parse\");\n    module2.exports = parse2;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js\nvar require_enoent = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js\"(exports, module2) {\n    \"use strict\";\n    var isWin = process.platform === \"win32\";\n    function notFoundError(original, syscall) {\n      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: \"ENOENT\",\n        errno: \"ENOENT\",\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args\n      });\n    }\n    __name(notFoundError, \"notFoundError\");\n    function hookChildProcess(cp, parsed) {\n      if (!isWin) {\n        return;\n      }\n      const originalEmit = cp.emit;\n      cp.emit = function(name, arg1) {\n        if (name === \"exit\") {\n          const err = verifyENOENT(arg1, parsed, \"spawn\");\n          if (err) {\n            return originalEmit.call(cp, \"error\", err);\n          }\n        }\n        return originalEmit.apply(cp, arguments);\n      };\n    }\n    __name(hookChildProcess, \"hookChildProcess\");\n    function verifyENOENT(status, parsed) {\n      if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, \"spawn\");\n      }\n      return null;\n    }\n    __name(verifyENOENT, \"verifyENOENT\");\n    function verifyENOENTSync(status, parsed) {\n      if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, \"spawnSync\");\n      }\n      return null;\n    }\n    __name(verifyENOENTSync, \"verifyENOENTSync\");\n    module2.exports = {\n      hookChildProcess,\n      verifyENOENT,\n      verifyENOENTSync,\n      notFoundError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js\nvar require_cross_spawn = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js\"(exports, module2) {\n    \"use strict\";\n    var cp = __webpack_require__(/*! child_process */ \"child_process\");\n    var parse2 = require_parse();\n    var enoent = require_enoent();\n    function spawn2(command, args, options) {\n      const parsed = parse2(command, args, options);\n      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n      enoent.hookChildProcess(spawned, parsed);\n      return spawned;\n    }\n    __name(spawn2, \"spawn\");\n    function spawnSync(command, args, options) {\n      const parsed = parse2(command, args, options);\n      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n      return result;\n    }\n    __name(spawnSync, \"spawnSync\");\n    module2.exports = spawn2;\n    module2.exports.spawn = spawn2;\n    module2.exports.sync = spawnSync;\n    module2.exports._parse = parse2;\n    module2.exports._enoent = enoent;\n  }\n});\n\n// ../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/package.json\nvar require_package = __commonJS({\n  \"../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/package.json\"(exports, module2) {\n    module2.exports = {\n      name: \"@prisma/engines-version\",\n      version: \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\",\n      main: \"index.js\",\n      types: \"index.d.ts\",\n      license: \"Apache-2.0\",\n      author: \"Tim Suchanek <suchanek@prisma.io>\",\n      prisma: {\n        enginesVersion: \"c875e43600dfe042452e0b868f7a48b817b9640b\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/prisma/engines-wrapper.git\",\n        directory: \"packages/engines-version\"\n      },\n      devDependencies: {\n        \"@types/node\": \"16.11.56\",\n        typescript: \"4.7.4\"\n      },\n      files: [\n        \"index.js\",\n        \"index.d.ts\"\n      ],\n      scripts: {\n        build: \"tsc -d\"\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/index.js\nvar require_engines_version = __commonJS({\n  \"../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.enginesVersion = void 0;\n    exports.enginesVersion = require_package().prisma.enginesVersion;\n  }\n});\n\n// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js\nvar require_strip_final_newline = __commonJS({\n  \"../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (input) => {\n      const LF = typeof input === \"string\" ? \"\\n\" : \"\\n\".charCodeAt();\n      const CR = typeof input === \"string\" ? \"\\r\" : \"\\r\".charCodeAt();\n      if (input[input.length - 1] === LF) {\n        input = input.slice(0, input.length - 1);\n      }\n      if (input[input.length - 1] === CR) {\n        input = input.slice(0, input.length - 1);\n      }\n      return input;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js\nvar require_npm_run_path = __commonJS({\n  \"../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var pathKey = require_path_key();\n    var npmRunPath = /* @__PURE__ */ __name((options) => {\n      options = {\n        cwd: process.cwd(),\n        path: process.env[pathKey()],\n        execPath: process.execPath,\n        ...options\n      };\n      let previous;\n      let cwdPath = path7.resolve(options.cwd);\n      const result = [];\n      while (previous !== cwdPath) {\n        result.push(path7.join(cwdPath, \"node_modules/.bin\"));\n        previous = cwdPath;\n        cwdPath = path7.resolve(cwdPath, \"..\");\n      }\n      const execPathDir = path7.resolve(options.cwd, options.execPath, \"..\");\n      result.push(execPathDir);\n      return result.concat(options.path).join(path7.delimiter);\n    }, \"npmRunPath\");\n    module2.exports = npmRunPath;\n    module2.exports.default = npmRunPath;\n    module2.exports.env = (options) => {\n      options = {\n        env: process.env,\n        ...options\n      };\n      const env2 = { ...options.env };\n      const path8 = pathKey({ env: env2 });\n      options.path = env2[path8];\n      env2[path8] = module2.exports(options);\n      return env2;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js\nvar require_mimic_fn = __commonJS({\n  \"../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js\"(exports, module2) {\n    \"use strict\";\n    var mimicFn = /* @__PURE__ */ __name((to, from) => {\n      for (const prop of Reflect.ownKeys(from)) {\n        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n      }\n      return to;\n    }, \"mimicFn\");\n    module2.exports = mimicFn;\n    module2.exports.default = mimicFn;\n  }\n});\n\n// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js\nvar require_onetime = __commonJS({\n  \"../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js\"(exports, module2) {\n    \"use strict\";\n    var mimicFn = require_mimic_fn();\n    var calledFunctions = /* @__PURE__ */ new WeakMap();\n    var onetime = /* @__PURE__ */ __name((function_, options = {}) => {\n      if (typeof function_ !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n      }\n      let returnValue;\n      let callCount = 0;\n      const functionName = function_.displayName || function_.name || \"<anonymous>\";\n      const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {\n        calledFunctions.set(onetime2, ++callCount);\n        if (callCount === 1) {\n          returnValue = function_.apply(this, arguments_);\n          function_ = null;\n        } else if (options.throw === true) {\n          throw new Error(`Function \\`${functionName}\\` can only be called once`);\n        }\n        return returnValue;\n      }, \"onetime\");\n      mimicFn(onetime2, function_);\n      calledFunctions.set(onetime2, callCount);\n      return onetime2;\n    }, \"onetime\");\n    module2.exports = onetime;\n    module2.exports.default = onetime;\n    module2.exports.callCount = (function_) => {\n      if (!calledFunctions.has(function_)) {\n        throw new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n      }\n      return calledFunctions.get(function_);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js\nvar require_core = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SIGNALS = void 0;\n    var SIGNALS = [\n      {\n        name: \"SIGHUP\",\n        number: 1,\n        action: \"terminate\",\n        description: \"Terminal closed\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGINT\",\n        number: 2,\n        action: \"terminate\",\n        description: \"User interruption with CTRL-C\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGQUIT\",\n        number: 3,\n        action: \"core\",\n        description: \"User interruption with CTRL-\\\\\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGILL\",\n        number: 4,\n        action: \"core\",\n        description: \"Invalid machine instruction\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGTRAP\",\n        number: 5,\n        action: \"core\",\n        description: \"Debugger breakpoint\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGABRT\",\n        number: 6,\n        action: \"core\",\n        description: \"Aborted\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGIOT\",\n        number: 6,\n        action: \"core\",\n        description: \"Aborted\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGBUS\",\n        number: 7,\n        action: \"core\",\n        description: \"Bus error due to misaligned, non-existing address or paging error\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGEMT\",\n        number: 7,\n        action: \"terminate\",\n        description: \"Command should be emulated but is not implemented\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGFPE\",\n        number: 8,\n        action: \"core\",\n        description: \"Floating point arithmetic error\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGKILL\",\n        number: 9,\n        action: \"terminate\",\n        description: \"Forced termination\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGUSR1\",\n        number: 10,\n        action: \"terminate\",\n        description: \"Application-specific signal\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGSEGV\",\n        number: 11,\n        action: \"core\",\n        description: \"Segmentation fault\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGUSR2\",\n        number: 12,\n        action: \"terminate\",\n        description: \"Application-specific signal\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGPIPE\",\n        number: 13,\n        action: \"terminate\",\n        description: \"Broken pipe or socket\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGALRM\",\n        number: 14,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGTERM\",\n        number: 15,\n        action: \"terminate\",\n        description: \"Termination\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGSTKFLT\",\n        number: 16,\n        action: \"terminate\",\n        description: \"Stack is empty or overflowed\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGCHLD\",\n        number: 17,\n        action: \"ignore\",\n        description: \"Child process terminated, paused or unpaused\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGCLD\",\n        number: 17,\n        action: \"ignore\",\n        description: \"Child process terminated, paused or unpaused\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGCONT\",\n        number: 18,\n        action: \"unpause\",\n        description: \"Unpaused\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGSTOP\",\n        number: 19,\n        action: \"pause\",\n        description: \"Paused\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGTSTP\",\n        number: 20,\n        action: \"pause\",\n        description: 'Paused using CTRL-Z or \"suspend\"',\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGTTIN\",\n        number: 21,\n        action: \"pause\",\n        description: \"Background process cannot read terminal input\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGBREAK\",\n        number: 21,\n        action: \"terminate\",\n        description: \"User interruption with CTRL-BREAK\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGTTOU\",\n        number: 22,\n        action: \"pause\",\n        description: \"Background process cannot write to terminal output\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGURG\",\n        number: 23,\n        action: \"ignore\",\n        description: \"Socket received out-of-band data\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGXCPU\",\n        number: 24,\n        action: \"core\",\n        description: \"Process timed out\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGXFSZ\",\n        number: 25,\n        action: \"core\",\n        description: \"File too big\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGVTALRM\",\n        number: 26,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGPROF\",\n        number: 27,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGWINCH\",\n        number: 28,\n        action: \"ignore\",\n        description: \"Terminal window size changed\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGIO\",\n        number: 29,\n        action: \"terminate\",\n        description: \"I/O is available\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGPOLL\",\n        number: 29,\n        action: \"terminate\",\n        description: \"Watched event\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGINFO\",\n        number: 29,\n        action: \"ignore\",\n        description: \"Request for process information\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGPWR\",\n        number: 30,\n        action: \"terminate\",\n        description: \"Device running out of power\",\n        standard: \"systemv\"\n      },\n      {\n        name: \"SIGSYS\",\n        number: 31,\n        action: \"core\",\n        description: \"Invalid system call\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGUNUSED\",\n        number: 31,\n        action: \"terminate\",\n        description: \"Invalid system call\",\n        standard: \"other\"\n      }\n    ];\n    exports.SIGNALS = SIGNALS;\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js\nvar require_realtime = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SIGRTMAX = exports.getRealtimeSignals = void 0;\n    var getRealtimeSignals = /* @__PURE__ */ __name(function() {\n      const length = SIGRTMAX - SIGRTMIN + 1;\n      return Array.from({ length }, getRealtimeSignal);\n    }, \"getRealtimeSignals\");\n    exports.getRealtimeSignals = getRealtimeSignals;\n    var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {\n      return {\n        name: `SIGRT${index + 1}`,\n        number: SIGRTMIN + index,\n        action: \"terminate\",\n        description: \"Application-specific signal (realtime)\",\n        standard: \"posix\"\n      };\n    }, \"getRealtimeSignal\");\n    var SIGRTMIN = 34;\n    var SIGRTMAX = 64;\n    exports.SIGRTMAX = SIGRTMAX;\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js\nvar require_signals = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.getSignals = void 0;\n    var _os = __webpack_require__(/*! os */ \"os\");\n    var _core = require_core();\n    var _realtime = require_realtime();\n    var getSignals = /* @__PURE__ */ __name(function() {\n      const realtimeSignals = (0, _realtime.getRealtimeSignals)();\n      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);\n      return signals;\n    }, \"getSignals\");\n    exports.getSignals = getSignals;\n    var normalizeSignal = /* @__PURE__ */ __name(function({\n      name,\n      number: defaultNumber,\n      description,\n      action,\n      forced = false,\n      standard\n    }) {\n      const {\n        signals: { [name]: constantSignal }\n      } = _os.constants;\n      const supported = constantSignal !== void 0;\n      const number = supported ? constantSignal : defaultNumber;\n      return { name, number, description, supported, action, forced, standard };\n    }, \"normalizeSignal\");\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js\nvar require_main = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.signalsByNumber = exports.signalsByName = void 0;\n    var _os = __webpack_require__(/*! os */ \"os\");\n    var _signals = require_signals();\n    var _realtime = require_realtime();\n    var getSignalsByName = /* @__PURE__ */ __name(function() {\n      const signals = (0, _signals.getSignals)();\n      return signals.reduce(getSignalByName, {});\n    }, \"getSignalsByName\");\n    var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {\n      return {\n        ...signalByNameMemo,\n        [name]: { name, number, description, supported, action, forced, standard }\n      };\n    }, \"getSignalByName\");\n    var signalsByName = getSignalsByName();\n    exports.signalsByName = signalsByName;\n    var getSignalsByNumber = /* @__PURE__ */ __name(function() {\n      const signals = (0, _signals.getSignals)();\n      const length = _realtime.SIGRTMAX + 1;\n      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));\n      return Object.assign({}, ...signalsA);\n    }, \"getSignalsByNumber\");\n    var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {\n      const signal = findSignalByNumber(number, signals);\n      if (signal === void 0) {\n        return {};\n      }\n      const { name, description, supported, action, forced, standard } = signal;\n      return {\n        [number]: {\n          name,\n          number,\n          description,\n          supported,\n          action,\n          forced,\n          standard\n        }\n      };\n    }, \"getSignalByNumber\");\n    var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {\n      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);\n      if (signal !== void 0) {\n        return signal;\n      }\n      return signals.find((signalA) => signalA.number === number);\n    }, \"findSignalByNumber\");\n    var signalsByNumber = getSignalsByNumber();\n    exports.signalsByNumber = signalsByNumber;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js\nvar require_error = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js\"(exports, module2) {\n    \"use strict\";\n    var { signalsByName } = require_main();\n    var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {\n      if (timedOut) {\n        return `timed out after ${timeout} milliseconds`;\n      }\n      if (isCanceled) {\n        return \"was canceled\";\n      }\n      if (errorCode !== void 0) {\n        return `failed with ${errorCode}`;\n      }\n      if (signal !== void 0) {\n        return `was killed with ${signal} (${signalDescription})`;\n      }\n      if (exitCode !== void 0) {\n        return `failed with exit code ${exitCode}`;\n      }\n      return \"failed\";\n    }, \"getErrorPrefix\");\n    var makeError = /* @__PURE__ */ __name(({\n      stdout,\n      stderr,\n      all,\n      error: error2,\n      signal,\n      exitCode,\n      command,\n      escapedCommand,\n      timedOut,\n      isCanceled,\n      killed,\n      parsed: { options: { timeout } }\n    }) => {\n      exitCode = exitCode === null ? void 0 : exitCode;\n      signal = signal === null ? void 0 : signal;\n      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;\n      const errorCode = error2 && error2.code;\n      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });\n      const execaMessage = `Command ${prefix}: ${command}`;\n      const isError2 = Object.prototype.toString.call(error2) === \"[object Error]\";\n      const shortMessage = isError2 ? `${execaMessage}\n${error2.message}` : execaMessage;\n      const message = [shortMessage, stderr, stdout].filter(Boolean).join(\"\\n\");\n      if (isError2) {\n        error2.originalMessage = error2.message;\n        error2.message = message;\n      } else {\n        error2 = new Error(message);\n      }\n      error2.shortMessage = shortMessage;\n      error2.command = command;\n      error2.escapedCommand = escapedCommand;\n      error2.exitCode = exitCode;\n      error2.signal = signal;\n      error2.signalDescription = signalDescription;\n      error2.stdout = stdout;\n      error2.stderr = stderr;\n      if (all !== void 0) {\n        error2.all = all;\n      }\n      if (\"bufferedData\" in error2) {\n        delete error2.bufferedData;\n      }\n      error2.failed = true;\n      error2.timedOut = Boolean(timedOut);\n      error2.isCanceled = isCanceled;\n      error2.killed = killed && !timedOut;\n      return error2;\n    }, \"makeError\");\n    module2.exports = makeError;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js\nvar require_stdio = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js\"(exports, module2) {\n    \"use strict\";\n    var aliases = [\"stdin\", \"stdout\", \"stderr\"];\n    var hasAlias = /* @__PURE__ */ __name((options) => aliases.some((alias) => options[alias] !== void 0), \"hasAlias\");\n    var normalizeStdio = /* @__PURE__ */ __name((options) => {\n      if (!options) {\n        return;\n      }\n      const { stdio } = options;\n      if (stdio === void 0) {\n        return aliases.map((alias) => options[alias]);\n      }\n      if (hasAlias(options)) {\n        throw new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map((alias) => `\\`${alias}\\``).join(\", \")}`);\n      }\n      if (typeof stdio === \"string\") {\n        return stdio;\n      }\n      if (!Array.isArray(stdio)) {\n        throw new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n      }\n      const length = Math.max(stdio.length, aliases.length);\n      return Array.from({ length }, (value, index) => stdio[index]);\n    }, \"normalizeStdio\");\n    module2.exports = normalizeStdio;\n    module2.exports.node = (options) => {\n      const stdio = normalizeStdio(options);\n      if (stdio === \"ipc\") {\n        return \"ipc\";\n      }\n      if (stdio === void 0 || typeof stdio === \"string\") {\n        return [stdio, stdio, stdio, \"ipc\"];\n      }\n      if (stdio.includes(\"ipc\")) {\n        return stdio;\n      }\n      return [...stdio, \"ipc\"];\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js\nvar require_signals2 = __commonJS({\n  \"../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js\"(exports, module2) {\n    module2.exports = [\n      \"SIGABRT\",\n      \"SIGALRM\",\n      \"SIGHUP\",\n      \"SIGINT\",\n      \"SIGTERM\"\n    ];\n    if (process.platform !== \"win32\") {\n      module2.exports.push(\n        \"SIGVTALRM\",\n        \"SIGXCPU\",\n        \"SIGXFSZ\",\n        \"SIGUSR2\",\n        \"SIGTRAP\",\n        \"SIGSYS\",\n        \"SIGQUIT\",\n        \"SIGIOT\"\n      );\n    }\n    if (process.platform === \"linux\") {\n      module2.exports.push(\n        \"SIGIO\",\n        \"SIGPOLL\",\n        \"SIGPWR\",\n        \"SIGSTKFLT\",\n        \"SIGUNUSED\"\n      );\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js\nvar require_signal_exit = __commonJS({\n  \"../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js\"(exports, module2) {\n    var process2 = global.process;\n    var processOk = /* @__PURE__ */ __name(function(process3) {\n      return process3 && typeof process3 === \"object\" && typeof process3.removeListener === \"function\" && typeof process3.emit === \"function\" && typeof process3.reallyExit === \"function\" && typeof process3.listeners === \"function\" && typeof process3.kill === \"function\" && typeof process3.pid === \"number\" && typeof process3.on === \"function\";\n    }, \"processOk\");\n    if (!processOk(process2)) {\n      module2.exports = function() {\n        return function() {\n        };\n      };\n    } else {\n      assert = __webpack_require__(/*! assert */ \"assert\");\n      signals = require_signals2();\n      isWin = /^win/i.test(process2.platform);\n      EE = __webpack_require__(/*! events */ \"events\");\n      if (typeof EE !== \"function\") {\n        EE = EE.EventEmitter;\n      }\n      if (process2.__signal_exit_emitter__) {\n        emitter = process2.__signal_exit_emitter__;\n      } else {\n        emitter = process2.__signal_exit_emitter__ = new EE();\n        emitter.count = 0;\n        emitter.emitted = {};\n      }\n      if (!emitter.infinite) {\n        emitter.setMaxListeners(Infinity);\n        emitter.infinite = true;\n      }\n      module2.exports = function(cb, opts) {\n        if (!processOk(global.process)) {\n          return function() {\n          };\n        }\n        assert.equal(typeof cb, \"function\", \"a callback must be provided for exit handler\");\n        if (loaded === false) {\n          load();\n        }\n        var ev = \"exit\";\n        if (opts && opts.alwaysLast) {\n          ev = \"afterexit\";\n        }\n        var remove = /* @__PURE__ */ __name(function() {\n          emitter.removeListener(ev, cb);\n          if (emitter.listeners(\"exit\").length === 0 && emitter.listeners(\"afterexit\").length === 0) {\n            unload();\n          }\n        }, \"remove\");\n        emitter.on(ev, cb);\n        return remove;\n      };\n      unload = /* @__PURE__ */ __name(function unload2() {\n        if (!loaded || !processOk(global.process)) {\n          return;\n        }\n        loaded = false;\n        signals.forEach(function(sig) {\n          try {\n            process2.removeListener(sig, sigListeners[sig]);\n          } catch (er) {\n          }\n        });\n        process2.emit = originalProcessEmit;\n        process2.reallyExit = originalProcessReallyExit;\n        emitter.count -= 1;\n      }, \"unload\");\n      module2.exports.unload = unload;\n      emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {\n        if (emitter.emitted[event]) {\n          return;\n        }\n        emitter.emitted[event] = true;\n        emitter.emit(event, code, signal);\n      }, \"emit\");\n      sigListeners = {};\n      signals.forEach(function(sig) {\n        sigListeners[sig] = /* @__PURE__ */ __name(function listener() {\n          if (!processOk(global.process)) {\n            return;\n          }\n          var listeners = process2.listeners(sig);\n          if (listeners.length === emitter.count) {\n            unload();\n            emit(\"exit\", null, sig);\n            emit(\"afterexit\", null, sig);\n            if (isWin && sig === \"SIGHUP\") {\n              sig = \"SIGINT\";\n            }\n            process2.kill(process2.pid, sig);\n          }\n        }, \"listener\");\n      });\n      module2.exports.signals = function() {\n        return signals;\n      };\n      loaded = false;\n      load = /* @__PURE__ */ __name(function load2() {\n        if (loaded || !processOk(global.process)) {\n          return;\n        }\n        loaded = true;\n        emitter.count += 1;\n        signals = signals.filter(function(sig) {\n          try {\n            process2.on(sig, sigListeners[sig]);\n            return true;\n          } catch (er) {\n            return false;\n          }\n        });\n        process2.emit = processEmit;\n        process2.reallyExit = processReallyExit;\n      }, \"load\");\n      module2.exports.load = load;\n      originalProcessReallyExit = process2.reallyExit;\n      processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {\n        if (!processOk(global.process)) {\n          return;\n        }\n        process2.exitCode = code || 0;\n        emit(\"exit\", process2.exitCode, null);\n        emit(\"afterexit\", process2.exitCode, null);\n        originalProcessReallyExit.call(process2, process2.exitCode);\n      }, \"processReallyExit\");\n      originalProcessEmit = process2.emit;\n      processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg2) {\n        if (ev === \"exit\" && processOk(global.process)) {\n          if (arg2 !== void 0) {\n            process2.exitCode = arg2;\n          }\n          var ret = originalProcessEmit.apply(this, arguments);\n          emit(\"exit\", process2.exitCode, null);\n          emit(\"afterexit\", process2.exitCode, null);\n          return ret;\n        } else {\n          return originalProcessEmit.apply(this, arguments);\n        }\n      }, \"processEmit\");\n    }\n    var assert;\n    var signals;\n    var isWin;\n    var EE;\n    var emitter;\n    var unload;\n    var emit;\n    var sigListeners;\n    var loaded;\n    var load;\n    var originalProcessReallyExit;\n    var processReallyExit;\n    var originalProcessEmit;\n    var processEmit;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js\nvar require_kill = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js\"(exports, module2) {\n    \"use strict\";\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var onExit = require_signal_exit();\n    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;\n    var spawnedKill = /* @__PURE__ */ __name((kill, signal = \"SIGTERM\", options = {}) => {\n      const killResult = kill(signal);\n      setKillTimeout(kill, signal, options, killResult);\n      return killResult;\n    }, \"spawnedKill\");\n    var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options, killResult) => {\n      if (!shouldForceKill(signal, options, killResult)) {\n        return;\n      }\n      const timeout = getForceKillAfterTimeout(options);\n      const t = setTimeout(() => {\n        kill(\"SIGKILL\");\n      }, timeout);\n      if (t.unref) {\n        t.unref();\n      }\n    }, \"setKillTimeout\");\n    var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {\n      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n    }, \"shouldForceKill\");\n    var isSigterm = /* @__PURE__ */ __name((signal) => {\n      return signal === os3.constants.signals.SIGTERM || typeof signal === \"string\" && signal.toUpperCase() === \"SIGTERM\";\n    }, \"isSigterm\");\n    var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {\n      if (forceKillAfterTimeout === true) {\n        return DEFAULT_FORCE_KILL_TIMEOUT;\n      }\n      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n        throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n      }\n      return forceKillAfterTimeout;\n    }, \"getForceKillAfterTimeout\");\n    var spawnedCancel = /* @__PURE__ */ __name((spawned, context3) => {\n      const killResult = spawned.kill();\n      if (killResult) {\n        context3.isCanceled = true;\n      }\n    }, \"spawnedCancel\");\n    var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject) => {\n      spawned.kill(signal);\n      reject(Object.assign(new Error(\"Timed out\"), { timedOut: true, signal }));\n    }, \"timeoutKill\");\n    var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = \"SIGTERM\" }, spawnedPromise) => {\n      if (timeout === 0 || timeout === void 0) {\n        return spawnedPromise;\n      }\n      let timeoutId;\n      const timeoutPromise = new Promise((resolve, reject) => {\n        timeoutId = setTimeout(() => {\n          timeoutKill(spawned, killSignal, reject);\n        }, timeout);\n      });\n      const safeSpawnedPromise = spawnedPromise.finally(() => {\n        clearTimeout(timeoutId);\n      });\n      return Promise.race([timeoutPromise, safeSpawnedPromise]);\n    }, \"setupTimeout\");\n    var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {\n      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {\n        throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n      }\n    }, \"validateTimeout\");\n    var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {\n      if (!cleanup || detached) {\n        return timedPromise;\n      }\n      const removeExitHandler = onExit(() => {\n        spawned.kill();\n      });\n      return timedPromise.finally(() => {\n        removeExitHandler();\n      });\n    }, \"setExitHandler\");\n    module2.exports = {\n      spawnedKill,\n      spawnedCancel,\n      setupTimeout,\n      validateTimeout,\n      setExitHandler\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js\nvar require_is_stream = __commonJS({\n  \"../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var isStream = /* @__PURE__ */ __name((stream2) => stream2 !== null && typeof stream2 === \"object\" && typeof stream2.pipe === \"function\", \"isStream\");\n    isStream.writable = (stream2) => isStream(stream2) && stream2.writable !== false && typeof stream2._write === \"function\" && typeof stream2._writableState === \"object\";\n    isStream.readable = (stream2) => isStream(stream2) && stream2.readable !== false && typeof stream2._read === \"function\" && typeof stream2._readableState === \"object\";\n    isStream.duplex = (stream2) => isStream.writable(stream2) && isStream.readable(stream2);\n    isStream.transform = (stream2) => isStream.duplex(stream2) && typeof stream2._transform === \"function\";\n    module2.exports = isStream;\n  }\n});\n\n// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js\nvar require_buffer_stream = __commonJS({\n  \"../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js\"(exports, module2) {\n    \"use strict\";\n    var { PassThrough: PassThroughStream } = __webpack_require__(/*! stream */ \"stream\");\n    module2.exports = (options) => {\n      options = { ...options };\n      const { array } = options;\n      let { encoding } = options;\n      const isBuffer = encoding === \"buffer\";\n      let objectMode = false;\n      if (array) {\n        objectMode = !(encoding || isBuffer);\n      } else {\n        encoding = encoding || \"utf8\";\n      }\n      if (isBuffer) {\n        encoding = null;\n      }\n      const stream2 = new PassThroughStream({ objectMode });\n      if (encoding) {\n        stream2.setEncoding(encoding);\n      }\n      let length = 0;\n      const chunks = [];\n      stream2.on(\"data\", (chunk) => {\n        chunks.push(chunk);\n        if (objectMode) {\n          length = chunks.length;\n        } else {\n          length += chunk.length;\n        }\n      });\n      stream2.getBufferedValue = () => {\n        if (array) {\n          return chunks;\n        }\n        return isBuffer ? Buffer.concat(chunks, length) : chunks.join(\"\");\n      };\n      stream2.getBufferedLength = () => length;\n      return stream2;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js\nvar require_get_stream = __commonJS({\n  \"../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var { constants: BufferConstants } = __webpack_require__(/*! buffer */ \"buffer\");\n    var stream2 = __webpack_require__(/*! stream */ \"stream\");\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var bufferStream = require_buffer_stream();\n    var streamPipelinePromisified = promisify4(stream2.pipeline);\n    var MaxBufferError = class extends Error {\n      constructor() {\n        super(\"maxBuffer exceeded\");\n        this.name = \"MaxBufferError\";\n      }\n    };\n    __name(MaxBufferError, \"MaxBufferError\");\n    async function getStream2(inputStream, options) {\n      if (!inputStream) {\n        throw new Error(\"Expected a stream\");\n      }\n      options = {\n        maxBuffer: Infinity,\n        ...options\n      };\n      const { maxBuffer } = options;\n      const stream3 = bufferStream(options);\n      await new Promise((resolve, reject) => {\n        const rejectPromise = /* @__PURE__ */ __name((error2) => {\n          if (error2 && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n            error2.bufferedData = stream3.getBufferedValue();\n          }\n          reject(error2);\n        }, \"rejectPromise\");\n        (async () => {\n          try {\n            await streamPipelinePromisified(inputStream, stream3);\n            resolve();\n          } catch (error2) {\n            rejectPromise(error2);\n          }\n        })();\n        stream3.on(\"data\", () => {\n          if (stream3.getBufferedLength() > maxBuffer) {\n            rejectPromise(new MaxBufferError());\n          }\n        });\n      });\n      return stream3.getBufferedValue();\n    }\n    __name(getStream2, \"getStream\");\n    module2.exports = getStream2;\n    module2.exports.buffer = (stream3, options) => getStream2(stream3, { ...options, encoding: \"buffer\" });\n    module2.exports.array = (stream3, options) => getStream2(stream3, { ...options, array: true });\n    module2.exports.MaxBufferError = MaxBufferError;\n  }\n});\n\n// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js\nvar require_merge_stream = __commonJS({\n  \"../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var { PassThrough } = __webpack_require__(/*! stream */ \"stream\");\n    module2.exports = function() {\n      var sources = [];\n      var output = new PassThrough({ objectMode: true });\n      output.setMaxListeners(0);\n      output.add = add2;\n      output.isEmpty = isEmpty;\n      output.on(\"unpipe\", remove);\n      Array.prototype.slice.call(arguments).forEach(add2);\n      return output;\n      function add2(source) {\n        if (Array.isArray(source)) {\n          source.forEach(add2);\n          return this;\n        }\n        sources.push(source);\n        source.once(\"end\", remove.bind(null, source));\n        source.once(\"error\", output.emit.bind(output, \"error\"));\n        source.pipe(output, { end: false });\n        return this;\n      }\n      __name(add2, \"add\");\n      function isEmpty() {\n        return sources.length == 0;\n      }\n      __name(isEmpty, \"isEmpty\");\n      function remove(source) {\n        sources = sources.filter(function(it) {\n          return it !== source;\n        });\n        if (!sources.length && output.readable) {\n          output.end();\n        }\n      }\n      __name(remove, \"remove\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js\nvar require_stream = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js\"(exports, module2) {\n    \"use strict\";\n    var isStream = require_is_stream();\n    var getStream2 = require_get_stream();\n    var mergeStream = require_merge_stream();\n    var handleInput = /* @__PURE__ */ __name((spawned, input) => {\n      if (input === void 0 || spawned.stdin === void 0) {\n        return;\n      }\n      if (isStream(input)) {\n        input.pipe(spawned.stdin);\n      } else {\n        spawned.stdin.end(input);\n      }\n    }, \"handleInput\");\n    var makeAllStream = /* @__PURE__ */ __name((spawned, { all }) => {\n      if (!all || !spawned.stdout && !spawned.stderr) {\n        return;\n      }\n      const mixed = mergeStream();\n      if (spawned.stdout) {\n        mixed.add(spawned.stdout);\n      }\n      if (spawned.stderr) {\n        mixed.add(spawned.stderr);\n      }\n      return mixed;\n    }, \"makeAllStream\");\n    var getBufferedData = /* @__PURE__ */ __name(async (stream2, streamPromise) => {\n      if (!stream2) {\n        return;\n      }\n      stream2.destroy();\n      try {\n        return await streamPromise;\n      } catch (error2) {\n        return error2.bufferedData;\n      }\n    }, \"getBufferedData\");\n    var getStreamPromise = /* @__PURE__ */ __name((stream2, { encoding, buffer, maxBuffer }) => {\n      if (!stream2 || !buffer) {\n        return;\n      }\n      if (encoding) {\n        return getStream2(stream2, { encoding, maxBuffer });\n      }\n      return getStream2.buffer(stream2, { maxBuffer });\n    }, \"getStreamPromise\");\n    var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {\n      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });\n      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });\n      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });\n      try {\n        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n      } catch (error2) {\n        return Promise.all([\n          { error: error2, signal: error2.signal, timedOut: error2.timedOut },\n          getBufferedData(stdout, stdoutPromise),\n          getBufferedData(stderr, stderrPromise),\n          getBufferedData(all, allPromise)\n        ]);\n      }\n    }, \"getSpawnedResult\");\n    var validateInputSync = /* @__PURE__ */ __name(({ input }) => {\n      if (isStream(input)) {\n        throw new TypeError(\"The `input` option cannot be a stream in sync mode\");\n      }\n    }, \"validateInputSync\");\n    module2.exports = {\n      handleInput,\n      makeAllStream,\n      getSpawnedResult,\n      validateInputSync\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js\nvar require_promise = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js\"(exports, module2) {\n    \"use strict\";\n    var nativePromisePrototype = (async () => {\n    })().constructor.prototype;\n    var descriptors = [\"then\", \"catch\", \"finally\"].map((property) => [\n      property,\n      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)\n    ]);\n    var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {\n      for (const [property, descriptor] of descriptors) {\n        const value = typeof promise === \"function\" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);\n        Reflect.defineProperty(spawned, property, { ...descriptor, value });\n      }\n      return spawned;\n    }, \"mergePromise\");\n    var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {\n      return new Promise((resolve, reject) => {\n        spawned.on(\"exit\", (exitCode, signal) => {\n          resolve({ exitCode, signal });\n        });\n        spawned.on(\"error\", (error2) => {\n          reject(error2);\n        });\n        if (spawned.stdin) {\n          spawned.stdin.on(\"error\", (error2) => {\n            reject(error2);\n          });\n        }\n      });\n    }, \"getSpawnedPromise\");\n    module2.exports = {\n      mergePromise,\n      getSpawnedPromise\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js\nvar require_command = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js\"(exports, module2) {\n    \"use strict\";\n    var normalizeArgs = /* @__PURE__ */ __name((file, args = []) => {\n      if (!Array.isArray(args)) {\n        return [file];\n      }\n      return [file, ...args];\n    }, \"normalizeArgs\");\n    var NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\n    var DOUBLE_QUOTES_REGEXP = /\"/g;\n    var escapeArg = /* @__PURE__ */ __name((arg2) => {\n      if (typeof arg2 !== \"string\" || NO_ESCAPE_REGEXP.test(arg2)) {\n        return arg2;\n      }\n      return `\"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n    }, \"escapeArg\");\n    var joinCommand = /* @__PURE__ */ __name((file, args) => {\n      return normalizeArgs(file, args).join(\" \");\n    }, \"joinCommand\");\n    var getEscapedCommand = /* @__PURE__ */ __name((file, args) => {\n      return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(\" \");\n    }, \"getEscapedCommand\");\n    var SPACES_REGEXP = / +/g;\n    var parseCommand = /* @__PURE__ */ __name((command) => {\n      const tokens = [];\n      for (const token of command.trim().split(SPACES_REGEXP)) {\n        const previousToken = tokens[tokens.length - 1];\n        if (previousToken && previousToken.endsWith(\"\\\\\")) {\n          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n        } else {\n          tokens.push(token);\n        }\n      }\n      return tokens;\n    }, \"parseCommand\");\n    module2.exports = {\n      joinCommand,\n      getEscapedCommand,\n      parseCommand\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js\nvar require_execa = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var childProcess = __webpack_require__(/*! child_process */ \"child_process\");\n    var crossSpawn = require_cross_spawn();\n    var stripFinalNewline = require_strip_final_newline();\n    var npmRunPath = require_npm_run_path();\n    var onetime = require_onetime();\n    var makeError = require_error();\n    var normalizeStdio = require_stdio();\n    var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();\n    var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();\n    var { mergePromise, getSpawnedPromise } = require_promise();\n    var { joinCommand, parseCommand, getEscapedCommand } = require_command();\n    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;\n    var getEnv2 = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {\n      const env2 = extendEnv ? { ...process.env, ...envOption } : envOption;\n      if (preferLocal) {\n        return npmRunPath.env({ env: env2, cwd: localDir, execPath });\n      }\n      return env2;\n    }, \"getEnv\");\n    var handleArguments = /* @__PURE__ */ __name((file, args, options = {}) => {\n      const parsed = crossSpawn._parse(file, args, options);\n      file = parsed.command;\n      args = parsed.args;\n      options = parsed.options;\n      options = {\n        maxBuffer: DEFAULT_MAX_BUFFER,\n        buffer: true,\n        stripFinalNewline: true,\n        extendEnv: true,\n        preferLocal: false,\n        localDir: options.cwd || process.cwd(),\n        execPath: process.execPath,\n        encoding: \"utf8\",\n        reject: true,\n        cleanup: true,\n        all: false,\n        windowsHide: true,\n        ...options\n      };\n      options.env = getEnv2(options);\n      options.stdio = normalizeStdio(options);\n      if (process.platform === \"win32\" && path7.basename(file, \".exe\") === \"cmd\") {\n        args.unshift(\"/q\");\n      }\n      return { file, args, options, parsed };\n    }, \"handleArguments\");\n    var handleOutput = /* @__PURE__ */ __name((options, value, error2) => {\n      if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n        return error2 === void 0 ? void 0 : \"\";\n      }\n      if (options.stripFinalNewline) {\n        return stripFinalNewline(value);\n      }\n      return value;\n    }, \"handleOutput\");\n    var execa2 = /* @__PURE__ */ __name((file, args, options) => {\n      const parsed = handleArguments(file, args, options);\n      const command = joinCommand(file, args);\n      const escapedCommand = getEscapedCommand(file, args);\n      validateTimeout(parsed.options);\n      let spawned;\n      try {\n        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n      } catch (error2) {\n        const dummySpawned = new childProcess.ChildProcess();\n        const errorPromise = Promise.reject(makeError({\n          error: error2,\n          stdout: \"\",\n          stderr: \"\",\n          all: \"\",\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        }));\n        return mergePromise(dummySpawned, errorPromise);\n      }\n      const spawnedPromise = getSpawnedPromise(spawned);\n      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n      const processDone = setExitHandler(spawned, parsed.options, timedPromise);\n      const context3 = { isCanceled: false };\n      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n      spawned.cancel = spawnedCancel.bind(null, spawned, context3);\n      const handlePromise = /* @__PURE__ */ __name(async () => {\n        const [{ error: error2, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n        const stdout = handleOutput(parsed.options, stdoutResult);\n        const stderr = handleOutput(parsed.options, stderrResult);\n        const all = handleOutput(parsed.options, allResult);\n        if (error2 || exitCode !== 0 || signal !== null) {\n          const returnedError = makeError({\n            error: error2,\n            exitCode,\n            signal,\n            stdout,\n            stderr,\n            all,\n            command,\n            escapedCommand,\n            parsed,\n            timedOut,\n            isCanceled: context3.isCanceled,\n            killed: spawned.killed\n          });\n          if (!parsed.options.reject) {\n            return returnedError;\n          }\n          throw returnedError;\n        }\n        return {\n          command,\n          escapedCommand,\n          exitCode: 0,\n          stdout,\n          stderr,\n          all,\n          failed: false,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        };\n      }, \"handlePromise\");\n      const handlePromiseOnce = onetime(handlePromise);\n      handleInput(spawned, parsed.options.input);\n      spawned.all = makeAllStream(spawned, parsed.options);\n      return mergePromise(spawned, handlePromiseOnce);\n    }, \"execa\");\n    module2.exports = execa2;\n    module2.exports.sync = (file, args, options) => {\n      const parsed = handleArguments(file, args, options);\n      const command = joinCommand(file, args);\n      const escapedCommand = getEscapedCommand(file, args);\n      validateInputSync(parsed.options);\n      let result;\n      try {\n        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n      } catch (error2) {\n        throw makeError({\n          error: error2,\n          stdout: \"\",\n          stderr: \"\",\n          all: \"\",\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        });\n      }\n      const stdout = handleOutput(parsed.options, result.stdout, result.error);\n      const stderr = handleOutput(parsed.options, result.stderr, result.error);\n      if (result.error || result.status !== 0 || result.signal !== null) {\n        const error2 = makeError({\n          stdout,\n          stderr,\n          error: result.error,\n          signal: result.signal,\n          exitCode: result.status,\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: result.error && result.error.code === \"ETIMEDOUT\",\n          isCanceled: false,\n          killed: result.signal !== null\n        });\n        if (!parsed.options.reject) {\n          return error2;\n        }\n        throw error2;\n      }\n      return {\n        command,\n        escapedCommand,\n        exitCode: 0,\n        stdout,\n        stderr,\n        failed: false,\n        timedOut: false,\n        isCanceled: false,\n        killed: false\n      };\n    };\n    module2.exports.command = (command, options) => {\n      const [file, ...args] = parseCommand(command);\n      return execa2(file, args, options);\n    };\n    module2.exports.commandSync = (command, options) => {\n      const [file, ...args] = parseCommand(command);\n      return execa2.sync(file, args, options);\n    };\n    module2.exports.node = (scriptPath, args, options = {}) => {\n      if (args && !Array.isArray(args) && typeof args === \"object\") {\n        options = args;\n        args = [];\n      }\n      const stdio = normalizeStdio.node(options);\n      const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith(\"--inspect\"));\n      const {\n        nodePath = process.execPath,\n        nodeOptions = defaultExecArgv\n      } = options;\n      return execa2(\n        nodePath,\n        [\n          ...nodeOptions,\n          scriptPath,\n          ...Array.isArray(args) ? args : []\n        ],\n        {\n          ...options,\n          stdin: void 0,\n          stdout: void 0,\n          stderr: void 0,\n          stdio,\n          shell: false\n        }\n      );\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js\nvar require_retry_operation = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js\"(exports, module2) {\n    function RetryOperation(timeouts, options) {\n      if (typeof options === \"boolean\") {\n        options = { forever: options };\n      }\n      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n      this._timeouts = timeouts;\n      this._options = options || {};\n      this._maxRetryTime = options && options.maxRetryTime || Infinity;\n      this._fn = null;\n      this._errors = [];\n      this._attempts = 1;\n      this._operationTimeout = null;\n      this._operationTimeoutCb = null;\n      this._timeout = null;\n      this._operationStart = null;\n      this._timer = null;\n      if (this._options.forever) {\n        this._cachedTimeouts = this._timeouts.slice(0);\n      }\n    }\n    __name(RetryOperation, \"RetryOperation\");\n    module2.exports = RetryOperation;\n    RetryOperation.prototype.reset = function() {\n      this._attempts = 1;\n      this._timeouts = this._originalTimeouts.slice(0);\n    };\n    RetryOperation.prototype.stop = function() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n      if (this._timer) {\n        clearTimeout(this._timer);\n      }\n      this._timeouts = [];\n      this._cachedTimeouts = null;\n    };\n    RetryOperation.prototype.retry = function(err) {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n      if (!err) {\n        return false;\n      }\n      var currentTime = new Date().getTime();\n      if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n        this._errors.push(err);\n        this._errors.unshift(new Error(\"RetryOperation timeout occurred\"));\n        return false;\n      }\n      this._errors.push(err);\n      var timeout = this._timeouts.shift();\n      if (timeout === void 0) {\n        if (this._cachedTimeouts) {\n          this._errors.splice(0, this._errors.length - 1);\n          timeout = this._cachedTimeouts.slice(-1);\n        } else {\n          return false;\n        }\n      }\n      var self2 = this;\n      this._timer = setTimeout(function() {\n        self2._attempts++;\n        if (self2._operationTimeoutCb) {\n          self2._timeout = setTimeout(function() {\n            self2._operationTimeoutCb(self2._attempts);\n          }, self2._operationTimeout);\n          if (self2._options.unref) {\n            self2._timeout.unref();\n          }\n        }\n        self2._fn(self2._attempts);\n      }, timeout);\n      if (this._options.unref) {\n        this._timer.unref();\n      }\n      return true;\n    };\n    RetryOperation.prototype.attempt = function(fn, timeoutOps) {\n      this._fn = fn;\n      if (timeoutOps) {\n        if (timeoutOps.timeout) {\n          this._operationTimeout = timeoutOps.timeout;\n        }\n        if (timeoutOps.cb) {\n          this._operationTimeoutCb = timeoutOps.cb;\n        }\n      }\n      var self2 = this;\n      if (this._operationTimeoutCb) {\n        this._timeout = setTimeout(function() {\n          self2._operationTimeoutCb();\n        }, self2._operationTimeout);\n      }\n      this._operationStart = new Date().getTime();\n      this._fn(this._attempts);\n    };\n    RetryOperation.prototype.try = function(fn) {\n      console.log(\"Using RetryOperation.try() is deprecated\");\n      this.attempt(fn);\n    };\n    RetryOperation.prototype.start = function(fn) {\n      console.log(\"Using RetryOperation.start() is deprecated\");\n      this.attempt(fn);\n    };\n    RetryOperation.prototype.start = RetryOperation.prototype.try;\n    RetryOperation.prototype.errors = function() {\n      return this._errors;\n    };\n    RetryOperation.prototype.attempts = function() {\n      return this._attempts;\n    };\n    RetryOperation.prototype.mainError = function() {\n      if (this._errors.length === 0) {\n        return null;\n      }\n      var counts = {};\n      var mainError = null;\n      var mainErrorCount = 0;\n      for (var i = 0; i < this._errors.length; i++) {\n        var error2 = this._errors[i];\n        var message = error2.message;\n        var count2 = (counts[message] || 0) + 1;\n        counts[message] = count2;\n        if (count2 >= mainErrorCount) {\n          mainError = error2;\n          mainErrorCount = count2;\n        }\n      }\n      return mainError;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js\nvar require_retry = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js\"(exports) {\n    var RetryOperation = require_retry_operation();\n    exports.operation = function(options) {\n      var timeouts = exports.timeouts(options);\n      return new RetryOperation(timeouts, {\n        forever: options && (options.forever || options.retries === Infinity),\n        unref: options && options.unref,\n        maxRetryTime: options && options.maxRetryTime\n      });\n    };\n    exports.timeouts = function(options) {\n      if (options instanceof Array) {\n        return [].concat(options);\n      }\n      var opts = {\n        retries: 10,\n        factor: 2,\n        minTimeout: 1 * 1e3,\n        maxTimeout: Infinity,\n        randomize: false\n      };\n      for (var key in options) {\n        opts[key] = options[key];\n      }\n      if (opts.minTimeout > opts.maxTimeout) {\n        throw new Error(\"minTimeout is greater than maxTimeout\");\n      }\n      var timeouts = [];\n      for (var i = 0; i < opts.retries; i++) {\n        timeouts.push(this.createTimeout(i, opts));\n      }\n      if (options && options.forever && !timeouts.length) {\n        timeouts.push(this.createTimeout(i, opts));\n      }\n      timeouts.sort(function(a, b) {\n        return a - b;\n      });\n      return timeouts;\n    };\n    exports.createTimeout = function(attempt, opts) {\n      var random2 = opts.randomize ? Math.random() + 1 : 1;\n      var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n      timeout = Math.min(timeout, opts.maxTimeout);\n      return timeout;\n    };\n    exports.wrap = function(obj, options, methods) {\n      if (options instanceof Array) {\n        methods = options;\n        options = null;\n      }\n      if (!methods) {\n        methods = [];\n        for (var key in obj) {\n          if (typeof obj[key] === \"function\") {\n            methods.push(key);\n          }\n        }\n      }\n      for (var i = 0; i < methods.length; i++) {\n        var method = methods[i];\n        var original = obj[method];\n        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {\n          var op = exports.operation(options);\n          var args = Array.prototype.slice.call(arguments, 1);\n          var callback = args.pop();\n          args.push(function(err) {\n            if (op.retry(err)) {\n              return;\n            }\n            if (err) {\n              arguments[0] = op.mainError();\n            }\n            callback.apply(this, arguments);\n          });\n          op.attempt(function() {\n            original2.apply(obj, args);\n          });\n        }, \"retryWrapper\")).bind(obj, original);\n        obj[method].options = options;\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js\nvar require_retry2 = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js\"(exports, module2) {\n    module2.exports = require_retry();\n  }\n});\n\n// ../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js\nvar require_p_retry = __commonJS({\n  \"../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js\"(exports, module2) {\n    \"use strict\";\n    var retry = require_retry2();\n    var networkErrorMsgs = [\n      \"Failed to fetch\",\n      \"NetworkError when attempting to fetch resource.\",\n      \"The Internet connection appears to be offline.\",\n      \"Network request failed\"\n    ];\n    var AbortError = class extends Error {\n      constructor(message) {\n        super();\n        if (message instanceof Error) {\n          this.originalError = message;\n          ({ message } = message);\n        } else {\n          this.originalError = new Error(message);\n          this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n      }\n    };\n    __name(AbortError, \"AbortError\");\n    var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options) => {\n      const retriesLeft = options.retries - (attemptNumber - 1);\n      error2.attemptNumber = attemptNumber;\n      error2.retriesLeft = retriesLeft;\n      return error2;\n    }, \"decorateErrorWithCounts\");\n    var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), \"isNetworkError\");\n    var pRetry2 = /* @__PURE__ */ __name((input, options) => new Promise((resolve, reject) => {\n      options = {\n        onFailedAttempt: () => {\n        },\n        retries: 10,\n        ...options\n      };\n      const operation = retry.operation(options);\n      operation.attempt(async (attemptNumber) => {\n        try {\n          resolve(await input(attemptNumber));\n        } catch (error2) {\n          if (!(error2 instanceof Error)) {\n            reject(new TypeError(`Non-error was thrown: \"${error2}\". You should only throw errors.`));\n            return;\n          }\n          if (error2 instanceof AbortError) {\n            operation.stop();\n            reject(error2.originalError);\n          } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {\n            operation.stop();\n            reject(error2);\n          } else {\n            decorateErrorWithCounts(error2, attemptNumber, options);\n            try {\n              await options.onFailedAttempt(error2);\n            } catch (error3) {\n              reject(error3);\n              return;\n            }\n            if (!operation.retry(error2)) {\n              reject(operation.mainError());\n            }\n          }\n        }\n      });\n    }), \"pRetry\");\n    module2.exports = pRetry2;\n    module2.exports.default = pRetry2;\n    module2.exports.AbortError = AbortError;\n  }\n});\n\n// ../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js\nvar require_ansi_regex = __commonJS({\n  \"../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = ({ onlyFirst = false } = {}) => {\n      const pattern = [\n        \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n        \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"\n      ].join(\"|\");\n      return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js\nvar require_strip_ansi = __commonJS({\n  \"../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js\"(exports, module2) {\n    \"use strict\";\n    var ansiRegex = require_ansi_regex();\n    module2.exports = (string) => typeof string === \"string\" ? string.replace(ansiRegex(), \"\") : string;\n  }\n});\n\n// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js\nvar require_new_github_issue_url = __commonJS({\n  \"../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (options = {}) => {\n      let repoUrl;\n      if (options.repoUrl) {\n        repoUrl = options.repoUrl;\n      } else if (options.user && options.repo) {\n        repoUrl = `https://github.com/${options.user}/${options.repo}`;\n      } else {\n        throw new Error(\"You need to specify either the `repoUrl` option or both the `user` and `repo` options\");\n      }\n      const url = new URL(`${repoUrl}/issues/new`);\n      const types = [\n        \"body\",\n        \"title\",\n        \"labels\",\n        \"template\",\n        \"milestone\",\n        \"assignee\",\n        \"projects\"\n      ];\n      for (const type of types) {\n        let value = options[type];\n        if (value === void 0) {\n          continue;\n        }\n        if (type === \"labels\" || type === \"projects\") {\n          if (!Array.isArray(value)) {\n            throw new TypeError(`The \\`${type}\\` option should be an array`);\n          }\n          value = value.join(\",\");\n        }\n        url.searchParams.set(type, value);\n      }\n      return url.toString();\n    };\n    module2.exports.default = module2.exports;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/symbols.js\nvar require_symbols = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/symbols.js\"(exports, module2) {\n    module2.exports = {\n      kClose: Symbol(\"close\"),\n      kDestroy: Symbol(\"destroy\"),\n      kDispatch: Symbol(\"dispatch\"),\n      kUrl: Symbol(\"url\"),\n      kWriting: Symbol(\"writing\"),\n      kResuming: Symbol(\"resuming\"),\n      kQueue: Symbol(\"queue\"),\n      kConnect: Symbol(\"connect\"),\n      kConnecting: Symbol(\"connecting\"),\n      kHeadersList: Symbol(\"headers list\"),\n      kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n      kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n      kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n      kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n      kKeepAlive: Symbol(\"keep alive\"),\n      kHeadersTimeout: Symbol(\"headers timeout\"),\n      kBodyTimeout: Symbol(\"body timeout\"),\n      kServerName: Symbol(\"server name\"),\n      kHost: Symbol(\"host\"),\n      kNoRef: Symbol(\"no ref\"),\n      kBodyUsed: Symbol(\"used\"),\n      kRunning: Symbol(\"running\"),\n      kBlocking: Symbol(\"blocking\"),\n      kPending: Symbol(\"pending\"),\n      kSize: Symbol(\"size\"),\n      kBusy: Symbol(\"busy\"),\n      kQueued: Symbol(\"queued\"),\n      kFree: Symbol(\"free\"),\n      kConnected: Symbol(\"connected\"),\n      kClosed: Symbol(\"closed\"),\n      kNeedDrain: Symbol(\"need drain\"),\n      kReset: Symbol(\"reset\"),\n      kDestroyed: Symbol(\"destroyed\"),\n      kMaxHeadersSize: Symbol(\"max headers size\"),\n      kRunningIdx: Symbol(\"running index\"),\n      kPendingIdx: Symbol(\"pending index\"),\n      kError: Symbol(\"error\"),\n      kClients: Symbol(\"clients\"),\n      kClient: Symbol(\"client\"),\n      kParser: Symbol(\"parser\"),\n      kOnDestroyed: Symbol(\"destroy callbacks\"),\n      kPipelining: Symbol(\"pipelinig\"),\n      kSocket: Symbol(\"socket\"),\n      kHostHeader: Symbol(\"host header\"),\n      kConnector: Symbol(\"connector\"),\n      kStrictContentLength: Symbol(\"strict content length\"),\n      kMaxRedirections: Symbol(\"maxRedirections\"),\n      kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n      kProxy: Symbol(\"proxy agent options\"),\n      kCounter: Symbol(\"socket request counter\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/errors.js\nvar require_errors = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/errors.js\"(exports, module2) {\n    \"use strict\";\n    var UndiciError = class extends Error {\n      constructor(message) {\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n      }\n    };\n    __name(UndiciError, \"UndiciError\");\n    var ConnectTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n      }\n    };\n    __name(ConnectTimeoutError, \"ConnectTimeoutError\");\n    var HeadersTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n      }\n    };\n    __name(HeadersTimeoutError, \"HeadersTimeoutError\");\n    var HeadersOverflowError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n      }\n    };\n    __name(HeadersOverflowError, \"HeadersOverflowError\");\n    var BodyTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n      }\n    };\n    __name(BodyTimeoutError, \"BodyTimeoutError\");\n    var ResponseStatusCodeError = class extends UndiciError {\n      constructor(message, statusCode, headers, body) {\n        super(message);\n        Error.captureStackTrace(this, ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n      }\n    };\n    __name(ResponseStatusCodeError, \"ResponseStatusCodeError\");\n    var InvalidArgumentError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n      }\n    };\n    __name(InvalidArgumentError, \"InvalidArgumentError\");\n    var InvalidReturnValueError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n      }\n    };\n    __name(InvalidReturnValueError, \"InvalidReturnValueError\");\n    var RequestAbortedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n      }\n    };\n    __name(RequestAbortedError, \"RequestAbortedError\");\n    var InformationalError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n      }\n    };\n    __name(InformationalError, \"InformationalError\");\n    var RequestContentLengthMismatchError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(RequestContentLengthMismatchError, \"RequestContentLengthMismatchError\");\n    var ResponseContentLengthMismatchError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(ResponseContentLengthMismatchError, \"ResponseContentLengthMismatchError\");\n    var ClientDestroyedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n      }\n    };\n    __name(ClientDestroyedError, \"ClientDestroyedError\");\n    var ClientClosedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n      }\n    };\n    __name(ClientClosedError, \"ClientClosedError\");\n    var SocketError = class extends UndiciError {\n      constructor(message, socket) {\n        super(message);\n        Error.captureStackTrace(this, SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n      }\n    };\n    __name(SocketError, \"SocketError\");\n    var NotSupportedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n      }\n    };\n    __name(NotSupportedError, \"NotSupportedError\");\n    var BalancedPoolMissingUpstreamError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n      }\n    };\n    __name(BalancedPoolMissingUpstreamError, \"BalancedPoolMissingUpstreamError\");\n    var HTTPParserError = class extends Error {\n      constructor(message, code, data) {\n        super(message);\n        Error.captureStackTrace(this, HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : void 0;\n        this.data = data ? data.toString() : void 0;\n      }\n    };\n    __name(HTTPParserError, \"HTTPParserError\");\n    module2.exports = {\n      HTTPParserError,\n      UndiciError,\n      HeadersTimeoutError,\n      HeadersOverflowError,\n      BodyTimeoutError,\n      RequestContentLengthMismatchError,\n      ConnectTimeoutError,\n      ResponseStatusCodeError,\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError,\n      ClientDestroyedError,\n      ClientClosedError,\n      InformationalError,\n      SocketError,\n      NotSupportedError,\n      ResponseContentLengthMismatchError,\n      BalancedPoolMissingUpstreamError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/util.js\nvar require_util2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/util.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { kDestroyed, kBodyUsed } = require_symbols();\n    var { IncomingMessage } = __webpack_require__(/*! http */ \"http\");\n    var stream2 = __webpack_require__(/*! stream */ \"stream\");\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var { InvalidArgumentError } = require_errors();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var nodeUtil = __webpack_require__(/*! util */ \"util\");\n    function nop() {\n    }\n    __name(nop, \"nop\");\n    function isStream(obj) {\n      return obj && typeof obj.pipe === \"function\";\n    }\n    __name(isStream, \"isStream\");\n    function isBlobLike(object) {\n      return Blob && object instanceof Blob || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n    __name(isBlobLike, \"isBlobLike\");\n    function isObject3(val) {\n      return val !== null && typeof val === \"object\";\n    }\n    __name(isObject3, \"isObject\");\n    function encode(val) {\n      return encodeURIComponent(val);\n    }\n    __name(encode, \"encode\");\n    function buildURL(url, queryParams) {\n      if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n      }\n      if (!isObject3(queryParams)) {\n        throw new Error(\"Query params must be an object\");\n      }\n      const parts = [];\n      for (let [key, val] of Object.entries(queryParams)) {\n        if (val === null || typeof val === \"undefined\") {\n          continue;\n        }\n        if (!Array.isArray(val)) {\n          val = [val];\n        }\n        for (const v of val) {\n          if (isObject3(v)) {\n            throw new Error(\"Passing object as a query param is not supported, please serialize to string up-front\");\n          }\n          parts.push(encode(key) + \"=\" + encode(v));\n        }\n      }\n      const serializedParams = parts.join(\"&\");\n      if (serializedParams) {\n        url += \"?\" + serializedParams;\n      }\n      return url;\n    }\n    __name(buildURL, \"buildURL\");\n    function parseURL(url) {\n      if (typeof url === \"string\") {\n        url = new URL(url);\n      }\n      if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"invalid url\");\n      }\n      if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n        throw new InvalidArgumentError(\"invalid port\");\n      }\n      if (url.path != null && typeof url.path !== \"string\") {\n        throw new InvalidArgumentError(\"invalid path\");\n      }\n      if (url.pathname != null && typeof url.pathname !== \"string\") {\n        throw new InvalidArgumentError(\"invalid pathname\");\n      }\n      if (url.hostname != null && typeof url.hostname !== \"string\") {\n        throw new InvalidArgumentError(\"invalid hostname\");\n      }\n      if (url.origin != null && typeof url.origin !== \"string\") {\n        throw new InvalidArgumentError(\"invalid origin\");\n      }\n      if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"invalid protocol\");\n      }\n      if (!(url instanceof URL)) {\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;\n        let path7 = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin.endsWith(\"/\")) {\n          origin = origin.substring(0, origin.length - 1);\n        }\n        if (path7 && !path7.startsWith(\"/\")) {\n          path7 = `/${path7}`;\n        }\n        url = new URL(origin + path7);\n      }\n      return url;\n    }\n    __name(parseURL, \"parseURL\");\n    function parseOrigin(url) {\n      url = parseURL(url);\n      if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n      }\n      return url;\n    }\n    __name(parseOrigin, \"parseOrigin\");\n    function getHostname(host) {\n      if (host[0] === \"[\") {\n        const idx2 = host.indexOf(\"]\");\n        assert(idx2 !== -1);\n        return host.substr(1, idx2 - 1);\n      }\n      const idx = host.indexOf(\":\");\n      if (idx === -1)\n        return host;\n      return host.substr(0, idx);\n    }\n    __name(getHostname, \"getHostname\");\n    function getServerName(host) {\n      if (!host) {\n        return null;\n      }\n      assert.strictEqual(typeof host, \"string\");\n      const servername = getHostname(host);\n      if (net2.isIP(servername)) {\n        return \"\";\n      }\n      return servername;\n    }\n    __name(getServerName, \"getServerName\");\n    function deepClone2(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n    __name(deepClone2, \"deepClone\");\n    function isAsyncIterable(obj) {\n      return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n    }\n    __name(isAsyncIterable, \"isAsyncIterable\");\n    function isIterable(obj) {\n      return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n    }\n    __name(isIterable, \"isIterable\");\n    function bodyLength(body) {\n      if (body == null) {\n        return 0;\n      } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n      } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n      } else if (isBuffer(body)) {\n        return body.byteLength;\n      }\n      return null;\n    }\n    __name(bodyLength, \"bodyLength\");\n    function isDestroyed(stream3) {\n      return !stream3 || !!(stream3.destroyed || stream3[kDestroyed]);\n    }\n    __name(isDestroyed, \"isDestroyed\");\n    function isReadableAborted(stream3) {\n      const state = stream3 && stream3._readableState;\n      return isDestroyed(stream3) && state && !state.endEmitted;\n    }\n    __name(isReadableAborted, \"isReadableAborted\");\n    function destroy(stream3, err) {\n      if (!isStream(stream3) || isDestroyed(stream3)) {\n        return;\n      }\n      if (typeof stream3.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream3).constructor === IncomingMessage) {\n          stream3.socket = null;\n        }\n        stream3.destroy(err);\n      } else if (err) {\n        process.nextTick((stream4, err2) => {\n          stream4.emit(\"error\", err2);\n        }, stream3, err);\n      }\n      if (stream3.destroyed !== true) {\n        stream3[kDestroyed] = true;\n      }\n    }\n    __name(destroy, \"destroy\");\n    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\n    function parseKeepAliveTimeout(val) {\n      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n      return m ? parseInt(m[1], 10) * 1e3 : null;\n    }\n    __name(parseKeepAliveTimeout, \"parseKeepAliveTimeout\");\n    function parseHeaders(headers, obj = {}) {\n      for (let i = 0; i < headers.length; i += 2) {\n        const key = headers[i].toString().toLowerCase();\n        let val = obj[key];\n        if (!val) {\n          if (Array.isArray(headers[i + 1])) {\n            obj[key] = headers[i + 1];\n          } else {\n            obj[key] = headers[i + 1].toString();\n          }\n        } else {\n          if (!Array.isArray(val)) {\n            val = [val];\n            obj[key] = val;\n          }\n          val.push(headers[i + 1].toString());\n        }\n      }\n      return obj;\n    }\n    __name(parseHeaders, \"parseHeaders\");\n    function parseRawHeaders(headers) {\n      return headers.map((header) => header.toString());\n    }\n    __name(parseRawHeaders, \"parseRawHeaders\");\n    function isBuffer(buffer) {\n      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n    }\n    __name(isBuffer, \"isBuffer\");\n    function validateHandler(handler, method, upgrade) {\n      if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n      }\n      if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n      }\n      if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n      }\n      if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== void 0) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n      }\n      if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n      } else {\n        if (typeof handler.onHeaders !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n      }\n    }\n    __name(validateHandler, \"validateHandler\");\n    function isDisturbed(body) {\n      return !!(body && (stream2.isDisturbed ? stream2.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));\n    }\n    __name(isDisturbed, \"isDisturbed\");\n    function isErrored(body) {\n      return !!(body && (stream2.isErrored ? stream2.isErrored(body) : /state: 'errored'/.test(\n        nodeUtil.inspect(body)\n      )));\n    }\n    __name(isErrored, \"isErrored\");\n    function isReadable(body) {\n      return !!(body && (stream2.isReadable ? stream2.isReadable(body) : /state: 'readable'/.test(\n        nodeUtil.inspect(body)\n      )));\n    }\n    __name(isReadable, \"isReadable\");\n    function getSocketInfo(socket) {\n      return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n      };\n    }\n    __name(getSocketInfo, \"getSocketInfo\");\n    var ReadableStream;\n    function ReadableStreamFrom(iterable) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      if (ReadableStream.from) {\n        return ReadableStream.from(iterable);\n      }\n      let iterator;\n      return new ReadableStream(\n        {\n          async start() {\n            iterator = iterable[Symbol.asyncIterator]();\n          },\n          async pull(controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n              queueMicrotask(() => {\n                controller.close();\n              });\n            } else {\n              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n              controller.enqueue(new Uint8Array(buf));\n            }\n            return controller.desiredSize > 0;\n          },\n          async cancel(reason) {\n            await iterator.return();\n          }\n        },\n        0\n      );\n    }\n    __name(ReadableStreamFrom, \"ReadableStreamFrom\");\n    function isFormDataLike(chunk) {\n      return chunk && chunk.constructor && chunk.constructor.name === \"FormData\";\n    }\n    __name(isFormDataLike, \"isFormDataLike\");\n    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);\n    kEnumerableProperty.enumerable = true;\n    module2.exports = {\n      kEnumerableProperty,\n      nop,\n      isDisturbed,\n      isErrored,\n      isReadable,\n      toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),\n      isReadableAborted,\n      isBlobLike,\n      parseOrigin,\n      parseURL,\n      getServerName,\n      isStream,\n      isIterable,\n      isAsyncIterable,\n      isDestroyed,\n      parseRawHeaders,\n      parseHeaders,\n      parseKeepAliveTimeout,\n      destroy,\n      bodyLength,\n      deepClone: deepClone2,\n      ReadableStreamFrom,\n      isBuffer,\n      validateHandler,\n      getSocketInfo,\n      isFormDataLike,\n      buildURL\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/constants.js\nvar require_constants = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/constants.js\"(exports, module2) {\n    \"use strict\";\n    var corsSafeListedMethods = [\"GET\", \"HEAD\", \"POST\"];\n    var nullBodyStatus = [101, 204, 205, 304];\n    var redirectStatus = [301, 302, 303, 307, 308];\n    var referrerPolicy = [\n      \"\",\n      \"no-referrer\",\n      \"no-referrer-when-downgrade\",\n      \"same-origin\",\n      \"origin\",\n      \"strict-origin\",\n      \"origin-when-cross-origin\",\n      \"strict-origin-when-cross-origin\",\n      \"unsafe-url\"\n    ];\n    var requestRedirect = [\"follow\", \"manual\", \"error\"];\n    var safeMethods = [\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"];\n    var requestMode = [\"navigate\", \"same-origin\", \"no-cors\", \"cors\"];\n    var requestCredentials = [\"omit\", \"same-origin\", \"include\"];\n    var requestCache = [\n      \"default\",\n      \"no-store\",\n      \"reload\",\n      \"no-cache\",\n      \"force-cache\",\n      \"only-if-cached\"\n    ];\n    var requestBodyHeader = [\n      \"content-encoding\",\n      \"content-language\",\n      \"content-location\",\n      \"content-type\"\n    ];\n    var forbiddenMethods = [\"CONNECT\", \"TRACE\", \"TRACK\"];\n    var subresource = [\n      \"audio\",\n      \"audioworklet\",\n      \"font\",\n      \"image\",\n      \"manifest\",\n      \"paintworklet\",\n      \"script\",\n      \"style\",\n      \"track\",\n      \"video\",\n      \"xslt\",\n      \"\"\n    ];\n    var _a3;\n    var DOMException = (_a3 = globalThis.DOMException) != null ? _a3 : (() => {\n      try {\n        atob(\"~\");\n      } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n      }\n    })();\n    module2.exports = {\n      DOMException,\n      subresource,\n      forbiddenMethods,\n      requestBodyHeader,\n      referrerPolicy,\n      requestRedirect,\n      requestMode,\n      requestCredentials,\n      requestCache,\n      redirectStatus,\n      corsSafeListedMethods,\n      nullBodyStatus,\n      safeMethods\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/symbols.js\nvar require_symbols2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/symbols.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      kUrl: Symbol(\"url\"),\n      kHeaders: Symbol(\"headers\"),\n      kSignal: Symbol(\"signal\"),\n      kState: Symbol(\"state\"),\n      kGuard: Symbol(\"guard\"),\n      kRealm: Symbol(\"realm\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/webidl.js\nvar require_webidl = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/webidl.js\"(exports, module2) {\n    \"use strict\";\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var { hasOwn, toUSVString } = require_util3();\n    var webidl = {};\n    webidl.converters = {};\n    webidl.util = {};\n    webidl.errors = {};\n    webidl.errors.exception = function(message) {\n      throw new TypeError(`${message.header}: ${message.message}`);\n    };\n    webidl.errors.conversionFailed = function(context3) {\n      const plural = context3.types.length === 1 ? \"\" : \" one of\";\n      const message = `${context3.argument} could not be converted to${plural}: ${context3.types.join(\", \")}.`;\n      return webidl.errors.exception({\n        header: context3.prefix,\n        message\n      });\n    };\n    webidl.errors.invalidArgument = function(context3) {\n      return webidl.errors.exception({\n        header: context3.prefix,\n        message: `\"${context3.value}\" is an invalid ${context3.type}.`\n      });\n    };\n    webidl.util.Type = function(V) {\n      switch (typeof V) {\n        case \"undefined\":\n          return \"Undefined\";\n        case \"boolean\":\n          return \"Boolean\";\n        case \"string\":\n          return \"String\";\n        case \"symbol\":\n          return \"Symbol\";\n        case \"number\":\n          return \"Number\";\n        case \"bigint\":\n          return \"BigInt\";\n        case \"function\":\n        case \"object\": {\n          if (V === null) {\n            return \"Null\";\n          }\n          return \"Object\";\n        }\n      }\n    };\n    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n      let upperBound;\n      let lowerBound;\n      if (bitLength === 64) {\n        upperBound = Math.pow(2, 53) - 1;\n        if (signedness === \"unsigned\") {\n          lowerBound = 0;\n        } else {\n          lowerBound = Math.pow(-2, 53) + 1;\n        }\n      } else if (signedness === \"unsigned\") {\n        lowerBound = 0;\n        upperBound = Math.pow(2, bitLength) - 1;\n      } else {\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n      }\n      let x = Number(V);\n      if (Object.is(-0, x)) {\n        x = 0;\n      }\n      if (opts.enforceRange === true) {\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n          webidl.errors.exception({\n            header: \"Integer conversion\",\n            message: `Could not convert ${V} to an integer.`\n          });\n        }\n        x = webidl.util.IntegerPart(x);\n        if (x < lowerBound || x > upperBound) {\n          webidl.errors.exception({\n            header: \"Integer conversion\",\n            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n          });\n        }\n        return x;\n      }\n      if (!Number.isNaN(x) && opts.clamp === true) {\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        if (Math.floor(x) % 2 === 0) {\n          x = Math.floor(x);\n        } else {\n          x = Math.ceil(x);\n        }\n        return x;\n      }\n      if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n      }\n      x = webidl.util.IntegerPart(x);\n      x = x % Math.pow(2, bitLength);\n      if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n      }\n      return x;\n    };\n    webidl.util.IntegerPart = function(n) {\n      const r = Math.floor(Math.abs(n));\n      if (n < 0) {\n        return -1 * r;\n      }\n      return r;\n    };\n    webidl.sequenceConverter = function(converter) {\n      return (V) => {\n        var _a3;\n        if (webidl.util.Type(V) !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Sequence\",\n            message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n          });\n        }\n        const method = (_a3 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a3.call(V);\n        const seq = [];\n        if (method === void 0 || typeof method.next !== \"function\") {\n          webidl.errors.exception({\n            header: \"Sequence\",\n            message: \"Object is not an iterator.\"\n          });\n        }\n        while (true) {\n          const { done, value } = method.next();\n          if (done) {\n            break;\n          }\n          seq.push(converter(value));\n        }\n        return seq;\n      };\n    };\n    webidl.recordConverter = function(keyConverter, valueConverter) {\n      return (V) => {\n        const record = {};\n        const type = webidl.util.Type(V);\n        if (type === \"Undefined\" || type === \"Null\") {\n          return record;\n        }\n        if (type !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Record\",\n            message: `Expected ${V} to be an Object type.`\n          });\n        }\n        for (let [key, value] of Object.entries(V)) {\n          key = keyConverter(key);\n          value = valueConverter(value);\n          record[key] = value;\n        }\n        return record;\n      };\n    };\n    webidl.interfaceConverter = function(i) {\n      return (V, opts = {}) => {\n        if (opts.strict !== false && !(V instanceof i)) {\n          webidl.errors.exception({\n            header: i.name,\n            message: `Expected ${V} to be an instance of ${i.name}.`\n          });\n        }\n        return V;\n      };\n    };\n    webidl.dictionaryConverter = function(converters) {\n      return (dictionary) => {\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type !== \"Null\" && type !== \"Undefined\" && type !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Dictionary\",\n            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n          });\n        }\n        for (const options of converters) {\n          const { key, defaultValue, required, converter } = options;\n          if (required === true) {\n            if (!hasOwn(dictionary, key)) {\n              webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `Missing required key \"${key}\".`\n              });\n            }\n          }\n          let value = dictionary[key];\n          const hasDefault = hasOwn(options, \"defaultValue\");\n          if (hasDefault && value !== null) {\n            value = value != null ? value : defaultValue;\n          }\n          if (required || hasDefault || value !== void 0) {\n            value = converter(value);\n            if (options.allowedValues && !options.allowedValues.includes(value)) {\n              webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n              });\n            }\n            dict[key] = value;\n          }\n        }\n        return dict;\n      };\n    };\n    webidl.nullableConverter = function(converter) {\n      return (V) => {\n        if (V === null) {\n          return V;\n        }\n        return converter(V);\n      };\n    };\n    webidl.converters.DOMString = function(V, opts = {}) {\n      if (V === null && opts.legacyNullToEmptyString) {\n        return \"\";\n      }\n      if (typeof V === \"symbol\") {\n        throw new TypeError(\"Could not convert argument of type symbol to string.\");\n      }\n      return String(V);\n    };\n    webidl.converters.ByteString = function(V) {\n      const x = webidl.converters.DOMString(V);\n      for (let index = 0; index < x.length; index++) {\n        const charCode = x.charCodeAt(index);\n        if (charCode > 255) {\n          throw new TypeError(\n            `Cannot convert argument to a ByteString because the character atindex ${index} has a value of ${charCode} which is greater than 255.`\n          );\n        }\n      }\n      return x;\n    };\n    webidl.converters.USVString = toUSVString;\n    webidl.converters.boolean = function(V) {\n      const x = Boolean(V);\n      return x;\n    };\n    webidl.converters.any = function(V) {\n      return V;\n    };\n    webidl.converters[\"long long\"] = function(V, opts) {\n      const x = webidl.util.ConvertToInt(V, 64, \"signed\", opts);\n      return x;\n    };\n    webidl.converters[\"unsigned short\"] = function(V) {\n      const x = webidl.util.ConvertToInt(V, 16, \"unsigned\");\n      return x;\n    };\n    webidl.converters.ArrayBuffer = function(V, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        webidl.errors.conversionFailed({\n          prefix: `${V}`,\n          argument: `${V}`,\n          types: [\"ArrayBuffer\"]\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.TypedArray = function(V, T, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        webidl.errors.conversionFailed({\n          prefix: `${T.name}`,\n          argument: `${V}`,\n          types: [T.name]\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.DataView = function(V, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        webidl.errors.exception({\n          header: \"DataView\",\n          message: \"Object is not a DataView.\"\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.BufferSource = function(V, opts = {}) {\n      if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, opts);\n      }\n      if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor);\n      }\n      if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, opts);\n      }\n      throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n    };\n    webidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(\n      webidl.converters.ByteString\n    );\n    webidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(\n      webidl.converters[\"sequence<ByteString>\"]\n    );\n    webidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(\n      webidl.converters.ByteString,\n      webidl.converters.ByteString\n    );\n    module2.exports = {\n      webidl\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/file.js\nvar require_file = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/file.js\"(exports, module2) {\n    \"use strict\";\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var { kState } = require_symbols2();\n    var { isBlobLike } = require_util3();\n    var { webidl } = require_webidl();\n    var File = class extends Blob {\n      constructor(fileBits, fileName, options = {}) {\n        if (arguments.length < 2) {\n          throw new TypeError(\"2 arguments required\");\n        }\n        fileBits = webidl.converters[\"sequence<BlobPart>\"](fileBits);\n        fileName = webidl.converters.USVString(fileName);\n        options = webidl.converters.FilePropertyBag(options);\n        const n = fileName;\n        const d = options.lastModified;\n        super(processBlobParts(fileBits, options), { type: options.type });\n        this[kState] = {\n          name: n,\n          lastModified: d\n        };\n      }\n      get name() {\n        if (!(this instanceof File)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].name;\n      }\n      get lastModified() {\n        if (!(this instanceof File)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].lastModified;\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n    };\n    __name(File, \"File\");\n    var FileLike = class {\n      constructor(blobLike, fileName, options = {}) {\n        var _a3;\n        const n = fileName;\n        const t = options.type;\n        const d = (_a3 = options.lastModified) != null ? _a3 : Date.now();\n        this[kState] = {\n          blobLike,\n          name: n,\n          type: t,\n          lastModified: d\n        };\n      }\n      stream(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.stream(...args);\n      }\n      arrayBuffer(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.arrayBuffer(...args);\n      }\n      slice(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.slice(...args);\n      }\n      text(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.text(...args);\n      }\n      get size() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.size;\n      }\n      get type() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.type;\n      }\n      get name() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].name;\n      }\n      get lastModified() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].lastModified;\n      }\n      get [Symbol.toStringTag]() {\n        return \"File\";\n      }\n    };\n    __name(FileLike, \"FileLike\");\n    webidl.converters.Blob = webidl.interfaceConverter(Blob);\n    webidl.converters.BlobPart = function(V, opts) {\n      if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n          return webidl.converters.Blob(V, { strict: false });\n        }\n        return webidl.converters.BufferSource(V, opts);\n      } else {\n        return webidl.converters.USVString(V, opts);\n      }\n    };\n    webidl.converters[\"sequence<BlobPart>\"] = webidl.sequenceConverter(\n      webidl.converters.BlobPart\n    );\n    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n      {\n        key: \"lastModified\",\n        converter: webidl.converters[\"long long\"],\n        get defaultValue() {\n          return Date.now();\n        }\n      },\n      {\n        key: \"type\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n      },\n      {\n        key: \"endings\",\n        converter: (value) => {\n          value = webidl.converters.DOMString(value);\n          value = value.toLowerCase();\n          if (value !== \"native\") {\n            value = \"transparent\";\n          }\n          return value;\n        },\n        defaultValue: \"transparent\"\n      }\n    ]);\n    function processBlobParts(parts, options) {\n      const bytes = [];\n      for (const element of parts) {\n        if (typeof element === \"string\") {\n          let s = element;\n          if (options.endings === \"native\") {\n            s = convertLineEndingsNative(s);\n          }\n          bytes.push(new TextEncoder().encode(s));\n        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {\n          if (!element.buffer) {\n            bytes.push(new Uint8Array(element));\n          } else {\n            bytes.push(\n              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)\n            );\n          }\n        } else if (isBlobLike(element)) {\n          bytes.push(element);\n        }\n      }\n      return bytes;\n    }\n    __name(processBlobParts, \"processBlobParts\");\n    function convertLineEndingsNative(s) {\n      let nativeLineEnding = \"\\n\";\n      if (process.platform === \"win32\") {\n        nativeLineEnding = \"\\r\\n\";\n      }\n      return s.replace(/\\r?\\n/g, nativeLineEnding);\n    }\n    __name(convertLineEndingsNative, \"convertLineEndingsNative\");\n    module2.exports = { File, FileLike };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/util.js\nvar require_util3 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/util.js\"(exports, module2) {\n    \"use strict\";\n    var { redirectStatus } = require_constants();\n    var { performance: performance3 } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\");\n    var File;\n    var crypto2;\n    try {\n      crypto2 = __webpack_require__(/*! crypto */ \"crypto\");\n    } catch (e) {\n    }\n    var badPorts = [\n      \"1\",\n      \"7\",\n      \"9\",\n      \"11\",\n      \"13\",\n      \"15\",\n      \"17\",\n      \"19\",\n      \"20\",\n      \"21\",\n      \"22\",\n      \"23\",\n      \"25\",\n      \"37\",\n      \"42\",\n      \"43\",\n      \"53\",\n      \"69\",\n      \"77\",\n      \"79\",\n      \"87\",\n      \"95\",\n      \"101\",\n      \"102\",\n      \"103\",\n      \"104\",\n      \"109\",\n      \"110\",\n      \"111\",\n      \"113\",\n      \"115\",\n      \"117\",\n      \"119\",\n      \"123\",\n      \"135\",\n      \"137\",\n      \"139\",\n      \"143\",\n      \"161\",\n      \"179\",\n      \"389\",\n      \"427\",\n      \"465\",\n      \"512\",\n      \"513\",\n      \"514\",\n      \"515\",\n      \"526\",\n      \"530\",\n      \"531\",\n      \"532\",\n      \"540\",\n      \"548\",\n      \"554\",\n      \"556\",\n      \"563\",\n      \"587\",\n      \"601\",\n      \"636\",\n      \"989\",\n      \"990\",\n      \"993\",\n      \"995\",\n      \"1719\",\n      \"1720\",\n      \"1723\",\n      \"2049\",\n      \"3659\",\n      \"4045\",\n      \"5060\",\n      \"5061\",\n      \"6000\",\n      \"6566\",\n      \"6665\",\n      \"6666\",\n      \"6667\",\n      \"6668\",\n      \"6669\",\n      \"6697\",\n      \"10080\"\n    ];\n    function responseURL(response) {\n      const urlList = response.urlList;\n      const length = urlList.length;\n      return length === 0 ? null : urlList[length - 1].toString();\n    }\n    __name(responseURL, \"responseURL\");\n    function responseLocationURL(response, requestFragment) {\n      if (!redirectStatus.includes(response.status)) {\n        return null;\n      }\n      let location = response.headersList.get(\"location\");\n      location = location ? new URL(location, responseURL(response)) : null;\n      if (location && !location.hash) {\n        location.hash = requestFragment;\n      }\n      return location;\n    }\n    __name(responseLocationURL, \"responseLocationURL\");\n    function requestCurrentURL(request2) {\n      return request2.urlList[request2.urlList.length - 1];\n    }\n    __name(requestCurrentURL, \"requestCurrentURL\");\n    function requestBadPort(request2) {\n      const url = requestCurrentURL(request2);\n      if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n        return \"blocked\";\n      }\n      return \"allowed\";\n    }\n    __name(requestBadPort, \"requestBadPort\");\n    function isFileLike(object) {\n      if (!File) {\n        File = require_file().File;\n      }\n      return object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n    __name(isFileLike, \"isFileLike\");\n    function isErrorLike(object) {\n      var _a3, _b2;\n      return object instanceof Error || (((_a3 = object == null ? void 0 : object.constructor) == null ? void 0 : _a3.name) === \"Error\" || ((_b2 = object == null ? void 0 : object.constructor) == null ? void 0 : _b2.name) === \"DOMException\");\n    }\n    __name(isErrorLike, \"isErrorLike\");\n    function isValidReasonPhrase(statusText) {\n      for (let i = 0; i < statusText.length; ++i) {\n        const c = statusText.charCodeAt(i);\n        if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidReasonPhrase, \"isValidReasonPhrase\");\n    function isTokenChar(c) {\n      return !(c >= 127 || c <= 32 || c === \"(\" || c === \")\" || c === \"<\" || c === \">\" || c === \"@\" || c === \",\" || c === \";\" || c === \":\" || c === \"\\\\\" || c === '\"' || c === \"/\" || c === \"[\" || c === \"]\" || c === \"?\" || c === \"=\" || c === \"{\" || c === \"}\");\n    }\n    __name(isTokenChar, \"isTokenChar\");\n    function isValidHTTPToken(characters) {\n      if (!characters || typeof characters !== \"string\") {\n        return false;\n      }\n      for (let i = 0; i < characters.length; ++i) {\n        const c = characters.charCodeAt(i);\n        if (c > 127 || !isTokenChar(c)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidHTTPToken, \"isValidHTTPToken\");\n    function isValidHeaderName(potentialValue) {\n      if (potentialValue.length === 0) {\n        return false;\n      }\n      for (const char of potentialValue) {\n        if (!isValidHTTPToken(char)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidHeaderName, \"isValidHeaderName\");\n    function isValidHeaderValue(potentialValue) {\n      if (potentialValue.startsWith(\"\t\") || potentialValue.startsWith(\" \") || potentialValue.endsWith(\"\t\") || potentialValue.endsWith(\" \")) {\n        return false;\n      }\n      if (potentialValue.includes(\"\\0\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\n\")) {\n        return false;\n      }\n      return true;\n    }\n    __name(isValidHeaderValue, \"isValidHeaderValue\");\n    function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {\n      const policy = \"\";\n      if (policy !== \"\") {\n        request2.referrerPolicy = policy;\n      }\n    }\n    __name(setRequestReferrerPolicyOnRedirect, \"setRequestReferrerPolicyOnRedirect\");\n    function crossOriginResourcePolicyCheck() {\n      return \"allowed\";\n    }\n    __name(crossOriginResourcePolicyCheck, \"crossOriginResourcePolicyCheck\");\n    function corsCheck() {\n      return \"success\";\n    }\n    __name(corsCheck, \"corsCheck\");\n    function TAOCheck() {\n      return \"success\";\n    }\n    __name(TAOCheck, \"TAOCheck\");\n    function appendFetchMetadata(httpRequest) {\n      let header = null;\n      header = httpRequest.mode;\n      httpRequest.headersList.set(\"sec-fetch-mode\", header);\n    }\n    __name(appendFetchMetadata, \"appendFetchMetadata\");\n    function appendRequestOriginHeader(request2) {\n      let serializedOrigin = request2.origin;\n      if (request2.responseTainting === \"cors\" || request2.mode === \"websocket\") {\n        if (serializedOrigin) {\n          request2.headersList.append(\"Origin\", serializedOrigin);\n        }\n      } else if (request2.method !== \"GET\" && request2.method !== \"HEAD\") {\n        switch (request2.referrerPolicy) {\n          case \"no-referrer\":\n            serializedOrigin = null;\n            break;\n          case \"no-referrer-when-downgrade\":\n          case \"strict-origin\":\n          case \"strict-origin-when-cross-origin\":\n            if (/^https:/.test(request2.origin) && !/^https:/.test(requestCurrentURL(request2))) {\n              serializedOrigin = null;\n            }\n            break;\n          case \"same-origin\":\n            if (!sameOrigin(request2, requestCurrentURL(request2))) {\n              serializedOrigin = null;\n            }\n            break;\n          default:\n        }\n        if (serializedOrigin) {\n          request2.headersList.append(\"Origin\", serializedOrigin);\n        }\n      }\n    }\n    __name(appendRequestOriginHeader, \"appendRequestOriginHeader\");\n    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n      return performance3.now();\n    }\n    __name(coarsenedSharedCurrentTime, \"coarsenedSharedCurrentTime\");\n    function createOpaqueTimingInfo(timingInfo) {\n      var _a3, _b2;\n      return {\n        startTime: (_a3 = timingInfo.startTime) != null ? _a3 : 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: (_b2 = timingInfo.startTime) != null ? _b2 : 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n      };\n    }\n    __name(createOpaqueTimingInfo, \"createOpaqueTimingInfo\");\n    function makePolicyContainer() {\n      return {};\n    }\n    __name(makePolicyContainer, \"makePolicyContainer\");\n    function clonePolicyContainer() {\n      return {};\n    }\n    __name(clonePolicyContainer, \"clonePolicyContainer\");\n    function determineRequestsReferrer(request2) {\n      return \"no-referrer\";\n    }\n    __name(determineRequestsReferrer, \"determineRequestsReferrer\");\n    function bytesMatch(bytes, metadataList) {\n      if (crypto2 === void 0) {\n        return true;\n      }\n      const parsedMetadata = parseMetadata(metadataList);\n      if (parsedMetadata === \"no metadata\") {\n        return true;\n      }\n      if (parsedMetadata.length === 0) {\n        return true;\n      }\n      const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n      for (const item of metadata) {\n        const algorithm = item.algo;\n        const expectedValue = item.hash;\n        const actualValue = crypto2.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue === expectedValue) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(bytesMatch, \"bytesMatch\");\n    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i;\n    function parseMetadata(metadata) {\n      const result = [];\n      let empty2 = true;\n      const supportedHashes = crypto2.getHashes();\n      for (const token of metadata.split(\" \")) {\n        empty2 = false;\n        const parsedToken = parseHashWithOptions.exec(token);\n        if (parsedToken === null || parsedToken.groups === void 0) {\n          continue;\n        }\n        const algorithm = parsedToken.groups.algo;\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n          result.push(parsedToken.groups);\n        }\n      }\n      if (empty2 === true) {\n        return \"no metadata\";\n      }\n      return result;\n    }\n    __name(parseMetadata, \"parseMetadata\");\n    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {\n    }\n    __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, \"tryUpgradeRequestToAPotentiallyTrustworthyURL\");\n    function sameOrigin(A, B) {\n      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n      }\n      return false;\n    }\n    __name(sameOrigin, \"sameOrigin\");\n    function createDeferredPromise() {\n      let res;\n      let rej;\n      const promise = new Promise((resolve, reject) => {\n        res = resolve;\n        rej = reject;\n      });\n      return { promise, resolve: res, reject: rej };\n    }\n    __name(createDeferredPromise, \"createDeferredPromise\");\n    function isAborted(fetchParams) {\n      return fetchParams.controller.state === \"aborted\";\n    }\n    __name(isAborted, \"isAborted\");\n    function isCancelled(fetchParams) {\n      return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n    }\n    __name(isCancelled, \"isCancelled\");\n    function normalizeMethod(method) {\n      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n    }\n    __name(normalizeMethod, \"normalizeMethod\");\n    function serializeJavascriptValueToJSONString(value) {\n      const result = JSON.stringify(value);\n      if (result === void 0) {\n        throw new TypeError(\"Value is not JSON serializable\");\n      }\n      assert(typeof result === \"string\");\n      return result;\n    }\n    __name(serializeJavascriptValueToJSONString, \"serializeJavascriptValueToJSONString\");\n    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n    function makeIterator(iterator, name) {\n      const i = {\n        next() {\n          if (Object.getPrototypeOf(this) !== i) {\n            throw new TypeError(\n              `'next' called on an object that does not implement interface ${name} Iterator.`\n            );\n          }\n          return iterator.next();\n        },\n        [Symbol.toStringTag]: `${name} Iterator`\n      };\n      Object.setPrototypeOf(i, esIteratorPrototype);\n      return Object.setPrototypeOf({}, i);\n    }\n    __name(makeIterator, \"makeIterator\");\n    async function fullyReadBody(body, processBody, processBodyError) {\n      try {\n        const chunks = [];\n        let length = 0;\n        const reader = body.stream.getReader();\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done === true) {\n            break;\n          }\n          assert(isUint8Array(value));\n          chunks.push(value);\n          length += value.byteLength;\n        }\n        const fulfilledSteps = /* @__PURE__ */ __name((bytes) => queueMicrotask(() => {\n          processBody(bytes);\n        }), \"fulfilledSteps\");\n        fulfilledSteps(Buffer.concat(chunks, length));\n      } catch (err) {\n        queueMicrotask(() => processBodyError(err));\n      }\n    }\n    __name(fullyReadBody, \"fullyReadBody\");\n    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\n    module2.exports = {\n      isAborted,\n      isCancelled,\n      createDeferredPromise,\n      ReadableStreamFrom,\n      toUSVString,\n      tryUpgradeRequestToAPotentiallyTrustworthyURL,\n      coarsenedSharedCurrentTime,\n      determineRequestsReferrer,\n      makePolicyContainer,\n      clonePolicyContainer,\n      appendFetchMetadata,\n      appendRequestOriginHeader,\n      TAOCheck,\n      corsCheck,\n      crossOriginResourcePolicyCheck,\n      createOpaqueTimingInfo,\n      setRequestReferrerPolicyOnRedirect,\n      isValidHTTPToken,\n      requestBadPort,\n      requestCurrentURL,\n      responseURL,\n      responseLocationURL,\n      isBlobLike,\n      isFileLike,\n      isValidReasonPhrase,\n      sameOrigin,\n      normalizeMethod,\n      serializeJavascriptValueToJSONString,\n      makeIterator,\n      isValidHeaderName,\n      isValidHeaderValue,\n      hasOwn,\n      isErrorLike,\n      fullyReadBody,\n      bytesMatch\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/formdata.js\nvar require_formdata = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/formdata.js\"(exports, module2) {\n    \"use strict\";\n    var { isBlobLike, isFileLike, toUSVString, makeIterator } = require_util3();\n    var { kState } = require_symbols2();\n    var { File, FileLike } = require_file();\n    var { webidl } = require_webidl();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var _FormData = class {\n      constructor(form) {\n        if (arguments.length > 0 && form != null) {\n          webidl.errors.conversionFailed({\n            prefix: \"FormData constructor\",\n            argument: \"Argument 1\",\n            types: [\"null\"]\n          });\n        }\n        this[kState] = [];\n      }\n      append(name, value, filename = void 0) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        if (arguments.length === 3 && !isBlobLike(value)) {\n          throw new TypeError(\n            \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n          );\n        }\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;\n        const entry = makeEntry(name, value, filename);\n        this[kState].push(entry);\n      }\n      delete(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        const next = [];\n        for (const entry of this[kState]) {\n          if (entry.name !== name) {\n            next.push(entry);\n          }\n        }\n        this[kState] = next;\n      }\n      get(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        const idx = this[kState].findIndex((entry) => entry.name === name);\n        if (idx === -1) {\n          return null;\n        }\n        return this[kState][idx].value;\n      }\n      getAll(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);\n      }\n      has(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        return this[kState].findIndex((entry) => entry.name === name) !== -1;\n      }\n      set(name, value, filename = void 0) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        if (arguments.length === 3 && !isBlobLike(value)) {\n          throw new TypeError(\n            \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n          );\n        }\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? toUSVString(filename) : void 0;\n        const entry = makeEntry(name, value, filename);\n        const idx = this[kState].findIndex((entry2) => entry2.name === name);\n        if (idx !== -1) {\n          this[kState] = [\n            ...this[kState].slice(0, idx),\n            entry,\n            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)\n          ];\n        } else {\n          this[kState].push(entry);\n        }\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      entries() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"entries\"),\n          \"FormData\"\n        );\n      }\n      keys() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"keys\"),\n          \"FormData\"\n        );\n      }\n      values() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"values\"),\n          \"FormData\"\n        );\n      }\n      forEach(callbackFn, thisArg = globalThis) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        if (typeof callbackFn !== \"function\") {\n          throw new TypeError(\n            \"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\"\n          );\n        }\n        for (const [key, value] of this) {\n          callbackFn.apply(thisArg, [value, key, this]);\n        }\n      }\n    };\n    var FormData = _FormData;\n    __name(FormData, \"FormData\");\n    __publicField(FormData, \"name\", \"FormData\");\n    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;\n    function makeEntry(name, value, filename) {\n      name = Buffer.from(name).toString(\"utf8\");\n      if (typeof value === \"string\") {\n        value = Buffer.from(value).toString(\"utf8\");\n      } else {\n        if (!isFileLike(value)) {\n          value = value instanceof Blob ? new File([value], \"blob\", { type: value.type }) : new FileLike(value, \"blob\", { type: value.type });\n        }\n        if (filename !== void 0) {\n          value = value instanceof File ? new File([value], filename, { type: value.type }) : new FileLike(value, filename, { type: value.type });\n        }\n      }\n      return { name, value };\n    }\n    __name(makeEntry, \"makeEntry\");\n    function* makeIterable(entries, type) {\n      for (const { name, value } of entries) {\n        if (type === \"entries\") {\n          yield [name, value];\n        } else if (type === \"values\") {\n          yield value;\n        } else {\n          yield name;\n        }\n      }\n    }\n    __name(makeIterable, \"makeIterable\");\n    module2.exports = { FormData };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/body.js\nvar require_body = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/body.js\"(exports, module2) {\n    \"use strict\";\n    var util2 = require_util2();\n    var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util3();\n    var { FormData } = require_formdata();\n    var { kState } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var { kBodyUsed } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { NotSupportedError } = require_errors();\n    var { isErrored } = require_util2();\n    var { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\");\n    var ReadableStream;\n    async function* blobGen(blob) {\n      yield* blob.stream();\n    }\n    __name(blobGen, \"blobGen\");\n    function extractBody(object, keepalive = false) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      let stream2 = null;\n      let action = null;\n      let source = null;\n      let length = null;\n      let contentType = null;\n      if (object == null) {\n      } else if (object instanceof URLSearchParams) {\n        source = object.toString();\n        contentType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      } else if (isArrayBuffer(object)) {\n        source = new Uint8Array(object.slice());\n      } else if (ArrayBuffer.isView(object)) {\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n      } else if (util2.isFormDataLike(object)) {\n        const boundary = \"----formdata-undici-\" + Math.random();\n        const prefix = `--${boundary}\\r\nContent-Disposition: form-data`;\n        const escape = /* @__PURE__ */ __name((str) => str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), \"escape\");\n        const normalizeLinefeeds = /* @__PURE__ */ __name((value) => value.replace(/\\r?\\n|\\r/g, \"\\r\\n\"), \"normalizeLinefeeds\");\n        action = /* @__PURE__ */ __name(async function* (object2) {\n          const enc = new TextEncoder();\n          for (const [name, value] of object2) {\n            if (typeof value === \"string\") {\n              yield enc.encode(\n                prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"\\r\n\\r\n${normalizeLinefeeds(value)}\\r\n`\n              );\n            } else {\n              yield enc.encode(\n                prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + `\\r\nContent-Type: ${value.type || \"application/octet-stream\"}\\r\n\\r\n`\n              );\n              yield* blobGen(value);\n              yield enc.encode(\"\\r\\n\");\n            }\n          }\n          yield enc.encode(`--${boundary}--`);\n        }, \"action\");\n        source = object;\n        contentType = \"multipart/form-data; boundary=\" + boundary;\n      } else if (isBlobLike(object)) {\n        action = blobGen;\n        source = object;\n        length = object.size;\n        if (object.type) {\n          contentType = object.type;\n        }\n      } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        if (keepalive) {\n          throw new TypeError(\"keepalive\");\n        }\n        if (util2.isDisturbed(object) || object.locked) {\n          throw new TypeError(\n            \"Response body object should not be disturbed or locked\"\n          );\n        }\n        stream2 = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n      } else {\n        source = toUSVString(object);\n        contentType = \"text/plain;charset=UTF-8\";\n      }\n      if (typeof source === \"string\" || util2.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n      }\n      if (action != null) {\n        let iterator;\n        stream2 = new ReadableStream({\n          async start() {\n            iterator = action(object)[Symbol.asyncIterator]();\n          },\n          async pull(controller) {\n            const { value, done } = await iterator.next();\n            if (done) {\n              queueMicrotask(() => {\n                controller.close();\n              });\n            } else {\n              if (!isErrored(stream2)) {\n                controller.enqueue(new Uint8Array(value));\n              }\n            }\n            return controller.desiredSize > 0;\n          },\n          async cancel(reason) {\n            await iterator.return();\n          }\n        });\n      } else if (!stream2) {\n        stream2 = new ReadableStream({\n          async pull(controller) {\n            controller.enqueue(\n              typeof source === \"string\" ? new TextEncoder().encode(source) : source\n            );\n            queueMicrotask(() => {\n              controller.close();\n            });\n          }\n        });\n      }\n      const body = { stream: stream2, source, length };\n      return [body, contentType];\n    }\n    __name(extractBody, \"extractBody\");\n    function safelyExtractBody(object, keepalive = false) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      if (object instanceof ReadableStream) {\n        assert(!util2.isDisturbed(object), \"disturbed\");\n        assert(!object.locked, \"locked\");\n      }\n      return extractBody(object, keepalive);\n    }\n    __name(safelyExtractBody, \"safelyExtractBody\");\n    function cloneBody(body) {\n      const [out1, out2] = body.stream.tee();\n      body.stream = out1;\n      return {\n        stream: out2,\n        length: body.length,\n        source: body.source\n      };\n    }\n    __name(cloneBody, \"cloneBody\");\n    async function* consumeBody(body) {\n      if (body) {\n        if (isUint8Array(body)) {\n          yield body;\n        } else {\n          const stream2 = body.stream;\n          if (util2.isDisturbed(stream2)) {\n            throw new TypeError(\"disturbed\");\n          }\n          if (stream2.locked) {\n            throw new TypeError(\"locked\");\n          }\n          stream2[kBodyUsed] = true;\n          yield* stream2;\n        }\n      }\n    }\n    __name(consumeBody, \"consumeBody\");\n    function bodyMixinMethods(instance) {\n      const methods = {\n        async blob() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const chunks = [];\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            chunks.push(new Blob([chunk]));\n          }\n          return new Blob(chunks, { type: this.headers.get(\"Content-Type\") || \"\" });\n        },\n        async arrayBuffer() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const contentLength = this.headers.get(\"content-length\");\n          const encoded = this.headers.has(\"content-encoding\");\n          if (!encoded && contentLength) {\n            const buffer2 = new Uint8Array(contentLength);\n            let offset2 = 0;\n            for await (const chunk of consumeBody(this[kState].body)) {\n              if (!isUint8Array(chunk)) {\n                throw new TypeError(\"Expected Uint8Array chunk\");\n              }\n              buffer2.set(chunk, offset2);\n              offset2 += chunk.length;\n            }\n            return buffer2.buffer;\n          }\n          const chunks = [];\n          let size = 0;\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            chunks.push(chunk);\n            size += chunk.byteLength;\n          }\n          const buffer = new Uint8Array(size);\n          let offset = 0;\n          for (const chunk of chunks) {\n            buffer.set(chunk, offset);\n            offset += chunk.byteLength;\n          }\n          return buffer.buffer;\n        },\n        async text() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          let result = \"\";\n          const textDecoder = new TextDecoder();\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            result += textDecoder.decode(chunk, { stream: true });\n          }\n          result += textDecoder.decode();\n          return result;\n        },\n        async json() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return JSON.parse(await this.text());\n        },\n        async formData() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const contentType = this.headers.get(\"Content-Type\");\n          if (/multipart\\/form-data/.test(contentType)) {\n            throw new NotSupportedError(\"multipart/form-data not supported\");\n          } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n            let entries;\n            try {\n              let text = \"\";\n              const textDecoder = new TextDecoder(\"utf-8\", { ignoreBOM: true });\n              for await (const chunk of consumeBody(this[kState].body)) {\n                if (!isUint8Array(chunk)) {\n                  throw new TypeError(\"Expected Uint8Array chunk\");\n                }\n                text += textDecoder.decode(chunk, { stream: true });\n              }\n              text += textDecoder.decode();\n              entries = new URLSearchParams(text);\n            } catch (err) {\n              throw Object.assign(new TypeError(), { cause: err });\n            }\n            const formData = new FormData();\n            for (const [name, value] of entries) {\n              formData.append(name, value);\n            }\n            return formData;\n          } else {\n            webidl.errors.exception({\n              header: `${instance.name}.formData`,\n              value: \"Could not parse content as FormData.\"\n            });\n          }\n        }\n      };\n      return methods;\n    }\n    __name(bodyMixinMethods, \"bodyMixinMethods\");\n    var properties = {\n      body: {\n        enumerable: true,\n        get() {\n          if (!this || !this[kState]) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return this[kState].body ? this[kState].body.stream : null;\n        }\n      },\n      bodyUsed: {\n        enumerable: true,\n        get() {\n          if (!this || !this[kState]) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);\n        }\n      }\n    };\n    function mixinBody(prototype) {\n      Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n      Object.defineProperties(prototype.prototype, properties);\n    }\n    __name(mixinBody, \"mixinBody\");\n    module2.exports = {\n      extractBody,\n      safelyExtractBody,\n      cloneBody,\n      mixinBody\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/request.js\nvar require_request = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/request.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      InvalidArgumentError,\n      NotSupportedError\n    } = require_errors();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var util2 = require_util2();\n    var tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n    var headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n    var invalidPathRegex = /[^\\u0021-\\u00ff]/;\n    var kHandler = Symbol(\"handler\");\n    var channels = {};\n    var extractBody;\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    try {\n      const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n      channels.create = diagnosticsChannel.channel(\"undici:request:create\");\n      channels.bodySent = diagnosticsChannel.channel(\"undici:request:bodySent\");\n      channels.headers = diagnosticsChannel.channel(\"undici:request:headers\");\n      channels.trailers = diagnosticsChannel.channel(\"undici:request:trailers\");\n      channels.error = diagnosticsChannel.channel(\"undici:request:error\");\n    } catch (e) {\n      channels.create = { hasSubscribers: false };\n      channels.bodySent = { hasSubscribers: false };\n      channels.headers = { hasSubscribers: false };\n      channels.trailers = { hasSubscribers: false };\n      channels.error = { hasSubscribers: false };\n    }\n    var Request = class {\n      constructor(origin, {\n        path: path7,\n        method,\n        body,\n        headers,\n        query: query2,\n        idempotent,\n        blocking,\n        upgrade,\n        headersTimeout,\n        bodyTimeout,\n        throwOnError\n      }, handler) {\n        if (typeof path7 !== \"string\") {\n          throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path7[0] !== \"/\" && !(path7.startsWith(\"http://\") || path7.startsWith(\"https://\")) && method !== \"CONNECT\") {\n          throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.exec(path7) !== null) {\n          throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n          throw new InvalidArgumentError(\"method must be a string\");\n        } else if (tokenRegExp.exec(method) === null) {\n          throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n          throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        if (body == null) {\n          this.body = null;\n        } else if (util2.isStream(body)) {\n          this.body = body;\n        } else if (util2.isBuffer(body)) {\n          this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n          this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n          this.body = body.length ? Buffer.from(body) : null;\n        } else if (util2.isFormDataLike(body) || util2.isIterable(body) || util2.isBlobLike(body)) {\n          this.body = body;\n        } else {\n          throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query2 ? util2.buildURL(path7, query2) : path7;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = \"\";\n        if (Array.isArray(headers)) {\n          if (headers.length % 2 !== 0) {\n            throw new InvalidArgumentError(\"headers array must be even\");\n          }\n          for (let i = 0; i < headers.length; i += 2) {\n            processHeader(this, headers[i], headers[i + 1]);\n          }\n        } else if (headers && typeof headers === \"object\") {\n          const keys2 = Object.keys(headers);\n          for (let i = 0; i < keys2.length; i++) {\n            const key = keys2[i];\n            processHeader(this, key, headers[key]);\n          }\n        } else if (headers != null) {\n          throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        if (util2.isFormDataLike(this.body)) {\n          if (nodeMajor < 16 || nodeMajor === 16 && nodeMinor < 8) {\n            throw new InvalidArgumentError(\"Form-Data bodies are only supported in node v16.8 and newer.\");\n          }\n          if (!extractBody) {\n            extractBody = require_body().extractBody;\n          }\n          const [bodyStream, contentType] = extractBody(body);\n          if (this.contentType == null) {\n            this.contentType = contentType;\n            this.headers += `content-type: ${contentType}\\r\n`;\n          }\n          this.body = bodyStream.stream;\n        } else if (util2.isBlobLike(body) && this.contentType == null && body.type) {\n          this.contentType = body.type;\n          this.headers += `content-type: ${body.type}\\r\n`;\n        }\n        util2.validateHandler(handler, method, upgrade);\n        this.servername = util2.getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n          channels.create.publish({ request: this });\n        }\n      }\n      onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n          try {\n            this[kHandler].onBodySent(chunk);\n          } catch (err) {\n            this.onError(err);\n          }\n        }\n      }\n      onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n          channels.bodySent.publish({ request: this });\n        }\n      }\n      onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onConnect(abort);\n      }\n      onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });\n        }\n        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n      }\n      onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onData(chunk);\n      }\n      onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n      }\n      onComplete(trailers) {\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n          channels.trailers.publish({ request: this, trailers });\n        }\n        return this[kHandler].onComplete(trailers);\n      }\n      onError(error2) {\n        if (channels.error.hasSubscribers) {\n          channels.error.publish({ request: this, error: error2 });\n        }\n        if (this.aborted) {\n          return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error2);\n      }\n      addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n      }\n    };\n    __name(Request, \"Request\");\n    function processHeader(request2, key, val) {\n      if (val && typeof val === \"object\") {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n      } else if (val === void 0) {\n        return;\n      }\n      if (request2.host === null && key.length === 4 && key.toLowerCase() === \"host\") {\n        request2.host = val;\n      } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === \"content-length\") {\n        request2.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request2.contentLength)) {\n          throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n      } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === \"content-type\" && headerCharRegex.exec(val) === null) {\n        request2.contentType = val;\n        request2.headers += `${key}: ${val}\\r\n`;\n      } else if (key.length === 17 && key.toLowerCase() === \"transfer-encoding\") {\n        throw new InvalidArgumentError(\"invalid transfer-encoding header\");\n      } else if (key.length === 10 && key.toLowerCase() === \"connection\") {\n        throw new InvalidArgumentError(\"invalid connection header\");\n      } else if (key.length === 10 && key.toLowerCase() === \"keep-alive\") {\n        throw new InvalidArgumentError(\"invalid keep-alive header\");\n      } else if (key.length === 7 && key.toLowerCase() === \"upgrade\") {\n        throw new InvalidArgumentError(\"invalid upgrade header\");\n      } else if (key.length === 6 && key.toLowerCase() === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n      } else if (tokenRegExp.exec(key) === null) {\n        throw new InvalidArgumentError(\"invalid header key\");\n      } else if (headerCharRegex.exec(val) !== null) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n      } else {\n        request2.headers += `${key}: ${val}\\r\n`;\n      }\n    }\n    __name(processHeader, \"processHeader\");\n    module2.exports = Request;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher.js\nvar require_dispatcher = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher.js\"(exports, module2) {\n    \"use strict\";\n    var EventEmitter4 = __webpack_require__(/*! events */ \"events\");\n    var Dispatcher = class extends EventEmitter4 {\n      dispatch() {\n        throw new Error(\"not implemented\");\n      }\n      close() {\n        throw new Error(\"not implemented\");\n      }\n      destroy() {\n        throw new Error(\"not implemented\");\n      }\n    };\n    __name(Dispatcher, \"Dispatcher\");\n    module2.exports = Dispatcher;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher-base.js\nvar require_dispatcher_base = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher-base.js\"(exports, module2) {\n    \"use strict\";\n    var Dispatcher = require_dispatcher();\n    var {\n      ClientDestroyedError,\n      ClientClosedError,\n      InvalidArgumentError\n    } = require_errors();\n    var { kDestroy, kClose, kDispatch } = require_symbols();\n    var kDestroyed = Symbol(\"destroyed\");\n    var kClosed = Symbol(\"closed\");\n    var kOnDestroyed = Symbol(\"onDestroyed\");\n    var kOnClosed = Symbol(\"onClosed\");\n    var DispatcherBase = class extends Dispatcher {\n      constructor() {\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = [];\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n      }\n      get destroyed() {\n        return this[kDestroyed];\n      }\n      get closed() {\n        return this[kClosed];\n      }\n      close(callback) {\n        if (callback === void 0) {\n          return new Promise((resolve, reject) => {\n            this.close((err, data) => {\n              return err ? reject(err) : resolve(data);\n            });\n          });\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n          queueMicrotask(() => callback(new ClientDestroyedError(), null));\n          return;\n        }\n        if (this[kClosed]) {\n          if (this[kOnClosed]) {\n            this[kOnClosed].push(callback);\n          } else {\n            queueMicrotask(() => callback(null, null));\n          }\n          return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = /* @__PURE__ */ __name(() => {\n          const callbacks = this[kOnClosed];\n          this[kOnClosed] = null;\n          for (let i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, null);\n          }\n        }, \"onClosed\");\n        this[kClose]().then(() => this.destroy()).then(() => {\n          queueMicrotask(onClosed);\n        });\n      }\n      destroy(err, callback) {\n        if (typeof err === \"function\") {\n          callback = err;\n          err = null;\n        }\n        if (callback === void 0) {\n          return new Promise((resolve, reject) => {\n            this.destroy(err, (err2, data) => {\n              return err2 ? reject(err2) : resolve(data);\n            });\n          });\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n          if (this[kOnDestroyed]) {\n            this[kOnDestroyed].push(callback);\n          } else {\n            queueMicrotask(() => callback(null, null));\n          }\n          return;\n        }\n        if (!err) {\n          err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = /* @__PURE__ */ __name(() => {\n          const callbacks = this[kOnDestroyed];\n          this[kOnDestroyed] = null;\n          for (let i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, null);\n          }\n        }, \"onDestroyed\");\n        this[kDestroy](err).then(() => {\n          queueMicrotask(onDestroyed);\n        });\n      }\n      dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n          throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n          if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object.\");\n          }\n          if (this[kDestroyed]) {\n            throw new ClientDestroyedError();\n          }\n          if (this[kClosed]) {\n            throw new ClientClosedError();\n          }\n          return this[kDispatch](opts, handler);\n        } catch (err) {\n          if (typeof handler.onError !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onError method\");\n          }\n          handler.onError(err);\n          return false;\n        }\n      }\n    };\n    __name(DispatcherBase, \"DispatcherBase\");\n    module2.exports = DispatcherBase;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/handler/redirect.js\nvar require_redirect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/handler/redirect.js\"(exports, module2) {\n    \"use strict\";\n    var util2 = require_util2();\n    var { kBodyUsed } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { InvalidArgumentError } = require_errors();\n    var EE = __webpack_require__(/*! events */ \"events\");\n    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];\n    var kBody = Symbol(\"body\");\n    var BodyAsyncIterable = class {\n      constructor(body) {\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n      }\n      async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n      }\n    };\n    __name(BodyAsyncIterable, \"BodyAsyncIterable\");\n    var RedirectHandler = class {\n      constructor(dispatcher, maxRedirections, opts, handler) {\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util2.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatcher = dispatcher;\n        this.location = null;\n        this.abort = null;\n        this.opts = { ...opts, maxRedirections: 0 };\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        if (util2.isStream(this.opts.body)) {\n          if (util2.bodyLength(this.opts.body) === 0) {\n            this.opts.body.on(\"data\", function() {\n              assert(false);\n            });\n          }\n          if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n            this.opts.body[kBodyUsed] = false;\n            EE.prototype.on.call(this.opts.body, \"data\", function() {\n              this[kBodyUsed] = true;\n            });\n          }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n          this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {\n          this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n      }\n      onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, { history: this.history });\n      }\n      onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n      }\n      onError(error2) {\n        this.handler.onError(error2);\n      }\n      onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.origin) {\n          this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n          return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path7 = search ? `${pathname}${search}` : pathname;\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path7;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n          this.opts.method = \"GET\";\n          this.opts.body = null;\n        }\n      }\n      onData(chunk) {\n        if (this.location) {\n        } else {\n          return this.handler.onData(chunk);\n        }\n      }\n      onComplete(trailers) {\n        if (this.location) {\n          this.location = null;\n          this.abort = null;\n          this.dispatcher.dispatch(this.opts, this);\n        } else {\n          this.handler.onComplete(trailers);\n        }\n      }\n      onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n          this.handler.onBodySent(chunk);\n        }\n      }\n    };\n    __name(RedirectHandler, \"RedirectHandler\");\n    function parseLocation(statusCode, headers) {\n      if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        if (headers[i].toString().toLowerCase() === \"location\") {\n          return headers[i + 1];\n        }\n      }\n    }\n    __name(parseLocation, \"parseLocation\");\n    function shouldRemoveHeader(header, removeContent, unknownOrigin) {\n      return header.length === 4 && header.toString().toLowerCase() === \"host\" || removeContent && header.toString().toLowerCase().indexOf(\"content-\") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === \"authorization\" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === \"cookie\";\n    }\n    __name(shouldRemoveHeader, \"shouldRemoveHeader\");\n    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n      const ret = [];\n      if (Array.isArray(headers)) {\n        for (let i = 0; i < headers.length; i += 2) {\n          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n            ret.push(headers[i], headers[i + 1]);\n          }\n        }\n      } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)) {\n          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n            ret.push(key, headers[key]);\n          }\n        }\n      } else {\n        assert(headers == null, \"headers must be an object or an array\");\n      }\n      return ret;\n    }\n    __name(cleanRequestHeaders, \"cleanRequestHeaders\");\n    module2.exports = RedirectHandler;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/connect.js\nvar require_connect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/connect.js\"(exports, module2) {\n    \"use strict\";\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var util2 = require_util2();\n    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();\n    var tls;\n    function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {\n      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n      }\n      const options = { path: socketPath, ...opts };\n      const sessionCache = /* @__PURE__ */ new Map();\n      timeout = timeout == null ? 1e4 : timeout;\n      maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n      return /* @__PURE__ */ __name(function connect({ hostname: hostname3, host, protocol, port, servername, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n          if (!tls) {\n            tls = __webpack_require__(/*! tls */ \"tls\");\n          }\n          servername = servername || options.servername || util2.getServerName(host) || null;\n          const sessionKey = servername || hostname3;\n          const session = sessionCache.get(sessionKey) || null;\n          assert(sessionKey);\n          socket = tls.connect({\n            highWaterMark: 16384,\n            ...options,\n            servername,\n            session,\n            socket: httpSocket,\n            port: port || 443,\n            host: hostname3\n          });\n          socket.on(\"session\", function(session2) {\n            if (maxCachedSessions === 0) {\n              return;\n            }\n            if (sessionCache.size >= maxCachedSessions) {\n              const { value: oldestKey } = sessionCache.keys().next();\n              sessionCache.delete(oldestKey);\n            }\n            sessionCache.set(sessionKey, session2);\n          }).on(\"error\", function(err) {\n            if (sessionKey && err.code !== \"UND_ERR_INFO\") {\n              sessionCache.delete(sessionKey);\n            }\n          });\n        } else {\n          assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n          socket = net2.connect({\n            highWaterMark: 64 * 1024,\n            ...options,\n            port: port || 80,\n            host: hostname3\n          });\n        }\n        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n          cancelTimeout();\n          if (callback) {\n            const cb = callback;\n            callback = null;\n            cb(null, this);\n          }\n        }).on(\"error\", function(err) {\n          cancelTimeout();\n          if (callback) {\n            const cb = callback;\n            callback = null;\n            cb(err);\n          }\n        });\n        return socket;\n      }, \"connect\");\n    }\n    __name(buildConnector, \"buildConnector\");\n    function setupTimeout(onConnectTimeout2, timeout) {\n      if (!timeout) {\n        return () => {\n        };\n      }\n      let s1 = null;\n      let s2 = null;\n      const timeoutId = setTimeout(() => {\n        s1 = setImmediate(() => {\n          if (process.platform === \"win32\") {\n            s2 = setImmediate(() => onConnectTimeout2());\n          } else {\n            onConnectTimeout2();\n          }\n        });\n      }, timeout);\n      return () => {\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n      };\n    }\n    __name(setupTimeout, \"setupTimeout\");\n    function onConnectTimeout(socket) {\n      util2.destroy(socket, new ConnectTimeoutError());\n    }\n    __name(onConnectTimeout, \"onConnectTimeout\");\n    module2.exports = buildConnector;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/utils.js\nvar require_utils = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/utils.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.enumToMap = void 0;\n    function enumToMap(obj) {\n      const res = {};\n      Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === \"number\") {\n          res[key] = value;\n        }\n      });\n      return res;\n    }\n    __name(enumToMap, \"enumToMap\");\n    exports.enumToMap = enumToMap;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/constants.js\nvar require_constants2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/constants.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\n    var utils_1 = require_utils();\n    var ERROR;\n    (function(ERROR2) {\n      ERROR2[ERROR2[\"OK\"] = 0] = \"OK\";\n      ERROR2[ERROR2[\"INTERNAL\"] = 1] = \"INTERNAL\";\n      ERROR2[ERROR2[\"STRICT\"] = 2] = \"STRICT\";\n      ERROR2[ERROR2[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n      ERROR2[ERROR2[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n      ERROR2[ERROR2[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n      ERROR2[ERROR2[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n      ERROR2[ERROR2[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n      ERROR2[ERROR2[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n      ERROR2[ERROR2[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n      ERROR2[ERROR2[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n      ERROR2[ERROR2[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n      ERROR2[ERROR2[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n      ERROR2[ERROR2[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n      ERROR2[ERROR2[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n      ERROR2[ERROR2[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n      ERROR2[ERROR2[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n      ERROR2[ERROR2[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n      ERROR2[ERROR2[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n      ERROR2[ERROR2[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n      ERROR2[ERROR2[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n      ERROR2[ERROR2[\"PAUSED\"] = 21] = \"PAUSED\";\n      ERROR2[ERROR2[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n      ERROR2[ERROR2[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n      ERROR2[ERROR2[\"USER\"] = 24] = \"USER\";\n    })(ERROR = exports.ERROR || (exports.ERROR = {}));\n    var TYPE;\n    (function(TYPE2) {\n      TYPE2[TYPE2[\"BOTH\"] = 0] = \"BOTH\";\n      TYPE2[TYPE2[\"REQUEST\"] = 1] = \"REQUEST\";\n      TYPE2[TYPE2[\"RESPONSE\"] = 2] = \"RESPONSE\";\n    })(TYPE = exports.TYPE || (exports.TYPE = {}));\n    var FLAGS;\n    (function(FLAGS2) {\n      FLAGS2[FLAGS2[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n      FLAGS2[FLAGS2[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n      FLAGS2[FLAGS2[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n      FLAGS2[FLAGS2[\"CHUNKED\"] = 8] = \"CHUNKED\";\n      FLAGS2[FLAGS2[\"UPGRADE\"] = 16] = \"UPGRADE\";\n      FLAGS2[FLAGS2[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n      FLAGS2[FLAGS2[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n      FLAGS2[FLAGS2[\"TRAILING\"] = 128] = \"TRAILING\";\n      FLAGS2[FLAGS2[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n    })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\n    var LENIENT_FLAGS;\n    (function(LENIENT_FLAGS2) {\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"HEADERS\"] = 1] = \"HEADERS\";\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n    })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\n    var METHODS;\n    (function(METHODS2) {\n      METHODS2[METHODS2[\"DELETE\"] = 0] = \"DELETE\";\n      METHODS2[METHODS2[\"GET\"] = 1] = \"GET\";\n      METHODS2[METHODS2[\"HEAD\"] = 2] = \"HEAD\";\n      METHODS2[METHODS2[\"POST\"] = 3] = \"POST\";\n      METHODS2[METHODS2[\"PUT\"] = 4] = \"PUT\";\n      METHODS2[METHODS2[\"CONNECT\"] = 5] = \"CONNECT\";\n      METHODS2[METHODS2[\"OPTIONS\"] = 6] = \"OPTIONS\";\n      METHODS2[METHODS2[\"TRACE\"] = 7] = \"TRACE\";\n      METHODS2[METHODS2[\"COPY\"] = 8] = \"COPY\";\n      METHODS2[METHODS2[\"LOCK\"] = 9] = \"LOCK\";\n      METHODS2[METHODS2[\"MKCOL\"] = 10] = \"MKCOL\";\n      METHODS2[METHODS2[\"MOVE\"] = 11] = \"MOVE\";\n      METHODS2[METHODS2[\"PROPFIND\"] = 12] = \"PROPFIND\";\n      METHODS2[METHODS2[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n      METHODS2[METHODS2[\"SEARCH\"] = 14] = \"SEARCH\";\n      METHODS2[METHODS2[\"UNLOCK\"] = 15] = \"UNLOCK\";\n      METHODS2[METHODS2[\"BIND\"] = 16] = \"BIND\";\n      METHODS2[METHODS2[\"REBIND\"] = 17] = \"REBIND\";\n      METHODS2[METHODS2[\"UNBIND\"] = 18] = \"UNBIND\";\n      METHODS2[METHODS2[\"ACL\"] = 19] = \"ACL\";\n      METHODS2[METHODS2[\"REPORT\"] = 20] = \"REPORT\";\n      METHODS2[METHODS2[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n      METHODS2[METHODS2[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n      METHODS2[METHODS2[\"MERGE\"] = 23] = \"MERGE\";\n      METHODS2[METHODS2[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n      METHODS2[METHODS2[\"NOTIFY\"] = 25] = \"NOTIFY\";\n      METHODS2[METHODS2[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n      METHODS2[METHODS2[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n      METHODS2[METHODS2[\"PATCH\"] = 28] = \"PATCH\";\n      METHODS2[METHODS2[\"PURGE\"] = 29] = \"PURGE\";\n      METHODS2[METHODS2[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n      METHODS2[METHODS2[\"LINK\"] = 31] = \"LINK\";\n      METHODS2[METHODS2[\"UNLINK\"] = 32] = \"UNLINK\";\n      METHODS2[METHODS2[\"SOURCE\"] = 33] = \"SOURCE\";\n      METHODS2[METHODS2[\"PRI\"] = 34] = \"PRI\";\n      METHODS2[METHODS2[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n      METHODS2[METHODS2[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n      METHODS2[METHODS2[\"SETUP\"] = 37] = \"SETUP\";\n      METHODS2[METHODS2[\"PLAY\"] = 38] = \"PLAY\";\n      METHODS2[METHODS2[\"PAUSE\"] = 39] = \"PAUSE\";\n      METHODS2[METHODS2[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n      METHODS2[METHODS2[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n      METHODS2[METHODS2[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n      METHODS2[METHODS2[\"REDIRECT\"] = 43] = \"REDIRECT\";\n      METHODS2[METHODS2[\"RECORD\"] = 44] = \"RECORD\";\n      METHODS2[METHODS2[\"FLUSH\"] = 45] = \"FLUSH\";\n    })(METHODS = exports.METHODS || (exports.METHODS = {}));\n    exports.METHODS_HTTP = [\n      METHODS.DELETE,\n      METHODS.GET,\n      METHODS.HEAD,\n      METHODS.POST,\n      METHODS.PUT,\n      METHODS.CONNECT,\n      METHODS.OPTIONS,\n      METHODS.TRACE,\n      METHODS.COPY,\n      METHODS.LOCK,\n      METHODS.MKCOL,\n      METHODS.MOVE,\n      METHODS.PROPFIND,\n      METHODS.PROPPATCH,\n      METHODS.SEARCH,\n      METHODS.UNLOCK,\n      METHODS.BIND,\n      METHODS.REBIND,\n      METHODS.UNBIND,\n      METHODS.ACL,\n      METHODS.REPORT,\n      METHODS.MKACTIVITY,\n      METHODS.CHECKOUT,\n      METHODS.MERGE,\n      METHODS[\"M-SEARCH\"],\n      METHODS.NOTIFY,\n      METHODS.SUBSCRIBE,\n      METHODS.UNSUBSCRIBE,\n      METHODS.PATCH,\n      METHODS.PURGE,\n      METHODS.MKCALENDAR,\n      METHODS.LINK,\n      METHODS.UNLINK,\n      METHODS.PRI,\n      METHODS.SOURCE\n    ];\n    exports.METHODS_ICE = [\n      METHODS.SOURCE\n    ];\n    exports.METHODS_RTSP = [\n      METHODS.OPTIONS,\n      METHODS.DESCRIBE,\n      METHODS.ANNOUNCE,\n      METHODS.SETUP,\n      METHODS.PLAY,\n      METHODS.PAUSE,\n      METHODS.TEARDOWN,\n      METHODS.GET_PARAMETER,\n      METHODS.SET_PARAMETER,\n      METHODS.REDIRECT,\n      METHODS.RECORD,\n      METHODS.FLUSH,\n      METHODS.GET,\n      METHODS.POST\n    ];\n    exports.METHOD_MAP = utils_1.enumToMap(METHODS);\n    exports.H_METHOD_MAP = {};\n    Object.keys(exports.METHOD_MAP).forEach((key) => {\n      if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n      }\n    });\n    var FINISH;\n    (function(FINISH2) {\n      FINISH2[FINISH2[\"SAFE\"] = 0] = \"SAFE\";\n      FINISH2[FINISH2[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n      FINISH2[FINISH2[\"UNSAFE\"] = 2] = \"UNSAFE\";\n    })(FINISH = exports.FINISH || (exports.FINISH = {}));\n    exports.ALPHA = [];\n    for (let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++) {\n      exports.ALPHA.push(String.fromCharCode(i));\n      exports.ALPHA.push(String.fromCharCode(i + 32));\n    }\n    exports.NUM_MAP = {\n      0: 0,\n      1: 1,\n      2: 2,\n      3: 3,\n      4: 4,\n      5: 5,\n      6: 6,\n      7: 7,\n      8: 8,\n      9: 9\n    };\n    exports.HEX_MAP = {\n      0: 0,\n      1: 1,\n      2: 2,\n      3: 3,\n      4: 4,\n      5: 5,\n      6: 6,\n      7: 7,\n      8: 8,\n      9: 9,\n      A: 10,\n      B: 11,\n      C: 12,\n      D: 13,\n      E: 14,\n      F: 15,\n      a: 10,\n      b: 11,\n      c: 12,\n      d: 13,\n      e: 14,\n      f: 15\n    };\n    exports.NUM = [\n      \"0\",\n      \"1\",\n      \"2\",\n      \"3\",\n      \"4\",\n      \"5\",\n      \"6\",\n      \"7\",\n      \"8\",\n      \"9\"\n    ];\n    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\n    exports.MARK = [\"-\", \"_\", \".\", \"!\", \"~\", \"*\", \"'\", \"(\", \")\"];\n    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\"%\", \";\", \":\", \"&\", \"=\", \"+\", \"$\", \",\"]);\n    exports.STRICT_URL_CHAR = [\n      \"!\",\n      '\"',\n      \"$\",\n      \"%\",\n      \"&\",\n      \"'\",\n      \"(\",\n      \")\",\n      \"*\",\n      \"+\",\n      \",\",\n      \"-\",\n      \".\",\n      \"/\",\n      \":\",\n      \";\",\n      \"<\",\n      \"=\",\n      \">\",\n      \"@\",\n      \"[\",\n      \"\\\\\",\n      \"]\",\n      \"^\",\n      \"_\",\n      \"`\",\n      \"{\",\n      \"|\",\n      \"}\",\n      \"~\"\n    ].concat(exports.ALPHANUM);\n    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\"\t\", \"\\f\"]);\n    for (let i = 128; i <= 255; i++) {\n      exports.URL_CHAR.push(i);\n    }\n    exports.HEX = exports.NUM.concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]);\n    exports.STRICT_TOKEN = [\n      \"!\",\n      \"#\",\n      \"$\",\n      \"%\",\n      \"&\",\n      \"'\",\n      \"*\",\n      \"+\",\n      \"-\",\n      \".\",\n      \"^\",\n      \"_\",\n      \"`\",\n      \"|\",\n      \"~\"\n    ].concat(exports.ALPHANUM);\n    exports.TOKEN = exports.STRICT_TOKEN.concat([\" \"]);\n    exports.HEADER_CHARS = [\"\t\"];\n    for (let i = 32; i <= 255; i++) {\n      if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n      }\n    }\n    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\n    exports.MAJOR = exports.NUM_MAP;\n    exports.MINOR = exports.MAJOR;\n    var HEADER_STATE;\n    (function(HEADER_STATE2) {\n      HEADER_STATE2[HEADER_STATE2[\"GENERAL\"] = 0] = \"GENERAL\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION\"] = 1] = \"CONNECTION\";\n      HEADER_STATE2[HEADER_STATE2[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n      HEADER_STATE2[HEADER_STATE2[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n      HEADER_STATE2[HEADER_STATE2[\"UPGRADE\"] = 4] = \"UPGRADE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n      HEADER_STATE2[HEADER_STATE2[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\n    exports.SPECIAL_HEADERS = {\n      \"connection\": HEADER_STATE.CONNECTION,\n      \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n      \"proxy-connection\": HEADER_STATE.CONNECTION,\n      \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n      \"upgrade\": HEADER_STATE.UPGRADE\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp.wasm.js\nvar require_llhttp_wasm = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp.wasm.js\"(exports, module2) {\n    module2.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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f2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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HgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcN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ImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiAC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IiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABB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QR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVO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AAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\";\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js\nvar require_llhttp_simd_wasm = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js\"(exports, module2) {\n    module2.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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ASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4OsAEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGhweHyAjJCUmJygpKiwtLi8w+wI0Njg5PD9BQkNERUZHSElKS0xNTk9QUVJTVVdZXF1eYGJjZGVmZ2hrbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHaAeAB4QHkAfEBvQK9AgsgASIIIAJHDcIBQbwBIR4MlQMLIAEiHiACRw2xAUGsASEeDJQDCyABIgEgAkcNZ0HiACEeDJMDCyABIgEgAkcNXUHaACEeDJIDCyABIgEgAkcNVkHVACEeDJEDCyABIgEgAkcNUkHTACEeDJADCyABIgEgAkcNT0HRACEeDI8DCyABIgEgAkcNTEHPACEeDI4DCyABIgEgAkcNEEEMIR4MjQMLIAEiASACRw0zQTghHgyMAwsgASIBIAJHDS9BNSEeDIsDCyABIgEgAkcNJkEyIR4MigMLIAEiASACRw0kQS8hHgyJAwsgASIBIAJHDR1BJCEeDIgDCyAALQAuQQFGDf0CDMcBCyAAIAEiASACELSAgIAAQQFHDbQBDLUBCyAAIAEiASACEK2AgIAAIh4NtQEgASEBDLACCwJAIAEiASACRw0AQQYhHgyFAwsgACABQQFqIgEgAhCwgICAACIeDbYBIAEhAQwPCyAAQgA3AyBBEyEeDPMCCyABIh4gAkcNCUEPIR4MggMLAkAgASIBIAJGDQAgAUEBaiEBQREhHgzyAgtBByEeDIEDCyAAQgAgACkDICIfIAIgASIea60iIH0iISAhIB9WGzcDICAfICBWIiJFDbMBQQghHgyAAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBFSEeDPACC0EJIR4M/wILIAEhASAAKQMgUA2yASABIQEMrQILAkAgASIBIAJHDQBBCyEeDP4CCyAAIAFBAWoiASACEK+AgIAAIh4NsgEgASEBDK0CCwNAAkAgAS0AAEHwnYCAAGotAAAiHkEBRg0AIB5BAkcNtAEgAUEBaiEBDAMLIAFBAWoiASACRw0AC0EMIR4M/AILAkAgASIBIAJHDQBBDSEeDPwCCwJAAkAgAS0AACIeQXNqDhQBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBALQBCyABQQFqIQEMtAELIAFBAWohAQtBGCEeDOoCCwJAIAEiHiACRw0AQQ4hHgz6AgtCACEfIB4hAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHi0AAEFQag43yAHHAQABAgMEBQYHvgK+Ar4CvgK+Ar4CvgIICQoLDA2+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CDg8QERITvgILQgIhHwzHAQtCAyEfDMYBC0IEIR8MxQELQgUhHwzEAQtCBiEfDMMBC0IHIR8MwgELQgghHwzBAQtCCSEfDMABC0IKIR8MvwELQgshHwy+AQtCDCEfDL0BC0INIR8MvAELQg4hHwy7AQtCDyEfDLoBC0IKIR8MuQELQgshHwy4AQtCDCEfDLcBC0INIR8MtgELQg4hHwy1AQtCDyEfDLQBC0IAIR8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4tAABBUGoON8cBxgEAAQIDBAUGB8gByAHIAcgByAHIAcgBCAkKCwwNyAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAQ4PEBESE8gBC0ICIR8MxgELQgMhHwzFAQtCBCEfDMQBC0IFIR8MwwELQgYhHwzCAQtCByEfDMEBC0IIIR8MwAELQgkhHwy/AQtCCiEfDL4BC0ILIR8MvQELQgwhHwy8AQtCDSEfDLsBC0IOIR8MugELQg8hHwy5AQtCCiEfDLgBC0ILIR8MtwELQgwhHwy2AQtCDSEfDLUBC0IOIR8MtAELQg8hHwyzAQsgAEIAIAApAyAiHyACIAEiHmutIiB9IiEgISAfVhs3AyAgHyAgViIiRQ20AUERIR4M9wILAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRshHgznAgtBEiEeDPYCCyAAIAEiHiACELKAgIAAQX9qDgWmAQCiAgGzAbQBC0ESIR4M5AILIABBAToALyAeIQEM8gILIAEiASACRw20AUEWIR4M8gILIAEiHCACRw0ZQTkhHgzxAgsCQCABIgEgAkcNAEEaIR4M8QILIABBADYCBCAAQYqAgIAANgIIIAAgASABEKqAgIAAIh4NtgEgASEBDLkBCwJAIAEiHiACRw0AQRshHgzwAgsCQCAeLQAAIgFBIEcNACAeQQFqIQEMGgsgAUEJRw22ASAeQQFqIQEMGQsCQCABIgEgAkYNACABQQFqIQEMFAtBHCEeDO4CCwJAIAEiHiACRw0AQR0hHgzuAgsCQCAeLQAAIgFBCUcNACAeIQEM0gILIAFBIEcNtQEgHiEBDNECCwJAIAEiASACRw0AQR4hHgztAgsgAS0AAEEKRw24ASABQQFqIQEMoAILIAEiASACRw24AUEiIR4M6wILA0ACQCABLQAAIh5BIEYNAAJAIB5BdmoOBAC+Ab4BALwBCyABIQEMxAELIAFBAWoiASACRw0AC0EkIR4M6gILQSUhHiABIiMgAkYN6QIgAiAjayAAKAIAIiRqISUgIyEmICQhAQJAA0AgJi0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHwn4CAAGotAABHDQEgAUEDRg3WAiABQQFqIQEgJkEBaiImIAJHDQALIAAgJTYCAAzqAgsgAEEANgIAICYhAQy7AQtBJiEeIAEiIyACRg3oAiACICNrIAAoAgAiJGohJSAjISYgJCEBAkADQCAmLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQfSfgIAAai0AAEcNASABQQhGDb0BIAFBAWohASAmQQFqIiYgAkcNAAsgACAlNgIADOkCCyAAQQA2AgAgJiEBDLoBC0EnIR4gASIjIAJGDecCIAIgI2sgACgCACIkaiElICMhJiAkIQECQANAICYtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFB0KaAgABqLQAARw0BIAFBBUYNvQEgAUEBaiEBICZBAWoiJiACRw0ACyAAICU2AgAM6AILIABBADYCACAmIQEMuQELAkAgASIBIAJGDQADQAJAIAEtAABBgKKAgABqLQAAIh5BAUYNACAeQQJGDQogASEBDMEBCyABQQFqIgEgAkcNAAtBIyEeDOcCC0EjIR4M5gILAkAgASIBIAJGDQADQAJAIAEtAAAiHkEgRg0AIB5BdmoOBL0BvgG+Ab0BvgELIAFBAWoiASACRw0AC0ErIR4M5gILQSshHgzlAgsDQAJAIAEtAAAiHkEgRg0AIB5BCUcNAwsgAUEBaiIBIAJHDQALQS8hHgzkAgsDQAJAIAEtAAAiHkEgRg0AAkACQCAeQXZqDgS+AQEBvgEACyAeQSxGDb8BCyABIQEMBAsgAUEBaiIBIAJHDQALQTIhHgzjAgsgASEBDL8BC0EzIR4gASImIAJGDeECIAIgJmsgACgCACIjaiEkICYhIiAjIQECQANAICItAABBIHIgAUGApICAAGotAABHDQEgAUEGRg3QAiABQQFqIQEgIkEBaiIiIAJHDQALIAAgJDYCAAziAgsgAEEANgIAICIhAQtBKyEeDNACCwJAIAEiHSACRw0AQTQhHgzgAgsgAEGKgICAADYCCCAAIB02AgQgHSEBIAAtACxBf2oOBK8BuQG7Ab0BxwILIAFBAWohAQyuAQsCQCABIgEgAkYNAANAAkAgAS0AACIeQSByIB4gHkG/f2pB/wFxQRpJG0H/AXEiHkEJRg0AIB5BIEYNAAJAAkACQAJAIB5BnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQSYhHgzTAgsgAUEBaiEBQSchHgzSAgsgAUEBaiEBQSghHgzRAgsgASEBDLIBCyABQQFqIgEgAkcNAAtBKCEeDN4CC0EoIR4M3QILAkAgASIBIAJGDQADQAJAIAEtAABBgKCAgABqLQAAQQFGDQAgASEBDLcBCyABQQFqIgEgAkcNAAtBMCEeDN0CC0EwIR4M3AILAkADQAJAIAEtAABBd2oOGAACwQLBAscCwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECAMECCyABQQFqIgEgAkcNAAtBNSEeDNwCCyABQQFqIQELQSEhHgzKAgsgASIBIAJHDbkBQTchHgzZAgsDQAJAIAEtAABBkKSAgABqLQAAQQFGDQAgASEBDJACCyABQQFqIgEgAkcNAAtBOCEeDNgCCyAcLQAAIh5BIEYNmgEgHkE6Rw3GAiAAKAIEIQEgAEEANgIEIAAgASAcEKiAgIAAIgENtgEgHEEBaiEBDLgBCyAAIAEgAhCpgICAABoLQQohHgzFAgtBOiEeIAEiJiACRg3UAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZCmgIAAai0AAEcNxAIgAUEFRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNUCCyAAQQA2AgAgAEEBOgAsICYgI2tBBmohAQy+AgtBOyEeIAEiJiACRg3TAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZamgIAAai0AAEcNwwIgAUEJRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNQCCyAAQQA2AgAgAEECOgAsICYgI2tBCmohAQy9AgsCQCABIhwgAkcNAEE8IR4M0wILAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwDDAsMCwwLDAsMCAcMCCyAcQQFqIQFBMiEeDMMCCyAcQQFqIQFBMyEeDMICC0E9IR4gASImIAJGDdECIAIgJmsgACgCACIjaiEkICYhHCAjIQEDQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaCmgIAAai0AAEcNwAIgAUEBRg20AiABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzRAgtBPiEeIAEiJiACRg3QAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaKmgIAAai0AAEcNwAIgAUEORg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNECCyAAQQA2AgAgAEEBOgAsICYgI2tBD2ohAQy6AgtBPyEeIAEiJiACRg3PAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQcCmgIAAai0AAEcNvwIgAUEPRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNACCyAAQQA2AgAgAEEDOgAsICYgI2tBEGohAQy5AgtBwAAhHiABIiYgAkYNzgIgAiAmayAAKAIAIiNqISQgJiEcICMhAQJAA0AgHC0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHQpoCAAGotAABHDb4CIAFBBUYNASABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzPAgsgAEEANgIAIABBBDoALCAmICNrQQZqIQEMuAILAkAgASIcIAJHDQBBwQAhHgzOAgsCQAJAAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGdf2oOEwDAAsACwALAAsACwALAAsACwALAAsACwAIBwALAAsACAgPAAgsgHEEBaiEBQTUhHgzAAgsgHEEBaiEBQTYhHgy/AgsgHEEBaiEBQTchHgy+AgsgHEEBaiEBQTghHgy9AgsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBOSEeDL0CC0HCACEeDMwCCyABIgEgAkcNrwFBxAAhHgzLAgtBxQAhHiABIiYgAkYNygIgAiAmayAAKAIAIiNqISQgJiEiICMhAQJAA0AgIi0AACABQdamgIAAai0AAEcNtAEgAUEBRg0BIAFBAWohASAiQQFqIiIgAkcNAAsgACAkNgIADMsCCyAAQQA2AgAgJiAja0ECaiEBDK8BCwJAIAEiASACRw0AQccAIR4MygILIAEtAABBCkcNswEgAUEBaiEBDK8BCwJAIAEiASACRw0AQcgAIR4MyQILAkACQCABLQAAQXZqDgQBtAG0AQC0AQsgAUEBaiEBQT0hHgy5AgsgAUEBaiEBDK4BCwJAIAEiASACRw0AQckAIR4MyAILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KuwG6AQABAgMEBQYHvAELQQIhHgy6AQtBAyEeDLkBC0EEIR4MuAELQQUhHgy3AQtBBiEeDLYBC0EHIR4MtQELQQghHgy0AQtBCSEeDLMBCwJAIAEiASACRw0AQcoAIR4MxwILIAEtAABBLkcNtAEgAUEBaiEBDIACCwJAIAEiASACRw0AQcsAIR4MxgILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KvQG8AQABAgMEBQYHvgELQQIhHgy8AQtBAyEeDLsBC0EEIR4MugELQQUhHgy5AQtBBiEeDLgBC0EHIR4MtwELQQghHgy2AQtBCSEeDLUBC0HMACEeIAEiJiACRg3EAiACICZrIAAoAgAiI2ohJCAmIQEgIyEiA0AgAS0AACAiQeKmgIAAai0AAEcNuAEgIkEDRg23ASAiQQFqISIgAUEBaiIBIAJHDQALIAAgJDYCAAzEAgtBzQAhHiABIiYgAkYNwwIgAiAmayAAKAIAIiNqISQgJiEBICMhIgNAIAEtAAAgIkHmpoCAAGotAABHDbcBICJBAkYNuQEgIkEBaiEiIAFBAWoiASACRw0ACyAAICQ2AgAMwwILQc4AIR4gASImIAJGDcICIAIgJmsgACgCACIjaiEkICYhASAjISIDQCABLQAAICJB6aaAgABqLQAARw22ASAiQQNGDbkBICJBAWohIiABQQFqIgEgAkcNAAsgACAkNgIADMICCwNAAkAgAS0AACIeQSBGDQACQAJAAkAgHkG4f2oOCwABugG6AboBugG6AboBugG6AQK6AQsgAUEBaiEBQcIAIR4MtQILIAFBAWohAUHDACEeDLQCCyABQQFqIQFBxAAhHgyzAgsgAUEBaiIBIAJHDQALQc8AIR4MwQILAkAgASIBIAJGDQAgACABQQFqIgEgAhClgICAABogASEBQQchHgyxAgtB0AAhHgzAAgsDQAJAIAEtAABB8KaAgABqLQAAIh5BAUYNACAeQX5qDgO5AboBuwG8AQsgAUEBaiIBIAJHDQALQdEAIR4MvwILAkAgASIBIAJGDQAgAUEBaiEBDAMLQdIAIR4MvgILA0ACQCABLQAAQfCogIAAai0AACIeQQFGDQACQCAeQX5qDgS8Ab0BvgEAvwELIAEhAUHGACEeDK8CCyABQQFqIgEgAkcNAAtB0wAhHgy9AgsCQCABIgEgAkcNAEHUACEeDL0CCwJAIAEtAAAiHkF2ag4apAG/Ab8BpgG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG0Ab8BvwEAvQELIAFBAWohAQtBBiEeDKsCCwNAAkAgAS0AAEHwqoCAAGotAABBAUYNACABIQEM+gELIAFBAWoiASACRw0AC0HVACEeDLoCCwJAIAEiASACRg0AIAFBAWohAQwDC0HWACEeDLkCCwJAIAEiASACRw0AQdcAIR4MuQILIAFBAWohAQwBCwJAIAEiASACRw0AQdgAIR4MuAILIAFBAWohAQtBBCEeDKYCCwJAIAEiIiACRw0AQdkAIR4MtgILICIhAQJAAkACQCAiLQAAQfCsgIAAai0AAEF/ag4HvgG/AcABAPgBAQLBAQsgIkEBaiEBDAoLICJBAWohAQy3AQtBACEeIABBADYCHCAAQfGOgIAANgIQIABBBzYCDCAAICJBAWo2AhQMtQILAkADQAJAIAEtAABB8KyAgABqLQAAIh5BBEYNAAJAAkAgHkF/ag4HvAG9Ab4BwwEABAHDAQsgASEBQckAIR4MqAILIAFBAWohAUHLACEeDKcCCyABQQFqIgEgAkcNAAtB2gAhHgy1AgsgAUEBaiEBDLUBCwJAIAEiIiACRw0AQdsAIR4MtAILICItAABBL0cNvgEgIkEBaiEBDAYLAkAgASIiIAJHDQBB3AAhHgyzAgsCQCAiLQAAIgFBL0cNACAiQQFqIQFBzAAhHgyjAgsgAUF2aiIBQRZLDb0BQQEgAXRBiYCAAnFFDb0BDJMCCwJAIAEiASACRg0AIAFBAWohAUHNACEeDKICC0HdACEeDLECCwJAIAEiIiACRw0AQd8AIR4MsQILICIhAQJAICItAABB8LCAgABqLQAAQX9qDgOSAvABAL4BC0HQACEeDKACCwJAIAEiIiACRg0AA0ACQCAiLQAAQfCugIAAai0AACIBQQNGDQACQCABQX9qDgKUAgC/AQsgIiEBQc4AIR4MogILICJBAWoiIiACRw0AC0HeACEeDLACC0HeACEeDK8CCwJAIAEiASACRg0AIABBjICAgAA2AgggACABNgIEIAEhAUHPACEeDJ8CC0HgACEeDK4CCwJAIAEiASACRw0AQeEAIR4MrgILIABBjICAgAA2AgggACABNgIEIAEhAQtBAyEeDJwCCwNAIAEtAABBIEcNjAIgAUEBaiIBIAJHDQALQeIAIR4MqwILAkAgASIBIAJHDQBB4wAhHgyrAgsgAS0AAEEgRw24ASABQQFqIQEM1AELAkAgASIIIAJHDQBB5AAhHgyqAgsgCC0AAEHMAEcNuwEgCEEBaiEBQRMhHgy5AQtB5QAhHiABIiIgAkYNqAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUHwsoCAAGotAABHDboBIAFBBUYNuAEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMqAILAkAgASIIIAJHDQBB5gAhHgyoAgsCQAJAIAgtAABBvX9qDgwAuwG7AbsBuwG7AbsBuwG7AbsBuwEBuwELIAhBAWohAUHUACEeDJgCCyAIQQFqIQFB1QAhHgyXAgtB5wAhHiABIiIgAkYNpgIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQe2zgIAAai0AAEcNuQEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKcCCyAAQQA2AgAgIiAma0EDaiEBQRAhHgy2AQtB6AAhHiABIiIgAkYNpQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfaygIAAai0AAEcNuAEgAUEFRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKYCCyAAQQA2AgAgIiAma0EGaiEBQRYhHgy1AQtB6QAhHiABIiIgAkYNpAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfyygIAAai0AAEcNtwEgAUEDRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKUCCyAAQQA2AgAgIiAma0EEaiEBQQUhHgy0AQsCQCABIgggAkcNAEHqACEeDKQCCyAILQAAQdkARw21ASAIQQFqIQFBCCEeDLMBCwJAIAEiCCACRw0AQesAIR4MowILAkACQCAILQAAQbJ/ag4DALYBAbYBCyAIQQFqIQFB2QAhHgyTAgsgCEEBaiEBQdoAIR4MkgILAkAgASIIIAJHDQBB7AAhHgyiAgsCQAJAIAgtAABBuH9qDggAtQG1AbUBtQG1AbUBAbUBCyAIQQFqIQFB2AAhHgySAgsgCEEBaiEBQdsAIR4MkQILQe0AIR4gASIiIAJGDaACIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGAs4CAAGotAABHDbMBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAyhAgtBACEeIABBADYCACAiICZrQQNqIQEMsAELQe4AIR4gASIiIAJGDZ8CIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGDs4CAAGotAABHDbIBIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAygAgsgAEEANgIAICIgJmtBBWohAUEjIR4MrwELAkAgASIIIAJHDQBB7wAhHgyfAgsCQAJAIAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJq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LwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMDIkBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxGCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIgBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDIcBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDIYBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxDCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIUBCyAAQQA2AhwgACABNgIUIABBooqAgAA2AhAgAEEHNgIMQQAhHgyEAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHEADYCHCAAIAE2AhQgACAeNgIMQQAhHgyDAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyCAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMPwsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgyBAQsgAEEANgIcIAAgATYCFCAAQbiIgIAANgIQIABBBzYCDEEAIR4MgAELIB5BP0cNASABQQFqIQELQQUhHgxuC0EAIR4gAEEANgIcIAAgATYCFCAAQdOPgIAANgIQIABBBzYCDAx9CyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw0CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDHwLIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDDQLIABBxQA2AhwgACABNgIUIAAgHjYCDEEAIR4MewsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOAsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgx6CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQwxCyAAQcQANgIcIAAgIjYCFCAAIAE2AgxBACEeDHkLIAAoAgQhASAAQQA2AgQCQCAAIAEgIhCkgICAACIBDQAgIiEBDDELIABBxQA2AhwgACAiNgIUIAAgATYCDEEAIR4MeAsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMNQsgAEHQADYCHCAAICI2AhQgACABNgIMQQAhHgx3CyAAQQA2AhwgACAiNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx2CyAAQQA2AhwgACABNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx1C0EAIR4gAEEANgIcIAAgIjYCFCAAQb+UgIAANgIQIABBBzYCDAx0CyAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMQQAhHgxzCyAAQQA2AhwgACAiNgIUIABB1I6AgAA2AhAgAEEHNgIMQQAhHgxyCyAAQQA2AhwgACABNgIUIABBwZOAgAA2AhAgAEEGNgIMQQAhHgxxCyAAQQA2AgAgIiAma0EGaiEBQSQhHgsgACAeOgApIAEhAQxOCyAAQQA2AgALQQAhHiAAQQA2AhwgACAINgIUIABBpJSAgAA2AhAgAEEGNgIMDG0LIAAoAgQhEyAAQQA2AgQgACATIB4QpoCAgAAiEw0BIB5BAWohEwtBnQEhHgxbCyAAQaoBNgIcIAAgEzYCDCAAIB5BAWo2AhRBACEeDGoLIAAoAgQhFCAAQQA2AgQgACAUIB4QpoCAgAAiFA0BIB5BAWohFAtBmgEhHgxYCyAAQasBNgIcIAAgFDYCDCAAIB5BAWo2AhRBACEeDGcLIABBADYCHCAAIBU2AhQgAEHzioCAADYCECAAQQ02AgxBACEeDGYLIABBADYCHCAAIBY2AhQgAEHOjYCAADYCECAAQQk2AgxBACEeDGULQQEhHgsgACAeOgArIBdBAWohFgwuCyAAQQA2AhwgACAXNgIUIABBoo2AgAA2AhAgAEEJNgIMQQAhHgxiCyAAQQA2AhwgACAYNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgxhC0EBIR4LIAAgHjoAKiAZQQFqIRgMLAsgAEEANgIcIAAgGTYCFCAAQbiNgIAANgIQIABBCTYCDEEAIR4MXgsgAEEANgIcIAAgGTYCFCAAQbmbgIAANgIQIABBCDYCDCAAQQA2AgBBACEeDF0LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGLlICAADYCECAAQQg2AgwMWwsgAEECOgAoIABBADYCACAbIBlrQQNqIRkMNgsgAEECOgAvIAAgCCACEKOAgIAAIh4NAUGvASEeDEkLIAAtAChBf2oOAh4gHwsgHkEVRw0nIABBuwE2AhwgACAINgIUIABBp5KAgAA2AhAgAEEVNgIMQQAhHgxXC0EAIR4MRgtBAiEeDEULQQ4hHgxEC0EQIR4MQwtBHCEeDEILQRQhHgxBC0EWIR4MQAtBFyEeDD8LQRkhHgw+C0EaIR4MPQtBOiEeDDwLQSMhHgw7C0EkIR4MOgtBMCEeDDkLQTshHgw4C0E8IR4MNwtBPiEeDDYLQT8hHgw1C0HAACEeDDQLQcEAIR4MMwtBxQAhHgwyC0HHACEeDDELQcgAIR4MMAtBygAhHgwvC0HfACEeDC4LQeIAIR4MLQtB+wAhHgwsC0GFASEeDCsLQZcBIR4MKgtBmQEhHgwpC0GpASEeDCgLQaQBIR4MJwtBmwEhHgwmC0GeASEeDCULQZ8BIR4MJAtBoQEhHgwjC0GiASEeDCILQacBIR4MIQtBqAEhHgwgCyAAQQA2AhwgACAINgIUIABB5ouAgAA2AhAgAEEQNgIMQQAhHgwvCyAAQQA2AgQgACAdIB0QqoCAgAAiAUUNASAAQS02AhwgACABNgIMIAAgHUEBajYCFEEAIR4MLgsgACgCBCEIIABBADYCBAJAIAAgCCABEKqAgIAAIghFDQAgAEEuNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDC4LIAFBAWohAQweCyAdQQFqIQEMHgsgAEEANgIcIAAgHTYCFCAAQbqPgIAANgIQIABBBDYCDEEAIR4MKwsgAEEpNgIcIAAgATYCFCAAIAg2AgxBACEeDCoLIBxBAWohAQweCyAAQQo2AhwgACABNgIUIABBkZKAgAA2AhAgAEEVNgIMQQAhHgwoCyAAQRA2AhwgACABNgIUIABBvpKAgAA2AhAgAEEVNgIMQQAhHgwnCyAAQQA2AhwgACAeNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhHgwmCyAAQQQ2AhwgACABNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgwlCyAAQQA2AgAgCCAia0EFaiEZC0GjASEeDBMLIABBADYCACAiICZrQQJqIQFB4wAhHgwSCyAAQQA2AgAgAEGBBDsBKCAaIB5rQQJqIQELQdMAIR4MEAsgASEBAkAgAC0AKUEFRw0AQdIAIR4MEAtB0QAhHgwPC0EAIR4gAEEANgIcIABBuo6AgAA2AhAgAEEHNgIMIAAgIkEBajYCFAweCyAAQQA2AgAgJiAja0ECaiEBQTQhHgwNCyABIQELQS0hHgwLCwJAIAEiHSACRg0AA0ACQCAdLQAAQYCigIAAai0AACIBQQFGDQAgAUECRw0DIB1BAWohAQwECyAdQQFqIh0gAkcNAAtBMSEeDBsLQTEhHgwaCyAAQQA6ACwgHSEBDAELQQwhHgwIC0EvIR4MBwsgAUEBaiEBQSIhHgwGC0EfIR4MBQsgAEEANgIAICMgJGtBBGohAUEGIR4LIAAgHjoALCABIQFBDSEeDAMLIABBADYCACAmICNrQQdqIQFBCyEeDAILIABBADYCAAsgAEEAOgAsIBwhAUEJIR4MAAsLQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA4LQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA0LQQAhHiAAQQA2AhwgACABNgIUIABBlo+AgAA2AhAgAEELNgIMDAwLQQAhHiAAQQA2AhwgACABNgIUIABB8YiAgAA2AhAgAEELNgIMDAsLQQAhHiAAQQA2AhwgACABNgIUIABBiI2AgAA2AhAgAEEKNgIMDAoLIABBAjYCHCAAIAE2AhQgAEHwkoCAADYCECAAQRY2AgxBACEeDAkLQQEhHgwIC0HGACEeIAEiASACRg0HIANBCGogACABIAJB2KaAgABBChC5gICAACADKAIMIQEgAygCCA4DAQcCAAsQv4CAgAAACyAAQQA2AhwgAEGJk4CAADYCECAAQRc2AgwgACABQQFqNgIUQQAhHgwFCyAAQQA2AhwgACABNgIUIABBnpOAgAA2AhAgAEEJNgIMQQAhHgwECwJAIAEiASACRw0AQSEhHgwECwJAIAEtAABBCkYNACAAQQA2AhwgACABNgIUIABB7oyAgAA2AhAgAEEKNgIMQQAhHgwECyAAKAIEIQggAEEANgIEIAAgCCABEKqAgIAAIggNASABQQFqIQELQQAhHiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJA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AkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQ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BQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv\";\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/client.js\nvar require_client = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/client.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var util2 = require_util2();\n    var Request = require_request();\n    var DispatcherBase = require_dispatcher_base();\n    var RedirectHandler = require_redirect();\n    var {\n      RequestContentLengthMismatchError,\n      ResponseContentLengthMismatchError,\n      InvalidArgumentError,\n      RequestAbortedError,\n      HeadersTimeoutError,\n      HeadersOverflowError,\n      SocketError,\n      InformationalError,\n      BodyTimeoutError,\n      HTTPParserError\n    } = require_errors();\n    var buildConnector = require_connect();\n    var {\n      kUrl,\n      kReset,\n      kServerName,\n      kClient,\n      kBusy,\n      kParser,\n      kConnect,\n      kBlocking,\n      kResuming,\n      kRunning,\n      kPending,\n      kSize,\n      kWriting,\n      kQueue,\n      kConnected,\n      kConnecting,\n      kNeedDrain,\n      kNoRef,\n      kKeepAliveDefaultTimeout,\n      kHostHeader,\n      kPendingIdx,\n      kRunningIdx,\n      kError,\n      kPipelining,\n      kSocket,\n      kKeepAliveTimeoutValue,\n      kMaxHeadersSize,\n      kKeepAliveMaxTimeout,\n      kKeepAliveTimeoutThreshold,\n      kHeadersTimeout,\n      kBodyTimeout,\n      kStrictContentLength,\n      kConnector,\n      kMaxRedirections,\n      kMaxRequests,\n      kCounter,\n      kClose,\n      kDestroy,\n      kDispatch\n    } = require_symbols();\n    var kClosedResolve = Symbol(\"kClosedResolve\");\n    var channels = {};\n    try {\n      const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n      channels.sendHeaders = diagnosticsChannel.channel(\"undici:client:sendHeaders\");\n      channels.beforeConnect = diagnosticsChannel.channel(\"undici:client:beforeConnect\");\n      channels.connectError = diagnosticsChannel.channel(\"undici:client:connectError\");\n      channels.connected = diagnosticsChannel.channel(\"undici:client:connected\");\n    } catch (e) {\n      channels.sendHeaders = { hasSubscribers: false };\n      channels.beforeConnect = { hasSubscribers: false };\n      channels.connectError = { hasSubscribers: false };\n      channels.connected = { hasSubscribers: false };\n    }\n    var Client = class extends DispatcherBase {\n      constructor(url, {\n        maxHeaderSize,\n        headersTimeout,\n        socketTimeout,\n        requestTimeout,\n        connectTimeout,\n        bodyTimeout,\n        idleTimeout,\n        keepAlive,\n        keepAliveTimeout,\n        maxKeepAliveTimeout,\n        keepAliveMaxTimeout,\n        keepAliveTimeoutThreshold,\n        socketPath,\n        pipelining,\n        tls,\n        strictContentLength,\n        maxCachedSessions,\n        maxRedirections,\n        connect: connect2,\n        maxRequestsPerClient\n      } = {}) {\n        super();\n        if (keepAlive !== void 0) {\n          throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n          throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n          throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n          throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n          throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n          throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n          throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n          throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect2 != null && typeof connect2 !== \"function\" && typeof connect2 !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n          throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (typeof connect2 !== \"function\") {\n          connect2 = buildConnector({\n            ...tls,\n            maxCachedSessions,\n            socketPath,\n            timeout: connectTimeout,\n            ...connect2\n          });\n        }\n        this[kUrl] = util2.parseOrigin(url);\n        this[kConnector] = connect2;\n        this[kSocket] = null;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || 16384;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kResuming] = 0;\n        this[kNeedDrain] = 0;\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n      }\n      get pipelining() {\n        return this[kPipelining];\n      }\n      set pipelining(value) {\n        this[kPipelining] = value;\n        resume(this, true);\n      }\n      get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n      }\n      get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n      }\n      get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n      }\n      get [kConnected]() {\n        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n      }\n      get [kBusy]() {\n        const socket = this[kSocket];\n        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n      }\n      [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n      }\n      [kDispatch](opts, handler) {\n        const { maxRedirections = this[kMaxRedirections] } = opts;\n        if (maxRedirections) {\n          handler = new RedirectHandler(this, maxRedirections, opts, handler);\n        }\n        const origin = opts.origin || this[kUrl].origin;\n        const request2 = new Request(origin, opts, handler);\n        this[kQueue].push(request2);\n        if (this[kResuming]) {\n        } else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {\n          this[kResuming] = 1;\n          process.nextTick(resume, this);\n        } else {\n          resume(this, true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n          this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n      }\n      async [kClose]() {\n        return new Promise((resolve) => {\n          if (!this[kSize]) {\n            this.destroy(resolve);\n          } else {\n            this[kClosedResolve] = resolve;\n          }\n        });\n      }\n      async [kDestroy](err) {\n        return new Promise((resolve) => {\n          const requests = this[kQueue].splice(this[kPendingIdx]);\n          for (let i = 0; i < requests.length; i++) {\n            const request2 = requests[i];\n            errorRequest(this, request2, err);\n          }\n          const callback = /* @__PURE__ */ __name(() => {\n            if (this[kClosedResolve]) {\n              this[kClosedResolve]();\n              this[kClosedResolve] = null;\n            }\n            resolve();\n          }, \"callback\");\n          if (!this[kSocket]) {\n            queueMicrotask(callback);\n          } else {\n            util2.destroy(this[kSocket].on(\"close\", callback), err);\n          }\n          resume(this);\n        });\n      }\n    };\n    __name(Client, \"Client\");\n    var constants = require_constants2();\n    var EMPTY_BUF = Buffer.alloc(0);\n    async function lazyllhttp() {\n      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;\n      let mod2;\n      try {\n        mod2 = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), \"base64\"));\n      } catch (e) {\n        mod2 = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), \"base64\"));\n      }\n      return await WebAssembly.instantiate(mod2, {\n        env: {\n          wasm_on_url: (p, at, len) => {\n            return 0;\n          },\n          wasm_on_status: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_message_begin: (p) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onMessageBegin() || 0;\n          },\n          wasm_on_header_field: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_header_value: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n          },\n          wasm_on_body: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_message_complete: (p) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onMessageComplete() || 0;\n          }\n        }\n      });\n    }\n    __name(lazyllhttp, \"lazyllhttp\");\n    var llhttpInstance = null;\n    var llhttpPromise = lazyllhttp().catch(() => {\n    });\n    var currentParser = null;\n    var currentBufferRef = null;\n    var currentBufferSize = 0;\n    var currentBufferPtr = null;\n    var TIMEOUT_HEADERS = 1;\n    var TIMEOUT_BODY = 2;\n    var TIMEOUT_IDLE = 3;\n    var Parser = class {\n      constructor(client, socket, { exports: exports2 }) {\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports2;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n      }\n      setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n          clearTimeout(this.timeout);\n          if (value) {\n            this.timeout = setTimeout(onParserTimeout, value, this);\n            if (this.timeout.unref) {\n              this.timeout.unref();\n            }\n          } else {\n            this.timeout = null;\n          }\n          this.timeoutValue = value;\n        } else if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n      }\n      resume() {\n        if (this.socket.destroyed || !this.paused) {\n          return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF);\n        this.readMore();\n      }\n      readMore() {\n        while (!this.paused && this.ptr) {\n          const chunk = this.socket.read();\n          if (chunk === null) {\n            break;\n          }\n          this.execute(chunk);\n        }\n      }\n      execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n          if (currentBufferPtr) {\n            llhttp.free(currentBufferPtr);\n          }\n          currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n          currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        try {\n          let ret;\n          try {\n            currentBufferRef = data;\n            currentParser = this;\n            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n          } catch (err) {\n            throw err;\n          } finally {\n            currentParser = null;\n            currentBufferRef = null;\n          }\n          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n          if (ret === constants.ERROR.PAUSED_UPGRADE) {\n            this.onUpgrade(data.slice(offset));\n          } else if (ret === constants.ERROR.PAUSED) {\n            this.paused = true;\n            socket.unshift(data.slice(offset));\n          } else if (ret !== constants.ERROR.OK) {\n            const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n            let message = \"\";\n            if (ptr) {\n              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n              message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n            }\n            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n          }\n        } catch (err) {\n          util2.destroy(socket, err);\n        }\n      }\n      finish() {\n        try {\n          try {\n            currentParser = this;\n          } finally {\n            currentParser = null;\n          }\n        } catch (err) {\n          util2.destroy(this.socket, err);\n        }\n      }\n      destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n      }\n      onStatus(buf) {\n        this.statusText = buf.toString();\n      }\n      onMessageBegin() {\n        const { socket, client } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        if (!request2) {\n          return -1;\n        }\n      }\n      onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n          this.headers.push(buf);\n        } else {\n          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n        }\n        this.trackHeader(buf.length);\n      }\n      onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n          this.headers.push(buf);\n          len += 1;\n        } else {\n          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === \"keep-alive\") {\n          this.keepAlive += buf.toString();\n        } else if (key.length === 14 && key.toString().toLowerCase() === \"content-length\") {\n          this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n      }\n      trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n          util2.destroy(this.socket, new HeadersOverflowError());\n        }\n      }\n      onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request2.upgrade || request2.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        socket.removeListener(\"error\", onSocketError).removeListener(\"readable\", onSocketReadable).removeListener(\"end\", onSocketEnd).removeListener(\"close\", onSocketClose);\n        client[kSocket] = null;\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [client], new InformationalError(\"upgrade\"));\n        try {\n          request2.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n          util2.destroy(socket, err);\n        }\n        resume(client);\n      }\n      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        if (!request2) {\n          return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n          util2.destroy(socket, new SocketError(\"bad response\", util2.getSocketInfo(socket)));\n          return -1;\n        }\n        if (upgrade && !request2.upgrade) {\n          util2.destroy(socket, new SocketError(\"bad upgrade\", util2.getSocketInfo(socket)));\n          return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive;\n        if (this.statusCode >= 200) {\n          const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client[kBodyTimeout];\n          this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        if (request2.method === \"CONNECT\") {\n          assert(client[kRunning] === 1);\n          this.upgrade = true;\n          return 2;\n        }\n        if (upgrade) {\n          assert(client[kRunning] === 1);\n          this.upgrade = true;\n          return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (shouldKeepAlive && client[kPipelining]) {\n          const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;\n          if (keepAliveTimeout != null) {\n            const timeout = Math.min(\n              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n              client[kKeepAliveMaxTimeout]\n            );\n            if (timeout <= 0) {\n              socket[kReset] = true;\n            } else {\n              client[kKeepAliveTimeoutValue] = timeout;\n            }\n          } else {\n            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n          }\n        } else {\n          socket[kReset] = true;\n        }\n        let pause;\n        try {\n          pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        } catch (err) {\n          util2.destroy(socket, err);\n          return -1;\n        }\n        if (request2.method === \"HEAD\") {\n          assert(socket[kReset]);\n          return 1;\n        }\n        if (statusCode < 200) {\n          return 1;\n        }\n        if (socket[kBlocking]) {\n          socket[kBlocking] = false;\n          resume(client);\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n      }\n      onBody(buf) {\n        const { client, socket, statusCode } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        assert(statusCode >= 200);\n        this.bytesRead += buf.length;\n        try {\n          if (request2.onData(buf) === false) {\n            return constants.ERROR.PAUSED;\n          }\n        } catch (err) {\n          util2.destroy(socket, err);\n          return -1;\n        }\n      }\n      onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n          return -1;\n        }\n        if (upgrade) {\n          return;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n          return;\n        }\n        if (request2.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n          util2.destroy(socket, new ResponseContentLengthMismatchError());\n          return -1;\n        }\n        try {\n          request2.onComplete(headers);\n        } catch (err) {\n          errorRequest(client, request2, err);\n        }\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n          assert.strictEqual(client[kRunning], 0);\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] === 1) {\n          setImmediate(resume, client);\n        } else {\n          resume(client);\n        }\n      }\n    };\n    __name(Parser, \"Parser\");\n    function onParserTimeout(parser) {\n      const { socket, timeoutType, client } = parser;\n      if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n          assert(!parser.paused, \"cannot be paused while waiting for headers\");\n          util2.destroy(socket, new HeadersTimeoutError());\n        }\n      } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n          util2.destroy(socket, new BodyTimeoutError());\n        }\n      } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util2.destroy(socket, new InformationalError(\"socket idle timeout\"));\n      }\n    }\n    __name(onParserTimeout, \"onParserTimeout\");\n    function onSocketReadable() {\n      const { [kParser]: parser } = this;\n      parser.readMore();\n    }\n    __name(onSocketReadable, \"onSocketReadable\");\n    function onSocketError(err) {\n      const { [kParser]: parser } = this;\n      assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n      if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n        parser.finish();\n        return;\n      }\n      this[kError] = err;\n      onError(this[kClient], err);\n    }\n    __name(onSocketError, \"onSocketError\");\n    function onError(client, err) {\n      if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for (let i = 0; i < requests.length; i++) {\n          const request2 = requests[i];\n          errorRequest(client, request2, err);\n        }\n        assert(client[kSize] === 0);\n      }\n    }\n    __name(onError, \"onError\");\n    function onSocketEnd() {\n      const { [kParser]: parser } = this;\n      if (parser.statusCode && !parser.shouldKeepAlive) {\n        parser.finish();\n        return;\n      }\n      util2.destroy(this, new SocketError(\"other side closed\", util2.getSocketInfo(this)));\n    }\n    __name(onSocketEnd, \"onSocketEnd\");\n    function onSocketClose() {\n      const { [kClient]: client } = this;\n      this[kParser].destroy();\n      this[kParser] = null;\n      const err = this[kError] || new SocketError(\"closed\", util2.getSocketInfo(this));\n      client[kSocket] = null;\n      if (client.destroyed) {\n        assert(client[kPending] === 0);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for (let i = 0; i < requests.length; i++) {\n          const request2 = requests[i];\n          errorRequest(client, request2, err);\n        }\n      } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n        const request2 = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request2, err);\n      }\n      client[kPendingIdx] = client[kRunningIdx];\n      assert(client[kRunning] === 0);\n      client.emit(\"disconnect\", client[kUrl], [client], err);\n      resume(client);\n    }\n    __name(onSocketClose, \"onSocketClose\");\n    async function connect(client) {\n      assert(!client[kConnecting]);\n      assert(!client[kSocket]);\n      let { host, hostname: hostname3, protocol, port } = client[kUrl];\n      if (hostname3[0] === \"[\") {\n        const idx = hostname3.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname3.substr(1, idx - 1);\n        assert(net2.isIP(ip));\n        hostname3 = ip;\n      }\n      client[kConnecting] = true;\n      if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n          connectParams: {\n            host,\n            hostname: hostname3,\n            protocol,\n            port,\n            servername: client[kServerName]\n          },\n          connector: client[kConnector]\n        });\n      }\n      try {\n        const socket = await new Promise((resolve, reject) => {\n          client[kConnector]({\n            host,\n            hostname: hostname3,\n            protocol,\n            port,\n            servername: client[kServerName]\n          }, (err, socket2) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(socket2);\n            }\n          });\n        });\n        if (!llhttpInstance) {\n          llhttpInstance = await llhttpPromise;\n          llhttpPromise = null;\n        }\n        client[kConnecting] = false;\n        assert(socket);\n        client[kSocket] = socket;\n        socket[kNoRef] = false;\n        socket[kWriting] = false;\n        socket[kReset] = false;\n        socket[kBlocking] = false;\n        socket[kError] = null;\n        socket[kParser] = new Parser(client, socket, llhttpInstance);\n        socket[kClient] = client;\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket.on(\"error\", onSocketError).on(\"readable\", onSocketReadable).on(\"end\", onSocketEnd).on(\"close\", onSocketClose);\n        if (channels.connected.hasSubscribers) {\n          channels.connected.publish({\n            connectParams: {\n              host,\n              hostname: hostname3,\n              protocol,\n              port,\n              servername: client[kServerName]\n            },\n            connector: client[kConnector],\n            socket\n          });\n        }\n        client.emit(\"connect\", client[kUrl], [client]);\n      } catch (err) {\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n          channels.connectError.publish({\n            connectParams: {\n              host,\n              hostname: hostname3,\n              protocol,\n              port,\n              servername: client[kServerName]\n            },\n            connector: client[kConnector],\n            error: err\n          });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n          assert(client[kRunning] === 0);\n          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n            const request2 = client[kQueue][client[kPendingIdx]++];\n            errorRequest(client, request2, err);\n          }\n        } else {\n          onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [client], err);\n      }\n      resume(client);\n    }\n    __name(connect, \"connect\");\n    function emitDrain(client) {\n      client[kNeedDrain] = 0;\n      client.emit(\"drain\", client[kUrl], [client]);\n    }\n    __name(emitDrain, \"emitDrain\");\n    function resume(client, sync) {\n      if (client[kResuming] === 2) {\n        return;\n      }\n      client[kResuming] = 2;\n      _resume(client, sync);\n      client[kResuming] = 0;\n      if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n      }\n    }\n    __name(resume, \"resume\");\n    function _resume(client, sync) {\n      while (true) {\n        if (client.destroyed) {\n          assert(client[kPending] === 0);\n          return;\n        }\n        if (client.closed && !client[kSize]) {\n          client.destroy();\n          return;\n        }\n        const socket = client[kSocket];\n        if (socket) {\n          if (client[kSize] === 0) {\n            if (!socket[kNoRef] && socket.unref) {\n              socket.unref();\n              socket[kNoRef] = true;\n            }\n          } else if (socket[kNoRef] && socket.ref) {\n            socket.ref();\n            socket[kNoRef] = false;\n          }\n          if (client[kSize] === 0) {\n            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n            }\n          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n              const request3 = client[kQueue][client[kRunningIdx]];\n              const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client[kHeadersTimeout];\n              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n            }\n          }\n        }\n        if (client[kBusy]) {\n          client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n          if (sync) {\n            client[kNeedDrain] = 1;\n            process.nextTick(emitDrain, client);\n          } else {\n            emitDrain(client);\n          }\n          continue;\n        }\n        if (client[kPending] === 0) {\n          return;\n        }\n        if (client[kRunning] >= (client[kPipelining] || 1)) {\n          return;\n        }\n        const request2 = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request2.servername) {\n          if (client[kRunning] > 0) {\n            return;\n          }\n          client[kServerName] = request2.servername;\n          if (socket && socket.servername !== request2.servername) {\n            util2.destroy(socket, new InformationalError(\"servername changed\"));\n            return;\n          }\n        }\n        if (client[kConnecting]) {\n          return;\n        }\n        if (!socket) {\n          connect(client);\n          continue;\n        }\n        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n          return;\n        }\n        if (client[kRunning] > 0 && !request2.idempotent) {\n          return;\n        }\n        if (client[kRunning] > 0 && (request2.upgrade || request2.method === \"CONNECT\")) {\n          return;\n        }\n        if (util2.isStream(request2.body) && util2.bodyLength(request2.body) === 0) {\n          request2.body.on(\"data\", function() {\n            assert(false);\n          }).on(\"error\", function(err) {\n            errorRequest(client, request2, err);\n          }).on(\"end\", function() {\n            util2.destroy(this);\n          });\n          request2.body = null;\n        }\n        if (client[kRunning] > 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body))) {\n          return;\n        }\n        if (!request2.aborted && write(client, request2)) {\n          client[kPendingIdx]++;\n        } else {\n          client[kQueue].splice(client[kPendingIdx], 1);\n        }\n      }\n    }\n    __name(_resume, \"_resume\");\n    function write(client, request2) {\n      const { body, method, path: path7, host, upgrade, headers, blocking } = request2;\n      const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n      if (body && typeof body.read === \"function\") {\n        body.read(0);\n      }\n      let contentLength = util2.bodyLength(body);\n      if (contentLength === null) {\n        contentLength = request2.contentLength;\n      }\n      if (contentLength === 0 && !expectsPayload) {\n        contentLength = null;\n      }\n      if (request2.contentLength !== null && request2.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n          errorRequest(client, request2, new RequestContentLengthMismatchError());\n          return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n      const socket = client[kSocket];\n      try {\n        request2.onConnect((err) => {\n          if (request2.aborted || request2.completed) {\n            return;\n          }\n          errorRequest(client, request2, err || new RequestAbortedError());\n          util2.destroy(socket, new InformationalError(\"aborted\"));\n        });\n      } catch (err) {\n        errorRequest(client, request2, err);\n      }\n      if (request2.aborted) {\n        return false;\n      }\n      if (method === \"HEAD\") {\n        socket[kReset] = true;\n      }\n      if (upgrade || method === \"CONNECT\") {\n        socket[kReset] = true;\n      }\n      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n      }\n      if (blocking) {\n        socket[kBlocking] = true;\n      }\n      let header = `${method} ${path7} HTTP/1.1\\r\n`;\n      if (typeof host === \"string\") {\n        header += `host: ${host}\\r\n`;\n      } else {\n        header += client[kHostHeader];\n      }\n      if (upgrade) {\n        header += `connection: upgrade\\r\nupgrade: ${upgrade}\\r\n`;\n      } else if (client[kPipelining]) {\n        header += \"connection: keep-alive\\r\\n\";\n      } else {\n        header += \"connection: close\\r\\n\";\n      }\n      if (headers) {\n        header += headers;\n      }\n      if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({ request: request2, headers: header, socket });\n      }\n      if (!body) {\n        if (contentLength === 0) {\n          socket.write(`${header}content-length: 0\\r\n\\r\n`, \"ascii\");\n        } else {\n          assert(contentLength === null, \"no body must not have content length\");\n          socket.write(`${header}\\r\n`, \"ascii\");\n        }\n        request2.onRequestSent();\n      } else if (util2.isBuffer(body)) {\n        assert(contentLength === body.byteLength, \"buffer body must have content length\");\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n        socket.write(body);\n        socket.uncork();\n        request2.onBodySent(body);\n        request2.onRequestSent();\n        if (!expectsPayload) {\n          socket[kReset] = true;\n        }\n      } else if (util2.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n          writeIterable({ body: body.stream(), client, request: request2, socket, contentLength, header, expectsPayload });\n        } else {\n          writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n        }\n      } else if (util2.isStream(body)) {\n        writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n      } else if (util2.isIterable(body)) {\n        writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n      } else {\n        assert(false);\n      }\n      return true;\n    }\n    __name(write, \"write\");\n    function writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n      let finished = false;\n      const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });\n      const onData = /* @__PURE__ */ __name(function(chunk) {\n        try {\n          assert(!finished);\n          if (!writer.write(chunk) && this.pause) {\n            this.pause();\n          }\n        } catch (err) {\n          util2.destroy(this, err);\n        }\n      }, \"onData\");\n      const onDrain = /* @__PURE__ */ __name(function() {\n        assert(!finished);\n        if (body.resume) {\n          body.resume();\n        }\n      }, \"onDrain\");\n      const onAbort = /* @__PURE__ */ __name(function() {\n        onFinished(new RequestAbortedError());\n      }, \"onAbort\");\n      const onFinished = /* @__PURE__ */ __name(function(err) {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"error\", onFinished).removeListener(\"close\", onAbort);\n        if (!err) {\n          try {\n            writer.end();\n          } catch (er) {\n            err = er;\n          }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n          util2.destroy(body, err);\n        } else {\n          util2.destroy(body);\n        }\n      }, \"onFinished\");\n      body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onAbort);\n      if (body.resume) {\n        body.resume();\n      }\n      socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n    }\n    __name(writeStream, \"writeStream\");\n    async function writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength === body.size, \"blob body must have content length\");\n      try {\n        if (contentLength != null && contentLength !== body.size) {\n          throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n        socket.write(buffer);\n        socket.uncork();\n        request2.onBodySent(buffer);\n        request2.onRequestSent();\n        if (!expectsPayload) {\n          socket[kReset] = true;\n        }\n        resume(client);\n      } catch (err) {\n        util2.destroy(socket, err);\n      }\n    }\n    __name(writeBlob, \"writeBlob\");\n    async function writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n      let callback = null;\n      function onDrain() {\n        if (callback) {\n          const cb = callback;\n          callback = null;\n          cb();\n        }\n      }\n      __name(onDrain, \"onDrain\");\n      const waitForDrain = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {\n        assert(callback === null);\n        if (socket[kError]) {\n          reject(socket[kError]);\n        } else {\n          callback = resolve;\n        }\n      }), \"waitForDrain\");\n      socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n      const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });\n      try {\n        for await (const chunk of body) {\n          if (socket[kError]) {\n            throw socket[kError];\n          }\n          if (!writer.write(chunk)) {\n            await waitForDrain();\n          }\n        }\n        writer.end();\n      } catch (err) {\n        writer.destroy(err);\n      } finally {\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n      }\n    }\n    __name(writeIterable, \"writeIterable\");\n    var AsyncWriter = class {\n      constructor({ socket, request: request2, contentLength, client, expectsPayload, header }) {\n        this.socket = socket;\n        this.request = request2;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[kWriting] = true;\n      }\n      write(chunk) {\n        const { socket, request: request2, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n          throw socket[kError];\n        }\n        if (socket.destroyed) {\n          return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n          return true;\n        }\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n          if (client[kStrictContentLength]) {\n            throw new RequestContentLengthMismatchError();\n          }\n          process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        if (bytesWritten === 0) {\n          if (!expectsPayload) {\n            socket[kReset] = true;\n          }\n          if (contentLength === null) {\n            socket.write(`${header}transfer-encoding: chunked\\r\n`, \"ascii\");\n          } else {\n            socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n          }\n        }\n        if (contentLength === null) {\n          socket.write(`\\r\n${len.toString(16)}\\r\n`, \"ascii\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        request2.onBodySent(chunk);\n        if (!ret) {\n          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            if (socket[kParser].timeout.refresh) {\n              socket[kParser].timeout.refresh();\n            }\n          }\n        }\n        return ret;\n      }\n      end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request2 } = this;\n        request2.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n          throw socket[kError];\n        }\n        if (socket.destroyed) {\n          return;\n        }\n        if (bytesWritten === 0) {\n          if (expectsPayload) {\n            socket.write(`${header}content-length: 0\\r\n\\r\n`, \"ascii\");\n          } else {\n            socket.write(`${header}\\r\n`, \"ascii\");\n          }\n        } else if (contentLength === null) {\n          socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"ascii\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n          if (client[kStrictContentLength]) {\n            throw new RequestContentLengthMismatchError();\n          } else {\n            process.emitWarning(new RequestContentLengthMismatchError());\n          }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n          if (socket[kParser].timeout.refresh) {\n            socket[kParser].timeout.refresh();\n          }\n        }\n        resume(client);\n      }\n      destroy(err) {\n        const { socket, client } = this;\n        socket[kWriting] = false;\n        if (err) {\n          assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n          util2.destroy(socket, err);\n        }\n      }\n    };\n    __name(AsyncWriter, \"AsyncWriter\");\n    function errorRequest(client, request2, err) {\n      try {\n        request2.onError(err);\n        assert(request2.aborted);\n      } catch (err2) {\n        client.emit(\"error\", err2);\n      }\n    }\n    __name(errorRequest, \"errorRequest\");\n    module2.exports = Client;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/node/fixed-queue.js\nvar require_fixed_queue = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/node/fixed-queue.js\"(exports, module2) {\n    \"use strict\";\n    var kSize = 2048;\n    var kMask = kSize - 1;\n    var FixedCircularBuffer = class {\n      constructor() {\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n      }\n      isEmpty() {\n        return this.top === this.bottom;\n      }\n      isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n      }\n      push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n      }\n      shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === void 0)\n          return null;\n        this.list[this.bottom] = void 0;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n      }\n    };\n    __name(FixedCircularBuffer, \"FixedCircularBuffer\");\n    module2.exports = /* @__PURE__ */ __name(class FixedQueue {\n      constructor() {\n        this.head = this.tail = new FixedCircularBuffer();\n      }\n      isEmpty() {\n        return this.head.isEmpty();\n      }\n      push(data) {\n        if (this.head.isFull()) {\n          this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n      }\n      shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n          this.tail = tail.next;\n        }\n        return next;\n      }\n    }, \"FixedQueue\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-stats.js\nvar require_pool_stats = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-stats.js\"(exports, module2) {\n    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();\n    var kPool = Symbol(\"pool\");\n    var PoolStats = class {\n      constructor(pool) {\n        this[kPool] = pool;\n      }\n      get connected() {\n        return this[kPool][kConnected];\n      }\n      get free() {\n        return this[kPool][kFree];\n      }\n      get pending() {\n        return this[kPool][kPending];\n      }\n      get queued() {\n        return this[kPool][kQueued];\n      }\n      get running() {\n        return this[kPool][kRunning];\n      }\n      get size() {\n        return this[kPool][kSize];\n      }\n    };\n    __name(PoolStats, \"PoolStats\");\n    module2.exports = PoolStats;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-base.js\nvar require_pool_base = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-base.js\"(exports, module2) {\n    \"use strict\";\n    var DispatcherBase = require_dispatcher_base();\n    var FixedQueue = require_fixed_queue();\n    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();\n    var PoolStats = require_pool_stats();\n    var kClients = Symbol(\"clients\");\n    var kNeedDrain = Symbol(\"needDrain\");\n    var kQueue = Symbol(\"queue\");\n    var kClosedResolve = Symbol(\"closed resolve\");\n    var kOnDrain = Symbol(\"onDrain\");\n    var kOnConnect = Symbol(\"onConnect\");\n    var kOnDisconnect = Symbol(\"onDisconnect\");\n    var kOnConnectionError = Symbol(\"onConnectionError\");\n    var kGetDispatcher = Symbol(\"get dispatcher\");\n    var kAddClient = Symbol(\"add client\");\n    var kRemoveClient = Symbol(\"remove client\");\n    var kStats = Symbol(\"stats\");\n    var PoolBase = class extends DispatcherBase {\n      constructor() {\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = /* @__PURE__ */ __name(function onDrain(origin, targets) {\n          const queue = pool[kQueue];\n          let needDrain = false;\n          while (!needDrain) {\n            const item = queue.shift();\n            if (!item) {\n              break;\n            }\n            pool[kQueued]--;\n            needDrain = !this.dispatch(item.opts, item.handler);\n          }\n          this[kNeedDrain] = needDrain;\n          if (!this[kNeedDrain] && pool[kNeedDrain]) {\n            pool[kNeedDrain] = false;\n            pool.emit(\"drain\", origin, [pool, ...targets]);\n          }\n          if (pool[kClosedResolve] && queue.isEmpty()) {\n            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);\n          }\n        }, \"onDrain\");\n        this[kOnConnect] = (origin, targets) => {\n          pool.emit(\"connect\", origin, [pool, ...targets]);\n        };\n        this[kOnDisconnect] = (origin, targets, err) => {\n          pool.emit(\"disconnect\", origin, [pool, ...targets], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err) => {\n          pool.emit(\"connectionError\", origin, [pool, ...targets], err);\n        };\n        this[kStats] = new PoolStats(this);\n      }\n      get [kBusy]() {\n        return this[kNeedDrain];\n      }\n      get [kConnected]() {\n        return this[kClients].filter((client) => client[kConnected]).length;\n      }\n      get [kFree]() {\n        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;\n      }\n      get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]) {\n          ret += pending;\n        }\n        return ret;\n      }\n      get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]) {\n          ret += running;\n        }\n        return ret;\n      }\n      get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]) {\n          ret += size;\n        }\n        return ret;\n      }\n      get stats() {\n        return this[kStats];\n      }\n      async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n          return Promise.all(this[kClients].map((c) => c.close()));\n        } else {\n          return new Promise((resolve) => {\n            this[kClosedResolve] = resolve;\n          });\n        }\n      }\n      async [kDestroy](err) {\n        while (true) {\n          const item = this[kQueue].shift();\n          if (!item) {\n            break;\n          }\n          item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c) => c.destroy(err)));\n      }\n      [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n          this[kNeedDrain] = true;\n          this[kQueue].push({ opts, handler });\n          this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n          dispatcher[kNeedDrain] = true;\n          this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n      }\n      [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n          process.nextTick(() => {\n            if (this[kNeedDrain]) {\n              this[kOnDrain](client[kUrl], [this, client]);\n            }\n          });\n        }\n        return this;\n      }\n      [kRemoveClient](client) {\n        client.close(() => {\n          const idx = this[kClients].indexOf(client);\n          if (idx !== -1) {\n            this[kClients].splice(idx, 1);\n          }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n      }\n    };\n    __name(PoolBase, \"PoolBase\");\n    module2.exports = {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kRemoveClient,\n      kGetDispatcher\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool.js\nvar require_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kGetDispatcher\n    } = require_pool_base();\n    var Client = require_client();\n    var {\n      InvalidArgumentError\n    } = require_errors();\n    var util2 = require_util2();\n    var { kUrl } = require_symbols();\n    var buildConnector = require_connect();\n    var kOptions = Symbol(\"options\");\n    var kConnections = Symbol(\"connections\");\n    var kFactory = Symbol(\"factory\");\n    function defaultFactory(origin, opts) {\n      return new Client(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var Pool = class extends PoolBase {\n      constructor(origin, {\n        connections,\n        factory = defaultFactory,\n        connect,\n        connectTimeout,\n        tls,\n        maxCachedSessions,\n        socketPath,\n        ...options\n      } = {}) {\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n          throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n          connect = buildConnector({\n            ...tls,\n            maxCachedSessions,\n            socketPath,\n            timeout: connectTimeout == null ? 1e4 : connectTimeout,\n            ...connect\n          });\n        }\n        this[kConnections] = connections || null;\n        this[kUrl] = util2.parseOrigin(origin);\n        this[kOptions] = { ...util2.deepClone(options), connect };\n        this[kFactory] = factory;\n      }\n      [kGetDispatcher]() {\n        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);\n        if (dispatcher) {\n          return dispatcher;\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n          dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n          this[kAddClient](dispatcher);\n        }\n        return dispatcher;\n      }\n    };\n    __name(Pool, \"Pool\");\n    module2.exports = Pool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/balanced-pool.js\nvar require_balanced_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/balanced-pool.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      BalancedPoolMissingUpstreamError,\n      InvalidArgumentError\n    } = require_errors();\n    var {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kRemoveClient,\n      kGetDispatcher\n    } = require_pool_base();\n    var Pool = require_pool();\n    var { kUrl } = require_symbols();\n    var { parseOrigin } = require_util2();\n    var kFactory = Symbol(\"factory\");\n    var kOptions = Symbol(\"options\");\n    var kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\n    var kCurrentWeight = Symbol(\"kCurrentWeight\");\n    var kIndex = Symbol(\"kIndex\");\n    var kWeight = Symbol(\"kWeight\");\n    var kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\n    var kErrorPenalty = Symbol(\"kErrorPenalty\");\n    function getGreatestCommonDivisor(a, b) {\n      if (b === 0)\n        return a;\n      return getGreatestCommonDivisor(b, a % b);\n    }\n    __name(getGreatestCommonDivisor, \"getGreatestCommonDivisor\");\n    function defaultFactory(origin, opts) {\n      return new Pool(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var BalancedPool = class extends PoolBase {\n      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n          upstreams = [upstreams];\n        }\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kFactory] = factory;\n        for (const upstream of upstreams) {\n          this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n      }\n      addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {\n          return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", () => {\n          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", () => {\n          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n          this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args) => {\n          const err = args[2];\n          if (err && err.code === \"UND_ERR_SOCKET\") {\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n          }\n        });\n        for (const client of this[kClients]) {\n          client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n      }\n      _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n      }\n      removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);\n        if (pool) {\n          this[kRemoveClient](pool);\n        }\n        return this;\n      }\n      get upstreams() {\n        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);\n      }\n      [kGetDispatcher]() {\n        if (this[kClients].length === 0) {\n          throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);\n        if (!dispatcher) {\n          return;\n        }\n        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);\n        if (allClientsBusy) {\n          return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);\n        while (counter++ < this[kClients].length) {\n          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n          const pool = this[kClients][this[kIndex]];\n          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n            maxWeightIndex = this[kIndex];\n          }\n          if (this[kIndex] === 0) {\n            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n            if (this[kCurrentWeight] <= 0) {\n              this[kCurrentWeight] = this[kMaxWeightPerServer];\n            }\n          }\n          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n            return pool;\n          }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n      }\n    };\n    __name(BalancedPool, \"BalancedPool\");\n    module2.exports = BalancedPool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/compat/dispatcher-weakref.js\nvar require_dispatcher_weakref = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/compat/dispatcher-weakref.js\"(exports, module2) {\n    \"use strict\";\n    var { kConnected, kSize } = require_symbols();\n    var CompatWeakRef = class {\n      constructor(value) {\n        this.value = value;\n      }\n      deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;\n      }\n    };\n    __name(CompatWeakRef, \"CompatWeakRef\");\n    var CompatFinalizer = class {\n      constructor(finalizer) {\n        this.finalizer = finalizer;\n      }\n      register(dispatcher, key) {\n        dispatcher.on(\"disconnect\", () => {\n          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n            this.finalizer(key);\n          }\n        });\n      }\n    };\n    __name(CompatFinalizer, \"CompatFinalizer\");\n    module2.exports = function() {\n      return {\n        WeakRef: global.WeakRef || CompatWeakRef,\n        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n      };\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/agent.js\nvar require_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/agent.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError } = require_errors();\n    var { kClients, kRunning, kClose, kDestroy, kDispatch } = require_symbols();\n    var DispatcherBase = require_dispatcher_base();\n    var Pool = require_pool();\n    var Client = require_client();\n    var util2 = require_util2();\n    var RedirectHandler = require_redirect();\n    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();\n    var kOnConnect = Symbol(\"onConnect\");\n    var kOnDisconnect = Symbol(\"onDisconnect\");\n    var kOnConnectionError = Symbol(\"onConnectionError\");\n    var kMaxRedirections = Symbol(\"maxRedirections\");\n    var kOnDrain = Symbol(\"onDrain\");\n    var kFactory = Symbol(\"factory\");\n    var kFinalizer = Symbol(\"finalizer\");\n    var kOptions = Symbol(\"options\");\n    function defaultFactory(origin, opts) {\n      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var Agent = class extends DispatcherBase {\n      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n        super();\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n          connect = { ...connect };\n        }\n        this[kOptions] = { ...util2.deepClone(options), connect };\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = /* @__PURE__ */ new Map();\n        this[kFinalizer] = new FinalizationRegistry((key) => {\n          const ref = this[kClients].get(key);\n          if (ref !== void 0 && ref.deref() === void 0) {\n            this[kClients].delete(key);\n          }\n        });\n        const agent = this;\n        this[kOnDrain] = (origin, targets) => {\n          agent.emit(\"drain\", origin, [agent, ...targets]);\n        };\n        this[kOnConnect] = (origin, targets) => {\n          agent.emit(\"connect\", origin, [agent, ...targets]);\n        };\n        this[kOnDisconnect] = (origin, targets, err) => {\n          agent.emit(\"disconnect\", origin, [agent, ...targets], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err) => {\n          agent.emit(\"connectionError\", origin, [agent, ...targets], err);\n        };\n      }\n      get [kRunning]() {\n        let ret = 0;\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            ret += client[kRunning];\n          }\n        }\n        return ret;\n      }\n      [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n          key = String(opts.origin);\n        } else {\n          throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        const ref = this[kClients].get(key);\n        let dispatcher = ref ? ref.deref() : null;\n        if (!dispatcher) {\n          dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n          this[kClients].set(key, new WeakRef2(dispatcher));\n          this[kFinalizer].register(dispatcher, key);\n        }\n        const { maxRedirections = this[kMaxRedirections] } = opts;\n        if (maxRedirections != null && maxRedirections !== 0) {\n          opts = { ...opts, maxRedirections: 0 };\n          handler = new RedirectHandler(this, maxRedirections, opts, handler);\n        }\n        return dispatcher.dispatch(opts, handler);\n      }\n      async [kClose]() {\n        const closePromises = [];\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            closePromises.push(client.close());\n          }\n        }\n        await Promise.all(closePromises);\n      }\n      async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            destroyPromises.push(client.destroy(err));\n          }\n        }\n        await Promise.all(destroyPromises);\n      }\n    };\n    __name(Agent, \"Agent\");\n    module2.exports = Agent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/readable.js\nvar require_readable = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/readable.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { Readable } = __webpack_require__(/*! stream */ \"stream\");\n    var { RequestAbortedError, NotSupportedError } = require_errors();\n    var util2 = require_util2();\n    var { ReadableStreamFrom, toUSVString } = require_util2();\n    var Blob;\n    var kConsume = Symbol(\"kConsume\");\n    var kReading = Symbol(\"kReading\");\n    var kBody = Symbol(\"kBody\");\n    var kAbort = Symbol(\"abort\");\n    var kContentType = Symbol(\"kContentType\");\n    module2.exports = /* @__PURE__ */ __name(class BodyReadable extends Readable {\n      constructor(resume, abort, contentType = \"\") {\n        super({\n          autoDestroy: true,\n          read: resume,\n          highWaterMark: 64 * 1024\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        this[kReading] = false;\n      }\n      destroy(err) {\n        if (this.destroyed) {\n          return this;\n        }\n        if (!err && !this._readableState.endEmitted) {\n          err = new RequestAbortedError();\n        }\n        if (err) {\n          this[kAbort]();\n        }\n        return super.destroy(err);\n      }\n      emit(ev, ...args) {\n        if (ev === \"data\") {\n          this._readableState.dataEmitted = true;\n        } else if (ev === \"error\") {\n          this._readableState.errorEmitted = true;\n        }\n        return super.emit(ev, ...args);\n      }\n      on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n          this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n      }\n      addListener(ev, ...args) {\n        return this.on(ev, ...args);\n      }\n      off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n          this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n      }\n      removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n      }\n      push(chunk) {\n        if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n          consumePush(this[kConsume], chunk);\n          return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n      }\n      async text() {\n        return consume(this, \"text\");\n      }\n      async json() {\n        return consume(this, \"json\");\n      }\n      async blob() {\n        return consume(this, \"blob\");\n      }\n      async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n      }\n      async formData() {\n        throw new NotSupportedError();\n      }\n      get bodyUsed() {\n        return util2.isDisturbed(this);\n      }\n      get body() {\n        if (!this[kBody]) {\n          this[kBody] = ReadableStreamFrom(this);\n          if (this[kConsume]) {\n            this[kBody].getReader();\n            assert(this[kBody].locked);\n          }\n        }\n        return this[kBody];\n      }\n      async dump(opts) {\n        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n        try {\n          for await (const chunk of this) {\n            limit -= Buffer.byteLength(chunk);\n            if (limit < 0) {\n              return;\n            }\n          }\n        } catch (e) {\n        }\n      }\n    }, \"BodyReadable\");\n    function isLocked(self2) {\n      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];\n    }\n    __name(isLocked, \"isLocked\");\n    function isUnusable(self2) {\n      return util2.isDisturbed(self2) || isLocked(self2);\n    }\n    __name(isUnusable, \"isUnusable\");\n    async function consume(stream2, type) {\n      if (isUnusable(stream2)) {\n        throw new TypeError(\"unusable\");\n      }\n      assert(!stream2[kConsume]);\n      return new Promise((resolve, reject) => {\n        stream2[kConsume] = {\n          type,\n          stream: stream2,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        };\n        stream2.on(\"error\", function(err) {\n          consumeFinish(this[kConsume], err);\n        }).on(\"close\", function() {\n          if (this[kConsume].body !== null) {\n            consumeFinish(this[kConsume], new RequestAbortedError());\n          }\n        });\n        process.nextTick(consumeStart, stream2[kConsume]);\n      });\n    }\n    __name(consume, \"consume\");\n    function consumeStart(consume2) {\n      if (consume2.body === null) {\n        return;\n      }\n      const { _readableState: state } = consume2.stream;\n      for (const chunk of state.buffer) {\n        consumePush(consume2, chunk);\n      }\n      if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n      } else {\n        consume2.stream.on(\"end\", function() {\n          consumeEnd(this[kConsume]);\n        });\n      }\n      consume2.stream.resume();\n      while (consume2.stream.read() != null) {\n      }\n    }\n    __name(consumeStart, \"consumeStart\");\n    function consumeEnd(consume2) {\n      const { type, body, resolve, stream: stream2, length } = consume2;\n      try {\n        if (type === \"text\") {\n          resolve(toUSVString(Buffer.concat(body)));\n        } else if (type === \"json\") {\n          resolve(JSON.parse(Buffer.concat(body)));\n        } else if (type === \"arrayBuffer\") {\n          const dst = new Uint8Array(length);\n          let pos = 0;\n          for (const buf of body) {\n            dst.set(buf, pos);\n            pos += buf.byteLength;\n          }\n          resolve(dst);\n        } else if (type === \"blob\") {\n          if (!Blob) {\n            Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob);\n          }\n          resolve(new Blob(body, { type: stream2[kContentType] }));\n        }\n        consumeFinish(consume2);\n      } catch (err) {\n        stream2.destroy(err);\n      }\n    }\n    __name(consumeEnd, \"consumeEnd\");\n    function consumePush(consume2, chunk) {\n      consume2.length += chunk.length;\n      consume2.body.push(chunk);\n    }\n    __name(consumePush, \"consumePush\");\n    function consumeFinish(consume2, err) {\n      if (consume2.body === null) {\n        return;\n      }\n      if (err) {\n        consume2.reject(err);\n      } else {\n        consume2.resolve();\n      }\n      consume2.type = null;\n      consume2.stream = null;\n      consume2.resolve = null;\n      consume2.reject = null;\n      consume2.length = 0;\n      consume2.body = null;\n    }\n    __name(consumeFinish, \"consumeFinish\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/abort-signal.js\nvar require_abort_signal = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/abort-signal.js\"(exports, module2) {\n    var { RequestAbortedError } = require_errors();\n    var kListener = Symbol(\"kListener\");\n    var kSignal = Symbol(\"kSignal\");\n    function abort(self2) {\n      if (self2.abort) {\n        self2.abort();\n      } else {\n        self2.onError(new RequestAbortedError());\n      }\n    }\n    __name(abort, \"abort\");\n    function addSignal(self2, signal) {\n      self2[kSignal] = null;\n      self2[kListener] = null;\n      if (!signal) {\n        return;\n      }\n      if (signal.aborted) {\n        abort(self2);\n        return;\n      }\n      self2[kSignal] = signal;\n      self2[kListener] = () => {\n        abort(self2);\n      };\n      if (\"addEventListener\" in self2[kSignal]) {\n        self2[kSignal].addEventListener(\"abort\", self2[kListener]);\n      } else {\n        self2[kSignal].addListener(\"abort\", self2[kListener]);\n      }\n    }\n    __name(addSignal, \"addSignal\");\n    function removeSignal(self2) {\n      if (!self2[kSignal]) {\n        return;\n      }\n      if (\"removeEventListener\" in self2[kSignal]) {\n        self2[kSignal].removeEventListener(\"abort\", self2[kListener]);\n      } else {\n        self2[kSignal].removeListener(\"abort\", self2[kListener]);\n      }\n      self2[kSignal] = null;\n      self2[kListener] = null;\n    }\n    __name(removeSignal, \"removeSignal\");\n    module2.exports = {\n      addSignal,\n      removeSignal\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-request.js\nvar require_api_request = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-request.js\"(exports, module2) {\n    \"use strict\";\n    var Readable = require_readable();\n    var {\n      InvalidArgumentError,\n      RequestAbortedError,\n      ResponseStatusCodeError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var RequestHandler2 = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n          if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n          }\n          if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n          }\n          if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n          }\n          if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n          }\n          super(\"UNDICI_REQUEST\");\n        } catch (err) {\n          if (util2.isStream(body)) {\n            util2.destroy(body.on(\"error\", util2.nop), err);\n          }\n          throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        if (util2.isStream(body)) {\n          body.on(\"error\", (err) => {\n            this.onError(err);\n          });\n        }\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers2 = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers: headers2 });\n          }\n          return;\n        }\n        const parsedHeaders = util2.parseHeaders(rawHeaders);\n        const contentType = parsedHeaders[\"content-type\"];\n        const body = new Readable(resume, abort, contentType);\n        this.callback = null;\n        this.res = body;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        if (callback !== null) {\n          if (this.throwOnError && statusCode >= 400) {\n            this.runInAsyncScope(\n              getResolveErrorBodyCallback,\n              null,\n              { callback, body, contentType, statusCode, statusMessage, headers }\n            );\n            return;\n          }\n          this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            trailers: this.trailers,\n            opaque,\n            body,\n            context: context3\n          });\n        }\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        util2.parseHeaders(trailers, this.trailers);\n        res.push(null);\n      }\n      onError(err) {\n        const { res, callback, body, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n        if (res) {\n          this.res = null;\n          queueMicrotask(() => {\n            util2.destroy(res, err);\n          });\n        }\n        if (body) {\n          this.body = null;\n          util2.destroy(body, err);\n        }\n      }\n    };\n    __name(RequestHandler2, \"RequestHandler\");\n    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n      if (statusCode === 204 || !contentType) {\n        body.dump();\n        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n        return;\n      }\n      try {\n        if (contentType.startsWith(\"application/json\")) {\n          const payload = await body.json();\n          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n          return;\n        }\n        if (contentType.startsWith(\"text/\")) {\n          const payload = await body.text();\n          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n          return;\n        }\n      } catch (err) {\n      }\n      body.dump();\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n    }\n    __name(getResolveErrorBodyCallback, \"getResolveErrorBodyCallback\");\n    function request2(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          request2.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        this.dispatch(opts, new RequestHandler2(opts, callback));\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(request2, \"request\");\n    module2.exports = request2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-stream.js\nvar require_api_stream = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-stream.js\"(exports, module2) {\n    \"use strict\";\n    var { finished } = __webpack_require__(/*! stream */ \"stream\");\n    var {\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var StreamHandler = class extends AsyncResource2 {\n      constructor(opts, factory, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;\n        try {\n          if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n          }\n          if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"invalid factory\");\n          }\n          if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n          }\n          if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n          }\n          if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n          }\n          super(\"UNDICI_STREAM\");\n        } catch (err) {\n          if (util2.isStream(body)) {\n            util2.destroy(body.on(\"error\", util2.nop), err);\n          }\n          throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        if (util2.isStream(body)) {\n          body.on(\"error\", (err) => {\n            this.onError(err);\n          });\n        }\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume) {\n        const { factory, opaque, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers2 = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers: headers2 });\n          }\n          return;\n        }\n        this.factory = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        const res = this.runInAsyncScope(factory, null, {\n          statusCode,\n          headers,\n          opaque,\n          context: context3\n        });\n        if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n          throw new InvalidReturnValueError(\"expected Writable\");\n        }\n        res.on(\"drain\", resume);\n        finished(res, { readable: false }, (err) => {\n          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;\n          this.res = null;\n          if (err || !res2.readable) {\n            util2.destroy(res2, err);\n          }\n          this.callback = null;\n          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });\n          if (err) {\n            abort();\n          }\n        });\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n        return needDrain !== true;\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.write(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        this.trailers = util2.parseHeaders(trailers);\n        res.end();\n      }\n      onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n          this.res = null;\n          util2.destroy(res, err);\n        } else if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n        if (body) {\n          this.body = null;\n          util2.destroy(body, err);\n        }\n      }\n    };\n    __name(StreamHandler, \"StreamHandler\");\n    function stream2(opts, factory, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          stream2.call(this, opts, factory, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(stream2, \"stream\");\n    module2.exports = stream2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-pipeline.js\nvar require_api_pipeline = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-pipeline.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      Readable,\n      Duplex,\n      PassThrough\n    } = __webpack_require__(/*! stream */ \"stream\");\n    var {\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var kResume = Symbol(\"resume\");\n    var PipelineRequest = class extends Readable {\n      constructor() {\n        super({ autoDestroy: true });\n        this[kResume] = null;\n      }\n      _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n          this[kResume] = null;\n          resume();\n        }\n      }\n      _destroy(err, callback) {\n        this._read();\n        callback(err);\n      }\n    };\n    __name(PipelineRequest, \"PipelineRequest\");\n    var PipelineResponse = class extends Readable {\n      constructor(resume) {\n        super({ autoDestroy: true });\n        this[kResume] = resume;\n      }\n      _read() {\n        this[kResume]();\n      }\n      _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n          err = new RequestAbortedError();\n        }\n        callback(err);\n      }\n    };\n    __name(PipelineResponse, \"PipelineResponse\");\n    var PipelineHandler = class extends AsyncResource2 {\n      constructor(opts, handler) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n          throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n          throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util2.nop);\n        this.ret = new Duplex({\n          readableObjectMode: opts.objectMode,\n          autoDestroy: true,\n          read: () => {\n            const { body } = this;\n            if (body && body.resume) {\n              body.resume();\n            }\n          },\n          write: (chunk, encoding, callback) => {\n            const { req } = this;\n            if (req.push(chunk, encoding) || req._readableState.destroyed) {\n              callback();\n            } else {\n              req[kResume] = callback;\n            }\n          },\n          destroy: (err, callback) => {\n            const { body, req, res, ret, abort } = this;\n            if (!err && !ret._readableState.endEmitted) {\n              err = new RequestAbortedError();\n            }\n            if (abort && err) {\n              abort();\n            }\n            util2.destroy(body, err);\n            util2.destroy(req, err);\n            util2.destroy(res, err);\n            removeSignal(this);\n            callback(err);\n          }\n        }).on(\"prefinish\", () => {\n          const { req } = this;\n          req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        const { ret, res } = this;\n        assert(!res, \"pipeline cannot be retried\");\n        if (ret.destroyed) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers });\n          }\n          return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n          this.handler = null;\n          const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n          body = this.runInAsyncScope(handler, null, {\n            statusCode,\n            headers,\n            opaque,\n            body: this.res,\n            context: context3\n          });\n        } catch (err) {\n          this.res.on(\"error\", util2.nop);\n          throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n          throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk) => {\n          const { ret, body: body2 } = this;\n          if (!ret.push(chunk) && body2.pause) {\n            body2.pause();\n          }\n        }).on(\"error\", (err) => {\n          const { ret } = this;\n          util2.destroy(ret, err);\n        }).on(\"end\", () => {\n          const { ret } = this;\n          ret.push(null);\n        }).on(\"close\", () => {\n          const { ret } = this;\n          if (!ret._readableState.ended) {\n            util2.destroy(ret, new RequestAbortedError());\n          }\n        });\n        this.body = body;\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n      }\n      onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util2.destroy(ret, err);\n      }\n    };\n    __name(PipelineHandler, \"PipelineHandler\");\n    function pipeline(opts, handler) {\n      try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);\n        return pipelineHandler.ret;\n      } catch (err) {\n        return new PassThrough().destroy(err);\n      }\n    }\n    __name(pipeline, \"pipeline\");\n    module2.exports = pipeline;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-upgrade.js\nvar require_api_upgrade = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-upgrade.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var util2 = require_util2();\n    var { addSignal, removeSignal } = require_abort_signal();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var UpgradeHandler = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = null;\n      }\n      onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n      }\n      onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context: context3 } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n          headers,\n          socket,\n          opaque,\n          context: context3\n        });\n      }\n      onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n      }\n    };\n    __name(UpgradeHandler, \"UpgradeHandler\");\n    function upgrade(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          upgrade.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n          ...opts,\n          method: opts.method || \"GET\",\n          upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(upgrade, \"upgrade\");\n    module2.exports = upgrade;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-connect.js\nvar require_api_connect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-connect.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var util2 = require_util2();\n    var { addSignal, removeSignal } = require_abort_signal();\n    var ConnectHandler = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n      }\n      onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context: context3 } = this;\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          socket,\n          opaque,\n          context: context3\n        });\n      }\n      onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n      }\n    };\n    __name(ConnectHandler, \"ConnectHandler\");\n    function connect(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          connect.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({ ...opts, method: \"CONNECT\" }, connectHandler);\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(connect, \"connect\");\n    module2.exports = connect;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/index.js\nvar require_api = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports.request = require_api_request();\n    module2.exports.stream = require_api_stream();\n    module2.exports.pipeline = require_api_pipeline();\n    module2.exports.upgrade = require_api_upgrade();\n    module2.exports.connect = require_api_connect();\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-errors.js\nvar require_mock_errors = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-errors.js\"(exports, module2) {\n    \"use strict\";\n    var { UndiciError } = require_errors();\n    var MockNotMatchedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n      }\n    };\n    __name(MockNotMatchedError, \"MockNotMatchedError\");\n    module2.exports = {\n      MockNotMatchedError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-symbols.js\nvar require_mock_symbols = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-symbols.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      kAgent: Symbol(\"agent\"),\n      kOptions: Symbol(\"options\"),\n      kFactory: Symbol(\"factory\"),\n      kDispatches: Symbol(\"dispatches\"),\n      kDispatchKey: Symbol(\"dispatch key\"),\n      kDefaultHeaders: Symbol(\"default headers\"),\n      kDefaultTrailers: Symbol(\"default trailers\"),\n      kContentLength: Symbol(\"content length\"),\n      kMockAgent: Symbol(\"mock agent\"),\n      kMockAgentSet: Symbol(\"mock agent set\"),\n      kMockAgentGet: Symbol(\"mock agent get\"),\n      kMockDispatch: Symbol(\"mock dispatch\"),\n      kClose: Symbol(\"close\"),\n      kOriginalClose: Symbol(\"original agent close\"),\n      kOrigin: Symbol(\"origin\"),\n      kIsMockActive: Symbol(\"is mock active\"),\n      kNetConnect: Symbol(\"net connect\"),\n      kGetNetConnect: Symbol(\"get net connect\"),\n      kConnected: Symbol(\"connected\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-utils.js\nvar require_mock_utils = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-utils.js\"(exports, module2) {\n    \"use strict\";\n    var { MockNotMatchedError } = require_mock_errors();\n    var {\n      kDispatches,\n      kMockAgent,\n      kOriginalDispatch,\n      kOrigin,\n      kGetNetConnect\n    } = require_mock_symbols();\n    var { buildURL, nop } = require_util2();\n    function matchValue(match, value) {\n      if (typeof match === \"string\") {\n        return match === value;\n      }\n      if (match instanceof RegExp) {\n        return match.test(value);\n      }\n      if (typeof match === \"function\") {\n        return match(value) === true;\n      }\n      return false;\n    }\n    __name(matchValue, \"matchValue\");\n    function lowerCaseEntries(headers) {\n      return Object.fromEntries(\n        Object.entries(headers).map(([headerName, headerValue]) => {\n          return [headerName.toLocaleLowerCase(), headerValue];\n        })\n      );\n    }\n    __name(lowerCaseEntries, \"lowerCaseEntries\");\n    function getHeaderByName(headers, key) {\n      if (Array.isArray(headers)) {\n        for (let i = 0; i < headers.length; i += 2) {\n          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n            return headers[i + 1];\n          }\n        }\n        return void 0;\n      } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n      } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n      }\n    }\n    __name(getHeaderByName, \"getHeaderByName\");\n    function buildHeadersFromArray(headers) {\n      const clone2 = headers.slice();\n      const entries = [];\n      for (let index = 0; index < clone2.length; index += 2) {\n        entries.push([clone2[index], clone2[index + 1]]);\n      }\n      return Object.fromEntries(entries);\n    }\n    __name(buildHeadersFromArray, \"buildHeadersFromArray\");\n    function matchHeaders(mockDispatch2, headers) {\n      if (typeof mockDispatch2.headers === \"function\") {\n        if (Array.isArray(headers)) {\n          headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});\n      }\n      if (typeof mockDispatch2.headers === \"undefined\") {\n        return true;\n      }\n      if (typeof headers !== \"object\" || typeof mockDispatch2.headers !== \"object\") {\n        return false;\n      }\n      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(matchHeaders, \"matchHeaders\");\n    function safeUrl(path7) {\n      if (typeof path7 !== \"string\") {\n        return path7;\n      }\n      const pathSegments = path7.split(\"?\");\n      if (pathSegments.length !== 2) {\n        return path7;\n      }\n      const qp = new URLSearchParams(pathSegments.pop());\n      qp.sort();\n      return [...pathSegments, qp.toString()].join(\"?\");\n    }\n    __name(safeUrl, \"safeUrl\");\n    function matchKey(mockDispatch2, { path: path7, method, body, headers }) {\n      const pathMatch = matchValue(mockDispatch2.path, path7);\n      const methodMatch = matchValue(mockDispatch2.method, method);\n      const bodyMatch = typeof mockDispatch2.body !== \"undefined\" ? matchValue(mockDispatch2.body, body) : true;\n      const headersMatch = matchHeaders(mockDispatch2, headers);\n      return pathMatch && methodMatch && bodyMatch && headersMatch;\n    }\n    __name(matchKey, \"matchKey\");\n    function getResponseData(data) {\n      if (Buffer.isBuffer(data)) {\n        return data;\n      } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n      } else {\n        return data.toString();\n      }\n    }\n    __name(getResponseData, \"getResponseData\");\n    function getMockDispatch(mockDispatches, key) {\n      const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n      const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path7 }) => matchValue(safeUrl(path7), resolvedPath));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers}'`);\n      }\n      return matchedMockDispatches[0];\n    }\n    __name(getMockDispatch, \"getMockDispatch\");\n    function addMockDispatch(mockDispatches, key, data) {\n      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };\n      const replyData = typeof data === \"function\" ? { callback: data } : { ...data };\n      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };\n      mockDispatches.push(newMockDispatch);\n      return newMockDispatch;\n    }\n    __name(addMockDispatch, \"addMockDispatch\");\n    function deleteMockDispatch(mockDispatches, key) {\n      const index = mockDispatches.findIndex((dispatch) => {\n        if (!dispatch.consumed) {\n          return false;\n        }\n        return matchKey(dispatch, key);\n      });\n      if (index !== -1) {\n        mockDispatches.splice(index, 1);\n      }\n    }\n    __name(deleteMockDispatch, \"deleteMockDispatch\");\n    function buildKey(opts) {\n      const { path: path7, method, body, headers, query: query2 } = opts;\n      return {\n        path: path7,\n        method,\n        body,\n        headers,\n        query: query2\n      };\n    }\n    __name(buildKey, \"buildKey\");\n    function generateKeyValues(data) {\n      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);\n    }\n    __name(generateKeyValues, \"generateKeyValues\");\n    function getStatusText(statusCode) {\n      switch (statusCode) {\n        case 100:\n          return \"Continue\";\n        case 101:\n          return \"Switching Protocols\";\n        case 102:\n          return \"Processing\";\n        case 103:\n          return \"Early Hints\";\n        case 200:\n          return \"OK\";\n        case 201:\n          return \"Created\";\n        case 202:\n          return \"Accepted\";\n        case 203:\n          return \"Non-Authoritative Information\";\n        case 204:\n          return \"No Content\";\n        case 205:\n          return \"Reset Content\";\n        case 206:\n          return \"Partial Content\";\n        case 207:\n          return \"Multi-Status\";\n        case 208:\n          return \"Already Reported\";\n        case 226:\n          return \"IM Used\";\n        case 300:\n          return \"Multiple Choice\";\n        case 301:\n          return \"Moved Permanently\";\n        case 302:\n          return \"Found\";\n        case 303:\n          return \"See Other\";\n        case 304:\n          return \"Not Modified\";\n        case 305:\n          return \"Use Proxy\";\n        case 306:\n          return \"unused\";\n        case 307:\n          return \"Temporary Redirect\";\n        case 308:\n          return \"Permanent Redirect\";\n        case 400:\n          return \"Bad Request\";\n        case 401:\n          return \"Unauthorized\";\n        case 402:\n          return \"Payment Required\";\n        case 403:\n          return \"Forbidden\";\n        case 404:\n          return \"Not Found\";\n        case 405:\n          return \"Method Not Allowed\";\n        case 406:\n          return \"Not Acceptable\";\n        case 407:\n          return \"Proxy Authentication Required\";\n        case 408:\n          return \"Request Timeout\";\n        case 409:\n          return \"Conflict\";\n        case 410:\n          return \"Gone\";\n        case 411:\n          return \"Length Required\";\n        case 412:\n          return \"Precondition Failed\";\n        case 413:\n          return \"Payload Too Large\";\n        case 414:\n          return \"URI Too Large\";\n        case 415:\n          return \"Unsupported Media Type\";\n        case 416:\n          return \"Range Not Satisfiable\";\n        case 417:\n          return \"Expectation Failed\";\n        case 418:\n          return \"I'm a teapot\";\n        case 421:\n          return \"Misdirected Request\";\n        case 422:\n          return \"Unprocessable Entity\";\n        case 423:\n          return \"Locked\";\n        case 424:\n          return \"Failed Dependency\";\n        case 425:\n          return \"Too Early\";\n        case 426:\n          return \"Upgrade Required\";\n        case 428:\n          return \"Precondition Required\";\n        case 429:\n          return \"Too Many Requests\";\n        case 431:\n          return \"Request Header Fields Too Large\";\n        case 451:\n          return \"Unavailable For Legal Reasons\";\n        case 500:\n          return \"Internal Server Error\";\n        case 501:\n          return \"Not Implemented\";\n        case 502:\n          return \"Bad Gateway\";\n        case 503:\n          return \"Service Unavailable\";\n        case 504:\n          return \"Gateway Timeout\";\n        case 505:\n          return \"HTTP Version Not Supported\";\n        case 506:\n          return \"Variant Also Negotiates\";\n        case 507:\n          return \"Insufficient Storage\";\n        case 508:\n          return \"Loop Detected\";\n        case 510:\n          return \"Not Extended\";\n        case 511:\n          return \"Network Authentication Required\";\n        default:\n          return \"unknown\";\n      }\n    }\n    __name(getStatusText, \"getStatusText\");\n    async function getResponse(body) {\n      const buffers = [];\n      for await (const data of body) {\n        buffers.push(data);\n      }\n      return Buffer.concat(buffers).toString(\"utf8\");\n    }\n    __name(getResponse, \"getResponse\");\n    function mockDispatch(opts, handler) {\n      const key = buildKey(opts);\n      const mockDispatch2 = getMockDispatch(this[kDispatches], key);\n      mockDispatch2.timesInvoked++;\n      if (mockDispatch2.data.callback) {\n        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };\n      }\n      const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;\n      const { timesInvoked, times } = mockDispatch2;\n      mockDispatch2.consumed = !persist && timesInvoked >= times;\n      mockDispatch2.pending = timesInvoked < times;\n      if (error2 !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error2);\n        return true;\n      }\n      if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(() => {\n          handleReply(this[kDispatches]);\n        }, delay);\n      } else {\n        handleReply(this[kDispatches]);\n      }\n      function handleReply(mockDispatches) {\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const responseData = getResponseData(\n          typeof data === \"function\" ? data({ ...opts, headers: optsHeaders }) : data\n        );\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.abort = nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n      }\n      __name(handleReply, \"handleReply\");\n      function resume() {\n      }\n      __name(resume, \"resume\");\n      return true;\n    }\n    __name(mockDispatch, \"mockDispatch\");\n    function buildMockDispatch() {\n      const agent = this[kMockAgent];\n      const origin = this[kOrigin];\n      const originalDispatch = this[kOriginalDispatch];\n      return /* @__PURE__ */ __name(function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n          try {\n            mockDispatch.call(this, opts, handler);\n          } catch (error2) {\n            if (error2 instanceof MockNotMatchedError) {\n              const netConnect = agent[kGetNetConnect]();\n              if (netConnect === false) {\n                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n              }\n              if (checkNetConnect(netConnect, origin)) {\n                originalDispatch.call(this, opts, handler);\n              } else {\n                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n              }\n            } else {\n              throw error2;\n            }\n          }\n        } else {\n          originalDispatch.call(this, opts, handler);\n        }\n      }, \"dispatch\");\n    }\n    __name(buildMockDispatch, \"buildMockDispatch\");\n    function checkNetConnect(netConnect, origin) {\n      const url = new URL(origin);\n      if (netConnect === true) {\n        return true;\n      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n        return true;\n      }\n      return false;\n    }\n    __name(checkNetConnect, \"checkNetConnect\");\n    function buildMockOptions(opts) {\n      if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n      }\n    }\n    __name(buildMockOptions, \"buildMockOptions\");\n    module2.exports = {\n      getResponseData,\n      getMockDispatch,\n      addMockDispatch,\n      deleteMockDispatch,\n      buildKey,\n      generateKeyValues,\n      matchValue,\n      getResponse,\n      getStatusText,\n      mockDispatch,\n      buildMockDispatch,\n      checkNetConnect,\n      buildMockOptions,\n      getHeaderByName\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-interceptor.js\nvar require_mock_interceptor = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-interceptor.js\"(exports, module2) {\n    \"use strict\";\n    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kDispatchKey,\n      kDefaultHeaders,\n      kDefaultTrailers,\n      kContentLength,\n      kMockDispatch\n    } = require_mock_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var { buildURL } = require_util2();\n    var MockScope = class {\n      constructor(mockDispatch) {\n        this[kMockDispatch] = mockDispatch;\n      }\n      delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n          throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n      }\n      persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n      }\n      times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n          throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n      }\n    };\n    __name(MockScope, \"MockScope\");\n    var MockInterceptor = class {\n      constructor(opts, mockDispatches) {\n        if (typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n          throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n          opts.method = \"GET\";\n        }\n        if (typeof opts.path === \"string\") {\n          if (opts.query) {\n            opts.path = buildURL(opts.path, opts.query);\n          } else {\n            const parsedURL = new URL(opts.path, \"data://\");\n            opts.path = parsedURL.pathname + parsedURL.search;\n          }\n        }\n        if (typeof opts.method === \"string\") {\n          opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n      }\n      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? { \"content-length\": responseData.length } : {};\n        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };\n        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };\n        return { statusCode, data, headers, trailers };\n      }\n      validateReplyParameters(statusCode, data, responseOptions) {\n        if (typeof statusCode === \"undefined\") {\n          throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof data === \"undefined\") {\n          throw new InvalidArgumentError(\"data must be defined\");\n        }\n        if (typeof responseOptions !== \"object\") {\n          throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n      }\n      reply(replyData) {\n        if (typeof replyData === \"function\") {\n          const wrappedDefaultsCallback = /* @__PURE__ */ __name((opts) => {\n            const resolvedData = replyData(opts);\n            if (typeof resolvedData !== \"object\") {\n              throw new InvalidArgumentError(\"reply options callback must return an object\");\n            }\n            const { statusCode: statusCode2, data: data2 = \"\", responseOptions: responseOptions2 = {} } = resolvedData;\n            this.validateReplyParameters(statusCode2, data2, responseOptions2);\n            return {\n              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)\n            };\n          }, \"wrappedDefaultsCallback\");\n          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n          return new MockScope(newMockDispatch2);\n        }\n        const [statusCode, data = \"\", responseOptions = {}] = [...arguments];\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n      }\n      replyWithError(error2) {\n        if (typeof error2 === \"undefined\") {\n          throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });\n        return new MockScope(newMockDispatch);\n      }\n      defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n          throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n      }\n      defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n          throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n      }\n      replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n      }\n    };\n    __name(MockInterceptor, \"MockInterceptor\");\n    module2.exports.MockInterceptor = MockInterceptor;\n    module2.exports.MockScope = MockScope;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-client.js\nvar require_mock_client = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-client.js\"(exports, module2) {\n    \"use strict\";\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var Client = require_client();\n    var { buildMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kMockAgent,\n      kClose,\n      kOriginalClose,\n      kOrigin,\n      kOriginalDispatch,\n      kConnected\n    } = require_mock_symbols();\n    var { MockInterceptor } = require_mock_interceptor();\n    var Symbols = require_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var MockClient = class extends Client {\n      constructor(origin, opts) {\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n      }\n      get [Symbols.kConnected]() {\n        return this[kConnected];\n      }\n      intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n      }\n      async [kClose]() {\n        await promisify4(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n      }\n    };\n    __name(MockClient, \"MockClient\");\n    module2.exports = MockClient;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-pool.js\nvar require_mock_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-pool.js\"(exports, module2) {\n    \"use strict\";\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var Pool = require_pool();\n    var { buildMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kMockAgent,\n      kClose,\n      kOriginalClose,\n      kOrigin,\n      kOriginalDispatch,\n      kConnected\n    } = require_mock_symbols();\n    var { MockInterceptor } = require_mock_interceptor();\n    var Symbols = require_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var MockPool = class extends Pool {\n      constructor(origin, opts) {\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n      }\n      get [Symbols.kConnected]() {\n        return this[kConnected];\n      }\n      intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n      }\n      async [kClose]() {\n        await promisify4(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n      }\n    };\n    __name(MockPool, \"MockPool\");\n    module2.exports = MockPool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pluralizer.js\nvar require_pluralizer = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pluralizer.js\"(exports, module2) {\n    \"use strict\";\n    var singulars = {\n      pronoun: \"it\",\n      is: \"is\",\n      was: \"was\",\n      this: \"this\"\n    };\n    var plurals = {\n      pronoun: \"they\",\n      is: \"are\",\n      was: \"were\",\n      this: \"these\"\n    };\n    module2.exports = /* @__PURE__ */ __name(class Pluralizer {\n      constructor(singular, plural) {\n        this.singular = singular;\n        this.plural = plural;\n      }\n      pluralize(count2) {\n        const one = count2 === 1;\n        const keys2 = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return { ...keys2, count: count2, noun };\n      }\n    }, \"Pluralizer\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js\nvar require_pending_interceptors_formatter = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js\"(exports, module2) {\n    \"use strict\";\n    var { Transform } = __webpack_require__(/*! stream */ \"stream\");\n    var { Console } = __webpack_require__(/*! console */ \"console\");\n    module2.exports = /* @__PURE__ */ __name(class PendingInterceptorsFormatter {\n      constructor({ disableColors } = {}) {\n        this.transform = new Transform({\n          transform(chunk, _enc, cb) {\n            cb(null, chunk);\n          }\n        });\n        this.logger = new Console({\n          stdout: this.transform,\n          inspectOptions: {\n            colors: !disableColors && !process.env.CI\n          }\n        });\n      }\n      format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(\n          ({ method, path: path7, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n            Method: method,\n            Origin: origin,\n            Path: path7,\n            \"Status code\": statusCode,\n            Persistent: persist ? \"\\u2705\" : \"\\u274C\",\n            Invocations: timesInvoked,\n            Remaining: persist ? Infinity : times - timesInvoked\n          })\n        );\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n      }\n    }, \"PendingInterceptorsFormatter\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-agent.js\nvar require_mock_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-agent.js\"(exports, module2) {\n    \"use strict\";\n    var { kClients } = require_symbols();\n    var Agent = require_agent();\n    var {\n      kAgent,\n      kMockAgentSet,\n      kMockAgentGet,\n      kDispatches,\n      kIsMockActive,\n      kNetConnect,\n      kGetNetConnect,\n      kOptions,\n      kFactory\n    } = require_mock_symbols();\n    var MockClient = require_mock_client();\n    var MockPool = require_mock_pool();\n    var { matchValue, buildMockOptions } = require_mock_utils();\n    var { InvalidArgumentError, UndiciError } = require_errors();\n    var Dispatcher = require_dispatcher();\n    var Pluralizer = require_pluralizer();\n    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();\n    var FakeWeakRef = class {\n      constructor(value) {\n        this.value = value;\n      }\n      deref() {\n        return this.value;\n      }\n    };\n    __name(FakeWeakRef, \"FakeWeakRef\");\n    var MockAgent = class extends Dispatcher {\n      constructor(opts) {\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        if (opts && opts.agent && typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n      }\n      get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n          dispatcher = this[kFactory](origin);\n          this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n      }\n      dispatch(opts, handler) {\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n      }\n      async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n      }\n      deactivate() {\n        this[kIsMockActive] = false;\n      }\n      activate() {\n        this[kIsMockActive] = true;\n      }\n      enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n          if (Array.isArray(this[kNetConnect])) {\n            this[kNetConnect].push(matcher);\n          } else {\n            this[kNetConnect] = [matcher];\n          }\n        } else if (typeof matcher === \"undefined\") {\n          this[kNetConnect] = true;\n        } else {\n          throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n      }\n      disableNetConnect() {\n        this[kNetConnect] = false;\n      }\n      get isMockActive() {\n        return this[kIsMockActive];\n      }\n      [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, new FakeWeakRef(dispatcher));\n      }\n      [kFactory](origin) {\n        const mockOptions = Object.assign({ agent: this }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n      }\n      [kMockAgentGet](origin) {\n        const ref = this[kClients].get(origin);\n        if (ref) {\n          return ref.deref();\n        }\n        if (typeof origin !== \"string\") {\n          const dispatcher = this[kFactory](\"http://localhost:9999\");\n          this[kMockAgentSet](origin, dispatcher);\n          return dispatcher;\n        }\n        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n          const nonExplicitDispatcher = nonExplicitRef.deref();\n          if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n            const dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n            return dispatcher;\n          }\n        }\n      }\n      [kGetNetConnect]() {\n        return this[kNetConnect];\n      }\n      pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);\n      }\n      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n          return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n      }\n    };\n    __name(MockAgent, \"MockAgent\");\n    module2.exports = MockAgent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/proxy-agent.js\nvar require_proxy_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/proxy-agent.js\"(exports, module2) {\n    \"use strict\";\n    var { kClose, kDestroy } = require_symbols();\n    var Client = require_agent();\n    var Agent = require_agent();\n    var DispatcherBase = require_dispatcher_base();\n    var { InvalidArgumentError, RequestAbortedError } = require_errors();\n    var buildConnector = require_connect();\n    var kAgent = Symbol(\"proxy agent\");\n    var kClient = Symbol(\"proxy client\");\n    var kProxyHeaders = Symbol(\"proxy headers\");\n    var kRequestTls = Symbol(\"request tls settings\");\n    var kProxyTls = Symbol(\"proxy tls settings\");\n    var kConnectEndpoint = Symbol(\"connect endpoint function\");\n    function defaultProtocolPort(protocol) {\n      return protocol === \"https:\" ? 443 : 80;\n    }\n    __name(defaultProtocolPort, \"defaultProtocolPort\");\n    var ProxyAgent = class extends DispatcherBase {\n      constructor(opts) {\n        super(opts);\n        if (typeof opts === \"string\") {\n          opts = { uri: opts };\n        }\n        if (!opts || !opts.uri) {\n          throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n        }\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = {};\n        if (opts.auth) {\n          this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        }\n        const { origin, port } = new URL(opts.uri);\n        const connect = buildConnector({ ...opts.proxyTls });\n        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });\n        this[kClient] = new Client({ origin: opts.origin, connect });\n        this[kAgent] = new Agent({\n          ...opts,\n          connect: async (opts2, callback) => {\n            let requestedHost = opts2.host;\n            if (!opts2.port) {\n              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;\n            }\n            try {\n              const { socket, statusCode } = await this[kClient].connect({\n                origin,\n                port,\n                path: requestedHost,\n                signal: opts2.signal,\n                headers: {\n                  ...this[kProxyHeaders],\n                  host: opts2.host\n                }\n              });\n              if (statusCode !== 200) {\n                socket.on(\"error\", () => {\n                }).destroy();\n                callback(new RequestAbortedError(\"Proxy response !== 200 when HTTP Tunneling\"));\n              }\n              if (opts2.protocol !== \"https:\") {\n                callback(null, socket);\n                return;\n              }\n              let servername;\n              if (this[kRequestTls]) {\n                servername = this[kRequestTls].servername;\n              } else {\n                servername = opts2.servername;\n              }\n              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        });\n      }\n      dispatch(opts, handler) {\n        const { host } = new URL(opts.origin);\n        const headers = buildHeaders2(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        return this[kAgent].dispatch(\n          {\n            ...opts,\n            headers: {\n              ...headers,\n              host\n            }\n          },\n          handler\n        );\n      }\n      async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n      }\n      async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n      }\n    };\n    __name(ProxyAgent, \"ProxyAgent\");\n    function buildHeaders2(headers) {\n      if (Array.isArray(headers)) {\n        const headersPair = {};\n        for (let i = 0; i < headers.length; i += 2) {\n          headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n      }\n      return headers;\n    }\n    __name(buildHeaders2, \"buildHeaders\");\n    function throwIfProxyAuthIsSent(headers) {\n      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === \"proxy-authorization\");\n      if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n      }\n    }\n    __name(throwIfProxyAuthIsSent, \"throwIfProxyAuthIsSent\");\n    module2.exports = ProxyAgent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/global.js\nvar require_global = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/global.js\"(exports, module2) {\n    \"use strict\";\n    var globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\n    var { InvalidArgumentError } = require_errors();\n    var Agent = require_agent();\n    if (getGlobalDispatcher() === void 0) {\n      setGlobalDispatcher(new Agent());\n    }\n    function setGlobalDispatcher(agent) {\n      if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n      }\n      Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n      });\n    }\n    __name(setGlobalDispatcher, \"setGlobalDispatcher\");\n    function getGlobalDispatcher() {\n      return globalThis[globalDispatcher];\n    }\n    __name(getGlobalDispatcher, \"getGlobalDispatcher\");\n    module2.exports = {\n      setGlobalDispatcher,\n      getGlobalDispatcher\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/headers.js\nvar require_headers = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/headers.js\"(exports, module2) {\n    \"use strict\";\n    var { kHeadersList } = require_symbols();\n    var { kGuard } = require_symbols2();\n    var { kEnumerableProperty } = require_util2();\n    var {\n      makeIterator,\n      isValidHeaderName,\n      isValidHeaderValue\n    } = require_util3();\n    var { webidl } = require_webidl();\n    var kHeadersMap = Symbol(\"headers map\");\n    var kHeadersSortedMap = Symbol(\"headers map sorted\");\n    function headerValueNormalize(potentialValue) {\n      return potentialValue.replace(\n        /^[\\r\\n\\t ]+|[\\r\\n\\t ]+$/g,\n        \"\"\n      );\n    }\n    __name(headerValueNormalize, \"headerValueNormalize\");\n    function fill(headers, object) {\n      if (Array.isArray(object)) {\n        for (const header of object) {\n          if (header.length !== 2) {\n            webidl.errors.exception({\n              header: \"Headers constructor\",\n              message: `expected name/value pair to be length 2, found ${header.length}.`\n            });\n          }\n          headers.append(header[0], header[1]);\n        }\n      } else if (typeof object === \"object\" && object !== null) {\n        for (const [key, value] of Object.entries(object)) {\n          headers.append(key, value);\n        }\n      } else {\n        webidl.errors.conversionFailed({\n          prefix: \"Headers constructor\",\n          argument: \"Argument 1\",\n          types: [\"sequence<sequence<ByteString>>\", \"record<ByteString, ByteString>\"]\n        });\n      }\n    }\n    __name(fill, \"fill\");\n    var HeadersList = class {\n      constructor(init) {\n        if (init instanceof HeadersList) {\n          this[kHeadersMap] = new Map(init[kHeadersMap]);\n          this[kHeadersSortedMap] = init[kHeadersSortedMap];\n        } else {\n          this[kHeadersMap] = new Map(init);\n          this[kHeadersSortedMap] = null;\n        }\n      }\n      contains(name) {\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n      }\n      clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n      }\n      append(name, value) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        const exists4 = this[kHeadersMap].get(name);\n        if (exists4) {\n          this[kHeadersMap].set(name, `${exists4}, ${value}`);\n        } else {\n          this[kHeadersMap].set(name, `${value}`);\n        }\n      }\n      set(name, value) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        return this[kHeadersMap].set(name, value);\n      }\n      delete(name) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        return this[kHeadersMap].delete(name);\n      }\n      get(name) {\n        var _a3;\n        name = name.toLowerCase();\n        if (!this.contains(name)) {\n          return null;\n        }\n        return (_a3 = this[kHeadersMap].get(name)) != null ? _a3 : null;\n      }\n      has(name) {\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n      }\n      keys() {\n        return this[kHeadersMap].keys();\n      }\n      values() {\n        return this[kHeadersMap].values();\n      }\n      entries() {\n        return this[kHeadersMap].entries();\n      }\n      [Symbol.iterator]() {\n        return this[kHeadersMap][Symbol.iterator]();\n      }\n    };\n    __name(HeadersList, \"HeadersList\");\n    var Headers = class {\n      constructor(init = void 0) {\n        this[kHeadersList] = new HeadersList();\n        this[kGuard] = \"none\";\n        if (init !== void 0) {\n          init = webidl.converters.HeadersInit(init);\n          fill(this, init);\n        }\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      append(name, value) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        value = headerValueNormalize(value);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value: name,\n            type: \"header name\"\n          });\n        } else if (!isValidHeaderValue(value)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value,\n            type: \"header value\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        return this[kHeadersList].append(name, value);\n      }\n      delete(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.delete\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        if (!this[kHeadersList].contains(name)) {\n          return;\n        }\n        return this[kHeadersList].delete(name);\n      }\n      get(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.get\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        return this[kHeadersList].get(name);\n      }\n      has(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.has\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        return this[kHeadersList].contains(name);\n      }\n      set(name, value) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        value = headerValueNormalize(value);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.set\",\n            value: name,\n            type: \"header name\"\n          });\n        } else if (!isValidHeaderValue(value)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.set\",\n            value,\n            type: \"header value\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        return this[kHeadersList].set(name, value);\n      }\n      get [kHeadersSortedMap]() {\n        var _a3, _b2;\n        (_b2 = (_a3 = this[kHeadersList])[kHeadersSortedMap]) != null ? _b2 : _a3[kHeadersSortedMap] = new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1));\n        return this[kHeadersList][kHeadersSortedMap];\n      }\n      keys() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].keys(), \"Headers\");\n      }\n      values() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].values(), \"Headers\");\n      }\n      entries() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].entries(), \"Headers\");\n      }\n      forEach(callbackFn, thisArg = globalThis) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        if (typeof callbackFn !== \"function\") {\n          throw new TypeError(\n            \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n          );\n        }\n        for (const [key, value] of this) {\n          callbackFn.apply(thisArg, [value, key, this]);\n        }\n      }\n      [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeadersList];\n      }\n    };\n    __name(Headers, \"Headers\");\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n    Object.defineProperties(Headers.prototype, {\n      append: kEnumerableProperty,\n      delete: kEnumerableProperty,\n      get: kEnumerableProperty,\n      has: kEnumerableProperty,\n      set: kEnumerableProperty,\n      keys: kEnumerableProperty,\n      values: kEnumerableProperty,\n      entries: kEnumerableProperty,\n      forEach: kEnumerableProperty\n    });\n    webidl.converters.HeadersInit = function(V) {\n      if (webidl.util.Type(V) === \"Object\") {\n        if (V[Symbol.iterator]) {\n          return webidl.converters[\"sequence<sequence<ByteString>>\"](V);\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V);\n      }\n      webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\"sequence<sequence<ByteString>>\", \"record<ByteString, ByteString>\"]\n      });\n    };\n    module2.exports = {\n      fill,\n      Headers,\n      HeadersList\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/response.js\nvar require_response = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/response.js\"(exports, module2) {\n    \"use strict\";\n    var { Headers, HeadersList, fill } = require_headers();\n    var { extractBody, cloneBody, mixinBody } = require_body();\n    var util2 = require_util2();\n    var { kEnumerableProperty } = util2;\n    var {\n      responseURL,\n      isValidReasonPhrase,\n      isCancelled,\n      isAborted,\n      isBlobLike,\n      serializeJavascriptValueToJSONString,\n      isErrorLike\n    } = require_util3();\n    var {\n      redirectStatus,\n      nullBodyStatus,\n      DOMException\n    } = require_constants();\n    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { FormData } = require_formdata();\n    var { kHeadersList } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    var Response = class {\n      static error() {\n        const relevantRealm = { settingsObject: {} };\n        const responseObject = new Response();\n        responseObject[kState] = makeNetworkError();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        return responseObject;\n      }\n      static json(data, init = {}) {\n        if (arguments.length === 0) {\n          throw new TypeError(\n            \"Failed to execute 'json' on 'Response': 1 argument required, but 0 present.\"\n          );\n        }\n        if (init !== null) {\n          init = webidl.converters.ResponseInit(init);\n        }\n        const bytes = new TextEncoder(\"utf-8\").encode(\n          serializeJavascriptValueToJSONString(data)\n        );\n        const body = extractBody(bytes);\n        const relevantRealm = { settingsObject: {} };\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"response\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        initializeResponse(responseObject, init, { body: body[0], type: \"application/json\" });\n        return responseObject;\n      }\n      static redirect(url, status = 302) {\n        const relevantRealm = { settingsObject: {} };\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        let parsedURL;\n        try {\n          parsedURL = new URL(url);\n        } catch (err) {\n          throw Object.assign(new TypeError(\"Failed to parse URL from \" + url), {\n            cause: err\n          });\n        }\n        if (!redirectStatus.includes(status)) {\n          throw new RangeError(\"Invalid status code\");\n        }\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        responseObject[kState].status = status;\n        const value = parsedURL.toString();\n        responseObject[kState].headersList.append(\"location\", value);\n        return responseObject;\n      }\n      constructor(body = null, init = {}) {\n        if (body !== null) {\n          body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        this[kRealm] = { settingsObject: {} };\n        this[kState] = makeResponse({});\n        this[kHeaders] = new Headers();\n        this[kHeaders][kGuard] = \"response\";\n        this[kHeaders][kHeadersList] = this[kState].headersList;\n        this[kHeaders][kRealm] = this[kRealm];\n        let bodyWithType = null;\n        if (body != null) {\n          const [extractedBody, type] = extractBody(body);\n          bodyWithType = { body: extractedBody, type };\n        }\n        initializeResponse(this, init, bodyWithType);\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      get type() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].type;\n      }\n      get url() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        let url = responseURL(this[kState]);\n        if (url == null) {\n          return \"\";\n        }\n        if (url.hash) {\n          url = new URL(url);\n          url.hash = \"\";\n        }\n        return url.toString();\n      }\n      get redirected() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].urlList.length > 1;\n      }\n      get status() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].status;\n      }\n      get ok() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].status >= 200 && this[kState].status <= 299;\n      }\n      get statusText() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].statusText;\n      }\n      get headers() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeaders];\n      }\n      clone() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this.bodyUsed || this.body && this.body.locked) {\n          webidl.errors.exception({\n            header: \"Response.clone\",\n            message: \"Body has already been consumed.\"\n          });\n        }\n        const clonedResponse = cloneResponse(this[kState]);\n        const clonedResponseObject = new Response();\n        clonedResponseObject[kState] = clonedResponse;\n        clonedResponseObject[kRealm] = this[kRealm];\n        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        return clonedResponseObject;\n      }\n    };\n    __name(Response, \"Response\");\n    mixinBody(Response);\n    Object.defineProperties(Response.prototype, {\n      type: kEnumerableProperty,\n      url: kEnumerableProperty,\n      status: kEnumerableProperty,\n      ok: kEnumerableProperty,\n      redirected: kEnumerableProperty,\n      statusText: kEnumerableProperty,\n      headers: kEnumerableProperty,\n      clone: kEnumerableProperty\n    });\n    function cloneResponse(response) {\n      if (response.internalResponse) {\n        return filterResponse(\n          cloneResponse(response.internalResponse),\n          response.type\n        );\n      }\n      const newResponse = makeResponse({ ...response, body: null });\n      if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n      }\n      return newResponse;\n    }\n    __name(cloneResponse, \"cloneResponse\");\n    function makeResponse(init) {\n      return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n        urlList: init.urlList ? [...init.urlList] : []\n      };\n    }\n    __name(makeResponse, \"makeResponse\");\n    function makeNetworkError(reason) {\n      const isError2 = isErrorLike(reason);\n      return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError2 ? reason : new Error(reason ? String(reason) : reason, {\n          cause: isError2 ? reason : void 0\n        }),\n        aborted: reason && reason.name === \"AbortError\"\n      });\n    }\n    __name(makeNetworkError, \"makeNetworkError\");\n    function makeFilteredResponse(response, state) {\n      state = {\n        internalResponse: response,\n        ...state\n      };\n      return new Proxy(response, {\n        get(target, p) {\n          return p in state ? state[p] : target[p];\n        },\n        set(target, p, value) {\n          assert(!(p in state));\n          target[p] = value;\n          return true;\n        }\n      });\n    }\n    __name(makeFilteredResponse, \"makeFilteredResponse\");\n    function filterResponse(response, type) {\n      if (type === \"basic\") {\n        return makeFilteredResponse(response, {\n          type: \"basic\",\n          headersList: response.headersList\n        });\n      } else if (type === \"cors\") {\n        return makeFilteredResponse(response, {\n          type: \"cors\",\n          headersList: response.headersList\n        });\n      } else if (type === \"opaque\") {\n        return makeFilteredResponse(response, {\n          type: \"opaque\",\n          urlList: Object.freeze([]),\n          status: 0,\n          statusText: \"\",\n          body: null\n        });\n      } else if (type === \"opaqueredirect\") {\n        return makeFilteredResponse(response, {\n          type: \"opaqueredirect\",\n          status: 0,\n          statusText: \"\",\n          headersList: [],\n          body: null\n        });\n      } else {\n        assert(false);\n      }\n    }\n    __name(filterResponse, \"filterResponse\");\n    function makeAppropriateNetworkError(fetchParams) {\n      assert(isCancelled(fetchParams));\n      return isAborted(fetchParams) ? makeNetworkError(new DOMException(\"The operation was aborted.\", \"AbortError\")) : makeNetworkError(fetchParams.controller.terminated.reason);\n    }\n    __name(makeAppropriateNetworkError, \"makeAppropriateNetworkError\");\n    function initializeResponse(response, init, body) {\n      if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n      }\n      if (\"statusText\" in init && init.statusText != null) {\n        if (!isValidReasonPhrase(String(init.statusText))) {\n          throw new TypeError(\"Invalid statusText\");\n        }\n      }\n      if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n      }\n      if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n      }\n      if (\"headers\" in init && init.headers != null) {\n        fill(response[kState].headersList, init.headers);\n      }\n      if (body) {\n        if (nullBodyStatus.includes(response.status)) {\n          webidl.errors.exception({\n            header: \"Response constructor\",\n            message: \"Invalid response status code.\"\n          });\n        }\n        response[kState].body = body.body;\n        if (body.type != null && !response[kState].headersList.has(\"Content-Type\")) {\n          response[kState].headersList.append(\"content-type\", body.type);\n        }\n      }\n    }\n    __name(initializeResponse, \"initializeResponse\");\n    webidl.converters.ReadableStream = webidl.interfaceConverter(\n      ReadableStream\n    );\n    webidl.converters.FormData = webidl.interfaceConverter(\n      FormData\n    );\n    webidl.converters.URLSearchParams = webidl.interfaceConverter(\n      URLSearchParams\n    );\n    webidl.converters.XMLHttpRequestBodyInit = function(V) {\n      if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n      }\n      if (isBlobLike(V)) {\n        return webidl.converters.Blob(V);\n      }\n      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n        return webidl.converters.BufferSource(V);\n      }\n      if (V instanceof FormData) {\n        return webidl.converters.FormData(V);\n      }\n      if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V);\n      }\n      return webidl.converters.DOMString(V);\n    };\n    webidl.converters.BodyInit = function(V) {\n      if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V);\n      }\n      if (V == null ? void 0 : V[Symbol.asyncIterator]) {\n        return V;\n      }\n      return webidl.converters.XMLHttpRequestBodyInit(V);\n    };\n    webidl.converters.ResponseInit = webidl.dictionaryConverter([\n      {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 200\n      },\n      {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: \"\"\n      },\n      {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n      }\n    ]);\n    module2.exports = {\n      makeNetworkError,\n      makeResponse,\n      makeAppropriateNetworkError,\n      filterResponse,\n      Response\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/request.js\nvar require_request2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/request.js\"(exports, module2) {\n    \"use strict\";\n    var { extractBody, mixinBody, cloneBody } = require_body();\n    var { Headers, fill: fillHeaders, HeadersList } = require_headers();\n    var { FinalizationRegistry } = require_dispatcher_weakref()();\n    var util2 = require_util2();\n    var {\n      isValidHTTPToken,\n      sameOrigin,\n      normalizeMethod\n    } = require_util3();\n    var {\n      forbiddenMethods,\n      corsSafeListedMethods,\n      referrerPolicy,\n      requestRedirect,\n      requestMode,\n      requestCredentials,\n      requestCache\n    } = require_constants();\n    var { kEnumerableProperty } = util2;\n    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { kHeadersList } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var TransformStream;\n    var kInit = Symbol(\"init\");\n    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n      signal.removeEventListener(\"abort\", abort);\n    });\n    var Request = class {\n      constructor(input, init = {}) {\n        var _a3, _b2;\n        if (input === kInit) {\n          return;\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        input = webidl.converters.RequestInfo(input);\n        init = webidl.converters.RequestInit(init);\n        this[kRealm] = { settingsObject: {} };\n        let request2 = null;\n        let fallbackMode = null;\n        const baseUrl = this[kRealm].settingsObject.baseUrl;\n        let signal = null;\n        if (typeof input === \"string\") {\n          let parsedURL;\n          try {\n            parsedURL = new URL(input, baseUrl);\n          } catch (err) {\n            throw new TypeError(\"Failed to parse URL from \" + input, { cause: err });\n          }\n          if (parsedURL.username || parsedURL.password) {\n            throw new TypeError(\n              \"Request cannot be constructed from a URL that includes credentials: \" + input\n            );\n          }\n          request2 = makeRequest({ urlList: [parsedURL] });\n          fallbackMode = \"cors\";\n        } else {\n          assert(input instanceof Request);\n          request2 = input[kState];\n          signal = input[kSignal];\n        }\n        const origin = this[kRealm].settingsObject.origin;\n        let window2 = \"client\";\n        if (((_b2 = (_a3 = request2.window) == null ? void 0 : _a3.constructor) == null ? void 0 : _b2.name) === \"EnvironmentSettingsObject\" && sameOrigin(request2.window, origin)) {\n          window2 = request2.window;\n        }\n        if (init.window !== void 0 && init.window != null) {\n          throw new TypeError(`'window' option '${window2}' must be null`);\n        }\n        if (init.window !== void 0) {\n          window2 = \"no-window\";\n        }\n        request2 = makeRequest({\n          method: request2.method,\n          headersList: request2.headersList,\n          unsafeRequest: request2.unsafeRequest,\n          client: this[kRealm].settingsObject,\n          window: window2,\n          priority: request2.priority,\n          origin: request2.origin,\n          referrer: request2.referrer,\n          referrerPolicy: request2.referrerPolicy,\n          mode: request2.mode,\n          credentials: request2.credentials,\n          cache: request2.cache,\n          redirect: request2.redirect,\n          integrity: request2.integrity,\n          keepalive: request2.keepalive,\n          reloadNavigation: request2.reloadNavigation,\n          historyNavigation: request2.historyNavigation,\n          urlList: [...request2.urlList]\n        });\n        if (Object.keys(init).length > 0) {\n          if (request2.mode === \"navigate\") {\n            request2.mode = \"same-origin\";\n          }\n          request2.reloadNavigation = false;\n          request2.historyNavigation = false;\n          request2.origin = \"client\";\n          request2.referrer = \"client\";\n          request2.referrerPolicy = \"\";\n          request2.url = request2.urlList[request2.urlList.length - 1];\n          request2.urlList = [request2.url];\n        }\n        if (init.referrer !== void 0) {\n          const referrer = init.referrer;\n          if (referrer === \"\") {\n            request2.referrer = \"no-referrer\";\n          } else {\n            let parsedReferrer;\n            try {\n              parsedReferrer = new URL(referrer, baseUrl);\n            } catch (err) {\n              throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err });\n            }\n            request2.referrer = parsedReferrer;\n          }\n        }\n        if (init.referrerPolicy !== void 0) {\n          request2.referrerPolicy = init.referrerPolicy;\n          if (!referrerPolicy.includes(request2.referrerPolicy)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n            );\n          }\n        }\n        let mode;\n        if (init.mode !== void 0) {\n          mode = init.mode;\n          if (!requestMode.includes(mode)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.mode}' is not a valid enum value of type RequestMode.`\n            );\n          }\n        } else {\n          mode = fallbackMode;\n        }\n        if (mode === \"navigate\") {\n          webidl.errors.exception({\n            header: \"Request constructor\",\n            message: \"invalid request mode navigate.\"\n          });\n        }\n        if (mode != null) {\n          request2.mode = mode;\n        }\n        if (init.credentials !== void 0) {\n          request2.credentials = init.credentials;\n          if (!requestCredentials.includes(request2.credentials)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.credentials}' is not a valid enum value of type RequestCredentials.`\n            );\n          }\n        }\n        if (init.cache !== void 0) {\n          request2.cache = init.cache;\n          if (!requestCache.includes(request2.cache)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.cache}' is not a valid enum value of type RequestCache.`\n            );\n          }\n        }\n        if (request2.cache === \"only-if-cached\" && request2.mode !== \"same-origin\") {\n          throw new TypeError(\n            \"'only-if-cached' can be set only with 'same-origin' mode\"\n          );\n        }\n        if (init.redirect !== void 0) {\n          request2.redirect = init.redirect;\n          if (!requestRedirect.includes(request2.redirect)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.redirect}' is not a valid enum value of type RequestRedirect.`\n            );\n          }\n        }\n        if (init.integrity !== void 0 && init.integrity != null) {\n          request2.integrity = String(init.integrity);\n        }\n        if (init.keepalive !== void 0) {\n          request2.keepalive = Boolean(init.keepalive);\n        }\n        if (init.method !== void 0) {\n          let method = init.method;\n          if (!isValidHTTPToken(init.method)) {\n            throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n          }\n          if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n            throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n          }\n          method = normalizeMethod(init.method);\n          request2.method = method;\n        }\n        if (init.signal !== void 0) {\n          signal = init.signal;\n        }\n        this[kState] = request2;\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        this[kSignal][kRealm] = this[kRealm];\n        if (signal != null) {\n          if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n            throw new TypeError(\n              \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n            );\n          }\n          if (signal.aborted) {\n            ac.abort(signal.reason);\n          } else {\n            const abort = /* @__PURE__ */ __name(() => ac.abort(signal.reason), \"abort\");\n            signal.addEventListener(\"abort\", abort, { once: true });\n            requestFinalizer.register(this, { signal, abort });\n          }\n        }\n        this[kHeaders] = new Headers();\n        this[kHeaders][kHeadersList] = request2.headersList;\n        this[kHeaders][kGuard] = \"request\";\n        this[kHeaders][kRealm] = this[kRealm];\n        if (mode === \"no-cors\") {\n          if (!corsSafeListedMethods.includes(request2.method)) {\n            throw new TypeError(\n              `'${request2.method} is unsupported in no-cors mode.`\n            );\n          }\n          this[kHeaders][kGuard] = \"request-no-cors\";\n        }\n        if (Object.keys(init).length !== 0) {\n          let headers = new Headers(this[kHeaders]);\n          if (init.headers !== void 0) {\n            headers = init.headers;\n          }\n          this[kHeaders][kHeadersList].clear();\n          if (headers.constructor.name === \"Headers\") {\n            for (const [key, val] of headers) {\n              this[kHeaders].append(key, val);\n            }\n          } else {\n            fillHeaders(this[kHeaders], headers);\n          }\n        }\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        if ((init.body !== void 0 && init.body != null || inputBody != null) && (request2.method === \"GET\" || request2.method === \"HEAD\")) {\n          throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        let initBody = null;\n        if (init.body !== void 0 && init.body != null) {\n          const [extractedBody, contentType] = extractBody(\n            init.body,\n            request2.keepalive\n          );\n          initBody = extractedBody;\n          if (contentType && !this[kHeaders].has(\"content-type\")) {\n            this[kHeaders].append(\"content-type\", contentType);\n          }\n        }\n        const inputOrInitBody = initBody != null ? initBody : inputBody;\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n          if (request2.mode !== \"same-origin\" && request2.mode !== \"cors\") {\n            throw new TypeError(\n              'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n            );\n          }\n          request2.useCORSPreflightFlag = true;\n        }\n        let finalBody = inputOrInitBody;\n        if (initBody == null && inputBody != null) {\n          if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n            throw new TypeError(\n              \"Cannot construct a Request with a Request object that has already been used.\"\n            );\n          }\n          if (!TransformStream) {\n            TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream);\n          }\n          const identityTransform = new TransformStream();\n          inputBody.stream.pipeThrough(identityTransform);\n          finalBody = {\n            source: inputBody.source,\n            length: inputBody.length,\n            stream: identityTransform.readable\n          };\n        }\n        this[kState].body = finalBody;\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      get method() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].method;\n      }\n      get url() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].url.toString();\n      }\n      get headers() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeaders];\n      }\n      get destination() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].destination;\n      }\n      get referrer() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this[kState].referrer === \"no-referrer\") {\n          return \"\";\n        }\n        if (this[kState].referrer === \"client\") {\n          return \"about:client\";\n        }\n        return this[kState].referrer.toString();\n      }\n      get referrerPolicy() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].referrerPolicy;\n      }\n      get mode() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].mode;\n      }\n      get credentials() {\n        return this[kState].credentials;\n      }\n      get cache() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].cache;\n      }\n      get redirect() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].redirect;\n      }\n      get integrity() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].integrity;\n      }\n      get keepalive() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].keepalive;\n      }\n      get isReloadNavigation() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].reloadNavigation;\n      }\n      get isHistoryNavigation() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].historyNavigation;\n      }\n      get signal() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kSignal];\n      }\n      clone() {\n        var _a3;\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this.bodyUsed || ((_a3 = this.body) == null ? void 0 : _a3.locked)) {\n          throw new TypeError(\"unusable\");\n        }\n        const clonedRequest = cloneRequest(this[kState]);\n        const clonedRequestObject = new Request(kInit);\n        clonedRequestObject[kState] = clonedRequest;\n        clonedRequestObject[kRealm] = this[kRealm];\n        clonedRequestObject[kHeaders] = new Headers();\n        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n          ac.abort(this.signal.reason);\n        } else {\n          this.signal.addEventListener(\n            \"abort\",\n            () => {\n              ac.abort(this.signal.reason);\n            },\n            { once: true }\n          );\n        }\n        clonedRequestObject[kSignal] = ac.signal;\n        return clonedRequestObject;\n      }\n    };\n    __name(Request, \"Request\");\n    mixinBody(Request);\n    function makeRequest(init) {\n      const request2 = {\n        method: \"GET\",\n        localURLsOnly: false,\n        unsafeRequest: false,\n        body: null,\n        client: null,\n        reservedClient: null,\n        replacesClientId: \"\",\n        window: \"client\",\n        keepalive: false,\n        serviceWorkers: \"all\",\n        initiator: \"\",\n        destination: \"\",\n        priority: null,\n        origin: \"client\",\n        policyContainer: \"client\",\n        referrer: \"client\",\n        referrerPolicy: \"\",\n        mode: \"no-cors\",\n        useCORSPreflightFlag: false,\n        credentials: \"same-origin\",\n        useCredentials: false,\n        cache: \"default\",\n        redirect: \"follow\",\n        integrity: \"\",\n        cryptoGraphicsNonceMetadata: \"\",\n        parserMetadata: \"\",\n        reloadNavigation: false,\n        historyNavigation: false,\n        userActivation: false,\n        taintedOrigin: false,\n        redirectCount: 0,\n        responseTainting: \"basic\",\n        preventNoCacheCacheControlHeaderModification: false,\n        done: false,\n        timingAllowFailed: false,\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n      };\n      request2.url = request2.urlList[0];\n      return request2;\n    }\n    __name(makeRequest, \"makeRequest\");\n    function cloneRequest(request2) {\n      const newRequest = makeRequest({ ...request2, body: null });\n      if (request2.body != null) {\n        newRequest.body = cloneBody(request2.body);\n      }\n      return newRequest;\n    }\n    __name(cloneRequest, \"cloneRequest\");\n    Object.defineProperties(Request.prototype, {\n      method: kEnumerableProperty,\n      url: kEnumerableProperty,\n      headers: kEnumerableProperty,\n      redirect: kEnumerableProperty,\n      clone: kEnumerableProperty,\n      signal: kEnumerableProperty\n    });\n    webidl.converters.Request = webidl.interfaceConverter(\n      Request\n    );\n    webidl.converters.RequestInfo = function(V) {\n      if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n      }\n      if (V instanceof Request) {\n        return webidl.converters.Request(V);\n      }\n      return webidl.converters.USVString(V);\n    };\n    webidl.converters.AbortSignal = webidl.interfaceConverter(\n      AbortSignal\n    );\n    webidl.converters.RequestInit = webidl.dictionaryConverter([\n      {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n      },\n      {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n      },\n      {\n        key: \"body\",\n        converter: webidl.nullableConverter(\n          webidl.converters.BodyInit\n        )\n      },\n      {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n      },\n      {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"\",\n          \"no-referrer\",\n          \"no-referrer-when-downgrade\",\n          \"same-origin\",\n          \"origin\",\n          \"strict-origin\",\n          \"origin-when-cross-origin\",\n          \"strict-origin-when-cross-origin\",\n          \"unsafe-url\"\n        ]\n      },\n      {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"same-origin\",\n          \"cors\",\n          \"no-cors\",\n          \"navigate\",\n          \"websocket\"\n        ]\n      },\n      {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"omit\",\n          \"same-origin\",\n          \"include\"\n        ]\n      },\n      {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"default\",\n          \"no-store\",\n          \"reload\",\n          \"no-cache\",\n          \"force-cache\",\n          \"only-if-cached\"\n        ]\n      },\n      {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"follow\",\n          \"error\",\n          \"manual\"\n        ]\n      },\n      {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n      },\n      {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n      },\n      {\n        key: \"signal\",\n        converter: webidl.nullableConverter(\n          (signal) => webidl.converters.AbortSignal(\n            signal,\n            { strict: false }\n          )\n        )\n      },\n      {\n        key: \"window\",\n        converter: webidl.converters.any\n      }\n    ]);\n    module2.exports = { Request, makeRequest };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/dataURL.js\nvar require_dataURL = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/dataURL.js\"(exports, module2) {\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { atob: atob2 } = __webpack_require__(/*! buffer */ \"buffer\");\n    var encoder = new TextEncoder();\n    function dataURLProcessor(dataURL) {\n      assert(dataURL.protocol === \"data:\");\n      let input = URLSerializer(dataURL, true);\n      input = input.slice(5);\n      const position = { position: 0 };\n      let mimeType = collectASequenceOfCodePoints(\n        (char) => char !== \",\",\n        input,\n        position\n      );\n      const mimeTypeLength = mimeType.length;\n      mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, \"\");\n      if (position.position >= input.length) {\n        return \"failure\";\n      }\n      position.position++;\n      const encodedBody = input.slice(mimeTypeLength + 1);\n      let body = stringPercentDecode(encodedBody);\n      if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        const stringBody = decodeURIComponent(new TextDecoder(\"utf-8\").decode(body));\n        body = forgivingBase64(stringBody);\n        if (body === \"failure\") {\n          return \"failure\";\n        }\n        mimeType = mimeType.slice(0, -6);\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        mimeType = mimeType.slice(0, -1);\n      }\n      if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n      }\n      let mimeTypeRecord = parseMIMEType(mimeType);\n      if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n      }\n      return { mimeType: mimeTypeRecord, body };\n    }\n    __name(dataURLProcessor, \"dataURLProcessor\");\n    function URLSerializer(url, excludeFragment = false) {\n      let output = url.protocol;\n      if (url.host.length > 0) {\n        output += \"//\";\n        if (url.username.length > 0 || url.password.length > 0) {\n          output += url.username;\n          if (url.password.length > 0) {\n            output += \":\" + url.password;\n          }\n          output += \"@\";\n        }\n        output += decodeURIComponent(url.host);\n        if (url.port.length > 0) {\n          output += \":\" + url.port;\n        }\n      }\n      if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === \".\") {\n        output += \"/.\";\n      }\n      output += url.pathname;\n      if (url.search.length > 0) {\n        output += url.search;\n      }\n      if (excludeFragment === false && url.hash.length > 0) {\n        output += url.hash;\n      }\n      return output;\n    }\n    __name(URLSerializer, \"URLSerializer\");\n    function collectASequenceOfCodePoints(condition, input, position) {\n      let result = \"\";\n      while (position.position < input.length && condition(input[position.position])) {\n        result += input[position.position];\n        position.position++;\n      }\n      return result;\n    }\n    __name(collectASequenceOfCodePoints, \"collectASequenceOfCodePoints\");\n    function stringPercentDecode(input) {\n      const bytes = encoder.encode(input);\n      return percentDecode(bytes);\n    }\n    __name(stringPercentDecode, \"stringPercentDecode\");\n    function percentDecode(input) {\n      const output = [];\n      for (let i = 0; i < input.length; i++) {\n        const byte = input[i];\n        if (byte !== 37) {\n          output.push(byte);\n        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n          output.push(37);\n        } else {\n          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n          const bytePoint = Number.parseInt(nextTwoBytes, 16);\n          output.push(bytePoint);\n          i += 2;\n        }\n      }\n      return Uint8Array.from(output);\n    }\n    __name(percentDecode, \"percentDecode\");\n    function parseMIMEType(input) {\n      input = input.trim();\n      const position = { position: 0 };\n      const type = collectASequenceOfCodePoints(\n        (char) => char !== \"/\",\n        input,\n        position\n      );\n      if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n        return \"failure\";\n      }\n      if (position.position > input.length) {\n        return \"failure\";\n      }\n      position.position++;\n      let subtype = collectASequenceOfCodePoints(\n        (char) => char !== \";\",\n        input,\n        position\n      );\n      subtype = subtype.trim();\n      if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n        return \"failure\";\n      }\n      const mimeType = {\n        type: type.toLowerCase(),\n        subtype: subtype.toLowerCase(),\n        parameters: /* @__PURE__ */ new Map()\n      };\n      while (position.position < input.length) {\n        position.position++;\n        collectASequenceOfCodePoints(\n          (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n          input,\n          position\n        );\n        let parameterName = collectASequenceOfCodePoints(\n          (char) => char !== \";\" && char !== \"=\",\n          input,\n          position\n        );\n        parameterName = parameterName.toLowerCase();\n        if (position.position < input.length) {\n          if (input[position.position] === \";\") {\n            continue;\n          }\n          position.position++;\n        }\n        if (position.position > input.length) {\n          break;\n        }\n        let parameterValue = null;\n        if (input[position.position] === '\"') {\n          parameterValue = collectAnHTTPQuotedString(input, position);\n          collectASequenceOfCodePoints(\n            (char) => char !== \";\",\n            input,\n            position\n          );\n        } else {\n          parameterValue = collectASequenceOfCodePoints(\n            (char) => char !== \";\",\n            input,\n            position\n          );\n          parameterValue = parameterValue.trim();\n          if (parameterValue.length === 0) {\n            continue;\n          }\n        }\n        if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {\n          mimeType.parameters.set(parameterName, parameterValue);\n        }\n      }\n      return mimeType;\n    }\n    __name(parseMIMEType, \"parseMIMEType\");\n    function forgivingBase64(data) {\n      data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, \"\");\n      if (data.length % 4 === 0) {\n        data = data.replace(/=?=$/, \"\");\n      }\n      if (data.length % 4 === 1) {\n        return \"failure\";\n      }\n      if (/[^+/0-9A-Za-z]/.test(data)) {\n        return \"failure\";\n      }\n      const binary = atob2(data);\n      const bytes = new Uint8Array(binary.length);\n      for (let byte = 0; byte < binary.length; byte++) {\n        bytes[byte] = binary.charCodeAt(byte);\n      }\n      return bytes;\n    }\n    __name(forgivingBase64, \"forgivingBase64\");\n    function collectAnHTTPQuotedString(input, position, extractValue) {\n      const positionStart = position.position;\n      let value = \"\";\n      assert(input[position.position] === '\"');\n      position.position++;\n      while (true) {\n        value += collectASequenceOfCodePoints(\n          (char) => char !== '\"' && char !== \"\\\\\",\n          input,\n          position\n        );\n        if (position.position >= input.length) {\n          break;\n        }\n        const quoteOrBackslash = input[position.position];\n        position.position++;\n        if (quoteOrBackslash === \"\\\\\") {\n          if (position.position >= input.length) {\n            value += \"\\\\\";\n            break;\n          }\n          value += input[position.position];\n          position.position++;\n        } else {\n          assert(quoteOrBackslash === '\"');\n          break;\n        }\n      }\n      if (extractValue) {\n        return value;\n      }\n      return input.slice(positionStart, position.position);\n    }\n    __name(collectAnHTTPQuotedString, \"collectAnHTTPQuotedString\");\n    module2.exports = {\n      dataURLProcessor,\n      URLSerializer,\n      collectASequenceOfCodePoints,\n      stringPercentDecode,\n      parseMIMEType,\n      collectAnHTTPQuotedString\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/index.js\nvar require_fetch = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/index.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      Response,\n      makeNetworkError,\n      makeAppropriateNetworkError,\n      filterResponse,\n      makeResponse\n    } = require_response();\n    var { Headers } = require_headers();\n    var { Request, makeRequest } = require_request2();\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    var {\n      bytesMatch,\n      makePolicyContainer,\n      clonePolicyContainer,\n      requestBadPort,\n      TAOCheck,\n      appendRequestOriginHeader,\n      responseLocationURL,\n      requestCurrentURL,\n      setRequestReferrerPolicyOnRedirect,\n      tryUpgradeRequestToAPotentiallyTrustworthyURL,\n      createOpaqueTimingInfo,\n      appendFetchMetadata,\n      corsCheck,\n      crossOriginResourcePolicyCheck,\n      determineRequestsReferrer,\n      coarsenedSharedCurrentTime,\n      createDeferredPromise,\n      isBlobLike,\n      sameOrigin,\n      isCancelled,\n      isAborted,\n      isErrorLike,\n      fullyReadBody\n    } = require_util3();\n    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { safelyExtractBody, extractBody } = require_body();\n    var {\n      redirectStatus,\n      nullBodyStatus,\n      safeMethods,\n      requestBodyHeader,\n      subresource,\n      DOMException\n    } = require_constants();\n    var { kHeadersList } = require_symbols();\n    var EE = __webpack_require__(/*! events */ \"events\");\n    var { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\");\n    var { isErrored, isReadable } = require_util2();\n    var { dataURLProcessor } = require_dataURL();\n    var { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\n    var resolveObjectURL;\n    var ReadableStream;\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    var Fetch = class extends EE {\n      constructor(dispatcher) {\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n      }\n      terminate(reason) {\n        var _a3;\n        if (this.state !== \"ongoing\") {\n          return;\n        }\n        this.state = \"terminated\";\n        (_a3 = this.connection) == null ? void 0 : _a3.destroy(reason);\n        this.emit(\"terminated\", reason);\n      }\n      abort() {\n        var _a3;\n        if (this.state !== \"ongoing\") {\n          return;\n        }\n        const reason = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        this.state = \"aborted\";\n        (_a3 = this.connection) == null ? void 0 : _a3.destroy(reason);\n        this.emit(\"terminated\", reason);\n      }\n    };\n    __name(Fetch, \"Fetch\");\n    async function fetch2(input, init = {}) {\n      var _a3;\n      if (arguments.length < 1) {\n        throw new TypeError(\n          `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`\n        );\n      }\n      const p = createDeferredPromise();\n      let requestObject;\n      try {\n        requestObject = new Request(input, init);\n      } catch (e) {\n        p.reject(e);\n        return p.promise;\n      }\n      const request2 = requestObject[kState];\n      if (requestObject.signal.aborted) {\n        abortFetch(p, request2, null);\n        return p.promise;\n      }\n      const globalObject = request2.client.globalObject;\n      if (((_a3 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a3.name) === \"ServiceWorkerGlobalScope\") {\n        request2.serviceWorkers = \"none\";\n      }\n      let responseObject = null;\n      const relevantRealm = null;\n      let locallyAborted = false;\n      let controller = null;\n      requestObject.signal.addEventListener(\n        \"abort\",\n        () => {\n          locallyAborted = true;\n          abortFetch(p, request2, responseObject);\n          if (controller != null) {\n            controller.abort();\n          }\n        },\n        { once: true }\n      );\n      const handleFetchDone = /* @__PURE__ */ __name((response) => finalizeAndReportTiming(response, \"fetch\"), \"handleFetchDone\");\n      const processResponse = /* @__PURE__ */ __name((response) => {\n        if (locallyAborted) {\n          return;\n        }\n        if (response.aborted) {\n          abortFetch(p, request2, responseObject);\n          return;\n        }\n        if (response.type === \"error\") {\n          p.reject(\n            Object.assign(new TypeError(\"fetch failed\"), { cause: response.error })\n          );\n          return;\n        }\n        responseObject = new Response();\n        responseObject[kState] = response;\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = response.headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        p.resolve(responseObject);\n      }, \"processResponse\");\n      controller = fetching({\n        request: request2,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: this\n      });\n      return p.promise;\n    }\n    __name(fetch2, \"fetch\");\n    function finalizeAndReportTiming(response, initiatorType = \"other\") {\n      var _a3;\n      if (response.type === \"error\" && response.aborted) {\n        return;\n      }\n      if (!((_a3 = response.urlList) == null ? void 0 : _a3.length)) {\n        return;\n      }\n      const originalURL = response.urlList[0];\n      let timingInfo = response.timingInfo;\n      let cacheState = response.cacheState;\n      if (!/^https?:/.test(originalURL.protocol)) {\n        return;\n      }\n      if (timingInfo === null) {\n        return;\n      }\n      if (!timingInfo.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo({\n          startTime: timingInfo.startTime\n        });\n        cacheState = \"\";\n      }\n      response.timingInfo.endTime = coarsenedSharedCurrentTime();\n      response.timingInfo = timingInfo;\n      markResourceTiming(\n        timingInfo,\n        originalURL,\n        initiatorType,\n        globalThis,\n        cacheState\n      );\n    }\n    __name(finalizeAndReportTiming, \"finalizeAndReportTiming\");\n    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {\n      if (nodeMajor >= 18 && nodeMinor >= 2) {\n        performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);\n      }\n    }\n    __name(markResourceTiming, \"markResourceTiming\");\n    function abortFetch(p, request2, responseObject) {\n      var _a3, _b2;\n      const error2 = new DOMException(\"The operation was aborted.\", \"AbortError\");\n      p.reject(error2);\n      if (request2.body != null && isReadable((_a3 = request2.body) == null ? void 0 : _a3.stream)) {\n        request2.body.stream.cancel(error2).catch((err) => {\n          if (err.code === \"ERR_INVALID_STATE\") {\n            return;\n          }\n          throw err;\n        });\n      }\n      if (responseObject == null) {\n        return;\n      }\n      const response = responseObject[kState];\n      if (response.body != null && isReadable((_b2 = response.body) == null ? void 0 : _b2.stream)) {\n        response.body.stream.cancel(error2).catch((err) => {\n          if (err.code === \"ERR_INVALID_STATE\") {\n            return;\n          }\n          throw err;\n        });\n      }\n    }\n    __name(abortFetch, \"abortFetch\");\n    function fetching({\n      request: request2,\n      processRequestBodyChunkLength,\n      processRequestEndOfBody,\n      processResponse,\n      processResponseEndOfBody,\n      processResponseConsumeBody,\n      useParallelQueue = false,\n      dispatcher\n    }) {\n      var _a3, _b2, _c, _d;\n      let taskDestination = null;\n      let crossOriginIsolatedCapability = false;\n      if (request2.client != null) {\n        taskDestination = request2.client.globalObject;\n        crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;\n      }\n      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n      const timingInfo = createOpaqueTimingInfo({\n        startTime: currenTime\n      });\n      const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request: request2,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n      };\n      assert(!request2.body || request2.body.stream);\n      if (request2.window === \"client\") {\n        request2.window = ((_c = (_b2 = (_a3 = request2.client) == null ? void 0 : _a3.globalObject) == null ? void 0 : _b2.constructor) == null ? void 0 : _c.name) === \"Window\" ? request2.client : \"no-window\";\n      }\n      if (request2.origin === \"client\") {\n        request2.origin = (_d = request2.client) == null ? void 0 : _d.origin;\n      }\n      if (request2.policyContainer === \"client\") {\n        if (request2.client != null) {\n          request2.policyContainer = clonePolicyContainer(\n            request2.client.policyContainer\n          );\n        } else {\n          request2.policyContainer = makePolicyContainer();\n        }\n      }\n      if (!request2.headersList.has(\"accept\")) {\n        const value = \"*/*\";\n        request2.headersList.append(\"accept\", value);\n      }\n      if (!request2.headersList.has(\"accept-language\")) {\n        request2.headersList.append(\"accept-language\", \"*\");\n      }\n      if (request2.priority === null) {\n      }\n      if (subresource.includes(request2.destination)) {\n      }\n      mainFetch(fetchParams).catch((err) => {\n        fetchParams.controller.terminate(err);\n      });\n      return fetchParams.controller;\n    }\n    __name(fetching, \"fetching\");\n    async function mainFetch(fetchParams, recursive = false) {\n      const request2 = fetchParams.request;\n      let response = null;\n      if (request2.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request2).protocol)) {\n        response = makeNetworkError(\"local URLs only\");\n      }\n      tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);\n      if (requestBadPort(request2) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n      }\n      if (request2.referrerPolicy === \"\") {\n        request2.referrerPolicy = request2.policyContainer.referrerPolicy;\n      }\n      if (request2.referrer !== \"no-referrer\") {\n        request2.referrer = determineRequestsReferrer(request2);\n      }\n      if (response === null) {\n        response = await (async () => {\n          const currentURL = requestCurrentURL(request2);\n          if (sameOrigin(currentURL, request2.url) && request2.responseTainting === \"basic\" || currentURL.protocol === \"data:\" || (request2.mode === \"navigate\" || request2.mode === \"websocket\")) {\n            request2.responseTainting = \"basic\";\n            return await schemeFetch(fetchParams);\n          }\n          if (request2.mode === \"same-origin\") {\n            return makeNetworkError('request mode cannot be \"same-origin\"');\n          }\n          if (request2.mode === \"no-cors\") {\n            if (request2.redirect !== \"follow\") {\n              return makeNetworkError(\n                'redirect mode cannot be \"follow\" for \"no-cors\" request'\n              );\n            }\n            request2.responseTainting = \"opaque\";\n            return await schemeFetch(fetchParams);\n          }\n          if (!/^https?:/.test(requestCurrentURL(request2).protocol)) {\n            return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n          }\n          request2.responseTainting = \"cors\";\n          return await httpFetch(fetchParams);\n        })();\n      }\n      if (recursive) {\n        return response;\n      }\n      if (response.status !== 0 && !response.internalResponse) {\n        if (request2.responseTainting === \"cors\") {\n        }\n        if (request2.responseTainting === \"basic\") {\n          response = filterResponse(response, \"basic\");\n        } else if (request2.responseTainting === \"cors\") {\n          response = filterResponse(response, \"cors\");\n        } else if (request2.responseTainting === \"opaque\") {\n          response = filterResponse(response, \"opaque\");\n        } else {\n          assert(false);\n        }\n      }\n      let internalResponse = response.status === 0 ? response : response.internalResponse;\n      if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request2.urlList);\n      }\n      if (!request2.timingAllowFailed) {\n        response.timingAllowPassed = true;\n      }\n      if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.has(\"range\")) {\n        response = internalResponse = makeNetworkError();\n      }\n      if (response.status !== 0 && (request2.method === \"HEAD\" || request2.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n      }\n      if (request2.integrity) {\n        const processBodyError = /* @__PURE__ */ __name((reason) => fetchFinale(fetchParams, makeNetworkError(reason)), \"processBodyError\");\n        if (request2.responseTainting === \"opaque\" || response.body == null) {\n          processBodyError(response.error);\n          return;\n        }\n        const processBody = /* @__PURE__ */ __name((bytes) => {\n          if (!bytesMatch(bytes, request2.integrity)) {\n            processBodyError(\"integrity mismatch\");\n            return;\n          }\n          response.body = safelyExtractBody(bytes)[0];\n          fetchFinale(fetchParams, response);\n        }, \"processBody\");\n        await fullyReadBody(response.body, processBody, processBodyError);\n      } else {\n        fetchFinale(fetchParams, response);\n      }\n    }\n    __name(mainFetch, \"mainFetch\");\n    async function schemeFetch(fetchParams) {\n      const { request: request2 } = fetchParams;\n      const {\n        protocol: scheme,\n        pathname: path7\n      } = requestCurrentURL(request2);\n      switch (scheme) {\n        case \"about:\": {\n          if (path7 === \"blank\") {\n            const resp = makeResponse({\n              statusText: \"OK\",\n              headersList: [\n                [\"content-type\", \"text/html;charset=utf-8\"]\n              ]\n            });\n            resp.urlList = [new URL(\"about:blank\")];\n            return resp;\n          }\n          return makeNetworkError(\"invalid path called\");\n        }\n        case \"blob:\": {\n          resolveObjectURL = resolveObjectURL || (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL);\n          const currentURL = requestCurrentURL(request2);\n          if (currentURL.search.length !== 0) {\n            return makeNetworkError(\"NetworkError when attempting to fetch resource.\");\n          }\n          const blob = resolveObjectURL(currentURL.toString());\n          if (request2.method !== \"GET\" || !isBlobLike(blob)) {\n            return makeNetworkError(\"invalid method\");\n          }\n          const response = makeResponse({ statusText: \"OK\", urlList: [currentURL] });\n          response.headersList.set(\"content-length\", `${blob.size}`);\n          response.headersList.set(\"content-type\", blob.type);\n          response.body = extractBody(blob)[0];\n          return response;\n        }\n        case \"data:\": {\n          const currentURL = requestCurrentURL(request2);\n          const dataURLStruct = dataURLProcessor(currentURL);\n          if (dataURLStruct === \"failure\") {\n            return makeNetworkError(\"failed to fetch the data URL\");\n          }\n          const { mimeType } = dataURLStruct;\n          let contentType = `${mimeType.type}/${mimeType.subtype}`;\n          const contentTypeParams = [];\n          if (mimeType.parameters.size > 0) {\n            contentType += \";\";\n          }\n          for (const [key, value] of mimeType.parameters) {\n            if (value.length > 0) {\n              contentTypeParams.push(`${key}=${value}`);\n            } else {\n              contentTypeParams.push(key);\n            }\n          }\n          contentType += contentTypeParams.join(\",\");\n          return makeResponse({\n            statusText: \"OK\",\n            headersList: [\n              [\"content-type\", contentType]\n            ],\n            body: extractBody(dataURLStruct.body)[0]\n          });\n        }\n        case \"file:\": {\n          return makeNetworkError(\"not implemented... yet...\");\n        }\n        case \"http:\":\n        case \"https:\": {\n          return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));\n        }\n        default: {\n          return makeNetworkError(\"unknown scheme\");\n        }\n      }\n    }\n    __name(schemeFetch, \"schemeFetch\");\n    function finalizeResponse(fetchParams, response) {\n      fetchParams.request.done = true;\n      if (fetchParams.processResponseDone != null) {\n        queueMicrotask(() => fetchParams.processResponseDone(response));\n      }\n    }\n    __name(finalizeResponse, \"finalizeResponse\");\n    async function fetchFinale(fetchParams, response) {\n      if (response.type === \"error\") {\n        response.urlList = [fetchParams.request.urlList[0]];\n        response.timingInfo = createOpaqueTimingInfo({\n          startTime: fetchParams.timingInfo.startTime\n        });\n      }\n      const processResponseEndOfBody = /* @__PURE__ */ __name(() => {\n        fetchParams.request.done = true;\n        if (fetchParams.processResponseEndOfBody != null) {\n          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));\n        }\n      }, \"processResponseEndOfBody\");\n      if (fetchParams.processResponse != null) {\n        queueMicrotask(() => fetchParams.processResponse(response));\n      }\n      if (response.body == null) {\n        processResponseEndOfBody();\n      } else {\n        const identityTransformAlgorithm = /* @__PURE__ */ __name((chunk, controller) => {\n          controller.enqueue(chunk);\n        }, \"identityTransformAlgorithm\");\n        const transformStream = new TransformStream({\n          start() {\n          },\n          transform: identityTransformAlgorithm,\n          flush: processResponseEndOfBody\n        });\n        response.body = { stream: response.body.stream.pipeThrough(transformStream) };\n      }\n      if (fetchParams.processResponseConsumeBody != null) {\n        const processBody = /* @__PURE__ */ __name((nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), \"processBody\");\n        const processBodyError = /* @__PURE__ */ __name((failure) => fetchParams.processResponseConsumeBody(response, failure), \"processBodyError\");\n        if (response.body == null) {\n          queueMicrotask(() => processBody(null));\n        } else {\n          await fullyReadBody(response.body, processBody, processBodyError);\n        }\n      }\n    }\n    __name(fetchFinale, \"fetchFinale\");\n    async function httpFetch(fetchParams) {\n      const request2 = fetchParams.request;\n      let response = null;\n      let actualResponse = null;\n      const timingInfo = fetchParams.timingInfo;\n      if (request2.serviceWorkers === \"all\") {\n      }\n      if (response === null) {\n        if (request2.redirect === \"follow\") {\n          request2.serviceWorkers = \"none\";\n        }\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        if (request2.responseTainting === \"cors\" && corsCheck(request2, response) === \"failure\") {\n          return makeNetworkError(\"cors failure\");\n        }\n        if (TAOCheck(request2, response) === \"failure\") {\n          request2.timingAllowFailed = true;\n        }\n      }\n      if ((request2.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(\n        request2.origin,\n        request2.client,\n        request2.destination,\n        actualResponse\n      ) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n      }\n      if (redirectStatus.includes(actualResponse.status)) {\n        fetchParams.controller.connection.destroy();\n        if (request2.redirect === \"error\") {\n          response = makeNetworkError(\"unexpected redirect\");\n        } else if (request2.redirect === \"manual\") {\n          response = actualResponse;\n        } else if (request2.redirect === \"follow\") {\n          response = await httpRedirectFetch(fetchParams, response);\n        } else {\n          assert(false);\n        }\n      }\n      response.timingInfo = timingInfo;\n      return response;\n    }\n    __name(httpFetch, \"httpFetch\");\n    async function httpRedirectFetch(fetchParams, response) {\n      const request2 = fetchParams.request;\n      const actualResponse = response.internalResponse ? response.internalResponse : response;\n      let locationURL;\n      try {\n        locationURL = responseLocationURL(\n          actualResponse,\n          requestCurrentURL(request2).hash\n        );\n        if (locationURL == null) {\n          return response;\n        }\n      } catch (err) {\n        return makeNetworkError(err);\n      }\n      if (!/^https?:/.test(locationURL.protocol)) {\n        return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n      }\n      if (request2.redirectCount === 20) {\n        return makeNetworkError(\"redirect count exceeded\");\n      }\n      request2.redirectCount += 1;\n      if (request2.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {\n        return makeNetworkError('cross origin not allowed for request mode \"cors\"');\n      }\n      if (request2.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return makeNetworkError(\n          'URL cannot contain credentials for request mode \"cors\"'\n        );\n      }\n      if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {\n        return makeNetworkError();\n      }\n      if ([301, 302].includes(actualResponse.status) && request2.method === \"POST\" || actualResponse.status === 303 && ![\"GET\", \"HEAD\"].includes(request2.method)) {\n        request2.method = \"GET\";\n        request2.body = null;\n        for (const headerName of requestBodyHeader) {\n          request2.headersList.delete(headerName);\n        }\n      }\n      if (request2.body != null) {\n        assert(request2.body.source);\n        request2.body = safelyExtractBody(request2.body.source)[0];\n      }\n      const timingInfo = fetchParams.timingInfo;\n      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n      if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n      }\n      request2.urlList.push(locationURL);\n      setRequestReferrerPolicyOnRedirect(request2, actualResponse);\n      return mainFetch(fetchParams, true);\n    }\n    __name(httpRedirectFetch, \"httpRedirectFetch\");\n    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n      const request2 = fetchParams.request;\n      let httpFetchParams = null;\n      let httpRequest = null;\n      let response = null;\n      const httpCache = null;\n      const revalidatingFlag = false;\n      if (request2.window === \"no-window\" && request2.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request2;\n      } else {\n        httpRequest = makeRequest(request2);\n        httpFetchParams = { ...fetchParams };\n        httpFetchParams.request = httpRequest;\n      }\n      const includeCredentials = request2.credentials === \"include\" || request2.credentials === \"same-origin\" && request2.responseTainting === \"basic\";\n      const contentLength = httpRequest.body ? httpRequest.body.length : null;\n      let contentLengthHeaderValue = null;\n      if (httpRequest.body == null && [\"POST\", \"PUT\"].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n      }\n      if (contentLength != null) {\n        contentLengthHeaderValue = String(contentLength);\n      }\n      if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue);\n      }\n      if (contentLength != null && httpRequest.keepalive) {\n      }\n      if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", httpRequest.referrer.href);\n      }\n      appendRequestOriginHeader(httpRequest);\n      appendFetchMetadata(httpRequest);\n      if (!httpRequest.headersList.has(\"user-agent\")) {\n        httpRequest.headersList.append(\"user-agent\", \"undici\");\n      }\n      if (httpRequest.cache === \"default\" && (httpRequest.headersList.has(\"if-modified-since\") || httpRequest.headersList.has(\"if-none-match\") || httpRequest.headersList.has(\"if-unmodified-since\") || httpRequest.headersList.has(\"if-match\") || httpRequest.headersList.has(\"if-range\"))) {\n        httpRequest.cache = \"no-store\";\n      }\n      if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has(\"cache-control\")) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\");\n      }\n      if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        if (!httpRequest.headersList.has(\"pragma\")) {\n          httpRequest.headersList.append(\"pragma\", \"no-cache\");\n        }\n        if (!httpRequest.headersList.has(\"cache-control\")) {\n          httpRequest.headersList.append(\"cache-control\", \"no-cache\");\n        }\n      }\n      if (httpRequest.headersList.has(\"range\")) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\");\n      }\n      if (!httpRequest.headersList.has(\"accept-encoding\")) {\n        if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n          httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\");\n        } else {\n          httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\");\n        }\n      }\n      if (includeCredentials) {\n      }\n      if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n      }\n      if (httpRequest.mode !== \"no-store\" && httpRequest.mode !== \"reload\") {\n      }\n      if (response == null) {\n        if (httpRequest.mode === \"only-if-cached\") {\n          return makeNetworkError(\"only if cached\");\n        }\n        const forwardResponse = await httpNetworkFetch(\n          httpFetchParams,\n          includeCredentials,\n          isNewConnectionFetch\n        );\n        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        }\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        }\n        if (response == null) {\n          response = forwardResponse;\n        }\n      }\n      response.urlList = [...httpRequest.urlList];\n      if (httpRequest.headersList.has(\"range\")) {\n        response.rangeRequested = true;\n      }\n      response.requestIncludesCredentials = includeCredentials;\n      if (response.status === 407) {\n        if (request2.window === \"no-window\") {\n          return makeNetworkError();\n        }\n        if (isCancelled(fetchParams)) {\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        return makeNetworkError(\"proxy authentication required\");\n      }\n      if (response.status === 421 && !isNewConnectionFetch && (request2.body == null || request2.body.source != null)) {\n        if (isCancelled(fetchParams)) {\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(\n          fetchParams,\n          isAuthenticationFetch,\n          true\n        );\n      }\n      if (isAuthenticationFetch) {\n      }\n      return response;\n    }\n    __name(httpNetworkOrCacheFetch, \"httpNetworkOrCacheFetch\");\n    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n      fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy(err) {\n          var _a3;\n          if (!this.destroyed) {\n            this.destroyed = true;\n            (_a3 = this.abort) == null ? void 0 : _a3.call(this, err != null ? err : new DOMException(\"The operation was aborted.\", \"AbortError\"));\n          }\n        }\n      };\n      const request2 = fetchParams.request;\n      let response = null;\n      const timingInfo = fetchParams.timingInfo;\n      const httpCache = null;\n      if (httpCache == null) {\n        request2.cache = \"no-store\";\n      }\n      const newConnection = forceNewConnection ? \"yes\" : \"no\";\n      if (request2.mode === \"websocket\") {\n      } else {\n      }\n      let requestBody = null;\n      if (request2.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(() => fetchParams.processRequestEndOfBody());\n      } else if (request2.body != null) {\n        const processBodyChunk = /* @__PURE__ */ __name(async function* (bytes) {\n          var _a3;\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          yield bytes;\n          (_a3 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a3.call(fetchParams, bytes.byteLength);\n        }, \"processBodyChunk\");\n        const processEndOfBody = /* @__PURE__ */ __name(() => {\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          if (fetchParams.processRequestEndOfBody) {\n            fetchParams.processRequestEndOfBody();\n          }\n        }, \"processEndOfBody\");\n        const processBodyError = /* @__PURE__ */ __name((e) => {\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          if (e.name === \"AbortError\") {\n            fetchParams.controller.abort();\n          } else {\n            fetchParams.controller.terminate(e);\n          }\n        }, \"processBodyError\");\n        requestBody = async function* () {\n          try {\n            for await (const bytes of request2.body.stream) {\n              yield* processBodyChunk(bytes);\n            }\n            processEndOfBody();\n          } catch (err) {\n            processBodyError(err);\n          }\n        }();\n      }\n      try {\n        const { body, status, statusText, headersList } = await dispatch({ body: requestBody });\n        const iterator = body[Symbol.asyncIterator]();\n        fetchParams.controller.next = () => iterator.next();\n        response = makeResponse({ status, statusText, headersList });\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          fetchParams.controller.connection.destroy();\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        return makeNetworkError(err);\n      }\n      const pullAlgorithm = /* @__PURE__ */ __name(() => {\n        fetchParams.controller.resume();\n      }, \"pullAlgorithm\");\n      const cancelAlgorithm = /* @__PURE__ */ __name(() => {\n        fetchParams.controller.abort();\n      }, \"cancelAlgorithm\");\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      const stream2 = new ReadableStream(\n        {\n          async start(controller) {\n            fetchParams.controller.controller = controller;\n          },\n          async pull(controller) {\n            await pullAlgorithm(controller);\n          },\n          async cancel(reason) {\n            await cancelAlgorithm(reason);\n          }\n        },\n        { highWaterMark: 0 }\n      );\n      response.body = { stream: stream2 };\n      fetchParams.controller.on(\"terminated\", onAborted);\n      fetchParams.controller.resume = async () => {\n        var _a3;\n        while (true) {\n          let bytes;\n          try {\n            const { done, value } = await fetchParams.controller.next();\n            if (isAborted(fetchParams)) {\n              break;\n            }\n            bytes = done ? void 0 : value;\n          } catch (err) {\n            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n              bytes = void 0;\n            } else {\n              bytes = err;\n            }\n          }\n          if (bytes === void 0) {\n            try {\n              fetchParams.controller.controller.close();\n            } catch (err) {\n              if (!/Controller is already closed/.test(err)) {\n                throw err;\n              }\n            }\n            finalizeResponse(fetchParams, response);\n            return;\n          }\n          timingInfo.decodedBodySize += (_a3 = bytes == null ? void 0 : bytes.byteLength) != null ? _a3 : 0;\n          if (isErrorLike(bytes)) {\n            fetchParams.controller.terminate(bytes);\n            return;\n          }\n          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n          if (isErrored(stream2)) {\n            fetchParams.controller.terminate();\n            return;\n          }\n          if (!fetchParams.controller.controller.desiredSize) {\n            return;\n          }\n        }\n      };\n      function onAborted(reason) {\n        if (isAborted(fetchParams)) {\n          response.aborted = true;\n          if (isReadable(stream2)) {\n            fetchParams.controller.controller.error(\n              new DOMException(\"The operation was aborted.\", \"AbortError\")\n            );\n          }\n        } else {\n          if (isReadable(stream2)) {\n            fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n              cause: isErrorLike(reason) ? reason : void 0\n            }));\n          }\n        }\n        fetchParams.controller.connection.destroy();\n      }\n      __name(onAborted, \"onAborted\");\n      return response;\n      async function dispatch({ body }) {\n        const url = requestCurrentURL(request2);\n        return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(\n          {\n            path: url.pathname + url.search,\n            origin: url.origin,\n            method: request2.method,\n            body: fetchParams.controller.dispatcher.isMockActive ? request2.body && request2.body.source : body,\n            headers: [...request2.headersList].flat(),\n            maxRedirections: 0,\n            bodyTimeout: 3e5,\n            headersTimeout: 3e5\n          },\n          {\n            body: null,\n            abort: null,\n            onConnect(abort) {\n              const { connection } = fetchParams.controller;\n              if (connection.destroyed) {\n                abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n              } else {\n                fetchParams.controller.on(\"terminated\", abort);\n                this.abort = connection.abort = abort;\n              }\n            },\n            onHeaders(status, headersList, resume, statusText) {\n              if (status < 200) {\n                return;\n              }\n              let codings = [];\n              let location = \"\";\n              const headers = new Headers();\n              for (let n = 0; n < headersList.length; n += 2) {\n                const key = headersList[n + 0].toString(\"latin1\");\n                const val = headersList[n + 1].toString(\"latin1\");\n                if (key.toLowerCase() === \"content-encoding\") {\n                  codings = val.split(\",\").map((x) => x.trim());\n                } else if (key.toLowerCase() === \"location\") {\n                  location = val;\n                }\n                headers.append(key, val);\n              }\n              this.body = new Readable({ read: resume });\n              const decoders = [];\n              if (request2.method !== \"HEAD\" && request2.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !(request2.redirect === \"follow\" && location)) {\n                for (const coding of codings) {\n                  if (/(x-)?gzip/.test(coding)) {\n                    decoders.push(zlib.createGunzip());\n                  } else if (/(x-)?deflate/.test(coding)) {\n                    decoders.push(zlib.createInflate());\n                  } else if (coding === \"br\") {\n                    decoders.push(zlib.createBrotliDecompress());\n                  } else {\n                    decoders.length = 0;\n                    break;\n                  }\n                }\n              }\n              resolve({\n                status,\n                statusText,\n                headersList: headers[kHeadersList],\n                body: decoders.length ? pipeline(this.body, ...decoders, () => {\n                }) : this.body.on(\"error\", () => {\n                })\n              });\n              return true;\n            },\n            onData(chunk) {\n              if (fetchParams.controller.dump) {\n                return;\n              }\n              const bytes = chunk;\n              timingInfo.encodedBodySize += bytes.byteLength;\n              return this.body.push(bytes);\n            },\n            onComplete() {\n              if (this.abort) {\n                fetchParams.controller.off(\"terminated\", this.abort);\n              }\n              fetchParams.controller.ended = true;\n              this.body.push(null);\n            },\n            onError(error2) {\n              var _a3;\n              if (this.abort) {\n                fetchParams.controller.off(\"terminated\", this.abort);\n              }\n              (_a3 = this.body) == null ? void 0 : _a3.destroy(error2);\n              fetchParams.controller.terminate(error2);\n              reject(error2);\n            }\n          }\n        ));\n      }\n      __name(dispatch, \"dispatch\");\n    }\n    __name(httpNetworkFetch, \"httpNetworkFetch\");\n    module2.exports = fetch2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/index.js\nvar require_undici = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/index.js\"(exports, module2) {\n    \"use strict\";\n    var Client = require_client();\n    var Dispatcher = require_dispatcher();\n    var errors = require_errors();\n    var Pool = require_pool();\n    var BalancedPool = require_balanced_pool();\n    var Agent = require_agent();\n    var util2 = require_util2();\n    var { InvalidArgumentError } = errors;\n    var api = require_api();\n    var buildConnector = require_connect();\n    var MockClient = require_mock_client();\n    var MockAgent = require_mock_agent();\n    var MockPool = require_mock_pool();\n    var mockErrors = require_mock_errors();\n    var ProxyAgent = require_proxy_agent();\n    var { getGlobalDispatcher, setGlobalDispatcher } = require_global();\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    Object.assign(Dispatcher.prototype, api);\n    module2.exports.Dispatcher = Dispatcher;\n    module2.exports.Client = Client;\n    module2.exports.Pool = Pool;\n    module2.exports.BalancedPool = BalancedPool;\n    module2.exports.Agent = Agent;\n    module2.exports.ProxyAgent = ProxyAgent;\n    module2.exports.buildConnector = buildConnector;\n    module2.exports.errors = errors;\n    function makeDispatcher(fn) {\n      return (url, opts, handler) => {\n        if (typeof opts === \"function\") {\n          handler = opts;\n          opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n          throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n          if (typeof opts.path !== \"string\") {\n            throw new InvalidArgumentError(\"invalid opts.path\");\n          }\n          let path7 = opts.path;\n          if (!opts.path.startsWith(\"/\")) {\n            path7 = `/${path7}`;\n          }\n          url = new URL(util2.parseOrigin(url).origin + path7);\n        } else {\n          if (!opts) {\n            opts = typeof url === \"object\" ? url : {};\n          }\n          url = util2.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n          throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n          ...opts,\n          origin: url.origin,\n          path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n          method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n      };\n    }\n    __name(makeDispatcher, \"makeDispatcher\");\n    module2.exports.setGlobalDispatcher = setGlobalDispatcher;\n    module2.exports.getGlobalDispatcher = getGlobalDispatcher;\n    if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 8) {\n      let fetchImpl = null;\n      module2.exports.fetch = /* @__PURE__ */ __name(async function fetch2(resource) {\n        if (!fetchImpl) {\n          fetchImpl = require_fetch();\n        }\n        const dispatcher = arguments[1] && arguments[1].dispatcher || getGlobalDispatcher();\n        return fetchImpl.apply(dispatcher, arguments);\n      }, \"fetch\");\n      module2.exports.Headers = require_headers().Headers;\n      module2.exports.Response = require_response().Response;\n      module2.exports.Request = require_request2().Request;\n      module2.exports.FormData = require_formdata().FormData;\n      module2.exports.File = require_file().File;\n    }\n    module2.exports.request = makeDispatcher(api.request);\n    module2.exports.stream = makeDispatcher(api.stream);\n    module2.exports.pipeline = makeDispatcher(api.pipeline);\n    module2.exports.connect = makeDispatcher(api.connect);\n    module2.exports.upgrade = makeDispatcher(api.upgrade);\n    module2.exports.MockClient = MockClient;\n    module2.exports.MockPool = MockPool;\n    module2.exports.MockAgent = MockAgent;\n    module2.exports.mockErrors = mockErrors;\n  }\n});\n\n// ../../node_modules/.pnpm/dotenv@16.0.1/node_modules/dotenv/lib/main.js\nvar require_main2 = __commonJS({\n  \"../../node_modules/.pnpm/dotenv@16.0.1/node_modules/dotenv/lib/main.js\"(exports, module2) {\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n    function parse2(src) {\n      const obj = {};\n      let lines = src.toString();\n      lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n      let match;\n      while ((match = LINE.exec(lines)) != null) {\n        const key = match[1];\n        let value = match[2] || \"\";\n        value = value.trim();\n        const maybeQuote = value[0];\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        if (maybeQuote === '\"') {\n          value = value.replace(/\\\\n/g, \"\\n\");\n          value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        obj[key] = value;\n      }\n      return obj;\n    }\n    __name(parse2, \"parse\");\n    function _log(message) {\n      console.log(`[dotenv][DEBUG] ${message}`);\n    }\n    __name(_log, \"_log\");\n    function _resolveHome(envPath) {\n      return envPath[0] === \"~\" ? path7.join(os3.homedir(), envPath.slice(1)) : envPath;\n    }\n    __name(_resolveHome, \"_resolveHome\");\n    function config2(options) {\n      let dotenvPath = path7.resolve(process.cwd(), \".env\");\n      let encoding = \"utf8\";\n      const debug13 = Boolean(options && options.debug);\n      const override = Boolean(options && options.override);\n      if (options) {\n        if (options.path != null) {\n          dotenvPath = _resolveHome(options.path);\n        }\n        if (options.encoding != null) {\n          encoding = options.encoding;\n        }\n      }\n      try {\n        const parsed = DotenvModule.parse(fs11.readFileSync(dotenvPath, { encoding }));\n        Object.keys(parsed).forEach(function(key) {\n          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n            process.env[key] = parsed[key];\n          } else {\n            if (override === true) {\n              process.env[key] = parsed[key];\n            }\n            if (debug13) {\n              if (override === true) {\n                _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`);\n              } else {\n                _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`);\n              }\n            }\n          }\n        });\n        return { parsed };\n      } catch (e) {\n        if (debug13) {\n          _log(`Failed to load ${dotenvPath} ${e.message}`);\n        }\n        return { error: e };\n      }\n    }\n    __name(config2, \"config\");\n    var DotenvModule = {\n      config: config2,\n      parse: parse2\n    };\n    module2.exports.config = DotenvModule.config;\n    module2.exports.parse = DotenvModule.parse;\n    module2.exports = DotenvModule;\n  }\n});\n\n// ../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js\nvar require_arg = __commonJS({\n  \"../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js\"(exports, module2) {\n    var flagSymbol = Symbol(\"arg flag\");\n    var ArgError = class extends Error {\n      constructor(msg, code) {\n        super(msg);\n        this.name = \"ArgError\";\n        this.code = code;\n        Object.setPrototypeOf(this, ArgError.prototype);\n      }\n    };\n    __name(ArgError, \"ArgError\");\n    function arg2(opts, {\n      argv = process.argv.slice(2),\n      permissive = false,\n      stopAtPositional = false\n    } = {}) {\n      if (!opts) {\n        throw new ArgError(\n          \"argument specification object is required\",\n          \"ARG_CONFIG_NO_SPEC\"\n        );\n      }\n      const result = { _: [] };\n      const aliases = {};\n      const handlers = {};\n      for (const key of Object.keys(opts)) {\n        if (!key) {\n          throw new ArgError(\n            \"argument key cannot be an empty string\",\n            \"ARG_CONFIG_EMPTY_KEY\"\n          );\n        }\n        if (key[0] !== \"-\") {\n          throw new ArgError(\n            `argument key must start with '-' but found: '${key}'`,\n            \"ARG_CONFIG_NONOPT_KEY\"\n          );\n        }\n        if (key.length === 1) {\n          throw new ArgError(\n            `argument key must have a name; singular '-' keys are not allowed: ${key}`,\n            \"ARG_CONFIG_NONAME_KEY\"\n          );\n        }\n        if (typeof opts[key] === \"string\") {\n          aliases[key] = opts[key];\n          continue;\n        }\n        let type = opts[key];\n        let isFlag = false;\n        if (Array.isArray(type) && type.length === 1 && typeof type[0] === \"function\") {\n          const [fn] = type;\n          type = /* @__PURE__ */ __name((value, name, prev = []) => {\n            prev.push(fn(value, name, prev[prev.length - 1]));\n            return prev;\n          }, \"type\");\n          isFlag = fn === Boolean || fn[flagSymbol] === true;\n        } else if (typeof type === \"function\") {\n          isFlag = type === Boolean || type[flagSymbol] === true;\n        } else {\n          throw new ArgError(\n            `type missing or not a function or valid array type: ${key}`,\n            \"ARG_CONFIG_VAD_TYPE\"\n          );\n        }\n        if (key[1] !== \"-\" && key.length > 2) {\n          throw new ArgError(\n            `short argument keys (with a single hyphen) must have only one character: ${key}`,\n            \"ARG_CONFIG_SHORTOPT_TOOLONG\"\n          );\n        }\n        handlers[key] = [type, isFlag];\n      }\n      for (let i = 0, len = argv.length; i < len; i++) {\n        const wholeArg = argv[i];\n        if (stopAtPositional && result._.length > 0) {\n          result._ = result._.concat(argv.slice(i));\n          break;\n        }\n        if (wholeArg === \"--\") {\n          result._ = result._.concat(argv.slice(i + 1));\n          break;\n        }\n        if (wholeArg.length > 1 && wholeArg[0] === \"-\") {\n          const separatedArguments = wholeArg[1] === \"-\" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split(\"\").map((a) => `-${a}`);\n          for (let j = 0; j < separatedArguments.length; j++) {\n            const arg3 = separatedArguments[j];\n            const [originalArgName, argStr] = arg3[1] === \"-\" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];\n            let argName = originalArgName;\n            while (argName in aliases) {\n              argName = aliases[argName];\n            }\n            if (!(argName in handlers)) {\n              if (permissive) {\n                result._.push(arg3);\n                continue;\n              } else {\n                throw new ArgError(\n                  `unknown or unexpected option: ${originalArgName}`,\n                  \"ARG_UNKNOWN_OPTION\"\n                );\n              }\n            }\n            const [type, isFlag] = handlers[argName];\n            if (!isFlag && j + 1 < separatedArguments.length) {\n              throw new ArgError(\n                `option requires argument (but was followed by another short argument): ${originalArgName}`,\n                \"ARG_MISSING_REQUIRED_SHORTARG\"\n              );\n            }\n            if (isFlag) {\n              result[argName] = type(true, argName, result[argName]);\n            } else if (argStr === void 0) {\n              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === \"-\" && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number || typeof BigInt !== \"undefined\" && type === BigInt))) {\n                const extended = originalArgName === argName ? \"\" : ` (alias for ${argName})`;\n                throw new ArgError(\n                  `option requires argument: ${originalArgName}${extended}`,\n                  \"ARG_MISSING_REQUIRED_LONGARG\"\n                );\n              }\n              result[argName] = type(argv[i + 1], argName, result[argName]);\n              ++i;\n            } else {\n              result[argName] = type(argStr, argName, result[argName]);\n            }\n          }\n        } else {\n          result._.push(wholeArg);\n        }\n      }\n      return result;\n    }\n    __name(arg2, \"arg\");\n    arg2.flag = (fn) => {\n      fn[flagSymbol] = true;\n      return fn;\n    };\n    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);\n    arg2.ArgError = ArgError;\n    module2.exports = arg2;\n  }\n});\n\n// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js\nvar require_min_indent = __commonJS({\n  \"../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (string) => {\n      const match = string.match(/^[ \\t]*(?=\\S)/gm);\n      if (!match) {\n        return 0;\n      }\n      return match.reduce((r, a) => Math.min(r, a.length), Infinity);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js\nvar require_strip_indent = __commonJS({\n  \"../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js\"(exports, module2) {\n    \"use strict\";\n    var minIndent = require_min_indent();\n    module2.exports = (string) => {\n      const indent4 = minIndent(string);\n      if (indent4 === 0) {\n        return string;\n      }\n      const regex = new RegExp(`^[ \\\\t]{${indent4}}`, \"gm\");\n      return string.replace(regex, \"\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js\nvar require_pluralize = __commonJS({\n  \"../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js\"(exports, module2) {\n    (function(root, pluralize2) {\n      if ( true && typeof exports === \"object\" && typeof module2 === \"object\") {\n        module2.exports = pluralize2();\n      } else if (false) {} else {\n        root.pluralize = pluralize2();\n      }\n    })(exports, function() {\n      var pluralRules = [];\n      var singularRules = [];\n      var uncountables = {};\n      var irregularPlurals = {};\n      var irregularSingles = {};\n      function sanitizeRule(rule) {\n        if (typeof rule === \"string\") {\n          return new RegExp(\"^\" + rule + \"$\", \"i\");\n        }\n        return rule;\n      }\n      __name(sanitizeRule, \"sanitizeRule\");\n      function restoreCase(word, token) {\n        if (word === token)\n          return token;\n        if (word === word.toLowerCase())\n          return token.toLowerCase();\n        if (word === word.toUpperCase())\n          return token.toUpperCase();\n        if (word[0] === word[0].toUpperCase()) {\n          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();\n        }\n        return token.toLowerCase();\n      }\n      __name(restoreCase, \"restoreCase\");\n      function interpolate(str, args) {\n        return str.replace(/\\$(\\d{1,2})/g, function(match, index) {\n          return args[index] || \"\";\n        });\n      }\n      __name(interpolate, \"interpolate\");\n      function replace(word, rule) {\n        return word.replace(rule[0], function(match, index) {\n          var result = interpolate(rule[1], arguments);\n          if (match === \"\") {\n            return restoreCase(word[index - 1], result);\n          }\n          return restoreCase(match, result);\n        });\n      }\n      __name(replace, \"replace\");\n      function sanitizeWord(token, word, rules) {\n        if (!token.length || uncountables.hasOwnProperty(token)) {\n          return word;\n        }\n        var len = rules.length;\n        while (len--) {\n          var rule = rules[len];\n          if (rule[0].test(word))\n            return replace(word, rule);\n        }\n        return word;\n      }\n      __name(sanitizeWord, \"sanitizeWord\");\n      function replaceWord(replaceMap, keepMap, rules) {\n        return function(word) {\n          var token = word.toLowerCase();\n          if (keepMap.hasOwnProperty(token)) {\n            return restoreCase(word, token);\n          }\n          if (replaceMap.hasOwnProperty(token)) {\n            return restoreCase(word, replaceMap[token]);\n          }\n          return sanitizeWord(token, word, rules);\n        };\n      }\n      __name(replaceWord, \"replaceWord\");\n      function checkWord(replaceMap, keepMap, rules, bool) {\n        return function(word) {\n          var token = word.toLowerCase();\n          if (keepMap.hasOwnProperty(token))\n            return true;\n          if (replaceMap.hasOwnProperty(token))\n            return false;\n          return sanitizeWord(token, token, rules) === token;\n        };\n      }\n      __name(checkWord, \"checkWord\");\n      function pluralize2(word, count2, inclusive) {\n        var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);\n        return (inclusive ? count2 + \" \" : \"\") + pluralized;\n      }\n      __name(pluralize2, \"pluralize\");\n      pluralize2.plural = replaceWord(\n        irregularSingles,\n        irregularPlurals,\n        pluralRules\n      );\n      pluralize2.isPlural = checkWord(\n        irregularSingles,\n        irregularPlurals,\n        pluralRules\n      );\n      pluralize2.singular = replaceWord(\n        irregularPlurals,\n        irregularSingles,\n        singularRules\n      );\n      pluralize2.isSingular = checkWord(\n        irregularPlurals,\n        irregularSingles,\n        singularRules\n      );\n      pluralize2.addPluralRule = function(rule, replacement) {\n        pluralRules.push([sanitizeRule(rule), replacement]);\n      };\n      pluralize2.addSingularRule = function(rule, replacement) {\n        singularRules.push([sanitizeRule(rule), replacement]);\n      };\n      pluralize2.addUncountableRule = function(word) {\n        if (typeof word === \"string\") {\n          uncountables[word.toLowerCase()] = true;\n          return;\n        }\n        pluralize2.addPluralRule(word, \"$0\");\n        pluralize2.addSingularRule(word, \"$0\");\n      };\n      pluralize2.addIrregularRule = function(single, plural) {\n        plural = plural.toLowerCase();\n        single = single.toLowerCase();\n        irregularSingles[single] = plural;\n        irregularPlurals[plural] = single;\n      };\n      [\n        [\"I\", \"we\"],\n        [\"me\", \"us\"],\n        [\"he\", \"they\"],\n        [\"she\", \"they\"],\n        [\"them\", \"them\"],\n        [\"myself\", \"ourselves\"],\n        [\"yourself\", \"yourselves\"],\n        [\"itself\", \"themselves\"],\n        [\"herself\", \"themselves\"],\n        [\"himself\", \"themselves\"],\n        [\"themself\", \"themselves\"],\n        [\"is\", \"are\"],\n        [\"was\", \"were\"],\n        [\"has\", \"have\"],\n        [\"this\", \"these\"],\n        [\"that\", \"those\"],\n        [\"echo\", \"echoes\"],\n        [\"dingo\", \"dingoes\"],\n        [\"volcano\", \"volcanoes\"],\n        [\"tornado\", \"tornadoes\"],\n        [\"torpedo\", \"torpedoes\"],\n        [\"genus\", \"genera\"],\n        [\"viscus\", \"viscera\"],\n        [\"stigma\", \"stigmata\"],\n        [\"stoma\", \"stomata\"],\n        [\"dogma\", \"dogmata\"],\n        [\"lemma\", \"lemmata\"],\n        [\"schema\", \"schemata\"],\n        [\"anathema\", \"anathemata\"],\n        [\"ox\", \"oxen\"],\n        [\"axe\", \"axes\"],\n        [\"die\", \"dice\"],\n        [\"yes\", \"yeses\"],\n        [\"foot\", \"feet\"],\n        [\"eave\", \"eaves\"],\n        [\"goose\", \"geese\"],\n        [\"tooth\", \"teeth\"],\n        [\"quiz\", \"quizzes\"],\n        [\"human\", \"humans\"],\n        [\"proof\", \"proofs\"],\n        [\"carve\", \"carves\"],\n        [\"valve\", \"valves\"],\n        [\"looey\", \"looies\"],\n        [\"thief\", \"thieves\"],\n        [\"groove\", \"grooves\"],\n        [\"pickaxe\", \"pickaxes\"],\n        [\"passerby\", \"passersby\"]\n      ].forEach(function(rule) {\n        return pluralize2.addIrregularRule(rule[0], rule[1]);\n      });\n      [\n        [/s?$/i, \"s\"],\n        [/[^\\u0000-\\u007F]$/i, \"$0\"],\n        [/([^aeiou]ese)$/i, \"$1\"],\n        [/(ax|test)is$/i, \"$1es\"],\n        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, \"$1es\"],\n        [/(e[mn]u)s?$/i, \"$1s\"],\n        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, \"$1\"],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, \"$1i\"],\n        [/(alumn|alg|vertebr)(?:a|ae)$/i, \"$1ae\"],\n        [/(seraph|cherub)(?:im)?$/i, \"$1im\"],\n        [/(her|at|gr)o$/i, \"$1oes\"],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, \"$1a\"],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, \"$1a\"],\n        [/sis$/i, \"ses\"],\n        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, \"$1$2ves\"],\n        [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n        [/([^ch][ieo][ln])ey$/i, \"$1ies\"],\n        [/(x|ch|ss|sh|zz)$/i, \"$1es\"],\n        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, \"$1ices\"],\n        [/\\b((?:tit)?m|l)(?:ice|ouse)$/i, \"$1ice\"],\n        [/(pe)(?:rson|ople)$/i, \"$1ople\"],\n        [/(child)(?:ren)?$/i, \"$1ren\"],\n        [/eaux$/i, \"$0\"],\n        [/m[ae]n$/i, \"men\"],\n        [\"thou\", \"you\"]\n      ].forEach(function(rule) {\n        return pluralize2.addPluralRule(rule[0], rule[1]);\n      });\n      [\n        [/s$/i, \"\"],\n        [/(ss)$/i, \"$1\"],\n        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\\w]|^)li)ves$/i, \"$1fe\"],\n        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, \"$1f\"],\n        [/ies$/i, \"y\"],\n        [/\\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, \"$1ie\"],\n        [/\\b(mon|smil)ies$/i, \"$1ey\"],\n        [/\\b((?:tit)?m|l)ice$/i, \"$1ouse\"],\n        [/(seraph|cherub)im$/i, \"$1\"],\n        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, \"$1\"],\n        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, \"$1sis\"],\n        [/(movie|twelve|abuse|e[mn]u)s$/i, \"$1\"],\n        [/(test)(?:is|es)$/i, \"$1is\"],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, \"$1us\"],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, \"$1um\"],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, \"$1on\"],\n        [/(alumn|alg|vertebr)ae$/i, \"$1a\"],\n        [/(cod|mur|sil|vert|ind)ices$/i, \"$1ex\"],\n        [/(matr|append)ices$/i, \"$1ix\"],\n        [/(pe)(rson|ople)$/i, \"$1rson\"],\n        [/(child)ren$/i, \"$1\"],\n        [/(eau)x?$/i, \"$1\"],\n        [/men$/i, \"man\"]\n      ].forEach(function(rule) {\n        return pluralize2.addSingularRule(rule[0], rule[1]);\n      });\n      [\n        \"adulthood\",\n        \"advice\",\n        \"agenda\",\n        \"aid\",\n        \"aircraft\",\n        \"alcohol\",\n        \"ammo\",\n        \"analytics\",\n        \"anime\",\n        \"athletics\",\n        \"audio\",\n        \"bison\",\n        \"blood\",\n        \"bream\",\n        \"buffalo\",\n        \"butter\",\n        \"carp\",\n        \"cash\",\n        \"chassis\",\n        \"chess\",\n        \"clothing\",\n        \"cod\",\n        \"commerce\",\n        \"cooperation\",\n        \"corps\",\n        \"debris\",\n        \"diabetes\",\n        \"digestion\",\n        \"elk\",\n        \"energy\",\n        \"equipment\",\n        \"excretion\",\n        \"expertise\",\n        \"firmware\",\n        \"flounder\",\n        \"fun\",\n        \"gallows\",\n        \"garbage\",\n        \"graffiti\",\n        \"hardware\",\n        \"headquarters\",\n        \"health\",\n        \"herpes\",\n        \"highjinks\",\n        \"homework\",\n        \"housework\",\n        \"information\",\n        \"jeans\",\n        \"justice\",\n        \"kudos\",\n        \"labour\",\n        \"literature\",\n        \"machinery\",\n        \"mackerel\",\n        \"mail\",\n        \"media\",\n        \"mews\",\n        \"moose\",\n        \"music\",\n        \"mud\",\n        \"manga\",\n        \"news\",\n        \"only\",\n        \"personnel\",\n        \"pike\",\n        \"plankton\",\n        \"pliers\",\n        \"police\",\n        \"pollution\",\n        \"premises\",\n        \"rain\",\n        \"research\",\n        \"rice\",\n        \"salmon\",\n        \"scissors\",\n        \"series\",\n        \"sewage\",\n        \"shambles\",\n        \"shrimp\",\n        \"software\",\n        \"species\",\n        \"staff\",\n        \"swine\",\n        \"tennis\",\n        \"traffic\",\n        \"transportation\",\n        \"trout\",\n        \"tuna\",\n        \"wealth\",\n        \"welfare\",\n        \"whiting\",\n        \"wildebeest\",\n        \"wildlife\",\n        \"you\",\n        /pok[eé]mon$/i,\n        /[^aeiou]ese$/i,\n        /deer$/i,\n        /fish$/i,\n        /measles$/i,\n        /o[iu]s$/i,\n        /pox$/i,\n        /sheep$/i\n      ].forEach(pluralize2.addUncountableRule);\n      return pluralize2;\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js\nvar require_is_regexp = __commonJS({\n  \"../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (input) => Object.prototype.toString.call(input) === \"[object RegExp]\";\n  }\n});\n\n// ../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js\nvar require_is_obj = __commonJS({\n  \"../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (value) => {\n      const type = typeof value;\n      return value !== null && (type === \"object\" || type === \"function\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js\nvar require_lib = __commonJS({\n  \"../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));\n  }\n});\n\n// package.json\nvar require_package2 = __commonJS({\n  \"package.json\"(exports, module2) {\n    module2.exports = {\n      name: \"@prisma/client\",\n      version: \"4.3.1\",\n      description: \"Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.\",\n      keywords: [\n        \"orm\",\n        \"prisma2\",\n        \"prisma\",\n        \"client\",\n        \"query\",\n        \"database\",\n        \"sql\",\n        \"postgres\",\n        \"postgresql\",\n        \"mysql\",\n        \"sqlite\",\n        \"mariadb\",\n        \"mssql\",\n        \"typescript\",\n        \"query-builder\"\n      ],\n      main: \"index.js\",\n      browser: \"index-browser.js\",\n      types: \"index.d.ts\",\n      license: \"Apache-2.0\",\n      engines: {\n        node: \">=14.17\"\n      },\n      homepage: \"https://www.prisma.io\",\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/prisma/prisma.git\",\n        directory: \"packages/client\"\n      },\n      author: \"Tim Suchanek <suchanek@prisma.io>\",\n      bugs: \"https://github.com/prisma/prisma/issues\",\n      scripts: {\n        dev: \"DEV=true node -r esbuild-register helpers/build.ts\",\n        build: \"node -r esbuild-register helpers/build.ts\",\n        test: \"jest --verbose\",\n        \"test:functional\": \"node -r esbuild-register helpers/functional-test/run-tests.ts\",\n        \"test:memory\": \"node -r esbuild-register helpers/memory-tests.ts\",\n        \"test:functional:code\": \"node -r esbuild-register helpers/functional-test/run-tests.ts --no-types\",\n        \"test:functional:types\": \"node -r esbuild-register helpers/functional-test/run-tests.ts --types-only\",\n        \"test-notypes\": \"jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts\",\n        generate: \"node scripts/postinstall.js\",\n        postinstall: \"node scripts/postinstall.js\",\n        prepublishOnly: \"pnpm run build\",\n        \"new-test\": \"NODE_OPTIONS='-r ts-node/register' yo ./helpers/generator-test/index.ts\"\n      },\n      files: [\n        \"README.md\",\n        \"runtime\",\n        \"scripts\",\n        \"generator-build\",\n        \"edge.js\",\n        \"edge.d.ts\",\n        \"index.js\",\n        \"index.d.ts\",\n        \"index-browser.js\"\n      ],\n      devDependencies: {\n        \"@faker-js/faker\": \"7.4.0\",\n        \"@jest/test-sequencer\": \"28.1.3\",\n        \"@microsoft/api-extractor\": \"7.29.5\",\n        \"@opentelemetry/api\": \"1.1.0\",\n        \"@opentelemetry/context-async-hooks\": \"1.5.0\",\n        \"@opentelemetry/instrumentation\": \"0.31.0\",\n        \"@opentelemetry/resources\": \"1.5.0\",\n        \"@opentelemetry/sdk-trace-base\": \"1.5.0\",\n        \"@opentelemetry/semantic-conventions\": \"1.5.0\",\n        \"@prisma/debug\": \"workspace:4.3.1\",\n        \"@prisma/engine-core\": \"workspace:4.3.1\",\n        \"@prisma/engines\": \"workspace:4.3.1\",\n        \"@prisma/fetch-engine\": \"workspace:4.3.1\",\n        \"@prisma/generator-helper\": \"workspace:4.3.1\",\n        \"@prisma/get-platform\": \"workspace:4.3.1\",\n        \"@prisma/instrumentation\": \"workspace:4.3.1\",\n        \"@prisma/internals\": \"workspace:4.3.1\",\n        \"@prisma/migrate\": \"workspace:4.3.1\",\n        \"@swc-node/register\": \"1.5.1\",\n        \"@swc/core\": \"1.2.242\",\n        \"@swc/jest\": \"0.2.22\",\n        \"@timsuchanek/copy\": \"1.4.5\",\n        \"@types/debug\": \"4.1.7\",\n        \"@types/jest\": \"28.1.7\",\n        \"@types/js-levenshtein\": \"1.1.1\",\n        \"@types/mssql\": \"8.1.1\",\n        \"@types/node\": \"14.18.26\",\n        \"@types/pg\": \"8.6.5\",\n        \"@types/yeoman-generator\": \"5.2.11\",\n        arg: \"5.0.2\",\n        benchmark: \"2.1.4\",\n        chalk: \"4.1.2\",\n        cuid: \"2.1.8\",\n        \"decimal.js\": \"10.4.0\",\n        esbuild: \"0.15.5\",\n        execa: \"5.1.1\",\n        \"expect-type\": \"0.13.0\",\n        \"flat-map-polyfill\": \"0.3.8\",\n        \"fs-extra\": \"10.1.0\",\n        \"fs-monkey\": \"1.0.3\",\n        \"get-own-enumerable-property-symbols\": \"3.0.2\",\n        globby: \"11.1.0\",\n        \"indent-string\": \"4.0.0\",\n        \"is-obj\": \"2.0.0\",\n        \"is-regexp\": \"2.1.0\",\n        jest: \"28.1.3\",\n        \"jest-junit\": \"14.0.0\",\n        \"jest-snapshot\": \"28.1.3\",\n        \"js-levenshtein\": \"1.1.6\",\n        klona: \"2.0.5\",\n        \"lz-string\": \"1.4.4\",\n        \"make-dir\": \"3.1.0\",\n        mariadb: \"3.0.1\",\n        memfs: \"3.4.7\",\n        mssql: \"9.0.1\",\n        pg: \"8.8.0\",\n        \"pkg-up\": \"3.1.0\",\n        pluralize: \"8.0.0\",\n        \"replace-string\": \"3.1.0\",\n        resolve: \"1.22.1\",\n        rimraf: \"3.0.2\",\n        \"simple-statistics\": \"7.7.6\",\n        \"sort-keys\": \"4.2.0\",\n        \"source-map-support\": \"0.5.21\",\n        \"sql-template-tag\": \"5.0.3\",\n        \"stacktrace-parser\": \"0.1.10\",\n        \"strip-ansi\": \"6.0.1\",\n        \"strip-indent\": \"3.0.0\",\n        \"ts-jest\": \"28.0.8\",\n        \"ts-node\": \"10.9.1\",\n        tsd: \"0.21.0\",\n        typescript: \"4.8.2\",\n        \"yeoman-generator\": \"5.7.0\",\n        yo: \"4.3.0\"\n      },\n      peerDependencies: {\n        prisma: \"*\"\n      },\n      peerDependenciesMeta: {\n        prisma: {\n          optional: true\n        }\n      },\n      dependencies: {\n        \"@prisma/engines-version\": \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\"\n      },\n      sideEffects: false\n    };\n  }\n});\n\n// src/runtime/index.ts\nvar runtime_exports = {};\n__export(runtime_exports, {\n  DMMF: () => DMMF,\n  DMMFClass: () => DMMFHelper,\n  Debug: () => Debug,\n  Decimal: () => decimal_default,\n  Engine: () => Engine,\n  MetricsClient: () => MetricsClient,\n  NotFoundError: () => NotFoundError2,\n  PrismaClientInitializationError: () => PrismaClientInitializationError,\n  PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,\n  PrismaClientRustPanicError: () => PrismaClientRustPanicError,\n  PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,\n  PrismaClientValidationError: () => PrismaClientValidationError,\n  Sql: () => Sql,\n  decompressFromBase64: () => decompressFromBase642,\n  empty: () => empty,\n  findSync: () => findSync,\n  getPrismaClient: () => getPrismaClient,\n  join: () => join,\n  makeDocument: () => makeDocument,\n  makeStrictEnum: () => makeStrictEnum,\n  objectEnumValues: () => objectEnumValues,\n  raw: () => raw,\n  sqltag: () => sql,\n  transformDocument: () => transformDocument,\n  unpack: () => unpack,\n  warnEnvConflicts: () => warnEnvConflicts\n});\nmodule.exports = __toCommonJS(runtime_exports);\nvar lzString = __toESM(require_lz_string());\n\n// src/runtime/core/metrics/MetricsClient.ts\nvar MetricsClient = class {\n  constructor(engine) {\n    this._engine = engine;\n  }\n  prometheus(options) {\n    return this._engine.metrics({ format: \"prometheus\", ...options });\n  }\n  json(options) {\n    return this._engine.metrics({ format: \"json\", ...options });\n  }\n};\n__name(MetricsClient, \"MetricsClient\");\n\n// src/runtime/utils/applyMixins.ts\nfunction applyMixins(derivedCtor, constructors) {\n  var _a3;\n  for (const baseCtor of constructors) {\n    for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        (_a3 = Object.getOwnPropertyDescriptor(baseCtor.prototype, name)) != null ? _a3 : /* @__PURE__ */ Object.create(null)\n      );\n    }\n  }\n}\n__name(applyMixins, \"applyMixins\");\n\n// src/runtime/utils/common.ts\nvar import_chalk = __toESM(require_source());\n\n// ../../node_modules/.pnpm/decimal.js@10.4.0/node_modules/decimal.js/decimal.mjs\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  precision: 20,\n  rounding: 4,\n  modulo: 1,\n  toExpNeg: -7,\n  toExpPos: 21,\n  minE: -EXP_LIMIT,\n  maxE: EXP_LIMIT,\n  crypto: false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0)\n    x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s)\n    return new Ctor(NaN);\n  if (min2.gt(max2))\n    throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0])\n    return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys)\n    return xs;\n  if (x.e !== y.e)\n    return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i])\n      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d)\n    return new Ctor(NaN);\n  if (!x.d[0])\n    return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3)\n      n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w)\n      for (; w % 10 == 0; w /= 10)\n        n--;\n    if (n < 0)\n      n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite())\n    return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero())\n    return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(x.s);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero())\n    return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.asin();\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return halfPi.minus(x);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1))\n    return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.e >= 0)\n    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1)\n    return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero())\n    return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s)\n      return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i)\n    x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0)\n      for (i = j; r.d[i] === t.d[i] && i--; )\n        ;\n  }\n  if (k)\n    r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1))\n      return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg2.d;\n  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; )\n        k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg2, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg2, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (x.d)\n      y.s = -y.s;\n    else\n      y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0])\n      y.s = -y.s;\n    else if (xd[0])\n      y = new Ctor(x);\n    else\n      return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; )\n      d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy)\n      len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i)\n    xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; )\n        xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; )\n    xd.pop();\n  for (; xd[0] === 0; xd.shift())\n    --e;\n  if (!xd[0])\n    return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0])\n    return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (!x.d)\n      y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0])\n      y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; )\n      d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; )\n    xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)\n    throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k)\n      k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0)\n      n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; )\n    r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; )\n    r.pop();\n  if (carry)\n    ++e;\n  else\n    r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0)\n    return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0)\n    rm = Ctor.rounding;\n  else\n    checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd)\n    return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1))\n      throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1)\n      break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d)\n      return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d)\n      return y.s ? x : y;\n    if (!y.d) {\n      if (y.s)\n        y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0])\n    return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1))\n    return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1))\n    return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1)\n      return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0)\n      s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)\n    return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k)\n        str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k)\n      str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; )\n    w /= 10;\n  return str + w;\n}\n__name(digitsToString, \"digitsToString\");\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\n__name(checkInt32, \"checkInt32\");\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10)\n    --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0)\n        rd = rd / 100 | 0;\n      else if (i == 1)\n        rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0)\n        rd = rd / 1e3 | 0;\n      else if (i == 1)\n        rd = rd / 100 | 0;\n      else if (i == 2)\n        rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\n__name(checkRoundingDigits, \"checkRoundingDigits\");\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; )\n      arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0)\n          arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\n__name(convertBase, \"convertBase\");\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero())\n    return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\n__name(cosine, \"cosine\");\nvar divide = function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry)\n      x.unshift(carry);\n    return x;\n  }\n  __name(multiplyInteger, \"multiplyInteger\");\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  __name(compare, \"compare\");\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; )\n      a.shift();\n  }\n  __name(subtract, \"subtract\");\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0\n      );\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++)\n      ;\n    if (yd[i] > (xd[i] || 0))\n      e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; )\n          rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2)\n          ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL)\n              rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base)\n                k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0)\n                cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL)\n              prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0])\n        qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10)\n        i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out:\n    if (sd != null) {\n      xd = x.d;\n      if (!xd)\n        return x;\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10)\n        digits++;\n      i = sd - digits;\n      if (i < 0) {\n        i += LOG_BASE;\n        j = sd;\n        w = xd[xdi = 0];\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n      } else {\n        xdi = Math.ceil((i + 1) / LOG_BASE);\n        k = xd.length;\n        if (xdi >= k) {\n          if (isTruncated) {\n            for (; k++ <= xdi; )\n              xd.push(0);\n            w = rd = 0;\n            digits = 1;\n            i %= LOG_BASE;\n            j = i - LOG_BASE + 1;\n          } else {\n            break out;\n          }\n        } else {\n          w = k = xd[xdi];\n          for (digits = 1; k >= 10; k /= 10)\n            digits++;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + digits;\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n        }\n      }\n      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n      if (sd < 1 || !xd[0]) {\n        xd.length = 0;\n        if (roundUp) {\n          sd -= x.e + 1;\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n          x.e = -sd || 0;\n        } else {\n          xd[0] = x.e = 0;\n        }\n        return x;\n      }\n      if (i == 0) {\n        xd.length = xdi;\n        k = 1;\n        xdi--;\n      } else {\n        xd.length = xdi + 1;\n        k = mathpow(10, LOG_BASE - i);\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n      }\n      if (roundUp) {\n        for (; ; ) {\n          if (xdi == 0) {\n            for (i = 1, j = xd[0]; j >= 10; j /= 10)\n              i++;\n            j = xd[0] += k;\n            for (k = 1; j >= 10; j /= 10)\n              k++;\n            if (i != k) {\n              x.e++;\n              if (xd[0] == BASE)\n                xd[0] = 1;\n            }\n            break;\n          } else {\n            xd[xdi] += k;\n            if (xd[xdi] != BASE)\n              break;\n            xd[xdi--] = 0;\n            k = 1;\n          }\n        }\n      }\n      for (i = xd.length; xd[--i] === 0; )\n        xd.pop();\n    }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\n__name(finalise, \"finalise\");\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite())\n    return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0)\n      str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0)\n      str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len)\n      str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len)\n        str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\n__name(finiteToString, \"finiteToString\");\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10)\n    e++;\n  return e;\n}\n__name(getBase10Exponent, \"getBase10Exponent\");\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr)\n      Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\n__name(getLn10, \"getLn10\");\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION)\n    throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\n__name(getPi, \"getPi\");\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10)\n      len--;\n    for (w = digits[0]; w >= 10; w /= 10)\n      len++;\n  }\n  return len;\n}\n__name(getPrecision, \"getPrecision\");\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; )\n    zs += \"0\";\n  return zs;\n}\n__name(getZeroString, \"getZeroString\");\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k))\n        isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0)\n        ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\n__name(intPow, \"intPow\");\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\n__name(isOdd, \"isOdd\");\nfunction maxOrMin(Ctor, args, ltgt) {\n  var y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    } else if (x[ltgt](y)) {\n      x = y;\n    }\n  }\n  return x;\n}\n__name(maxOrMin, \"maxOrMin\");\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum3 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum3.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {\n      j = k;\n      while (j--)\n        sum3 = finalise(sum3.times(sum3), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum3, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum3;\n      }\n    }\n    sum3 = t;\n  }\n}\n__name(naturalExponential, \"naturalExponential\");\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {\n      sum3 = sum3.times(2);\n      if (e !== 0)\n        sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum3 = divide(sum3, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum3, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum3;\n      }\n    }\n    sum3 = t;\n    denominator += 2;\n  }\n}\n__name(naturalLogarithm, \"naturalLogarithm\");\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\n__name(nonFiniteToString, \"nonFiniteToString\");\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1)\n    str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0)\n      e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++)\n    ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)\n    ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0)\n      i += LOG_BASE;\n    if (i < len) {\n      if (i)\n        x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; )\n        x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; )\n      str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\n__name(parseDecimal, \"parseDecimal\");\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str))\n      return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str)\n      x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i)\n    xd.pop();\n  if (i < 0)\n    return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat)\n    x = divide(x, divisor, len * 4);\n  if (p)\n    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\n__name(parseOther, \"parseOther\");\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\n__name(sine, \"sine\");\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; )\n        ;\n      if (j == -1)\n        break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\n__name(taylorSeries, \"taylorSeries\");\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e)\n    n *= b;\n  return n;\n}\n__name(tinyPow, \"tinyPow\");\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\n__name(toLessThanHalfPi, \"toLessThanHalfPi\");\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; )\n      xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len)\n        ;\n      for (i = 0, str = \"\"; i < len; i++)\n        str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++)\n              str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len)\n              ;\n            for (i = 1, str = \"1.\"; i < len; i++)\n              str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; )\n          str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len)\n          for (e -= len; e--; )\n            str += \"0\";\n        else if (e < len)\n          str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\n__name(toStringBinary, \"toStringBinary\");\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\n__name(truncate, \"truncate\");\nfunction abs(x) {\n  return new this(x).abs();\n}\n__name(abs, \"abs\");\nfunction acos(x) {\n  return new this(x).acos();\n}\n__name(acos, \"acos\");\nfunction acosh(x) {\n  return new this(x).acosh();\n}\n__name(acosh, \"acosh\");\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\n__name(add, \"add\");\nfunction asin(x) {\n  return new this(x).asin();\n}\n__name(asin, \"asin\");\nfunction asinh(x) {\n  return new this(x).asinh();\n}\n__name(asinh, \"asinh\");\nfunction atan(x) {\n  return new this(x).atan();\n}\n__name(atan, \"atan\");\nfunction atanh(x) {\n  return new this(x).atanh();\n}\n__name(atanh, \"atanh\");\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\n__name(atan2, \"atan2\");\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\n__name(cbrt, \"cbrt\");\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\n__name(ceil, \"ceil\");\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\n__name(clamp, \"clamp\");\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\")\n    throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults)\n      this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])\n        this[p] = v;\n      else\n        throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults)\n    this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\n__name(config, \"config\");\nfunction cos(x) {\n  return new this(x).cos();\n}\n__name(cos, \"cos\");\nfunction cosh(x) {\n  return new this(x).cosh();\n}\n__name(cosh, \"cosh\");\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2))\n      return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)\n          e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      } else if (v * 0 !== 0) {\n        if (!v)\n          x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    } else if (t !== \"string\") {\n      throw Error(invalidArgument + v);\n    }\n    if ((i2 = v.charCodeAt(0)) === 45) {\n      v = v.slice(1);\n      x.s = -1;\n    } else {\n      if (i2 === 43)\n        v = v.slice(1);\n      x.s = 1;\n    }\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n  }\n  __name(Decimal2, \"Decimal\");\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0)\n    obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; )\n        if (!obj.hasOwnProperty(p = ps[i++]))\n          obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\n__name(clone, \"clone\");\nfunction div(x, y) {\n  return new this(x).div(y);\n}\n__name(div, \"div\");\nfunction exp(x) {\n  return new this(x).exp();\n}\n__name(exp, \"exp\");\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\n__name(floor, \"floor\");\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\n__name(hypot, \"hypot\");\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n__name(isDecimalInstance, \"isDecimalInstance\");\nfunction ln(x) {\n  return new this(x).ln();\n}\n__name(ln, \"ln\");\nfunction log(x, y) {\n  return new this(x).log(y);\n}\n__name(log, \"log\");\nfunction log2(x) {\n  return new this(x).log(2);\n}\n__name(log2, \"log2\");\nfunction log10(x) {\n  return new this(x).log(10);\n}\n__name(log10, \"log10\");\nfunction max() {\n  return maxOrMin(this, arguments, \"lt\");\n}\n__name(max, \"max\");\nfunction min() {\n  return maxOrMin(this, arguments, \"gt\");\n}\n__name(min, \"min\");\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\n__name(mod, \"mod\");\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\n__name(mul, \"mul\");\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\n__name(pow, \"pow\");\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0)\n    sd = this.precision;\n  else\n    checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; )\n      rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--)\n    rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE)\n      rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10)\n      k++;\n    if (k < LOG_BASE)\n      e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\n__name(random, \"random\");\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n__name(round, \"round\");\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n__name(sign, \"sign\");\nfunction sin(x) {\n  return new this(x).sin();\n}\n__name(sin, \"sin\");\nfunction sinh(x) {\n  return new this(x).sinh();\n}\n__name(sinh, \"sinh\");\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\n__name(sqrt, \"sqrt\");\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\n__name(sub, \"sub\");\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; )\n    x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\n__name(sum, \"sum\");\nfunction tan(x) {\n  return new this(x).tan();\n}\n__name(tan, \"tan\");\nfunction tanh(x) {\n  return new this(x).tanh();\n}\n__name(tanh, \"tanh\");\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\n__name(trunc, \"trunc\");\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\nvar decimal_default = Decimal;\n\n// src/runtime/utils/common.ts\nvar import_indent_string = __toESM(require_indent_string());\nvar import_js_levenshtein = __toESM(require_js_levenshtein());\n\n// src/runtime/core/model/FieldRef.ts\nvar FieldRefImpl = class {\n  constructor(modelName, name, fieldType, isList) {\n    this.modelName = modelName;\n    this.name = name;\n    this.typeName = fieldType;\n    this.isList = isList;\n  }\n  _toGraphQLInputType() {\n    const prefix = this.isList ? `List${this.typeName}` : this.typeName;\n    return `${prefix}FieldRefInput<${this.modelName}>`;\n  }\n};\n__name(FieldRefImpl, \"FieldRefImpl\");\n\n// src/runtime/object-enums.ts\nvar objectEnumNames = [\"JsonNullValueInput\", \"NullableJsonNullValueInput\", \"JsonNullValueFilter\"];\nvar secret = Symbol();\nvar representations = /* @__PURE__ */ new WeakMap();\nvar ObjectEnumValue = class {\n  constructor(arg2) {\n    if (arg2 === secret) {\n      representations.set(this, `Prisma.${this._getName()}`);\n    } else {\n      representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);\n    }\n  }\n  _getName() {\n    return this.constructor.name;\n  }\n  toString() {\n    return representations.get(this);\n  }\n};\n__name(ObjectEnumValue, \"ObjectEnumValue\");\nvar NullTypesEnumValue = class extends ObjectEnumValue {\n  _getNamespace() {\n    return \"NullTypes\";\n  }\n};\n__name(NullTypesEnumValue, \"NullTypesEnumValue\");\nvar DbNull = class extends NullTypesEnumValue {\n};\n__name(DbNull, \"DbNull\");\nvar JsonNull = class extends NullTypesEnumValue {\n};\n__name(JsonNull, \"JsonNull\");\nvar AnyNull = class extends NullTypesEnumValue {\n};\n__name(AnyNull, \"AnyNull\");\nvar objectEnumValues = {\n  classes: {\n    DbNull,\n    JsonNull,\n    AnyNull\n  },\n  instances: {\n    DbNull: new DbNull(secret),\n    JsonNull: new JsonNull(secret),\n    AnyNull: new AnyNull(secret)\n  }\n};\n\n// src/runtime/utils/decimalJsLike.ts\nfunction isDecimalJsLike(value) {\n  if (Decimal.isDecimal(value)) {\n    return true;\n  }\n  return value !== null && typeof value === \"object\" && typeof value.s === \"number\" && typeof value.e === \"number\" && Array.isArray(value.d);\n}\n__name(isDecimalJsLike, \"isDecimalJsLike\");\nfunction stringifyDecimalJsLike(value) {\n  if (Decimal.isDecimal(value)) {\n    return String(value);\n  }\n  const tmpDecimal = new Decimal(0);\n  tmpDecimal.d = value.d;\n  tmpDecimal.e = value.e;\n  tmpDecimal.s = value.s;\n  return String(tmpDecimal);\n}\n__name(stringifyDecimalJsLike, \"stringifyDecimalJsLike\");\n\n// src/runtime/utils/common.ts\nvar keyBy = /* @__PURE__ */ __name((collection, prop) => {\n  const acc = {};\n  for (const obj of collection) {\n    const key = obj[prop];\n    acc[key] = obj;\n  }\n  return acc;\n}, \"keyBy\");\nvar ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Decimal: true,\n  BigInt: true\n};\nvar JSTypeToGraphQLType = {\n  string: \"String\",\n  boolean: \"Boolean\",\n  object: \"Json\",\n  symbol: \"Symbol\"\n};\nfunction stringifyGraphQLType(type) {\n  if (typeof type === \"string\") {\n    return type;\n  }\n  return type.name;\n}\n__name(stringifyGraphQLType, \"stringifyGraphQLType\");\nfunction wrapWithList(str, isList) {\n  if (isList) {\n    return `List<${str}>`;\n  }\n  return str;\n}\n__name(wrapWithList, \"wrapWithList\");\nvar RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\nvar UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nfunction getGraphQLType(value, inputType) {\n  const potentialType = inputType == null ? void 0 : inputType.type;\n  if (value === null) {\n    return \"null\";\n  }\n  if (Object.prototype.toString.call(value) === \"[object BigInt]\") {\n    return \"BigInt\";\n  }\n  if (decimal_default.isDecimal(value)) {\n    return \"Decimal\";\n  }\n  if (potentialType === \"Decimal\" && isDecimalJsLike(value)) {\n    return \"Decimal\";\n  }\n  if (Buffer.isBuffer(value)) {\n    return \"Bytes\";\n  }\n  if (isValidEnumValue(value, inputType)) {\n    return potentialType.name;\n  }\n  if (value instanceof ObjectEnumValue) {\n    return value._getName();\n  }\n  if (value instanceof FieldRefImpl) {\n    return value._toGraphQLInputType();\n  }\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, inputType);\n      if (!acc.includes(type)) {\n        acc.push(type);\n      }\n      return acc;\n    }, []);\n    if (scalarTypes.includes(\"Float\") && scalarTypes.includes(\"Int\")) {\n      scalarTypes = [\"Float\"];\n    }\n    return `List<${scalarTypes.join(\" | \")}>`;\n  }\n  const jsType = typeof value;\n  if (jsType === \"number\") {\n    if (Math.trunc(value) === value) {\n      return \"Int\";\n    } else {\n      return \"Float\";\n    }\n  }\n  if (Object.prototype.toString.call(value) === \"[object Date]\") {\n    return \"DateTime\";\n  }\n  if (jsType === \"string\") {\n    if (UUID_REGEX.test(value)) {\n      return \"UUID\";\n    }\n    const date = new Date(value);\n    if (date.toString() === \"Invalid Date\") {\n      return \"String\";\n    }\n    if (RFC_3339_REGEX.test(value)) {\n      return \"DateTime\";\n    }\n  }\n  return JSTypeToGraphQLType[jsType];\n}\n__name(getGraphQLType, \"getGraphQLType\");\nfunction isValidEnumValue(value, inputType) {\n  var _a3;\n  const enumType = inputType == null ? void 0 : inputType.type;\n  if (!isSchemaEnum(enumType)) {\n    return false;\n  }\n  if ((inputType == null ? void 0 : inputType.namespace) === \"prisma\" && objectEnumNames.includes(enumType.name)) {\n    const name = (_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name;\n    return typeof name === \"string\" && objectEnumValues.instances[name] === value && enumType.values.includes(name);\n  }\n  return typeof value === \"string\" && enumType.values.includes(value);\n}\n__name(isValidEnumValue, \"isValidEnumValue\");\nfunction getSuggestion(str, possibilities) {\n  const bestMatch = possibilities.reduce(\n    (acc, curr) => {\n      const distance = (0, import_js_levenshtein.default)(str, curr);\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr\n        };\n      }\n      return acc;\n    },\n    {\n      distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),\n      str: null\n    }\n  );\n  return bestMatch.str;\n}\n__name(getSuggestion, \"getSuggestion\");\nfunction stringifyInputType(input, greenKeys = false) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  if (input.values) {\n    return `enum ${input.name} {\n${(0, import_indent_string.default)(input.values.join(\", \"), 2)}\n}`;\n  } else {\n    const body = (0, import_indent_string.default)(\n      input.fields.map((arg2) => {\n        const key = `${arg2.name}`;\n        const str = `${greenKeys ? import_chalk.default.green(key) : key}${arg2.isRequired ? \"\" : \"?\"}: ${import_chalk.default.white(\n          arg2.inputTypes.map((argType) => {\n            return wrapWithList(\n              argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type),\n              argType.isList\n            );\n          }).join(\" | \")\n        )}`;\n        if (!arg2.isRequired) {\n          return import_chalk.default.dim(str);\n        }\n        return str;\n      }).join(\"\\n\"),\n      2\n    );\n    return `${import_chalk.default.dim(\"type\")} ${import_chalk.default.bold.dim(input.name)} ${import_chalk.default.dim(\"{\")}\n${body}\n${import_chalk.default.dim(\"}\")}`;\n  }\n}\n__name(stringifyInputType, \"stringifyInputType\");\nfunction argIsInputType(arg2) {\n  if (typeof arg2 === \"string\") {\n    return false;\n  }\n  return true;\n}\n__name(argIsInputType, \"argIsInputType\");\nfunction getInputTypeName(input) {\n  if (typeof input === \"string\") {\n    if (input === \"Null\") {\n      return \"null\";\n    }\n    return input;\n  }\n  return input.name;\n}\n__name(getInputTypeName, \"getInputTypeName\");\nfunction getOutputTypeName(input) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  return input.name;\n}\n__name(getOutputTypeName, \"getOutputTypeName\");\nfunction inputTypeToJson(input, isRequired, nameOnly = false) {\n  if (typeof input === \"string\") {\n    if (input === \"Null\") {\n      return \"null\";\n    }\n    return input;\n  }\n  if (input.values) {\n    return input.values.join(\" | \");\n  }\n  const inputType = input;\n  const showDeepType = isRequired && inputType.fields.every(\n    (arg2) => {\n      var _a3;\n      return arg2.inputTypes[0].location === \"inputObjectTypes\" || ((_a3 = arg2.inputTypes[1]) == null ? void 0 : _a3.location) === \"inputObjectTypes\";\n    }\n  );\n  if (nameOnly) {\n    return getInputTypeName(input);\n  }\n  return inputType.fields.reduce((acc, curr) => {\n    let str = \"\";\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(\" | \");\n    } else {\n      str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(\" | \");\n    }\n    acc[curr.name + (curr.isRequired ? \"\" : \"?\")] = str;\n    return acc;\n  }, {});\n}\n__name(inputTypeToJson, \"inputTypeToJson\");\nfunction unionBy(arr1, arr2, iteratee) {\n  const map = {};\n  for (const element of arr1) {\n    map[iteratee(element)] = element;\n  }\n  for (const element of arr2) {\n    const key = iteratee(element);\n    if (!map[key]) {\n      map[key] = element;\n    }\n  }\n  return Object.values(map);\n}\n__name(unionBy, \"unionBy\");\nfunction lowerCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\n__name(lowerCase, \"lowerCase\");\nfunction isGroupByOutputName(type) {\n  return type.endsWith(\"GroupByOutputType\");\n}\n__name(isGroupByOutputName, \"isGroupByOutputName\");\nfunction isSchemaEnum(type) {\n  return typeof type === \"object\" && type !== null && typeof type.name === \"string\" && Array.isArray(type.values);\n}\n__name(isSchemaEnum, \"isSchemaEnum\");\n\n// src/runtime/dmmf.ts\nvar DMMFDatamodelHelper = class {\n  constructor({ datamodel }) {\n    this.datamodel = datamodel;\n    this.datamodelEnumMap = this.getDatamodelEnumMap();\n    this.modelMap = this.getModelMap();\n    this.typeMap = this.getTypeMap();\n    this.typeAndModelMap = this.getTypeModelMap();\n  }\n  getDatamodelEnumMap() {\n    return keyBy(this.datamodel.enums, \"name\");\n  }\n  getModelMap() {\n    return { ...keyBy(this.datamodel.models, \"name\") };\n  }\n  getTypeMap() {\n    return { ...keyBy(this.datamodel.types, \"name\") };\n  }\n  getTypeModelMap() {\n    return { ...this.getTypeMap(), ...this.getModelMap() };\n  }\n};\n__name(DMMFDatamodelHelper, \"DMMFDatamodelHelper\");\nvar DMMFMappingsHelper = class {\n  constructor({ mappings }) {\n    this.mappings = mappings;\n    this.mappingsMap = this.getMappingsMap();\n  }\n  getMappingsMap() {\n    return keyBy(this.mappings.modelOperations, \"model\");\n  }\n};\n__name(DMMFMappingsHelper, \"DMMFMappingsHelper\");\nvar DMMFSchemaHelper = class {\n  constructor({ schema }) {\n    this.outputTypeToMergedOutputType = /* @__PURE__ */ __name((outputType) => {\n      return {\n        ...outputType,\n        fields: outputType.fields\n      };\n    }, \"outputTypeToMergedOutputType\");\n    this.schema = schema;\n    this.enumMap = this.getEnumMap();\n    this.queryType = this.getQueryType();\n    this.mutationType = this.getMutationType();\n    this.outputTypes = this.getOutputTypes();\n    this.outputTypeMap = this.getMergedOutputTypeMap();\n    this.resolveOutputTypes();\n    this.inputObjectTypes = this.schema.inputObjectTypes;\n    this.inputTypeMap = this.getInputTypeMap();\n    this.resolveInputTypes();\n    this.resolveFieldArgumentTypes();\n    this.queryType = this.outputTypeMap.Query;\n    this.mutationType = this.outputTypeMap.Mutation;\n    this.rootFieldMap = this.getRootFieldMap();\n  }\n  get [Symbol.toStringTag]() {\n    return \"DMMFClass\";\n  }\n  resolveOutputTypes() {\n    for (const type of this.outputTypes.model) {\n      for (const field of type.fields) {\n        if (typeof field.outputType.type === \"string\" && !ScalarTypeTable[field.outputType.type]) {\n          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n    for (const type of this.outputTypes.prisma) {\n      for (const field of type.fields) {\n        if (typeof field.outputType.type === \"string\" && !ScalarTypeTable[field.outputType.type]) {\n          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n  }\n  resolveInputTypes() {\n    const inputTypes = this.inputObjectTypes.prisma;\n    if (this.inputObjectTypes.model) {\n      inputTypes.push(...this.inputObjectTypes.model);\n    }\n    for (const type of inputTypes) {\n      for (const field of type.fields) {\n        for (const fieldInputType of field.inputTypes) {\n          const fieldType = fieldInputType.type;\n          if (typeof fieldType === \"string\" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {\n            fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;\n          }\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n  }\n  resolveFieldArgumentTypes() {\n    for (const type of this.outputTypes.prisma) {\n      for (const field of type.fields) {\n        for (const arg2 of field.args) {\n          for (const argInputType of arg2.inputTypes) {\n            const argType = argInputType.type;\n            if (typeof argType === \"string\" && !ScalarTypeTable[argType]) {\n              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;\n            }\n          }\n        }\n      }\n    }\n    for (const type of this.outputTypes.model) {\n      for (const field of type.fields) {\n        for (const arg2 of field.args) {\n          for (const argInputType of arg2.inputTypes) {\n            const argType = argInputType.type;\n            if (typeof argType === \"string\" && !ScalarTypeTable[argType]) {\n              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;\n            }\n          }\n        }\n      }\n    }\n  }\n  getQueryType() {\n    return this.schema.outputObjectTypes.prisma.find((t) => t.name === \"Query\");\n  }\n  getMutationType() {\n    return this.schema.outputObjectTypes.prisma.find((t) => t.name === \"Mutation\");\n  }\n  getOutputTypes() {\n    return {\n      model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),\n      prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)\n    };\n  }\n  getEnumMap() {\n    return {\n      ...keyBy(this.schema.enumTypes.prisma, \"name\"),\n      ...this.schema.enumTypes.model ? keyBy(this.schema.enumTypes.model, \"name\") : void 0\n    };\n  }\n  hasEnumInNamespace(enumName, namespace) {\n    var _a3;\n    return ((_a3 = this.schema.enumTypes[namespace]) == null ? void 0 : _a3.find((schemaEnum) => schemaEnum.name === enumName)) !== void 0;\n  }\n  getMergedOutputTypeMap() {\n    return {\n      ...keyBy(this.outputTypes.model, \"name\"),\n      ...keyBy(this.outputTypes.prisma, \"name\")\n    };\n  }\n  getInputTypeMap() {\n    return {\n      ...this.schema.inputObjectTypes.model ? keyBy(this.schema.inputObjectTypes.model, \"name\") : void 0,\n      ...keyBy(this.schema.inputObjectTypes.prisma, \"name\")\n    };\n  }\n  getRootFieldMap() {\n    return { ...keyBy(this.queryType.fields, \"name\"), ...keyBy(this.mutationType.fields, \"name\") };\n  }\n};\n__name(DMMFSchemaHelper, \"DMMFSchemaHelper\");\nvar BaseDMMFHelper = class {\n  constructor(dmmf) {\n    return Object.assign(this, new DMMFDatamodelHelper(dmmf), new DMMFMappingsHelper(dmmf));\n  }\n};\n__name(BaseDMMFHelper, \"BaseDMMFHelper\");\napplyMixins(BaseDMMFHelper, [DMMFDatamodelHelper, DMMFMappingsHelper]);\nvar DMMFHelper = class {\n  constructor(dmmf) {\n    return Object.assign(this, new BaseDMMFHelper(dmmf), new DMMFSchemaHelper(dmmf));\n  }\n};\n__name(DMMFHelper, \"DMMFHelper\");\napplyMixins(DMMFHelper, [BaseDMMFHelper, DMMFSchemaHelper]);\n\n// ../generator-helper/src/dmmf.ts\nvar DMMF;\n((DMMF2) => {\n  let ModelAction;\n  ((ModelAction2) => {\n    ModelAction2[\"findUnique\"] = \"findUnique\";\n    ModelAction2[\"findFirst\"] = \"findFirst\";\n    ModelAction2[\"findMany\"] = \"findMany\";\n    ModelAction2[\"create\"] = \"create\";\n    ModelAction2[\"createMany\"] = \"createMany\";\n    ModelAction2[\"update\"] = \"update\";\n    ModelAction2[\"updateMany\"] = \"updateMany\";\n    ModelAction2[\"upsert\"] = \"upsert\";\n    ModelAction2[\"delete\"] = \"delete\";\n    ModelAction2[\"deleteMany\"] = \"deleteMany\";\n    ModelAction2[\"groupBy\"] = \"groupBy\";\n    ModelAction2[\"count\"] = \"count\";\n    ModelAction2[\"aggregate\"] = \"aggregate\";\n    ModelAction2[\"findRaw\"] = \"findRaw\";\n    ModelAction2[\"aggregateRaw\"] = \"aggregateRaw\";\n  })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));\n})(DMMF || (DMMF = {}));\n\n// ../debug/src/index.ts\nvar import_debug = __toESM(require_src());\nvar MAX_LOGS = 100;\nvar debugArgsHistory = [];\nvar _a, _b;\nif (typeof process !== \"undefined\" && typeof ((_a = process.stderr) == null ? void 0 : _a.write) !== \"function\") {\n  import_debug.default.log = (_b = console.debug) != null ? _b : console.log;\n}\nfunction debugCall(namespace) {\n  const debugNamespace = (0, import_debug.default)(namespace);\n  const call = Object.assign((...args) => {\n    debugNamespace.log = call.log;\n    if (args.length !== 0) {\n      debugArgsHistory.push([namespace, ...args]);\n    }\n    if (debugArgsHistory.length > MAX_LOGS) {\n      debugArgsHistory.shift();\n    }\n    return debugNamespace(\"\", ...args);\n  }, debugNamespace);\n  return call;\n}\n__name(debugCall, \"debugCall\");\nvar Debug = Object.assign(debugCall, import_debug.default);\nfunction getLogs(numChars = 7500) {\n  const output = debugArgsHistory.map(\n    (c) => c.map((item) => {\n      if (typeof item === \"string\") {\n        return item;\n      }\n      return JSON.stringify(item);\n    }).join(\" \")\n  ).join(\"\\n\");\n  if (output.length < numChars) {\n    return output;\n  }\n  return output.slice(-numChars);\n}\n__name(getLogs, \"getLogs\");\nvar src_default = Debug;\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js\nvar _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/version.js\nvar VERSION = \"1.1.0\";\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js\nvar re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\nfunction _makeCompatibilityCheck(ownVersion) {\n  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);\n  var rejectedVersions = /* @__PURE__ */ new Set();\n  var myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    return function() {\n      return false;\n    };\n  }\n  var ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4]\n  };\n  if (ownVersionParsed.prerelease != null) {\n    return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {\n      return globalVersion === ownVersion;\n    }, \"isExactmatch\");\n  }\n  function _reject(v) {\n    rejectedVersions.add(v);\n    return false;\n  }\n  __name(_reject, \"_reject\");\n  function _accept(v) {\n    acceptedVersions.add(v);\n    return true;\n  }\n  __name(_accept, \"_accept\");\n  return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n    var globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      return _reject(globalVersion);\n    }\n    var globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4]\n    };\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major === 0) {\n      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {\n        return _accept(globalVersion);\n      }\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n    return _reject(globalVersion);\n  }, \"isCompatible\");\n}\n__name(_makeCompatibilityCheck, \"_makeCompatibilityCheck\");\nvar isCompatible = _makeCompatibilityCheck(VERSION);\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js\nvar major = VERSION.split(\".\")[0];\nvar GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\"opentelemetry.js.api.\" + major);\nvar _global = _globalThis;\nfunction registerGlobal(type, instance, diag3, allowOverride) {\n  var _a3;\n  if (allowOverride === void 0) {\n    allowOverride = false;\n  }\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a3 !== void 0 ? _a3 : {\n    version: VERSION\n  };\n  if (!allowOverride && api[type]) {\n    var err = new Error(\"@opentelemetry/api: Attempted duplicate registration of API: \" + type);\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  if (api.version !== VERSION) {\n    var err = new Error(\"@opentelemetry/api: All API registration versions must match\");\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  api[type] = instance;\n  diag3.debug(\"@opentelemetry/api: Registered a global for \" + type + \" v\" + VERSION + \".\");\n  return true;\n}\n__name(registerGlobal, \"registerGlobal\");\nfunction getGlobal(type) {\n  var _a3, _b2;\n  var globalVersion = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a3 === void 0 ? void 0 : _a3.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === void 0 ? void 0 : _b2[type];\n}\n__name(getGlobal, \"getGlobal\");\nfunction unregisterGlobal(type, diag3) {\n  diag3.debug(\"@opentelemetry/api: Unregistering a global for \" + type + \" v\" + VERSION + \".\");\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n  if (api) {\n    delete api[type];\n  }\n}\n__name(unregisterGlobal, \"unregisterGlobal\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js\nvar DiagComponentLogger = function() {\n  function DiagComponentLogger2(props) {\n    this._namespace = props.namespace || \"DiagComponentLogger\";\n  }\n  __name(DiagComponentLogger2, \"DiagComponentLogger\");\n  DiagComponentLogger2.prototype.debug = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"debug\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.error = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"error\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.info = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"info\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.warn = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"warn\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.verbose = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"verbose\", this._namespace, args);\n  };\n  return DiagComponentLogger2;\n}();\nfunction logProxy(funcName, namespace, args) {\n  var logger2 = getGlobal(\"diag\");\n  if (!logger2) {\n    return;\n  }\n  args.unshift(namespace);\n  return logger2[funcName].apply(logger2, args);\n}\n__name(logProxy, \"logProxy\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/types.js\nvar DiagLogLevel;\n(function(DiagLogLevel2) {\n  DiagLogLevel2[DiagLogLevel2[\"NONE\"] = 0] = \"NONE\";\n  DiagLogLevel2[DiagLogLevel2[\"ERROR\"] = 30] = \"ERROR\";\n  DiagLogLevel2[DiagLogLevel2[\"WARN\"] = 50] = \"WARN\";\n  DiagLogLevel2[DiagLogLevel2[\"INFO\"] = 60] = \"INFO\";\n  DiagLogLevel2[DiagLogLevel2[\"DEBUG\"] = 70] = \"DEBUG\";\n  DiagLogLevel2[DiagLogLevel2[\"VERBOSE\"] = 80] = \"VERBOSE\";\n  DiagLogLevel2[DiagLogLevel2[\"ALL\"] = 9999] = \"ALL\";\n})(DiagLogLevel || (DiagLogLevel = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js\nfunction createLogLevelDiagLogger(maxLevel, logger2) {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n  logger2 = logger2 || {};\n  function _filterFunc(funcName, theLevel) {\n    var theFunc = logger2[funcName];\n    if (typeof theFunc === \"function\" && maxLevel >= theLevel) {\n      return theFunc.bind(logger2);\n    }\n    return function() {\n    };\n  }\n  __name(_filterFunc, \"_filterFunc\");\n  return {\n    error: _filterFunc(\"error\", DiagLogLevel.ERROR),\n    warn: _filterFunc(\"warn\", DiagLogLevel.WARN),\n    info: _filterFunc(\"info\", DiagLogLevel.INFO),\n    debug: _filterFunc(\"debug\", DiagLogLevel.DEBUG),\n    verbose: _filterFunc(\"verbose\", DiagLogLevel.VERBOSE)\n  };\n}\n__name(createLogLevelDiagLogger, \"createLogLevelDiagLogger\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/diag.js\nvar API_NAME = \"diag\";\nvar DiagAPI = function() {\n  function DiagAPI2() {\n    function _logProxy(funcName) {\n      return function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var logger2 = getGlobal(\"diag\");\n        if (!logger2)\n          return;\n        return logger2[funcName].apply(logger2, args);\n      };\n    }\n    __name(_logProxy, \"_logProxy\");\n    var self2 = this;\n    self2.setLogger = function(logger2, logLevel) {\n      var _a3, _b2;\n      if (logLevel === void 0) {\n        logLevel = DiagLogLevel.INFO;\n      }\n      if (logger2 === self2) {\n        var err = new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");\n        self2.error((_a3 = err.stack) !== null && _a3 !== void 0 ? _a3 : err.message);\n        return false;\n      }\n      var oldLogger = getGlobal(\"diag\");\n      var newLogger = createLogLevelDiagLogger(logLevel, logger2);\n      if (oldLogger) {\n        var stack = (_b2 = new Error().stack) !== null && _b2 !== void 0 ? _b2 : \"<failed to generate stacktrace>\";\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n      return registerGlobal(\"diag\", newLogger, self2, true);\n    };\n    self2.disable = function() {\n      unregisterGlobal(API_NAME, self2);\n    };\n    self2.createComponentLogger = function(options) {\n      return new DiagComponentLogger(options);\n    };\n    self2.verbose = _logProxy(\"verbose\");\n    self2.debug = _logProxy(\"debug\");\n    self2.info = _logProxy(\"info\");\n    self2.warn = _logProxy(\"warn\");\n    self2.error = _logProxy(\"error\");\n  }\n  __name(DiagAPI2, \"DiagAPI\");\n  DiagAPI2.instance = function() {\n    if (!this._instance) {\n      this._instance = new DiagAPI2();\n    }\n    return this._instance;\n  };\n  return DiagAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js\nvar BaggageImpl = function() {\n  function BaggageImpl2(entries) {\n    this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();\n  }\n  __name(BaggageImpl2, \"BaggageImpl\");\n  BaggageImpl2.prototype.getEntry = function(key) {\n    var entry = this._entries.get(key);\n    if (!entry) {\n      return void 0;\n    }\n    return Object.assign({}, entry);\n  };\n  BaggageImpl2.prototype.getAllEntries = function() {\n    return Array.from(this._entries.entries()).map(function(_a3) {\n      var k = _a3[0], v = _a3[1];\n      return [k, v];\n    });\n  };\n  BaggageImpl2.prototype.setEntry = function(key, entry) {\n    var newBaggage = new BaggageImpl2(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.removeEntry = function(key) {\n    var newBaggage = new BaggageImpl2(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.removeEntries = function() {\n    var keys2 = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      keys2[_i] = arguments[_i];\n    }\n    var newBaggage = new BaggageImpl2(this._entries);\n    for (var _a3 = 0, keys_1 = keys2; _a3 < keys_1.length; _a3++) {\n      var key = keys_1[_a3];\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.clear = function() {\n    return new BaggageImpl2();\n  };\n  return BaggageImpl2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js\nvar baggageEntryMetadataSymbol = Symbol(\"BaggageEntryMetadata\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/utils.js\nvar diag = DiagAPI.instance();\nfunction createBaggage(entries) {\n  if (entries === void 0) {\n    entries = {};\n  }\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n__name(createBaggage, \"createBaggage\");\nfunction baggageEntryMetadataFromString(str) {\n  if (typeof str !== \"string\") {\n    diag.error(\"Cannot create baggage metadata from unknown type: \" + typeof str);\n    str = \"\";\n  }\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString: function() {\n      return str;\n    }\n  };\n}\n__name(baggageEntryMetadataFromString, \"baggageEntryMetadataFromString\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js\nvar consoleMap = [\n  { n: \"error\", c: \"error\" },\n  { n: \"warn\", c: \"warn\" },\n  { n: \"info\", c: \"info\" },\n  { n: \"debug\", c: \"debug\" },\n  { n: \"verbose\", c: \"trace\" }\n];\nvar DiagConsoleLogger = function() {\n  function DiagConsoleLogger2() {\n    function _consoleFunc(funcName) {\n      return function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        if (console) {\n          var theFunc = console[funcName];\n          if (typeof theFunc !== \"function\") {\n            theFunc = console.log;\n          }\n          if (typeof theFunc === \"function\") {\n            return theFunc.apply(console, args);\n          }\n        }\n      };\n    }\n    __name(_consoleFunc, \"_consoleFunc\");\n    for (var i = 0; i < consoleMap.length; i++) {\n      this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);\n    }\n  }\n  __name(DiagConsoleLogger2, \"DiagConsoleLogger\");\n  return DiagConsoleLogger2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js\nvar defaultTextMapGetter = {\n  get: function(carrier, key) {\n    if (carrier == null) {\n      return void 0;\n    }\n    return carrier[key];\n  },\n  keys: function(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  }\n};\nvar defaultTextMapSetter = {\n  set: function(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n    carrier[key] = value;\n  }\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/context/context.js\nfunction createContextKey(description) {\n  return Symbol.for(description);\n}\n__name(createContextKey, \"createContextKey\");\nvar BaseContext = function() {\n  function BaseContext2(parentContext) {\n    var self2 = this;\n    self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();\n    self2.getValue = function(key) {\n      return self2._currentContext.get(key);\n    };\n    self2.setValue = function(key, value) {\n      var context3 = new BaseContext2(self2._currentContext);\n      context3._currentContext.set(key, value);\n      return context3;\n    };\n    self2.deleteValue = function(key) {\n      var context3 = new BaseContext2(self2._currentContext);\n      context3._currentContext.delete(key);\n      return context3;\n    };\n  }\n  __name(BaseContext2, \"BaseContext\");\n  return BaseContext2;\n}();\nvar ROOT_CONTEXT = new BaseContext();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js\nvar __spreadArray = function(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};\nvar NoopContextManager = function() {\n  function NoopContextManager2() {\n  }\n  __name(NoopContextManager2, \"NoopContextManager\");\n  NoopContextManager2.prototype.active = function() {\n    return ROOT_CONTEXT;\n  };\n  NoopContextManager2.prototype.with = function(_context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return fn.call.apply(fn, __spreadArray([thisArg], args));\n  };\n  NoopContextManager2.prototype.bind = function(_context, target) {\n    return target;\n  };\n  NoopContextManager2.prototype.enable = function() {\n    return this;\n  };\n  NoopContextManager2.prototype.disable = function() {\n    return this;\n  };\n  return NoopContextManager2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/context.js\nvar __spreadArray2 = function(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};\nvar API_NAME2 = \"context\";\nvar NOOP_CONTEXT_MANAGER = new NoopContextManager();\nvar ContextAPI = function() {\n  function ContextAPI2() {\n  }\n  __name(ContextAPI2, \"ContextAPI\");\n  ContextAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new ContextAPI2();\n    }\n    return this._instance;\n  };\n  ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {\n    return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());\n  };\n  ContextAPI2.prototype.active = function() {\n    return this._getContextManager().active();\n  };\n  ContextAPI2.prototype.with = function(context3, fn, thisArg) {\n    var _a3;\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return (_a3 = this._getContextManager()).with.apply(_a3, __spreadArray2([context3, fn, thisArg], args));\n  };\n  ContextAPI2.prototype.bind = function(context3, target) {\n    return this._getContextManager().bind(context3, target);\n  };\n  ContextAPI2.prototype._getContextManager = function() {\n    return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;\n  };\n  ContextAPI2.prototype.disable = function() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME2, DiagAPI.instance());\n  };\n  return ContextAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js\nvar TraceFlags;\n(function(TraceFlags2) {\n  TraceFlags2[TraceFlags2[\"NONE\"] = 0] = \"NONE\";\n  TraceFlags2[TraceFlags2[\"SAMPLED\"] = 1] = \"SAMPLED\";\n})(TraceFlags || (TraceFlags = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js\nvar INVALID_SPANID = \"0000000000000000\";\nvar INVALID_TRACEID = \"00000000000000000000000000000000\";\nvar INVALID_SPAN_CONTEXT = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js\nvar NonRecordingSpan = function() {\n  function NonRecordingSpan2(_spanContext) {\n    if (_spanContext === void 0) {\n      _spanContext = INVALID_SPAN_CONTEXT;\n    }\n    this._spanContext = _spanContext;\n  }\n  __name(NonRecordingSpan2, \"NonRecordingSpan\");\n  NonRecordingSpan2.prototype.spanContext = function() {\n    return this._spanContext;\n  };\n  NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setAttributes = function(_attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setStatus = function(_status) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.updateName = function(_name) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.end = function(_endTime) {\n  };\n  NonRecordingSpan2.prototype.isRecording = function() {\n    return false;\n  };\n  NonRecordingSpan2.prototype.recordException = function(_exception, _time) {\n  };\n  return NonRecordingSpan2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js\nvar SPAN_KEY = createContextKey(\"OpenTelemetry Context Key SPAN\");\nfunction getSpan(context3) {\n  return context3.getValue(SPAN_KEY) || void 0;\n}\n__name(getSpan, \"getSpan\");\nfunction setSpan(context3, span) {\n  return context3.setValue(SPAN_KEY, span);\n}\n__name(setSpan, \"setSpan\");\nfunction deleteSpan(context3) {\n  return context3.deleteValue(SPAN_KEY);\n}\n__name(deleteSpan, \"deleteSpan\");\nfunction setSpanContext(context3, spanContext) {\n  return setSpan(context3, new NonRecordingSpan(spanContext));\n}\n__name(setSpanContext, \"setSpanContext\");\nfunction getSpanContext(context3) {\n  var _a3;\n  return (_a3 = getSpan(context3)) === null || _a3 === void 0 ? void 0 : _a3.spanContext();\n}\n__name(getSpanContext, \"getSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js\nvar VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nvar VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\nfunction isValidTraceId(traceId) {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n__name(isValidTraceId, \"isValidTraceId\");\nfunction isValidSpanId(spanId) {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n__name(isValidSpanId, \"isValidSpanId\");\nfunction isSpanContextValid(spanContext) {\n  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);\n}\n__name(isSpanContextValid, \"isSpanContextValid\");\nfunction wrapSpanContext(spanContext) {\n  return new NonRecordingSpan(spanContext);\n}\n__name(wrapSpanContext, \"wrapSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js\nvar context = ContextAPI.getInstance();\nvar NoopTracer = function() {\n  function NoopTracer2() {\n  }\n  __name(NoopTracer2, \"NoopTracer\");\n  NoopTracer2.prototype.startSpan = function(name, options, context3) {\n    var root = Boolean(options === null || options === void 0 ? void 0 : options.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n    var parentFromContext = context3 && getSpanContext(context3);\n    if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  };\n  NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = setSpan(parentContext, span);\n    return context.with(contextWithSpanSet, fn, void 0, span);\n  };\n  return NoopTracer2;\n}();\nfunction isSpanContext(spanContext) {\n  return typeof spanContext === \"object\" && typeof spanContext[\"spanId\"] === \"string\" && typeof spanContext[\"traceId\"] === \"string\" && typeof spanContext[\"traceFlags\"] === \"number\";\n}\n__name(isSpanContext, \"isSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js\nvar NOOP_TRACER = new NoopTracer();\nvar ProxyTracer = function() {\n  function ProxyTracer2(_provider, name, version, options) {\n    this._provider = _provider;\n    this.name = name;\n    this.version = version;\n    this.options = options;\n  }\n  __name(ProxyTracer2, \"ProxyTracer\");\n  ProxyTracer2.prototype.startSpan = function(name, options, context3) {\n    return this._getTracer().startSpan(name, options, context3);\n  };\n  ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {\n    var tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  };\n  ProxyTracer2.prototype._getTracer = function() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n    var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n    this._delegate = tracer;\n    return this._delegate;\n  };\n  return ProxyTracer2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js\nvar NoopTracerProvider = function() {\n  function NoopTracerProvider2() {\n  }\n  __name(NoopTracerProvider2, \"NoopTracerProvider\");\n  NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {\n    return new NoopTracer();\n  };\n  return NoopTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js\nvar NOOP_TRACER_PROVIDER = new NoopTracerProvider();\nvar ProxyTracerProvider = function() {\n  function ProxyTracerProvider2() {\n  }\n  __name(ProxyTracerProvider2, \"ProxyTracerProvider\");\n  ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {\n    var _a3;\n    return (_a3 = this.getDelegateTracer(name, version, options)) !== null && _a3 !== void 0 ? _a3 : new ProxyTracer(this, name, version, options);\n  };\n  ProxyTracerProvider2.prototype.getDelegate = function() {\n    var _a3;\n    return (_a3 = this._delegate) !== null && _a3 !== void 0 ? _a3 : NOOP_TRACER_PROVIDER;\n  };\n  ProxyTracerProvider2.prototype.setDelegate = function(delegate) {\n    this._delegate = delegate;\n  };\n  ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {\n    var _a3;\n    return (_a3 = this._delegate) === null || _a3 === void 0 ? void 0 : _a3.getTracer(name, version, options);\n  };\n  return ProxyTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js\nvar SamplingDecision;\n(function(SamplingDecision3) {\n  SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n})(SamplingDecision || (SamplingDecision = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/span_kind.js\nvar SpanKind;\n(function(SpanKind2) {\n  SpanKind2[SpanKind2[\"INTERNAL\"] = 0] = \"INTERNAL\";\n  SpanKind2[SpanKind2[\"SERVER\"] = 1] = \"SERVER\";\n  SpanKind2[SpanKind2[\"CLIENT\"] = 2] = \"CLIENT\";\n  SpanKind2[SpanKind2[\"PRODUCER\"] = 3] = \"PRODUCER\";\n  SpanKind2[SpanKind2[\"CONSUMER\"] = 4] = \"CONSUMER\";\n})(SpanKind || (SpanKind = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/status.js\nvar SpanStatusCode;\n(function(SpanStatusCode2) {\n  SpanStatusCode2[SpanStatusCode2[\"UNSET\"] = 0] = \"UNSET\";\n  SpanStatusCode2[SpanStatusCode2[\"OK\"] = 1] = \"OK\";\n  SpanStatusCode2[SpanStatusCode2[\"ERROR\"] = 2] = \"ERROR\";\n})(SpanStatusCode || (SpanStatusCode = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js\nvar VALID_KEY_CHAR_RANGE = \"[_0-9a-z-*/]\";\nvar VALID_KEY = \"[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,255}\";\nvar VALID_VENDOR_KEY = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,13}\";\nvar VALID_KEY_REGEX = new RegExp(\"^(?:\" + VALID_KEY + \"|\" + VALID_VENDOR_KEY + \")$\");\nvar VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nvar INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\nfunction validateKey(key) {\n  return VALID_KEY_REGEX.test(key);\n}\n__name(validateKey, \"validateKey\");\nfunction validateValue(value) {\n  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);\n}\n__name(validateValue, \"validateValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js\nvar MAX_TRACE_STATE_ITEMS = 32;\nvar MAX_TRACE_STATE_LEN = 512;\nvar LIST_MEMBERS_SEPARATOR = \",\";\nvar LIST_MEMBER_KEY_VALUE_SPLITTER = \"=\";\nvar TraceStateImpl = function() {\n  function TraceStateImpl2(rawTraceState) {\n    this._internalState = /* @__PURE__ */ new Map();\n    if (rawTraceState)\n      this._parse(rawTraceState);\n  }\n  __name(TraceStateImpl2, \"TraceStateImpl\");\n  TraceStateImpl2.prototype.set = function(key, value) {\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceStateImpl2.prototype.unset = function(key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceStateImpl2.prototype.get = function(key) {\n    return this._internalState.get(key);\n  };\n  TraceStateImpl2.prototype.serialize = function() {\n    var _this = this;\n    return this._keys().reduce(function(agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  };\n  TraceStateImpl2.prototype._parse = function(rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN)\n      return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {\n      var listMember = part.trim();\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {\n        }\n      }\n      return agg;\n    }, /* @__PURE__ */ new Map());\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  };\n  TraceStateImpl2.prototype._keys = function() {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceStateImpl2.prototype._clone = function() {\n    var traceState = new TraceStateImpl2();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceStateImpl2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/trace.js\nvar API_NAME3 = \"trace\";\nvar TraceAPI = function() {\n  function TraceAPI2() {\n    this._proxyTracerProvider = new ProxyTracerProvider();\n    this.wrapSpanContext = wrapSpanContext;\n    this.isSpanContextValid = isSpanContextValid;\n    this.deleteSpan = deleteSpan;\n    this.getSpan = getSpan;\n    this.getSpanContext = getSpanContext;\n    this.setSpan = setSpan;\n    this.setSpanContext = setSpanContext;\n  }\n  __name(TraceAPI2, \"TraceAPI\");\n  TraceAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new TraceAPI2();\n    }\n    return this._instance;\n  };\n  TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {\n    var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  };\n  TraceAPI2.prototype.getTracerProvider = function() {\n    return getGlobal(API_NAME3) || this._proxyTracerProvider;\n  };\n  TraceAPI2.prototype.getTracer = function(name, version) {\n    return this.getTracerProvider().getTracer(name, version);\n  };\n  TraceAPI2.prototype.disable = function() {\n    unregisterGlobal(API_NAME3, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  };\n  return TraceAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js\nvar NoopTextMapPropagator = function() {\n  function NoopTextMapPropagator2() {\n  }\n  __name(NoopTextMapPropagator2, \"NoopTextMapPropagator\");\n  NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {\n  };\n  NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {\n    return context3;\n  };\n  NoopTextMapPropagator2.prototype.fields = function() {\n    return [];\n  };\n  return NoopTextMapPropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js\nvar BAGGAGE_KEY = createContextKey(\"OpenTelemetry Baggage Key\");\nfunction getBaggage(context3) {\n  return context3.getValue(BAGGAGE_KEY) || void 0;\n}\n__name(getBaggage, \"getBaggage\");\nfunction setBaggage(context3, baggage) {\n  return context3.setValue(BAGGAGE_KEY, baggage);\n}\n__name(setBaggage, \"setBaggage\");\nfunction deleteBaggage(context3) {\n  return context3.deleteValue(BAGGAGE_KEY);\n}\n__name(deleteBaggage, \"deleteBaggage\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/propagation.js\nvar API_NAME4 = \"propagation\";\nvar NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\nvar PropagationAPI = function() {\n  function PropagationAPI2() {\n    this.createBaggage = createBaggage;\n    this.getBaggage = getBaggage;\n    this.setBaggage = setBaggage;\n    this.deleteBaggage = deleteBaggage;\n  }\n  __name(PropagationAPI2, \"PropagationAPI\");\n  PropagationAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new PropagationAPI2();\n    }\n    return this._instance;\n  };\n  PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {\n    return registerGlobal(API_NAME4, propagator, DiagAPI.instance());\n  };\n  PropagationAPI2.prototype.inject = function(context3, carrier, setter) {\n    if (setter === void 0) {\n      setter = defaultTextMapSetter;\n    }\n    return this._getGlobalPropagator().inject(context3, carrier, setter);\n  };\n  PropagationAPI2.prototype.extract = function(context3, carrier, getter) {\n    if (getter === void 0) {\n      getter = defaultTextMapGetter;\n    }\n    return this._getGlobalPropagator().extract(context3, carrier, getter);\n  };\n  PropagationAPI2.prototype.fields = function() {\n    return this._getGlobalPropagator().fields();\n  };\n  PropagationAPI2.prototype.disable = function() {\n    unregisterGlobal(API_NAME4, DiagAPI.instance());\n  };\n  PropagationAPI2.prototype._getGlobalPropagator = function() {\n    return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;\n  };\n  return PropagationAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/index.js\nvar context2 = ContextAPI.getInstance();\nvar trace = TraceAPI.getInstance();\nvar propagation = PropagationAPI.getInstance();\nvar diag2 = DiagAPI.instance();\n\n// ../engines/src/index.ts\nvar import_engines_version = __toESM(require_engines_version());\n\n// ../get-platform/src/getNodeAPIName.ts\nvar NODE_API_QUERY_ENGINE_URL_BASE = \"libquery_engine\";\nfunction getNodeAPIName(platform3, type) {\n  const isUrl = type === \"url\";\n  if (platform3.includes(\"windows\")) {\n    return isUrl ? `query_engine.dll.node` : `query_engine-${platform3}.dll.node`;\n  } else if (platform3.includes(\"darwin\")) {\n    return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.dylib.node`;\n  } else {\n    return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.so.node`;\n  }\n}\n__name(getNodeAPIName, \"getNodeAPIName\");\n\n// ../get-platform/src/getPlatform.ts\nvar import_child_process = __webpack_require__(/*! child_process */ \"child_process\");\nvar import_fs = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_os = __toESM(__webpack_require__(/*! os */ \"os\"));\nvar import_util = __webpack_require__(/*! util */ \"util\");\nvar readFile = (0, import_util.promisify)(import_fs.default.readFile);\nvar exists = (0, import_util.promisify)(import_fs.default.exists);\nasync function getos() {\n  const platform3 = import_os.default.platform();\n  const arch2 = process.arch;\n  if (platform3 === \"freebsd\") {\n    const version = await gracefulExec(`freebsd-version`);\n    if (version && version.trim().length > 0) {\n      const regex = /^(\\d+)\\.?/;\n      const match = regex.exec(version);\n      if (match) {\n        return {\n          platform: \"freebsd\",\n          distro: `freebsd${match[1]}`,\n          arch: arch2\n        };\n      }\n    }\n  }\n  if (platform3 !== \"linux\") {\n    return {\n      platform: platform3,\n      arch: arch2\n    };\n  }\n  return {\n    platform: \"linux\",\n    libssl: await getOpenSSLVersion(),\n    distro: await resolveDistro(),\n    arch: arch2\n  };\n}\n__name(getos, \"getos\");\nfunction parseDistro(input) {\n  const idRegex = /^ID=\"?([^\"\\n]*)\"?$/im;\n  const idLikeRegex = /^ID_LIKE=\"?([^\"\\n]*)\"?$/im;\n  const idMatch = idRegex.exec(input);\n  const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || \"\";\n  const idLikeMatch = idLikeRegex.exec(input);\n  const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || \"\";\n  if (id === \"raspbian\") {\n    return \"arm\";\n  }\n  if (id === \"nixos\") {\n    return \"nixos\";\n  }\n  if (idLike.includes(\"centos\") || idLike.includes(\"fedora\") || idLike.includes(\"rhel\") || id === \"fedora\") {\n    return \"rhel\";\n  }\n  if (idLike.includes(\"debian\") || idLike.includes(\"ubuntu\") || id === \"debian\") {\n    return \"debian\";\n  }\n  return;\n}\n__name(parseDistro, \"parseDistro\");\nasync function resolveDistro() {\n  const osReleaseFile = \"/etc/os-release\";\n  const alpineReleaseFile = \"/etc/alpine-release\";\n  if (await exists(alpineReleaseFile)) {\n    return \"musl\";\n  } else if (await exists(osReleaseFile)) {\n    return parseDistro(await readFile(osReleaseFile, \"utf-8\"));\n  } else {\n    return;\n  }\n}\n__name(resolveDistro, \"resolveDistro\");\nfunction parseOpenSSLVersion(input) {\n  const match = /^OpenSSL\\s(\\d+\\.\\d+)\\.\\d+/.exec(input);\n  if (match) {\n    return match[1] + \".x\";\n  }\n  return;\n}\n__name(parseOpenSSLVersion, \"parseOpenSSLVersion\");\nasync function getOpenSSLVersion() {\n  const [version, ls] = await Promise.all([\n    gracefulExec(`openssl version -v`),\n    gracefulExec(`\n      ls -l /lib64 | grep ssl;\n      ls -l /usr/lib64 | grep ssl;\n    `)\n  ]);\n  if (version) {\n    const v = parseOpenSSLVersion(version);\n    if (v) {\n      return v;\n    }\n  }\n  if (ls) {\n    const match = /libssl\\.so\\.(\\d+\\.\\d+)\\.\\d+/.exec(ls);\n    if (match) {\n      return match[1] + \".x\";\n    }\n  }\n  return void 0;\n}\n__name(getOpenSSLVersion, \"getOpenSSLVersion\");\nasync function gracefulExec(cmd) {\n  return new Promise((resolve) => {\n    try {\n      (0, import_child_process.exec)(cmd, (err, stdout) => {\n        resolve(String(stdout));\n      });\n    } catch (e) {\n      resolve(void 0);\n      return void 0;\n    }\n    return void 0;\n  });\n}\n__name(gracefulExec, \"gracefulExec\");\nasync function getPlatform() {\n  const { platform: platform3, libssl, distro, arch: arch2 } = await getos();\n  if (platform3 === \"darwin\" && arch2 === \"arm64\") {\n    return \"darwin-arm64\";\n  }\n  if (platform3 === \"darwin\") {\n    return \"darwin\";\n  }\n  if (platform3 === \"win32\") {\n    return \"windows\";\n  }\n  if (platform3 === \"freebsd\") {\n    return distro;\n  }\n  if (platform3 === \"openbsd\") {\n    return \"openbsd\";\n  }\n  if (platform3 === \"netbsd\") {\n    return \"netbsd\";\n  }\n  if (platform3 === \"linux\" && arch2 === \"arm64\") {\n    return `linux-arm64-openssl-${libssl}`;\n  }\n  if (platform3 === \"linux\" && arch2 === \"arm\") {\n    return `linux-arm-openssl-${libssl}`;\n  }\n  if (platform3 === \"linux\" && distro === \"nixos\") {\n    return \"linux-nixos\";\n  }\n  if (platform3 === \"linux\" && distro === \"musl\") {\n    return \"linux-musl\";\n  }\n  if (platform3 === \"linux\" && distro && libssl) {\n    return distro + \"-openssl-\" + libssl;\n  }\n  if (libssl) {\n    return \"debian-openssl-\" + libssl;\n  }\n  if (distro) {\n    return distro + \"-openssl-1.1.x\";\n  }\n  return \"debian-openssl-1.1.x\";\n}\n__name(getPlatform, \"getPlatform\");\n\n// ../get-platform/src/isNodeAPISupported.ts\nvar import_fs2 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nasync function isNodeAPISupported() {\n  const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;\n  const customLibraryExists = customLibraryPath && import_fs2.default.existsSync(customLibraryPath);\n  const os3 = await getos();\n  if (!customLibraryExists && (os3.arch === \"x32\" || os3.arch === \"ia32\")) {\n    throw new Error(\n      `The default query engine type (Node-API, \"library\") is currently not supported for 32bit Node. Please set \\`engineType = \"binary\"\\` in the \"generator\" block of your \"schema.prisma\" file (or use the environment variables \"PRISMA_CLIENT_ENGINE_TYPE=binary\" and/or \"PRISMA_CLI_QUERY_ENGINE_TYPE=binary\".)`\n    );\n  }\n}\n__name(isNodeAPISupported, \"isNodeAPISupported\");\n\n// ../get-platform/src/platforms.ts\nvar platforms = [\n  \"darwin\",\n  \"darwin-arm64\",\n  \"debian-openssl-1.0.x\",\n  \"debian-openssl-1.1.x\",\n  \"debian-openssl-3.0.x\",\n  \"rhel-openssl-1.0.x\",\n  \"rhel-openssl-1.1.x\",\n  \"rhel-openssl-3.0.x\",\n  \"linux-arm64-openssl-1.1.x\",\n  \"linux-arm64-openssl-1.0.x\",\n  \"linux-arm64-openssl-3.0.x\",\n  \"linux-arm-openssl-1.1.x\",\n  \"linux-arm-openssl-1.0.x\",\n  \"linux-arm-openssl-3.0.x\",\n  \"linux-musl\",\n  \"linux-nixos\",\n  \"windows\",\n  \"freebsd11\",\n  \"freebsd12\",\n  \"freebsd13\",\n  \"openbsd\",\n  \"netbsd\",\n  \"arm\"\n];\n\n// ../engines/src/index.ts\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_engines_version2 = __toESM(require_engines_version());\nvar debug2 = src_default(\"prisma:engines\");\nfunction getEnginesPath() {\n  return import_path.default.join(__dirname, \"../\");\n}\n__name(getEnginesPath, \"getEnginesPath\");\nvar DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = \"libquery-engine\" /* libqueryEngine */;\nimport_path.default.join(__dirname, \"../query-engine-darwin\");\nimport_path.default.join(__dirname, \"../introspection-engine-darwin\");\nimport_path.default.join(__dirname, \"../prisma-fmt-darwin\");\nimport_path.default.join(__dirname, \"../query-engine-darwin-arm64\");\nimport_path.default.join(__dirname, \"../introspection-engine-darwin-arm64\");\nimport_path.default.join(__dirname, \"../prisma-fmt-darwin-arm64\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../libquery_engine-darwin.dylib.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-darwin-arm64.dylib.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-musl.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../query_engine-windows.dll.node\");\n\n// ../engine-core/src/binary/BinaryEngine.ts\nvar import_chalk3 = __toESM(require_source());\nvar import_child_process2 = __webpack_require__(/*! child_process */ \"child_process\");\nvar import_events = __toESM(__webpack_require__(/*! events */ \"events\"));\nvar import_execa = __toESM(require_execa());\nvar import_fs4 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_net = __toESM(__webpack_require__(/*! net */ \"net\"));\nvar import_p_retry = __toESM(require_p_retry());\nvar import_path2 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_url = __webpack_require__(/*! url */ \"url\");\nvar import_util4 = __webpack_require__(/*! util */ \"util\");\n\n// ../engine-core/src/common/Engine.ts\nvar Engine = class {\n};\n__name(Engine, \"Engine\");\n\n// ../engine-core/src/common/errors/PrismaClientInitializationError.ts\nvar PrismaClientInitializationError = class extends Error {\n  constructor(message, clientVersion2, errorCode) {\n    super(message);\n    this.clientVersion = clientVersion2;\n    this.errorCode = errorCode;\n    Error.captureStackTrace(PrismaClientInitializationError);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientInitializationError\";\n  }\n};\n__name(PrismaClientInitializationError, \"PrismaClientInitializationError\");\n\n// ../engine-core/src/common/errors/PrismaClientKnownRequestError.ts\nvar PrismaClientKnownRequestError = class extends Error {\n  constructor(message, code, clientVersion2, meta) {\n    super(message);\n    this.code = code;\n    this.clientVersion = clientVersion2;\n    this.meta = meta;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientKnownRequestError\";\n  }\n};\n__name(PrismaClientKnownRequestError, \"PrismaClientKnownRequestError\");\n\n// ../engine-core/src/common/errors/utils/log.ts\nfunction getMessage(log4) {\n  if (typeof log4 === \"string\") {\n    return log4;\n  } else if (isRustError(log4)) {\n    return getBacktraceFromRustError(log4);\n  } else if (isRustLog(log4)) {\n    return getBacktraceFromLog(log4);\n  }\n  return JSON.stringify(log4);\n}\n__name(getMessage, \"getMessage\");\nfunction getBacktraceFromLog(log4) {\n  var _a3, _b2, _c, _d, _e, _f, _g;\n  if ((_a3 = log4.fields) == null ? void 0 : _a3.message) {\n    let str = (_b2 = log4.fields) == null ? void 0 : _b2.message;\n    if ((_c = log4.fields) == null ? void 0 : _c.file) {\n      str += ` in ${log4.fields.file}`;\n      if ((_d = log4.fields) == null ? void 0 : _d.line) {\n        str += `:${log4.fields.line}`;\n      }\n      if ((_e = log4.fields) == null ? void 0 : _e.column) {\n        str += `:${log4.fields.column}`;\n      }\n    }\n    if ((_f = log4.fields) == null ? void 0 : _f.reason) {\n      str += `\n${(_g = log4.fields) == null ? void 0 : _g.reason}`;\n    }\n    return str;\n  }\n  return \"Unknown error\";\n}\n__name(getBacktraceFromLog, \"getBacktraceFromLog\");\nfunction getBacktraceFromRustError(err) {\n  let str = \"\";\n  if (err.is_panic) {\n    str += `PANIC`;\n  }\n  if (err.backtrace) {\n    str += ` in ${err.backtrace}`;\n  }\n  if (err.message) {\n    str += `\n${err.message}`;\n  }\n  return str;\n}\n__name(getBacktraceFromRustError, \"getBacktraceFromRustError\");\nfunction isRustLog(e) {\n  return e.timestamp && typeof e.level === \"string\" && typeof e.target === \"string\";\n}\n__name(isRustLog, \"isRustLog\");\nfunction isRustErrorLog(e) {\n  var _a3, _b2;\n  return isRustLog(e) && (e.level === \"error\" || ((_b2 = (_a3 = e.fields) == null ? void 0 : _a3.message) == null ? void 0 : _b2.includes(\"fatal error\")));\n}\n__name(isRustErrorLog, \"isRustErrorLog\");\nfunction isRustError(e) {\n  return typeof e.is_panic !== \"undefined\";\n}\n__name(isRustError, \"isRustError\");\nfunction convertLog(rustLog) {\n  const isQuery = isQueryLog(rustLog.fields);\n  const level = isQuery ? \"query\" : rustLog.level.toLowerCase();\n  return {\n    ...rustLog,\n    level,\n    timestamp: new Date(rustLog.timestamp)\n  };\n}\n__name(convertLog, \"convertLog\");\nfunction isQueryLog(fields) {\n  return Boolean(fields.query);\n}\n__name(isQueryLog, \"isQueryLog\");\n\n// ../engine-core/src/common/errors/PrismaClientRustError.ts\nvar PrismaClientRustError = class extends Error {\n  constructor({ clientVersion: clientVersion2, log: log4, error: error2 }) {\n    var __super = (...args) => {\n      super(...args);\n    };\n    if (log4) {\n      const backtrace = getBacktraceFromLog(log4);\n      __super(backtrace != null ? backtrace : \"Unknown error\");\n    } else if (error2) {\n      const backtrace = getBacktraceFromRustError(error2);\n      __super(backtrace);\n    } else {\n      __super(`Unknown error`);\n    }\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\n__name(PrismaClientRustError, \"PrismaClientRustError\");\n\n// ../engine-core/src/common/errors/PrismaClientRustPanicError.ts\nvar PrismaClientRustPanicError = class extends Error {\n  constructor(message, clientVersion2) {\n    super(message);\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\n__name(PrismaClientRustPanicError, \"PrismaClientRustPanicError\");\n\n// ../engine-core/src/common/errors/PrismaClientUnknownRequestError.ts\nvar PrismaClientUnknownRequestError = class extends Error {\n  constructor(message, clientVersion2) {\n    super(message);\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientUnknownRequestError\";\n  }\n};\n__name(PrismaClientUnknownRequestError, \"PrismaClientUnknownRequestError\");\n\n// ../engine-core/src/common/errors/utils/getErrorMessageWithLink.ts\nvar import_chalk2 = __toESM(require_source());\nvar import_strip_ansi = __toESM(require_strip_ansi());\n\n// ../engine-core/src/common/utils/util.ts\nvar import_fs3 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_new_github_issue_url = __toESM(require_new_github_issue_url());\nvar debug3 = src_default(\"plusX\");\nfunction plusX(file) {\n  const s = import_fs3.default.statSync(file);\n  const newMode = s.mode | 64 | 8 | 1;\n  if (s.mode === newMode) {\n    debug3(`Execution permissions of ${file} are fine`);\n    return;\n  }\n  const base8 = newMode.toString(8).slice(-3);\n  debug3(`Have to call plusX on ${file}`);\n  import_fs3.default.chmodSync(file, base8);\n}\n__name(plusX, \"plusX\");\nfunction transformPlatformToEnvValue(platform3) {\n  return { fromEnvVar: null, value: platform3 };\n}\n__name(transformPlatformToEnvValue, \"transformPlatformToEnvValue\");\nfunction fixBinaryTargets(binaryTargets, platform3) {\n  binaryTargets = binaryTargets || [];\n  if (!binaryTargets.find((object) => object.value === \"native\")) {\n    return [transformPlatformToEnvValue(\"native\"), ...binaryTargets];\n  }\n  return [...binaryTargets, transformPlatformToEnvValue(platform3)];\n}\n__name(fixBinaryTargets, \"fixBinaryTargets\");\nfunction getGithubIssueUrl({\n  title,\n  user = \"prisma\",\n  repo = \"prisma\",\n  template = \"bug_report.md\",\n  body\n}) {\n  return (0, import_new_github_issue_url.default)({\n    user,\n    repo,\n    template,\n    title,\n    body\n  });\n}\n__name(getGithubIssueUrl, \"getGithubIssueUrl\");\n\n// ../engine-core/src/common/errors/utils/maskQuery.ts\nfunction maskQuery(query2) {\n  if (!query2) {\n    return \"\";\n  }\n  return query2.replace(/\".*\"/g, '\"X\"').replace(/[\\s:\\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {\n    return `${substr[0]}5`;\n  });\n}\n__name(maskQuery, \"maskQuery\");\n\n// ../engine-core/src/common/errors/utils/normalizeLogs.ts\nfunction normalizeLogs(logs) {\n  return logs.split(\"\\n\").map((l) => {\n    return l.replace(/^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)\\s*/, \"\").replace(/\\+\\d+\\s*ms$/, \"\");\n  }).join(\"\\n\");\n}\n__name(normalizeLogs, \"normalizeLogs\");\n\n// ../engine-core/src/common/errors/utils/getErrorMessageWithLink.ts\nfunction getErrorMessageWithLink({\n  version,\n  platform: platform3,\n  title,\n  description,\n  engineVersion,\n  database,\n  query: query2\n}) {\n  var _a3, _b2;\n  const gotLogs = getLogs(6e3 - ((_a3 = query2 == null ? void 0 : query2.length) != null ? _a3 : 0));\n  const logs = normalizeLogs((0, import_strip_ansi.default)(gotLogs));\n  const moreInfo = description ? `# Description\n\\`\\`\\`\n${description}\n\\`\\`\\`` : \"\";\n  const body = (0, import_strip_ansi.default)(\n    `Hi Prisma Team! My Prisma Client just crashed. This is the report:\n## Versions\n\n| Name            | Version            |\n|-----------------|--------------------|\n| Node            | ${(_b2 = process.version) == null ? void 0 : _b2.padEnd(19)}| \n| OS              | ${platform3 == null ? void 0 : platform3.padEnd(19)}|\n| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|\n| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|\n| Database        | ${database == null ? void 0 : database.padEnd(19)}|\n\n${moreInfo}\n\n## Logs\n\\`\\`\\`\n${logs}\n\\`\\`\\`\n\n## Client Snippet\n\\`\\`\\`ts\n// PLEASE FILL YOUR CODE SNIPPET HERE\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`prisma\n// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE\n\\`\\`\\`\n\n## Prisma Engine Query\n\\`\\`\\`\n${query2 ? maskQuery(query2) : \"\"}\n\\`\\`\\`\n`\n  );\n  const url = getGithubIssueUrl({ title, body });\n  return `${title}\n\nThis is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.\n\n${import_chalk2.default.underline(url)}\n\nIf you want the Prisma team to look into it, please open the link above \\u{1F64F}\nTo increase the chance of success, please post your schema and a snippet of\nhow you used Prisma Client in the issue. \n`;\n}\n__name(getErrorMessageWithLink, \"getErrorMessageWithLink\");\n\n// ../engine-core/src/common/errors/utils/prismaGraphQLToJSError.ts\nfunction prismaGraphQLToJSError(error2, clientVersion2) {\n  if (error2.user_facing_error.error_code) {\n    return new PrismaClientKnownRequestError(\n      error2.user_facing_error.message,\n      error2.user_facing_error.error_code,\n      clientVersion2,\n      error2.user_facing_error.meta\n    );\n  }\n  return new PrismaClientUnknownRequestError(error2.error, clientVersion2);\n}\n__name(prismaGraphQLToJSError, \"prismaGraphQLToJSError\");\n\n// ../engine-core/src/common/utils/printGeneratorConfig.ts\nvar import_indent_string2 = __toESM(require_indent_string());\nfunction printGeneratorConfig(config2) {\n  return String(new GeneratorConfigClass(config2));\n}\n__name(printGeneratorConfig, \"printGeneratorConfig\");\nvar GeneratorConfigClass = class {\n  constructor(config2) {\n    this.config = config2;\n  }\n  toString() {\n    const { config: config2 } = this;\n    const provider = config2.provider.fromEnvVar ? `env(\"${config2.provider.fromEnvVar}\")` : config2.provider.value;\n    const obj = JSON.parse(\n      JSON.stringify({\n        provider,\n        binaryTargets: getOriginalBinaryTargetsValue(config2.binaryTargets)\n      })\n    );\n    return `generator ${config2.name} {\n${(0, import_indent_string2.default)(printDatamodelObject(obj), 2)}\n}`;\n  }\n};\n__name(GeneratorConfigClass, \"GeneratorConfigClass\");\nfunction getOriginalBinaryTargetsValue(binaryTargets) {\n  let value;\n  if (binaryTargets.length > 0) {\n    const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);\n    if (binaryTargetsFromEnvVar) {\n      value = `env(\"${binaryTargetsFromEnvVar.fromEnvVar}\")`;\n    } else {\n      value = binaryTargets.map((object) => object.value);\n    }\n  } else {\n    value = void 0;\n  }\n  return value;\n}\n__name(getOriginalBinaryTargetsValue, \"getOriginalBinaryTargetsValue\");\nfunction printDatamodelObject(obj) {\n  const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);\n  return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join(\"\\n\");\n}\n__name(printDatamodelObject, \"printDatamodelObject\");\nfunction niceStringify(value) {\n  return JSON.parse(\n    JSON.stringify(value, (_, value2) => {\n      if (Array.isArray(value2)) {\n        return `[${value2.map((element) => JSON.stringify(element)).join(\", \")}]`;\n      }\n      return JSON.stringify(value2);\n    })\n  );\n}\n__name(niceStringify, \"niceStringify\");\n\n// ../engine-core/src/tools/byline.ts\nvar import_stream = __toESM(__webpack_require__(/*! stream */ \"stream\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nfunction byline(readStream, options) {\n  return createStream(readStream, options);\n}\n__name(byline, \"byline\");\nfunction createStream(readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options);\n  } else {\n    return new LineStream(options);\n  }\n}\n__name(createStream, \"createStream\");\nfunction createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error(\"expected readStream\");\n  }\n  if (!readStream.readable) {\n    throw new Error(\"readStream must be readable\");\n  }\n  const ls = new LineStream(options);\n  readStream.pipe(ls);\n  return ls;\n}\n__name(createLineStream, \"createLineStream\");\nfunction LineStream(options) {\n  import_stream.default.Transform.call(this, options);\n  options = options || {};\n  this._readableState.objectMode = true;\n  this._lineBuffer = [];\n  this._keepEmptyLines = options.keepEmptyLines || false;\n  this._lastChunkEndedWithCR = false;\n  this.on(\"pipe\", function(src) {\n    if (!this.encoding) {\n      if (src instanceof import_stream.default.Readable) {\n        this.encoding = src._readableState.encoding;\n      }\n    }\n  });\n}\n__name(LineStream, \"LineStream\");\nimport_util3.default.inherits(LineStream, import_stream.default.Transform);\nLineStream.prototype._transform = function(chunk, encoding, done) {\n  encoding = encoding || \"utf8\";\n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == \"buffer\") {\n      chunk = chunk.toString();\n      encoding = \"utf8\";\n    } else {\n      chunk = chunk.toString(encoding);\n    }\n  }\n  this._chunkEncoding = encoding;\n  const lines = chunk.split(/\\r\\n|\\r|\\n/g);\n  if (this._lastChunkEndedWithCR && chunk[0] == \"\\n\") {\n    lines.shift();\n  }\n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];\n    lines.shift();\n  }\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == \"\\r\";\n  this._lineBuffer = this._lineBuffer.concat(lines);\n  this._pushBuffer(encoding, 1, done);\n};\nLineStream.prototype._pushBuffer = function(encoding, keep, done) {\n  while (this._lineBuffer.length > keep) {\n    const line = this._lineBuffer.shift();\n    if (this._keepEmptyLines || line.length > 0) {\n      if (!this.push(this._reencode(line, encoding))) {\n        const self2 = this;\n        setImmediate(function() {\n          self2._pushBuffer(encoding, keep, done);\n        });\n        return;\n      }\n    }\n  }\n  done();\n};\nLineStream.prototype._flush = function(done) {\n  this._pushBuffer(this._chunkEncoding, 0, done);\n};\nLineStream.prototype._reencode = function(line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return Buffer.from(line, chunkEncoding).toString(this.encoding);\n  } else if (this.encoding) {\n    return line;\n  } else {\n    return Buffer.from(line, chunkEncoding);\n  }\n};\n\n// ../engine-core/src/tools/omit.ts\nfunction omit(obj, keys2) {\n  return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {\n    result[key] = obj[key];\n    return result;\n  }, {});\n}\n__name(omit, \"omit\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js\nvar SUPPRESS_TRACING_KEY = createContextKey(\"OpenTelemetry SDK Context Key SUPPRESS_TRACING\");\nfunction suppressTracing(context3) {\n  return context3.setValue(SUPPRESS_TRACING_KEY, true);\n}\n__name(suppressTracing, \"suppressTracing\");\nfunction isTracingSuppressed(context3) {\n  return context3.getValue(SUPPRESS_TRACING_KEY) === true;\n}\n__name(isTracingSuppressed, \"isTracingSuppressed\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/constants.js\nvar BAGGAGE_KEY_PAIR_SEPARATOR = \"=\";\nvar BAGGAGE_PROPERTIES_SEPARATOR = \";\";\nvar BAGGAGE_ITEMS_SEPARATOR = \",\";\nvar BAGGAGE_HEADER = \"baggage\";\nvar BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;\nvar BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;\nvar BAGGAGE_MAX_TOTAL_LENGTH = 8192;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/utils.js\nvar __read = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce(function(hValue, current) {\n    var value = \"\" + hValue + (hValue !== \"\" ? BAGGAGE_ITEMS_SEPARATOR : \"\") + current;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, \"\");\n}\n__name(serializeKeyPairs, \"serializeKeyPairs\");\nfunction getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(function(_a3) {\n    var _b2 = __read(_a3, 2), key = _b2[0], value = _b2[1];\n    var entry = encodeURIComponent(key) + \"=\" + encodeURIComponent(value.value);\n    if (value.metadata !== void 0) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n    return entry;\n  });\n}\n__name(getKeyPairs, \"getKeyPairs\");\nfunction parsePairKeyValue(entry) {\n  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0)\n    return;\n  var keyPairPart = valueProps.shift();\n  if (!keyPairPart)\n    return;\n  var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (keyPair.length !== 2)\n    return;\n  var key = decodeURIComponent(keyPair[0].trim());\n  var value = decodeURIComponent(keyPair[1].trim());\n  var metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n  return { key, value, metadata };\n}\n__name(parsePairKeyValue, \"parsePairKeyValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js\nvar W3CBaggagePropagator = function() {\n  function W3CBaggagePropagator2() {\n  }\n  __name(W3CBaggagePropagator2, \"W3CBaggagePropagator\");\n  W3CBaggagePropagator2.prototype.inject = function(context3, carrier, setter) {\n    var baggage = propagation.getBaggage(context3);\n    if (!baggage || isTracingSuppressed(context3))\n      return;\n    var keyPairs = getKeyPairs(baggage).filter(function(pair) {\n      return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;\n    }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);\n    var headerValue = serializeKeyPairs(keyPairs);\n    if (headerValue.length > 0) {\n      setter.set(carrier, BAGGAGE_HEADER, headerValue);\n    }\n  };\n  W3CBaggagePropagator2.prototype.extract = function(context3, carrier, getter) {\n    var headerValue = getter.get(carrier, BAGGAGE_HEADER);\n    var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;\n    if (!baggageString)\n      return context3;\n    var baggage = {};\n    if (baggageString.length === 0) {\n      return context3;\n    }\n    var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);\n    pairs.forEach(function(entry) {\n      var keyPair = parsePairKeyValue(entry);\n      if (keyPair) {\n        var baggageEntry = { value: keyPair.value };\n        if (keyPair.metadata) {\n          baggageEntry.metadata = keyPair.metadata;\n        }\n        baggage[keyPair.key] = baggageEntry;\n      }\n    });\n    if (Object.entries(baggage).length === 0) {\n      return context3;\n    }\n    return propagation.setBaggage(context3, propagation.createBaggage(baggage));\n  };\n  W3CBaggagePropagator2.prototype.fields = function() {\n    return [BAGGAGE_HEADER];\n  };\n  return W3CBaggagePropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/attributes.js\nvar __values = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read2 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction sanitizeAttributes(attributes) {\n  var e_1, _a3;\n  var out = {};\n  if (typeof attributes !== \"object\" || attributes == null) {\n    return out;\n  }\n  try {\n    for (var _b2 = __values(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n      var _d = __read2(_c.value, 2), key = _d[0], val = _d[1];\n      if (!isAttributeKey(key)) {\n        diag2.warn(\"Invalid attribute key: \" + key);\n        continue;\n      }\n      if (!isAttributeValue(val)) {\n        diag2.warn(\"Invalid attribute value set for key: \" + key);\n        continue;\n      }\n      if (Array.isArray(val)) {\n        out[key] = val.slice();\n      } else {\n        out[key] = val;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a3 = _b2.return))\n        _a3.call(_b2);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return out;\n}\n__name(sanitizeAttributes, \"sanitizeAttributes\");\nfunction isAttributeKey(key) {\n  return typeof key === \"string\" && key.length > 0;\n}\n__name(isAttributeKey, \"isAttributeKey\");\nfunction isAttributeValue(val) {\n  if (val == null) {\n    return true;\n  }\n  if (Array.isArray(val)) {\n    return isHomogeneousAttributeValueArray(val);\n  }\n  return isValidPrimitiveAttributeValue(val);\n}\n__name(isAttributeValue, \"isAttributeValue\");\nfunction isHomogeneousAttributeValueArray(arr) {\n  var e_2, _a3;\n  var type;\n  try {\n    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n      var element = arr_1_1.value;\n      if (element == null)\n        continue;\n      if (!type) {\n        if (isValidPrimitiveAttributeValue(element)) {\n          type = typeof element;\n          continue;\n        }\n        return false;\n      }\n      if (typeof element === type) {\n        continue;\n      }\n      return false;\n    }\n  } catch (e_2_1) {\n    e_2 = { error: e_2_1 };\n  } finally {\n    try {\n      if (arr_1_1 && !arr_1_1.done && (_a3 = arr_1.return))\n        _a3.call(arr_1);\n    } finally {\n      if (e_2)\n        throw e_2.error;\n    }\n  }\n  return true;\n}\n__name(isHomogeneousAttributeValueArray, \"isHomogeneousAttributeValueArray\");\nfunction isValidPrimitiveAttributeValue(val) {\n  switch (typeof val) {\n    case \"number\":\n    case \"boolean\":\n    case \"string\":\n      return true;\n  }\n  return false;\n}\n__name(isValidPrimitiveAttributeValue, \"isValidPrimitiveAttributeValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js\nfunction loggingErrorHandler() {\n  return function(ex) {\n    diag2.error(stringifyException(ex));\n  };\n}\n__name(loggingErrorHandler, \"loggingErrorHandler\");\nfunction stringifyException(ex) {\n  if (typeof ex === \"string\") {\n    return ex;\n  } else {\n    return JSON.stringify(flattenException(ex));\n  }\n}\n__name(stringifyException, \"stringifyException\");\nfunction flattenException(ex) {\n  var result = {};\n  var current = ex;\n  while (current !== null) {\n    Object.getOwnPropertyNames(current).forEach(function(propertyName) {\n      if (result[propertyName])\n        return;\n      var value = current[propertyName];\n      if (value) {\n        result[propertyName] = String(value);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n  return result;\n}\n__name(flattenException, \"flattenException\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js\nvar delegateHandler = loggingErrorHandler();\nfunction globalErrorHandler(ex) {\n  try {\n    delegateHandler(ex);\n  } catch (_a3) {\n  }\n}\n__name(globalErrorHandler, \"globalErrorHandler\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\nvar os2 = __toESM(__webpack_require__(/*! os */ \"os\"));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/sampling.js\nvar TracesSamplerValues;\n(function(TracesSamplerValues2) {\n  TracesSamplerValues2[\"AlwaysOff\"] = \"always_off\";\n  TracesSamplerValues2[\"AlwaysOn\"] = \"always_on\";\n  TracesSamplerValues2[\"ParentBasedAlwaysOff\"] = \"parentbased_always_off\";\n  TracesSamplerValues2[\"ParentBasedAlwaysOn\"] = \"parentbased_always_on\";\n  TracesSamplerValues2[\"ParentBasedTraceIdRatio\"] = \"parentbased_traceidratio\";\n  TracesSamplerValues2[\"TraceIdRatio\"] = \"traceidratio\";\n})(TracesSamplerValues || (TracesSamplerValues = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js\nvar _globalThis2 = typeof globalThis === \"object\" ? globalThis : typeof self === \"object\" ? self : typeof window === \"object\" ? window : typeof global === \"object\" ? global : {};\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/environment.js\nvar DEFAULT_LIST_SEPARATOR = \",\";\nvar ENVIRONMENT_NUMBERS_KEYS = [\n  \"OTEL_BSP_EXPORT_TIMEOUT\",\n  \"OTEL_BSP_MAX_EXPORT_BATCH_SIZE\",\n  \"OTEL_BSP_MAX_QUEUE_SIZE\",\n  \"OTEL_BSP_SCHEDULE_DELAY\",\n  \"OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n  \"OTEL_ATTRIBUTE_COUNT_LIMIT\",\n  \"OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n  \"OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT\",\n  \"OTEL_SPAN_EVENT_COUNT_LIMIT\",\n  \"OTEL_SPAN_LINK_COUNT_LIMIT\",\n  \"OTEL_EXPORTER_OTLP_TIMEOUT\",\n  \"OTEL_EXPORTER_OTLP_TRACES_TIMEOUT\",\n  \"OTEL_EXPORTER_OTLP_METRICS_TIMEOUT\",\n  \"OTEL_EXPORTER_JAEGER_AGENT_PORT\"\n];\nfunction isEnvVarANumber(key) {\n  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;\n}\n__name(isEnvVarANumber, \"isEnvVarANumber\");\nvar ENVIRONMENT_LISTS_KEYS = [\n  \"OTEL_NO_PATCH_MODULES\",\n  \"OTEL_PROPAGATORS\"\n];\nfunction isEnvVarAList(key) {\n  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;\n}\n__name(isEnvVarAList, \"isEnvVarAList\");\nvar DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\nvar DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\nvar DEFAULT_ENVIRONMENT = {\n  CONTAINER_NAME: \"\",\n  ECS_CONTAINER_METADATA_URI_V4: \"\",\n  ECS_CONTAINER_METADATA_URI: \"\",\n  HOSTNAME: \"\",\n  KUBERNETES_SERVICE_HOST: \"\",\n  NAMESPACE: \"\",\n  OTEL_BSP_EXPORT_TIMEOUT: 3e4,\n  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,\n  OTEL_BSP_MAX_QUEUE_SIZE: 2048,\n  OTEL_BSP_SCHEDULE_DELAY: 5e3,\n  OTEL_EXPORTER_JAEGER_AGENT_HOST: \"\",\n  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,\n  OTEL_EXPORTER_JAEGER_ENDPOINT: \"\",\n  OTEL_EXPORTER_JAEGER_PASSWORD: \"\",\n  OTEL_EXPORTER_JAEGER_USER: \"\",\n  OTEL_EXPORTER_OTLP_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,\n  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,\n  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,\n  OTEL_EXPORTER_ZIPKIN_ENDPOINT: \"http://localhost:9411/api/v2/spans\",\n  OTEL_LOG_LEVEL: DiagLogLevel.INFO,\n  OTEL_NO_PATCH_MODULES: [],\n  OTEL_PROPAGATORS: [\"tracecontext\", \"baggage\"],\n  OTEL_RESOURCE_ATTRIBUTES: \"\",\n  OTEL_SERVICE_NAME: \"\",\n  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,\n  OTEL_SPAN_LINK_COUNT_LIMIT: 128,\n  OTEL_TRACES_EXPORTER: \"none\",\n  OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,\n  OTEL_TRACES_SAMPLER_ARG: \"\",\n  OTEL_EXPORTER_OTLP_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: \"\"\n};\nfunction parseNumber(name, environment, values, min2, max2) {\n  if (min2 === void 0) {\n    min2 = -Infinity;\n  }\n  if (max2 === void 0) {\n    max2 = Infinity;\n  }\n  if (typeof values[name] !== \"undefined\") {\n    var value = Number(values[name]);\n    if (!isNaN(value)) {\n      if (value < min2) {\n        environment[name] = min2;\n      } else if (value > max2) {\n        environment[name] = max2;\n      } else {\n        environment[name] = value;\n      }\n    }\n  }\n}\n__name(parseNumber, \"parseNumber\");\nfunction parseStringList(name, output, input, separator) {\n  if (separator === void 0) {\n    separator = DEFAULT_LIST_SEPARATOR;\n  }\n  var givenValue = input[name];\n  if (typeof givenValue === \"string\") {\n    output[name] = givenValue.split(separator).map(function(v) {\n      return v.trim();\n    });\n  }\n}\n__name(parseStringList, \"parseStringList\");\nvar logLevelMap = {\n  ALL: DiagLogLevel.ALL,\n  VERBOSE: DiagLogLevel.VERBOSE,\n  DEBUG: DiagLogLevel.DEBUG,\n  INFO: DiagLogLevel.INFO,\n  WARN: DiagLogLevel.WARN,\n  ERROR: DiagLogLevel.ERROR,\n  NONE: DiagLogLevel.NONE\n};\nfunction setLogLevelFromEnv(key, environment, values) {\n  var value = values[key];\n  if (typeof value === \"string\") {\n    var theLevel = logLevelMap[value.toUpperCase()];\n    if (theLevel != null) {\n      environment[key] = theLevel;\n    }\n  }\n}\n__name(setLogLevelFromEnv, \"setLogLevelFromEnv\");\nfunction parseEnvironment(values) {\n  var environment = {};\n  for (var env2 in DEFAULT_ENVIRONMENT) {\n    var key = env2;\n    switch (key) {\n      case \"OTEL_LOG_LEVEL\":\n        setLogLevelFromEnv(key, environment, values);\n        break;\n      default:\n        if (isEnvVarANumber(key)) {\n          parseNumber(key, environment, values);\n        } else if (isEnvVarAList(key)) {\n          parseStringList(key, environment, values);\n        } else {\n          var value = values[key];\n          if (typeof value !== \"undefined\" && value !== null) {\n            environment[key] = String(value);\n          }\n        }\n    }\n  }\n  return environment;\n}\n__name(parseEnvironment, \"parseEnvironment\");\nfunction getEnvWithoutDefaults() {\n  return typeof process !== \"undefined\" ? parseEnvironment(process.env) : parseEnvironment(_globalThis2);\n}\n__name(getEnvWithoutDefaults, \"getEnvWithoutDefaults\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\nfunction getEnv() {\n  var processEnv = parseEnvironment(process.env);\n  return Object.assign({\n    HOSTNAME: os2.hostname()\n  }, DEFAULT_ENVIRONMENT, processEnv);\n}\n__name(getEnv, \"getEnv\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js\nvar _globalThis3 = typeof globalThis === \"object\" ? globalThis : global;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js\nvar buf8 = Buffer.alloc(8);\nvar buf16 = Buffer.alloc(16);\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js\nvar SPAN_ID_BYTES = 8;\nvar TRACE_ID_BYTES = 16;\nvar RandomIdGenerator = function() {\n  function RandomIdGenerator3() {\n    this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n    this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n  }\n  __name(RandomIdGenerator3, \"RandomIdGenerator\");\n  return RandomIdGenerator3;\n}();\nvar SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes) {\n  return /* @__PURE__ */ __name(function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER.toString(\"hex\", 0, bytes);\n  }, \"generateId\");\n}\n__name(getIdGenerator, \"getIdGenerator\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/performance.js\nvar import_perf_hooks = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nvar otperformance = import_perf_hooks.performance;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/version.js\nvar VERSION2 = \"1.6.0\";\n\n// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.6.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js\nvar SemanticAttributes = {\n  AWS_LAMBDA_INVOKED_ARN: \"aws.lambda.invoked_arn\",\n  DB_SYSTEM: \"db.system\",\n  DB_CONNECTION_STRING: \"db.connection_string\",\n  DB_USER: \"db.user\",\n  DB_JDBC_DRIVER_CLASSNAME: \"db.jdbc.driver_classname\",\n  DB_NAME: \"db.name\",\n  DB_STATEMENT: \"db.statement\",\n  DB_OPERATION: \"db.operation\",\n  DB_MSSQL_INSTANCE_NAME: \"db.mssql.instance_name\",\n  DB_CASSANDRA_KEYSPACE: \"db.cassandra.keyspace\",\n  DB_CASSANDRA_PAGE_SIZE: \"db.cassandra.page_size\",\n  DB_CASSANDRA_CONSISTENCY_LEVEL: \"db.cassandra.consistency_level\",\n  DB_CASSANDRA_TABLE: \"db.cassandra.table\",\n  DB_CASSANDRA_IDEMPOTENCE: \"db.cassandra.idempotence\",\n  DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: \"db.cassandra.speculative_execution_count\",\n  DB_CASSANDRA_COORDINATOR_ID: \"db.cassandra.coordinator.id\",\n  DB_CASSANDRA_COORDINATOR_DC: \"db.cassandra.coordinator.dc\",\n  DB_HBASE_NAMESPACE: \"db.hbase.namespace\",\n  DB_REDIS_DATABASE_INDEX: \"db.redis.database_index\",\n  DB_MONGODB_COLLECTION: \"db.mongodb.collection\",\n  DB_SQL_TABLE: \"db.sql.table\",\n  EXCEPTION_TYPE: \"exception.type\",\n  EXCEPTION_MESSAGE: \"exception.message\",\n  EXCEPTION_STACKTRACE: \"exception.stacktrace\",\n  EXCEPTION_ESCAPED: \"exception.escaped\",\n  FAAS_TRIGGER: \"faas.trigger\",\n  FAAS_EXECUTION: \"faas.execution\",\n  FAAS_DOCUMENT_COLLECTION: \"faas.document.collection\",\n  FAAS_DOCUMENT_OPERATION: \"faas.document.operation\",\n  FAAS_DOCUMENT_TIME: \"faas.document.time\",\n  FAAS_DOCUMENT_NAME: \"faas.document.name\",\n  FAAS_TIME: \"faas.time\",\n  FAAS_CRON: \"faas.cron\",\n  FAAS_COLDSTART: \"faas.coldstart\",\n  FAAS_INVOKED_NAME: \"faas.invoked_name\",\n  FAAS_INVOKED_PROVIDER: \"faas.invoked_provider\",\n  FAAS_INVOKED_REGION: \"faas.invoked_region\",\n  NET_TRANSPORT: \"net.transport\",\n  NET_PEER_IP: \"net.peer.ip\",\n  NET_PEER_PORT: \"net.peer.port\",\n  NET_PEER_NAME: \"net.peer.name\",\n  NET_HOST_IP: \"net.host.ip\",\n  NET_HOST_PORT: \"net.host.port\",\n  NET_HOST_NAME: \"net.host.name\",\n  NET_HOST_CONNECTION_TYPE: \"net.host.connection.type\",\n  NET_HOST_CONNECTION_SUBTYPE: \"net.host.connection.subtype\",\n  NET_HOST_CARRIER_NAME: \"net.host.carrier.name\",\n  NET_HOST_CARRIER_MCC: \"net.host.carrier.mcc\",\n  NET_HOST_CARRIER_MNC: \"net.host.carrier.mnc\",\n  NET_HOST_CARRIER_ICC: \"net.host.carrier.icc\",\n  PEER_SERVICE: \"peer.service\",\n  ENDUSER_ID: \"enduser.id\",\n  ENDUSER_ROLE: \"enduser.role\",\n  ENDUSER_SCOPE: \"enduser.scope\",\n  THREAD_ID: \"thread.id\",\n  THREAD_NAME: \"thread.name\",\n  CODE_FUNCTION: \"code.function\",\n  CODE_NAMESPACE: \"code.namespace\",\n  CODE_FILEPATH: \"code.filepath\",\n  CODE_LINENO: \"code.lineno\",\n  HTTP_METHOD: \"http.method\",\n  HTTP_URL: \"http.url\",\n  HTTP_TARGET: \"http.target\",\n  HTTP_HOST: \"http.host\",\n  HTTP_SCHEME: \"http.scheme\",\n  HTTP_STATUS_CODE: \"http.status_code\",\n  HTTP_FLAVOR: \"http.flavor\",\n  HTTP_USER_AGENT: \"http.user_agent\",\n  HTTP_REQUEST_CONTENT_LENGTH: \"http.request_content_length\",\n  HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: \"http.request_content_length_uncompressed\",\n  HTTP_RESPONSE_CONTENT_LENGTH: \"http.response_content_length\",\n  HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: \"http.response_content_length_uncompressed\",\n  HTTP_SERVER_NAME: \"http.server_name\",\n  HTTP_ROUTE: \"http.route\",\n  HTTP_CLIENT_IP: \"http.client_ip\",\n  AWS_DYNAMODB_TABLE_NAMES: \"aws.dynamodb.table_names\",\n  AWS_DYNAMODB_CONSUMED_CAPACITY: \"aws.dynamodb.consumed_capacity\",\n  AWS_DYNAMODB_ITEM_COLLECTION_METRICS: \"aws.dynamodb.item_collection_metrics\",\n  AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: \"aws.dynamodb.provisioned_read_capacity\",\n  AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: \"aws.dynamodb.provisioned_write_capacity\",\n  AWS_DYNAMODB_CONSISTENT_READ: \"aws.dynamodb.consistent_read\",\n  AWS_DYNAMODB_PROJECTION: \"aws.dynamodb.projection\",\n  AWS_DYNAMODB_LIMIT: \"aws.dynamodb.limit\",\n  AWS_DYNAMODB_ATTRIBUTES_TO_GET: \"aws.dynamodb.attributes_to_get\",\n  AWS_DYNAMODB_INDEX_NAME: \"aws.dynamodb.index_name\",\n  AWS_DYNAMODB_SELECT: \"aws.dynamodb.select\",\n  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: \"aws.dynamodb.global_secondary_indexes\",\n  AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: \"aws.dynamodb.local_secondary_indexes\",\n  AWS_DYNAMODB_EXCLUSIVE_START_TABLE: \"aws.dynamodb.exclusive_start_table\",\n  AWS_DYNAMODB_TABLE_COUNT: \"aws.dynamodb.table_count\",\n  AWS_DYNAMODB_SCAN_FORWARD: \"aws.dynamodb.scan_forward\",\n  AWS_DYNAMODB_SEGMENT: \"aws.dynamodb.segment\",\n  AWS_DYNAMODB_TOTAL_SEGMENTS: \"aws.dynamodb.total_segments\",\n  AWS_DYNAMODB_COUNT: \"aws.dynamodb.count\",\n  AWS_DYNAMODB_SCANNED_COUNT: \"aws.dynamodb.scanned_count\",\n  AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: \"aws.dynamodb.attribute_definitions\",\n  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: \"aws.dynamodb.global_secondary_index_updates\",\n  MESSAGING_SYSTEM: \"messaging.system\",\n  MESSAGING_DESTINATION: \"messaging.destination\",\n  MESSAGING_DESTINATION_KIND: \"messaging.destination_kind\",\n  MESSAGING_TEMP_DESTINATION: \"messaging.temp_destination\",\n  MESSAGING_PROTOCOL: \"messaging.protocol\",\n  MESSAGING_PROTOCOL_VERSION: \"messaging.protocol_version\",\n  MESSAGING_URL: \"messaging.url\",\n  MESSAGING_MESSAGE_ID: \"messaging.message_id\",\n  MESSAGING_CONVERSATION_ID: \"messaging.conversation_id\",\n  MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: \"messaging.message_payload_size_bytes\",\n  MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: \"messaging.message_payload_compressed_size_bytes\",\n  MESSAGING_OPERATION: \"messaging.operation\",\n  MESSAGING_CONSUMER_ID: \"messaging.consumer_id\",\n  MESSAGING_RABBITMQ_ROUTING_KEY: \"messaging.rabbitmq.routing_key\",\n  MESSAGING_KAFKA_MESSAGE_KEY: \"messaging.kafka.message_key\",\n  MESSAGING_KAFKA_CONSUMER_GROUP: \"messaging.kafka.consumer_group\",\n  MESSAGING_KAFKA_CLIENT_ID: \"messaging.kafka.client_id\",\n  MESSAGING_KAFKA_PARTITION: \"messaging.kafka.partition\",\n  MESSAGING_KAFKA_TOMBSTONE: \"messaging.kafka.tombstone\",\n  RPC_SYSTEM: \"rpc.system\",\n  RPC_SERVICE: \"rpc.service\",\n  RPC_METHOD: \"rpc.method\",\n  RPC_GRPC_STATUS_CODE: \"rpc.grpc.status_code\",\n  RPC_JSONRPC_VERSION: \"rpc.jsonrpc.version\",\n  RPC_JSONRPC_REQUEST_ID: \"rpc.jsonrpc.request_id\",\n  RPC_JSONRPC_ERROR_CODE: \"rpc.jsonrpc.error_code\",\n  RPC_JSONRPC_ERROR_MESSAGE: \"rpc.jsonrpc.error_message\",\n  MESSAGE_TYPE: \"message.type\",\n  MESSAGE_ID: \"message.id\",\n  MESSAGE_COMPRESSED_SIZE: \"message.compressed_size\",\n  MESSAGE_UNCOMPRESSED_SIZE: \"message.uncompressed_size\"\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.6.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js\nvar SemanticResourceAttributes = {\n  CLOUD_PROVIDER: \"cloud.provider\",\n  CLOUD_ACCOUNT_ID: \"cloud.account.id\",\n  CLOUD_REGION: \"cloud.region\",\n  CLOUD_AVAILABILITY_ZONE: \"cloud.availability_zone\",\n  CLOUD_PLATFORM: \"cloud.platform\",\n  AWS_ECS_CONTAINER_ARN: \"aws.ecs.container.arn\",\n  AWS_ECS_CLUSTER_ARN: \"aws.ecs.cluster.arn\",\n  AWS_ECS_LAUNCHTYPE: \"aws.ecs.launchtype\",\n  AWS_ECS_TASK_ARN: \"aws.ecs.task.arn\",\n  AWS_ECS_TASK_FAMILY: \"aws.ecs.task.family\",\n  AWS_ECS_TASK_REVISION: \"aws.ecs.task.revision\",\n  AWS_EKS_CLUSTER_ARN: \"aws.eks.cluster.arn\",\n  AWS_LOG_GROUP_NAMES: \"aws.log.group.names\",\n  AWS_LOG_GROUP_ARNS: \"aws.log.group.arns\",\n  AWS_LOG_STREAM_NAMES: \"aws.log.stream.names\",\n  AWS_LOG_STREAM_ARNS: \"aws.log.stream.arns\",\n  CONTAINER_NAME: \"container.name\",\n  CONTAINER_ID: \"container.id\",\n  CONTAINER_RUNTIME: \"container.runtime\",\n  CONTAINER_IMAGE_NAME: \"container.image.name\",\n  CONTAINER_IMAGE_TAG: \"container.image.tag\",\n  DEPLOYMENT_ENVIRONMENT: \"deployment.environment\",\n  DEVICE_ID: \"device.id\",\n  DEVICE_MODEL_IDENTIFIER: \"device.model.identifier\",\n  DEVICE_MODEL_NAME: \"device.model.name\",\n  FAAS_NAME: \"faas.name\",\n  FAAS_ID: \"faas.id\",\n  FAAS_VERSION: \"faas.version\",\n  FAAS_INSTANCE: \"faas.instance\",\n  FAAS_MAX_MEMORY: \"faas.max_memory\",\n  HOST_ID: \"host.id\",\n  HOST_NAME: \"host.name\",\n  HOST_TYPE: \"host.type\",\n  HOST_ARCH: \"host.arch\",\n  HOST_IMAGE_NAME: \"host.image.name\",\n  HOST_IMAGE_ID: \"host.image.id\",\n  HOST_IMAGE_VERSION: \"host.image.version\",\n  K8S_CLUSTER_NAME: \"k8s.cluster.name\",\n  K8S_NODE_NAME: \"k8s.node.name\",\n  K8S_NODE_UID: \"k8s.node.uid\",\n  K8S_NAMESPACE_NAME: \"k8s.namespace.name\",\n  K8S_POD_UID: \"k8s.pod.uid\",\n  K8S_POD_NAME: \"k8s.pod.name\",\n  K8S_CONTAINER_NAME: \"k8s.container.name\",\n  K8S_REPLICASET_UID: \"k8s.replicaset.uid\",\n  K8S_REPLICASET_NAME: \"k8s.replicaset.name\",\n  K8S_DEPLOYMENT_UID: \"k8s.deployment.uid\",\n  K8S_DEPLOYMENT_NAME: \"k8s.deployment.name\",\n  K8S_STATEFULSET_UID: \"k8s.statefulset.uid\",\n  K8S_STATEFULSET_NAME: \"k8s.statefulset.name\",\n  K8S_DAEMONSET_UID: \"k8s.daemonset.uid\",\n  K8S_DAEMONSET_NAME: \"k8s.daemonset.name\",\n  K8S_JOB_UID: \"k8s.job.uid\",\n  K8S_JOB_NAME: \"k8s.job.name\",\n  K8S_CRONJOB_UID: \"k8s.cronjob.uid\",\n  K8S_CRONJOB_NAME: \"k8s.cronjob.name\",\n  OS_TYPE: \"os.type\",\n  OS_DESCRIPTION: \"os.description\",\n  OS_NAME: \"os.name\",\n  OS_VERSION: \"os.version\",\n  PROCESS_PID: \"process.pid\",\n  PROCESS_EXECUTABLE_NAME: \"process.executable.name\",\n  PROCESS_EXECUTABLE_PATH: \"process.executable.path\",\n  PROCESS_COMMAND: \"process.command\",\n  PROCESS_COMMAND_LINE: \"process.command_line\",\n  PROCESS_COMMAND_ARGS: \"process.command_args\",\n  PROCESS_OWNER: \"process.owner\",\n  PROCESS_RUNTIME_NAME: \"process.runtime.name\",\n  PROCESS_RUNTIME_VERSION: \"process.runtime.version\",\n  PROCESS_RUNTIME_DESCRIPTION: \"process.runtime.description\",\n  SERVICE_NAME: \"service.name\",\n  SERVICE_NAMESPACE: \"service.namespace\",\n  SERVICE_INSTANCE_ID: \"service.instance.id\",\n  SERVICE_VERSION: \"service.version\",\n  TELEMETRY_SDK_NAME: \"telemetry.sdk.name\",\n  TELEMETRY_SDK_LANGUAGE: \"telemetry.sdk.language\",\n  TELEMETRY_SDK_VERSION: \"telemetry.sdk.version\",\n  TELEMETRY_AUTO_VERSION: \"telemetry.auto.version\",\n  WEBENGINE_NAME: \"webengine.name\",\n  WEBENGINE_VERSION: \"webengine.version\",\n  WEBENGINE_DESCRIPTION: \"webengine.description\"\n};\nvar TelemetrySdkLanguageValues = {\n  CPP: \"cpp\",\n  DOTNET: \"dotnet\",\n  ERLANG: \"erlang\",\n  GO: \"go\",\n  JAVA: \"java\",\n  NODEJS: \"nodejs\",\n  PHP: \"php\",\n  PYTHON: \"python\",\n  RUBY: \"ruby\",\n  WEBJS: \"webjs\"\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js\nvar _a2;\nvar SDK_INFO = (_a2 = {}, _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = \"opentelemetry\", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"node\", _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.NODEJS, _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION2, _a2);\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js\nfunction unrefTimer(timer) {\n  timer.unref();\n}\n__name(unrefTimer, \"unrefTimer\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/time.js\nvar NANOSECOND_DIGITS = 9;\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\nfunction numberToHrtime(epochMillis) {\n  var epochSeconds = epochMillis / 1e3;\n  var seconds = Math.trunc(epochSeconds);\n  var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) * SECOND_TO_NANOSECONDS;\n  return [seconds, nanos];\n}\n__name(numberToHrtime, \"numberToHrtime\");\nfunction getTimeOrigin() {\n  var timeOrigin = otperformance.timeOrigin;\n  if (typeof timeOrigin !== \"number\") {\n    var perf = otperformance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\n__name(getTimeOrigin, \"getTimeOrigin\");\nfunction hrTime(performanceNow) {\n  var timeOrigin = numberToHrtime(getTimeOrigin());\n  var now = numberToHrtime(typeof performanceNow === \"number\" ? performanceNow : otperformance.now());\n  var seconds = timeOrigin[0] + now[0];\n  var nanos = timeOrigin[1] + now[1];\n  if (nanos > SECOND_TO_NANOSECONDS) {\n    nanos -= SECOND_TO_NANOSECONDS;\n    seconds += 1;\n  }\n  return [seconds, nanos];\n}\n__name(hrTime, \"hrTime\");\nfunction timeInputToHrTime(time) {\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === \"number\") {\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      return numberToHrtime(time);\n    }\n  } else if (time instanceof Date) {\n    return numberToHrtime(time.getTime());\n  } else {\n    throw TypeError(\"Invalid input type\");\n  }\n}\n__name(timeInputToHrTime, \"timeInputToHrTime\");\nfunction hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1];\n  if (nanos < 0) {\n    seconds -= 1;\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n  return [seconds, nanos];\n}\n__name(hrTimeDuration, \"hrTimeDuration\");\nfunction hrTimeToMicroseconds(time) {\n  return Math.round(time[0] * 1e6 + time[1] / 1e3);\n}\n__name(hrTimeToMicroseconds, \"hrTimeToMicroseconds\");\nfunction isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === \"number\" && typeof value[1] === \"number\";\n}\n__name(isTimeInputHrTime, \"isTimeInputHrTime\");\nfunction isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === \"number\" || value instanceof Date;\n}\n__name(isTimeInput, \"isTimeInput\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/ExportResult.js\nvar ExportResultCode;\n(function(ExportResultCode2) {\n  ExportResultCode2[ExportResultCode2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  ExportResultCode2[ExportResultCode2[\"FAILED\"] = 1] = \"FAILED\";\n})(ExportResultCode || (ExportResultCode = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/propagation/composite.js\nvar __values2 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar CompositePropagator = function() {\n  function CompositePropagator2(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    var _a3;\n    this._propagators = (_a3 = config2.propagators) !== null && _a3 !== void 0 ? _a3 : [];\n    this._fields = Array.from(new Set(this._propagators.map(function(p) {\n      return typeof p.fields === \"function\" ? p.fields() : [];\n    }).reduce(function(x, y) {\n      return x.concat(y);\n    }, [])));\n  }\n  __name(CompositePropagator2, \"CompositePropagator\");\n  CompositePropagator2.prototype.inject = function(context3, carrier, setter) {\n    var e_1, _a3;\n    try {\n      for (var _b2 = __values2(this._propagators), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var propagator = _c.value;\n        try {\n          propagator.inject(context3, carrier, setter);\n        } catch (err) {\n          diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n  };\n  CompositePropagator2.prototype.extract = function(context3, carrier, getter) {\n    return this._propagators.reduce(function(ctx, propagator) {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n      }\n      return ctx;\n    }, context3);\n  };\n  CompositePropagator2.prototype.fields = function() {\n    return this._fields.slice();\n  };\n  return CompositePropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/internal/validators.js\nvar VALID_KEY_CHAR_RANGE2 = \"[_0-9a-z-*/]\";\nvar VALID_KEY2 = \"[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,255}\";\nvar VALID_VENDOR_KEY2 = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE2 + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,13}\";\nvar VALID_KEY_REGEX2 = new RegExp(\"^(?:\" + VALID_KEY2 + \"|\" + VALID_VENDOR_KEY2 + \")$\");\nvar VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;\nvar INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;\nfunction validateKey2(key) {\n  return VALID_KEY_REGEX2.test(key);\n}\n__name(validateKey2, \"validateKey\");\nfunction validateValue2(value) {\n  return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);\n}\n__name(validateValue2, \"validateValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js\nvar MAX_TRACE_STATE_ITEMS2 = 32;\nvar MAX_TRACE_STATE_LEN2 = 512;\nvar LIST_MEMBERS_SEPARATOR2 = \",\";\nvar LIST_MEMBER_KEY_VALUE_SPLITTER2 = \"=\";\nvar TraceState = function() {\n  function TraceState2(rawTraceState) {\n    this._internalState = /* @__PURE__ */ new Map();\n    if (rawTraceState)\n      this._parse(rawTraceState);\n  }\n  __name(TraceState2, \"TraceState\");\n  TraceState2.prototype.set = function(key, value) {\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceState2.prototype.unset = function(key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceState2.prototype.get = function(key) {\n    return this._internalState.get(key);\n  };\n  TraceState2.prototype.serialize = function() {\n    var _this = this;\n    return this._keys().reduce(function(agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR2);\n  };\n  TraceState2.prototype._parse = function(rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN2)\n      return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce(function(agg, part) {\n      var listMember = part.trim();\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey2(key) && validateValue2(value)) {\n          agg.set(key, value);\n        } else {\n        }\n      }\n      return agg;\n    }, /* @__PURE__ */ new Map());\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));\n    }\n  };\n  TraceState2.prototype._keys = function() {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceState2.prototype._clone = function() {\n    var traceState = new TraceState2();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceState2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js\nvar TRACE_PARENT_HEADER = \"traceparent\";\nvar TRACE_STATE_HEADER = \"tracestate\";\nvar VERSION3 = \"00\";\nvar VERSION_PART = \"(?!ff)[\\\\da-f]{2}\";\nvar TRACE_ID_PART = \"(?![0]{32})[\\\\da-f]{32}\";\nvar PARENT_ID_PART = \"(?![0]{16})[\\\\da-f]{16}\";\nvar FLAGS_PART = \"[\\\\da-f]{2}\";\nvar TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\nfunction parseTraceParent(traceParent) {\n  var match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match)\n    return null;\n  if (match[1] === \"00\" && match[5])\n    return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\n__name(parseTraceParent, \"parseTraceParent\");\nvar W3CTraceContextPropagator = function() {\n  function W3CTraceContextPropagator2() {\n  }\n  __name(W3CTraceContextPropagator2, \"W3CTraceContextPropagator\");\n  W3CTraceContextPropagator2.prototype.inject = function(context3, carrier, setter) {\n    var spanContext = trace.getSpanContext(context3);\n    if (!spanContext || isTracingSuppressed(context3) || !isSpanContextValid(spanContext))\n      return;\n    var traceParent = VERSION3 + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n    }\n  };\n  W3CTraceContextPropagator2.prototype.extract = function(context3, carrier, getter) {\n    var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader)\n      return context3;\n    var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n    if (typeof traceParent !== \"string\")\n      return context3;\n    var spanContext = parseTraceParent(traceParent);\n    if (!spanContext)\n      return context3;\n    spanContext.isRemote = true;\n    var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(\",\") : traceStateHeader;\n      spanContext.traceState = new TraceState(typeof state === \"string\" ? state : void 0);\n    }\n    return trace.setSpanContext(context3, spanContext);\n  };\n  W3CTraceContextPropagator2.prototype.fields = function() {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  };\n  return W3CTraceContextPropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js\nvar RPC_METADATA_KEY = createContextKey(\"OpenTelemetry SDK Context Key RPC_METADATA\");\nvar RPCType;\n(function(RPCType2) {\n  RPCType2[\"HTTP\"] = \"http\";\n})(RPCType || (RPCType = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler = function() {\n  function AlwaysOffSampler3() {\n  }\n  __name(AlwaysOffSampler3, \"AlwaysOffSampler\");\n  AlwaysOffSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision.NOT_RECORD\n    };\n  };\n  AlwaysOffSampler3.prototype.toString = function() {\n    return \"AlwaysOffSampler\";\n  };\n  return AlwaysOffSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler = function() {\n  function AlwaysOnSampler3() {\n  }\n  __name(AlwaysOnSampler3, \"AlwaysOnSampler\");\n  AlwaysOnSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED\n    };\n  };\n  AlwaysOnSampler3.prototype.toString = function() {\n    return \"AlwaysOnSampler\";\n  };\n  return AlwaysOnSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js\nvar ParentBasedSampler = function() {\n  function ParentBasedSampler3(config2) {\n    var _a3, _b2, _c, _d;\n    this._root = config2.root;\n    if (!this._root) {\n      globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n      this._root = new AlwaysOnSampler();\n    }\n    this._remoteParentSampled = (_a3 = config2.remoteParentSampled) !== null && _a3 !== void 0 ? _a3 : new AlwaysOnSampler();\n    this._remoteParentNotSampled = (_b2 = config2.remoteParentNotSampled) !== null && _b2 !== void 0 ? _b2 : new AlwaysOffSampler();\n    this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();\n    this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();\n  }\n  __name(ParentBasedSampler3, \"ParentBasedSampler\");\n  ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {\n    var parentContext = trace.getSpanContext(context3);\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n      }\n      return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n  };\n  ParentBasedSampler3.prototype.toString = function() {\n    return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n  };\n  return ParentBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler = function() {\n  function TraceIdRatioBasedSampler3(_ratio) {\n    if (_ratio === void 0) {\n      _ratio = 0;\n    }\n    this._ratio = _ratio;\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 4294967295);\n  }\n  __name(TraceIdRatioBasedSampler3, \"TraceIdRatioBasedSampler\");\n  TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {\n    return {\n      decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD\n    };\n  };\n  TraceIdRatioBasedSampler3.prototype.toString = function() {\n    return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n  };\n  TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n    if (typeof ratio !== \"number\" || isNaN(ratio))\n      return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  };\n  TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n    var accumulation = 0;\n    for (var i = 0; i < traceId.length / 8; i++) {\n      var pos = i * 8;\n      var part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  };\n  return TraceIdRatioBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js\nvar objectTag = \"[object Object]\";\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nvar objectCtorString = funcToString.call(Object);\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar symToStringTag = Symbol ? Symbol.toStringTag : void 0;\nvar nativeObjectToString = objectProto.toString;\nfunction overArg(func, transform) {\n  return function(arg2) {\n    return func(transform(arg2));\n  };\n}\n__name(overArg, \"overArg\");\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;\n}\n__name(isPlainObject, \"isPlainObject\");\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\n__name(isObjectLike, \"isObjectLike\");\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n__name(baseGetTag, \"baseGetTag\");\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];\n  var unmasked = false;\n  try {\n    value[symToStringTag] = void 0;\n    unmasked = true;\n  } catch (e) {\n  }\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag2;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n__name(getRawTag, \"getRawTag\");\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n__name(objectToString, \"objectToString\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/merge.js\nvar MAX_LEVEL = 20;\nfunction merge() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var result = args.shift();\n  var objects = /* @__PURE__ */ new WeakMap();\n  while (args.length > 0) {\n    result = mergeTwoObjects(result, args.shift(), 0, objects);\n  }\n  return result;\n}\n__name(merge, \"merge\");\nfunction takeValue(value) {\n  if (isArray(value)) {\n    return value.slice();\n  }\n  return value;\n}\n__name(takeValue, \"takeValue\");\nfunction mergeTwoObjects(one, two, level, objects) {\n  if (level === void 0) {\n    level = 0;\n  }\n  var result;\n  if (level > MAX_LEVEL) {\n    return void 0;\n  }\n  level++;\n  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {\n    result = takeValue(two);\n  } else if (isArray(one)) {\n    result = one.slice();\n    if (isArray(two)) {\n      for (var i = 0, j = two.length; i < j; i++) {\n        result.push(takeValue(two[i]));\n      }\n    } else if (isObject(two)) {\n      var keys2 = Object.keys(two);\n      for (var i = 0, j = keys2.length; i < j; i++) {\n        var key = keys2[i];\n        result[key] = takeValue(two[key]);\n      }\n    }\n  } else if (isObject(one)) {\n    if (isObject(two)) {\n      if (!shouldMerge(one, two)) {\n        return two;\n      }\n      result = Object.assign({}, one);\n      var keys2 = Object.keys(two);\n      for (var i = 0, j = keys2.length; i < j; i++) {\n        var key = keys2[i];\n        var twoValue = two[key];\n        if (isPrimitive(twoValue)) {\n          if (typeof twoValue === \"undefined\") {\n            delete result[key];\n          } else {\n            result[key] = twoValue;\n          }\n        } else {\n          var obj1 = result[key];\n          var obj2 = twoValue;\n          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {\n            delete result[key];\n          } else {\n            if (isObject(obj1) && isObject(obj2)) {\n              var arr1 = objects.get(obj1) || [];\n              var arr2 = objects.get(obj2) || [];\n              arr1.push({ obj: one, key });\n              arr2.push({ obj: two, key });\n              objects.set(obj1, arr1);\n              objects.set(obj2, arr2);\n            }\n            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);\n          }\n        }\n      }\n    } else {\n      result = two;\n    }\n  }\n  return result;\n}\n__name(mergeTwoObjects, \"mergeTwoObjects\");\nfunction wasObjectReferenced(obj, key, objects) {\n  var arr = objects.get(obj[key]) || [];\n  for (var i = 0, j = arr.length; i < j; i++) {\n    var info2 = arr[i];\n    if (info2.key === key && info2.obj === obj) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(wasObjectReferenced, \"wasObjectReferenced\");\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n__name(isArray, \"isArray\");\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n__name(isFunction, \"isFunction\");\nfunction isObject(value) {\n  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === \"object\";\n}\n__name(isObject, \"isObject\");\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"undefined\" || value instanceof Date || value instanceof RegExp || value === null;\n}\n__name(isPrimitive, \"isPrimitive\");\nfunction shouldMerge(one, two) {\n  if (!isPlainObject(one) || !isPlainObject(two)) {\n    return false;\n  }\n  return true;\n}\n__name(shouldMerge, \"shouldMerge\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/promise.js\nvar Deferred = function() {\n  function Deferred2() {\n    var _this = this;\n    this._promise = new Promise(function(resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  }\n  __name(Deferred2, \"Deferred\");\n  Object.defineProperty(Deferred2.prototype, \"promise\", {\n    get: function() {\n      return this._promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Deferred2.prototype.resolve = function(val) {\n    this._resolve(val);\n  };\n  Deferred2.prototype.reject = function(err) {\n    this._reject(err);\n  };\n  return Deferred2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/callback.js\nvar __read3 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray3 = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar BindOnceFuture = function() {\n  function BindOnceFuture2(_callback, _that) {\n    this._callback = _callback;\n    this._that = _that;\n    this._isCalled = false;\n    this._deferred = new Deferred();\n  }\n  __name(BindOnceFuture2, \"BindOnceFuture\");\n  Object.defineProperty(BindOnceFuture2.prototype, \"isCalled\", {\n    get: function() {\n      return this._isCalled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BindOnceFuture2.prototype, \"promise\", {\n    get: function() {\n      return this._deferred.promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BindOnceFuture2.prototype.call = function() {\n    var _a3;\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (!this._isCalled) {\n      this._isCalled = true;\n      try {\n        Promise.resolve((_a3 = this._callback).call.apply(_a3, __spreadArray3([this._that], __read3(args), false))).then(function(val) {\n          return _this._deferred.resolve(val);\n        }, function(err) {\n          return _this._deferred.reject(err);\n        });\n      } catch (err) {\n        this._deferred.reject(err);\n      }\n    }\n    return this._deferred.promise;\n  };\n  return BindOnceFuture2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js\nvar ExceptionEventName = \"exception\";\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js\nvar __values3 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read4 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar Span = function() {\n  function Span3(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links, startTime) {\n    if (links === void 0) {\n      links = [];\n    }\n    if (startTime === void 0) {\n      startTime = hrTime();\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this.status = {\n      code: SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    this.startTime = timeInputToHrTime(startTime);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context3);\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n  }\n  __name(Span3, \"Span\");\n  Span3.prototype.spanContext = function() {\n    return this._spanContext;\n  };\n  Span3.prototype.setAttribute = function(key, value) {\n    if (value == null || this._isSpanEnded())\n      return this;\n    if (key.length === 0) {\n      diag2.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag2.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span3.prototype.setAttributes = function(attributes) {\n    var e_1, _a3;\n    try {\n      for (var _b2 = __values3(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var _d = __read4(_c.value, 2), k = _d[0], v = _d[1];\n        this.setAttribute(k, v);\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return this;\n  };\n  Span3.prototype.addEvent = function(name, attributesOrStartTime, startTime) {\n    if (this._isSpanEnded())\n      return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag2.warn(\"No events allowed.\");\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      diag2.warn(\"Dropping extra events.\");\n      this.events.shift();\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (typeof startTime === \"undefined\") {\n        startTime = attributesOrStartTime;\n      }\n      attributesOrStartTime = void 0;\n    }\n    if (typeof startTime === \"undefined\") {\n      startTime = hrTime();\n    }\n    var attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name,\n      attributes,\n      time: timeInputToHrTime(startTime)\n    });\n    return this;\n  };\n  Span3.prototype.setStatus = function(status) {\n    if (this._isSpanEnded())\n      return this;\n    this.status = status;\n    return this;\n  };\n  Span3.prototype.updateName = function(name) {\n    if (this._isSpanEnded())\n      return this;\n    this.name = name;\n    return this;\n  };\n  Span3.prototype.end = function(endTime) {\n    if (endTime === void 0) {\n      endTime = hrTime();\n    }\n    if (this._isSpanEnded()) {\n      diag2.error(\"You can only call end() on a span once.\");\n      return;\n    }\n    this._ended = true;\n    this.endTime = timeInputToHrTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag2.warn(\"Inconsistent start and end time, startTime > endTime\", this.startTime, this.endTime);\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span3.prototype.isRecording = function() {\n    return this._ended === false;\n  };\n  Span3.prototype.recordException = function(exception, time) {\n    if (time === void 0) {\n      time = hrTime();\n    }\n    var attributes = {};\n    if (typeof exception === \"string\") {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag2.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span3.prototype, \"duration\", {\n    get: function() {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span3.prototype, \"ended\", {\n    get: function() {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span3.prototype._isSpanEnded = function() {\n    if (this._ended) {\n      diag2.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  Span3.prototype._truncateToLimitUtil = function(value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  };\n  Span3.prototype._truncateToSize = function(value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    if (limit <= 0) {\n      diag2.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    if (typeof value === \"string\") {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    if (Array.isArray(value)) {\n      return value.map(function(val) {\n        return typeof val === \"string\" ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    return value;\n  };\n  return Span3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js\nvar SamplingDecision2;\n(function(SamplingDecision3) {\n  SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n})(SamplingDecision2 || (SamplingDecision2 = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler2 = function() {\n  function AlwaysOffSampler3() {\n  }\n  __name(AlwaysOffSampler3, \"AlwaysOffSampler\");\n  AlwaysOffSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision2.NOT_RECORD\n    };\n  };\n  AlwaysOffSampler3.prototype.toString = function() {\n    return \"AlwaysOffSampler\";\n  };\n  return AlwaysOffSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler2 = function() {\n  function AlwaysOnSampler3() {\n  }\n  __name(AlwaysOnSampler3, \"AlwaysOnSampler\");\n  AlwaysOnSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision2.RECORD_AND_SAMPLED\n    };\n  };\n  AlwaysOnSampler3.prototype.toString = function() {\n    return \"AlwaysOnSampler\";\n  };\n  return AlwaysOnSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js\nvar ParentBasedSampler2 = function() {\n  function ParentBasedSampler3(config2) {\n    var _a3, _b2, _c, _d;\n    this._root = config2.root;\n    if (!this._root) {\n      globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n      this._root = new AlwaysOnSampler2();\n    }\n    this._remoteParentSampled = (_a3 = config2.remoteParentSampled) !== null && _a3 !== void 0 ? _a3 : new AlwaysOnSampler2();\n    this._remoteParentNotSampled = (_b2 = config2.remoteParentNotSampled) !== null && _b2 !== void 0 ? _b2 : new AlwaysOffSampler2();\n    this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler2();\n    this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler2();\n  }\n  __name(ParentBasedSampler3, \"ParentBasedSampler\");\n  ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {\n    var parentContext = trace.getSpanContext(context3);\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n      }\n      return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n  };\n  ParentBasedSampler3.prototype.toString = function() {\n    return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n  };\n  return ParentBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler2 = function() {\n  function TraceIdRatioBasedSampler3(_ratio) {\n    if (_ratio === void 0) {\n      _ratio = 0;\n    }\n    this._ratio = _ratio;\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 4294967295);\n  }\n  __name(TraceIdRatioBasedSampler3, \"TraceIdRatioBasedSampler\");\n  TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {\n    return {\n      decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision2.RECORD_AND_SAMPLED : SamplingDecision2.NOT_RECORD\n    };\n  };\n  TraceIdRatioBasedSampler3.prototype.toString = function() {\n    return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n  };\n  TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n    if (typeof ratio !== \"number\" || isNaN(ratio))\n      return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  };\n  TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n    var accumulation = 0;\n    for (var i = 0; i < traceId.length / 8; i++) {\n      var pos = i * 8;\n      var part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  };\n  return TraceIdRatioBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js\nvar env = getEnv();\nvar FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;\nvar DEFAULT_RATIO = 1;\nfunction loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(env),\n    forceFlushTimeoutMillis: 3e4,\n    generalLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT\n    },\n    spanLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n      linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,\n      eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT\n    }\n  };\n}\n__name(loadDefaultConfig, \"loadDefaultConfig\");\nfunction buildSamplerFromEnv(environment) {\n  if (environment === void 0) {\n    environment = getEnv();\n  }\n  switch (environment.OTEL_TRACES_SAMPLER) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler2();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler2();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler2({\n        root: new AlwaysOnSampler2()\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler2({\n        root: new AlwaysOffSampler2()\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment));\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler2({\n        root: new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment))\n      });\n    default:\n      diag2.error('OTEL_TRACES_SAMPLER value \"' + environment.OTEL_TRACES_SAMPLER + \" invalid, defaulting to \" + FALLBACK_OTEL_TRACES_SAMPLER + '\".');\n      return new AlwaysOnSampler2();\n  }\n}\n__name(buildSamplerFromEnv, \"buildSamplerFromEnv\");\nfunction getSamplerProbabilityFromEnv(environment) {\n  if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === \"\") {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG is blank, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);\n  if (isNaN(probability)) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is invalid, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  if (probability < 0 || probability > 1) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is out of range ([0..1]), defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  return probability;\n}\n__name(getSamplerProbabilityFromEnv, \"getSamplerProbabilityFromEnv\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js\nfunction mergeConfig(userConfig) {\n  var perInstanceDefaults = {\n    sampler: buildSamplerFromEnv()\n  };\n  var DEFAULT_CONFIG = loadDefaultConfig();\n  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);\n  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});\n  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});\n  return target;\n}\n__name(mergeConfig, \"mergeConfig\");\nfunction reconfigureLimits(userConfig) {\n  var _a3, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n  var spanLimits = Object.assign({}, userConfig.spanLimits);\n  var parsedEnvConfig = getEnvWithoutDefaults();\n  spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b2 = (_a3 = userConfig.spanLimits) === null || _a3 === void 0 ? void 0 : _a3.attributeCountLimit) !== null && _b2 !== void 0 ? _b2 : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n  return Object.assign({}, userConfig, { spanLimits });\n}\n__name(reconfigureLimits, \"reconfigureLimits\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js\nvar BatchSpanProcessorBase = function() {\n  function BatchSpanProcessorBase2(_exporter, config2) {\n    this._exporter = _exporter;\n    this._finishedSpans = [];\n    var env2 = getEnv();\n    this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === \"number\" ? config2.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === \"number\" ? config2.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === \"number\" ? config2.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === \"number\" ? config2.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n  __name(BatchSpanProcessorBase2, \"BatchSpanProcessorBase\");\n  BatchSpanProcessorBase2.prototype.forceFlush = function() {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  };\n  BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {\n  };\n  BatchSpanProcessorBase2.prototype.onEnd = function(span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    this._addToBuffer(span);\n  };\n  BatchSpanProcessorBase2.prototype.shutdown = function() {\n    return this._shutdownOnce.call();\n  };\n  BatchSpanProcessorBase2.prototype._shutdown = function() {\n    var _this = this;\n    return Promise.resolve().then(function() {\n      return _this.onShutdown();\n    }).then(function() {\n      return _this._flushAll();\n    }).then(function() {\n      return _this._exporter.shutdown();\n    });\n  };\n  BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      return;\n    }\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  };\n  BatchSpanProcessorBase2.prototype._flushAll = function() {\n    var _this = this;\n    return new Promise(function(resolve, reject) {\n      var promises = [];\n      var count2 = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n      for (var i = 0, j = count2; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n      Promise.all(promises).then(function() {\n        resolve();\n      }).catch(reject);\n    });\n  };\n  BatchSpanProcessorBase2.prototype._flushOneBatch = function() {\n    var _this = this;\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise(function(resolve, reject) {\n      var timer = setTimeout(function() {\n        reject(new Error(\"Timeout\"));\n      }, _this._exportTimeoutMillis);\n      context2.with(suppressTracing(context2.active()), function() {\n        _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function(result) {\n          var _a3;\n          clearTimeout(timer);\n          if (result.code === ExportResultCode.SUCCESS) {\n            resolve();\n          } else {\n            reject((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error(\"BatchSpanProcessor: span export failed\"));\n          }\n        });\n      });\n    });\n  };\n  BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {\n    var _this = this;\n    if (this._timer !== void 0)\n      return;\n    this._timer = setTimeout(function() {\n      _this._flushOneBatch().then(function() {\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n          _this._maybeStartTimer();\n        }\n      }).catch(function(e) {\n        globalErrorHandler(e);\n      });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n  BatchSpanProcessorBase2.prototype._clearTimer = function() {\n    if (this._timer !== void 0) {\n      clearTimeout(this._timer);\n      this._timer = void 0;\n    }\n  };\n  return BatchSpanProcessorBase2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js\nvar __extends = function() {\n  var extendStatics = /* @__PURE__ */ __name(function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  }, \"extendStatics\");\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    __name(__, \"__\");\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar BatchSpanProcessor = function(_super) {\n  __extends(BatchSpanProcessor2, _super);\n  function BatchSpanProcessor2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  __name(BatchSpanProcessor2, \"BatchSpanProcessor\");\n  BatchSpanProcessor2.prototype.onShutdown = function() {\n  };\n  return BatchSpanProcessor2;\n}(BatchSpanProcessorBase);\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js\nvar SPAN_ID_BYTES2 = 8;\nvar TRACE_ID_BYTES2 = 16;\nvar RandomIdGenerator2 = function() {\n  function RandomIdGenerator3() {\n    this.generateTraceId = getIdGenerator2(TRACE_ID_BYTES2);\n    this.generateSpanId = getIdGenerator2(SPAN_ID_BYTES2);\n  }\n  __name(RandomIdGenerator3, \"RandomIdGenerator\");\n  return RandomIdGenerator3;\n}();\nvar SHARED_BUFFER2 = Buffer.allocUnsafe(TRACE_ID_BYTES2);\nfunction getIdGenerator2(bytes) {\n  return /* @__PURE__ */ __name(function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER2.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER2[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER2[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER2.toString(\"hex\", 0, bytes);\n  }, \"generateId\");\n}\n__name(getIdGenerator2, \"getIdGenerator\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js\nvar Tracer = function() {\n  function Tracer3(instrumentationLibrary, config2, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config2);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config2.idGenerator || new RandomIdGenerator2();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  __name(Tracer3, \"Tracer\");\n  Tracer3.prototype.startSpan = function(name, options, context3) {\n    var _a3, _b2;\n    if (options === void 0) {\n      options = {};\n    }\n    if (context3 === void 0) {\n      context3 = context2.active();\n    }\n    if (isTracingSuppressed(context3)) {\n      diag2.debug(\"Instrumentation suppressed, returning Noop Span\");\n      return trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n    }\n    if (options.root) {\n      context3 = trace.deleteSpan(context3);\n    }\n    var parentSpanContext = trace.getSpanContext(context3);\n    var spanId = this._idGenerator.generateSpanId();\n    var traceId;\n    var traceState;\n    var parentSpanId;\n    if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n    var spanKind = (_a3 = options.kind) !== null && _a3 !== void 0 ? _a3 : SpanKind.INTERNAL;\n    var links = ((_b2 = options.links) !== null && _b2 !== void 0 ? _b2 : []).map(function(link) {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    var attributes = sanitizeAttributes(options.attributes);\n    var samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);\n    var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;\n    var spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === SamplingDecision.NOT_RECORD) {\n      diag2.debug(\"Recording is off, propagating context in a non-recording span\");\n      return trace.wrapSpanContext(spanContext);\n    }\n    var span = new Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime);\n    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    span.setAttributes(initAttributes);\n    return span;\n  };\n  Tracer3.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : context2.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = trace.setSpan(parentContext, span);\n    return context2.with(contextWithSpanSet, fn, void 0, span);\n  };\n  Tracer3.prototype.getGeneralLimits = function() {\n    return this._generalLimits;\n  };\n  Tracer3.prototype.getSpanLimits = function() {\n    return this._spanLimits;\n  };\n  Tracer3.prototype.getActiveSpanProcessor = function() {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n  return Tracer3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\nfunction defaultServiceName() {\n  return \"unknown_service:\" + process.argv0;\n}\n__name(defaultServiceName, \"defaultServiceName\");\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetector.js\nvar import_os2 = __webpack_require__(/*! os */ \"os\");\nvar __awaiter = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar HostDetector = function() {\n  function HostDetector2() {\n  }\n  __name(HostDetector2, \"HostDetector\");\n  HostDetector2.prototype.detect = function(_config) {\n    return __awaiter(this, void 0, void 0, function() {\n      var attributes;\n      var _a3;\n      return __generator(this, function(_b2) {\n        attributes = (_a3 = {}, _a3[SemanticResourceAttributes.HOST_NAME] = (0, import_os2.hostname)(), _a3[SemanticResourceAttributes.HOST_ARCH] = this._normalizeArch((0, import_os2.arch)()), _a3);\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  HostDetector2.prototype._normalizeArch = function(nodeArchString) {\n    switch (nodeArchString) {\n      case \"arm\":\n        return \"arm32\";\n      case \"ppc\":\n        return \"ppc32\";\n      case \"x64\":\n        return \"amd64\";\n      default:\n        return nodeArchString;\n    }\n  };\n  return HostDetector2;\n}();\nvar hostDetector = new HostDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetector.js\nvar import_os3 = __webpack_require__(/*! os */ \"os\");\nvar __awaiter2 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator2 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar OSDetector = function() {\n  function OSDetector2() {\n  }\n  __name(OSDetector2, \"OSDetector\");\n  OSDetector2.prototype.detect = function(_config) {\n    return __awaiter2(this, void 0, void 0, function() {\n      var attributes;\n      var _a3;\n      return __generator2(this, function(_b2) {\n        attributes = (_a3 = {}, _a3[SemanticResourceAttributes.OS_TYPE] = this._normalizeType((0, import_os3.platform)()), _a3[SemanticResourceAttributes.OS_VERSION] = (0, import_os3.release)(), _a3);\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  OSDetector2.prototype._normalizeType = function(nodePlatform) {\n    switch (nodePlatform) {\n      case \"sunos\":\n        return \"solaris\";\n      case \"win32\":\n        return \"windows\";\n      default:\n        return nodePlatform;\n    }\n  };\n  return OSDetector2;\n}();\nvar osDetector = new OSDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/Resource.js\nvar Resource = function() {\n  function Resource2(attributes) {\n    this.attributes = attributes;\n  }\n  __name(Resource2, \"Resource\");\n  Resource2.empty = function() {\n    return Resource2.EMPTY;\n  };\n  Resource2.default = function() {\n    var _a3;\n    return new Resource2((_a3 = {}, _a3[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a3[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a3[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a3[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a3));\n  };\n  Resource2.prototype.merge = function(other) {\n    if (!other || !Object.keys(other.attributes).length)\n      return this;\n    var mergedAttributes = Object.assign({}, this.attributes, other.attributes);\n    return new Resource2(mergedAttributes);\n  };\n  Resource2.EMPTY = new Resource2({});\n  return Resource2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetector.js\nvar __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter3 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator3 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar BrowserDetector = function() {\n  function BrowserDetector2() {\n  }\n  __name(BrowserDetector2, \"BrowserDetector\");\n  BrowserDetector2.prototype.detect = function(config2) {\n    return __awaiter3(this, void 0, void 0, function() {\n      var isBrowser, browserResource;\n      var _a3;\n      return __generator3(this, function(_b2) {\n        isBrowser = typeof navigator !== \"undefined\";\n        if (!isBrowser) {\n          return [2, Resource.empty()];\n        }\n        browserResource = (_a3 = {}, _a3[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"browser\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Web Browser\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a3);\n        return [2, this._getResourceAttributes(browserResource, config2)];\n      });\n    });\n  };\n  BrowserDetector2.prototype._getResourceAttributes = function(browserResource, _config) {\n    if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === \"\") {\n      diag2.debug(\"BrowserDetector failed: Unable to find required browser resources. \");\n      return Resource.empty();\n    } else {\n      return new Resource(__assign({}, browserResource));\n    }\n  };\n  return BrowserDetector2;\n}();\nvar browserDetector = new BrowserDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetector.js\nvar __awaiter4 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator4 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar __values4 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read5 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar EnvDetector = function() {\n  function EnvDetector2() {\n    this._MAX_LENGTH = 255;\n    this._COMMA_SEPARATOR = \",\";\n    this._LABEL_KEY_VALUE_SPLITTER = \"=\";\n    this._ERROR_MESSAGE_INVALID_CHARS = \"should be a ASCII string with a length greater than 0 and not exceed \" + this._MAX_LENGTH + \" characters.\";\n    this._ERROR_MESSAGE_INVALID_VALUE = \"should be a ASCII string with a length not exceed \" + this._MAX_LENGTH + \" characters.\";\n  }\n  __name(EnvDetector2, \"EnvDetector\");\n  EnvDetector2.prototype.detect = function(_config) {\n    return __awaiter4(this, void 0, void 0, function() {\n      var attributes, env2, rawAttributes, serviceName, parsedAttributes;\n      return __generator4(this, function(_a3) {\n        attributes = {};\n        env2 = getEnv();\n        rawAttributes = env2.OTEL_RESOURCE_ATTRIBUTES;\n        serviceName = env2.OTEL_SERVICE_NAME;\n        if (rawAttributes) {\n          try {\n            parsedAttributes = this._parseResourceAttributes(rawAttributes);\n            Object.assign(attributes, parsedAttributes);\n          } catch (e) {\n            diag2.debug(\"EnvDetector failed: \" + e.message);\n          }\n        }\n        if (serviceName) {\n          attributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;\n        }\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  EnvDetector2.prototype._parseResourceAttributes = function(rawEnvAttributes) {\n    var e_1, _a3;\n    if (!rawEnvAttributes)\n      return {};\n    var attributes = {};\n    var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);\n    try {\n      for (var rawAttributes_1 = __values4(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {\n        var rawAttribute = rawAttributes_1_1.value;\n        var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);\n        if (keyValuePair.length !== 2) {\n          continue;\n        }\n        var _b2 = __read5(keyValuePair, 2), key = _b2[0], value = _b2[1];\n        key = key.trim();\n        value = value.trim().split('^\"|\"$').join(\"\");\n        if (!this._isValidAndNotEmpty(key)) {\n          throw new Error(\"Attribute key \" + this._ERROR_MESSAGE_INVALID_CHARS);\n        }\n        if (!this._isValid(value)) {\n          throw new Error(\"Attribute value \" + this._ERROR_MESSAGE_INVALID_VALUE);\n        }\n        attributes[key] = value;\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a3 = rawAttributes_1.return))\n          _a3.call(rawAttributes_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return attributes;\n  };\n  EnvDetector2.prototype._isValid = function(name) {\n    return name.length <= this._MAX_LENGTH && this._isPrintableString(name);\n  };\n  EnvDetector2.prototype._isPrintableString = function(str) {\n    for (var i = 0; i < str.length; i++) {\n      var ch = str.charAt(i);\n      if (ch <= \" \" || ch >= \"~\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  EnvDetector2.prototype._isValidAndNotEmpty = function(str) {\n    return str.length > 0 && this._isValid(str);\n  };\n  return EnvDetector2;\n}();\nvar envDetector = new EnvDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/ProcessDetector.js\nvar __assign2 = function() {\n  __assign2 = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign2.apply(this, arguments);\n};\nvar __awaiter5 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator5 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar ProcessDetector = function() {\n  function ProcessDetector2() {\n  }\n  __name(ProcessDetector2, \"ProcessDetector\");\n  ProcessDetector2.prototype.detect = function(config2) {\n    return __awaiter5(this, void 0, void 0, function() {\n      var processResource;\n      var _a3;\n      return __generator5(this, function(_b2) {\n        if (typeof process !== \"object\") {\n          return [2, Resource.empty()];\n        }\n        processResource = (_a3 = {}, _a3[SemanticResourceAttributes.PROCESS_PID] = process.pid, _a3[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title || \"\", _a3[SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1] || \"\", _a3[SemanticResourceAttributes.PROCESS_COMMAND_LINE] = process.argv.join(\" \") || \"\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node, _a3[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"nodejs\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Node.js\", _a3);\n        return [2, this._getResourceAttributes(processResource, config2)];\n      });\n    });\n  };\n  ProcessDetector2.prototype._getResourceAttributes = function(processResource, _config) {\n    if (processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] === \"\" || processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] === \"\" || processResource[SemanticResourceAttributes.PROCESS_COMMAND] === \"\" || processResource[SemanticResourceAttributes.PROCESS_COMMAND_LINE] === \"\" || processResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === \"\") {\n      diag2.debug(\"ProcessDetector failed: Unable to find required process resources. \");\n      return Resource.empty();\n    } else {\n      return new Resource(__assign2({}, processResource));\n    }\n  };\n  return ProcessDetector2;\n}();\nvar processDetector = new ProcessDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js\nvar __values5 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar MultiSpanProcessor = function() {\n  function MultiSpanProcessor2(_spanProcessors) {\n    this._spanProcessors = _spanProcessors;\n  }\n  __name(MultiSpanProcessor2, \"MultiSpanProcessor\");\n  MultiSpanProcessor2.prototype.forceFlush = function() {\n    var e_1, _a3;\n    var promises = [];\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.forceFlush());\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return new Promise(function(resolve) {\n      Promise.all(promises).then(function() {\n        resolve();\n      }).catch(function(error2) {\n        globalErrorHandler(error2 || new Error(\"MultiSpanProcessor: forceFlush failed\"));\n        resolve();\n      });\n    });\n  };\n  MultiSpanProcessor2.prototype.onStart = function(span, context3) {\n    var e_2, _a3;\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onStart(span, context3);\n      }\n    } catch (e_2_1) {\n      e_2 = { error: e_2_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_2)\n          throw e_2.error;\n      }\n    }\n  };\n  MultiSpanProcessor2.prototype.onEnd = function(span) {\n    var e_3, _a3;\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onEnd(span);\n      }\n    } catch (e_3_1) {\n      e_3 = { error: e_3_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_3)\n          throw e_3.error;\n      }\n    }\n  };\n  MultiSpanProcessor2.prototype.shutdown = function() {\n    var e_4, _a3;\n    var promises = [];\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.shutdown());\n      }\n    } catch (e_4_1) {\n      e_4 = { error: e_4_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_4)\n          throw e_4.error;\n      }\n    }\n    return new Promise(function(resolve, reject) {\n      Promise.all(promises).then(function() {\n        resolve();\n      }, reject);\n    });\n  };\n  return MultiSpanProcessor2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js\nvar NoopSpanProcessor = function() {\n  function NoopSpanProcessor2() {\n  }\n  __name(NoopSpanProcessor2, \"NoopSpanProcessor\");\n  NoopSpanProcessor2.prototype.onStart = function(_span, _context) {\n  };\n  NoopSpanProcessor2.prototype.onEnd = function(_span) {\n  };\n  NoopSpanProcessor2.prototype.shutdown = function() {\n    return Promise.resolve();\n  };\n  NoopSpanProcessor2.prototype.forceFlush = function() {\n    return Promise.resolve();\n  };\n  return NoopSpanProcessor2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js\nvar ForceFlushState;\n(function(ForceFlushState2) {\n  ForceFlushState2[ForceFlushState2[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState2[ForceFlushState2[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState2[ForceFlushState2[\"error\"] = 2] = \"error\";\n  ForceFlushState2[ForceFlushState2[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\nvar BasicTracerProvider = function() {\n  function BasicTracerProvider2(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    var _a3;\n    this._registeredSpanProcessors = [];\n    this._tracers = /* @__PURE__ */ new Map();\n    var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config2));\n    this.resource = (_a3 = mergedConfig.resource) !== null && _a3 !== void 0 ? _a3 : Resource.empty();\n    this.resource = Resource.default().merge(this.resource);\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource\n    });\n    var defaultExporter = this._buildExporterFromEnv();\n    if (defaultExporter !== void 0) {\n      var batchProcessor = new BatchSpanProcessor(defaultExporter);\n      this.activeSpanProcessor = batchProcessor;\n    } else {\n      this.activeSpanProcessor = new NoopSpanProcessor();\n    }\n  }\n  __name(BasicTracerProvider2, \"BasicTracerProvider\");\n  BasicTracerProvider2.prototype.getTracer = function(name, version, options) {\n    var key = name + \"@\" + (version || \"\") + \":\" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || \"\");\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));\n    }\n    return this._tracers.get(key);\n  };\n  BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {\n    if (this._registeredSpanProcessors.length === 0) {\n      this.activeSpanProcessor.shutdown().catch(function(err) {\n        return diag2.error(\"Error while trying to shutdown current span processor\", err);\n      });\n    }\n    this._registeredSpanProcessors.push(spanProcessor);\n    this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n  };\n  BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {\n    return this.activeSpanProcessor;\n  };\n  BasicTracerProvider2.prototype.register = function(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    trace.setGlobalTracerProvider(this);\n    if (config2.propagator === void 0) {\n      config2.propagator = this._buildPropagatorFromEnv();\n    }\n    if (config2.contextManager) {\n      context2.setGlobalContextManager(config2.contextManager);\n    }\n    if (config2.propagator) {\n      propagation.setGlobalPropagator(config2.propagator);\n    }\n  };\n  BasicTracerProvider2.prototype.forceFlush = function() {\n    var timeout = this._config.forceFlushTimeoutMillis;\n    var promises = this._registeredSpanProcessors.map(function(spanProcessor) {\n      return new Promise(function(resolve) {\n        var state;\n        var timeoutInterval = setTimeout(function() {\n          resolve(new Error(\"Span processor did not completed within timeout period of \" + timeout + \" ms\"));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(function() {\n          clearTimeout(timeoutInterval);\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(function(error2) {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error2);\n        });\n      });\n    });\n    return new Promise(function(resolve, reject) {\n      Promise.all(promises).then(function(results) {\n        var errors = results.filter(function(result) {\n          return result !== ForceFlushState.resolved;\n        });\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(function(error2) {\n        return reject([error2]);\n      });\n    });\n  };\n  BasicTracerProvider2.prototype.shutdown = function() {\n    return this.activeSpanProcessor.shutdown();\n  };\n  BasicTracerProvider2.prototype._getPropagator = function(name) {\n    var _a3;\n    return (_a3 = this.constructor._registeredPropagators.get(name)) === null || _a3 === void 0 ? void 0 : _a3();\n  };\n  BasicTracerProvider2.prototype._getSpanExporter = function(name) {\n    var _a3;\n    return (_a3 = this.constructor._registeredExporters.get(name)) === null || _a3 === void 0 ? void 0 : _a3();\n  };\n  BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {\n    var _this = this;\n    var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));\n    var propagators = uniquePropagatorNames.map(function(name) {\n      var propagator = _this._getPropagator(name);\n      if (!propagator) {\n        diag2.warn('Propagator \"' + name + '\" requested through environment variable is unavailable.');\n      }\n      return propagator;\n    });\n    var validPropagators = propagators.reduce(function(list, item) {\n      if (item) {\n        list.push(item);\n      }\n      return list;\n    }, []);\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators\n      });\n    }\n  };\n  BasicTracerProvider2.prototype._buildExporterFromEnv = function() {\n    var exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === \"none\")\n      return;\n    var exporter = this._getSpanExporter(exporterName);\n    if (!exporter) {\n      diag2.error('Exporter \"' + exporterName + '\" requested through environment variable is unavailable.');\n    }\n    return exporter;\n  };\n  BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([\n    [\"tracecontext\", function() {\n      return new W3CTraceContextPropagator();\n    }],\n    [\"baggage\", function() {\n      return new W3CBaggagePropagator();\n    }]\n  ]);\n  BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();\n  return BasicTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ConsoleSpanExporter.js\nvar __values6 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar ConsoleSpanExporter = function() {\n  function ConsoleSpanExporter2() {\n  }\n  __name(ConsoleSpanExporter2, \"ConsoleSpanExporter\");\n  ConsoleSpanExporter2.prototype.export = function(spans, resultCallback) {\n    return this._sendSpans(spans, resultCallback);\n  };\n  ConsoleSpanExporter2.prototype.shutdown = function() {\n    this._sendSpans([]);\n    return Promise.resolve();\n  };\n  ConsoleSpanExporter2.prototype._exportInfo = function(span) {\n    return {\n      traceId: span.spanContext().traceId,\n      parentId: span.parentSpanId,\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links\n    };\n  };\n  ConsoleSpanExporter2.prototype._sendSpans = function(spans, done) {\n    var e_1, _a3;\n    try {\n      for (var spans_1 = __values6(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {\n        var span = spans_1_1.value;\n        console.dir(this._exportInfo(span), { depth: 3 });\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (spans_1_1 && !spans_1_1.done && (_a3 = spans_1.return))\n          _a3.call(spans_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  };\n  return ConsoleSpanExporter2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/InMemorySpanExporter.js\nvar __read6 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray4 = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar InMemorySpanExporter = function() {\n  function InMemorySpanExporter2() {\n    this._finishedSpans = [];\n    this._stopped = false;\n  }\n  __name(InMemorySpanExporter2, \"InMemorySpanExporter\");\n  InMemorySpanExporter2.prototype.export = function(spans, resultCallback) {\n    var _a3;\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error(\"Exporter has been stopped\")\n      });\n    (_a3 = this._finishedSpans).push.apply(_a3, __spreadArray4([], __read6(spans), false));\n    setTimeout(function() {\n      return resultCallback({ code: ExportResultCode.SUCCESS });\n    }, 0);\n  };\n  InMemorySpanExporter2.prototype.shutdown = function() {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return Promise.resolve();\n  };\n  InMemorySpanExporter2.prototype.reset = function() {\n    this._finishedSpans = [];\n  };\n  InMemorySpanExporter2.prototype.getFinishedSpans = function() {\n    return this._finishedSpans;\n  };\n  return InMemorySpanExporter2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SimpleSpanProcessor.js\nvar SimpleSpanProcessor = function() {\n  function SimpleSpanProcessor2(_exporter) {\n    this._exporter = _exporter;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n  __name(SimpleSpanProcessor2, \"SimpleSpanProcessor\");\n  SimpleSpanProcessor2.prototype.forceFlush = function() {\n    return Promise.resolve();\n  };\n  SimpleSpanProcessor2.prototype.onStart = function(_span, _parentContext) {\n  };\n  SimpleSpanProcessor2.prototype.onEnd = function(span) {\n    var _this = this;\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    context2.with(suppressTracing(context2.active()), function() {\n      _this._exporter.export([span], function(result) {\n        var _a3;\n        if (result.code !== ExportResultCode.SUCCESS) {\n          globalErrorHandler((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error(\"SimpleSpanProcessor: span export failed (status \" + result + \")\"));\n        }\n      });\n    });\n  };\n  SimpleSpanProcessor2.prototype.shutdown = function() {\n    return this._shutdownOnce.call();\n  };\n  SimpleSpanProcessor2.prototype._shutdown = function() {\n    return this._exporter.shutdown();\n  };\n  return SimpleSpanProcessor2;\n}();\n\n// ../engine-core/src/tracing/createSpan.ts\nasync function createSpan(engineSpanEvent) {\n  await new Promise((res) => setTimeout(res, 0));\n  const tracer = trace.getTracer(\"prisma\");\n  engineSpanEvent.spans.forEach((engineSpan) => {\n    var _a3;\n    const spanContext = {\n      traceId: engineSpan.trace_id,\n      spanId: engineSpan.span_id,\n      traceFlags: TraceFlags.SAMPLED\n    };\n    const links = (_a3 = engineSpan.links) == null ? void 0 : _a3.map((link) => {\n      return {\n        context: {\n          traceId: link.trace_id,\n          spanId: link.span_id,\n          traceFlags: TraceFlags.SAMPLED\n        }\n      };\n    });\n    const span = new Span(\n      tracer,\n      ROOT_CONTEXT,\n      engineSpan.name,\n      spanContext,\n      SpanKind.INTERNAL,\n      engineSpan.parent_span_id,\n      links,\n      engineSpan.start_time\n    );\n    if (engineSpan.attributes) {\n      span.setAttributes(engineSpan.attributes);\n    }\n    span.end(engineSpan.end_time);\n  });\n}\n__name(createSpan, \"createSpan\");\n\n// ../engine-core/src/tracing/getTraceParent.ts\nfunction getTraceParent({\n  context: context3,\n  tracingConfig\n}) {\n  const span = trace.getSpanContext(context3 != null ? context3 : context2.active());\n  if ((tracingConfig == null ? void 0 : tracingConfig.enabled) && (span == null ? void 0 : span.traceFlags) === 1) {\n    return `00-${span.traceId}-${span.spanId}-01`;\n  } else {\n    return `00-00-00-00`;\n  }\n}\n__name(getTraceParent, \"getTraceParent\");\n\n// ../engine-core/src/tracing/getTracingConfig.ts\nfunction getTracingConfig(previewFeatures) {\n  const hasTracingPreviewFeatureFlagEnabled = previewFeatures.includes(\"tracing\");\n  return {\n    get enabled() {\n      return Boolean(globalThis.PRISMA_INSTRUMENTATION && hasTracingPreviewFeatureFlagEnabled);\n    },\n    get middleware() {\n      return Boolean(globalThis.PRISMA_INSTRUMENTATION && globalThis.PRISMA_INSTRUMENTATION.middleware);\n    }\n  };\n}\n__name(getTracingConfig, \"getTracingConfig\");\n\n// ../engine-core/src/tracing/runInChildSpan.ts\nasync function runInChildSpan(options, cb) {\n  var _a3;\n  if (options.enabled === false)\n    return cb();\n  const tracer = trace.getTracer(\"prisma\");\n  const context3 = (_a3 = options.context) != null ? _a3 : context2.active();\n  if (options.active === false) {\n    const span = tracer.startSpan(`prisma:client:${options.name}`, options, context3);\n    try {\n      return await cb(span, context3);\n    } finally {\n      span.end();\n    }\n  }\n  return tracer.startActiveSpan(`prisma:client:${options.name}`, options, context3, async (span) => {\n    try {\n      return await cb(span, context2.active());\n    } finally {\n      span.end();\n    }\n  });\n}\n__name(runInChildSpan, \"runInChildSpan\");\n\n// ../engine-core/src/binary/Connection.ts\nvar import_get_stream = __toESM(require_get_stream());\nvar undici = /* @__PURE__ */ __name(() => require_undici(), \"undici\");\nfunction assertHasPool(pool) {\n  if (pool === void 0) {\n    throw new Error(\"Connection has not been opened\");\n  }\n}\n__name(assertHasPool, \"assertHasPool\");\nvar Connection = class {\n  constructor() {\n  }\n  static async onHttpError(response, handler) {\n    const _response = await response;\n    if (_response.statusCode >= 400) {\n      return handler(_response);\n    }\n    return _response;\n  }\n  open(url, options) {\n    if (this._pool)\n      return;\n    this._pool = new (undici()).Pool(url, {\n      connections: 1e3,\n      keepAliveMaxTimeout: 6e5,\n      headersTimeout: 0,\n      bodyTimeout: 0,\n      ...options\n    });\n  }\n  async raw(method, endpoint, headers, body, parseResponse = true) {\n    assertHasPool(this._pool);\n    const response = await this._pool.request({\n      path: endpoint,\n      method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body\n    });\n    const bodyString = await (0, import_get_stream.default)(response.body);\n    return {\n      statusCode: response.statusCode,\n      headers: response.headers,\n      data: parseResponse ? JSON.parse(bodyString) : bodyString\n    };\n  }\n  post(endpoint, body, headers, parseResponse) {\n    return this.raw(\"POST\", endpoint, headers, body, parseResponse);\n  }\n  get(path7, headers) {\n    return this.raw(\"GET\", path7, headers);\n  }\n  close() {\n    if (this._pool) {\n      this._pool.close(() => {\n      });\n    }\n    this._pool = void 0;\n  }\n};\n__name(Connection, \"Connection\");\n\n// ../engine-core/src/binary/BinaryEngine.ts\nvar debug4 = src_default(\"prisma:engine\");\nvar exists2 = (0, import_util4.promisify)(import_fs4.default.exists);\nvar logger = /* @__PURE__ */ __name((...args) => {\n}, \"logger\");\nvar knownPlatforms = [...platforms, \"native\"];\nvar engines = [];\nvar socketPaths = [];\nvar MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;\nvar MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;\nvar BinaryEngine = class extends Engine {\n  constructor({\n    cwd,\n    datamodelPath,\n    prismaPath,\n    generator,\n    datasources,\n    showColors,\n    logLevel,\n    logQueries,\n    env: env2,\n    flags,\n    clientVersion: clientVersion2,\n    previewFeatures,\n    engineEndpoint,\n    enableDebugLogs,\n    allowTriggerPanic,\n    dirname: dirname2,\n    activeProvider,\n    tracingConfig\n  }) {\n    var _a3;\n    super();\n    this.startCount = 0;\n    this.previewFeatures = [];\n    this.stderrLogs = \"\";\n    this.handleRequestError = /* @__PURE__ */ __name(async (error2, graceful = false) => {\n      var _a3, _b2;\n      debug4({ error: error2 });\n      if (this.startPromise) {\n        await this.startPromise;\n      }\n      this.throwAsyncErrorIfExists();\n      if ((_a3 = this.currentRequestPromise) == null ? void 0 : _a3.isCanceled) {\n        this.throwAsyncErrorIfExists();\n      } else if (error2.code === \"ECONNRESET\" || error2.code === \"ECONNREFUSED\" || error2.code === \"UND_ERR_CLOSED\" || error2.code === \"UND_ERR_SOCKET\" || error2.code === \"UND_ERR_DESTROYED\" || error2.code === \"UND_ERR_ABORTED\" || error2.message.toLowerCase().includes(\"client is destroyed\") || error2.message.toLowerCase().includes(\"other side closed\") || error2.message.toLowerCase().includes(\"the client is closed\")) {\n        if (this.globalKillSignalReceived && !((_b2 = this.child) == null ? void 0 : _b2.connected)) {\n          throw new PrismaClientUnknownRequestError(\n            `The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited\nand your request can't be processed.\nYou probably have some open handle that prevents your process from exiting.\nIt could be an open http server or stream that didn't close yet.\nWe recommend using the \\`wtfnode\\` package to debug open handles.`,\n            this.clientVersion\n          );\n        }\n        this.throwAsyncErrorIfExists();\n        if (this.startCount > MAX_STARTS) {\n          for (let i = 0; i < 5; i++) {\n            await new Promise((r) => setTimeout(r, 50));\n            this.throwAsyncErrorIfExists(true);\n          }\n          throw new Error(`Query engine is trying to restart, but can't.\nPlease look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);\n        }\n      }\n      if (!graceful) {\n        this.throwAsyncErrorIfExists(true);\n        throw error2;\n      }\n      return false;\n    }, \"handleRequestError\");\n    this.dirname = dirname2;\n    this.env = env2;\n    this.cwd = this.resolveCwd(cwd);\n    this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;\n    this.allowTriggerPanic = allowTriggerPanic != null ? allowTriggerPanic : false;\n    this.datamodelPath = datamodelPath;\n    this.prismaPath = (_a3 = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a3 : prismaPath;\n    this.generator = generator;\n    this.datasources = datasources;\n    this.tracingConfig = tracingConfig;\n    this.logEmitter = new import_events.default();\n    this.logEmitter.on(\"error\", () => {\n    });\n    this.showColors = showColors != null ? showColors : false;\n    this.logLevel = logLevel;\n    this.logQueries = logQueries != null ? logQueries : false;\n    this.clientVersion = clientVersion2;\n    this.flags = flags != null ? flags : [];\n    this.previewFeatures = previewFeatures != null ? previewFeatures : [];\n    this.activeProvider = activeProvider;\n    this.connection = new Connection();\n    initHooks();\n    const removedFlags = [\n      \"middlewares\",\n      \"aggregateApi\",\n      \"distinct\",\n      \"aggregations\",\n      \"insensitiveFilters\",\n      \"atomicNumberOperations\",\n      \"transactionApi\",\n      \"transaction\",\n      \"connectOrCreate\",\n      \"uncheckedScalarInputs\",\n      \"nativeTypes\",\n      \"createMany\",\n      \"groupBy\",\n      \"referentialActions\",\n      \"microsoftSqlServer\"\n    ];\n    const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));\n    if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {\n      console.log(\n        `${import_chalk3.default.blueBright(\"info\")} The preview flags \\`${removedFlagsUsed.join(\n          \"`, `\"\n        )}\\` were removed, you can now safely remove them from your schema.prisma.`\n      );\n    }\n    this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));\n    this.engineEndpoint = engineEndpoint;\n    if (engineEndpoint) {\n      const url = new import_url.URL(engineEndpoint);\n      this.port = Number(url.port);\n    }\n    if (this.platform) {\n      if (!knownPlatforms.includes(this.platform) && !import_fs4.default.existsSync(this.platform)) {\n        throw new PrismaClientInitializationError(\n          `Unknown ${import_chalk3.default.red(\"PRISMA_QUERY_ENGINE_BINARY\")} ${import_chalk3.default.redBright.bold(\n            this.platform\n          )}. Possible binaryTargets: ${import_chalk3.default.greenBright(\n            knownPlatforms.join(\", \")\n          )} or a path to the query engine binary.\nYou may have to run ${import_chalk3.default.greenBright(\"prisma generate\")} for your changes to take effect.`,\n          this.clientVersion\n        );\n      }\n    } else {\n      void this.getPlatform();\n    }\n    if (this.enableDebugLogs) {\n      src_default.enable(\"*\");\n    }\n    engines.push(this);\n    this.checkForTooManyEngines();\n  }\n  setError(err) {\n    var _a3;\n    if (isRustError(err)) {\n      this.lastRustError = err;\n      this.logEmitter.emit(\n        \"error\",\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion,\n          error: err\n        })\n      );\n      if (err.is_panic) {\n        this.handlePanic();\n      }\n    } else if (isRustErrorLog(err)) {\n      this.lastErrorLog = err;\n      this.logEmitter.emit(\n        \"error\",\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion,\n          log: err\n        })\n      );\n      if (((_a3 = err.fields) == null ? void 0 : _a3.message) === \"PANIC\") {\n        this.handlePanic();\n      }\n    } else {\n      this.logEmitter.emit(\"error\", err);\n    }\n  }\n  checkForTooManyEngines() {\n    if (engines.length >= 10) {\n      const runningEngines = engines.filter((e) => e.child);\n      if (runningEngines.length === 10) {\n        console.warn(\n          `${import_chalk3.default.yellow(\"warn(prisma-client)\")} There are already 10 instances of Prisma Client actively running.`\n        );\n      }\n    }\n  }\n  resolveCwd(cwd) {\n    if (cwd && import_fs4.default.existsSync(cwd) && import_fs4.default.lstatSync(cwd).isDirectory()) {\n      return cwd;\n    }\n    return process.cwd();\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      this.beforeExitListener = listener;\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async emitExit() {\n    if (this.beforeExitListener) {\n      try {\n        await this.beforeExitListener();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n  async getPlatform() {\n    if (this.platformPromise) {\n      return this.platformPromise;\n    }\n    this.platformPromise = getPlatform();\n    return this.platformPromise;\n  }\n  getQueryEnginePath(platform3, prefix = __dirname) {\n    let queryEnginePath = import_path2.default.join(prefix, `query-engine-${platform3}`);\n    if (platform3 === \"windows\") {\n      queryEnginePath = `${queryEnginePath}.exe`;\n    }\n    return queryEnginePath;\n  }\n  handlePanic() {\n    var _a3;\n    if (this.child) {\n      this.stopPromise = killProcessAndWait(this.child);\n    }\n    if ((_a3 = this.currentRequestPromise) == null ? void 0 : _a3.cancel) {\n      this.currentRequestPromise.cancel();\n    }\n  }\n  async resolvePrismaPath() {\n    var _a3, _b2, _c;\n    const searchedLocations = [];\n    let enginePath;\n    if (this.prismaPath) {\n      return { prismaPath: this.prismaPath, searchedLocations };\n    }\n    const platform = await this.getPlatform();\n    if (this.platform && this.platform !== platform) {\n      this.incorrectlyPinnedBinaryTarget = this.platform;\n    }\n    this.platform = this.platform || platform;\n    if (__filename.includes(\"BinaryEngine\")) {\n      enginePath = this.getQueryEnginePath(this.platform, getEnginesPath());\n      return { prismaPath: enginePath, searchedLocations };\n    }\n    const searchLocations = [\n      eval(`require('path').join(__dirname, '../../../.prisma/client')`),\n      (_c = (_b2 = (_a3 = this.generator) == null ? void 0 : _a3.output) == null ? void 0 : _b2.value) != null ? _c : eval(\"__dirname\"),\n      import_path2.default.join(eval(\"__dirname\"), \"..\"),\n      import_path2.default.dirname(this.datamodelPath),\n      this.cwd,\n      \"/tmp/prisma-engines\"\n    ];\n    if (this.dirname) {\n      searchLocations.push(this.dirname);\n    }\n    for (const location of searchLocations) {\n      searchedLocations.push(location);\n      debug4(`Search for Query Engine in ${location}`);\n      enginePath = this.getQueryEnginePath(this.platform, location);\n      if (import_fs4.default.existsSync(enginePath)) {\n        return { prismaPath: enginePath, searchedLocations };\n      }\n    }\n    enginePath = this.getQueryEnginePath(this.platform);\n    return { prismaPath: enginePath != null ? enginePath : \"\", searchedLocations };\n  }\n  async getPrismaPath() {\n    const { prismaPath, searchedLocations: searchedLocations2 } = await this.resolvePrismaPath();\n    const platform3 = await this.getPlatform();\n    if (!await exists2(prismaPath)) {\n      const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `\nYou incorrectly pinned it to ${import_chalk3.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}\n` : \"\";\n      let errorText = `Query engine binary for current platform \"${import_chalk3.default.bold(\n        platform3\n      )}\" could not be found.${pinnedStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${import_chalk3.default.underline(prismaPath)}\")\n\nSearched Locations:\n\n${searchedLocations2.map((f) => {\n        let msg = `  ${f}`;\n        if (process.env.DEBUG === \"node-engine-search-locations\" && import_fs4.default.existsSync(f)) {\n          const dir = import_fs4.default.readdirSync(f);\n          msg += dir.map((d) => `    ${d}`).join(\"\\n\");\n        }\n        return msg;\n      }).join(\"\\n\" + (process.env.DEBUG === \"node-engine-search-locations\" ? \"\\n\" : \"\"))}\n`;\n      if (this.generator) {\n        if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === \"native\")) {\n          errorText += `\nYou already added the platform${this.generator.binaryTargets.length > 1 ? \"s\" : \"\"} ${this.generator.binaryTargets.map((t) => `\"${import_chalk3.default.bold(t.value)}\"`).join(\", \")} to the \"${import_chalk3.default.underline(\"generator\")}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`;\n          errorText += ``;\n        } else {\n          errorText += `\n\nTo solve this problem, add the platform \"${this.platform}\" to the \"${import_chalk3.default.underline(\n            \"binaryTargets\"\n          )}\" attribute in the \"${import_chalk3.default.underline(\"generator\")}\" block in the \"schema.prisma\" file:\n${import_chalk3.default.greenBright(this.getFixedGenerator())}\n\nThen run \"${import_chalk3.default.greenBright(\"prisma generate\")}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`;\n        }\n      } else {\n        errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;\n      }\n      throw new PrismaClientInitializationError(errorText, this.clientVersion);\n    }\n    if (this.incorrectlyPinnedBinaryTarget) {\n      console.error(`${import_chalk3.default.yellow(\"Warning:\")} You pinned the platform ${import_chalk3.default.bold(\n        this.incorrectlyPinnedBinaryTarget\n      )}, but Prisma Client detects ${import_chalk3.default.bold(await this.getPlatform())}.\nThis means you should very likely pin the platform ${import_chalk3.default.greenBright(await this.getPlatform())} instead.\n${import_chalk3.default.dim(\"In case we're mistaken, please report this to us \\u{1F64F}.\")}`);\n    }\n    if (process.platform !== \"win32\") {\n      plusX(prismaPath);\n    }\n    return prismaPath;\n  }\n  getFixedGenerator() {\n    const fixedGenerator = {\n      ...this.generator,\n      binaryTargets: fixBinaryTargets(this.generator.binaryTargets, this.platform)\n    };\n    return printGeneratorConfig(fixedGenerator);\n  }\n  printDatasources() {\n    if (this.datasources) {\n      return JSON.stringify(this.datasources);\n    }\n    return \"[]\";\n  }\n  async start() {\n    if (this.stopPromise) {\n      await this.stopPromise;\n    }\n    const startFn = /* @__PURE__ */ __name(async () => {\n      if (!this.startPromise) {\n        this.startCount++;\n        this.startPromise = this.internalStart();\n      }\n      await this.startPromise;\n      if (!this.child && !this.engineEndpoint) {\n        throw new PrismaClientUnknownRequestError(\n          `Can't perform request, as the Engine has already been stopped`,\n          this.clientVersion\n        );\n      }\n    }, \"startFn\");\n    const spanOptions = {\n      name: \"connect\",\n      enabled: this.tracingConfig.enabled && !this.startPromise\n    };\n    return runInChildSpan(spanOptions, startFn);\n  }\n  getEngineEnvVars() {\n    var _a3, _b2;\n    const env2 = {\n      PRISMA_DML_PATH: this.datamodelPath\n    };\n    if (this.logQueries || this.logLevel === \"info\") {\n      if (this.logQueries) {\n        env2.LOG_QUERIES = \"true\";\n      }\n    }\n    if (this.datasources) {\n      env2.OVERWRITE_DATASOURCES = this.printDatasources();\n    }\n    if (!process.env.NO_COLOR && this.showColors) {\n      env2.CLICOLOR_FORCE = \"1\";\n    }\n    return {\n      ...this.env,\n      ...process.env,\n      ...env2,\n      RUST_BACKTRACE: (_a3 = process.env.RUST_BACKTRACE) != null ? _a3 : \"1\",\n      RUST_LOG: (_b2 = process.env.RUST_LOG) != null ? _b2 : \"info\"\n    };\n  }\n  internalStart() {\n    return new Promise(async (resolve, reject) => {\n      var _a3, _b2, _c;\n      await new Promise((r) => process.nextTick(r));\n      if (this.stopPromise) {\n        await this.stopPromise;\n      }\n      if (this.engineEndpoint) {\n        try {\n          this.connection.open(this.engineEndpoint);\n          await (0, import_p_retry.default)(() => this.connection.get(\"/status\"), {\n            retries: 10\n          });\n        } catch (e) {\n          return reject(e);\n        }\n        return resolve();\n      }\n      try {\n        if (((_a3 = this.child) == null ? void 0 : _a3.connected) || this.child && !((_b2 = this.child) == null ? void 0 : _b2.killed)) {\n          debug4(`There is a child that still runs and we want to start again`);\n        }\n        this.lastRustError = void 0;\n        this.lastErrorLog = void 0;\n        this.lastPanic = void 0;\n        logger(\"startin & resettin\");\n        this.globalKillSignalReceived = void 0;\n        debug4({ cwd: this.cwd });\n        const prismaPath = await this.getPrismaPath();\n        const additionalFlag = this.allowTriggerPanic ? [\"--debug\"] : [];\n        const flags = [\n          \"--enable-raw-queries\",\n          \"--enable-metrics\",\n          \"--enable-open-telemetry\",\n          ...this.flags,\n          ...additionalFlag\n        ];\n        this.port = await this.getFreePort();\n        flags.push(\"--port\", String(this.port));\n        debug4({ flags });\n        const env2 = this.getEngineEnvVars();\n        this.child = (0, import_child_process2.spawn)(prismaPath, flags, {\n          env: env2,\n          cwd: this.cwd,\n          windowsHide: true,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"]\n        });\n        byline(this.child.stderr).on(\"data\", (msg) => {\n          const data = String(msg);\n          debug4(\"stderr\", data);\n          try {\n            const json = JSON.parse(data);\n            if (typeof json.is_panic !== \"undefined\") {\n              debug4(json);\n              this.setError(json);\n              if (this.engineStartDeferred) {\n                const err = new PrismaClientInitializationError(json.message, this.clientVersion, json.error_code);\n                this.engineStartDeferred.reject(err);\n              }\n            }\n          } catch (e) {\n            if (!data.includes(\"Printing to stderr\") && !data.includes(\"Listening on \")) {\n              this.stderrLogs += \"\\n\" + data;\n            }\n          }\n        });\n        byline(this.child.stdout).on(\"data\", (msg) => {\n          var _a4, _b3;\n          const data = String(msg);\n          try {\n            const json = JSON.parse(data);\n            debug4(\"stdout\", getMessage(json));\n            if (this.engineStartDeferred && json.level === \"INFO\" && json.target === \"query_engine::server\" && ((_b3 = (_a4 = json.fields) == null ? void 0 : _a4.message) == null ? void 0 : _b3.startsWith(\"Started query engine http server\"))) {\n              this.connection.open(`http://127.0.0.1:${this.port}`);\n              this.engineStartDeferred.resolve();\n              this.engineStartDeferred = void 0;\n            }\n            if (typeof json.is_panic === \"undefined\") {\n              if (json.span === true) {\n                if (this.tracingConfig.enabled === true) {\n                  void createSpan(json);\n                }\n                return;\n              }\n              const log4 = convertLog(json);\n              const logIsRustErrorLog = isRustErrorLog(log4);\n              if (logIsRustErrorLog) {\n                this.setError(log4);\n              } else {\n                this.logEmitter.emit(log4.level, log4);\n              }\n            } else {\n              this.setError(json);\n            }\n          } catch (e) {\n            debug4(e, data);\n          }\n        });\n        this.child.on(\"exit\", (code) => {\n          var _a4;\n          logger(\"removing startPromise\");\n          this.startPromise = void 0;\n          if (this.engineStopDeferred) {\n            this.engineStopDeferred.resolve(code);\n            return;\n          }\n          this.connection.close();\n          if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {\n            let err;\n            let msg = this.stderrLogs;\n            if (this.lastRustError) {\n              msg = getMessage(this.lastRustError);\n            } else if (this.lastErrorLog) {\n              msg = getMessage(this.lastErrorLog);\n            }\n            if (code !== null) {\n              err = new PrismaClientInitializationError(\n                `Query engine exited with code ${code}\n` + msg,\n                this.clientVersion\n              );\n            } else if ((_a4 = this.child) == null ? void 0 : _a4.signalCode) {\n              err = new PrismaClientInitializationError(\n                `Query engine process killed with signal ${this.child.signalCode} for unknown reason.\nMake sure that the engine binary at ${prismaPath} is not corrupt.\n` + msg,\n                this.clientVersion\n              );\n            } else {\n              err = new PrismaClientInitializationError(msg, this.clientVersion);\n            }\n            this.engineStartDeferred.reject(err);\n          }\n          if (!this.child) {\n            return;\n          }\n          if (this.lastRustError) {\n            return;\n          }\n          if (code === 126) {\n            this.setError({\n              timestamp: new Date(),\n              target: \"exit\",\n              level: \"error\",\n              fields: {\n                message: `Couldn't start query engine as it's not executable on this operating system.\nYou very likely have the wrong \"binaryTarget\" defined in the schema.prisma file.`\n              }\n            });\n          }\n        });\n        this.child.on(\"error\", (err) => {\n          this.setError({\n            message: err.message,\n            backtrace: \"Could not start query engine\",\n            is_panic: false\n          });\n          reject(err);\n        });\n        this.child.on(\"close\", (code, signal) => {\n          var _a4;\n          this.connection.close();\n          if (code === null && signal === \"SIGABRT\" && this.child) {\n            const error2 = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\"Panic in Query Engine with SIGABRT signal\"),\n              this.clientVersion\n            );\n            this.logEmitter.emit(\"error\", error2);\n          } else if (code === 255 && signal === null && ((_a4 = this.lastErrorLog) == null ? void 0 : _a4.fields.message) === \"PANIC\" && !this.lastPanic) {\n            const error2 = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\n                `${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`\n              ),\n              this.clientVersion\n            );\n            this.setError(error2);\n          }\n        });\n        if (this.lastRustError) {\n          return reject(new PrismaClientInitializationError(getMessage(this.lastRustError), this.clientVersion));\n        }\n        if (this.lastErrorLog) {\n          return reject(new PrismaClientInitializationError(getMessage(this.lastErrorLog), this.clientVersion));\n        }\n        try {\n          await new Promise((resolve2, reject2) => {\n            this.engineStartDeferred = { resolve: resolve2, reject: reject2 };\n          });\n        } catch (err) {\n          (_c = this.child) == null ? void 0 : _c.kill();\n          throw err;\n        }\n        void (async () => {\n          try {\n            const engineVersion = await this.version(true);\n            debug4(`Client Version: ${this.clientVersion}`);\n            debug4(`Engine Version: ${engineVersion}`);\n            debug4(`Active provider: ${this.activeProvider}`);\n          } catch (e) {\n            debug4(e);\n          }\n        })();\n        this.stopPromise = void 0;\n        resolve();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  async stop() {\n    const stopFn = /* @__PURE__ */ __name(async () => {\n      if (!this.stopPromise) {\n        this.stopPromise = this._stop();\n      }\n      return this.stopPromise;\n    }, \"stopFn\");\n    const spanOptions = {\n      name: \"disconnect\",\n      enabled: this.tracingConfig.enabled\n    };\n    return runInChildSpan(spanOptions, stopFn);\n  }\n  async _stop() {\n    var _a3;\n    if (this.startPromise) {\n      await this.startPromise;\n    }\n    await new Promise((resolve) => process.nextTick(resolve));\n    if (this.currentRequestPromise) {\n      try {\n        await this.currentRequestPromise;\n      } catch (e) {\n      }\n    }\n    this.getConfigPromise = void 0;\n    let stopChildPromise;\n    if (this.child) {\n      debug4(`Stopping Prisma engine4`);\n      if (this.startPromise) {\n        debug4(`Waiting for start promise`);\n        await this.startPromise;\n      }\n      debug4(`Done waiting for start promise`);\n      stopChildPromise = new Promise((resolve, reject) => {\n        this.engineStopDeferred = { resolve, reject };\n      });\n      this.connection.close();\n      (_a3 = this.child) == null ? void 0 : _a3.kill();\n      this.child = void 0;\n    }\n    if (stopChildPromise) {\n      await stopChildPromise;\n    }\n    await new Promise((r) => process.nextTick(r));\n    this.startPromise = void 0;\n    this.engineStopDeferred = void 0;\n  }\n  kill(signal) {\n    var _a3;\n    this.getConfigPromise = void 0;\n    this.globalKillSignalReceived = signal;\n    (_a3 = this.child) == null ? void 0 : _a3.kill();\n    this.connection.close();\n  }\n  getFreePort() {\n    return new Promise((resolve, reject) => {\n      const server = import_net.default.createServer((s) => s.end(\"\"));\n      server.unref();\n      server.on(\"error\", reject);\n      server.listen(0, () => {\n        const address = server.address();\n        const port = typeof address === \"string\" ? parseInt(address.split(\":\").slice(-1)[0], 10) : address.port;\n        server.close((e) => {\n          if (e) {\n            reject(e);\n          }\n          resolve(port);\n        });\n      });\n    });\n  }\n  async getConfig() {\n    if (!this.getConfigPromise) {\n      this.getConfigPromise = this._getConfig();\n    }\n    return this.getConfigPromise;\n  }\n  async _getConfig() {\n    const prismaPath = await this.getPrismaPath();\n    const env2 = await this.getEngineEnvVars();\n    const result = await (0, import_execa.default)(prismaPath, [\"cli\", \"get-config\"], {\n      env: omit(env2, [\"PORT\"]),\n      cwd: this.cwd\n    });\n    return JSON.parse(result.stdout);\n  }\n  async getDmmf() {\n    if (!this.getDmmfPromise) {\n      this.getDmmfPromise = this._getDmmf();\n    }\n    return this.getDmmfPromise;\n  }\n  async _getDmmf() {\n    const prismaPath = await this.getPrismaPath();\n    const env2 = await this.getEngineEnvVars();\n    const result = await (0, import_execa.default)(prismaPath, [\"--enable-raw-queries\", \"cli\", \"dmmf\"], {\n      env: omit(env2, [\"PORT\"]),\n      cwd: this.cwd\n    });\n    return JSON.parse(result.stdout);\n  }\n  async version(forceRun = false) {\n    if (this.versionPromise && !forceRun) {\n      return this.versionPromise;\n    }\n    this.versionPromise = this.internalVersion();\n    return this.versionPromise;\n  }\n  async internalVersion() {\n    const prismaPath = await this.getPrismaPath();\n    const result = await (0, import_execa.default)(prismaPath, [\"--version\"]);\n    this.lastVersion = result.stdout;\n    return this.lastVersion;\n  }\n  async request(query2, headers = {}, numTry = 1) {\n    await this.start();\n    this.currentRequestPromise = this.connection.post(\"/\", stringifyQuery(query2), runtimeHeadersToHttpHeaders(headers));\n    this.lastQuery = query2;\n    try {\n      const { data, headers: headers2 } = await this.currentRequestPromise;\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n        }\n        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);\n      }\n      const elapsed = parseInt(headers2[\"x-elapsed\"]) / 1e3;\n      if (this.startCount > 0) {\n        this.startCount = 0;\n      }\n      this.currentRequestPromise = void 0;\n      return { data, elapsed };\n    } catch (e) {\n      logger(\"req - e\", e);\n      if (e instanceof PrismaClientKnownRequestError) {\n        throw e;\n      }\n      await this.handleRequestError(e, numTry <= MAX_REQUEST_RETRIES);\n      if (numTry <= MAX_REQUEST_RETRIES) {\n        logger(\"trying a retry now\");\n        return this.request(query2, headers, numTry + 1);\n      }\n    }\n    return null;\n  }\n  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {\n    await this.start();\n    const request2 = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction\n    };\n    this.lastQuery = JSON.stringify(request2);\n    this.currentRequestPromise = this.connection.post(\"/\", this.lastQuery, runtimeHeadersToHttpHeaders(headers));\n    return this.currentRequestPromise.then(({ data, headers: headers2 }) => {\n      const elapsed = parseInt(headers2[\"x-elapsed\"]) / 1e3;\n      const { batchResult, errors } = data;\n      if (Array.isArray(batchResult)) {\n        return batchResult.map((result) => {\n          if (result.errors) {\n            throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n          }\n          return {\n            data: result,\n            elapsed\n          };\n        });\n      } else {\n        throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n      }\n    }).catch(async (e) => {\n      const isError2 = await this.handleRequestError(e, numTry < 3);\n      if (!isError2) {\n        if (numTry <= MAX_REQUEST_RETRIES) {\n          return this.requestBatch(queries, headers, transaction, numTry + 1);\n        }\n      }\n      throw isError2;\n    });\n  }\n  async transaction(action, headers, arg2) {\n    var _a3, _b2;\n    await this.start();\n    if (action === \"start\") {\n      const jsonOptions = JSON.stringify({\n        max_wait: (_a3 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a3 : 2e3,\n        timeout: (_b2 = arg2 == null ? void 0 : arg2.timeout) != null ? _b2 : 5e3,\n        isolation_level: arg2 == null ? void 0 : arg2.isolationLevel\n      });\n      const result = await Connection.onHttpError(\n        this.connection.post(\"/transaction/start\", jsonOptions, runtimeHeadersToHttpHeaders(headers)),\n        transactionHttpErrorHandler\n      );\n      return result.data;\n    } else if (action === \"commit\") {\n      await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/commit`), transactionHttpErrorHandler);\n    } else if (action === \"rollback\") {\n      await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/rollback`), transactionHttpErrorHandler);\n    }\n    return void 0;\n  }\n  get hasMaxRestarts() {\n    return this.startCount >= MAX_STARTS;\n  }\n  throwAsyncErrorIfExists(forceThrow = false) {\n    var _a3, _b2;\n    logger(\"throwAsyncErrorIfExists\", this.startCount, this.hasMaxRestarts);\n    if (this.lastRustError) {\n      const err = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(getMessage(this.lastRustError)),\n        this.clientVersion\n      );\n      if (this.lastRustError.is_panic) {\n        this.lastPanic = err;\n      }\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err;\n      }\n    }\n    if (this.lastErrorLog && isRustErrorLog(this.lastErrorLog)) {\n      const err = new PrismaClientUnknownRequestError(\n        this.getErrorMessageWithLink(getMessage(this.lastErrorLog)),\n        this.clientVersion\n      );\n      if (((_b2 = (_a3 = this.lastErrorLog) == null ? void 0 : _a3.fields) == null ? void 0 : _b2.message) === \"PANIC\") {\n        this.lastPanic = err;\n      }\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err;\n      }\n    }\n  }\n  getErrorMessageWithLink(title) {\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.clientVersion,\n      engineVersion: this.lastVersion,\n      database: this.lastActiveProvider,\n      query: this.lastQuery\n    });\n  }\n  async metrics({ format: format2, globalLabels }) {\n    await this.start();\n    const parseResponse = format2 === \"json\";\n    const response = await this.connection.post(\n      `/metrics?format=${encodeURIComponent(format2)}`,\n      JSON.stringify(globalLabels),\n      null,\n      parseResponse\n    );\n    return response.data;\n  }\n};\n__name(BinaryEngine, \"BinaryEngine\");\nfunction stringifyQuery(q) {\n  return `{\"variables\":{},\"query\":${JSON.stringify(q)}}`;\n}\n__name(stringifyQuery, \"stringifyQuery\");\nfunction hookProcess(handler, exit = false) {\n  process.once(handler, async () => {\n    for (const engine of engines) {\n      await engine.emitExit();\n      engine.kill(handler);\n    }\n    engines.splice(0, engines.length);\n    if (socketPaths.length > 0) {\n      for (const socketPath of socketPaths) {\n        try {\n          import_fs4.default.unlinkSync(socketPath);\n        } catch (e) {\n        }\n      }\n    }\n    if (exit && process.listenerCount(handler) === 0) {\n      process.exit();\n    }\n  });\n}\n__name(hookProcess, \"hookProcess\");\nvar hooksInitialized = false;\nfunction initHooks() {\n  if (!hooksInitialized) {\n    hookProcess(\"beforeExit\");\n    hookProcess(\"exit\");\n    hookProcess(\"SIGINT\", true);\n    hookProcess(\"SIGUSR2\", true);\n    hookProcess(\"SIGTERM\", true);\n    hooksInitialized = true;\n  }\n}\n__name(initHooks, \"initHooks\");\nfunction transactionHttpErrorHandler(result) {\n  throw result.data;\n}\n__name(transactionHttpErrorHandler, \"transactionHttpErrorHandler\");\nfunction runtimeHeadersToHttpHeaders(headers) {\n  return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {\n    let httpHeaderKey = runtimeHeaderKey;\n    if (runtimeHeaderKey === \"transactionId\") {\n      httpHeaderKey = \"X-transaction-id\";\n    }\n    acc[httpHeaderKey] = headers[runtimeHeaderKey];\n    return acc;\n  }, {});\n}\n__name(runtimeHeadersToHttpHeaders, \"runtimeHeadersToHttpHeaders\");\nfunction killProcessAndWait(childProcess) {\n  return new Promise((resolve) => {\n    childProcess.once(\"exit\", resolve);\n    childProcess.kill();\n  });\n}\n__name(killProcessAndWait, \"killProcessAndWait\");\n\n// ../engine-core/src/data-proxy/DataProxyEngine.ts\nvar import_events2 = __toESM(__webpack_require__(/*! events */ \"events\"));\n\n// ../engine-core/src/common/errors/PrismaClientError.ts\nvar PrismaClientError = class extends Error {\n  constructor(message, info2) {\n    super(message);\n    this.clientVersion = info2.clientVersion;\n    this.cause = info2.cause;\n  }\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n};\n__name(PrismaClientError, \"PrismaClientError\");\n\n// ../engine-core/src/data-proxy/errors/DataProxyError.ts\nvar DataProxyError = class extends PrismaClientError {\n  constructor(message, info2) {\n    var _a3;\n    super(message, info2);\n    this.isRetryable = (_a3 = info2.isRetryable) != null ? _a3 : true;\n  }\n};\n__name(DataProxyError, \"DataProxyError\");\n\n// ../engine-core/src/data-proxy/errors/utils/setRetryable.ts\nfunction setRetryable(info2, retryable) {\n  return {\n    ...info2,\n    isRetryable: retryable\n  };\n}\n__name(setRetryable, \"setRetryable\");\n\n// ../engine-core/src/data-proxy/errors/ForcedRetryError.ts\nvar ForcedRetryError = class extends DataProxyError {\n  constructor(info2) {\n    super(\"This request must be retried\", setRetryable(info2, true));\n    this.name = \"ForcedRetryError\";\n    this.code = \"P5001\";\n  }\n};\n__name(ForcedRetryError, \"ForcedRetryError\");\n\n// ../engine-core/src/data-proxy/errors/InvalidDatasourceError.ts\nvar InvalidDatasourceError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(message, setRetryable(info2, false));\n    this.name = \"InvalidDatasourceError\";\n    this.code = \"P5002\";\n  }\n};\n__name(InvalidDatasourceError, \"InvalidDatasourceError\");\n\n// ../engine-core/src/data-proxy/errors/NotImplementedYetError.ts\nvar NotImplementedYetError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(message, setRetryable(info2, false));\n    this.name = \"NotImplementedYetError\";\n    this.code = \"P5004\";\n  }\n};\n__name(NotImplementedYetError, \"NotImplementedYetError\");\n\n// ../engine-core/src/data-proxy/errors/DataProxyAPIError.ts\nvar DataProxyAPIError = class extends DataProxyError {\n  constructor(message, info2) {\n    var _a3;\n    super(message, info2);\n    this.response = info2.response;\n    const requestId = (_a3 = this.response.headers) == null ? void 0 : _a3[\"Prisma-Request-Id\"];\n    if (requestId) {\n      const messageSuffix = `(The request id was: ${requestId})`;\n      this.message = this.message + \" \" + messageSuffix;\n    }\n  }\n};\n__name(DataProxyAPIError, \"DataProxyAPIError\");\n\n// ../engine-core/src/data-proxy/errors/SchemaMissingError.ts\nvar SchemaMissingError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Schema needs to be uploaded\", setRetryable(info2, true));\n    this.name = \"SchemaMissingError\";\n    this.code = \"P5005\";\n  }\n};\n__name(SchemaMissingError, \"SchemaMissingError\");\n\n// ../engine-core/src/data-proxy/errors/BadRequestError.ts\nvar BAD_REQUEST_DEFAULT_MESSAGE = \"This request could not be understood by the server\";\nvar BadRequestError = class extends DataProxyAPIError {\n  constructor(info2, message, code) {\n    super(message || BAD_REQUEST_DEFAULT_MESSAGE, setRetryable(info2, false));\n    this.name = \"BadRequestError\";\n    this.code = \"P5000\";\n    if (code)\n      this.code = code;\n  }\n};\n__name(BadRequestError, \"BadRequestError\");\n\n// ../engine-core/src/data-proxy/errors/GatewayTimeoutError.ts\nvar GatewayTimeoutError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Request timed out\", setRetryable(info2, false));\n    this.name = \"GatewayTimeoutError\";\n    this.code = \"P5009\";\n  }\n};\n__name(GatewayTimeoutError, \"GatewayTimeoutError\");\n\n// ../engine-core/src/data-proxy/errors/NotFoundError.ts\nvar NotFoundError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Requested resource does not exist\", setRetryable(info2, false));\n    this.name = \"NotFoundError\";\n    this.code = \"P5003\";\n  }\n};\n__name(NotFoundError, \"NotFoundError\");\n\n// ../engine-core/src/data-proxy/errors/ServerError.ts\nvar SERVER_ERROR_DEFAULT_MESSAGE = \"Unknown server error\";\nvar ServerError = class extends DataProxyAPIError {\n  constructor(info2, message, logs) {\n    super(message || SERVER_ERROR_DEFAULT_MESSAGE, setRetryable(info2, true));\n    this.name = \"ServerError\";\n    this.code = \"P5006\";\n    this.logs = logs;\n  }\n};\n__name(ServerError, \"ServerError\");\n\n// ../engine-core/src/data-proxy/errors/UnauthorizedError.ts\nvar UnauthorizedError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Unauthorized, check your connection string\", setRetryable(info2, false));\n    this.name = \"UnauthorizedError\";\n    this.code = \"P5007\";\n  }\n};\n__name(UnauthorizedError, \"UnauthorizedError\");\n\n// ../engine-core/src/data-proxy/errors/UsageExceededError.ts\nvar UsageExceededError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Usage exceeded, retry again later\", setRetryable(info2, true));\n    this.name = \"UsageExceededError\";\n    this.code = \"P5008\";\n  }\n};\n__name(UsageExceededError, \"UsageExceededError\");\n\n// ../engine-core/src/data-proxy/errors/utils/responseToError.ts\nasync function responseToError(response, clientVersion2) {\n  var _a3, _b2, _c, _d, _e;\n  if (response.ok)\n    return void 0;\n  const info2 = { clientVersion: clientVersion2, response };\n  if (response.status === 400) {\n    let knownError;\n    try {\n      const body = await response.json();\n      knownError = (_b2 = (_a3 = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _a3.reason) == null ? void 0 : _b2.KnownEngineStartupError;\n    } catch (_) {\n    }\n    if (knownError) {\n      throw new BadRequestError(info2, knownError.msg, knownError.error_code);\n    }\n  }\n  if (response.status === 401) {\n    throw new UnauthorizedError(info2);\n  }\n  if (response.status === 404) {\n    try {\n      const body = await response.json();\n      const isSchemaMissing = ((_c = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _c.reason) === \"SchemaMissing\";\n      return isSchemaMissing ? new SchemaMissingError(info2) : new NotFoundError(info2);\n    } catch (err) {\n      return new NotFoundError(info2);\n    }\n  }\n  if (response.status === 429) {\n    throw new UsageExceededError(info2);\n  }\n  if (response.status === 504) {\n    throw new GatewayTimeoutError(info2);\n  }\n  if (response.status >= 500) {\n    let body;\n    try {\n      body = await response.json();\n    } catch (err) {\n      throw new ServerError(info2);\n    }\n    if (typeof ((_d = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _d.reason) === \"string\") {\n      throw new ServerError(info2, body.EngineNotStarted.reason);\n    } else if (typeof ((_e = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _e.reason) === \"object\") {\n      const keys2 = Object.keys(body.EngineNotStarted.reason);\n      if (keys2.length > 0) {\n        const reason = body.EngineNotStarted.reason;\n        const content = reason[keys2[0]];\n        throw new ServerError(info2, keys2[0], content.logs);\n      }\n    }\n    throw new ServerError(info2);\n  }\n  if (response.status >= 400) {\n    throw new BadRequestError(info2);\n  }\n  return void 0;\n}\n__name(responseToError, \"responseToError\");\n\n// ../engine-core/src/data-proxy/utils/backOff.ts\nvar BACKOFF_INTERVAL = 50;\nfunction backOff(n) {\n  const baseDelay = Math.pow(2, n) * BACKOFF_INTERVAL;\n  const jitter = Math.ceil(Math.random() * baseDelay) - Math.ceil(baseDelay / 2);\n  const total = baseDelay + jitter;\n  return new Promise((done) => setTimeout(() => done(total), total));\n}\n__name(backOff, \"backOff\");\n\n// ../engines/package.json\nvar devDependencies = {\n  \"@prisma/debug\": \"workspace:4.3.1\",\n  \"@prisma/engines-version\": \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\",\n  \"@prisma/fetch-engine\": \"workspace:4.3.1\",\n  \"@prisma/get-platform\": \"workspace:4.3.1\",\n  \"@swc/core\": \"1.2.242\",\n  \"@swc/jest\": \"0.2.22\",\n  \"@types/jest\": \"28.1.7\",\n  \"@types/node\": \"16.11.56\",\n  execa: \"5.1.1\",\n  jest: \"28.1.3\",\n  typescript: \"4.8.2\"\n};\n\n// ../engine-core/src/data-proxy/errors/NetworkError.ts\nvar RequestError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(`Cannot fetch data from service:\n${message}`, setRetryable(info2, true));\n    this.name = \"RequestError\";\n    this.code = \"P5010\";\n  }\n};\n__name(RequestError, \"RequestError\");\n\n// ../engine-core/src/data-proxy/utils/getJSRuntimeName.ts\nfunction getJSRuntimeName() {\n  if (typeof self === \"undefined\") {\n    return \"node\";\n  }\n  return \"browser\";\n}\n__name(getJSRuntimeName, \"getJSRuntimeName\");\n\n// ../engine-core/src/data-proxy/utils/request.ts\nasync function request(url, options) {\n  var _a3;\n  const clientVersion2 = options.clientVersion;\n  const jsRuntimeName = getJSRuntimeName();\n  try {\n    if (jsRuntimeName === \"browser\") {\n      return await fetch(url, options);\n    } else {\n      return await nodeFetch(url, options);\n    }\n  } catch (e) {\n    const message = (_a3 = e.message) != null ? _a3 : \"Unknown error\";\n    throw new RequestError(message, { clientVersion: clientVersion2 });\n  }\n}\n__name(request, \"request\");\nfunction buildHeaders(options) {\n  return {\n    ...options.headers,\n    \"Content-Type\": \"application/json\"\n  };\n}\n__name(buildHeaders, \"buildHeaders\");\nfunction buildOptions(options) {\n  return {\n    method: options.method,\n    headers: buildHeaders(options)\n  };\n}\n__name(buildOptions, \"buildOptions\");\nfunction buildResponse(incomingData, response) {\n  return {\n    text: () => Buffer.concat(incomingData).toString(),\n    json: () => JSON.parse(Buffer.concat(incomingData).toString()),\n    ok: response.statusCode >= 200 && response.statusCode <= 299,\n    status: response.statusCode,\n    url: response.url,\n    headers: response.headers\n  };\n}\n__name(buildResponse, \"buildResponse\");\nasync function nodeFetch(url, options = {}) {\n  const https = include(\"https\");\n  const httpsOptions = buildOptions(options);\n  const incomingData = [];\n  const { origin } = new URL(url);\n  return new Promise((resolve, reject) => {\n    var _a3;\n    const request2 = https.request(url, httpsOptions, (response) => {\n      const { statusCode, headers: { location } } = response;\n      if (statusCode >= 301 && statusCode <= 399 && location) {\n        if (location.startsWith(\"http\") === false) {\n          resolve(nodeFetch(`${origin}${location}`, options));\n        } else {\n          resolve(nodeFetch(location, options));\n        }\n      }\n      response.on(\"data\", (chunk) => incomingData.push(chunk));\n      response.on(\"end\", () => resolve(buildResponse(incomingData, response)));\n      response.on(\"error\", reject);\n    });\n    request2.on(\"error\", reject);\n    request2.end((_a3 = options.body) != null ? _a3 : \"\");\n  });\n}\n__name(nodeFetch, \"nodeFetch\");\nvar include = undefined;\n\n// ../engine-core/src/data-proxy/utils/getClientVersion.ts\nvar semverRegex = /^[1-9][0-9]*\\.[0-9]+\\.[0-9]+$/;\nvar debug5 = src_default(\"prisma:client:dataproxyEngine\");\nasync function _getClientVersion(config2) {\n  var _a3, _b2, _c;\n  const engineVersion = devDependencies[\"@prisma/engines-version\"];\n  const clientVersion2 = (_a3 = config2.clientVersion) != null ? _a3 : \"unknown\";\n  if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) {\n    return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;\n  }\n  const [version, suffix] = (_b2 = clientVersion2 == null ? void 0 : clientVersion2.split(\"-\")) != null ? _b2 : [];\n  if (suffix === void 0 && semverRegex.test(version)) {\n    return version;\n  }\n  if (suffix !== void 0 || clientVersion2 === \"0.0.0\") {\n    const [version2] = (_c = engineVersion.split(\"-\")) != null ? _c : [];\n    const [major2, minor, patch] = version2.split(\".\");\n    const pkgURL = prismaPkgURL(`<=${major2}.${minor}.${patch}`);\n    const res = await request(pkgURL, { clientVersion: clientVersion2 });\n    const bodyAsText = await res.text();\n    debug5(\"length of body fetched from unpkg.com\", bodyAsText.length);\n    let bodyAsJson;\n    try {\n      bodyAsJson = JSON.parse(bodyAsText);\n    } catch (e) {\n      console.error(\"JSON.parse error: body fetched from unpkg.com: \", bodyAsText);\n      throw e;\n    }\n    return bodyAsJson[\"version\"];\n  }\n  throw new NotImplementedYetError(\"Only `major.minor.patch` versions are supported by Prisma Data Proxy.\", {\n    clientVersion: clientVersion2\n  });\n}\n__name(_getClientVersion, \"_getClientVersion\");\nasync function getClientVersion(config2) {\n  const version = await _getClientVersion(config2);\n  debug5(\"version\", version);\n  return version;\n}\n__name(getClientVersion, \"getClientVersion\");\nfunction prismaPkgURL(version) {\n  return encodeURI(`https://unpkg.com/prisma@${version}/package.json`);\n}\n__name(prismaPkgURL, \"prismaPkgURL\");\n\n// ../engine-core/src/data-proxy/DataProxyEngine.ts\nvar MAX_RETRIES = 10;\nvar P2 = Promise.resolve();\nvar debug6 = src_default(\"prisma:client:dataproxyEngine\");\nvar DataProxyEngine = class extends Engine {\n  constructor(config2) {\n    var _a3, _b2, _c, _d;\n    super();\n    this.config = config2;\n    this.env = { ...this.config.env, ...process.env };\n    this.inlineSchema = (_a3 = config2.inlineSchema) != null ? _a3 : \"\";\n    this.inlineDatasources = (_b2 = config2.inlineDatasources) != null ? _b2 : {};\n    this.inlineSchemaHash = (_c = config2.inlineSchemaHash) != null ? _c : \"\";\n    this.clientVersion = (_d = config2.clientVersion) != null ? _d : \"unknown\";\n    this.logEmitter = new import_events2.default();\n    this.logEmitter.on(\"error\", () => {\n    });\n    const [host, apiKey] = this.extractHostAndApiKey();\n    this.remoteClientVersion = P2.then(() => getClientVersion(this.config));\n    this.headers = { Authorization: `Bearer ${apiKey}` };\n    this.host = host;\n    debug6(\"host\", this.host);\n  }\n  version() {\n    return \"unknown\";\n  }\n  async start() {\n  }\n  async stop() {\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      throw new NotImplementedYetError(\"beforeExit event is not yet supported\", {\n        clientVersion: this.clientVersion\n      });\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async url(s) {\n    return `https://${this.host}/${await this.remoteClientVersion}/${this.inlineSchemaHash}/${s}`;\n  }\n  async getConfig() {\n    return Promise.resolve({\n      datasources: [\n        {\n          activeProvider: this.config.activeProvider\n        }\n      ]\n    });\n  }\n  getDmmf() {\n    throw new NotImplementedYetError(\"getDmmf is not yet supported\", {\n      clientVersion: this.clientVersion\n    });\n  }\n  async uploadSchema() {\n    const response = await request(await this.url(\"schema\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: this.inlineSchema,\n      clientVersion: this.clientVersion\n    });\n    if (!response.ok) {\n      debug6(\"schema response status\", response.status);\n    }\n    const err = await responseToError(response, this.clientVersion);\n    if (err) {\n      this.logEmitter.emit(\"warn\", { message: `Error while uploading schema: ${err.message}` });\n      throw err;\n    } else {\n      this.logEmitter.emit(\"info\", {\n        message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`\n      });\n    }\n  }\n  request(query2, headers, attempt = 0) {\n    this.logEmitter.emit(\"query\", { query: query2 });\n    return this.requestInternal({ query: query2, variables: {} }, headers, attempt);\n  }\n  async requestBatch(queries, headers, isTransaction = false, attempt = 0) {\n    this.logEmitter.emit(\"query\", {\n      query: `Batch${isTransaction ? \" in transaction\" : \"\"} (${queries.length}):\n${queries.join(\"\\n\")}`\n    });\n    const body = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction: isTransaction\n    };\n    const { batchResult } = await this.requestInternal(body, headers, attempt);\n    return batchResult;\n  }\n  async requestInternal(body, headers, attempt) {\n    var _a3;\n    try {\n      this.logEmitter.emit(\"info\", {\n        message: `Calling ${await this.url(\"graphql\")} (n=${attempt})`\n      });\n      const response = await request(await this.url(\"graphql\"), {\n        method: \"POST\",\n        headers: { ...headers, ...this.headers },\n        body: JSON.stringify(body),\n        clientVersion: this.clientVersion\n      });\n      if (!response.ok) {\n        debug6(\"graphql response status\", response.status);\n      }\n      const e = await responseToError(response, this.clientVersion);\n      if (e instanceof SchemaMissingError) {\n        await this.uploadSchema();\n        throw new ForcedRetryError({\n          clientVersion: this.clientVersion,\n          cause: e\n        });\n      }\n      if (e)\n        throw e;\n      const data = await response.json();\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);\n        }\n      }\n      return data;\n    } catch (e) {\n      this.logEmitter.emit(\"error\", {\n        message: `Error while querying: ${(_a3 = e.message) != null ? _a3 : \"(unknown)\"}`\n      });\n      if (!(e instanceof DataProxyError))\n        throw e;\n      if (!e.isRetryable)\n        throw e;\n      if (attempt >= MAX_RETRIES) {\n        if (e instanceof ForcedRetryError) {\n          throw e.cause;\n        } else {\n          throw e;\n        }\n      }\n      this.logEmitter.emit(\"warn\", { message: \"This request can be retried\" });\n      const delay = await backOff(attempt);\n      this.logEmitter.emit(\"warn\", { message: `Retrying after ${delay}ms` });\n      return this.requestInternal(body, headers, attempt + 1);\n    }\n  }\n  transaction() {\n    throw new NotImplementedYetError(\"Interactive transactions are not yet supported\", {\n      clientVersion: this.clientVersion\n    });\n  }\n  extractHostAndApiKey() {\n    const datasources = this.mergeOverriddenDatasources();\n    const mainDatasourceName = Object.keys(datasources)[0];\n    const mainDatasource = datasources[mainDatasourceName];\n    const dataProxyURL = this.resolveDatasourceURL(mainDatasourceName, mainDatasource);\n    let url;\n    try {\n      url = new URL(dataProxyURL);\n    } catch (e) {\n      throw new InvalidDatasourceError(\"Could not parse URL of the datasource\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    const { protocol, host, searchParams } = url;\n    if (protocol !== \"prisma:\") {\n      throw new InvalidDatasourceError(\"Datasource URL must use prisma:// protocol when --data-proxy is used\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    const apiKey = searchParams.get(\"api_key\");\n    if (apiKey === null || apiKey.length < 1) {\n      throw new InvalidDatasourceError(\"No valid API key found in the datasource URL\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    return [host, apiKey];\n  }\n  mergeOverriddenDatasources() {\n    if (this.config.datasources === void 0) {\n      return this.inlineDatasources;\n    }\n    const finalDatasources = { ...this.inlineDatasources };\n    for (const override of this.config.datasources) {\n      if (!this.inlineDatasources[override.name]) {\n        throw new Error(`Unknown datasource: ${override.name}`);\n      }\n      finalDatasources[override.name] = {\n        url: {\n          fromEnvVar: null,\n          value: override.url\n        }\n      };\n    }\n    return finalDatasources;\n  }\n  resolveDatasourceURL(name, datasource) {\n    if (datasource.url.value) {\n      return datasource.url.value;\n    }\n    if (datasource.url.fromEnvVar) {\n      const envVar = datasource.url.fromEnvVar;\n      const loadedEnvURL = this.env[envVar];\n      if (loadedEnvURL === void 0) {\n        throw new InvalidDatasourceError(\n          `Datasource \"${name}\" references an environment variable \"${envVar}\" that is not set`,\n          {\n            clientVersion: this.clientVersion\n          }\n        );\n      }\n      return loadedEnvURL;\n    }\n    throw new InvalidDatasourceError(\n      `Datasource \"${name}\" specification is invalid: both value and fromEnvVar are null`,\n      {\n        clientVersion: this.clientVersion\n      }\n    );\n  }\n  metrics(options) {\n    throw new NotImplementedYetError(\"Metric are not yet supported for Data Proxy\", {\n      clientVersion: this.clientVersion\n    });\n  }\n};\n__name(DataProxyEngine, \"DataProxyEngine\");\n\n// ../engine-core/src/library/LibraryEngine.ts\nvar import_chalk5 = __toESM(require_source());\nvar import_events3 = __toESM(__webpack_require__(/*! events */ \"events\"));\nvar import_fs6 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\n\n// ../engine-core/src/library/DefaultLibraryLoader.ts\nvar import_chalk4 = __toESM(require_source());\nvar import_fs5 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path3 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar debug7 = src_default(\"prisma:client:libraryEngine:loader\");\nvar DefaultLibraryLoader = class {\n  constructor(config2) {\n    this.libQueryEnginePath = null;\n    this.platform = null;\n    this.config = config2;\n  }\n  async loadLibrary() {\n    if (!this.libQueryEnginePath) {\n      this.libQueryEnginePath = await this.getLibQueryEnginePath();\n    }\n    debug7(`loadEngine using ${this.libQueryEnginePath}`);\n    try {\n      return eval(\"require\")(this.libQueryEnginePath);\n    } catch (e) {\n      if (import_fs5.default.existsSync(this.libQueryEnginePath)) {\n        if (this.libQueryEnginePath.endsWith(\".node\")) {\n          throw new PrismaClientInitializationError(\n            `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, Library may be corrupt`,\n            this.config.clientVersion\n          );\n        } else {\n          throw new PrismaClientInitializationError(\n            `Expected an Node-API Library but received ${import_chalk4.default.dim(this.libQueryEnginePath)}`,\n            this.config.clientVersion\n          );\n        }\n      } else {\n        throw new PrismaClientInitializationError(\n          `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, It does not exist`,\n          this.config.clientVersion\n        );\n      }\n    }\n  }\n  async getLibQueryEnginePath() {\n    var _a3, _b2, _c, _d;\n    const libPath = (_a3 = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a3 : this.config.prismaPath;\n    if (libPath && import_fs5.default.existsSync(libPath) && libPath.endsWith(\".node\")) {\n      return libPath;\n    }\n    this.platform = (_b2 = this.platform) != null ? _b2 : await getPlatform();\n    const { enginePath: enginePath2, searchedLocations: searchedLocations2 } = await this.resolveEnginePath();\n    if (!import_fs5.default.existsSync(enginePath2)) {\n      const incorrectPinnedPlatformErrorStr = this.platform ? `\nYou incorrectly pinned it to ${import_chalk4.default.redBright.bold(`${this.platform}`)}\n` : \"\";\n      let errorText = `Query engine library for current platform \"${import_chalk4.default.bold(\n        this.platform\n      )}\" could not be found.${incorrectPinnedPlatformErrorStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${import_chalk4.default.underline(enginePath2)}\")\n\nSearched Locations:\n\n${searchedLocations2.map((f) => {\n        let msg = `  ${f}`;\n        if (process.env.DEBUG === \"node-engine-search-locations\" && import_fs5.default.existsSync(f)) {\n          const dir = import_fs5.default.readdirSync(f);\n          msg += dir.map((d) => `    ${d}`).join(\"\\n\");\n        }\n        return msg;\n      }).join(\"\\n\" + (process.env.DEBUG === \"node-engine-search-locations\" ? \"\\n\" : \"\"))}\n`;\n      if (this.config.generator) {\n        this.platform = (_c = this.platform) != null ? _c : await getPlatform();\n        if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === \"native\")) {\n          errorText += `\nYou already added the platform${this.config.generator.binaryTargets.length > 1 ? \"s\" : \"\"} ${this.config.generator.binaryTargets.map((t) => `\"${import_chalk4.default.bold(t.value)}\"`).join(\", \")} to the \"${import_chalk4.default.underline(\"generator\")}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`;\n          errorText += ``;\n        } else {\n          errorText += `\n\nTo solve this problem, add the platform \"${this.platform}\" to the \"${import_chalk4.default.underline(\n            \"binaryTargets\"\n          )}\" attribute in the \"${import_chalk4.default.underline(\"generator\")}\" block in the \"schema.prisma\" file:\n${import_chalk4.default.greenBright(this.getFixedGenerator())}\n\nThen run \"${import_chalk4.default.greenBright(\"prisma generate\")}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`;\n        }\n      } else {\n        errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;\n      }\n      throw new PrismaClientInitializationError(errorText, this.config.clientVersion);\n    }\n    this.platform = (_d = this.platform) != null ? _d : await getPlatform();\n    return enginePath2;\n  }\n  async resolveEnginePath() {\n    var _a3, _b2, _c, _d;\n    const searchedLocations = [];\n    let enginePath;\n    if (this.libQueryEnginePath) {\n      return { enginePath: this.libQueryEnginePath, searchedLocations };\n    }\n    this.platform = (_a3 = this.platform) != null ? _a3 : await getPlatform();\n    if (__filename.includes(\"DefaultLibraryLoader\")) {\n      enginePath = import_path3.default.join(getEnginesPath(), getNodeAPIName(this.platform, \"fs\"));\n      return { enginePath, searchedLocations };\n    }\n    const dirname = eval(\"__dirname\");\n    const searchLocations = [\n      import_path3.default.resolve(dirname, \"../../../.prisma/client\"),\n      (_d = (_c = (_b2 = this.config.generator) == null ? void 0 : _b2.output) == null ? void 0 : _c.value) != null ? _d : dirname,\n      import_path3.default.resolve(dirname, \"..\"),\n      import_path3.default.dirname(this.config.datamodelPath),\n      this.config.cwd,\n      \"/tmp/prisma-engines\"\n    ];\n    if (this.config.dirname) {\n      searchLocations.push(this.config.dirname);\n    }\n    for (const location of searchLocations) {\n      searchedLocations.push(location);\n      debug7(`Searching for Query Engine Library in ${location}`);\n      enginePath = import_path3.default.join(location, getNodeAPIName(this.platform, \"fs\"));\n      if (import_fs5.default.existsSync(enginePath)) {\n        return { enginePath, searchedLocations };\n      }\n    }\n    enginePath = import_path3.default.join(__dirname, getNodeAPIName(this.platform, \"fs\"));\n    return { enginePath: enginePath != null ? enginePath : \"\", searchedLocations };\n  }\n  getFixedGenerator() {\n    const fixedGenerator = {\n      ...this.config.generator,\n      binaryTargets: fixBinaryTargets(this.config.generator.binaryTargets, this.platform)\n    };\n    return printGeneratorConfig(fixedGenerator);\n  }\n};\n__name(DefaultLibraryLoader, \"DefaultLibraryLoader\");\n\n// ../engine-core/src/library/ExitHooks.ts\nvar debug8 = src_default(\"prisma:client:libraryEngine:exitHooks\");\nvar ExitHooks = class {\n  constructor() {\n    this.nextOwnerId = 1;\n    this.ownerToIdMap = /* @__PURE__ */ new WeakMap();\n    this.idToListenerMap = /* @__PURE__ */ new Map();\n    this.areHooksInstalled = false;\n  }\n  install() {\n    if (this.areHooksInstalled) {\n      return;\n    }\n    this.installHook(\"beforeExit\");\n    this.installHook(\"exit\");\n    this.installHook(\"SIGINT\", true);\n    this.installHook(\"SIGUSR2\", true);\n    this.installHook(\"SIGTERM\", true);\n    this.areHooksInstalled = true;\n  }\n  setListener(owner, listener) {\n    if (listener) {\n      let id = this.ownerToIdMap.get(owner);\n      if (!id) {\n        id = this.nextOwnerId++;\n        this.ownerToIdMap.set(owner, id);\n      }\n      this.idToListenerMap.set(id, listener);\n    } else {\n      const id = this.ownerToIdMap.get(owner);\n      if (id !== void 0) {\n        this.ownerToIdMap.delete(owner);\n        this.idToListenerMap.delete(id);\n      }\n    }\n  }\n  getListener(owner) {\n    const id = this.ownerToIdMap.get(owner);\n    if (id === void 0) {\n      return void 0;\n    }\n    return this.idToListenerMap.get(id);\n  }\n  installHook(event, shouldExit = false) {\n    process.once(event, async (code) => {\n      debug8(`exit event received: ${event}`);\n      for (const listener of this.idToListenerMap.values()) {\n        await listener();\n      }\n      this.idToListenerMap.clear();\n      if (shouldExit && process.listenerCount(event) === 0) {\n        process.exit(code);\n      }\n    });\n  }\n};\n__name(ExitHooks, \"ExitHooks\");\n\n// ../engine-core/src/library/LibraryEngine.ts\nvar debug9 = src_default(\"prisma:client:libraryEngine\");\nfunction isQueryEvent(event) {\n  return event[\"item_type\"] === \"query\" && \"query\" in event;\n}\n__name(isQueryEvent, \"isQueryEvent\");\nfunction isPanicEvent(event) {\n  if (\"level\" in event) {\n    return event.level === \"error\" && event[\"message\"] === \"PANIC\";\n  } else {\n    return false;\n  }\n}\n__name(isPanicEvent, \"isPanicEvent\");\nvar knownPlatforms2 = [...platforms, \"native\"];\nvar engineInstanceCount = 0;\nvar exitHooks = new ExitHooks();\nvar LibraryEngine = class extends Engine {\n  constructor(config2, loader = new DefaultLibraryLoader(config2)) {\n    var _a3, _b2;\n    super();\n    this.datamodel = import_fs6.default.readFileSync(config2.datamodelPath, \"utf-8\");\n    this.config = config2;\n    this.libraryStarted = false;\n    this.logQueries = (_a3 = config2.logQueries) != null ? _a3 : false;\n    this.logLevel = (_b2 = config2.logLevel) != null ? _b2 : \"error\";\n    this.libraryLoader = loader;\n    this.logEmitter = new import_events3.default();\n    this.logEmitter.on(\"error\", (e) => {\n    });\n    this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};\n    if (config2.enableDebugLogs) {\n      this.logLevel = \"debug\";\n    }\n    this.libraryInstantiationPromise = this.instantiateLibrary();\n    exitHooks.install();\n    this.checkForTooManyEngines();\n  }\n  get beforeExitListener() {\n    return exitHooks.getListener(this);\n  }\n  set beforeExitListener(listener) {\n    exitHooks.setListener(this, listener);\n  }\n  checkForTooManyEngines() {\n    if (engineInstanceCount === 10) {\n      console.warn(\n        `${import_chalk5.default.yellow(\"warn(prisma-client)\")} There are already 10 instances of Prisma Client actively running.`\n      );\n    }\n  }\n  async transaction(action, headers, arg2) {\n    var _a3, _b2, _c, _d, _e;\n    await this.start();\n    const headerStr = JSON.stringify(headers);\n    let result;\n    if (action === \"start\") {\n      const jsonOptions = JSON.stringify({\n        max_wait: (_a3 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a3 : 2e3,\n        timeout: (_b2 = arg2 == null ? void 0 : arg2.timeout) != null ? _b2 : 5e3,\n        isolation_level: arg2 == null ? void 0 : arg2.isolationLevel\n      });\n      result = await ((_c = this.engine) == null ? void 0 : _c.startTransaction(jsonOptions, headerStr));\n    } else if (action === \"commit\") {\n      result = await ((_d = this.engine) == null ? void 0 : _d.commitTransaction(arg2.id, headerStr));\n    } else if (action === \"rollback\") {\n      result = await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg2.id, headerStr));\n    }\n    const response = this.parseEngineResponse(result);\n    if (response.error_code)\n      throw response;\n    return response;\n  }\n  async instantiateLibrary() {\n    debug9(\"internalSetup\");\n    if (this.libraryInstantiationPromise) {\n      return this.libraryInstantiationPromise;\n    }\n    await isNodeAPISupported();\n    this.platform = await this.getPlatform();\n    await this.loadEngine();\n    this.version();\n  }\n  async getPlatform() {\n    if (this.platform)\n      return this.platform;\n    const platform3 = await getPlatform();\n    if (!knownPlatforms2.includes(platform3)) {\n      throw new PrismaClientInitializationError(\n        `Unknown ${import_chalk5.default.red(\"PRISMA_QUERY_ENGINE_LIBRARY\")} ${import_chalk5.default.redBright.bold(\n          platform3\n        )}. Possible binaryTargets: ${import_chalk5.default.greenBright(\n          knownPlatforms2.join(\", \")\n        )} or a path to the query engine library.\nYou may have to run ${import_chalk5.default.greenBright(\"prisma generate\")} for your changes to take effect.`,\n        this.config.clientVersion\n      );\n    }\n    return platform3;\n  }\n  parseEngineResponse(response) {\n    if (!response) {\n      throw new PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);\n    }\n    try {\n      const config2 = JSON.parse(response);\n      return config2;\n    } catch (err) {\n      throw new PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);\n    }\n  }\n  convertDatasources(datasources) {\n    const obj = /* @__PURE__ */ Object.create(null);\n    for (const { name, url } of datasources) {\n      obj[name] = url;\n    }\n    return obj;\n  }\n  async loadEngine() {\n    var _a3;\n    if (!this.engine) {\n      if (!this.QueryEngineConstructor) {\n        this.library = await this.libraryLoader.loadLibrary();\n        this.QueryEngineConstructor = this.library.QueryEngine;\n      }\n      try {\n        const weakThis = new WeakRef(this);\n        this.engine = new this.QueryEngineConstructor(\n          {\n            datamodel: this.datamodel,\n            env: process.env,\n            logQueries: (_a3 = this.config.logQueries) != null ? _a3 : false,\n            ignoreEnvVarErrors: false,\n            datasourceOverrides: this.datasourceOverrides,\n            logLevel: this.logLevel,\n            configDir: this.config.cwd\n          },\n          (log4) => {\n            var _a4;\n            (_a4 = weakThis.deref()) == null ? void 0 : _a4.logger(log4);\n          }\n        );\n        engineInstanceCount++;\n      } catch (_e) {\n        const e = _e;\n        const error2 = this.parseInitError(e.message);\n        if (typeof error2 === \"string\") {\n          throw e;\n        } else {\n          throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);\n        }\n      }\n    }\n  }\n  logger(log4) {\n    var _a3;\n    const event = this.parseEngineResponse(log4);\n    if (!event)\n      return;\n    if (\"span\" in event) {\n      if (this.config.tracingConfig.enabled === true) {\n        void createSpan(event);\n      }\n      return;\n    }\n    event.level = (_a3 = event == null ? void 0 : event.level.toLowerCase()) != null ? _a3 : \"unknown\";\n    if (isQueryEvent(event)) {\n      this.logEmitter.emit(\"query\", {\n        timestamp: new Date(),\n        query: event.query,\n        params: event.params,\n        duration: Number(event.duration_ms),\n        target: event.module_path\n      });\n    } else if (isPanicEvent(event)) {\n      this.loggerRustPanic = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(\n          `${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`\n        ),\n        this.config.clientVersion\n      );\n      this.logEmitter.emit(\"error\", this.loggerRustPanic);\n    } else {\n      this.logEmitter.emit(event.level, {\n        timestamp: new Date(),\n        message: event.message,\n        target: event.module_path\n      });\n    }\n  }\n  getErrorMessageWithLink(title) {\n    var _a3;\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.config.clientVersion,\n      engineVersion: (_a3 = this.versionInfo) == null ? void 0 : _a3.commit,\n      database: this.config.activeProvider,\n      query: this.lastQuery\n    });\n  }\n  parseInitError(str) {\n    try {\n      const error2 = JSON.parse(str);\n      return error2;\n    } catch (e) {\n    }\n    return str;\n  }\n  parseRequestError(str) {\n    try {\n      const error2 = JSON.parse(str);\n      return error2;\n    } catch (e) {\n    }\n    return str;\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      this.beforeExitListener = listener;\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async start() {\n    await this.libraryInstantiationPromise;\n    await this.libraryStoppingPromise;\n    if (this.libraryStartingPromise) {\n      debug9(`library already starting, this.libraryStarted: ${this.libraryStarted}`);\n      return this.libraryStartingPromise;\n    }\n    if (this.libraryStarted) {\n      return;\n    }\n    const startFn = /* @__PURE__ */ __name(async () => {\n      var _a3;\n      debug9(\"library starting\");\n      try {\n        const headers = {\n          traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })\n        };\n        await ((_a3 = this.engine) == null ? void 0 : _a3.connect(JSON.stringify(headers)));\n        this.libraryStarted = true;\n        debug9(\"library started\");\n      } catch (err) {\n        const error2 = this.parseInitError(err.message);\n        if (typeof error2 === \"string\") {\n          throw err;\n        } else {\n          throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);\n        }\n      } finally {\n        this.libraryStartingPromise = void 0;\n      }\n    }, \"startFn\");\n    const spanConfig = {\n      name: \"connect\",\n      enabled: this.config.tracingConfig.enabled\n    };\n    this.libraryStartingPromise = runInChildSpan(spanConfig, startFn);\n    return this.libraryStartingPromise;\n  }\n  async stop() {\n    await this.libraryStartingPromise;\n    await this.executingQueryPromise;\n    if (this.libraryStoppingPromise) {\n      debug9(\"library is already stopping\");\n      return this.libraryStoppingPromise;\n    }\n    if (!this.libraryStarted) {\n      return;\n    }\n    const stopFn = /* @__PURE__ */ __name(async () => {\n      var _a3;\n      await new Promise((r) => setTimeout(r, 5));\n      debug9(\"library stopping\");\n      const headers = {\n        traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })\n      };\n      await ((_a3 = this.engine) == null ? void 0 : _a3.disconnect(JSON.stringify(headers)));\n      this.libraryStarted = false;\n      this.libraryStoppingPromise = void 0;\n      debug9(\"library stopped\");\n    }, \"stopFn\");\n    const spanConfig = {\n      name: \"disconnect\",\n      enabled: this.config.tracingConfig.enabled\n    };\n    this.libraryStoppingPromise = runInChildSpan(spanConfig, stopFn);\n    return this.libraryStoppingPromise;\n  }\n  async getConfig() {\n    await this.libraryInstantiationPromise;\n    return this.library.getConfig({\n      datamodel: this.datamodel,\n      datasourceOverrides: this.datasourceOverrides,\n      ignoreEnvVarErrors: true,\n      env: process.env\n    });\n  }\n  async getDmmf() {\n    await this.libraryInstantiationPromise;\n    return JSON.parse(await this.library.dmmf(this.datamodel));\n  }\n  version() {\n    var _a3, _b2, _c;\n    this.versionInfo = (_a3 = this.library) == null ? void 0 : _a3.version();\n    return (_c = (_b2 = this.versionInfo) == null ? void 0 : _b2.version) != null ? _c : \"unknown\";\n  }\n  debugPanic(message) {\n    var _a3;\n    return (_a3 = this.library) == null ? void 0 : _a3.debugPanic(message);\n  }\n  async request(query2, headers = {}, numTry = 1) {\n    var _a3, _b2;\n    debug9(`sending request, this.libraryStarted: ${this.libraryStarted}`);\n    const request2 = { query: query2, variables: {} };\n    const headerStr = JSON.stringify(headers);\n    const queryStr = JSON.stringify(request2);\n    try {\n      await this.start();\n      this.executingQueryPromise = (_a3 = this.engine) == null ? void 0 : _a3.query(queryStr, headerStr, headers.transactionId);\n      this.lastQuery = queryStr;\n      const data = this.parseEngineResponse(await this.executingQueryPromise);\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw this.buildQueryError(data.errors[0]);\n        }\n        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);\n      } else if (this.loggerRustPanic) {\n        throw this.loggerRustPanic;\n      }\n      return { data, elapsed: 0 };\n    } catch (e) {\n      if (e instanceof PrismaClientInitializationError) {\n        throw e;\n      }\n      if (e.code === \"GenericFailure\" && ((_b2 = e.message) == null ? void 0 : _b2.startsWith(\"PANIC:\"))) {\n        throw new PrismaClientRustPanicError(this.getErrorMessageWithLink(e.message), this.config.clientVersion);\n      }\n      const error2 = this.parseRequestError(e.message);\n      if (typeof error2 === \"string\") {\n        throw e;\n      } else {\n        throw new PrismaClientUnknownRequestError(`${error2.message}\n${error2.backtrace}`, this.config.clientVersion);\n      }\n    }\n  }\n  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {\n    debug9(\"requestBatch\");\n    const request2 = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction\n    };\n    await this.start();\n    this.lastQuery = JSON.stringify(request2);\n    this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);\n    const result = await this.executingQueryPromise;\n    const data = this.parseEngineResponse(result);\n    if (data.errors) {\n      if (data.errors.length === 1) {\n        throw this.buildQueryError(data.errors[0]);\n      }\n      throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);\n    }\n    const { batchResult, errors } = data;\n    if (Array.isArray(batchResult)) {\n      return batchResult.map((result2) => {\n        var _a3;\n        if (result2.errors) {\n          return (_a3 = this.loggerRustPanic) != null ? _a3 : this.buildQueryError(data.errors[0]);\n        }\n        return {\n          data: result2,\n          elapsed: 0\n        };\n      });\n    } else {\n      if (errors && errors.length === 1) {\n        throw new Error(errors[0].error);\n      }\n      throw new Error(JSON.stringify(data));\n    }\n  }\n  buildQueryError(error2) {\n    if (error2.user_facing_error.is_panic) {\n      return new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(error2.user_facing_error.message),\n        this.config.clientVersion\n      );\n    }\n    return prismaGraphQLToJSError(error2, this.config.clientVersion);\n  }\n  async metrics(options) {\n    await this.start();\n    const responseString = await this.engine.metrics(JSON.stringify(options));\n    if (options.format === \"prometheus\") {\n      return responseString;\n    }\n    return this.parseEngineResponse(responseString);\n  }\n};\n__name(LibraryEngine, \"LibraryEngine\");\n\n// ../internals/src/utils/tryLoadEnvs.ts\nvar import_chalk6 = __toESM(require_source());\nvar import_dotenv = __toESM(require_main2());\nvar import_fs7 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path4 = __toESM(__webpack_require__(/*! path */ \"path\"));\n\n// ../internals/src/dotenvExpand.ts\nfunction dotenvExpand(config2) {\n  const environment = config2.ignoreProcessEnv ? {} : process.env;\n  const interpolate = /* @__PURE__ */ __name((envValue) => {\n    const matches = envValue.match(/(.?\\${(?:[a-zA-Z0-9_]+)?})/g) || [];\n    return matches.reduce(function(newEnv, match) {\n      const parts = /(.?)\\${([a-zA-Z0-9_]+)?}/g.exec(match);\n      if (!parts) {\n        return newEnv;\n      }\n      const prefix = parts[1];\n      let value, replacePart;\n      if (prefix === \"\\\\\") {\n        replacePart = parts[0];\n        value = replacePart.replace(\"\\\\$\", \"$\");\n      } else {\n        const key = parts[2];\n        replacePart = parts[0].substring(prefix.length);\n        value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || \"\";\n        value = interpolate(value);\n      }\n      return newEnv.replace(replacePart, value);\n    }, envValue);\n  }, \"interpolate\");\n  for (const configKey in config2.parsed) {\n    const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];\n    config2.parsed[configKey] = interpolate(value);\n  }\n  for (const processKey in config2.parsed) {\n    environment[processKey] = config2.parsed[processKey];\n  }\n  return config2;\n}\n__name(dotenvExpand, \"dotenvExpand\");\n\n// ../internals/src/utils/tryLoadEnvs.ts\nvar debug10 = src_default(\"prisma:tryLoadEnv\");\nfunction tryLoadEnvs({\n  rootEnvPath,\n  schemaEnvPath\n}, opts = {\n  conflictCheck: \"none\"\n}) {\n  var _a3, _b2;\n  const rootEnvInfo = loadEnv(rootEnvPath);\n  if (opts.conflictCheck !== \"none\") {\n    checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);\n  }\n  let schemaEnvInfo = null;\n  if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {\n    schemaEnvInfo = loadEnv(schemaEnvPath);\n  }\n  if (!rootEnvInfo && !schemaEnvInfo) {\n    debug10(\"No Environment variables loaded\");\n  }\n  if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {\n    return console.error(import_chalk6.default.redBright.bold(\"Schema Env Error: \") + schemaEnvInfo.dotenvResult.error);\n  }\n  const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);\n  return {\n    message: messages.join(\"\\n\"),\n    parsed: {\n      ...(_a3 = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a3.parsed,\n      ...(_b2 = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b2.parsed\n    }\n  };\n}\n__name(tryLoadEnvs, \"tryLoadEnvs\");\nfunction checkForConflicts(rootEnvInfo, envPath, type) {\n  const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;\n  const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);\n  if (parsedRootEnv && envPath && areNotTheSame && import_fs7.default.existsSync(envPath)) {\n    const envConfig = import_dotenv.default.parse(import_fs7.default.readFileSync(envPath));\n    const conflicts = [];\n    for (const k in envConfig) {\n      if (parsedRootEnv[k] === envConfig[k]) {\n        conflicts.push(k);\n      }\n    }\n    if (conflicts.length > 0) {\n      const relativeRootEnvPath = import_path4.default.relative(process.cwd(), rootEnvInfo.path);\n      const relativeEnvPath = import_path4.default.relative(process.cwd(), envPath);\n      if (type === \"error\") {\n        const message = `There is a conflict between env var${conflicts.length > 1 ? \"s\" : \"\"} in ${import_chalk6.default.underline(\n          relativeRootEnvPath\n        )} and ${import_chalk6.default.underline(relativeEnvPath)}\nConflicting env vars:\n${conflicts.map((conflict) => `  ${import_chalk6.default.bold(conflict)}`).join(\"\\n\")}\n\nWe suggest to move the contents of ${import_chalk6.default.underline(relativeEnvPath)} to ${import_chalk6.default.underline(\n          relativeRootEnvPath\n        )} to consolidate your env vars.\n`;\n        throw new Error(message);\n      } else if (type === \"warn\") {\n        const message = `Conflict for env var${conflicts.length > 1 ? \"s\" : \"\"} ${conflicts.map((c) => import_chalk6.default.bold(c)).join(\", \")} in ${import_chalk6.default.underline(relativeRootEnvPath)} and ${import_chalk6.default.underline(relativeEnvPath)}\nEnv vars from ${import_chalk6.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk6.default.underline(relativeRootEnvPath)}\n      `;\n        console.warn(`${import_chalk6.default.yellow(\"warn(prisma)\")} ${message}`);\n      }\n    }\n  }\n}\n__name(checkForConflicts, \"checkForConflicts\");\nfunction loadEnv(envPath) {\n  if (exists3(envPath)) {\n    debug10(`Environment variables loaded from ${envPath}`);\n    return {\n      dotenvResult: dotenvExpand(\n        import_dotenv.default.config({\n          path: envPath,\n          debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0\n        })\n      ),\n      message: import_chalk6.default.dim(`Environment variables loaded from ${import_path4.default.relative(process.cwd(), envPath)}`),\n      path: envPath\n    };\n  } else {\n    debug10(`Environment variables not found at ${envPath}`);\n  }\n  return null;\n}\n__name(loadEnv, \"loadEnv\");\nfunction pathsEqual(path1, path22) {\n  return path1 && path22 && import_path4.default.resolve(path1) === import_path4.default.resolve(path22);\n}\n__name(pathsEqual, \"pathsEqual\");\nfunction exists3(p) {\n  return Boolean(p && import_fs7.default.existsSync(p));\n}\n__name(exists3, \"exists\");\n\n// ../internals/src/client/getClientEngineType.ts\nvar DEFAULT_CLIENT_ENGINE_TYPE = \"library\" /* Library */;\nfunction getClientEngineType(generatorConfig) {\n  const engineTypeFromEnvVar = getEngineTypeFromEnvVar();\n  if (engineTypeFromEnvVar)\n    return engineTypeFromEnvVar;\n  if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === \"library\" /* Library */) {\n    return \"library\" /* Library */;\n  } else if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === \"binary\" /* Binary */) {\n    return \"binary\" /* Binary */;\n  } else {\n    return DEFAULT_CLIENT_ENGINE_TYPE;\n  }\n}\n__name(getClientEngineType, \"getClientEngineType\");\nfunction getEngineTypeFromEnvVar() {\n  const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;\n  if (engineType === \"library\" /* Library */) {\n    return \"library\" /* Library */;\n  } else if (engineType === \"binary\" /* Binary */) {\n    return \"binary\" /* Binary */;\n  } else {\n    return void 0;\n  }\n}\n__name(getEngineTypeFromEnvVar, \"getEngineTypeFromEnvVar\");\n\n// ../internals/src/cli/utils.ts\nvar import_arg = __toESM(require_arg());\nvar import_strip_indent = __toESM(require_strip_indent());\nfunction isError(result) {\n  return result instanceof Error;\n}\n__name(isError, \"isError\");\n\n// ../internals/src/logger.ts\nvar logger_exports = {};\n__export(logger_exports, {\n  error: () => error,\n  info: () => info,\n  log: () => log3,\n  query: () => query,\n  should: () => should,\n  tags: () => tags,\n  warn: () => warn\n});\nvar import_chalk7 = __toESM(require_source());\nvar tags = {\n  error: import_chalk7.default.red(\"prisma:error\"),\n  warn: import_chalk7.default.yellow(\"prisma:warn\"),\n  info: import_chalk7.default.cyan(\"prisma:info\"),\n  query: import_chalk7.default.blue(\"prisma:query\")\n};\nvar should = {\n  warn: !process.env.PRISMA_DISABLE_WARNINGS\n};\nfunction log3(...data) {\n  console.log(...data);\n}\n__name(log3, \"log\");\nfunction warn(message, ...optionalParams) {\n  if (should.warn) {\n    console.warn(`${tags.warn} ${message}`, ...optionalParams);\n  }\n}\n__name(warn, \"warn\");\nfunction info(message, ...optionalParams) {\n  console.info(`${tags.info} ${message}`, ...optionalParams);\n}\n__name(info, \"info\");\nfunction error(message, ...optionalParams) {\n  console.error(`${tags.error} ${message}`, ...optionalParams);\n}\n__name(error, \"error\");\nfunction query(message, ...optionalParams) {\n  console.log(`${tags.query} ${message}`, ...optionalParams);\n}\n__name(query, \"query\");\n\n// ../internals/src/utils/assertNever.ts\nfunction assertNever(arg2, errorMessage) {\n  throw new Error(errorMessage);\n}\n__name(assertNever, \"assertNever\");\n\n// ../internals/src/utils/callOnce.ts\nfunction callOnce(fn) {\n  let result;\n  return (...args) => result != null ? result : result = fn(...args);\n}\n__name(callOnce, \"callOnce\");\n\n// ../internals/src/utils/keyBy.ts\nvar keyBy2 = /* @__PURE__ */ __name((collection, iteratee) => {\n  return collection.reduce((acc, curr) => {\n    acc[iteratee(curr)] = curr;\n    return acc;\n  }, {});\n}, \"keyBy\");\n\n// ../internals/src/warnOnce.ts\nvar alreadyWarned = /* @__PURE__ */ new Set();\nvar warnOnce = /* @__PURE__ */ __name((key, message, ...args) => {\n  if (!alreadyWarned.has(key)) {\n    alreadyWarned.add(key);\n    warn(message, ...args);\n  }\n}, \"warnOnce\");\n\n// src/runtime/getPrismaClient.ts\nvar import_async_hooks = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nvar import_fs9 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path5 = __toESM(__webpack_require__(/*! path */ \"path\"));\n\n// ../../node_modules/.pnpm/sql-template-tag@5.0.3/node_modules/sql-template-tag/dist/index.js\nvar Sql = class {\n  constructor(rawStrings, rawValues) {\n    if (rawStrings.length - 1 !== rawValues.length) {\n      if (rawStrings.length === 0) {\n        throw new TypeError(\"Expected at least 1 string\");\n      }\n      throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);\n    }\n    const valuesLength = rawValues.reduce((len, value) => len + (value instanceof Sql ? value.values.length : 1), 0);\n    this.values = new Array(valuesLength);\n    this.strings = new Array(valuesLength + 1);\n    this.strings[0] = rawStrings[0];\n    let i = 0, pos = 0;\n    while (i < rawValues.length) {\n      const child = rawValues[i++];\n      const rawString = rawStrings[i];\n      if (child instanceof Sql) {\n        this.strings[pos] += child.strings[0];\n        let childIndex = 0;\n        while (childIndex < child.values.length) {\n          this.values[pos++] = child.values[childIndex++];\n          this.strings[pos] = child.strings[childIndex];\n        }\n        this.strings[pos] += rawString;\n      } else {\n        this.values[pos++] = child;\n        this.strings[pos] = rawString;\n      }\n    }\n  }\n  get text() {\n    let i = 1, value = this.strings[0];\n    while (i < this.strings.length)\n      value += `$${i}${this.strings[i++]}`;\n    return value;\n  }\n  get sql() {\n    let i = 1, value = this.strings[0];\n    while (i < this.strings.length)\n      value += `?${this.strings[i++]}`;\n    return value;\n  }\n  inspect() {\n    return {\n      text: this.text,\n      sql: this.sql,\n      values: this.values\n    };\n  }\n};\n__name(Sql, \"Sql\");\nfunction join(values, separator = \",\", prefix = \"\", suffix = \"\") {\n  if (values.length === 0) {\n    throw new TypeError(\"Expected `join([])` to be called with an array of multiple elements, but got an empty array\");\n  }\n  return new Sql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);\n}\n__name(join, \"join\");\nfunction raw(value) {\n  return new Sql([value], []);\n}\n__name(raw, \"raw\");\nvar empty = raw(\"\");\nfunction sql(strings, ...values) {\n  return new Sql(strings, values);\n}\n__name(sql, \"sql\");\n\n// src/runtime/externalToInternalDmmf.ts\nvar import_pluralize = __toESM(require_pluralize());\nfunction externalToInternalDmmf(document2) {\n  return {\n    ...document2,\n    mappings: getMappings(document2.mappings, document2.datamodel)\n  };\n}\n__name(externalToInternalDmmf, \"externalToInternalDmmf\");\nfunction getMappings(mappings, datamodel) {\n  const modelOperations = mappings.modelOperations.filter((mapping) => {\n    const model = datamodel.models.find((m) => m.name === mapping.model);\n    if (!model) {\n      throw new Error(`Mapping without model ${mapping.model}`);\n    }\n    return model.fields.some((f) => f.kind !== \"object\");\n  }).map((mapping) => ({\n    model: mapping.model,\n    plural: (0, import_pluralize.default)(lowerCase(mapping.model)),\n    findUnique: mapping.findUnique || mapping.findSingle,\n    findFirst: mapping.findFirst,\n    findMany: mapping.findMany,\n    create: mapping.createOne || mapping.createSingle || mapping.create,\n    createMany: mapping.createMany,\n    delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,\n    update: mapping.updateOne || mapping.updateSingle || mapping.update,\n    deleteMany: mapping.deleteMany,\n    updateMany: mapping.updateMany,\n    upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,\n    aggregate: mapping.aggregate,\n    groupBy: mapping.groupBy,\n    findRaw: mapping.findRaw,\n    aggregateRaw: mapping.aggregateRaw\n  }));\n  return {\n    modelOperations,\n    otherOperations: mappings.otherOperations\n  };\n}\n__name(getMappings, \"getMappings\");\n\n// src/generation/getDMMF.ts\nfunction getPrismaClientDMMF(dmmf) {\n  return externalToInternalDmmf(dmmf);\n}\n__name(getPrismaClientDMMF, \"getPrismaClientDMMF\");\n\n// src/runtime/clientActions.ts\nvar clientOnlyActions = {\n  findUniqueOrThrow: {\n    wrappedAction: DMMF.ModelAction.findUnique\n  },\n  findFirstOrThrow: {\n    wrappedAction: DMMF.ModelAction.findFirst\n  }\n};\nfunction getDmmfActionName(name) {\n  if (isClientOnlyAction(name)) {\n    return clientOnlyActions[name].wrappedAction;\n  }\n  return name;\n}\n__name(getDmmfActionName, \"getDmmfActionName\");\nfunction isClientOnlyAction(action) {\n  return Object.prototype.hasOwnProperty.call(clientOnlyActions, action);\n}\n__name(isClientOnlyAction, \"isClientOnlyAction\");\nvar allClientModelActions = Object.keys(DMMF.ModelAction).concat(\n  Object.keys(clientOnlyActions)\n);\n\n// ../../node_modules/.pnpm/stacktrace-parser@0.1.10/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js\nvar UNKNOWN_FUNCTION = \"<unknown>\";\nfunction parse(stackString) {\n  var lines = stackString.split(\"\\n\");\n  return lines.reduce(function(stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n    return stack;\n  }, []);\n}\n__name(parse, \"parse\");\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  var isNative = parts[2] && parts[2].indexOf(\"native\") === 0;\n  var isEval = parts[2] && parts[2].indexOf(\"eval\") === 0;\n  var submatch = chromeEvalRe.exec(parts[2]);\n  if (isEval && submatch != null) {\n    parts[2] = submatch[1];\n    parts[3] = submatch[2];\n    parts[4] = submatch[3];\n  }\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseChrome, \"parseChrome\");\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseWinjs, \"parseWinjs\");\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  var isEval = parts[3] && parts[3].indexOf(\" > eval\") > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n  if (isEval && submatch != null) {\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null;\n  }\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(\",\") : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n__name(parseGecko, \"parseGecko\");\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n__name(parseJSC, \"parseJSC\");\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseNode, \"parseNode\");\n\n// src/runtime/utils/CallSite.ts\nvar DisabledCallSite = class {\n  getLocation() {\n    return null;\n  }\n};\n__name(DisabledCallSite, \"DisabledCallSite\");\nvar EnabledCallSite = class {\n  constructor() {\n    this._error = new Error();\n  }\n  getLocation() {\n    const stack = this._error.stack;\n    if (!stack) {\n      return null;\n    }\n    const stackFrames = parse(stack);\n    const frame = stackFrames.find((t) => {\n      return t.file && t.file !== \"<anonymous>\" && !t.file.includes(\"@prisma\") && !t.file.includes(\"getPrismaClient\") && !t.file.startsWith(\"internal/\") && !t.methodName.includes(\"new \") && !t.methodName.includes(\"getCallSite\") && !t.methodName.includes(\"Proxy.\") && t.methodName.split(\".\").length < 4;\n    });\n    if (!frame || !frame.file) {\n      return null;\n    }\n    return {\n      fileName: frame.file,\n      lineNumber: frame.lineNumber,\n      columnNumber: frame.column\n    };\n  }\n};\n__name(EnabledCallSite, \"EnabledCallSite\");\nfunction getCallSite(errorFormat) {\n  if (errorFormat === \"minimal\") {\n    return new DisabledCallSite();\n  }\n  return new EnabledCallSite();\n}\n__name(getCallSite, \"getCallSite\");\n\n// src/runtime/core/request/createPrismaPromise.ts\nfunction createPrismaPromise(callback) {\n  let promise;\n  const _callback = /* @__PURE__ */ __name((txId, lock) => {\n    try {\n      return promise != null ? promise : promise = callback(txId, lock);\n    } catch (error2) {\n      return Promise.reject(error2);\n    }\n  }, \"_callback\");\n  return {\n    then(onFulfilled, onRejected, txId) {\n      return _callback(txId, void 0).then(onFulfilled, onRejected, txId);\n    },\n    catch(onRejected, txId) {\n      return _callback(txId, void 0).catch(onRejected, txId);\n    },\n    finally(onFinally, txId) {\n      return _callback(txId, void 0).finally(onFinally, txId);\n    },\n    requestTransaction(txId, lock) {\n      const promise2 = _callback(txId, lock);\n      if (promise2.requestTransaction) {\n        return promise2.requestTransaction(txId, lock);\n      }\n      return promise2;\n    },\n    [Symbol.toStringTag]: \"PrismaPromise\"\n  };\n}\n__name(createPrismaPromise, \"createPrismaPromise\");\n\n// src/runtime/core/model/aggregates/utils/aggregateMap.ts\nvar aggregateMap = {\n  _avg: true,\n  _count: true,\n  _sum: true,\n  _min: true,\n  _max: true\n};\n\n// src/runtime/core/model/aggregates/aggregate.ts\nfunction desugarUserArgs(userArgs) {\n  const _userArgs = desugarCountInUserArgs(userArgs);\n  const userArgsEntries = Object.entries(_userArgs);\n  return userArgsEntries.reduce(\n    (aggregateArgs, [key, value]) => {\n      if (aggregateMap[key] !== void 0) {\n        aggregateArgs[\"select\"][key] = { select: value };\n      } else {\n        aggregateArgs[key] = value;\n      }\n      return aggregateArgs;\n    },\n    { select: {} }\n  );\n}\n__name(desugarUserArgs, \"desugarUserArgs\");\nfunction desugarCountInUserArgs(userArgs) {\n  if (typeof userArgs[\"_count\"] === \"boolean\") {\n    return { ...userArgs, _count: { _all: userArgs[\"_count\"] } };\n  }\n  return userArgs;\n}\n__name(desugarCountInUserArgs, \"desugarCountInUserArgs\");\nfunction createUnpacker(userArgs) {\n  return (data) => {\n    if (typeof userArgs[\"_count\"] === \"boolean\") {\n      data[\"_count\"] = data[\"_count\"][\"_all\"];\n    }\n    return data;\n  };\n}\n__name(createUnpacker, \"createUnpacker\");\nfunction aggregate(client, userArgs, modelAction) {\n  const aggregateArgs = desugarUserArgs(userArgs != null ? userArgs : {});\n  const aggregateUnpacker = createUnpacker(userArgs != null ? userArgs : {});\n  return modelAction({\n    action: \"aggregate\",\n    unpacker: aggregateUnpacker\n  })(aggregateArgs);\n}\n__name(aggregate, \"aggregate\");\n\n// src/runtime/core/model/aggregates/count.ts\nfunction count(client, userArgs, modelAction) {\n  const { select, ..._userArgs } = userArgs != null ? userArgs : {};\n  if (typeof select === \"object\") {\n    return aggregate(\n      client,\n      { ..._userArgs, _count: select },\n      (p) => modelAction({ ...p, action: \"count\", unpacker: (data) => {\n        var _a3;\n        return (_a3 = p.unpacker) == null ? void 0 : _a3.call(p, data)[\"_count\"];\n      } })\n    );\n  } else {\n    return aggregate(\n      client,\n      { ..._userArgs, _count: { _all: true } },\n      (p) => modelAction({ ...p, action: \"count\", unpacker: (data) => {\n        var _a3;\n        return (_a3 = p.unpacker) == null ? void 0 : _a3.call(p, data)[\"_count\"][\"_all\"];\n      } })\n    );\n  }\n}\n__name(count, \"count\");\n\n// src/runtime/core/model/aggregates/groupBy.ts\nfunction desugarUserArgs2(userArgs) {\n  const _userArgs = desugarUserArgs(userArgs);\n  if (Array.isArray(userArgs[\"by\"])) {\n    for (const key of userArgs[\"by\"]) {\n      if (typeof key === \"string\") {\n        _userArgs[\"select\"][key] = true;\n      }\n    }\n  }\n  return _userArgs;\n}\n__name(desugarUserArgs2, \"desugarUserArgs\");\nfunction createUnpacker2(userArgs) {\n  return (data) => {\n    if (typeof userArgs[\"_count\"] === \"boolean\") {\n      data.forEach((row) => {\n        row[\"_count\"] = row[\"_count\"][\"_all\"];\n      });\n    }\n    return data;\n  };\n}\n__name(createUnpacker2, \"createUnpacker\");\nfunction groupBy(client, userArgs, modelAction) {\n  const groupByArgs = desugarUserArgs2(userArgs != null ? userArgs : {});\n  const groupByUnpacker = createUnpacker2(userArgs != null ? userArgs : {});\n  return modelAction({\n    action: \"groupBy\",\n    unpacker: groupByUnpacker\n  })(groupByArgs);\n}\n__name(groupBy, \"groupBy\");\n\n// src/runtime/core/model/applyAggregates.ts\nfunction applyAggregates(client, action, modelAction) {\n  if (action === \"aggregate\")\n    return (userArgs) => aggregate(client, userArgs, modelAction);\n  if (action === \"count\")\n    return (userArgs) => count(client, userArgs, modelAction);\n  if (action === \"groupBy\")\n    return (userArgs) => groupBy(client, userArgs, modelAction);\n  return void 0;\n}\n__name(applyAggregates, \"applyAggregates\");\n\n// src/runtime/query.ts\nvar import_chalk11 = __toESM(require_source());\nvar import_indent_string4 = __toESM(require_indent_string());\nvar import_strip_ansi3 = __toESM(require_strip_ansi());\n\n// src/runtime/utils/createErrorMessageWithContext.ts\nvar import_chalk9 = __toESM(require_source());\nvar import_indent_string3 = __toESM(require_indent_string());\n\n// src/runtime/utils/SourceFileSlice.ts\nvar import_fs8 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\n\n// src/runtime/highlight/theme.ts\nvar import_chalk8 = __toESM(require_source());\nvar orange = import_chalk8.default.rgb(246, 145, 95);\nvar darkBrightBlue = import_chalk8.default.rgb(107, 139, 140);\nvar blue = import_chalk8.default.cyan;\nvar brightBlue = import_chalk8.default.rgb(127, 155, 155);\nvar identity = /* @__PURE__ */ __name((str) => str, \"identity\");\nvar theme = {\n  keyword: blue,\n  entity: blue,\n  value: brightBlue,\n  punctuation: darkBrightBlue,\n  directive: blue,\n  function: blue,\n  variable: brightBlue,\n  string: import_chalk8.default.greenBright,\n  boolean: orange,\n  number: import_chalk8.default.cyan,\n  comment: import_chalk8.default.grey\n};\n\n// src/runtime/highlight/prism.ts\nvar _self = {};\nvar uniqueId = 0;\nvar Prism = {\n  manual: _self.Prism && _self.Prism.manual,\n  disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n  util: {\n    encode: function(tokens) {\n      if (tokens instanceof Token) {\n        const anyTokens = tokens;\n        return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);\n      } else if (Array.isArray(tokens)) {\n        return tokens.map(Prism.util.encode);\n      } else {\n        return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n      }\n    },\n    type: function(o) {\n      return Object.prototype.toString.call(o).slice(8, -1);\n    },\n    objId: function(obj) {\n      if (!obj[\"__id\"]) {\n        Object.defineProperty(obj, \"__id\", { value: ++uniqueId });\n      }\n      return obj[\"__id\"];\n    },\n    clone: /* @__PURE__ */ __name(function deepClone(o, visited) {\n      let clone2, id, type = Prism.util.type(o);\n      visited = visited || {};\n      switch (type) {\n        case \"Object\":\n          id = Prism.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone2 = {};\n          visited[id] = clone2;\n          for (const key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone2[key] = deepClone(o[key], visited);\n            }\n          }\n          return clone2;\n        case \"Array\":\n          id = Prism.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone2 = [];\n          visited[id] = clone2;\n          o.forEach(function(v, i) {\n            clone2[i] = deepClone(v, visited);\n          });\n          return clone2;\n        default:\n          return o;\n      }\n    }, \"deepClone\")\n  },\n  languages: {\n    extend: function(id, redef) {\n      const lang = Prism.util.clone(Prism.languages[id]);\n      for (const key in redef) {\n        lang[key] = redef[key];\n      }\n      return lang;\n    },\n    insertBefore: function(inside, before, insert, root) {\n      root = root || Prism.languages;\n      const grammar = root[inside];\n      const ret = {};\n      for (const token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (const newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken];\n              }\n            }\n          }\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token];\n          }\n        }\n      }\n      const old = root[inside];\n      root[inside] = ret;\n      Prism.languages.DFS(Prism.languages, function(key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret;\n        }\n      });\n      return ret;\n    },\n    DFS: /* @__PURE__ */ __name(function DFS(o, callback, type, visited) {\n      visited = visited || {};\n      const objId = Prism.util.objId;\n      for (const i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i);\n          const property = o[i], propertyType = Prism.util.type(property);\n          if (propertyType === \"Object\" && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, null, visited);\n          } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, i, visited);\n          }\n        }\n      }\n    }, \"DFS\")\n  },\n  plugins: {},\n  highlight: function(text, grammar, language) {\n    const env2 = {\n      code: text,\n      grammar,\n      language\n    };\n    Prism.hooks.run(\"before-tokenize\", env2);\n    env2.tokens = Prism.tokenize(env2.code, env2.grammar);\n    Prism.hooks.run(\"after-tokenize\", env2);\n    return Token.stringify(Prism.util.encode(env2.tokens), env2.language);\n  },\n  matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {\n    for (const token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue;\n      }\n      if (token == target) {\n        return;\n      }\n      let patterns = grammar[token];\n      patterns = Prism.util.type(patterns) === \"Array\" ? patterns : [patterns];\n      for (let j = 0; j < patterns.length; ++j) {\n        let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;\n        if (greedy && !pattern.pattern.global) {\n          const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\n          pattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\n        }\n        pattern = pattern.pattern || pattern;\n        for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {\n          let str = strarr[i];\n          if (strarr.length > text.length) {\n            return;\n          }\n          if (str instanceof Token) {\n            continue;\n          }\n          if (greedy && i != strarr.length - 1) {\n            pattern.lastIndex = pos;\n            var match = pattern.exec(text);\n            if (!match) {\n              break;\n            }\n            var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;\n            for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {\n              p += strarr[k].length;\n              if (from >= p) {\n                ++i;\n                pos = p;\n              }\n            }\n            if (strarr[i] instanceof Token) {\n              continue;\n            }\n            delNum = k - i;\n            str = text.slice(pos, p);\n            match.index -= pos;\n          } else {\n            pattern.lastIndex = 0;\n            var match = pattern.exec(str), delNum = 1;\n          }\n          if (!match) {\n            if (oneshot) {\n              break;\n            }\n            continue;\n          }\n          if (lookbehind) {\n            lookbehindLength = match[1] ? match[1].length : 0;\n          }\n          var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);\n          const args = [i, delNum];\n          if (before) {\n            ++i;\n            pos += before.length;\n            args.push(before);\n          }\n          const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);\n          args.push(wrapped);\n          if (after) {\n            args.push(after);\n          }\n          Array.prototype.splice.apply(strarr, args);\n          if (delNum != 1)\n            Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);\n          if (oneshot)\n            break;\n        }\n      }\n    }\n  },\n  tokenize: function(text, grammar) {\n    const strarr = [text];\n    const rest = grammar.rest;\n    if (rest) {\n      for (const token in rest) {\n        grammar[token] = rest[token];\n      }\n      delete grammar.rest;\n    }\n    Prism.matchGrammar(text, strarr, grammar, 0, 0, false);\n    return strarr;\n  },\n  hooks: {\n    all: {},\n    add: function(name, callback) {\n      const hooks = Prism.hooks.all;\n      hooks[name] = hooks[name] || [];\n      hooks[name].push(callback);\n    },\n    run: function(name, env2) {\n      const callbacks = Prism.hooks.all[name];\n      if (!callbacks || !callbacks.length) {\n        return;\n      }\n      for (var i = 0, callback; callback = callbacks[i++]; ) {\n        callback(env2);\n      }\n    }\n  },\n  Token\n};\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      lookbehind: true\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true,\n      greedy: true\n    }\n  ],\n  string: {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  \"class-name\": {\n    pattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      punctuation: /[.\\\\]/\n    }\n  },\n  keyword: /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  boolean: /\\b(?:true|false)\\b/,\n  function: /\\w+(?=\\()/,\n  number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  operator: /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n  punctuation: /[{}[\\];(),.:]/\n};\nPrism.languages.javascript = Prism.languages.extend(\"clike\", {\n  \"class-name\": [\n    Prism.languages.clike[\"class-name\"],\n    {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[_$A-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\.(?:prototype|constructor))/,\n      lookbehind: true\n    }\n  ],\n  keyword: [\n    {\n      pattern: /((?:^|})\\s*)(?:catch|finally)\\b/,\n      lookbehind: true\n    },\n    {\n      pattern: /(^|[^.])\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n      lookbehind: true\n    }\n  ],\n  number: /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n  function: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  operator: /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n  regex: {\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=\\s*($|[\\r\\n,.;})\\]]))/,\n    lookbehind: true,\n    greedy: true\n  },\n  \"function-variable\": {\n    pattern: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/,\n    alias: \"function\"\n  },\n  parameter: [\n    {\n      pattern: /(function(?:\\s+[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)?\\s*\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\))/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=>)/i,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /(\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*=>)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*\\s*)\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*\\{)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    }\n  ],\n  constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nif (Prism.languages.markup) {\n  Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\nPrism.languages.typescript = Prism.languages.extend(\"javascript\", {\n  keyword: /\\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\\b/,\n  builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/\n});\nPrism.languages.ts = Prism.languages.typescript;\nfunction Token(type, content, alias, matchedStr, greedy) {\n  this.type = type;\n  this.content = content;\n  this.alias = alias;\n  this.length = (matchedStr || \"\").length | 0;\n  this.greedy = !!greedy;\n}\n__name(Token, \"Token\");\nToken.stringify = function(o, language) {\n  if (typeof o == \"string\") {\n    return o;\n  }\n  if (Array.isArray(o)) {\n    return o.map(function(element) {\n      return Token.stringify(element, language);\n    }).join(\"\");\n  }\n  return getColorForSyntaxKind(o.type)(o.content);\n};\nfunction getColorForSyntaxKind(syntaxKind) {\n  return theme[syntaxKind] || identity;\n}\n__name(getColorForSyntaxKind, \"getColorForSyntaxKind\");\n\n// src/runtime/highlight/highlight.ts\nfunction highlightTS(str) {\n  return highlight(str, Prism.languages.javascript);\n}\n__name(highlightTS, \"highlightTS\");\nfunction highlight(str, grammar) {\n  const tokens = Prism.tokenize(str, grammar);\n  return tokens.map((t) => Token.stringify(t)).join(\"\");\n}\n__name(highlight, \"highlight\");\n\n// src/runtime/utils/dedent.ts\nvar import_strip_indent2 = __toESM(require_strip_indent());\nfunction dedent2(str) {\n  return (0, import_strip_indent2.default)(str);\n}\n__name(dedent2, \"dedent\");\n\n// src/runtime/utils/SourceFileSlice.ts\nvar SourceFileSlice = class {\n  static read(filePath) {\n    let content;\n    try {\n      content = import_fs8.default.readFileSync(filePath, \"utf-8\");\n    } catch (e) {\n      return null;\n    }\n    return SourceFileSlice.fromContent(content);\n  }\n  static fromContent(content) {\n    const lines = content.split(/\\r?\\n/);\n    return new SourceFileSlice(1, lines);\n  }\n  constructor(firstLine, lines) {\n    this.firstLineNumber = firstLine;\n    this.lines = lines;\n  }\n  get lastLineNumber() {\n    return this.firstLineNumber + this.lines.length - 1;\n  }\n  mapLineAt(lineNumber, mapFn) {\n    if (lineNumber < this.firstLineNumber || lineNumber > this.lines.length + this.firstLineNumber) {\n      return this;\n    }\n    const idx = lineNumber - this.firstLineNumber;\n    const newLines = [...this.lines];\n    newLines[idx] = mapFn(newLines[idx]);\n    return new SourceFileSlice(this.firstLineNumber, newLines);\n  }\n  mapLines(mapFn) {\n    return new SourceFileSlice(\n      this.firstLineNumber,\n      this.lines.map((line, i) => mapFn(line, this.firstLineNumber + i))\n    );\n  }\n  lineAt(lineNumber) {\n    return this.lines[lineNumber - this.firstLineNumber];\n  }\n  prependSymbolAt(atLine, str) {\n    return this.mapLines((line, lineNumber) => {\n      if (lineNumber === atLine) {\n        return `${str} ${line}`;\n      }\n      return `  ${line}`;\n    });\n  }\n  slice(fromLine, toLine) {\n    const slicedLines = this.lines.slice(fromLine - 1, toLine).join(\"\\n\");\n    return new SourceFileSlice(fromLine, dedent2(slicedLines).split(\"\\n\"));\n  }\n  highlight() {\n    const highlighted = highlightTS(this.toString());\n    return new SourceFileSlice(this.firstLineNumber, highlighted.split(\"\\n\"));\n  }\n  toString() {\n    return this.lines.join(\"\\n\");\n  }\n};\n__name(SourceFileSlice, \"SourceFileSlice\");\n\n// src/runtime/utils/createErrorMessageWithContext.ts\nvar colorsEnabled = {\n  red: (str) => import_chalk9.default.red(str),\n  gray: (str) => import_chalk9.default.gray(str),\n  dim: (str) => import_chalk9.default.dim(str),\n  bold: (str) => import_chalk9.default.bold(str),\n  underline: (str) => import_chalk9.default.underline(str),\n  highlightSource: (source) => source.highlight()\n};\nvar colorsDisabled = {\n  red: (str) => str,\n  gray: (str) => str,\n  dim: (str) => str,\n  bold: (str) => str,\n  underline: (str) => str,\n  highlightSource: (source) => source\n};\nfunction getTemplateParameters({ callsite, message, originalMethod, isPanic, callArguments }, colors) {\n  var _a3;\n  const templateParameters = {\n    functionName: `prisma.${originalMethod}()`,\n    message,\n    isPanic: isPanic != null ? isPanic : false,\n    callArguments\n  };\n  if (!callsite || typeof window !== \"undefined\") {\n    return templateParameters;\n  }\n  if (false) {}\n  const callLocation = callsite.getLocation();\n  if (!callLocation || !callLocation.lineNumber || !callLocation.columnNumber) {\n    return templateParameters;\n  }\n  const contextFirstLine = Math.max(1, callLocation.lineNumber - 3);\n  let source = (_a3 = SourceFileSlice.read(callLocation.fileName)) == null ? void 0 : _a3.slice(contextFirstLine, callLocation.lineNumber);\n  if (source) {\n    const invocationLine = source.lineAt(callLocation.lineNumber);\n    const invocationLineIndent = getIndent(invocationLine);\n    const invocationCallCode = findPrismaActionCall(invocationLine);\n    if (!invocationCallCode) {\n      return templateParameters;\n    }\n    templateParameters.functionName = `${invocationCallCode.code})`;\n    templateParameters.location = callLocation;\n    if (!isPanic) {\n      source = source.mapLineAt(callLocation.lineNumber, (line) => line.slice(0, invocationCallCode.openingBraceIndex));\n    }\n    source = colors.highlightSource(source);\n    const numberColumnWidth = String(source.lastLineNumber).length;\n    templateParameters.contextLines = source.mapLines((line, lineNumber) => colors.gray(String(lineNumber).padStart(numberColumnWidth)) + \" \" + line).mapLines((line) => colors.dim(line)).prependSymbolAt(callLocation.lineNumber, colors.bold(colors.red(\"\\u2192\")));\n    if (callArguments) {\n      let indentValue = invocationLineIndent + numberColumnWidth + 1;\n      indentValue += 2;\n      templateParameters.callArguments = (0, import_indent_string3.default)(callArguments, indentValue).slice(indentValue);\n    }\n  }\n  return templateParameters;\n}\n__name(getTemplateParameters, \"getTemplateParameters\");\nfunction findPrismaActionCall(str) {\n  const allActions = allClientModelActions.join(\"|\");\n  const regexp = new RegExp(String.raw`\\S+(${allActions})\\(`);\n  const match = regexp.exec(str);\n  if (match) {\n    return {\n      code: match[0],\n      openingBraceIndex: match.index + match[0].length\n    };\n  }\n  return null;\n}\n__name(findPrismaActionCall, \"findPrismaActionCall\");\nfunction getIndent(line) {\n  let spaceCount = 0;\n  for (let i = 0; i < line.length; i++) {\n    if (line.charAt(i) !== \" \") {\n      return spaceCount;\n    }\n    spaceCount++;\n  }\n  return spaceCount;\n}\n__name(getIndent, \"getIndent\");\nfunction stringifyErrorMessage({ functionName, location, message, isPanic, contextLines, callArguments }, colors) {\n  const lines = [\"\"];\n  const introSuffix = location ? \" in\" : \":\";\n  if (isPanic) {\n    lines.push(colors.red(`Oops, an unknown error occured! This is ${colors.bold(\"on us\")}, you did nothing wrong.`));\n    lines.push(colors.red(`It occured in the ${colors.bold(`\\`${functionName}\\``)} invocation${introSuffix}`));\n  } else {\n    lines.push(colors.red(`Invalid ${colors.bold(`\\`${functionName}\\``)} invocation${introSuffix}`));\n  }\n  if (location) {\n    lines.push(colors.underline(stringifyLocationInFile(location)));\n  }\n  if (contextLines) {\n    lines.push(\"\");\n    const contextLineParts = [contextLines.toString()];\n    if (callArguments) {\n      contextLineParts.push(callArguments);\n      contextLineParts.push(colors.dim(\")\"));\n    }\n    lines.push(contextLineParts.join(\"\"));\n    if (callArguments) {\n      lines.push(\"\");\n    }\n  } else {\n    lines.push(\"\");\n    if (callArguments) {\n      lines.push(callArguments);\n    }\n    lines.push(\"\");\n  }\n  lines.push(message);\n  return lines.join(\"\\n\");\n}\n__name(stringifyErrorMessage, \"stringifyErrorMessage\");\nfunction stringifyLocationInFile(location) {\n  const parts = [location.fileName];\n  if (location.lineNumber) {\n    parts.push(String(location.lineNumber));\n  }\n  if (location.columnNumber) {\n    parts.push(String(location.columnNumber));\n  }\n  return parts.join(\":\");\n}\n__name(stringifyLocationInFile, \"stringifyLocationInFile\");\nfunction createErrorMessageWithContext(args) {\n  const colors = args.showColors ? colorsEnabled : colorsDisabled;\n  const templateParameters = getTemplateParameters(args, colors);\n  return stringifyErrorMessage(templateParameters, colors);\n}\n__name(createErrorMessageWithContext, \"createErrorMessageWithContext\");\n\n// src/runtime/utils/deep-extend.ts\nfunction isSpecificValue(val) {\n  return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;\n}\n__name(isSpecificValue, \"isSpecificValue\");\nfunction cloneSpecificValue(val) {\n  if (val instanceof Buffer) {\n    const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);\n    val.copy(x);\n    return x;\n  } else if (val instanceof Date) {\n    return new Date(val.getTime());\n  } else if (val instanceof RegExp) {\n    return new RegExp(val);\n  } else {\n    throw new Error(\"Unexpected situation\");\n  }\n}\n__name(cloneSpecificValue, \"cloneSpecificValue\");\nfunction deepCloneArray(arr) {\n  const clone2 = [];\n  arr.forEach(function(item, index) {\n    if (typeof item === \"object\" && item !== null) {\n      if (Array.isArray(item)) {\n        clone2[index] = deepCloneArray(item);\n      } else if (isSpecificValue(item)) {\n        clone2[index] = cloneSpecificValue(item);\n      } else {\n        clone2[index] = deepExtend({}, item);\n      }\n    } else {\n      clone2[index] = item;\n    }\n  });\n  return clone2;\n}\n__name(deepCloneArray, \"deepCloneArray\");\nfunction safeGetProperty(object, property) {\n  return property === \"__proto__\" ? void 0 : object[property];\n}\n__name(safeGetProperty, \"safeGetProperty\");\nvar deepExtend = /* @__PURE__ */ __name(function(target, ...args) {\n  if (!target || typeof target !== \"object\") {\n    return false;\n  }\n  if (args.length === 0) {\n    return target;\n  }\n  let val, src;\n  for (const obj of args) {\n    if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n      continue;\n    }\n    for (const key of Object.keys(obj)) {\n      src = safeGetProperty(target, key);\n      val = safeGetProperty(obj, key);\n      if (val === target) {\n        continue;\n      } else if (typeof val !== \"object\" || val === null) {\n        target[key] = val;\n        continue;\n      } else if (Array.isArray(val)) {\n        target[key] = deepCloneArray(val);\n        continue;\n      } else if (isSpecificValue(val)) {\n        target[key] = cloneSpecificValue(val);\n        continue;\n      } else if (typeof src !== \"object\" || src === null || Array.isArray(src)) {\n        target[key] = deepExtend({}, val);\n        continue;\n      } else {\n        target[key] = deepExtend(src, val);\n        continue;\n      }\n    }\n  }\n  return target;\n}, \"deepExtend\");\n\n// src/runtime/utils/deep-set.ts\nvar keys = /* @__PURE__ */ __name((ks) => Array.isArray(ks) ? ks : ks.split(\".\"), \"keys\");\nvar deepGet = /* @__PURE__ */ __name((o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o), \"deepGet\");\nvar deepSet = /* @__PURE__ */ __name((o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v2 }), v), \"deepSet\");\n\n// src/runtime/utils/filterObject.ts\nfunction filterObject(obj, cb) {\n  if (!obj || typeof obj !== \"object\" || typeof obj.hasOwnProperty !== \"function\") {\n    return obj;\n  }\n  const newObj = {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {\n      newObj[key] = value;\n    }\n  }\n  return newObj;\n}\n__name(filterObject, \"filterObject\");\n\n// src/runtime/utils/flatMap.ts\nfunction flatten(array) {\n  return Array.prototype.concat.apply([], array);\n}\n__name(flatten, \"flatten\");\nfunction flatMap(array, callbackFn, thisArg) {\n  return flatten(array.map(callbackFn, thisArg));\n}\n__name(flatMap, \"flatMap\");\n\n// src/runtime/utils/isObject.ts\nvar notReallyObjects = {\n  \"[object Date]\": true,\n  \"[object Uint8Array]\": true,\n  \"[object Decimal]\": true\n};\nfunction isObject2(value) {\n  if (!value) {\n    return false;\n  }\n  return typeof value === \"object\" && !notReallyObjects[Object.prototype.toString.call(value)];\n}\n__name(isObject2, \"isObject\");\n\n// src/runtime/utils/omit.ts\nfunction omit2(object, path7) {\n  const result = {};\n  const paths = Array.isArray(path7) ? path7 : [path7];\n  for (const key in object) {\n    if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n__name(omit2, \"omit\");\n\n// src/runtime/utils/printJsonErrors.ts\nvar import_chalk10 = __toESM(require_source());\nvar import_strip_ansi2 = __toESM(require_strip_ansi());\n\n// src/runtime/utils/stringifyObject.ts\nvar isRegexp = require_is_regexp();\nvar isObj = require_is_obj();\nvar getOwnEnumPropSymbols = require_lib().default;\nvar stringifyObject = /* @__PURE__ */ __name((input, options, pad) => {\n  const seen = [];\n  return (/* @__PURE__ */ __name(function stringifyObject2(input2, options2 = {}, pad2 = \"\", path7 = []) {\n    options2.indent = options2.indent || \"\t\";\n    let tokens;\n    if (options2.inlineCharacterLimit === void 0) {\n      tokens = {\n        newLine: \"\\n\",\n        newLineOrSpace: \"\\n\",\n        pad: pad2,\n        indent: pad2 + options2.indent\n      };\n    } else {\n      tokens = {\n        newLine: \"@@__STRINGIFY_OBJECT_NEW_LINE__@@\",\n        newLineOrSpace: \"@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@\",\n        pad: \"@@__STRINGIFY_OBJECT_PAD__@@\",\n        indent: \"@@__STRINGIFY_OBJECT_INDENT__@@\"\n      };\n    }\n    const expandWhiteSpace = /* @__PURE__ */ __name((string) => {\n      if (options2.inlineCharacterLimit === void 0) {\n        return string;\n      }\n      const oneLined = string.replace(new RegExp(tokens.newLine, \"g\"), \"\").replace(new RegExp(tokens.newLineOrSpace, \"g\"), \" \").replace(new RegExp(tokens.pad + \"|\" + tokens.indent, \"g\"), \"\");\n      if (oneLined.length <= options2.inlineCharacterLimit) {\n        return oneLined;\n      }\n      return string.replace(new RegExp(tokens.newLine + \"|\" + tokens.newLineOrSpace, \"g\"), \"\\n\").replace(new RegExp(tokens.pad, \"g\"), pad2).replace(new RegExp(tokens.indent, \"g\"), pad2 + options2.indent);\n    }, \"expandWhiteSpace\");\n    if (seen.indexOf(input2) !== -1) {\n      return '\"[Circular]\"';\n    }\n    if (Buffer.isBuffer(input2)) {\n      return `Buffer(${Buffer.length})`;\n    }\n    if (input2 === null || input2 === void 0 || typeof input2 === \"number\" || typeof input2 === \"boolean\" || typeof input2 === \"function\" || typeof input2 === \"symbol\" || input2 instanceof ObjectEnumValue || isRegexp(input2)) {\n      return String(input2);\n    }\n    if (input2 instanceof Date) {\n      return `new Date('${input2.toISOString()}')`;\n    }\n    if (input2 instanceof FieldRefImpl) {\n      return `prisma.${lowerCase(input2.modelName)}.fields.${input2.name}`;\n    }\n    if (Array.isArray(input2)) {\n      if (input2.length === 0) {\n        return \"[]\";\n      }\n      seen.push(input2);\n      const ret = \"[\" + tokens.newLine + input2.map((el, i) => {\n        const eol = input2.length - 1 === i ? tokens.newLine : \",\" + tokens.newLineOrSpace;\n        let value = stringifyObject2(el, options2, pad2 + options2.indent, [...path7, i]);\n        if (options2.transformValue) {\n          value = options2.transformValue(input2, i, value);\n        }\n        return tokens.indent + value + eol;\n      }).join(\"\") + tokens.pad + \"]\";\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n    if (isObj(input2)) {\n      let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));\n      if (options2.filter) {\n        objKeys = objKeys.filter((el) => options2.filter(input2, el));\n      }\n      if (objKeys.length === 0) {\n        return \"{}\";\n      }\n      seen.push(input2);\n      const ret = \"{\" + tokens.newLine + objKeys.map((el, i) => {\n        const eol = objKeys.length - 1 === i ? tokens.newLine : \",\" + tokens.newLineOrSpace;\n        const isSymbol = typeof el === \"symbol\";\n        const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);\n        const key = isSymbol || isClassic ? el : stringifyObject2(el, options2, void 0, [...path7, el]);\n        let value = stringifyObject2(input2[el], options2, pad2 + options2.indent, [...path7, el]);\n        if (options2.transformValue) {\n          value = options2.transformValue(input2, el, value);\n        }\n        let line = tokens.indent + String(key) + \": \" + value + eol;\n        if (options2.transformLine) {\n          line = options2.transformLine({\n            obj: input2,\n            indent: tokens.indent,\n            key,\n            stringifiedValue: value,\n            value: input2[el],\n            eol,\n            originalLine: line,\n            path: path7.concat(key)\n          });\n        }\n        return line;\n      }).join(\"\") + tokens.pad + \"}\";\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n    input2 = String(input2).replace(/[\\r\\n]/g, (x) => x === \"\\n\" ? \"\\\\n\" : \"\\\\r\");\n    if (options2.singleQuotes === false) {\n      input2 = input2.replace(/\"/g, '\\\\\"');\n      return `\"${input2}\"`;\n    }\n    input2 = input2.replace(/\\\\?'/g, \"\\\\'\");\n    return `'${input2}'`;\n  }, \"stringifyObject\"))(input, options, pad);\n}, \"stringifyObject\");\nvar stringifyObject_default = stringifyObject;\n\n// src/runtime/utils/printJsonErrors.ts\nvar DIM_TOKEN = \"@@__DIM_POINTER__@@\";\nfunction printJsonWithErrors({ ast, keyPaths, valuePaths, missingItems }) {\n  let obj = ast;\n  for (const { path: path7, type } of missingItems) {\n    obj = deepSet(obj, path7, type);\n  }\n  return stringifyObject_default(obj, {\n    indent: \"  \",\n    transformLine: ({ indent: indent4, key, value, stringifiedValue, eol, path: path7 }) => {\n      const dottedPath = path7.join(\".\");\n      const keyError = keyPaths.includes(dottedPath);\n      const valueError = valuePaths.includes(dottedPath);\n      const missingItem = missingItems.find((item) => item.path === dottedPath);\n      let valueStr = stringifiedValue;\n      if (missingItem) {\n        if (typeof value === \"string\") {\n          valueStr = valueStr.slice(1, valueStr.length - 1);\n        }\n        const isRequiredStr = missingItem.isRequired ? \"\" : \"?\";\n        const prefix = missingItem.isRequired ? \"+\" : \"?\";\n        const color = missingItem.isRequired ? import_chalk10.default.greenBright : import_chalk10.default.green;\n        let output = color(prefixLines(key + isRequiredStr + \": \" + valueStr + eol, indent4, prefix));\n        if (!missingItem.isRequired) {\n          output = import_chalk10.default.dim(output);\n        }\n        return output;\n      } else {\n        const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));\n        const isOptional = key[key.length - 2] === \"?\";\n        if (isOptional) {\n          key = key.slice(1, key.length - 1);\n        }\n        if (isOptional && typeof value === \"object\" && value !== null) {\n          valueStr = valueStr.split(\"\\n\").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join(\"\\n\");\n        }\n        if (isOnMissingItemPath && typeof value === \"string\") {\n          valueStr = valueStr.slice(1, valueStr.length - 1);\n          if (!isOptional) {\n            valueStr = import_chalk10.default.bold(valueStr);\n          }\n        }\n        if ((typeof value !== \"object\" || value === null) && !valueError && !isOnMissingItemPath) {\n          valueStr = import_chalk10.default.dim(valueStr);\n        }\n        const keyStr = keyError ? import_chalk10.default.redBright(key) : key;\n        valueStr = valueError ? import_chalk10.default.redBright(valueStr) : valueStr;\n        let output = indent4 + keyStr + \": \" + valueStr + (isOnMissingItemPath ? eol : import_chalk10.default.dim(eol));\n        if (keyError || valueError) {\n          const lines = output.split(\"\\n\");\n          const keyLength = String(key).length;\n          const keyScribbles = keyError ? import_chalk10.default.redBright(\"~\".repeat(keyLength)) : \" \".repeat(keyLength);\n          const valueLength = valueError ? getValueLength(indent4, key, value, stringifiedValue) : 0;\n          const hideValueScribbles = valueError && isRenderedAsObject(value);\n          const valueScribbles = valueError ? \"  \" + import_chalk10.default.redBright(\"~\".repeat(valueLength)) : \"\";\n          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {\n            lines.splice(1, 0, indent4 + keyScribbles + valueScribbles);\n          }\n          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {\n            lines.splice(lines.length - 1, 0, indent4.slice(0, indent4.length - 2) + valueScribbles);\n          }\n          output = lines.join(\"\\n\");\n        }\n        return output;\n      }\n    }\n  });\n}\n__name(printJsonWithErrors, \"printJsonWithErrors\");\nfunction getValueLength(indent4, key, value, stringifiedValue) {\n  if (value === null) {\n    return 4;\n  }\n  if (typeof value === \"string\") {\n    return value.length + 2;\n  }\n  if (isRenderedAsObject(value)) {\n    return Math.abs(getLongestLine(`${key}: ${(0, import_strip_ansi2.default)(stringifiedValue)}`) - indent4.length);\n  }\n  return String(value).length;\n}\n__name(getValueLength, \"getValueLength\");\nfunction isRenderedAsObject(value) {\n  return typeof value === \"object\" && value !== null && !(value instanceof ObjectEnumValue);\n}\n__name(isRenderedAsObject, \"isRenderedAsObject\");\nfunction getLongestLine(str) {\n  return str.split(\"\\n\").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);\n}\n__name(getLongestLine, \"getLongestLine\");\nfunction prefixLines(str, indent4, prefix) {\n  return str.split(\"\\n\").map(\n    (line, index, arr) => index === 0 ? prefix + indent4.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line\n  ).map((line) => {\n    return (0, import_strip_ansi2.default)(line).includes(DIM_TOKEN) ? import_chalk10.default.dim(line.replace(DIM_TOKEN, \"\")) : line.includes(\"?\") ? import_chalk10.default.dim(line) : line;\n  }).join(\"\\n\");\n}\n__name(prefixLines, \"prefixLines\");\n\n// src/runtime/query.ts\nvar tab = 2;\nvar Document = class {\n  constructor(type, children) {\n    this.type = type;\n    this.children = children;\n    this.printFieldError = /* @__PURE__ */ __name(({ error: error2 }, missingItems, minimal) => {\n      if (error2.type === \"emptySelect\") {\n        const additional = minimal ? \"\" : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        return `The ${import_chalk11.default.redBright(\"`select`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} must not be empty.${additional}`;\n      }\n      if (error2.type === \"emptyInclude\") {\n        if (missingItems.length === 0) {\n          return `${import_chalk11.default.bold(\n            getOutputTypeName(error2.field.outputType.type)\n          )} does not have any relation and therefore can't have an ${import_chalk11.default.redBright(\"`include`\")} statement.`;\n        }\n        const additional = minimal ? \"\" : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        return `The ${import_chalk11.default.redBright(\"`include`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} must not be empty.${additional}`;\n      }\n      if (error2.type === \"noTrueSelect\") {\n        return `The ${import_chalk11.default.redBright(\"`select`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} needs ${import_chalk11.default.bold(\"at least one truthy value\")}.`;\n      }\n      if (error2.type === \"includeAndSelect\") {\n        return `Please ${import_chalk11.default.bold(\"either\")} use ${import_chalk11.default.greenBright(\"`include`\")} or ${import_chalk11.default.greenBright(\n          \"`select`\"\n        )}, but ${import_chalk11.default.redBright(\"not both\")} at the same time.`;\n      }\n      if (error2.type === \"invalidFieldName\") {\n        const statement = error2.isInclude ? \"include\" : \"select\";\n        const wording = error2.isIncludeScalar ? \"Invalid scalar\" : \"Unknown\";\n        const additional = minimal ? \"\" : error2.isInclude && missingItems.length === 0 ? `\nThis model has no relations, so you can't use ${import_chalk11.default.redBright(\"include\")} with it.` : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        let str = `${wording} field ${import_chalk11.default.redBright(`\\`${error2.providedName}\\``)} for ${import_chalk11.default.bold(\n          statement\n        )} statement on model ${import_chalk11.default.bold.white(error2.modelName)}.${additional}`;\n        if (error2.didYouMean) {\n          str += ` Did you mean ${import_chalk11.default.greenBright(`\\`${error2.didYouMean}\\``)}?`;\n        }\n        if (error2.isIncludeScalar) {\n          str += `\nNote, that ${import_chalk11.default.bold(\"include\")} statements only accept relation fields.`;\n        }\n        return str;\n      }\n      if (error2.type === \"invalidFieldType\") {\n        const str = `Invalid value ${import_chalk11.default.redBright(\n          `${stringifyObject_default(error2.providedValue)}`\n        )} of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue, void 0))} for field ${import_chalk11.default.bold(\n          `${error2.fieldName}`\n        )} on model ${import_chalk11.default.bold.white(error2.modelName)}. Expected either ${import_chalk11.default.greenBright(\n          \"true\"\n        )} or ${import_chalk11.default.greenBright(\"false\")}.`;\n        return str;\n      }\n      return void 0;\n    }, \"printFieldError\");\n    this.printArgError = /* @__PURE__ */ __name(({ error: error2, path: path7, id }, hasMissingItems, minimal) => {\n      if (error2.type === \"invalidName\") {\n        let str = `Unknown arg ${import_chalk11.default.redBright(`\\`${error2.providedName}\\``)} in ${import_chalk11.default.bold(\n          path7.join(\".\")\n        )} for type ${import_chalk11.default.bold(error2.outputType ? error2.outputType.name : getInputTypeName(error2.originalType))}.`;\n        if (error2.didYouMeanField) {\n          str += `\n\\u2192 Did you forget to wrap it with \\`${import_chalk11.default.greenBright(\"select\")}\\`? ${import_chalk11.default.dim(\n            \"e.g. \" + import_chalk11.default.greenBright(`{ select: { ${error2.providedName}: ${error2.providedValue} } }`)\n          )}`;\n        } else if (error2.didYouMeanArg) {\n          str += ` Did you mean \\`${import_chalk11.default.greenBright(error2.didYouMeanArg)}\\`?`;\n          if (!hasMissingItems && !minimal) {\n            str += ` ${import_chalk11.default.dim(\"Available args:\")}\n` + stringifyInputType(error2.originalType, true);\n          }\n        } else {\n          if (error2.originalType.fields.length === 0) {\n            str += ` The field ${import_chalk11.default.bold(error2.originalType.name)} has no arguments.`;\n          } else if (!hasMissingItems && !minimal) {\n            str += ` Available args:\n\n` + stringifyInputType(error2.originalType, true);\n          }\n        }\n        return str;\n      }\n      if (error2.type === \"invalidType\") {\n        let valueStr = stringifyObject_default(error2.providedValue, { indent: \"  \" });\n        const multilineValue = valueStr.split(\"\\n\").length > 1;\n        if (multilineValue) {\n          valueStr = `\n${valueStr}\n`;\n        }\n        if (error2.requiredType.bestFittingType.location === \"enumTypes\") {\n          return `Argument ${import_chalk11.default.bold(error2.argName)}: Provided value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? \"\" : \" \"}of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue))} on ${import_chalk11.default.bold(\n            `prisma.${this.children[0].name}`\n          )} is not a ${import_chalk11.default.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error2.requiredType.bestFittingType.type),\n              error2.requiredType.bestFittingType.isList\n            )\n          )}.\n\\u2192 Possible values: ${error2.requiredType.bestFittingType.type.values.map((v) => import_chalk11.default.greenBright(`${stringifyGraphQLType(error2.requiredType.bestFittingType.type)}.${v}`)).join(\", \")}`;\n        }\n        let typeStr = \".\";\n        if (isInputArgType(error2.requiredType.bestFittingType.type)) {\n          typeStr = \":\\n\" + stringifyInputType(error2.requiredType.bestFittingType.type);\n        }\n        let expected = `${error2.requiredType.inputType.map(\n          (t) => import_chalk11.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error2.requiredType.bestFittingType.isList))\n        ).join(\" or \")}${typeStr}`;\n        const inputType = error2.requiredType.inputType.length === 2 && error2.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;\n        if (inputType) {\n          expected += `\n` + stringifyInputType(inputType.type, true);\n        }\n        return `Argument ${import_chalk11.default.bold(error2.argName)}: Got invalid value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? \"\" : \" \"}on ${import_chalk11.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk11.default.redBright(\n          getGraphQLType(error2.providedValue)\n        )}, expected ${expected}`;\n      }\n      if (error2.type === \"invalidNullArg\") {\n        const forStr = path7.length === 1 && path7[0] === error2.name ? \"\" : ` for ${import_chalk11.default.bold(`${path7.join(\".\")}`)}`;\n        const undefinedTip = ` Please use ${import_chalk11.default.bold.greenBright(\"undefined\")} instead.`;\n        return `Argument ${import_chalk11.default.greenBright(error2.name)}${forStr} must not be ${import_chalk11.default.bold(\"null\")}.${undefinedTip}`;\n      }\n      if (error2.type === \"missingArg\") {\n        const forStr = path7.length === 1 && path7[0] === error2.missingName ? \"\" : ` for ${import_chalk11.default.bold(`${path7.join(\".\")}`)}`;\n        return `Argument ${import_chalk11.default.greenBright(error2.missingName)}${forStr} is missing.`;\n      }\n      if (error2.type === \"atLeastOne\") {\n        const additional = minimal ? \"\" : ` Available args are listed in ${import_chalk11.default.dim.green(\"green\")}.`;\n        return `Argument ${import_chalk11.default.bold(path7.join(\".\"))} of type ${import_chalk11.default.bold(\n          error2.inputType.name\n        )} needs ${import_chalk11.default.greenBright(\"at least one\")} argument.${additional}`;\n      }\n      if (error2.type === \"atMostOne\") {\n        const additional = minimal ? \"\" : ` Please choose one. ${import_chalk11.default.dim(\"Available args:\")} \n${stringifyInputType(error2.inputType, true)}`;\n        return `Argument ${import_chalk11.default.bold(path7.join(\".\"))} of type ${import_chalk11.default.bold(\n          error2.inputType.name\n        )} needs ${import_chalk11.default.greenBright(\"exactly one\")} argument, but you provided ${error2.providedKeys.map((key) => import_chalk11.default.redBright(key)).join(\" and \")}.${additional}`;\n      }\n      return void 0;\n    }, \"printArgError\");\n    this.type = type;\n    this.children = children;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Document\";\n  }\n  toString() {\n    return `${this.type} {\n${(0, import_indent_string4.default)(this.children.map(String).join(\"\\n\"), tab)}\n}`;\n  }\n  validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {\n    var _a3;\n    if (!select) {\n      select = {};\n    }\n    const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);\n    if (invalidChildren.length === 0) {\n      return;\n    }\n    const fieldErrors = [];\n    const argErrors = [];\n    const prefix = select && select.select ? \"select\" : select.include ? \"include\" : void 0;\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix);\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1)\n        }))\n      );\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1)\n        }))\n      );\n    }\n    const topLevelQueryName = this.children[0].name;\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName;\n    const keyPaths = [];\n    const valuePaths = [];\n    const missingItems = [];\n    for (const fieldError of fieldErrors) {\n      const path7 = this.normalizePath(fieldError.path, select).join(\".\");\n      if (fieldError.error.type === \"invalidFieldName\") {\n        keyPaths.push(path7);\n        const fieldType = fieldError.error.outputType;\n        const { isInclude } = fieldError.error;\n        fieldType.fields.filter((field) => isInclude ? field.outputType.location === \"outputObjectTypes\" : true).forEach((field) => {\n          const splittedPath = path7.split(\".\");\n          missingItems.push({\n            path: `${splittedPath.slice(0, splittedPath.length - 1).join(\".\")}.${field.name}`,\n            type: \"true\",\n            isRequired: false\n          });\n        });\n      } else if (fieldError.error.type === \"includeAndSelect\") {\n        keyPaths.push(\"select\");\n        keyPaths.push(\"include\");\n      } else {\n        valuePaths.push(path7);\n      }\n      if (fieldError.error.type === \"emptySelect\" || fieldError.error.type === \"noTrueSelect\" || fieldError.error.type === \"emptyInclude\") {\n        const selectPathArray = this.normalizePath(fieldError.path, select);\n        const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(\".\");\n        const fieldType = fieldError.error.field.outputType.type;\n        (_a3 = fieldType.fields) == null ? void 0 : _a3.filter(\n          (field) => fieldError.error.type === \"emptyInclude\" ? field.outputType.location === \"outputObjectTypes\" : true\n        ).forEach((field) => {\n          missingItems.push({\n            path: `${selectPath}.${field.name}`,\n            type: \"true\",\n            isRequired: false\n          });\n        });\n      }\n    }\n    for (const argError of argErrors) {\n      const path7 = this.normalizePath(argError.path, select).join(\".\");\n      if (argError.error.type === \"invalidName\") {\n        keyPaths.push(path7);\n      } else if (argError.error.type !== \"missingArg\" && argError.error.type !== \"atLeastOne\") {\n        valuePaths.push(path7);\n      } else if (argError.error.type === \"missingArg\") {\n        const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {\n          const inputTypeName = getInputTypeName(t.type);\n          if (inputTypeName === \"Null\") {\n            return \"null\";\n          }\n          if (t.isList) {\n            return inputTypeName + \"[]\";\n          }\n          return inputTypeName;\n        }).join(\" | \");\n        missingItems.push({\n          path: path7,\n          type: inputTypeToJson(type, true, path7.split(\"where.\").length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        });\n      }\n    }\n    const renderErrorStr = /* @__PURE__ */ __name((callsite) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) => e.error.type === \"missingArg\" && e.error.missingArg.isRequired\n      );\n      const hasOptionalMissingArgsErrors = Boolean(\n        argErrors.find((e) => e.error.type === \"missingArg\" && !e.error.missingArg.isRequired)\n      );\n      const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;\n      let missingArgsLegend = \"\";\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\n${import_chalk11.default.dim(\"Note: Lines with \")}${import_chalk11.default.reset.greenBright(\"+\")} ${import_chalk11.default.dim(\n          \"are required\"\n        )}`;\n      }\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = \"\\n\";\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += import_chalk11.default.dim(`, lines with ${import_chalk11.default.green(\"?\")} are optional`);\n        } else {\n          missingArgsLegend += import_chalk11.default.dim(`Note: Lines with ${import_chalk11.default.green(\"?\")} are optional`);\n        }\n        missingArgsLegend += import_chalk11.default.dim(\".\");\n      }\n      const relevantArgErrors = argErrors.filter((e) => e.error.type !== \"missingArg\" || e.error.missingArg.isRequired);\n      let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === \"minimal\")).join(\"\\n\");\n      errorMessages += `\n${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === \"minimal\")).join(\"\\n\")}`;\n      if (errorFormat === \"minimal\") {\n        return (0, import_strip_ansi3.default)(errorMessages);\n      }\n      let printJsonArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems\n      };\n      if (originalMethod == null ? void 0 : originalMethod.endsWith(\"aggregate\")) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);\n      }\n      const errorStr = createErrorMessageWithContext({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === \"pretty\",\n        callArguments: printJsonWithErrors(printJsonArgs),\n        message: `${errorMessages}${missingArgsLegend}\n`\n      });\n      if (process.env.NO_COLOR || errorFormat === \"colorless\") {\n        return (0, import_strip_ansi3.default)(errorStr);\n      }\n      return errorStr;\n    }, \"renderErrorStr\");\n    const error2 = new PrismaClientValidationError(renderErrorStr(validationCallsite));\n    if (true) {\n      Object.defineProperty(error2, \"render\", {\n        get: () => renderErrorStr,\n        enumerable: false\n      });\n    }\n    throw error2;\n  }\n  normalizePath(inputPath, select) {\n    const path7 = inputPath.slice();\n    const newPath = [];\n    let key;\n    let pointer = select;\n    while ((key = path7.shift()) !== void 0) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue;\n      }\n      if (key === \"select\") {\n        if (!pointer[key]) {\n          pointer = pointer.include;\n        } else {\n          pointer = pointer[key];\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key];\n      }\n      newPath.push(key);\n    }\n    return newPath;\n  }\n};\n__name(Document, \"Document\");\nvar PrismaClientValidationError = class extends Error {\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientValidationError\";\n  }\n};\n__name(PrismaClientValidationError, \"PrismaClientValidationError\");\nvar PrismaClientConstructorValidationError = class extends Error {\n  constructor(message) {\n    super(message + `\nRead more at https://pris.ly/d/client-constructor`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientConstructorValidationError\";\n  }\n};\n__name(PrismaClientConstructorValidationError, \"PrismaClientConstructorValidationError\");\nvar Field = class {\n  constructor({ name, args, children, error: error2, schemaField }) {\n    this.name = name;\n    this.args = args;\n    this.children = children;\n    this.error = error2;\n    this.schemaField = schemaField;\n    this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;\n    this.hasInvalidArg = args ? args.hasInvalidArg : false;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Field\";\n  }\n  toString() {\n    let str = this.name;\n    if (this.error) {\n      return str + \" # INVALID_FIELD\";\n    }\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`;\n      } else {\n        str += `(\n${(0, import_indent_string4.default)(this.args.toString(), tab)}\n)`;\n      }\n    }\n    if (this.children) {\n      str += ` {\n${(0, import_indent_string4.default)(this.children.map(String).join(\"\\n\"), tab)}\n}`;\n    }\n    return str;\n  }\n  collectErrors(prefix = \"select\") {\n    const fieldErrors = [];\n    const argErrors = [];\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error\n      });\n    }\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix);\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path]\n          }))\n        );\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path]\n          }))\n        );\n      }\n    }\n    if (this.args) {\n      argErrors.push(...this.args.collectErrors().map((e) => ({ ...e, path: [this.name, ...e.path] })));\n    }\n    return {\n      fieldErrors,\n      argErrors\n    };\n  }\n};\n__name(Field, \"Field\");\nvar Args = class {\n  constructor(args = []) {\n    this.args = args;\n    this.hasInvalidArg = args ? args.some((arg2) => Boolean(arg2.hasError)) : false;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Args\";\n  }\n  toString() {\n    if (this.args.length === 0) {\n      return \"\";\n    }\n    return `${this.args.map((arg2) => arg2.toString()).filter((a) => a).join(\"\\n\")}`;\n  }\n  collectErrors() {\n    if (!this.hasInvalidArg) {\n      return [];\n    }\n    return flatMap(this.args, (arg2) => arg2.collectErrors());\n  }\n};\n__name(Args, \"Args\");\nfunction stringify(value, inputType) {\n  if (Buffer.isBuffer(value)) {\n    return JSON.stringify(value.toString(\"base64\"));\n  }\n  if (value instanceof FieldRefImpl) {\n    return `{ _ref: ${JSON.stringify(value.name)}}`;\n  }\n  if (Object.prototype.toString.call(value) === \"[object BigInt]\") {\n    return value.toString();\n  }\n  if (typeof (inputType == null ? void 0 : inputType.type) === \"string\" && inputType.type === \"Json\") {\n    if (value === null) {\n      return \"null\";\n    }\n    if (value && value.values && value.__prismaRawParamaters__) {\n      return JSON.stringify(value.values);\n    }\n    if ((inputType == null ? void 0 : inputType.isList) && Array.isArray(value)) {\n      return JSON.stringify(value.map((o) => JSON.stringify(o)));\n    }\n    return JSON.stringify(JSON.stringify(value));\n  }\n  if (value === void 0) {\n    return null;\n  }\n  if (value === null) {\n    return \"null\";\n  }\n  if (decimal_default.isDecimal(value) || (inputType == null ? void 0 : inputType.type) === \"Decimal\" && isDecimalJsLike(value)) {\n    return stringifyDecimalJsLike(value);\n  }\n  if ((inputType == null ? void 0 : inputType.location) === \"enumTypes\" && typeof value === \"string\") {\n    if (Array.isArray(value)) {\n      return `[${value.join(\", \")}]`;\n    }\n    return value;\n  }\n  return JSON.stringify(value, null, 2);\n}\n__name(stringify, \"stringify\");\nvar Arg2 = class {\n  constructor({ key, value, isEnum = false, error: error2, schemaArg, inputType }) {\n    this.inputType = inputType;\n    this.key = key;\n    this.value = value instanceof ObjectEnumValue ? value._getName() : value;\n    this.isEnum = isEnum;\n    this.error = error2;\n    this.schemaArg = schemaArg;\n    this.isNullable = (schemaArg == null ? void 0 : schemaArg.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true)) || false;\n    this.hasError = Boolean(error2) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);\n  }\n  get [Symbol.toStringTag]() {\n    return \"Arg\";\n  }\n  _toString(value, key) {\n    var _a3;\n    if (typeof value === \"undefined\") {\n      return void 0;\n    }\n    if (value instanceof Args) {\n      return `${key}: {\n${(0, import_indent_string4.default)(value.toString(), 2)}\n}`;\n    }\n    if (Array.isArray(value)) {\n      if (((_a3 = this.inputType) == null ? void 0 : _a3.type) === \"Json\") {\n        return `${key}: ${stringify(value, this.inputType)}`;\n      }\n      const isScalar = !value.some((v) => typeof v === \"object\");\n      return `${key}: [${isScalar ? \"\" : \"\\n\"}${(0, import_indent_string4.default)(\n        value.map((nestedValue) => {\n          if (nestedValue instanceof Args) {\n            return `{\n${(0, import_indent_string4.default)(nestedValue.toString(), tab)}\n}`;\n          }\n          return stringify(nestedValue, this.inputType);\n        }).join(`,${isScalar ? \" \" : \"\\n\"}`),\n        isScalar ? 0 : tab\n      )}${isScalar ? \"\" : \"\\n\"}]`;\n    }\n    return `${key}: ${stringify(value, this.inputType)}`;\n  }\n  toString() {\n    return this._toString(this.value, this.key);\n  }\n  collectErrors() {\n    var _a3;\n    if (!this.hasError) {\n      return [];\n    }\n    const errors = [];\n    if (this.error) {\n      const id = typeof ((_a3 = this.inputType) == null ? void 0 : _a3.type) === \"object\" ? `${this.inputType.type.name}${this.inputType.isList ? \"[]\" : \"\"}` : void 0;\n      errors.push({\n        error: this.error,\n        path: [this.key],\n        id\n      });\n    }\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...flatMap(this.value, (val, index) => {\n          if (!(val == null ? void 0 : val.collectErrors)) {\n            return [];\n          }\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] };\n          });\n        })\n      );\n    }\n    if (this.value instanceof Args) {\n      errors.push(...this.value.collectErrors().map((e) => ({ ...e, path: [this.key, ...e.path] })));\n    }\n    return errors;\n  }\n};\n__name(Arg2, \"Arg\");\nfunction makeDocument({ dmmf, rootTypeName, rootField, select, modelName }) {\n  if (!select) {\n    select = {};\n  }\n  const rootType = rootTypeName === \"query\" ? dmmf.queryType : dmmf.mutationType;\n  const fakeRootField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      location: \"outputObjectTypes\"\n    },\n    name: rootTypeName\n  };\n  const context3 = {\n    modelName\n  };\n  const children = selectionToFields(dmmf, { [rootField]: select }, fakeRootField, [rootTypeName], context3);\n  return new Document(rootTypeName, children);\n}\n__name(makeDocument, \"makeDocument\");\nfunction transformDocument(document2) {\n  return document2;\n}\n__name(transformDocument, \"transformDocument\");\nfunction selectionToFields(dmmf, selection, schemaField, path7, context3) {\n  const outputType = schemaField.outputType.type;\n  return Object.entries(selection).reduce((acc, [name, value]) => {\n    const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);\n    if (!field) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: \"invalidFieldName\",\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name)\n            ),\n            outputType\n          }\n        })\n      );\n      return acc;\n    }\n    if (field.outputType.location === \"scalar\" && field.args.length === 0 && typeof value !== \"boolean\") {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: \"invalidFieldType\",\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value\n          }\n        })\n      );\n      return acc;\n    }\n    if (value === false) {\n      return acc;\n    }\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    };\n    const argsWithoutIncludeAndSelect = typeof value === \"object\" ? omit2(value, [\"include\", \"select\"]) : void 0;\n    const args = argsWithoutIncludeAndSelect ? objectToArgs(\n      argsWithoutIncludeAndSelect,\n      transformedField,\n      context3,\n      [],\n      typeof field === \"string\" ? void 0 : field.outputType.type\n    ) : void 0;\n    const isRelation = field.outputType.location === \"outputObjectTypes\";\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: \"include\",\n                args: new Args(),\n                error: {\n                  type: \"includeAndSelect\",\n                  field\n                }\n              })\n            ]\n          })\n        );\n      } else if (value.include) {\n        const keys2 = Object.keys(value.include);\n        if (keys2.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"include\",\n                  args: new Args(),\n                  error: {\n                    type: \"emptyInclude\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n        if (field.outputType.location === \"outputObjectTypes\") {\n          const fieldOutputType = field.outputType.type;\n          const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === \"outputObjectTypes\").map((f) => f.name);\n          const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) => new Field({\n                  name: invalidKey,\n                  children: [\n                    new Field({\n                      name: invalidKey,\n                      args: new Args(),\n                      error: {\n                        type: \"invalidFieldName\",\n                        modelName: fieldOutputType.name,\n                        outputType: fieldOutputType,\n                        providedName: invalidKey,\n                        didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,\n                        isInclude: true,\n                        isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)\n                      }\n                    })\n                  ]\n                })\n              )\n            );\n            return acc;\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select);\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"select\",\n                  args: new Args(),\n                  error: {\n                    type: \"emptySelect\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n        const truthyValues = values.filter((v) => v);\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"select\",\n                  args: new Args(),\n                  error: {\n                    type: \"noTrueSelect\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n      }\n    }\n    const defaultSelection = isRelation ? getDefaultSelection(dmmf, field.outputType.type) : null;\n    let select = defaultSelection;\n    if (value) {\n      if (value.select) {\n        select = value.select;\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include);\n      } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === \"prisma\" && field.outputType.location === \"outputObjectTypes\" && isGroupByOutputName(field.outputType.type.name)) {\n        select = byToSelect(value.by);\n      }\n    }\n    const children = select !== false && isRelation ? selectionToFields(dmmf, select, field, [...path7, name], context3) : void 0;\n    acc.push(new Field({ name, args, children, schemaField: field }));\n    return acc;\n  }, []);\n}\n__name(selectionToFields, \"selectionToFields\");\nfunction byToSelect(by) {\n  const obj = /* @__PURE__ */ Object.create(null);\n  for (const b of by) {\n    obj[b] = true;\n  }\n  return obj;\n}\n__name(byToSelect, \"byToSelect\");\nfunction getDefaultSelection(dmmf, outputType) {\n  const acc = /* @__PURE__ */ Object.create(null);\n  for (const f of outputType.fields) {\n    if (dmmf.typeMap[f.outputType.type.name] !== void 0) {\n      acc[f.name] = true;\n    }\n    if (f.outputType.location === \"scalar\" || f.outputType.location === \"enumTypes\") {\n      acc[f.name] = true;\n    }\n  }\n  return acc;\n}\n__name(getDefaultSelection, \"getDefaultSelection\");\nfunction getInvalidTypeArg(key, value, arg2, bestFittingType) {\n  const arrg = new Arg2({\n    key,\n    value,\n    isEnum: bestFittingType.location === \"enumTypes\",\n    inputType: bestFittingType,\n    error: {\n      type: \"invalidType\",\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg2.inputTypes,\n        bestFittingType\n      }\n    }\n  });\n  return arrg;\n}\n__name(getInvalidTypeArg, \"getInvalidTypeArg\");\nfunction hasCorrectScalarType(value, inputType, context3) {\n  const { isList } = inputType;\n  const expectedType = getExpectedType(inputType, context3);\n  const graphQLType = getGraphQLType(value, inputType);\n  if (graphQLType === expectedType) {\n    return true;\n  }\n  if (isList && graphQLType === \"List<>\") {\n    return true;\n  }\n  if (expectedType === \"Json\" && graphQLType !== \"Symbol\" && !(value instanceof ObjectEnumValue) && !(value instanceof FieldRefImpl)) {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"BigInt\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if (graphQLType === \"List<BigInt | Int>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int | BigInt>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if ((graphQLType === \"Int\" || graphQLType === \"Float\") && expectedType === \"Decimal\") {\n    return true;\n  }\n  if (isValidDecimalListInput(graphQLType, value) && expectedType === \"List<Decimal>\") {\n    return true;\n  }\n  if (graphQLType === \"DateTime\" && expectedType === \"String\") {\n    return true;\n  }\n  if (graphQLType === \"List<DateTime>\" && expectedType === \"List<String>\") {\n    return true;\n  }\n  if (graphQLType === \"UUID\" && expectedType === \"String\") {\n    return true;\n  }\n  if (graphQLType === \"List<UUID>\" && expectedType === \"List<String>\") {\n    return true;\n  }\n  if (graphQLType === \"String\" && expectedType === \"ID\") {\n    return true;\n  }\n  if (graphQLType === \"List<String>\" && expectedType === \"List<ID>\") {\n    return true;\n  }\n  if (graphQLType === \"List<String>\" && expectedType === \"List<Json>\") {\n    return true;\n  }\n  if (expectedType === \"List<String>\" && (graphQLType === \"List<String | UUID>\" || graphQLType === \"List<UUID | String>\")) {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"Float\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<Float>\") {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"Long\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<Long>\") {\n    return true;\n  }\n  if (graphQLType === \"String\" && expectedType === \"Decimal\" && isDecimalString(value)) {\n    return true;\n  }\n  if (value === null) {\n    return true;\n  }\n  return false;\n}\n__name(hasCorrectScalarType, \"hasCorrectScalarType\");\nfunction getExpectedType(inputType, context3, isList = inputType.isList) {\n  let type = stringifyGraphQLType(inputType.type);\n  if (inputType.location === \"fieldRefTypes\" && context3.modelName) {\n    type += `<${context3.modelName}>`;\n  }\n  return wrapWithList(type, isList);\n}\n__name(getExpectedType, \"getExpectedType\");\nvar cleanObject = /* @__PURE__ */ __name((obj) => filterObject(obj, (k, v) => v !== void 0), \"cleanObject\");\nfunction isValidDecimalListInput(graphQLType, value) {\n  return graphQLType === \"List<Int>\" || graphQLType === \"List<Float>\" || graphQLType === \"List<String>\" && value.every(isDecimalString);\n}\n__name(isValidDecimalListInput, \"isValidDecimalListInput\");\nfunction isDecimalString(value) {\n  return /^\\-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value);\n}\n__name(isDecimalString, \"isDecimalString\");\nfunction valueToArg(key, value, arg2, context3) {\n  let maybeArg = null;\n  const argsWithErrors = [];\n  for (const inputType of arg2.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg2, inputType, context3);\n    if ((maybeArg == null ? void 0 : maybeArg.collectErrors().length) === 0) {\n      return maybeArg;\n    }\n    if (maybeArg && (maybeArg == null ? void 0 : maybeArg.collectErrors())) {\n      const argErrors = maybeArg == null ? void 0 : maybeArg.collectErrors();\n      if (argErrors && argErrors.length > 0) {\n        argsWithErrors.push({ arg: maybeArg, errors: argErrors });\n      }\n    }\n  }\n  if ((maybeArg == null ? void 0 : maybeArg.hasError) && argsWithErrors.length > 0) {\n    const argsWithScores = argsWithErrors.map(({ arg: arg3, errors }) => {\n      const errorScores = errors.map((e) => {\n        let score = 1;\n        if (e.error.type === \"invalidType\") {\n          score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;\n        }\n        score += Math.log(e.path.length);\n        if (e.error.type === \"missingArg\") {\n          if (arg3.inputType && isInputArgType(arg3.inputType.type) && arg3.inputType.type.name.includes(\"Unchecked\")) {\n            score *= 2;\n          }\n        }\n        if (e.error.type === \"invalidName\") {\n          if (isInputArgType(e.error.originalType)) {\n            if (e.error.originalType.name.includes(\"Unchecked\")) {\n              score *= 2;\n            }\n          }\n        }\n        return score;\n      });\n      return {\n        score: errors.length + sum2(errorScores),\n        arg: arg3,\n        errors\n      };\n    });\n    argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);\n    return argsWithScores[0].arg;\n  }\n  return maybeArg;\n}\n__name(valueToArg, \"valueToArg\");\nfunction getDepth(object) {\n  let level = 1;\n  if (!object || typeof object !== \"object\") {\n    return level;\n  }\n  for (const key in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, key)) {\n      continue;\n    }\n    if (typeof object[key] === \"object\") {\n      const depth = getDepth(object[key]) + 1;\n      level = Math.max(depth, level);\n    }\n  }\n  return level;\n}\n__name(getDepth, \"getDepth\");\nfunction sum2(n) {\n  return n.reduce((acc, curr) => acc + curr, 0);\n}\n__name(sum2, \"sum\");\nfunction tryInferArgs(key, value, arg2, inputType, context3) {\n  var _a3, _b2, _c, _d;\n  if (typeof value === \"undefined\") {\n    if (!arg2.isRequired) {\n      return null;\n    }\n    return new Arg2({\n      key,\n      value,\n      isEnum: inputType.location === \"enumTypes\",\n      inputType,\n      error: {\n        type: \"missingArg\",\n        missingName: key,\n        missingArg: arg2,\n        atLeastOne: false,\n        atMostOne: false\n      }\n    });\n  }\n  const { isNullable, isRequired } = arg2;\n  if (value === null && !isNullable && !isRequired) {\n    const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;\n    if (!isAtLeastOne) {\n      return new Arg2({\n        key,\n        value,\n        isEnum: inputType.location === \"enumTypes\",\n        inputType,\n        error: {\n          type: \"invalidNullArg\",\n          name: key,\n          invalidType: arg2.inputTypes,\n          atLeastOne: false,\n          atMostOne: false\n        }\n      });\n    }\n  }\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== \"object\" || Array.isArray(value) || inputType.location === \"inputObjectTypes\" && !isObject2(value)) {\n        return getInvalidTypeArg(key, value, arg2, inputType);\n      } else {\n        const val = cleanObject(value);\n        let error2;\n        const keys2 = Object.keys(val || {});\n        const numKeys = keys2.length;\n        if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === \"number\" && inputType.type.constraints.minNumFields > 0) {\n          error2 = {\n            type: \"atLeastOne\",\n            key,\n            inputType: inputType.type\n          };\n        } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === \"number\" && inputType.type.constraints.maxNumFields < 2) {\n          error2 = {\n            type: \"atMostOne\",\n            key,\n            inputType: inputType.type,\n            providedKeys: keys2\n          };\n        }\n        return new Arg2({\n          key,\n          value: val === null ? null : objectToArgs(val, inputType.type, context3, arg2.inputTypes),\n          isEnum: inputType.location === \"enumTypes\",\n          error: error2,\n          inputType,\n          schemaArg: arg2\n        });\n      }\n    } else {\n      return scalarToArg(key, value, arg2, inputType, context3);\n    }\n  }\n  if (!Array.isArray(value) && inputType.isList) {\n    if (key !== \"updateMany\") {\n      value = [value];\n    }\n  }\n  if (inputType.location === \"enumTypes\" || inputType.location === \"scalar\") {\n    return scalarToArg(key, value, arg2, inputType, context3);\n  }\n  const argInputType = inputType.type;\n  const hasAtLeastOneError = typeof ((_a3 = argInputType.constraints) == null ? void 0 : _a3.minNumFields) === \"number\" && ((_b2 = argInputType.constraints) == null ? void 0 : _b2.minNumFields) > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;\n  let err = hasAtLeastOneError ? {\n    inputType: argInputType,\n    key,\n    type: \"atLeastOne\"\n  } : void 0;\n  if (!err) {\n    const hasOneOfError = typeof ((_c = argInputType.constraints) == null ? void 0 : _c.maxNumFields) === \"number\" && ((_d = argInputType.constraints) == null ? void 0 : _d.maxNumFields) < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: \"atMostOne\",\n        providedKeys: Object.keys(hasOneOfError)\n      };\n    }\n  }\n  if (!Array.isArray(value)) {\n    for (const nestedArgInputType of arg2.inputTypes) {\n      const args = objectToArgs(value, nestedArgInputType.type, context3);\n      if (args.collectErrors().length === 0) {\n        return new Arg2({\n          key,\n          value: args,\n          isEnum: false,\n          schemaArg: arg2,\n          inputType: nestedArgInputType\n        });\n      }\n    }\n  }\n  return new Arg2({\n    key,\n    value: value.map((v) => {\n      if (inputType.isList && typeof v !== \"object\") {\n        return v;\n      }\n      if (typeof v !== \"object\" || !value) {\n        return getInvalidTypeArg(key, v, arg2, inputType);\n      }\n      return objectToArgs(v, argInputType, context3);\n    }),\n    isEnum: false,\n    inputType,\n    schemaArg: arg2,\n    error: err\n  });\n}\n__name(tryInferArgs, \"tryInferArgs\");\nfunction isInputArgType(argType) {\n  if (typeof argType === \"string\") {\n    return false;\n  }\n  if (Object.hasOwnProperty.call(argType, \"values\")) {\n    return false;\n  }\n  return true;\n}\n__name(isInputArgType, \"isInputArgType\");\nfunction scalarToArg(key, value, arg2, inputType, context3) {\n  if (hasCorrectScalarType(value, inputType, context3)) {\n    return new Arg2({\n      key,\n      value,\n      isEnum: inputType.location === \"enumTypes\",\n      schemaArg: arg2,\n      inputType\n    });\n  }\n  return getInvalidTypeArg(key, value, arg2, inputType);\n}\n__name(scalarToArg, \"scalarToArg\");\nfunction objectToArgs(initialObj, inputType, context3, possibilities, outputType) {\n  var _a3;\n  if ((_a3 = inputType.meta) == null ? void 0 : _a3.source) {\n    context3 = { modelName: inputType.meta.source };\n  }\n  const obj = cleanObject(initialObj);\n  const { fields: args, fieldMap } = inputType;\n  const requiredArgs = args.map((arg2) => [arg2.name, void 0]);\n  const objEntries = Object.entries(obj || {});\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0]);\n  const argsList = entries.reduce((acc, [argName, value]) => {\n    const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);\n    if (!schemaArg) {\n      const didYouMeanField = typeof value === \"boolean\" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;\n      acc.push(\n        new Arg2({\n          key: argName,\n          value,\n          error: {\n            type: \"invalidName\",\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg: !didYouMeanField && getSuggestion(argName, [...args.map((a) => a.name), \"select\"]) || void 0,\n            originalType: inputType,\n            possibilities,\n            outputType\n          }\n        })\n      );\n      return acc;\n    }\n    const arg2 = valueToArg(argName, value, schemaArg, context3);\n    if (arg2) {\n      acc.push(arg2);\n    }\n    return acc;\n  }, []);\n  if (typeof inputType.constraints.minNumFields === \"number\" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg2) => {\n    var _a4, _b2;\n    return ((_a4 = arg2.error) == null ? void 0 : _a4.type) === \"missingArg\" || ((_b2 = arg2.error) == null ? void 0 : _b2.type) === \"atLeastOne\";\n  })) {\n    const optionalMissingArgs = inputType.fields.filter(\n      (field) => !field.isRequired && obj && (typeof obj[field.name] === \"undefined\" || obj[field.name] === null)\n    );\n    argsList.push(\n      ...optionalMissingArgs.map((arg2) => {\n        const argInputType = arg2.inputTypes[0];\n        return new Arg2({\n          key: arg2.name,\n          value: void 0,\n          isEnum: argInputType.location === \"enumTypes\",\n          error: {\n            type: \"missingArg\",\n            missingName: arg2.name,\n            missingArg: arg2,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false\n          },\n          inputType: argInputType\n        });\n      })\n    );\n  }\n  return new Args(argsList);\n}\n__name(objectToArgs, \"objectToArgs\");\nfunction unpack({ document: document2, path: path7, data }) {\n  const result = deepGet(data, path7);\n  if (result === \"undefined\") {\n    return null;\n  }\n  if (typeof result !== \"object\") {\n    return result;\n  }\n  const field = getField(document2, path7);\n  return mapScalars({ field, data: result });\n}\n__name(unpack, \"unpack\");\nfunction mapScalars({ field, data }) {\n  var _a3;\n  if (!data || typeof data !== \"object\" || !field.children || !field.schemaField) {\n    return data;\n  }\n  const deserializers = {\n    DateTime: (value) => new Date(value),\n    Json: (value) => JSON.parse(value),\n    Bytes: (value) => Buffer.from(value, \"base64\"),\n    Decimal: (value) => {\n      return new decimal_default(value);\n    },\n    BigInt: (value) => BigInt(value)\n  };\n  for (const child of field.children) {\n    const outputType = (_a3 = child.schemaField) == null ? void 0 : _a3.outputType.type;\n    if (outputType && typeof outputType === \"string\") {\n      const deserializer = deserializers[outputType];\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            if (typeof entry[child.name] !== \"undefined\" && entry[child.name] !== null) {\n              if (Array.isArray(entry[child.name])) {\n                entry[child.name] = entry[child.name].map(deserializer);\n              } else {\n                entry[child.name] = deserializer(entry[child.name]);\n              }\n            }\n          }\n        } else {\n          if (typeof data[child.name] !== \"undefined\" && data[child.name] !== null) {\n            if (Array.isArray(data[child.name])) {\n              data[child.name] = data[child.name].map(deserializer);\n            } else {\n              data[child.name] = deserializer(data[child.name]);\n            }\n          }\n        }\n      }\n    }\n    if (child.schemaField && child.schemaField.outputType.location === \"outputObjectTypes\") {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] });\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] });\n      }\n    }\n  }\n  return data;\n}\n__name(mapScalars, \"mapScalars\");\nfunction getField(document2, path7) {\n  const todo = path7.slice();\n  const firstElement = todo.shift();\n  let pointer = document2.children.find((c) => c.name === firstElement);\n  if (!pointer) {\n    throw new Error(`Could not find field ${firstElement} in document ${document2}`);\n  }\n  while (todo.length > 0) {\n    const key = todo.shift();\n    if (!pointer.children) {\n      throw new Error(`Can't get children for field ${pointer} with child ${key}`);\n    }\n    const child = pointer.children.find((c) => c.name === key);\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`);\n    }\n    pointer = child;\n  }\n  return pointer;\n}\n__name(getField, \"getField\");\nfunction removeSelectFromPath(path7) {\n  return path7.split(\".\").filter((p) => p !== \"select\").join(\".\");\n}\n__name(removeSelectFromPath, \"removeSelectFromPath\");\nfunction removeSelectFromObject(obj) {\n  const type = Object.prototype.toString.call(obj);\n  if (type === \"[object Object]\") {\n    const copy = {};\n    for (const key in obj) {\n      if (key === \"select\") {\n        for (const subKey in obj[\"select\"]) {\n          copy[subKey] = removeSelectFromObject(obj[\"select\"][subKey]);\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key]);\n      }\n    }\n    return copy;\n  }\n  return obj;\n}\n__name(removeSelectFromObject, \"removeSelectFromObject\");\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths\n}) {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath);\n  const newValuePaths = valuePaths.map(removeSelectFromPath);\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type\n  }));\n  const newAst = removeSelectFromObject(ast);\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths\n  };\n}\n__name(transformAggregatePrintJsonArgs, \"transformAggregatePrintJsonArgs\");\n\n// src/runtime/utils/rejectOnNotFound.ts\nvar NotFoundError2 = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n};\n__name(NotFoundError2, \"NotFoundError\");\nfunction getRejectOnNotFound(action, modelName, args, clientInstance) {\n  let rejectOnNotFound;\n  if (args && typeof args === \"object\" && \"rejectOnNotFound\" in args && args[\"rejectOnNotFound\"] !== void 0) {\n    rejectOnNotFound = args[\"rejectOnNotFound\"];\n    delete args[\"rejectOnNotFound\"];\n  } else if (typeof clientInstance === \"boolean\") {\n    rejectOnNotFound = clientInstance;\n  } else if (clientInstance && typeof clientInstance === \"object\" && action in clientInstance) {\n    const rejectPerOperation = clientInstance[action];\n    if (rejectPerOperation && typeof rejectPerOperation === \"object\") {\n      if (modelName in rejectPerOperation) {\n        return rejectPerOperation[modelName];\n      }\n      return void 0;\n    }\n    rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);\n  } else if (typeof clientInstance === \"function\") {\n    rejectOnNotFound = clientInstance;\n  } else {\n    rejectOnNotFound = false;\n  }\n  return rejectOnNotFound;\n}\n__name(getRejectOnNotFound, \"getRejectOnNotFound\");\nvar REGEX = /(findUnique|findFirst)/;\nfunction throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {\n  if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {\n    if (typeof rejectOnNotFound === \"boolean\" && rejectOnNotFound) {\n      throw new NotFoundError2(`No ${typeName} found`);\n    } else if (typeof rejectOnNotFound === \"function\") {\n      throw rejectOnNotFound(new NotFoundError2(`No ${typeName} found`));\n    } else if (isError(rejectOnNotFound)) {\n      throw rejectOnNotFound;\n    }\n    throw new NotFoundError2(`No ${typeName} found`);\n  }\n}\n__name(throwIfNotFound, \"throwIfNotFound\");\n\n// src/runtime/core/model/applyClientOnlyWrapper.ts\nfunction wrapRequest(prop, dmmfModelName, requestCallback) {\n  if (prop === \"findFirstOrThrow\" || prop === \"findUniqueOrThrow\") {\n    return applyOrThrowWrapper(dmmfModelName, requestCallback);\n  }\n  assertNever(prop, \"Unknown wrapper name\");\n}\n__name(wrapRequest, \"wrapRequest\");\nfunction applyOrThrowWrapper(dmmfModelName, requestCallback) {\n  return async (requestParams) => {\n    if (\"rejectOnNotFound\" in requestParams.args) {\n      const message = createErrorMessageWithContext({\n        originalMethod: requestParams.clientMethod,\n        callsite: requestParams.callsite,\n        message: \"'rejectOnNotFound' option is not supported\"\n      });\n      throw new PrismaClientValidationError(message);\n    }\n    const result = await requestCallback(requestParams);\n    if (result === null || result === void 0) {\n      throw new NotFoundError2(`No ${dmmfModelName} found`);\n    }\n    return result;\n  };\n}\n__name(applyOrThrowWrapper, \"applyOrThrowWrapper\");\n\n// src/runtime/core/model/utils/defaultProxyHandlers.ts\nvar defaultPropertyDescriptor = {\n  enumerable: true,\n  configurable: true,\n  writable: true\n};\nfunction defaultProxyHandlers(ownKeys) {\n  const _ownKeys = new Set(ownKeys);\n  return {\n    getOwnPropertyDescriptor: () => defaultPropertyDescriptor,\n    has: (target, prop) => _ownKeys.has(prop),\n    set: (target, prop, value) => {\n      return _ownKeys.add(prop) && Reflect.set(target, prop, value);\n    },\n    ownKeys: () => [..._ownKeys]\n  };\n}\n__name(defaultProxyHandlers, \"defaultProxyHandlers\");\n\n// src/runtime/core/model/applyFieldsProxy.ts\nfunction applyFieldsProxy(model) {\n  const scalarFieldsList = model.fields.filter((field) => !field.relationName);\n  const scalarFields = keyBy2(scalarFieldsList, (field) => field.name);\n  return new Proxy(\n    {},\n    {\n      get(target, prop) {\n        if (prop in target || typeof prop === \"symbol\") {\n          return target[prop];\n        }\n        const dmmfField = scalarFields[prop];\n        if (dmmfField) {\n          return new FieldRefImpl(model.name, prop, dmmfField.type, dmmfField.isList);\n        }\n        return void 0;\n      },\n      ...defaultProxyHandlers(Object.keys(scalarFields))\n    }\n  );\n}\n__name(applyFieldsProxy, \"applyFieldsProxy\");\n\n// src/runtime/core/model/applyFluent.ts\nfunction getNextDataPath(fluentPropName, prevDataPath) {\n  if (fluentPropName === void 0 || prevDataPath === void 0)\n    return [];\n  return [...prevDataPath, \"select\", fluentPropName];\n}\n__name(getNextDataPath, \"getNextDataPath\");\nfunction getNextUserArgs(callArgs, prevArgs, nextDataPath) {\n  if (prevArgs === void 0)\n    return callArgs != null ? callArgs : {};\n  return deepSet(prevArgs, nextDataPath, callArgs || true);\n}\n__name(getNextUserArgs, \"getNextUserArgs\");\nfunction applyFluent(client, dmmfModelName, modelAction, fluentPropName, prevDataPath, prevUserArgs) {\n  const dmmfModel = client._baseDmmf.modelMap[dmmfModelName];\n  const dmmfModelFieldMap = dmmfModel.fields.reduce(\n    (acc, field) => ({ ...acc, [field.name]: field }),\n    {}\n  );\n  return (userArgs) => {\n    const callsite = getCallSite(client._errorFormat);\n    const nextDataPath = getNextDataPath(fluentPropName, prevDataPath);\n    const nextUserArgs = getNextUserArgs(userArgs, prevUserArgs, nextDataPath);\n    const prismaPromise = modelAction({ dataPath: nextDataPath, callsite })(nextUserArgs);\n    const ownKeys = getOwnKeys(client, dmmfModelName);\n    return new Proxy(prismaPromise, {\n      get(target, prop) {\n        if (!ownKeys.includes(prop))\n          return target[prop];\n        const dmmfModelName2 = dmmfModelFieldMap[prop].type;\n        const modelArgs = [dmmfModelName2, modelAction, prop];\n        const dataArgs = [nextDataPath, nextUserArgs];\n        return applyFluent(client, ...modelArgs, ...dataArgs);\n      },\n      ...defaultProxyHandlers([...ownKeys, ...Object.getOwnPropertyNames(prismaPromise)])\n    });\n  };\n}\n__name(applyFluent, \"applyFluent\");\nfunction getOwnKeys(client, dmmfModelName) {\n  return client._baseDmmf.modelMap[dmmfModelName].fields.filter((field) => field.kind === \"object\").map((field) => field.name);\n}\n__name(getOwnKeys, \"getOwnKeys\");\n\n// src/runtime/core/model/utils/dmmfToJSModelName.ts\nfunction dmmfToJSModelName(name) {\n  return name.replace(/^./, (str) => str.toLowerCase());\n}\n__name(dmmfToJSModelName, \"dmmfToJSModelName\");\n\n// src/runtime/core/model/applyModel.ts\nvar fluentProps = [\"findUnique\", \"findFirst\", \"create\", \"update\", \"upsert\", \"delete\"];\nvar aggregateProps = [\"aggregate\", \"count\", \"groupBy\"];\nfunction applyModel(client, dmmfModelName) {\n  var _a3;\n  const jsModelName = dmmfToJSModelName(dmmfModelName);\n  const model = client._baseDmmf.modelMap[dmmfModelName];\n  const fieldsProxyEnabled = (_a3 = client._engineConfig.previewFeatures) == null ? void 0 : _a3.includes(\"fieldReference\");\n  const ownKeys = getOwnKeys2(client, dmmfModelName);\n  const baseObject = {};\n  let fieldsProxy;\n  return new Proxy(baseObject, {\n    get(target, prop) {\n      if (prop in target || typeof prop === \"symbol\")\n        return target[prop];\n      if (prop === \"fields\" && fieldsProxyEnabled) {\n        return fieldsProxy != null ? fieldsProxy : fieldsProxy = applyFieldsProxy(model);\n      }\n      if (!isValidActionName(client, dmmfModelName, prop))\n        return void 0;\n      const dmmfActionName = getDmmfActionName(prop);\n      let requestFn = /* @__PURE__ */ __name((params) => client._request(params), \"requestFn\");\n      if (isClientOnlyAction(prop)) {\n        requestFn = wrapRequest(prop, dmmfModelName, requestFn);\n      }\n      const action = /* @__PURE__ */ __name((paramOverrides) => (userArgs) => {\n        const callSite = getCallSite(client._errorFormat);\n        return createPrismaPromise((txId, lock) => {\n          const data = { args: userArgs, dataPath: [] };\n          const action2 = { action: dmmfActionName, model: dmmfModelName };\n          const method = { clientMethod: `${jsModelName}.${prop}`, jsModelName };\n          const tx = { runInTransaction: !!txId, transactionId: txId, lock };\n          const trace2 = { callsite: callSite };\n          const params = { ...data, ...action2, ...method, ...tx, ...trace2 };\n          return requestFn({ ...params, ...paramOverrides });\n        });\n      }, \"action\");\n      if (fluentProps.includes(dmmfActionName)) {\n        return applyFluent(client, dmmfModelName, action);\n      }\n      if (isValidAggregateName(prop)) {\n        return applyAggregates(client, prop, action);\n      }\n      return action({});\n    },\n    ...defaultProxyHandlers(ownKeys)\n  });\n}\n__name(applyModel, \"applyModel\");\nfunction getOwnKeys2(client, dmmfModelName) {\n  return [...Object.keys(client._baseDmmf.mappingsMap[dmmfModelName]), \"count\"].filter(\n    (key) => ![\"model\", \"plural\"].includes(key)\n  );\n}\n__name(getOwnKeys2, \"getOwnKeys\");\nfunction isValidActionName(client, dmmfModelName, action) {\n  if (isClientOnlyAction(action)) {\n    return isValidActionName(client, dmmfModelName, clientOnlyActions[action].wrappedAction);\n  }\n  return getOwnKeys2(client, dmmfModelName).includes(action);\n}\n__name(isValidActionName, \"isValidActionName\");\nfunction isValidAggregateName(action) {\n  return aggregateProps.includes(action);\n}\n__name(isValidAggregateName, \"isValidAggregateName\");\n\n// src/runtime/core/model/utils/jsToDMMFModelName.ts\nfunction jsToDMMFModelName(name) {\n  return name.replace(/^./, (str) => str.toUpperCase());\n}\n__name(jsToDMMFModelName, \"jsToDMMFModelName\");\n\n// src/runtime/core/model/applyModels.ts\nfunction applyModels(client) {\n  const modelCache = {};\n  const ownKeys = getOwnKeys3(client);\n  return new Proxy(client, {\n    get(target, prop) {\n      if (prop in target || typeof prop === \"symbol\")\n        return target[prop];\n      const dmmfModelName = jsToDMMFModelName(prop);\n      if (modelCache[dmmfModelName] !== void 0) {\n        return modelCache[dmmfModelName];\n      }\n      if (client._baseDmmf.modelMap[dmmfModelName] !== void 0) {\n        return modelCache[dmmfModelName] = applyModel(client, dmmfModelName);\n      }\n      if (client._baseDmmf.modelMap[prop] !== void 0) {\n        return modelCache[dmmfModelName] = applyModel(client, prop);\n      }\n    },\n    ...defaultProxyHandlers(ownKeys)\n  });\n}\n__name(applyModels, \"applyModels\");\nfunction getOwnKeys3(client) {\n  return [...Object.keys(client._baseDmmf.modelMap).map(dmmfToJSModelName), ...Object.keys(client)];\n}\n__name(getOwnKeys3, \"getOwnKeys\");\n\n// src/runtime/core/transaction/utils/createLockCountPromise.ts\nfunction getLockCountPromise(knock, cb = () => {\n}) {\n  let resolve;\n  const lock = new Promise((res) => resolve = res);\n  return {\n    then(onFulfilled) {\n      if (--knock === 0)\n        resolve(cb());\n      return onFulfilled == null ? void 0 : onFulfilled(lock);\n    }\n  };\n}\n__name(getLockCountPromise, \"getLockCountPromise\");\n\n// src/runtime/getLogLevel.ts\nfunction getLogLevel(log4) {\n  if (typeof log4 === \"string\") {\n    return log4;\n  }\n  return log4.reduce((acc, curr) => {\n    const currentLevel = typeof curr === \"string\" ? curr : curr.level;\n    if (currentLevel === \"query\") {\n      return acc;\n    }\n    if (!acc) {\n      return currentLevel;\n    }\n    if (curr === \"info\" || acc === \"info\") {\n      return \"info\";\n    }\n    return currentLevel;\n  }, void 0);\n}\n__name(getLogLevel, \"getLogLevel\");\n\n// src/runtime/mergeBy.ts\nfunction mergeBy(arr1, arr2, cb) {\n  const groupedArr1 = groupBy2(arr1, cb);\n  const groupedArr2 = groupBy2(arr2, cb);\n  const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);\n  const arr2Keys = Object.keys(groupedArr2);\n  Object.entries(groupedArr1).forEach(([key, value]) => {\n    if (!arr2Keys.includes(key)) {\n      result.push(value[value.length - 1]);\n    }\n  });\n  return result;\n}\n__name(mergeBy, \"mergeBy\");\nvar groupBy2 = /* @__PURE__ */ __name((arr, cb) => {\n  return arr.reduce((acc, curr) => {\n    const key = cb(curr);\n    if (!acc[key]) {\n      acc[key] = [];\n    }\n    acc[key].push(curr);\n    return acc;\n  }, {});\n}, \"groupBy\");\n\n// src/runtime/MiddlewareHandler.ts\nvar MiddlewareHandler = class {\n  constructor() {\n    this._middlewares = [];\n  }\n  use(middleware) {\n    this._middlewares.push(middleware);\n  }\n  get(id) {\n    return this._middlewares[id];\n  }\n  has(id) {\n    return !!this._middlewares[id];\n  }\n  length() {\n    return this._middlewares.length;\n  }\n};\n__name(MiddlewareHandler, \"MiddlewareHandler\");\nvar Middlewares = class {\n  constructor() {\n    this.query = new MiddlewareHandler();\n    this.engine = new MiddlewareHandler();\n  }\n};\n__name(Middlewares, \"Middlewares\");\n\n// src/runtime/RequestHandler.ts\nvar import_strip_ansi4 = __toESM(require_strip_ansi());\n\n// src/runtime/DataLoader.ts\nvar DataLoader = class {\n  constructor(options) {\n    this.options = options;\n    this.tickActive = false;\n    this.batches = {};\n  }\n  request(request2) {\n    const hash = this.options.batchBy(request2);\n    if (!hash) {\n      return this.options.singleLoader(request2);\n    }\n    if (!this.batches[hash]) {\n      this.batches[hash] = [];\n      if (!this.tickActive) {\n        this.tickActive = true;\n        process.nextTick(() => {\n          this.dispatchBatches();\n          this.tickActive = false;\n        });\n      }\n    }\n    return new Promise((resolve, reject) => {\n      this.batches[hash].push({\n        request: request2,\n        resolve,\n        reject\n      });\n    });\n  }\n  dispatchBatches() {\n    for (const key in this.batches) {\n      const batch = this.batches[key];\n      delete this.batches[key];\n      if (batch.length === 1) {\n        this.options.singleLoader(batch[0].request).then((result) => {\n          if (result instanceof Error) {\n            batch[0].reject(result);\n          } else {\n            batch[0].resolve(result);\n          }\n        }).catch((e) => {\n          batch[0].reject(e);\n        });\n      } else {\n        this.options.batchLoader(batch.map((j) => j.request)).then((results) => {\n          if (results instanceof Error) {\n            for (let i = 0; i < batch.length; i++) {\n              batch[i].reject(results);\n            }\n          } else {\n            for (let i = 0; i < batch.length; i++) {\n              const value = results[i];\n              if (value instanceof Error) {\n                batch[i].reject(value);\n              } else {\n                batch[i].resolve(value);\n              }\n            }\n          }\n        }).catch((e) => {\n          for (let i = 0; i < batch.length; i++) {\n            batch[i].reject(e);\n          }\n        });\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"DataLoader\";\n  }\n};\n__name(DataLoader, \"DataLoader\");\n\n// src/runtime/RequestHandler.ts\nvar debug11 = src_default(\"prisma:client:request_handler\");\nfunction getRequestInfo(request2) {\n  var _a3;\n  const txId = request2.transactionId;\n  const inTx = request2.runInTransaction;\n  const headers = (_a3 = request2.headers) != null ? _a3 : {};\n  const traceparent = getTraceParent({ tracingConfig: request2.tracingConfig });\n  const _inTx = typeof txId === \"number\" && inTx ? true : void 0;\n  const _txId = typeof txId === \"string\" && inTx ? txId : void 0;\n  if (_txId !== void 0)\n    headers.transactionId = _txId;\n  if (traceparent !== void 0)\n    headers.traceparent = traceparent;\n  return { inTx: _inTx, headers };\n}\n__name(getRequestInfo, \"getRequestInfo\");\nvar RequestHandler = class {\n  constructor(client, hooks) {\n    this.client = client;\n    this.hooks = hooks;\n    this.dataloader = new DataLoader({\n      batchLoader: (requests) => {\n        const info2 = getRequestInfo(requests[0]);\n        const queries = requests.map((r) => String(r.document));\n        const traceparent = getTraceParent({ context: requests[0].otelParentCtx, tracingConfig: client._tracingConfig });\n        if (traceparent)\n          info2.headers.traceparent = traceparent;\n        return this.client._engine.requestBatch(queries, info2.headers, info2.inTx);\n      },\n      singleLoader: (request2) => {\n        const info2 = getRequestInfo(request2);\n        const query2 = String(request2.document);\n        return this.client._engine.request(query2, info2.headers);\n      },\n      batchBy: (request2) => {\n        if (request2.transactionId) {\n          return `transaction-${request2.transactionId}`;\n        }\n        return batchFindUniqueBy(request2);\n      }\n    });\n  }\n  async request({\n    document: document2,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    rejectOnNotFound,\n    clientMethod,\n    runInTransaction,\n    engineHook,\n    args,\n    headers,\n    transactionId,\n    unpacker,\n    otelParentCtx,\n    otelChildCtx\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query2 = String(document2);\n      this.hooks.beforeRequest({\n        query: query2,\n        path: dataPath,\n        rootField,\n        typeName,\n        document: document2,\n        isList,\n        clientMethod,\n        args\n      });\n    }\n    try {\n      let data, elapsed;\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document: document2,\n            runInTransaction\n          },\n          (params) => this.dataloader.request({ ...params, tracingConfig: this.client._tracingConfig })\n        );\n        data = result.data;\n        elapsed = result.elapsed;\n      } else {\n        const result = await this.dataloader.request({\n          document: document2,\n          runInTransaction,\n          headers,\n          transactionId,\n          otelParentCtx,\n          otelChildCtx,\n          tracingConfig: this.client._tracingConfig\n        });\n        data = result == null ? void 0 : result.data;\n        elapsed = result == null ? void 0 : result.elapsed;\n      }\n      const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);\n      throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed };\n      }\n      return unpackResult;\n    } catch (error2) {\n      this.handleRequestError({ error: error2, clientMethod, callsite });\n    }\n  }\n  handleRequestError({ error: error2, clientMethod, callsite }) {\n    debug11(error2);\n    let message = error2.message;\n    if (callsite) {\n      message = createErrorMessageWithContext({\n        callsite,\n        originalMethod: clientMethod,\n        isPanic: error2.isPanic,\n        showColors: this.client._errorFormat === \"pretty\",\n        message\n      });\n    }\n    message = this.sanitizeMessage(message);\n    if (error2.code) {\n      throw new PrismaClientKnownRequestError(message, error2.code, this.client._clientVersion, error2.meta);\n    } else if (error2.isPanic) {\n      throw new PrismaClientRustPanicError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientUnknownRequestError) {\n      throw new PrismaClientUnknownRequestError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientInitializationError) {\n      throw new PrismaClientInitializationError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientRustPanicError) {\n      throw new PrismaClientRustPanicError(message, this.client._clientVersion);\n    }\n    error2.clientVersion = this.client._clientVersion;\n    throw error2;\n  }\n  sanitizeMessage(message) {\n    if (this.client._errorFormat && this.client._errorFormat !== \"pretty\") {\n      return (0, import_strip_ansi4.default)(message);\n    }\n    return message;\n  }\n  unpack(document2, data, path7, rootField, unpacker) {\n    if (data == null ? void 0 : data.data) {\n      data = data.data;\n    }\n    if (unpacker) {\n      data[rootField] = unpacker(data[rootField]);\n    }\n    const getPath = [];\n    if (rootField) {\n      getPath.push(rootField);\n    }\n    getPath.push(...path7.filter((p) => p !== \"select\" && p !== \"include\"));\n    return unpack({ document: document2, data, path: getPath });\n  }\n  get [Symbol.toStringTag]() {\n    return \"RequestHandler\";\n  }\n};\n__name(RequestHandler, \"RequestHandler\");\nfunction batchFindUniqueBy(request2) {\n  var _a3;\n  if (!request2.document.children[0].name.startsWith(\"findUnique\")) {\n    return void 0;\n  }\n  const args = (_a3 = request2.document.children[0].args) == null ? void 0 : _a3.args.map((a) => {\n    if (a.value instanceof Args) {\n      return `${a.key}-${a.value.args.map((a2) => a2.key).join(\",\")}`;\n    }\n    return a.key;\n  }).join(\",\");\n  const selectionSet = request2.document.children[0].children.join(\",\");\n  return `${request2.document.children[0].name}|${args}|${selectionSet}`;\n}\n__name(batchFindUniqueBy, \"batchFindUniqueBy\");\n\n// src/runtime/utils/clientVersion.ts\nvar clientVersion = require_package2().version;\n\n// src/runtime/utils/deserializeRawResults.ts\nfunction deserializeRawResults(rows) {\n  return rows.map((row) => {\n    const mappedRow = {};\n    for (const key of Object.keys(row)) {\n      mappedRow[key] = deserializeValue(row[key]);\n    }\n    return mappedRow;\n  });\n}\n__name(deserializeRawResults, \"deserializeRawResults\");\nfunction deserializeValue({ prisma__type: type, prisma__value: value }) {\n  switch (type) {\n    case \"bigint\":\n      return BigInt(value);\n    case \"bytes\":\n      return Buffer.from(value, \"base64\");\n    case \"decimal\":\n      return new decimal_default(value);\n    case \"datetime\":\n    case \"date\":\n      return new Date(value);\n    case \"time\":\n      return new Date(`1970-01-01T${value}Z`);\n    case \"array\":\n      return value.map(deserializeValue);\n    default:\n      return value;\n  }\n}\n__name(deserializeValue, \"deserializeValue\");\n\n// src/runtime/utils/mssqlPreparedStatement.ts\nvar mssqlPreparedStatement = /* @__PURE__ */ __name((template) => {\n  return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);\n}, \"mssqlPreparedStatement\");\n\n// src/runtime/utils/serializeRawParameters.ts\nfunction serializeRawParameters(parameters) {\n  try {\n    return serializeRawParametersInternal(parameters, \"fast\");\n  } catch (error2) {\n    return serializeRawParametersInternal(parameters, \"slow\");\n  }\n}\n__name(serializeRawParameters, \"serializeRawParameters\");\nfunction serializeRawParametersInternal(parameters, objectSerialization) {\n  return JSON.stringify(parameters.map((parameter) => encodeParameter(parameter, objectSerialization)));\n}\n__name(serializeRawParametersInternal, \"serializeRawParametersInternal\");\nfunction encodeParameter(parameter, objectSerialization) {\n  if (typeof parameter === \"bigint\") {\n    return {\n      prisma__type: \"bigint\",\n      prisma__value: parameter.toString()\n    };\n  }\n  if (isDate(parameter)) {\n    return {\n      prisma__type: \"date\",\n      prisma__value: parameter.toJSON()\n    };\n  }\n  if (decimal_default.isDecimal(parameter)) {\n    return {\n      prisma__type: \"decimal\",\n      prisma__value: parameter.toJSON()\n    };\n  }\n  if (Buffer.isBuffer(parameter)) {\n    return {\n      prisma__type: \"bytes\",\n      prisma__value: parameter.toString(\"base64\")\n    };\n  }\n  if (isArrayBufferLike(parameter) || ArrayBuffer.isView(parameter)) {\n    return {\n      prisma__type: \"bytes\",\n      prisma__value: Buffer.from(parameter).toString(\"base64\")\n    };\n  }\n  if (typeof parameter === \"object\" && objectSerialization === \"slow\") {\n    return preprocessObject(parameter);\n  }\n  return parameter;\n}\n__name(encodeParameter, \"encodeParameter\");\nfunction isDate(value) {\n  if (value instanceof Date) {\n    return true;\n  }\n  return Object.prototype.toString.call(value) === \"[object Date]\" && typeof value.toJSON === \"function\";\n}\n__name(isDate, \"isDate\");\nfunction isArrayBufferLike(value) {\n  if (value instanceof ArrayBuffer || value instanceof SharedArrayBuffer) {\n    return true;\n  }\n  if (typeof value === \"object\" && value !== null) {\n    return value[Symbol.toStringTag] === \"ArrayBuffer\" || value[Symbol.toStringTag] === \"SharedArrayBuffer\";\n  }\n  return false;\n}\n__name(isArrayBufferLike, \"isArrayBufferLike\");\nfunction preprocessObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  if (typeof obj.toJSON === \"function\") {\n    return obj.toJSON();\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(preprocessValueInObject);\n  }\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = preprocessValueInObject(obj[key]);\n  }\n  return result;\n}\n__name(preprocessObject, \"preprocessObject\");\nfunction preprocessValueInObject(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return preprocessObject(value);\n}\n__name(preprocessValueInObject, \"preprocessValueInObject\");\n\n// src/runtime/utils/validatePrismaClientOptions.ts\nvar import_js_levenshtein2 = __toESM(require_js_levenshtein());\nvar knownProperties = [\"datasources\", \"errorFormat\", \"log\", \"__internal\", \"rejectOnNotFound\"];\nvar errorFormats = [\"pretty\", \"colorless\", \"minimal\"];\nvar logLevels = [\"info\", \"query\", \"warn\", \"error\"];\nvar validators = {\n  datasources: (options, datasourceNames) => {\n    if (!options) {\n      return;\n    }\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"datasources\" provided to PrismaClient constructor`\n      );\n    }\n    for (const [key, value] of Object.entries(options)) {\n      if (!datasourceNames.includes(key)) {\n        const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(\", \")}`;\n        throw new PrismaClientConstructorValidationError(\n          `Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`\n        );\n      }\n      if (typeof value !== \"object\" || Array.isArray(value)) {\n        throw new PrismaClientConstructorValidationError(\n          `Invalid value ${JSON.stringify(options)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n        );\n      }\n      if (value && typeof value === \"object\") {\n        for (const [key1, value1] of Object.entries(value)) {\n          if (key1 !== \"url\") {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(options)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n            );\n          }\n          if (typeof value1 !== \"string\") {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(value1)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n            );\n          }\n        }\n      }\n    }\n  },\n  errorFormat: (options) => {\n    if (!options) {\n      return;\n    }\n    if (typeof options !== \"string\") {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"errorFormat\" provided to PrismaClient constructor.`\n      );\n    }\n    if (!errorFormats.includes(options)) {\n      const didYouMean = getDidYouMean(options, errorFormats);\n      throw new PrismaClientConstructorValidationError(\n        `Invalid errorFormat ${options} provided to PrismaClient constructor.${didYouMean}`\n      );\n    }\n  },\n  log: (options) => {\n    if (!options) {\n      return;\n    }\n    if (!Array.isArray(options)) {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"log\" provided to PrismaClient constructor.`\n      );\n    }\n    function validateLogLevel(level) {\n      if (typeof level === \"string\") {\n        if (!logLevels.includes(level)) {\n          const didYouMean = getDidYouMean(level, logLevels);\n          throw new PrismaClientConstructorValidationError(\n            `Invalid log level \"${level}\" provided to PrismaClient constructor.${didYouMean}`\n          );\n        }\n      }\n    }\n    __name(validateLogLevel, \"validateLogLevel\");\n    for (const option of options) {\n      validateLogLevel(option);\n      const logValidators = {\n        level: validateLogLevel,\n        emit: (value) => {\n          const emits = [\"stdout\", \"event\"];\n          if (!emits.includes(value)) {\n            const didYouMean = getDidYouMean(value, emits);\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(\n                value\n              )} for \"emit\" in logLevel provided to PrismaClient constructor.${didYouMean}`\n            );\n          }\n        }\n      };\n      if (option && typeof option === \"object\") {\n        for (const [key, value] of Object.entries(option)) {\n          if (logValidators[key]) {\n            logValidators[key](value);\n          } else {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid property ${key} for \"log\" provided to PrismaClient constructor`\n            );\n          }\n        }\n      }\n    }\n  },\n  __internal: (value) => {\n    if (!value) {\n      return;\n    }\n    const knownKeys = [\"debug\", \"hooks\", \"engine\", \"measurePerformance\"];\n    if (typeof value !== \"object\") {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(value)} for \"__internal\" to PrismaClient constructor`\n      );\n    }\n    for (const [key] of Object.entries(value)) {\n      if (!knownKeys.includes(key)) {\n        const didYouMean = getDidYouMean(key, knownKeys);\n        throw new PrismaClientConstructorValidationError(\n          `Invalid property ${JSON.stringify(key)} for \"__internal\" provided to PrismaClient constructor.${didYouMean}`\n        );\n      }\n    }\n  },\n  rejectOnNotFound: (value) => {\n    if (!value) {\n      return;\n    }\n    if (isError(value) || typeof value === \"boolean\" || typeof value === \"object\" || typeof value === \"function\") {\n      return value;\n    }\n    throw new PrismaClientConstructorValidationError(\n      `Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(\n        value\n      )}`\n    );\n  }\n};\nfunction validatePrismaClientOptions(options, datasourceNames) {\n  for (const [key, value] of Object.entries(options)) {\n    if (!knownProperties.includes(key)) {\n      const didYouMean = getDidYouMean(key, knownProperties);\n      throw new PrismaClientConstructorValidationError(\n        `Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`\n      );\n    }\n    validators[key](value, datasourceNames);\n  }\n}\n__name(validatePrismaClientOptions, \"validatePrismaClientOptions\");\nfunction getDidYouMean(str, options) {\n  if (options.length === 0) {\n    return \"\";\n  }\n  if (typeof str !== \"string\") {\n    return \"\";\n  }\n  const alternative = getAlternative(str, options);\n  if (!alternative) {\n    return \"\";\n  }\n  return ` Did you mean \"${alternative}\"?`;\n}\n__name(getDidYouMean, \"getDidYouMean\");\nfunction getAlternative(str, options) {\n  if (options.length === 0) {\n    return null;\n  }\n  const optionsWithDistances = options.map((value) => ({\n    value,\n    distance: (0, import_js_levenshtein2.default)(str, value)\n  }));\n  optionsWithDistances.sort((a, b) => {\n    return a.distance < b.distance ? -1 : 1;\n  });\n  const bestAlternative = optionsWithDistances[0];\n  if (bestAlternative.distance < 3) {\n    return bestAlternative.value;\n  }\n  return null;\n}\n__name(getAlternative, \"getAlternative\");\n\n// src/runtime/getPrismaClient.ts\nvar debug12 = src_default(\"prisma:client\");\nvar ALTER_RE = /^(\\s*alter\\s)/i;\ntypeof globalThis === \"object\" ? globalThis.NODE_CLIENT = true : 0;\nfunction isReadonlyArray(arg2) {\n  return Array.isArray(arg2);\n}\n__name(isReadonlyArray, \"isReadonlyArray\");\nfunction checkAlter(query2, values, invalidCall) {\n  if (values.length > 0 && ALTER_RE.exec(query2)) {\n    throw new Error(`Running ALTER using ${invalidCall} is not supported\nUsing the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.\n\nExample:\n  await prisma.$executeRawUnsafe(\\`ALTER USER prisma WITH PASSWORD '\\${password}'\\`)\n\nMore Information: https://pris.ly/d/execute-raw\n`);\n  }\n}\n__name(checkAlter, \"checkAlter\");\nvar actionOperationMap = {\n  findUnique: \"query\",\n  findFirst: \"query\",\n  findMany: \"query\",\n  count: \"query\",\n  create: \"mutation\",\n  createMany: \"mutation\",\n  update: \"mutation\",\n  updateMany: \"mutation\",\n  upsert: \"mutation\",\n  delete: \"mutation\",\n  deleteMany: \"mutation\",\n  executeRaw: \"mutation\",\n  queryRaw: \"mutation\",\n  aggregate: \"query\",\n  groupBy: \"query\",\n  runCommandRaw: \"mutation\",\n  findRaw: \"query\",\n  aggregateRaw: \"query\"\n};\nvar TX_ID = Symbol.for(\"prisma.client.transaction.id\");\nfunction getPrismaClient(config2) {\n  class PrismaClient {\n    constructor(optionsArg) {\n      this._middlewares = new Middlewares();\n      this._transactionId = 1;\n      this._getDmmf = callOnce(async (params) => {\n        try {\n          const dmmf = await this._engine.getDmmf();\n          return new DMMFHelper(getPrismaClientDMMF(dmmf));\n        } catch (error2) {\n          this._fetcher.handleRequestError({ ...params, error: error2 });\n        }\n      });\n      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i;\n      if (optionsArg) {\n        validatePrismaClientOptions(optionsArg, config2.datasourceNames);\n      }\n      this._previewFeatures = (_b2 = (_a3 = config2.generator) == null ? void 0 : _a3.previewFeatures) != null ? _b2 : [];\n      this._rejectOnNotFound = optionsArg == null ? void 0 : optionsArg.rejectOnNotFound;\n      this._clientVersion = (_c = config2.clientVersion) != null ? _c : clientVersion;\n      this._activeProvider = config2.activeProvider;\n      this._dataProxy = config2.dataProxy;\n      this._tracingConfig = getTracingConfig(this._previewFeatures);\n      this._clientEngineType = getClientEngineType(config2.generator);\n      const envPaths = {\n        rootEnvPath: config2.relativeEnvPaths.rootEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),\n        schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)\n      };\n      const loadedEnv = tryLoadEnvs(envPaths, { conflictCheck: \"none\" });\n      try {\n        const options = optionsArg != null ? optionsArg : {};\n        const internal = (_d = options.__internal) != null ? _d : {};\n        const useDebug = internal.debug === true;\n        if (useDebug) {\n          src_default.enable(\"prisma:client\");\n        }\n        if (internal.hooks) {\n          this._hooks = internal.hooks;\n        }\n        let cwd = import_path5.default.resolve(config2.dirname, config2.relativePath);\n        if (!import_fs9.default.existsSync(cwd)) {\n          cwd = config2.dirname;\n        }\n        debug12(\"dirname\", config2.dirname);\n        debug12(\"relativePath\", config2.relativePath);\n        debug12(\"cwd\", cwd);\n        const thedatasources = options.datasources || {};\n        const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {\n          return source && source.url;\n        }).map(([name, { url }]) => ({\n          name,\n          url\n        }));\n        const datasources = mergeBy([], inputDatasources, (source) => source.name);\n        const engineConfig = internal.engine || {};\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat;\n        } else if (false) {} else if (process.env.NO_COLOR) {\n          this._errorFormat = \"colorless\";\n        } else {\n          this._errorFormat = \"colorless\";\n        }\n        this._baseDmmf = new BaseDMMFHelper(config2.document);\n        if (this._dataProxy) {\n          const rawDmmf = config2.document;\n          this._dmmf = new DMMFHelper(rawDmmf);\n        }\n        this._engineConfig = {\n          cwd,\n          dirname: config2.dirname,\n          enableDebugLogs: useDebug,\n          allowTriggerPanic: engineConfig.allowTriggerPanic,\n          datamodelPath: import_path5.default.join(config2.dirname, (_e = config2.filename) != null ? _e : \"schema.prisma\"),\n          prismaPath: (_f = engineConfig.binaryPath) != null ? _f : void 0,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config2.generator,\n          showColors: this._errorFormat === \"pretty\",\n          logLevel: options.log && getLogLevel(options.log),\n          logQueries: options.log && Boolean(\n            typeof options.log === \"string\" ? options.log === \"query\" : options.log.find((o) => typeof o === \"string\" ? o === \"query\" : o.level === \"query\")\n          ),\n          env: (_i = (_h = loadedEnv == null ? void 0 : loadedEnv.parsed) != null ? _h : (_g = config2.injectableEdgeEnv) == null ? void 0 : _g.parsed) != null ? _i : {},\n          flags: [],\n          clientVersion: config2.clientVersion,\n          previewFeatures: this._previewFeatures,\n          activeProvider: config2.activeProvider,\n          inlineSchema: config2.inlineSchema,\n          inlineDatasources: config2.inlineDatasources,\n          inlineSchemaHash: config2.inlineSchemaHash,\n          tracingConfig: this._tracingConfig\n        };\n        debug12(\"clientVersion\", config2.clientVersion);\n        debug12(\"clientEngineType\", this._dataProxy ? \"dataproxy\" : this._clientEngineType);\n        if (this._dataProxy) {\n          const runtime =  true ? \"Node.js\" : 0;\n          debug12(`using Data Proxy with ${runtime} runtime`);\n        }\n        this._engine = this.getEngine();\n        void this._getActiveProvider();\n        this._fetcher = new RequestHandler(this, this._hooks);\n        if (options.log) {\n          for (const log4 of options.log) {\n            const level = typeof log4 === \"string\" ? log4 : log4.emit === \"stdout\" ? log4.level : null;\n            if (level) {\n              this.$on(level, (event) => {\n                var _a4;\n                logger_exports.log(`${(_a4 = logger_exports.tags[level]) != null ? _a4 : \"\"}`, event.message || event.query);\n              });\n            }\n          }\n        }\n        this._metrics = new MetricsClient(this._engine);\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n      return applyModels(this);\n    }\n    get [Symbol.toStringTag]() {\n      return \"PrismaClient\";\n    }\n    getEngine() {\n      if (this._dataProxy === true) {\n        return new DataProxyEngine(this._engineConfig);\n      } else if (this._clientEngineType === \"library\" /* Library */) {\n        return new LibraryEngine(this._engineConfig);\n      } else if (this._clientEngineType === \"binary\" /* Binary */) {\n        return new BinaryEngine(this._engineConfig);\n      }\n      throw new PrismaClientValidationError(\"Invalid client engine type, please use `library` or `binary`\");\n    }\n    $use(arg0, arg1) {\n      if (typeof arg0 === \"function\") {\n        this._middlewares.query.use(arg0);\n      } else if (arg0 === \"all\") {\n        this._middlewares.query.use(arg1);\n      } else if (arg0 === \"engine\") {\n        this._middlewares.engine.use(arg1);\n      } else {\n        throw new Error(`Invalid middleware ${arg0}`);\n      }\n    }\n    $on(eventType, callback) {\n      if (eventType === \"beforeExit\") {\n        this._engine.on(\"beforeExit\", callback);\n      } else {\n        this._engine.on(eventType, (event) => {\n          var _a3, _b2, _c, _d;\n          const fields = event.fields;\n          if (eventType === \"query\") {\n            return callback({\n              timestamp: event.timestamp,\n              query: (_a3 = fields == null ? void 0 : fields.query) != null ? _a3 : event.query,\n              params: (_b2 = fields == null ? void 0 : fields.params) != null ? _b2 : event.params,\n              duration: (_c = fields == null ? void 0 : fields.duration_ms) != null ? _c : event.duration,\n              target: event.target\n            });\n          } else {\n            return callback({\n              timestamp: event.timestamp,\n              message: (_d = fields == null ? void 0 : fields.message) != null ? _d : event.message,\n              target: event.target\n            });\n          }\n        });\n      }\n    }\n    $connect() {\n      try {\n        return this._engine.start();\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n    }\n    async _runDisconnect() {\n      await this._engine.stop();\n      delete this._connectionPromise;\n      this._engine = this.getEngine();\n      delete this._disconnectionPromise;\n      delete this._getConfigPromise;\n    }\n    async $disconnect() {\n      try {\n        await this._engine.stop();\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      } finally {\n        if (!this._dataProxy) {\n          this._dmmf = void 0;\n        }\n      }\n    }\n    async _getActiveProvider() {\n      try {\n        const configResult = await this._engine.getConfig();\n        this._activeProvider = configResult.datasources[0].activeProvider;\n      } catch (e) {\n      }\n    }\n    $executeRawInternal(txId, lock, query2, ...values) {\n      let queryString = \"\";\n      let parameters = void 0;\n      if (typeof query2 === \"string\") {\n        queryString = query2;\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true\n        };\n        checkAlter(queryString, values, \"prisma.$executeRawUnsafe(<SQL>, [...values])\");\n      } else if (isReadonlyArray(query2)) {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.sql;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"cockroachdb\":\n          case \"postgresql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.text;\n            checkAlter(queryString, queryInstance.values, \"prisma.$executeRaw`<SQL>`\");\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"sqlserver\": {\n            queryString = mssqlPreparedStatement(query2);\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);\n          }\n        }\n      } else {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\":\n            queryString = query2.sql;\n            break;\n          case \"cockroachdb\":\n          case \"postgresql\":\n            queryString = query2.text;\n            checkAlter(queryString, query2.values, \"prisma.$executeRaw(sql`<SQL>`)\");\n            break;\n          case \"sqlserver\":\n            queryString = mssqlPreparedStatement(query2.strings);\n            break;\n          default:\n            throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);\n        }\n        parameters = {\n          values: serializeRawParameters(query2.values),\n          __prismaRawParamaters__: true\n        };\n      }\n      if (parameters == null ? void 0 : parameters.values) {\n        debug12(`prisma.$executeRaw(${queryString}, ${parameters.values})`);\n      } else {\n        debug12(`prisma.$executeRaw(${queryString})`);\n      }\n      const args = { query: queryString, parameters };\n      debug12(`Prisma Client call:`);\n      return this._request({\n        args,\n        clientMethod: \"$executeRaw\",\n        dataPath: [],\n        action: \"executeRaw\",\n        callsite: getCallSite(this._errorFormat),\n        runInTransaction: !!txId,\n        transactionId: txId,\n        lock\n      });\n    }\n    $executeRaw(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        if (query2.raw !== void 0 || query2.sql !== void 0) {\n          return this.$executeRawInternal(txId, lock, query2, ...values);\n        }\n        throw new PrismaClientValidationError(`\\`$executeRaw\\` is a tag function, please use it like the following:\n\\`\\`\\`\nconst result = await prisma.$executeRaw\\`UPDATE User SET cool = \\${true} WHERE email = \\${'user@email.com'};\\`\n\\`\\`\\`\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n`);\n      });\n    }\n    $executeRawUnsafe(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        return this.$executeRawInternal(txId, lock, query2, ...values);\n      });\n    }\n    $runCommandRaw(command) {\n      if (config2.activeProvider !== \"mongodb\") {\n        throw new PrismaClientValidationError(\n          `The ${config2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`\n        );\n      }\n      return createPrismaPromise((txId, lock) => {\n        return this._request({\n          args: { command },\n          clientMethod: \"$runCommandRaw\",\n          dataPath: [],\n          action: \"runCommandRaw\",\n          callsite: getCallSite(this._errorFormat),\n          runInTransaction: !!txId,\n          transactionId: txId,\n          lock\n        });\n      });\n    }\n    $queryRawInternal(txId, lock, query2, ...values) {\n      let queryString = \"\";\n      let parameters = void 0;\n      if (typeof query2 === \"string\") {\n        queryString = query2;\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true\n        };\n      } else if (isReadonlyArray(query2)) {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.sql;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"cockroachdb\":\n          case \"postgresql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.text;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"sqlserver\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = mssqlPreparedStatement(queryInstance.strings);\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);\n          }\n        }\n      } else {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\":\n            queryString = query2.sql;\n            break;\n          case \"cockroachdb\":\n          case \"postgresql\":\n            queryString = query2.text;\n            break;\n          case \"sqlserver\":\n            queryString = mssqlPreparedStatement(query2.strings);\n            break;\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);\n          }\n        }\n        parameters = {\n          values: serializeRawParameters(query2.values),\n          __prismaRawParamaters__: true\n        };\n      }\n      if (parameters == null ? void 0 : parameters.values) {\n        debug12(`prisma.queryRaw(${queryString}, ${parameters.values})`);\n      } else {\n        debug12(`prisma.queryRaw(${queryString})`);\n      }\n      const args = { query: queryString, parameters };\n      debug12(`Prisma Client call:`);\n      return this._request({\n        args,\n        clientMethod: \"$queryRaw\",\n        dataPath: [],\n        action: \"queryRaw\",\n        callsite: getCallSite(this._errorFormat),\n        runInTransaction: !!txId,\n        transactionId: txId,\n        lock\n      }).then(deserializeRawResults);\n    }\n    $queryRaw(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        if (query2.raw !== void 0 || query2.sql !== void 0) {\n          return this.$queryRawInternal(txId, lock, query2, ...values);\n        }\n        throw new PrismaClientValidationError(`\\`$queryRaw\\` is a tag function, please use it like the following:\n\\`\\`\\`\nconst result = await prisma.$queryRaw\\`SELECT * FROM User WHERE id = \\${1} OR email = \\${'user@email.com'};\\`\n\\`\\`\\`\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n`);\n      });\n    }\n    $queryRawUnsafe(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        return this.$queryRawInternal(txId, lock, query2, ...values);\n      });\n    }\n    __internal_triggerPanic(fatal) {\n      if (!this._engineConfig.allowTriggerPanic) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      allowTriggerPanic: true\n    }\n  }\n})`);\n      }\n      const headers = fatal ? { \"X-DEBUG-FATAL\": \"1\" } : { \"X-DEBUG-NON-FATAL\": \"1\" };\n      return this._request({\n        action: \"queryRaw\",\n        args: {\n          query: \"SELECT 1\",\n          parameters: void 0\n        },\n        clientMethod: \"queryRaw\",\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: getCallSite(this._errorFormat)\n      });\n    }\n    _transactionWithArray(promises) {\n      const txId = this._transactionId++;\n      const lock = getLockCountPromise(promises.length);\n      const requests = promises.map((request2) => {\n        var _a3;\n        if ((request2 == null ? void 0 : request2[Symbol.toStringTag]) !== \"PrismaPromise\") {\n          throw new Error(\n            `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`\n          );\n        }\n        return (_a3 = request2.requestTransaction) == null ? void 0 : _a3.call(request2, txId, lock);\n      });\n      return Promise.all(requests);\n    }\n    async _transactionWithCallback({\n      callback,\n      options\n    }) {\n      const headers = { traceparent: getTraceParent({ tracingConfig: this._tracingConfig }) };\n      const info2 = await this._engine.transaction(\"start\", headers, options);\n      let result;\n      try {\n        result = await callback(transactionProxy(this, info2.id));\n        await this._engine.transaction(\"commit\", headers, info2);\n      } catch (e) {\n        await this._engine.transaction(\"rollback\", headers, info2).catch(() => {\n        });\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n      return result;\n    }\n    $transaction(input, options) {\n      let callback;\n      if (typeof input === \"function\" && this._hasPreviewFlag(\"interactiveTransactions\")) {\n        callback = /* @__PURE__ */ __name(() => this._transactionWithCallback({ callback: input, options }), \"callback\");\n      } else {\n        callback = /* @__PURE__ */ __name(() => this._transactionWithArray(input), \"callback\");\n      }\n      const spanOptions = {\n        name: \"transaction\",\n        enabled: this._tracingConfig.enabled,\n        attributes: { method: \"$transaction\" }\n      };\n      return runInChildSpan(spanOptions, callback);\n    }\n    async _request(internalParams) {\n      internalParams.otelParentCtx = context2.active();\n      try {\n        const params = {\n          args: internalParams.args,\n          dataPath: internalParams.dataPath,\n          runInTransaction: internalParams.runInTransaction,\n          action: internalParams.action,\n          model: internalParams.model\n        };\n        const spanOptions = {\n          middleware: {\n            name: \"middleware\",\n            enabled: this._tracingConfig.middleware,\n            attributes: { method: \"$use\" },\n            active: false\n          },\n          operation: {\n            name: \"operation\",\n            enabled: this._tracingConfig.enabled,\n            attributes: {\n              method: params.action,\n              model: params.model,\n              name: `${params.model}.${params.action}`\n            }\n          }\n        };\n        let index = -1;\n        const consumer = /* @__PURE__ */ __name((changedParams) => {\n          const nextMiddleware = this._middlewares.query.get(++index);\n          if (nextMiddleware) {\n            return runInChildSpan(spanOptions.middleware, async (span) => {\n              return nextMiddleware(changedParams, (p) => (span == null ? void 0 : span.end(), consumer(p)));\n            });\n          }\n          return this._executeRequest({ ...internalParams, ...changedParams });\n        }, \"consumer\");\n        return await runInChildSpan(spanOptions.operation, () => {\n          if (true) {\n            const asyncRes = new import_async_hooks.AsyncResource(\"prisma-client-request\");\n            return asyncRes.runInAsyncScope(() => consumer(params));\n          }\n          return consumer(params);\n        });\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n    }\n    async _executeRequest({\n      args,\n      clientMethod,\n      jsModelName,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n      transactionId,\n      lock,\n      unpacker,\n      otelParentCtx\n    }) {\n      var _a3, _b2;\n      if (this._dmmf === void 0) {\n        this._dmmf = await this._getDmmf({ clientMethod, callsite });\n      }\n      let rootField;\n      const operation = actionOperationMap[action];\n      if (action === \"executeRaw\" || action === \"queryRaw\" || action === \"runCommandRaw\") {\n        rootField = action;\n      }\n      let mapping;\n      if (model !== void 0) {\n        mapping = (_a3 = this._dmmf) == null ? void 0 : _a3.mappingsMap[model];\n        if (mapping === void 0) {\n          throw new Error(`Could not find mapping for model ${model}`);\n        }\n        rootField = mapping[action === \"count\" ? \"aggregate\" : action];\n      }\n      if (operation !== \"query\" && operation !== \"mutation\") {\n        throw new Error(`Invalid operation ${operation} for action ${action}`);\n      }\n      const field = (_b2 = this._dmmf) == null ? void 0 : _b2.rootFieldMap[rootField];\n      if (field === void 0) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`\n        );\n      }\n      const { isList } = field.outputType;\n      const typeName = getOutputTypeName(field.outputType.type);\n      const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);\n      warnAboutRejectOnNotFound(rejectOnNotFound, jsModelName, action);\n      const serializationFn = /* @__PURE__ */ __name(() => {\n        const document3 = makeDocument({\n          dmmf: this._dmmf,\n          rootField,\n          rootTypeName: operation,\n          select: args,\n          modelName: model\n        });\n        document3.validate(args, false, clientMethod, this._errorFormat, callsite);\n        return transformDocument(document3);\n      }, \"serializationFn\");\n      const spanOptions = {\n        name: \"serialize\",\n        enabled: this._tracingConfig.enabled\n      };\n      const document2 = await runInChildSpan(spanOptions, serializationFn);\n      if (src_default.enabled(\"prisma:client\")) {\n        const query2 = String(document2);\n        debug12(`Prisma Client call:`);\n        debug12(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: []\n          })})`\n        );\n        debug12(`Generated request:`);\n        debug12(query2 + \"\\n\");\n      }\n      await lock;\n      return this._fetcher.request({\n        document: document2,\n        clientMethod,\n        typeName,\n        dataPath,\n        rejectOnNotFound,\n        isList,\n        rootField,\n        callsite,\n        args,\n        engineHook: this._middlewares.engine.get(0),\n        runInTransaction,\n        headers,\n        transactionId,\n        unpacker,\n        otelParentCtx,\n        otelChildCtx: context2.active()\n      });\n    }\n    get $metrics() {\n      if (!this._hasPreviewFlag(\"metrics\")) {\n        throw new PrismaClientValidationError(\n          \"`metrics` preview feature must be enabled in order to access metrics API\"\n        );\n      }\n      return this._metrics;\n    }\n    _hasPreviewFlag(feature) {\n      var _a3;\n      return !!((_a3 = this._engineConfig.previewFeatures) == null ? void 0 : _a3.includes(feature));\n    }\n  }\n  __name(PrismaClient, \"PrismaClient\");\n  return PrismaClient;\n}\n__name(getPrismaClient, \"getPrismaClient\");\nvar forbidden = [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$use\"];\nfunction transactionProxy(thing, txId) {\n  if (typeof thing !== \"object\")\n    return thing;\n  return new Proxy(thing, {\n    get: (target, prop) => {\n      if (forbidden.includes(prop))\n        return void 0;\n      if (prop === TX_ID)\n        return txId;\n      if (typeof target[prop] === \"function\") {\n        return (...args) => {\n          if (prop === \"then\")\n            return target[prop](args[0], args[1], txId);\n          if (prop === \"catch\")\n            return target[prop](args[0], txId);\n          if (prop === \"finally\")\n            return target[prop](args[0], txId);\n          return transactionProxy(target[prop](...args), txId);\n        };\n      }\n      return transactionProxy(target[prop], txId);\n    }\n  });\n}\n__name(transactionProxy, \"transactionProxy\");\nvar rejectOnNotFoundReplacements = {\n  findUnique: \"findUniqueOrThrow\",\n  findFirst: \"findFirstOrThrow\"\n};\nfunction warnAboutRejectOnNotFound(rejectOnNotFound, model, action) {\n  if (rejectOnNotFound) {\n    const replacementAction = rejectOnNotFoundReplacements[action];\n    const replacementCall = model ? `prisma.${model}.${replacementAction}` : `prisma.${replacementAction}`;\n    const key = `rejectOnNotFound.${model != null ? model : \"\"}.${action}`;\n    warnOnce(\n      key,\n      `\\`rejectOnNotFound\\` option is deprecated and will be removed in Prisma 5. Please use \\`${replacementCall}\\` method instead`\n    );\n  }\n}\n__name(warnAboutRejectOnNotFound, \"warnAboutRejectOnNotFound\");\n\n// src/runtime/strictEnum.ts\nvar allowList = /* @__PURE__ */ new Set([\n  \"toJSON\",\n  \"asymmetricMatch\",\n  Symbol.iterator,\n  Symbol.toStringTag,\n  Symbol.isConcatSpreadable,\n  Symbol.toPrimitive\n]);\nfunction makeStrictEnum(definition) {\n  return new Proxy(definition, {\n    get(target, property) {\n      if (property in target) {\n        return target[property];\n      }\n      if (allowList.has(property)) {\n        return void 0;\n      }\n      throw new TypeError(`Invalid enum value: ${String(property)}`);\n    }\n  });\n}\n__name(makeStrictEnum, \"makeStrictEnum\");\n\n// src/runtime/utils/find.ts\nvar import_fs10 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path6 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_util7 = __webpack_require__(/*! util */ \"util\");\nvar readdirAsync = (0, import_util7.promisify)(import_fs10.default.readdir);\nvar realpathAsync = (0, import_util7.promisify)(import_fs10.default.realpath);\nvar statAsync = (0, import_util7.promisify)(import_fs10.default.stat);\nvar readdirSync = import_fs10.default.readdirSync;\nvar realpathSync = import_fs10.default.realpathSync;\nvar statSync = import_fs10.default.statSync;\nfunction direntToType(dirent) {\n  return dirent.isFile() ? \"f\" : dirent.isDirectory() ? \"d\" : dirent.isSymbolicLink() ? \"l\" : void 0;\n}\n__name(direntToType, \"direntToType\");\nfunction isMatched(string, regexs) {\n  for (const regex of regexs) {\n    if (typeof regex === \"string\") {\n      if (string.includes(regex)) {\n        return true;\n      }\n    } else if (regex.exec(string)) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(isMatched, \"isMatched\");\nfunction findSync(root, match, types = [\"f\", \"d\", \"l\"], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {\n  try {\n    const realRoot = realpathSync(root);\n    if (seen[realRoot]) {\n      return found;\n    }\n    if (limit - found.length <= 0) {\n      return found;\n    }\n    if (direntToType(statSync(realRoot)) !== \"d\") {\n      return found;\n    }\n    const items = readdirSync(root, { withFileTypes: true });\n    seen[realRoot] = true;\n    for (const item of items) {\n      const itemName = item.name;\n      const itemType = direntToType(item);\n      const itemPath = import_path6.default.join(root, item.name);\n      if (itemType && types.includes(itemType)) {\n        if (isMatched(itemPath, match)) {\n          const value = handler(root, itemName, itemType);\n          if (typeof value === \"string\") {\n            found.push(value);\n          } else if (value === true) {\n            found.push(itemPath);\n          }\n        }\n      }\n      if (deep.includes(itemType)) {\n        findSync(itemPath, match, types, deep, limit, handler, found, seen);\n      }\n    }\n  } catch (e) {\n  }\n  return found;\n}\n__name(findSync, \"findSync\");\n\n// src/runtime/warnEnvConflicts.ts\nfunction warnEnvConflicts(envPaths) {\n  tryLoadEnvs(envPaths, { conflictCheck: \"warn\" });\n}\n__name(warnEnvConflicts, \"warnEnvConflicts\");\n\n// src/runtime/index.ts\nvar decompressFromBase642 = lzString.decompressFromBase64;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*!\n *  decimal.js v10.4.0\n *  An arbitrary-precision Decimal type for JavaScript.\n *  https://github.com/MikeMcl/decimal.js\n *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\n *  MIT Licence\n */\n/*!\n * @description Recursive object extending\n * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>\n * @license MIT\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2018 Viacheslav Lotsmanov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHLDJFQUEyRSwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSxLQUFxQyxFQUFFLEVBSTFDLENBQUM7QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGNBQWMsNkJBQTZCO0FBQzNDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsOEJBQThCO0FBQzNDLGlCQUFpQixrQ0FBa0M7QUFDbkQsZ0JBQWdCLGlDQUFpQztBQUNqRCxpQkFBaUIsa0NBQWtDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGVBQWUsNENBQTRDO0FBQzNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFLFVBQVUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0NBQXdDO0FBQ3RHLDREQUE0RCxzQ0FBc0M7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEVBQUUsRUFBRSxLQUFLO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsRUFBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQjtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsVUFBVSx3QkFBd0I7QUFDbEMsVUFBVSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxnQkFBSztBQUM1QixVQUFVLHVCQUF1QjtBQUNqQyxVQUFVLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLGtCQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhLElBQUksYUFBYSxHQUFHLEtBQUs7QUFDaEcscURBQXFELG1CQUFtQixFQUFFLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxzSEFBc0gsYUFBYTtBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsRUFBRSxJQUFJLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFF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O0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOENBQThDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNFQUFzRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9EQUFvRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlEQUFpRDtBQUN0RDtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwRkFBMEY7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBOEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRLEVBQUUsT0FBTztBQUN2QztBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxrQkFBa0IsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQkFBMEIsK0ZBQStGO0FBQ3pILFVBQVU7QUFDVixzQkFBc0IsZ0ZBQWdGO0FBQ3RHO0FBQ0EsUUFBUTtBQUNSLHNCQUFzQixnRkFBZ0Y7QUFDdEcsUUFBUTtBQUNSLHdCQUF3QixnRkFBZ0Y7QUFDeEcsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0ZBQWdGO0FBQzNHO0FBQ0E7QUFDQSx1Q0FBdUMsMEVBQTBFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdGQUFnRjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLGtCQUFrQixjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdGQUFnRjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1Q0FBdUMsMEVBQTBFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEVBQTBFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlGQUF5RjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLFlBQVk7QUFDWiw0QkFBNEIsT0FBTyxrQkFBa0IsY0FBYztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlCQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUZBQXlGO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0dBQWtHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DLElBQUk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFxRSxJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLFVBQVUsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDdkMsVUFBVSx5Q0FBeUM7QUFDbkQ7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1CQUFtQixrREFBc0I7QUFDekM7QUFDQSxtQ0FBbUMsNkJBQTZCO0FBQ2hFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxVQUFVLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDakUsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzRUFBc0U7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEUsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpRUFBaUU7QUFDbEg7QUFDQTtBQUNBLHVGQUF1RixXQUFXLEVBQUUscUJBQXFCLGNBQWMsT0FBTztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFdBQVcsRUFBRSxxQkFBcUIsY0FBYyxPQUFPO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFdBQVcsRUFBRSxxQkFBcUIsY0FBYyxPQUFPO0FBQ2hKO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFGQUFxRixXQUFXLEVBQUUscUJBQXFCLGNBQWMsT0FBTztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsVUFBVSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ2pFLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLGtCQUFrQix3REFBd0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNqRSxVQUFVLDBCQUEwQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUF5RDtBQUNuRSxVQUFVLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDakU7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEUsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUF5RDtBQUNuRSxVQUFVLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDakU7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVSwwQkFBMEIsYUFBYTtBQUM1RztBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQSwrRUFBK0UsV0FBVztBQUMxRjtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRFQUE0RTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVEQUF1RCxpQkFBaUIsSUFBSTtBQUM1RSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGNBQWMsUUFBUSxvREFBb0QsbUJBQW1CO0FBQzdGLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLCtCQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWUsaUNBQWlDLFFBQVE7QUFDekc7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlEQUFpRCxlQUFlLGlDQUFpQyxRQUFRO0FBQ3pHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsdURBQXVELHdDQUF3QztBQUMvRiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRkFBb0Y7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixlQUFlO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNsRDtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxrQkFBa0I7QUFDNUI7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ2xEO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGtCQUFrQjtBQUM1QjtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN4QyxVQUFVLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHdCQUFTO0FBQ3ZDO0FBQ0Esb0JBQW9CLGdCQUFnQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsWUFBWSx3Q0FBd0M7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLHFCQUFxQixjQUFjLFNBQVM7QUFDL0s7QUFDQSxvQ0FBb0Msb0VBQW9FLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxlQUFlOztBQUV4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQix5Q0FBeUMsa0JBQWtCO0FBQzNELGtEQUFrRCxvQkFBb0I7QUFDdEUscUNBQXFDLDhCQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLFNBQVM7QUFDbkIsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxjQUFjO0FBQ3ZGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRLElBQUksTUFBTTtBQUMzRCxVQUFVO0FBQ1YseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixrQkFBa0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysa0JBQWtCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixrQkFBa0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsa0JBQWtCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsa0JBQWtCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLG1DQUFtQztBQUM3QyxVQUFVLFNBQVM7QUFDbkIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsZUFBZTtBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxVQUFVLFFBQVEsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ2xDLHNEQUFzRCxvRUFBb0M7QUFDMUY7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5Q0FBeUM7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSx5RkFBeUYsa0JBQWtCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFxQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhEQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRix3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLCtCQUErQixjQUFjLEdBQUcsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUksR0FBRyxNQUFNO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQiw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1IsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0REFBNEQ7QUFDL0QsQ0FBQyxvQkFBb0I7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QyxvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDOztBQUV6QztBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQsNkRBQTZELE1BQU0sbUNBQW1DLEtBQUs7QUFDM0c7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osVUFBVTtBQUNWLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxjQUFJOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsOEJBQVk7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0QsK0RBQStELE1BQU0sb0NBQW9DLEtBQUs7QUFDOUc7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsNEJBQTRCLEdBQUcsVUFBVSxHQUFHO0FBQzVDLDZCQUE2QixHQUFHLFVBQVUsR0FBRztBQUM3QywyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbVRBQW1UO0FBQzNVO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrREFBK0QscUZBQXFGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4Qzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtVEFBbVQ7QUFDM1U7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFxRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBaUU7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVUs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsY0FBSTtBQUN0QywyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0EyQkw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0ZW1jYXRhbG9ndWUvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC5qcz85OTdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QyKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QyIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kMiA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kMiksIG1vZDIuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QyLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kMikpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QyIHx8ICFtb2QyLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kMlxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZDIpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZDIpO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sei1zdHJpbmdAMS40LjQvbm9kZV9tb2R1bGVzL2x6LXN0cmluZy9saWJzL2x6LXN0cmluZy5qc1xudmFyIHJlcXVpcmVfbHpfc3RyaW5nID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x6LXN0cmluZ0AxLjQuNC9ub2RlX21vZHVsZXMvbHotc3RyaW5nL2xpYnMvbHotc3RyaW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBMWlN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgICAgdmFyIGtleVN0ckJhc2U2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgIHZhciBrZXlTdHJVcmlTYWZlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJFwiO1xuICAgICAgdmFyIGJhc2VSZXZlcnNlRGljID0ge307XG4gICAgICBmdW5jdGlvbiBnZXRCYXNlVmFsdWUoYWxwaGFiZXQsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAoIWJhc2VSZXZlcnNlRGljW2FscGhhYmV0XSkge1xuICAgICAgICAgIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XVthbHBoYWJldC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XVtjaGFyYWN0ZXJdO1xuICAgICAgfVxuICAgICAgX19uYW1lKGdldEJhc2VWYWx1ZSwgXCJnZXRCYXNlVmFsdWVcIik7XG4gICAgICB2YXIgTFpTdHJpbmcyID0ge1xuICAgICAgICBjb21wcmVzc1RvQmFzZTY0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgdmFyIHJlcyA9IExaU3RyaW5nMi5fY29tcHJlc3MoaW5wdXQsIDYsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTdHJCYXNlNjQuY2hhckF0KGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN3aXRjaCAocmVzLmxlbmd0aCAlIDQpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiByZXMgKyBcIj09PVwiO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gcmVzICsgXCI9PVwiO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gcmVzICsgXCI9XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWNvbXByZXNzRnJvbUJhc2U2NDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5fZGVjb21wcmVzcyhpbnB1dC5sZW5ndGgsIDMyLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VWYWx1ZShrZXlTdHJCYXNlNjQsIGlucHV0LmNoYXJBdChpbmRleCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wcmVzc1RvVVRGMTY6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9jb21wcmVzcyhpbnB1dCwgMTUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmKGEgKyAzMik7XG4gICAgICAgICAgfSkgKyBcIiBcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb21wcmVzc0Zyb21VVEYxNjogZnVuY3Rpb24oY29tcHJlc3NlZCkge1xuICAgICAgICAgIGlmIChjb21wcmVzc2VkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICBpZiAoY29tcHJlc3NlZCA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5fZGVjb21wcmVzcyhjb21wcmVzc2VkLmxlbmd0aCwgMTYzODQsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGluZGV4KSAtIDMyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wcmVzc1RvVWludDhBcnJheTogZnVuY3Rpb24odW5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBMWlN0cmluZzIuY29tcHJlc3ModW5jb21wcmVzc2VkKTtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoY29tcHJlc3NlZC5sZW5ndGggKiAyKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgVG90YWxMZW4gPSBjb21wcmVzc2VkLmxlbmd0aDsgaSA8IFRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50X3ZhbHVlID0gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYnVmW2kgKiAyXSA9IGN1cnJlbnRfdmFsdWUgPj4+IDg7XG4gICAgICAgICAgICBidWZbaSAqIDIgKyAxXSA9IGN1cnJlbnRfdmFsdWUgJSAyNTY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29tcHJlc3NGcm9tVWludDhBcnJheTogZnVuY3Rpb24oY29tcHJlc3NlZCkge1xuICAgICAgICAgIGlmIChjb21wcmVzc2VkID09PSBudWxsIHx8IGNvbXByZXNzZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5kZWNvbXByZXNzKGNvbXByZXNzZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEFycmF5KGNvbXByZXNzZWQubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgVG90YWxMZW4gPSBidWYubGVuZ3RoOyBpIDwgVG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICBidWZbaV0gPSBjb21wcmVzc2VkW2kgKiAyXSAqIDI1NiArIGNvbXByZXNzZWRbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGJ1Zi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZihjKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBMWlN0cmluZzIuZGVjb21wcmVzcyhyZXN1bHQuam9pbihcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBMWlN0cmluZzIuX2NvbXByZXNzKGlucHV0LCA2LCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5U3RyVXJpU2FmZS5jaGFyQXQoYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC8gL2csIFwiK1wiKTtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9kZWNvbXByZXNzKGlucHV0Lmxlbmd0aCwgMzIsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmFzZVZhbHVlKGtleVN0clVyaVNhZmUsIGlucHV0LmNoYXJBdChpbmRleCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wcmVzczogZnVuY3Rpb24odW5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5fY29tcHJlc3ModW5jb21wcmVzc2VkLCAxNiwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGYoYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jb21wcmVzczogZnVuY3Rpb24odW5jb21wcmVzc2VkLCBiaXRzUGVyQ2hhciwgZ2V0Q2hhckZyb21JbnQpIHtcbiAgICAgICAgICBpZiAodW5jb21wcmVzc2VkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB2YXIgaSwgdmFsdWUsIGNvbnRleHRfZGljdGlvbmFyeSA9IHt9LCBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZSA9IHt9LCBjb250ZXh0X2MgPSBcIlwiLCBjb250ZXh0X3djID0gXCJcIiwgY29udGV4dF93ID0gXCJcIiwgY29udGV4dF9lbmxhcmdlSW4gPSAyLCBjb250ZXh0X2RpY3RTaXplID0gMywgY29udGV4dF9udW1CaXRzID0gMiwgY29udGV4dF9kYXRhID0gW10sIGNvbnRleHRfZGF0YV92YWwgPSAwLCBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwLCBpaTtcbiAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCB1bmNvbXByZXNzZWQubGVuZ3RoOyBpaSArPSAxKSB7XG4gICAgICAgICAgICBjb250ZXh0X2MgPSB1bmNvbXByZXNzZWQuY2hhckF0KGlpKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeSwgY29udGV4dF9jKSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF9jXSA9IGNvbnRleHRfZGljdFNpemUrKztcbiAgICAgICAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF9jXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0X3djID0gY29udGV4dF93ICsgY29udGV4dF9jO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnksIGNvbnRleHRfd2MpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfdyA9IGNvbnRleHRfd2M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlLCBjb250ZXh0X3cpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfdy5jaGFyQ29kZUF0KDApIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0X251bUJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxIHwgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZSAmIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlW2NvbnRleHRfd107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF93XTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZSAmIDE7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBjb250ZXh0X251bUJpdHMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3djXSA9IGNvbnRleHRfZGljdFNpemUrKztcbiAgICAgICAgICAgICAgY29udGV4dF93ID0gU3RyaW5nKGNvbnRleHRfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250ZXh0X3cgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGUsIGNvbnRleHRfdykpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfdy5jaGFyQ29kZUF0KDApIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHRfbnVtQml0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZSAmIDE7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlW2NvbnRleHRfd107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3ddO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxIHwgdmFsdWUgJiAxO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IDI7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHRfbnVtQml0czsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxIHwgdmFsdWUgJiAxO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb250ZXh0X2RhdGEuam9pbihcIlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb21wcmVzczogZnVuY3Rpb24oY29tcHJlc3NlZCkge1xuICAgICAgICAgIGlmIChjb21wcmVzc2VkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICBpZiAoY29tcHJlc3NlZCA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5fZGVjb21wcmVzcyhjb21wcmVzc2VkLmxlbmd0aCwgMzI3NjgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29tcHJlc3M6IGZ1bmN0aW9uKGxlbmd0aCwgcmVzZXRWYWx1ZSwgZ2V0TmV4dFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSBbXSwgbmV4dCwgZW5sYXJnZUluID0gNCwgZGljdFNpemUgPSA0LCBudW1CaXRzID0gMywgZW50cnkgPSBcIlwiLCByZXN1bHQgPSBbXSwgaSwgdywgYml0cywgcmVzYiwgbWF4cG93ZXIsIHBvd2VyLCBjLCBkYXRhID0geyB2YWw6IGdldE5leHRWYWx1ZSgwKSwgcG9zaXRpb246IHJlc2V0VmFsdWUsIGluZGV4OiAxIH07XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZGljdGlvbmFyeVtpXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwgMik7XG4gICAgICAgICAgcG93ZXIgPSAxO1xuICAgICAgICAgIHdoaWxlIChwb3dlciAhPSBtYXhwb3dlcikge1xuICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG5leHQgPSBiaXRzKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsIDgpO1xuICAgICAgICAgICAgICBwb3dlciA9IDE7XG4gICAgICAgICAgICAgIHdoaWxlIChwb3dlciAhPSBtYXhwb3dlcikge1xuICAgICAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpdHMgfD0gKHJlc2IgPiAwID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYyA9IGYoYml0cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLCAxNik7XG4gICAgICAgICAgICAgIHBvd2VyID0gMTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvd2VyICE9IG1heHBvd2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjID0gZihiaXRzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWN0aW9uYXJ5WzNdID0gYztcbiAgICAgICAgICB3ID0gYztcbiAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwgbnVtQml0cyk7XG4gICAgICAgICAgICBwb3dlciA9IDE7XG4gICAgICAgICAgICB3aGlsZSAocG93ZXIgIT0gbWF4cG93ZXIpIHtcbiAgICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGMgPSBiaXRzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsIDgpO1xuICAgICAgICAgICAgICAgIHBvd2VyID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocG93ZXIgIT0gbWF4cG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJpdHMgfD0gKHJlc2IgPiAwID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IGYoYml0cyk7XG4gICAgICAgICAgICAgICAgYyA9IGRpY3RTaXplIC0gMTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlSW4tLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwgMTYpO1xuICAgICAgICAgICAgICAgIHBvd2VyID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocG93ZXIgIT0gbWF4cG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJpdHMgfD0gKHJlc2IgPiAwID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IGYoYml0cyk7XG4gICAgICAgICAgICAgICAgYyA9IGRpY3RTaXplIC0gMTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlSW4tLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgICAgICBlbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBudW1CaXRzKTtcbiAgICAgICAgICAgICAgbnVtQml0cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpY3Rpb25hcnlbY10pIHtcbiAgICAgICAgICAgICAgZW50cnkgPSBkaWN0aW9uYXJ5W2NdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGMgPT09IGRpY3RTaXplKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgPSB3ICsgdy5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGRpY3Rpb25hcnlbZGljdFNpemUrK10gPSB3ICsgZW50cnkuY2hhckF0KDApO1xuICAgICAgICAgICAgZW5sYXJnZUluLS07XG4gICAgICAgICAgICB3ID0gZW50cnk7XG4gICAgICAgICAgICBpZiAoZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICAgICAgZW5sYXJnZUluID0gTWF0aC5wb3coMiwgbnVtQml0cyk7XG4gICAgICAgICAgICAgIG51bUJpdHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gTFpTdHJpbmcyO1xuICAgIH0oKTtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGZhbHNlKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBMWlN0cmluZztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZTIgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlMiAhPSBudWxsKSB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBMWlN0cmluZztcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItbmFtZUAxLjEuNC9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfY29sb3JfbmFtZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jb2xvci1uYW1lQDEuMS40L25vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICAgIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICAgIFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICAgIFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxuICAgICAgXCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgICBcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgICBcImJsYWNrXCI6IFswLCAwLCAwXSxcbiAgICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuICAgICAgXCJibHVlXCI6IFswLCAwLCAyNTVdLFxuICAgICAgXCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxuICAgICAgXCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuICAgICAgXCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxuICAgICAgXCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXG4gICAgICBcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcbiAgICAgIFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxuICAgICAgXCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcbiAgICAgIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuICAgICAgXCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgICBcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcbiAgICAgIFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgXCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcbiAgICAgIFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcbiAgICAgIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcbiAgICAgIFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgXCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXG4gICAgICBcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgIFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcbiAgICAgIFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcbiAgICAgIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcbiAgICAgIFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxuICAgICAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxuICAgICAgXCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuICAgICAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcbiAgICAgIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcbiAgICAgIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuICAgICAgXCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcbiAgICAgIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXG4gICAgICBcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcbiAgICAgIFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxuICAgICAgXCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICAgIFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcbiAgICAgIFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICBcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgXCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxuICAgICAgXCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcbiAgICAgIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxuICAgICAgXCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxuICAgICAgXCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgICBcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgICBcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxuICAgICAgXCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXG4gICAgICBcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcbiAgICAgIFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxuICAgICAgXCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcbiAgICAgIFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICAgIFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgICBcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxuICAgICAgXCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxuICAgICAgXCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICBcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICAgIFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxuICAgICAgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICAgIFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXG4gICAgICBcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgICBcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgICBcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxuICAgICAgXCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxuICAgICAgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgICBcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICBcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxuICAgICAgXCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxuICAgICAgXCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxuICAgICAgXCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgICBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXG4gICAgICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgICBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcbiAgICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICAgIFwibGltZVwiOiBbMCwgMjU1LCAwXSxcbiAgICAgIFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXG4gICAgICBcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcbiAgICAgIFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgXCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXG4gICAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxuICAgICAgXCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxuICAgICAgXCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXG4gICAgICBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxuICAgICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxuICAgICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxuICAgICAgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXG4gICAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcbiAgICAgIFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXG4gICAgICBcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgICBcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgICBcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcbiAgICAgIFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxuICAgICAgXCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxuICAgICAgXCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICAgIFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcbiAgICAgIFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxuICAgICAgXCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcbiAgICAgIFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcbiAgICAgIFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcbiAgICAgIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgICBcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgICBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxuICAgICAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcbiAgICAgIFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXG4gICAgICBcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgICBcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXG4gICAgICBcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxuICAgICAgXCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcbiAgICAgIFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgICBcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxuICAgICAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxuICAgICAgXCJyZWRcIjogWzI1NSwgMCwgMF0sXG4gICAgICBcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgICBcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcbiAgICAgIFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcbiAgICAgIFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcbiAgICAgIFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICAgIFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcbiAgICAgIFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxuICAgICAgXCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcbiAgICAgIFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICAgIFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgICBcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcbiAgICAgIFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICAgIFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICAgIFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgICBcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXG4gICAgICBcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcbiAgICAgIFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcbiAgICAgIFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxuICAgICAgXCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICAgIFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG4gICAgICBcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcbiAgICAgIFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcbiAgICAgIFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuICAgICAgXCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICBcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxuICAgICAgXCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcbiAgICAgIFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvY29udmVyc2lvbnMuanNcbnZhciByZXF1aXJlX2NvbnZlcnNpb25zID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvY29udmVyc2lvbnMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGNzc0tleXdvcmRzID0gcmVxdWlyZV9jb2xvcl9uYW1lKCk7XG4gICAgdmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNzc0tleXdvcmRzKSkge1xuICAgICAgcmV2ZXJzZUtleXdvcmRzW2Nzc0tleXdvcmRzW2tleV1dID0ga2V5O1xuICAgIH1cbiAgICB2YXIgY29udmVydCA9IHtcbiAgICAgIHJnYjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInJnYlwiIH0sXG4gICAgICBoc2w6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc2xcIiB9LFxuICAgICAgaHN2OiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwiaHN2XCIgfSxcbiAgICAgIGh3YjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImh3YlwiIH0sXG4gICAgICBjbXlrOiB7IGNoYW5uZWxzOiA0LCBsYWJlbHM6IFwiY215a1wiIH0sXG4gICAgICB4eXo6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJ4eXpcIiB9LFxuICAgICAgbGFiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwibGFiXCIgfSxcbiAgICAgIGxjaDogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImxjaFwiIH0sXG4gICAgICBoZXg6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiaGV4XCJdIH0sXG4gICAgICBrZXl3b3JkOiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImtleXdvcmRcIl0gfSxcbiAgICAgIGFuc2kxNjogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJhbnNpMTZcIl0gfSxcbiAgICAgIGFuc2kyNTY6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiYW5zaTI1NlwiXSB9LFxuICAgICAgaGNnOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcImhcIiwgXCJjXCIsIFwiZ1wiXSB9LFxuICAgICAgYXBwbGU6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogW1wicjE2XCIsIFwiZzE2XCIsIFwiYjE2XCJdIH0sXG4gICAgICBncmF5OiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImdyYXlcIl0gfVxuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29udmVydDtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC5rZXlzKGNvbnZlcnQpKSB7XG4gICAgICBpZiAoIShcImNoYW5uZWxzXCIgaW4gY29udmVydFttb2RlbF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6IFwiICsgbW9kZWwpO1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsYWJlbHNcIiBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogXCIgKyBtb2RlbCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiBcIiArIG1vZGVsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY2hhbm5lbHMsIGxhYmVscyB9ID0gY29udmVydFttb2RlbF07XG4gICAgICBkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG4gICAgICBkZWxldGUgY29udmVydFttb2RlbF0ubGFiZWxzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCBcImNoYW5uZWxzXCIsIHsgdmFsdWU6IGNoYW5uZWxzIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCBcImxhYmVsc1wiLCB7IHZhbHVlOiBsYWJlbHMgfSk7XG4gICAgfVxuICAgIGNvbnZlcnQucmdiLmhzbCA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgICAgIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgY29uc3QgbWluMiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgY29uc3QgbWF4MiA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgY29uc3QgZGVsdGEgPSBtYXgyIC0gbWluMjtcbiAgICAgIGxldCBoO1xuICAgICAgbGV0IHM7XG4gICAgICBpZiAobWF4MiA9PT0gbWluMikge1xuICAgICAgICBoID0gMDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gbWF4Mikge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgyKSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChiID09PSBtYXgyKSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDM2MDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGwgPSAobWluMiArIG1heDIpIC8gMjtcbiAgICAgIGlmIChtYXgyID09PSBtaW4yKSB7XG4gICAgICAgIHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChsIDw9IDAuNSkge1xuICAgICAgICBzID0gZGVsdGEgLyAobWF4MiArIG1pbjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gKDIgLSBtYXgyIC0gbWluMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBsZXQgcmRpZjtcbiAgICAgIGxldCBnZGlmO1xuICAgICAgbGV0IGJkaWY7XG4gICAgICBsZXQgaDtcbiAgICAgIGxldCBzO1xuICAgICAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgICAgIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgY29uc3QgdiA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgY29uc3QgZGlmZiA9IHYgLSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIGNvbnN0IGRpZmZjID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiAodiAtIGMpIC8gNiAvIGRpZmYgKyAxIC8gMjtcbiAgICAgIH0sIFwiZGlmZmNcIik7XG4gICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICBoID0gMDtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gZGlmZiAvIHY7XG4gICAgICAgIHJkaWYgPSBkaWZmYyhyKTtcbiAgICAgICAgZ2RpZiA9IGRpZmZjKGcpO1xuICAgICAgICBiZGlmID0gZGlmZmMoYik7XG4gICAgICAgIGlmIChyID09PSB2KSB7XG4gICAgICAgICAgaCA9IGJkaWYgLSBnZGlmO1xuICAgICAgICB9IGVsc2UgaWYgKGcgPT09IHYpIHtcbiAgICAgICAgICBoID0gMSAvIDMgKyByZGlmIC0gYmRpZjtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSB2KSB7XG4gICAgICAgICAgaCA9IDIgLyAzICsgZ2RpZiAtIHJkaWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgaCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBoICogMzYwLFxuICAgICAgICBzICogMTAwLFxuICAgICAgICB2ICogMTAwXG4gICAgICBdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuaHdiID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBjb25zdCByID0gcmdiWzBdO1xuICAgICAgY29uc3QgZyA9IHJnYlsxXTtcbiAgICAgIGxldCBiID0gcmdiWzJdO1xuICAgICAgY29uc3QgaCA9IGNvbnZlcnQucmdiLmhzbChyZ2IpWzBdO1xuICAgICAgY29uc3QgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG4gICAgICBiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG4gICAgICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgICAgIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgY29uc3QgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICAgICAgY29uc3QgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgY29uc3QgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgcmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuICAgICAgcmV0dXJuICh4WzBdIC0geVswXSkgKiogMiArICh4WzFdIC0geVsxXSkgKiogMiArICh4WzJdIC0geVsyXSkgKiogMjtcbiAgICB9XG4gICAgX19uYW1lKGNvbXBhcmF0aXZlRGlzdGFuY2UsIFwiY29tcGFyYXRpdmVEaXN0YW5jZVwiKTtcbiAgICBjb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBjb25zdCByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuICAgICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZDtcbiAgICAgIH1cbiAgICAgIGxldCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICBsZXQgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIE9iamVjdC5rZXlzKGNzc0tleXdvcmRzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNzc0tleXdvcmRzW2tleXdvcmRdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgY3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbiAgICB9O1xuICAgIGNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgICByZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGxldCByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgbGV0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICBsZXQgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICAgIHIgPSByID4gMC4wNDA0NSA/ICgociArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQgOiByIC8gMTIuOTI7XG4gICAgICBnID0gZyA+IDAuMDQwNDUgPyAoKGcgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40IDogZyAvIDEyLjkyO1xuICAgICAgYiA9IGIgPiAwLjA0MDQ1ID8gKChiICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IGIgLyAxMi45MjtcbiAgICAgIGNvbnN0IHggPSByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDU7XG4gICAgICBjb25zdCB5ID0gciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyO1xuICAgICAgY29uc3QgeiA9IHIgKiAwLjAxOTMgKyBnICogMC4xMTkyICsgYiAqIDAuOTUwNTtcbiAgICAgIHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGNvbnN0IHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuICAgICAgbGV0IHggPSB4eXpbMF07XG4gICAgICBsZXQgeSA9IHh5elsxXTtcbiAgICAgIGxldCB6ID0geHl6WzJdO1xuICAgICAgeCAvPSA5NS4wNDc7XG4gICAgICB5IC89IDEwMDtcbiAgICAgIHogLz0gMTA4Ljg4MztcbiAgICAgIHggPSB4ID4gODg1NmUtNiA/IHggKiogKDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICAgICAgeSA9IHkgPiA4ODU2ZS02ID8geSAqKiAoMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gICAgICB6ID0geiA+IDg4NTZlLTYgPyB6ICoqICgxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNjtcbiAgICAgIGNvbnN0IGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICBjb25zdCBhID0gNTAwICogKHggLSB5KTtcbiAgICAgIGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uKGhzbCkge1xuICAgICAgY29uc3QgaCA9IGhzbFswXSAvIDM2MDtcbiAgICAgIGNvbnN0IHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgICBjb25zdCBsID0gaHNsWzJdIC8gMTAwO1xuICAgICAgbGV0IHQyO1xuICAgICAgbGV0IHQzO1xuICAgICAgbGV0IHZhbDtcbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG4gICAgICB9XG4gICAgICBpZiAobCA8IDAuNSkge1xuICAgICAgICB0MiA9IGwgKiAoMSArIHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdDIgPSBsICsgcyAtIGwgKiBzO1xuICAgICAgfVxuICAgICAgY29uc3QgdDEgPSAyICogbCAtIHQyO1xuICAgICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgdDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcbiAgICAgICAgaWYgKHQzIDwgMCkge1xuICAgICAgICAgIHQzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQzID4gMSkge1xuICAgICAgICAgIHQzLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDYgKiB0MyA8IDEpIHtcbiAgICAgICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0MztcbiAgICAgICAgfSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG4gICAgICAgICAgdmFsID0gdDI7XG4gICAgICAgIH0gZWxzZSBpZiAoMyAqIHQzIDwgMikge1xuICAgICAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSB0MTtcbiAgICAgICAgfVxuICAgICAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH07XG4gICAgY29udmVydC5oc2wuaHN2ID0gZnVuY3Rpb24oaHNsKSB7XG4gICAgICBjb25zdCBoID0gaHNsWzBdO1xuICAgICAgbGV0IHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgICBsZXQgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICAgIGxldCBzbWluID0gcztcbiAgICAgIGNvbnN0IGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcbiAgICAgIGwgKj0gMjtcbiAgICAgIHMgKj0gbCA8PSAxID8gbCA6IDIgLSBsO1xuICAgICAgc21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG4gICAgICBjb25zdCB2ID0gKGwgKyBzKSAvIDI7XG4gICAgICBjb25zdCBzdiA9IGwgPT09IDAgPyAyICogc21pbiAvIChsbWluICsgc21pbikgOiAyICogcyAvIChsICsgcyk7XG4gICAgICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uKGhzdikge1xuICAgICAgY29uc3QgaCA9IGhzdlswXSAvIDYwO1xuICAgICAgY29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICAgIGxldCB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgY29uc3QgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcbiAgICAgIGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICAgIGNvbnN0IHAgPSAyNTUgKiB2ICogKDEgLSBzKTtcbiAgICAgIGNvbnN0IHEgPSAyNTUgKiB2ICogKDEgLSBzICogZik7XG4gICAgICBjb25zdCB0ID0gMjU1ICogdiAqICgxIC0gcyAqICgxIC0gZikpO1xuICAgICAgdiAqPSAyNTU7XG4gICAgICBzd2l0Y2ggKGhpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gW3YsIHQsIHBdO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gW3AsIHEsIHZdO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbihoc3YpIHtcbiAgICAgIGNvbnN0IGggPSBoc3ZbMF07XG4gICAgICBjb25zdCBzID0gaHN2WzFdIC8gMTAwO1xuICAgICAgY29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICAgIGNvbnN0IHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcbiAgICAgIGxldCBzbDtcbiAgICAgIGxldCBsO1xuICAgICAgbCA9ICgyIC0gcykgKiB2O1xuICAgICAgY29uc3QgbG1pbiA9ICgyIC0gcykgKiB2bWluO1xuICAgICAgc2wgPSBzICogdm1pbjtcbiAgICAgIHNsIC89IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcbiAgICAgIHNsID0gc2wgfHwgMDtcbiAgICAgIGwgLz0gMjtcbiAgICAgIHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5od2IucmdiID0gZnVuY3Rpb24oaHdiKSB7XG4gICAgICBjb25zdCBoID0gaHdiWzBdIC8gMzYwO1xuICAgICAgbGV0IHdoID0gaHdiWzFdIC8gMTAwO1xuICAgICAgbGV0IGJsID0gaHdiWzJdIC8gMTAwO1xuICAgICAgY29uc3QgcmF0aW8gPSB3aCArIGJsO1xuICAgICAgbGV0IGY7XG4gICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgIHdoIC89IHJhdGlvO1xuICAgICAgICBibCAvPSByYXRpbztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgICAgIGNvbnN0IHYgPSAxIC0gYmw7XG4gICAgICBmID0gNiAqIGggLSBpO1xuICAgICAgaWYgKChpICYgMSkgIT09IDApIHtcbiAgICAgICAgZiA9IDEgLSBmO1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IHdoICsgZiAqICh2IC0gd2gpO1xuICAgICAgbGV0IHI7XG4gICAgICBsZXQgZztcbiAgICAgIGxldCBiO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSBuO1xuICAgICAgICAgIGIgPSB3aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSB3aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHIgPSB3aDtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSB3aDtcbiAgICAgICAgICBnID0gbjtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgIGcgPSB3aDtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSB3aDtcbiAgICAgICAgICBiID0gbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcbiAgICBjb252ZXJ0LmNteWsucmdiID0gZnVuY3Rpb24oY215aykge1xuICAgICAgY29uc3QgYyA9IGNteWtbMF0gLyAxMDA7XG4gICAgICBjb25zdCBtID0gY215a1sxXSAvIDEwMDtcbiAgICAgIGNvbnN0IHkgPSBjbXlrWzJdIC8gMTAwO1xuICAgICAgY29uc3QgayA9IGNteWtbM10gLyAxMDA7XG4gICAgICBjb25zdCByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG4gICAgICBjb25zdCBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gICAgICBjb25zdCBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gICAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xuICAgIH07XG4gICAgY29udmVydC54eXoucmdiID0gZnVuY3Rpb24oeHl6KSB7XG4gICAgICBjb25zdCB4ID0geHl6WzBdIC8gMTAwO1xuICAgICAgY29uc3QgeSA9IHh5elsxXSAvIDEwMDtcbiAgICAgIGNvbnN0IHogPSB4eXpbMl0gLyAxMDA7XG4gICAgICBsZXQgcjtcbiAgICAgIGxldCBnO1xuICAgICAgbGV0IGI7XG4gICAgICByID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODY7XG4gICAgICBnID0geCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNTtcbiAgICAgIGIgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNCArIHogKiAxLjA1NztcbiAgICAgIHIgPSByID4gMzEzMDhlLTcgPyAxLjA1NSAqIHIgKiogKDEgLyAyLjQpIC0gMC4wNTUgOiByICogMTIuOTI7XG4gICAgICBnID0gZyA+IDMxMzA4ZS03ID8gMS4wNTUgKiBnICoqICgxIC8gMi40KSAtIDAuMDU1IDogZyAqIDEyLjkyO1xuICAgICAgYiA9IGIgPiAzMTMwOGUtNyA/IDEuMDU1ICogYiAqKiAoMSAvIDIuNCkgLSAwLjA1NSA6IGIgKiAxMi45MjtcbiAgICAgIHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG4gICAgICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICAgICAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcbiAgICBjb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbih4eXopIHtcbiAgICAgIGxldCB4ID0geHl6WzBdO1xuICAgICAgbGV0IHkgPSB4eXpbMV07XG4gICAgICBsZXQgeiA9IHh5elsyXTtcbiAgICAgIHggLz0gOTUuMDQ3O1xuICAgICAgeSAvPSAxMDA7XG4gICAgICB6IC89IDEwOC44ODM7XG4gICAgICB4ID0geCA+IDg4NTZlLTYgPyB4ICoqICgxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNjtcbiAgICAgIHkgPSB5ID4gODg1NmUtNiA/IHkgKiogKDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2O1xuICAgICAgeiA9IHogPiA4ODU2ZS02ID8geiAqKiAoMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTY7XG4gICAgICBjb25zdCBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgY29uc3QgYSA9IDUwMCAqICh4IC0geSk7XG4gICAgICBjb25zdCBiID0gMjAwICogKHkgLSB6KTtcbiAgICAgIHJldHVybiBbbCwgYSwgYl07XG4gICAgfTtcbiAgICBjb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbihsYWIpIHtcbiAgICAgIGNvbnN0IGwgPSBsYWJbMF07XG4gICAgICBjb25zdCBhID0gbGFiWzFdO1xuICAgICAgY29uc3QgYiA9IGxhYlsyXTtcbiAgICAgIGxldCB4O1xuICAgICAgbGV0IHk7XG4gICAgICBsZXQgejtcbiAgICAgIHkgPSAobCArIDE2KSAvIDExNjtcbiAgICAgIHggPSBhIC8gNTAwICsgeTtcbiAgICAgIHogPSB5IC0gYiAvIDIwMDtcbiAgICAgIGNvbnN0IHkyID0geSAqKiAzO1xuICAgICAgY29uc3QgeDIgPSB4ICoqIDM7XG4gICAgICBjb25zdCB6MiA9IHogKiogMztcbiAgICAgIHkgPSB5MiA+IDg4NTZlLTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgICB4ID0geDIgPiA4ODU2ZS02ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgICAgeiA9IHoyID4gODg1NmUtNiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICAgIHggKj0gOTUuMDQ3O1xuICAgICAgeSAqPSAxMDA7XG4gICAgICB6ICo9IDEwOC44ODM7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH07XG4gICAgY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24obGFiKSB7XG4gICAgICBjb25zdCBsID0gbGFiWzBdO1xuICAgICAgY29uc3QgYSA9IGxhYlsxXTtcbiAgICAgIGNvbnN0IGIgPSBsYWJbMl07XG4gICAgICBsZXQgaDtcbiAgICAgIGNvbnN0IGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICAgIGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIHJldHVybiBbbCwgYywgaF07XG4gICAgfTtcbiAgICBjb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbihsY2gpIHtcbiAgICAgIGNvbnN0IGwgPSBsY2hbMF07XG4gICAgICBjb25zdCBjID0gbGNoWzFdO1xuICAgICAgY29uc3QgaCA9IGxjaFsyXTtcbiAgICAgIGNvbnN0IGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICAgICAgY29uc3QgYSA9IGMgKiBNYXRoLmNvcyhocik7XG4gICAgICBjb25zdCBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgICAgIHJldHVybiBbbCwgYSwgYl07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbihhcmdzLCBzYXR1cmF0aW9uID0gbnVsbCkge1xuICAgICAgY29uc3QgW3IsIGcsIGJdID0gYXJncztcbiAgICAgIGxldCB2YWx1ZSA9IHNhdHVyYXRpb24gPT09IG51bGwgPyBjb252ZXJ0LnJnYi5oc3YoYXJncylbMl0gOiBzYXR1cmF0aW9uO1xuICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgIH1cbiAgICAgIGxldCBhbnNpID0gMzAgKyAoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyIHwgTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxIHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG4gICAgICBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgYW5zaSArPSA2MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbnNpO1xuICAgIH07XG4gICAgY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgcmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGNvbnN0IHIgPSBhcmdzWzBdO1xuICAgICAgY29uc3QgZyA9IGFyZ3NbMV07XG4gICAgICBjb25zdCBiID0gYXJnc1syXTtcbiAgICAgIGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcbiAgICAgICAgaWYgKHIgPCA4KSB7XG4gICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyID4gMjQ4KSB7XG4gICAgICAgICAgcmV0dXJuIDIzMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgociAtIDgpIC8gMjQ3ICogMjQpICsgMjMyO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zaSA9IDE2ICsgMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSArIDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSArIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuICAgICAgcmV0dXJuIGFuc2k7XG4gICAgfTtcbiAgICBjb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICBsZXQgY29sb3IgPSBhcmdzICUgMTA7XG4gICAgICBpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcbiAgICAgICAgaWYgKGFyZ3MgPiA1MCkge1xuICAgICAgICAgIGNvbG9yICs9IDMuNTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcbiAgICAgICAgcmV0dXJuIFtjb2xvciwgY29sb3IsIGNvbG9yXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG11bHQgPSAofn4oYXJncyA+IDUwKSArIDEpICogMC41O1xuICAgICAgY29uc3QgciA9IChjb2xvciAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIGNvbnN0IGcgPSAoY29sb3IgPj4gMSAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIGNvbnN0IGIgPSAoY29sb3IgPj4gMiAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcbiAgICBjb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgaWYgKGFyZ3MgPj0gMjMyKSB7XG4gICAgICAgIGNvbnN0IGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG4gICAgICAgIHJldHVybiBbYywgYywgY107XG4gICAgICB9XG4gICAgICBhcmdzIC09IDE2O1xuICAgICAgbGV0IHJlbTtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuICAgICAgY29uc3QgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG4gICAgICBjb25zdCBiID0gcmVtICUgNiAvIDUgKiAyNTU7XG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgY29uc3QgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDI1NSkgPDwgMTYpICsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMjU1KSA8PCA4KSArIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMjU1KTtcbiAgICAgIGNvbnN0IHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gXCIwMDAwMDBcIi5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG4gICAgfTtcbiAgICBjb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIGxldCBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KFwiXCIpLm1hcCgoY2hhcikgPT4ge1xuICAgICAgICAgIHJldHVybiBjaGFyICsgY2hhcjtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuICAgICAgY29uc3QgciA9IGludGVnZXIgPj4gMTYgJiAyNTU7XG4gICAgICBjb25zdCBnID0gaW50ZWdlciA+PiA4ICYgMjU1O1xuICAgICAgY29uc3QgYiA9IGludGVnZXIgJiAyNTU7XG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgICBjb25zdCBtYXgyID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuICAgICAgY29uc3QgbWluMiA9IE1hdGgubWluKE1hdGgubWluKHIsIGcpLCBiKTtcbiAgICAgIGNvbnN0IGNocm9tYSA9IG1heDIgLSBtaW4yO1xuICAgICAgbGV0IGdyYXlzY2FsZTtcbiAgICAgIGxldCBodWU7XG4gICAgICBpZiAoY2hyb21hIDwgMSkge1xuICAgICAgICBncmF5c2NhbGUgPSBtaW4yIC8gKDEgLSBjaHJvbWEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JheXNjYWxlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjaHJvbWEgPD0gMCkge1xuICAgICAgICBodWUgPSAwO1xuICAgICAgfSBlbHNlIGlmIChtYXgyID09PSByKSB7XG4gICAgICAgIGh1ZSA9IChnIC0gYikgLyBjaHJvbWEgJSA2O1xuICAgICAgfSBlbHNlIGlmIChtYXgyID09PSBnKSB7XG4gICAgICAgIGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHVlID0gNCArIChyIC0gZykgLyBjaHJvbWE7XG4gICAgICB9XG4gICAgICBodWUgLz0gNjtcbiAgICAgIGh1ZSAlPSAxO1xuICAgICAgcmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uKGhzbCkge1xuICAgICAgY29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgICBjb25zdCBjID0gbCA8IDAuNSA/IDIgKiBzICogbCA6IDIgKiBzICogKDEgLSBsKTtcbiAgICAgIGxldCBmID0gMDtcbiAgICAgIGlmIChjIDwgMSkge1xuICAgICAgICBmID0gKGwgLSAwLjUgKiBjKSAvICgxIC0gYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbihoc3YpIHtcbiAgICAgIGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgICBjb25zdCB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgY29uc3QgYyA9IHMgKiB2O1xuICAgICAgbGV0IGYgPSAwO1xuICAgICAgaWYgKGMgPCAxKSB7XG4gICAgICAgIGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uKGhjZykge1xuICAgICAgY29uc3QgaCA9IGhjZ1swXSAvIDM2MDtcbiAgICAgIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICBjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1cmUgPSBbMCwgMCwgMF07XG4gICAgICBjb25zdCBoaSA9IGggJSAxICogNjtcbiAgICAgIGNvbnN0IHYgPSBoaSAlIDE7XG4gICAgICBjb25zdCB3ID0gMSAtIHY7XG4gICAgICBsZXQgbWcgPSAwO1xuICAgICAgc3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcHVyZVswXSA9IDE7XG4gICAgICAgICAgcHVyZVsxXSA9IHY7XG4gICAgICAgICAgcHVyZVsyXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwdXJlWzBdID0gdztcbiAgICAgICAgICBwdXJlWzFdID0gMTtcbiAgICAgICAgICBwdXJlWzJdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHB1cmVbMF0gPSAwO1xuICAgICAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgICAgIHB1cmVbMl0gPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVyZVswXSA9IDA7XG4gICAgICAgICAgcHVyZVsxXSA9IHc7XG4gICAgICAgICAgcHVyZVsyXSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwdXJlWzBdID0gdjtcbiAgICAgICAgICBwdXJlWzFdID0gMDtcbiAgICAgICAgICBwdXJlWzJdID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXJlWzBdID0gMTtcbiAgICAgICAgICBwdXJlWzFdID0gMDtcbiAgICAgICAgICBwdXJlWzJdID0gdztcbiAgICAgIH1cbiAgICAgIG1nID0gKDEgLSBjKSAqIGc7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsXG4gICAgICAgIChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcbiAgICAgICAgKGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG4gICAgICBdO1xuICAgIH07XG4gICAgY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24oaGNnKSB7XG4gICAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgY29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIGNvbnN0IHYgPSBjICsgZyAqICgxIC0gYyk7XG4gICAgICBsZXQgZiA9IDA7XG4gICAgICBpZiAodiA+IDApIHtcbiAgICAgICAgZiA9IGMgLyB2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5oY2cuaHNsID0gZnVuY3Rpb24oaGNnKSB7XG4gICAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgY29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIGNvbnN0IGwgPSBnICogKDEgLSBjKSArIDAuNSAqIGM7XG4gICAgICBsZXQgcyA9IDA7XG4gICAgICBpZiAobCA+IDAgJiYgbCA8IDAuNSkge1xuICAgICAgICBzID0gYyAvICgyICogbCk7XG4gICAgICB9IGVsc2UgaWYgKGwgPj0gMC41ICYmIGwgPCAxKSB7XG4gICAgICAgIHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaGNnLmh3YiA9IGZ1bmN0aW9uKGhjZykge1xuICAgICAgY29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgICBjb25zdCB2ID0gYyArIGcgKiAoMSAtIGMpO1xuICAgICAgcmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24oaHdiKSB7XG4gICAgICBjb25zdCB3ID0gaHdiWzFdIC8gMTAwO1xuICAgICAgY29uc3QgYiA9IGh3YlsyXSAvIDEwMDtcbiAgICAgIGNvbnN0IHYgPSAxIC0gYjtcbiAgICAgIGNvbnN0IGMgPSB2IC0gdztcbiAgICAgIGxldCBnID0gMDtcbiAgICAgIGlmIChjIDwgMSkge1xuICAgICAgICBnID0gKHYgLSBjKSAvICgxIC0gYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uKGFwcGxlKSB7XG4gICAgICByZXR1cm4gW2FwcGxlWzBdIC8gNjU1MzUgKiAyNTUsIGFwcGxlWzFdIC8gNjU1MzUgKiAyNTUsIGFwcGxlWzJdIC8gNjU1MzUgKiAyNTVdO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIHJldHVybiBbcmdiWzBdIC8gMjU1ICogNjU1MzUsIHJnYlsxXSAvIDI1NSAqIDY1NTM1LCByZ2JbMl0gLyAyNTUgKiA2NTUzNV07XG4gICAgfTtcbiAgICBjb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgcmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbiAgICB9O1xuICAgIGNvbnZlcnQuZ3JheS5oc2wgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xuICAgIH07XG4gICAgY29udmVydC5ncmF5LmhzdiA9IGNvbnZlcnQuZ3JheS5oc2w7XG4gICAgY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uKGdyYXkpIHtcbiAgICAgIHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24oZ3JheSkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbihncmF5KSB7XG4gICAgICByZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xuICAgIH07XG4gICAgY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uKGdyYXkpIHtcbiAgICAgIGNvbnN0IHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAyNTU7XG4gICAgICBjb25zdCBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBcIjAwMDAwMFwiLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbiAgICB9O1xuICAgIGNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGNvbnN0IHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcbiAgICAgIHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvcm91dGUuanNcbnZhciByZXF1aXJlX3JvdXRlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvcm91dGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZV9jb252ZXJzaW9ucygpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG4gICAgICBjb25zdCBncmFwaCA9IHt9O1xuICAgICAgY29uc3QgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuICAgICAgZm9yIChsZXQgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBncmFwaFttb2RlbHNbaV1dID0ge1xuICAgICAgICAgIGRpc3RhbmNlOiAtMSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkR3JhcGgsIFwiYnVpbGRHcmFwaFwiKTtcbiAgICBmdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG4gICAgICBjb25zdCBncmFwaCA9IGJ1aWxkR3JhcGgoKTtcbiAgICAgIGNvbnN0IHF1ZXVlID0gW2Zyb21Nb2RlbF07XG4gICAgICBncmFwaFtmcm9tTW9kZWxdLmRpc3RhbmNlID0gMDtcbiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBjb25zdCBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG4gICAgICAgIGZvciAobGV0IGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcbiAgICAgICAgICBjb25zdCBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuICAgICAgICAgIGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICBfX25hbWUoZGVyaXZlQkZTLCBcImRlcml2ZUJGU1wiKTtcbiAgICBmdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gdG8oZnJvbShhcmdzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUobGluaywgXCJsaW5rXCIpO1xuICAgIGZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG4gICAgICBjb25zdCBwYXRoNyA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuICAgICAgbGV0IGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcbiAgICAgIGxldCBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG4gICAgICB3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcbiAgICAgICAgcGF0aDcudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG4gICAgICAgIGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuICAgICAgICBjdXIgPSBncmFwaFtjdXJdLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGZuLmNvbnZlcnNpb24gPSBwYXRoNztcbiAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgX19uYW1lKHdyYXBDb252ZXJzaW9uLCBcIndyYXBDb252ZXJzaW9uXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGZyb21Nb2RlbCkge1xuICAgICAgY29uc3QgZ3JhcGggPSBkZXJpdmVCRlMoZnJvbU1vZGVsKTtcbiAgICAgIGNvbnN0IGNvbnZlcnNpb24gPSB7fTtcbiAgICAgIGNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcbiAgICAgIGZvciAobGV0IGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnZlcnNpb247XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jb2xvci1jb252ZXJ0QDIuMC4xL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9jb2xvcl9jb252ZXJ0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZV9jb252ZXJzaW9ucygpO1xuICAgIHZhciByb3V0ZSA9IHJlcXVpcmVfcm91dGUoKTtcbiAgICB2YXIgY29udmVydCA9IHt9O1xuICAgIHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG4gICAgZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuICAgICAgY29uc3Qgd3JhcHBlZEZuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoYXJnMCA9PT0gdm9pZCAwIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJnMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnMC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncyA9IGFyZzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKGFyZ3MpO1xuICAgICAgfSwgXCJ3cmFwcGVkRm5cIik7XG4gICAgICBpZiAoXCJjb252ZXJzaW9uXCIgaW4gZm4pIHtcbiAgICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWRGbjtcbiAgICB9XG4gICAgX19uYW1lKHdyYXBSYXcsIFwid3JhcFJhd1wiKTtcbiAgICBmdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuICAgICAgY29uc3Qgd3JhcHBlZEZuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoYXJnMCA9PT0gdm9pZCAwIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJnMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnMC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncyA9IGFyZzA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgXCJ3cmFwcGVkRm5cIik7XG4gICAgICBpZiAoXCJjb252ZXJzaW9uXCIgaW4gZm4pIHtcbiAgICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWRGbjtcbiAgICB9XG4gICAgX19uYW1lKHdyYXBSb3VuZGVkLCBcIndyYXBSb3VuZGVkXCIpO1xuICAgIG1vZGVscy5mb3JFYWNoKChmcm9tTW9kZWwpID0+IHtcbiAgICAgIGNvbnZlcnRbZnJvbU1vZGVsXSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgXCJjaGFubmVsc1wiLCB7IHZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmNoYW5uZWxzIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgXCJsYWJlbHNcIiwgeyB2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHMgfSk7XG4gICAgICBjb25zdCByb3V0ZXMgPSByb3V0ZShmcm9tTW9kZWwpO1xuICAgICAgY29uc3Qgcm91dGVNb2RlbHMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xuICAgICAgcm91dGVNb2RlbHMuZm9yRWFjaCgodG9Nb2RlbCkgPT4ge1xuICAgICAgICBjb25zdCBmbiA9IHJvdXRlc1t0b01vZGVsXTtcbiAgICAgICAgY29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuICAgICAgICBjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBjb252ZXJ0O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Fuc2ktc3R5bGVzQDQuMy4wL25vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfYW5zaV9zdHlsZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYW5zaS1zdHlsZXNANC4zLjAvbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB3cmFwQW5zaTE2ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZm4sIG9mZnNldCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBmbiguLi5hcmdzKTtcbiAgICAgIHJldHVybiBgXFx4MUJbJHtjb2RlICsgb2Zmc2V0fW1gO1xuICAgIH0sIFwid3JhcEFuc2kxNlwiKTtcbiAgICB2YXIgd3JhcEFuc2kyNTYgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmbiwgb2Zmc2V0KSA9PiAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY29kZSA9IGZuKC4uLmFyZ3MpO1xuICAgICAgcmV0dXJuIGBcXHgxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcbiAgICB9LCBcIndyYXBBbnNpMjU2XCIpO1xuICAgIHZhciB3cmFwQW5zaTE2bSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCByZ2IgPSBmbiguLi5hcmdzKTtcbiAgICAgIHJldHVybiBgXFx4MUJbJHszOCArIG9mZnNldH07Mjske3JnYlswXX07JHtyZ2JbMV19OyR7cmdiWzJdfW1gO1xuICAgIH0sIFwid3JhcEFuc2kxNm1cIik7XG4gICAgdmFyIGFuc2kyYW5zaSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG4pID0+IG4sIFwiYW5zaTJhbnNpXCIpO1xuICAgIHZhciByZ2IycmdiID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgociwgZywgYikgPT4gW3IsIGcsIGJdLCBcInJnYjJyZ2JcIik7XG4gICAgdmFyIHNldExhenlQcm9wZXJ0eSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9iamVjdCwgcHJvcGVydHksIGdldCkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQoKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIFwic2V0TGF6eVByb3BlcnR5XCIpO1xuICAgIHZhciBjb2xvckNvbnZlcnQ7XG4gICAgdmFyIG1ha2VEeW5hbWljU3R5bGVzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgod3JhcCwgdGFyZ2V0U3BhY2UsIGlkZW50aXR5MiwgaXNCYWNrZ3JvdW5kKSA9PiB7XG4gICAgICBpZiAoY29sb3JDb252ZXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29sb3JDb252ZXJ0ID0gcmVxdWlyZV9jb2xvcl9jb252ZXJ0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2tncm91bmQgPyAxMCA6IDA7XG4gICAgICBjb25zdCBzdHlsZXMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW3NvdXJjZVNwYWNlLCBzdWl0ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29sb3JDb252ZXJ0KSkge1xuICAgICAgICBjb25zdCBuYW1lID0gc291cmNlU3BhY2UgPT09IFwiYW5zaTE2XCIgPyBcImFuc2lcIiA6IHNvdXJjZVNwYWNlO1xuICAgICAgICBpZiAoc291cmNlU3BhY2UgPT09IHRhcmdldFNwYWNlKSB7XG4gICAgICAgICAgc3R5bGVzW25hbWVdID0gd3JhcChpZGVudGl0eTIsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1aXRlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgc3R5bGVzW25hbWVdID0gd3JhcChzdWl0ZVt0YXJnZXRTcGFjZV0sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSwgXCJtYWtlRHluYW1pY1N0eWxlc1wiKTtcbiAgICBmdW5jdGlvbiBhc3NlbWJsZVN0eWxlcygpIHtcbiAgICAgIGNvbnN0IGNvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgICAgbW9kaWZpZXI6IHtcbiAgICAgICAgICByZXNldDogWzAsIDBdLFxuICAgICAgICAgIGJvbGQ6IFsxLCAyMl0sXG4gICAgICAgICAgZGltOiBbMiwgMjJdLFxuICAgICAgICAgIGl0YWxpYzogWzMsIDIzXSxcbiAgICAgICAgICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gICAgICAgICAgaW52ZXJzZTogWzcsIDI3XSxcbiAgICAgICAgICBoaWRkZW46IFs4LCAyOF0sXG4gICAgICAgICAgc3RyaWtldGhyb3VnaDogWzksIDI5XVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGJsYWNrOiBbMzAsIDM5XSxcbiAgICAgICAgICByZWQ6IFszMSwgMzldLFxuICAgICAgICAgIGdyZWVuOiBbMzIsIDM5XSxcbiAgICAgICAgICB5ZWxsb3c6IFszMywgMzldLFxuICAgICAgICAgIGJsdWU6IFszNCwgMzldLFxuICAgICAgICAgIG1hZ2VudGE6IFszNSwgMzldLFxuICAgICAgICAgIGN5YW46IFszNiwgMzldLFxuICAgICAgICAgIHdoaXRlOiBbMzcsIDM5XSxcbiAgICAgICAgICBibGFja0JyaWdodDogWzkwLCAzOV0sXG4gICAgICAgICAgcmVkQnJpZ2h0OiBbOTEsIDM5XSxcbiAgICAgICAgICBncmVlbkJyaWdodDogWzkyLCAzOV0sXG4gICAgICAgICAgeWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcbiAgICAgICAgICBibHVlQnJpZ2h0OiBbOTQsIDM5XSxcbiAgICAgICAgICBtYWdlbnRhQnJpZ2h0OiBbOTUsIDM5XSxcbiAgICAgICAgICBjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcbiAgICAgICAgICB3aGl0ZUJyaWdodDogWzk3LCAzOV1cbiAgICAgICAgfSxcbiAgICAgICAgYmdDb2xvcjoge1xuICAgICAgICAgIGJnQmxhY2s6IFs0MCwgNDldLFxuICAgICAgICAgIGJnUmVkOiBbNDEsIDQ5XSxcbiAgICAgICAgICBiZ0dyZWVuOiBbNDIsIDQ5XSxcbiAgICAgICAgICBiZ1llbGxvdzogWzQzLCA0OV0sXG4gICAgICAgICAgYmdCbHVlOiBbNDQsIDQ5XSxcbiAgICAgICAgICBiZ01hZ2VudGE6IFs0NSwgNDldLFxuICAgICAgICAgIGJnQ3lhbjogWzQ2LCA0OV0sXG4gICAgICAgICAgYmdXaGl0ZTogWzQ3LCA0OV0sXG4gICAgICAgICAgYmdCbGFja0JyaWdodDogWzEwMCwgNDldLFxuICAgICAgICAgIGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG4gICAgICAgICAgYmdHcmVlbkJyaWdodDogWzEwMiwgNDldLFxuICAgICAgICAgIGJnWWVsbG93QnJpZ2h0OiBbMTAzLCA0OV0sXG4gICAgICAgICAgYmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG4gICAgICAgICAgYmdNYWdlbnRhQnJpZ2h0OiBbMTA1LCA0OV0sXG4gICAgICAgICAgYmdDeWFuQnJpZ2h0OiBbMTA2LCA0OV0sXG4gICAgICAgICAgYmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzdHlsZXMuY29sb3IuZ3JheSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG4gICAgICBzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmJnR3JleSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG4gICAgICBmb3IgKGNvbnN0IFtncm91cE5hbWUsIGdyb3VwXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVdIG9mIE9iamVjdC5lbnRyaWVzKGdyb3VwKSkge1xuICAgICAgICAgIHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuICAgICAgICAgICAgb3BlbjogYFxceDFCWyR7c3R5bGVbMF19bWAsXG4gICAgICAgICAgICBjbG9zZTogYFxceDFCWyR7c3R5bGVbMV19bWBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogZ3JvdXAsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBcImNvZGVzXCIsIHtcbiAgICAgICAgdmFsdWU6IGNvZGVzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBzdHlsZXMuY29sb3IuY2xvc2UgPSBcIlxceDFCWzM5bVwiO1xuICAgICAgc3R5bGVzLmJnQ29sb3IuY2xvc2UgPSBcIlxceDFCWzQ5bVwiO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5jb2xvciwgXCJhbnNpXCIsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsIFwiYW5zaTE2XCIsIGFuc2kyYW5zaSwgZmFsc2UpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsIFwiYW5zaTI1NlwiLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTI1NiwgXCJhbnNpMjU2XCIsIGFuc2kyYW5zaSwgZmFsc2UpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsIFwiYW5zaTE2bVwiLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTE2bSwgXCJyZ2JcIiwgcmdiMnJnYiwgZmFsc2UpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuYmdDb2xvciwgXCJhbnNpXCIsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsIFwiYW5zaTE2XCIsIGFuc2kyYW5zaSwgdHJ1ZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCBcImFuc2kyNTZcIiwgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kyNTYsIFwiYW5zaTI1NlwiLCBhbnNpMmFuc2ksIHRydWUpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuYmdDb2xvciwgXCJhbnNpMTZtXCIsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTZtLCBcInJnYlwiLCByZ2IycmdiLCB0cnVlKSk7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbiAgICBfX25hbWUoYXNzZW1ibGVTdHlsZXMsIFwiYXNzZW1ibGVTdHlsZXNcIik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZTIsIFwiZXhwb3J0c1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBhc3NlbWJsZVN0eWxlc1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhcy1mbGFnQDQuMC4wL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qc1xudmFyIHJlcXVpcmVfaGFzX2ZsYWcgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzLWZsYWdANC4wLjAvbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChmbGFnLCBhcmd2ID0gcHJvY2Vzcy5hcmd2KSA9PiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBmbGFnLnN0YXJ0c1dpdGgoXCItXCIpID8gXCJcIiA6IGZsYWcubGVuZ3RoID09PSAxID8gXCItXCIgOiBcIi0tXCI7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcbiAgICAgIGNvbnN0IHRlcm1pbmF0b3JQb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZihcIi0tXCIpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uICE9PSAtMSAmJiAodGVybWluYXRvclBvc2l0aW9uID09PSAtMSB8fCBwb3NpdGlvbiA8IHRlcm1pbmF0b3JQb3NpdGlvbik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdXBwb3J0cy1jb2xvckA3LjIuMC9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanNcbnZhciByZXF1aXJlX3N1cHBvcnRzX2NvbG9yID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cHBvcnRzLWNvbG9yQDcuMi4wL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgb3MzID0gcmVxdWlyZShcIm9zXCIpO1xuICAgIHZhciB0dHkgPSByZXF1aXJlKFwidHR5XCIpO1xuICAgIHZhciBoYXNGbGFnID0gcmVxdWlyZV9oYXNfZmxhZygpO1xuICAgIHZhciB7IGVudjogZW52MiB9ID0gcHJvY2VzcztcbiAgICB2YXIgZm9yY2VDb2xvcjtcbiAgICBpZiAoaGFzRmxhZyhcIm5vLWNvbG9yXCIpIHx8IGhhc0ZsYWcoXCJuby1jb2xvcnNcIikgfHwgaGFzRmxhZyhcImNvbG9yPWZhbHNlXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj1uZXZlclwiKSkge1xuICAgICAgZm9yY2VDb2xvciA9IDA7XG4gICAgfSBlbHNlIGlmIChoYXNGbGFnKFwiY29sb3JcIikgfHwgaGFzRmxhZyhcImNvbG9yc1wiKSB8fCBoYXNGbGFnKFwiY29sb3I9dHJ1ZVwiKSB8fCBoYXNGbGFnKFwiY29sb3I9YWx3YXlzXCIpKSB7XG4gICAgICBmb3JjZUNvbG9yID0gMTtcbiAgICB9XG4gICAgaWYgKFwiRk9SQ0VfQ09MT1JcIiBpbiBlbnYyKSB7XG4gICAgICBpZiAoZW52Mi5GT1JDRV9DT0xPUiA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgZm9yY2VDb2xvciA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGVudjIuRk9SQ0VfQ09MT1IgPT09IFwiZmFsc2VcIikge1xuICAgICAgICBmb3JjZUNvbG9yID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlQ29sb3IgPSBlbnYyLkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYyLkZPUkNFX0NPTE9SLCAxMCksIDMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxldmVsLFxuICAgICAgICBoYXNCYXNpYzogdHJ1ZSxcbiAgICAgICAgaGFzMjU2OiBsZXZlbCA+PSAyLFxuICAgICAgICBoYXMxNm06IGxldmVsID49IDNcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZSh0cmFuc2xhdGVMZXZlbCwgXCJ0cmFuc2xhdGVMZXZlbFwiKTtcbiAgICBmdW5jdGlvbiBzdXBwb3J0c0NvbG9yKGhhdmVTdHJlYW0sIHN0cmVhbUlzVFRZKSB7XG4gICAgICBpZiAoZm9yY2VDb2xvciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNGbGFnKFwiY29sb3I9MTZtXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj1mdWxsXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj10cnVlY29sb3JcIikpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRmxhZyhcImNvbG9yPTI1NlwiKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW4yID0gZm9yY2VDb2xvciB8fCAwO1xuICAgICAgaWYgKGVudjIuVEVSTSA9PT0gXCJkdW1iXCIpIHtcbiAgICAgICAgcmV0dXJuIG1pbjI7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIGNvbnN0IG9zUmVsZWFzZSA9IG9zMy5yZWxlYXNlKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoTnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiYgTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODYpIHtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChcIkNJXCIgaW4gZW52Mikge1xuICAgICAgICBpZiAoW1wiVFJBVklTXCIsIFwiQ0lSQ0xFQ0lcIiwgXCJBUFBWRVlPUlwiLCBcIkdJVExBQl9DSVwiLCBcIkdJVEhVQl9BQ1RJT05TXCIsIFwiQlVJTERLSVRFXCJdLnNvbWUoKHNpZ24yKSA9PiBzaWduMiBpbiBlbnYyKSB8fCBlbnYyLkNJX05BTUUgPT09IFwiY29kZXNoaXBcIikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4yO1xuICAgICAgfVxuICAgICAgaWYgKFwiVEVBTUNJVFlfVkVSU0lPTlwiIGluIGVudjIpIHtcbiAgICAgICAgcmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudjIuVEVBTUNJVFlfVkVSU0lPTikgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChlbnYyLkNPTE9SVEVSTSA9PT0gXCJ0cnVlY29sb3JcIikge1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH1cbiAgICAgIGlmIChcIlRFUk1fUFJPR1JBTVwiIGluIGVudjIpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYyLlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8IFwiXCIpLnNwbGl0KFwiLlwiKVswXSwgMTApO1xuICAgICAgICBzd2l0Y2ggKGVudjIuVEVSTV9QUk9HUkFNKSB7XG4gICAgICAgICAgY2FzZSBcImlUZXJtLmFwcFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuICAgICAgICAgIGNhc2UgXCJBcHBsZV9UZXJtaW5hbFwiOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52Mi5URVJNKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfF52dDIyMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52Mi5URVJNKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChcIkNPTE9SVEVSTVwiIGluIGVudjIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluMjtcbiAgICB9XG4gICAgX19uYW1lKHN1cHBvcnRzQ29sb3IsIFwic3VwcG9ydHNDb2xvclwiKTtcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtMikge1xuICAgICAgY29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbTIsIHN0cmVhbTIgJiYgc3RyZWFtMi5pc1RUWSk7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0U3VwcG9ydExldmVsLCBcImdldFN1cHBvcnRMZXZlbFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG4gICAgICBzdGRvdXQ6IHRyYW5zbGF0ZUxldmVsKHN1cHBvcnRzQ29sb3IodHJ1ZSwgdHR5LmlzYXR0eSgxKSkpLFxuICAgICAgc3RkZXJyOiB0cmFuc2xhdGVMZXZlbChzdXBwb3J0c0NvbG9yKHRydWUsIHR0eS5pc2F0dHkoMikpKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhbGtANC4xLjIvbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS91dGlsLmpzXG52YXIgcmVxdWlyZV91dGlsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYWxrQDQuMS4yL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvdXRpbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgc3RyaW5nUmVwbGFjZUFsbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0cmluZywgc3Vic3RyaW5nLCByZXBsYWNlcikgPT4ge1xuICAgICAgbGV0IGluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnN0cmluZ0xlbmd0aCA9IHN1YnN0cmluZy5sZW5ndGg7XG4gICAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgICAgbGV0IHJldHVyblZhbHVlID0gXCJcIjtcbiAgICAgIGRvIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCwgaW5kZXggLSBlbmRJbmRleCkgKyBzdWJzdHJpbmcgKyByZXBsYWNlcjtcbiAgICAgICAgZW5kSW5kZXggPSBpbmRleCArIHN1YnN0cmluZ0xlbmd0aDtcbiAgICAgICAgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihzdWJzdHJpbmcsIGVuZEluZGV4KTtcbiAgICAgIH0gd2hpbGUgKGluZGV4ICE9PSAtMSk7XG4gICAgICByZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4KTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LCBcInN0cmluZ1JlcGxhY2VBbGxcIik7XG4gICAgdmFyIHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0cmluZywgcHJlZml4LCBwb3N0Zml4LCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGVuZEluZGV4ID0gMDtcbiAgICAgIGxldCByZXR1cm5WYWx1ZSA9IFwiXCI7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGdvdENSID0gc3RyaW5nW2luZGV4IC0gMV0gPT09IFwiXFxyXCI7XG4gICAgICAgIHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgsIChnb3RDUiA/IGluZGV4IC0gMSA6IGluZGV4KSAtIGVuZEluZGV4KSArIHByZWZpeCArIChnb3RDUiA/IFwiXFxyXFxuXCIgOiBcIlxcblwiKSArIHBvc3RmaXg7XG4gICAgICAgIGVuZEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBpbmRleCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIGVuZEluZGV4KTtcbiAgICAgIH0gd2hpbGUgKGluZGV4ICE9PSAtMSk7XG4gICAgICByZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4KTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LCBcInN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBzdHJpbmdSZXBsYWNlQWxsLFxuICAgICAgc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFsa0A0LjEuMi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3RlbXBsYXRlcy5qc1xudmFyIHJlcXVpcmVfdGVtcGxhdGVzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYWxrQDQuMS4yL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvdGVtcGxhdGVzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBURU1QTEFURV9SRUdFWCA9IC8oPzpcXFxcKHUoPzpbYS1mXFxkXXs0fXxcXHtbYS1mXFxkXXsxLDZ9XFx9KXx4W2EtZlxcZF17Mn18LikpfCg/Olxceyh+KT8oXFx3Kyg/OlxcKFteKV0qXFwpKT8oPzpcXC5cXHcrKD86XFwoW14pXSpcXCkpPykqKSg/OlsgXFx0XXwoPz1cXHI/XFxuKSkpfChcXH0pfCgoPzoufFtcXHJcXG5cXGZdKSs/KS9naTtcbiAgICB2YXIgU1RZTEVfUkVHRVggPSAvKD86XnxcXC4pKFxcdyspKD86XFwoKFteKV0qKVxcKSk/L2c7XG4gICAgdmFyIFNUUklOR19SRUdFWCA9IC9eKFsnXCJdKSgoPzpcXFxcLnwoPyFcXDEpW15cXFxcXSkqKVxcMSQvO1xuICAgIHZhciBFU0NBUEVfUkVHRVggPSAvXFxcXCh1KD86W2EtZlxcZF17NH18e1thLWZcXGRdezEsNn19KXx4W2EtZlxcZF17Mn18Lil8KFteXFxcXF0pL2dpO1xuICAgIHZhciBFU0NBUEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgW1wiblwiLCBcIlxcblwiXSxcbiAgICAgIFtcInJcIiwgXCJcXHJcIl0sXG4gICAgICBbXCJ0XCIsIFwiXHRcIl0sXG4gICAgICBbXCJiXCIsIFwiXFxiXCJdLFxuICAgICAgW1wiZlwiLCBcIlxcZlwiXSxcbiAgICAgIFtcInZcIiwgXCJcXHZcIl0sXG4gICAgICBbXCIwXCIsIFwiXFwwXCJdLFxuICAgICAgW1wiXFxcXFwiLCBcIlxcXFxcIl0sXG4gICAgICBbXCJlXCIsIFwiXFx4MUJcIl0sXG4gICAgICBbXCJhXCIsIFwiXFx4MDdcIl1cbiAgICBdKTtcbiAgICBmdW5jdGlvbiB1bmVzY2FwZShjKSB7XG4gICAgICBjb25zdCB1ID0gY1swXSA9PT0gXCJ1XCI7XG4gICAgICBjb25zdCBicmFja2V0ID0gY1sxXSA9PT0gXCJ7XCI7XG4gICAgICBpZiAodSAmJiAhYnJhY2tldCAmJiBjLmxlbmd0aCA9PT0gNSB8fCBjWzBdID09PSBcInhcIiAmJiBjLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjLnNsaWNlKDEpLCAxNikpO1xuICAgICAgfVxuICAgICAgaWYgKHUgJiYgYnJhY2tldCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoYy5zbGljZSgyLCAtMSksIDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRVNDQVBFUy5nZXQoYykgfHwgYztcbiAgICB9XG4gICAgX19uYW1lKHVuZXNjYXBlLCBcInVuZXNjYXBlXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKG5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGNvbnN0IGNodW5rcyA9IGFyZ3VtZW50c18udHJpbSgpLnNwbGl0KC9cXHMqLFxccyovZyk7XG4gICAgICBsZXQgbWF0Y2hlcztcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihjaHVuayk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gY2h1bmsubWF0Y2goU1RSSU5HX1JFR0VYKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChtYXRjaGVzWzJdLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobSwgZXNjYXBlLCBjaGFyYWN0ZXIpID0+IGVzY2FwZSA/IHVuZXNjYXBlKGVzY2FwZSkgOiBjaGFyYWN0ZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ2hhbGsgdGVtcGxhdGUgc3R5bGUgYXJndW1lbnQ6ICR7Y2h1bmt9IChpbiBzdHlsZSAnJHtuYW1lfScpYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VBcmd1bWVudHMsIFwicGFyc2VBcmd1bWVudHNcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VTdHlsZShzdHlsZSkge1xuICAgICAgU1RZTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgd2hpbGUgKChtYXRjaGVzID0gU1RZTEVfUkVHRVguZXhlYyhzdHlsZSkpICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICBpZiAobWF0Y2hlc1syXSkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhuYW1lLCBtYXRjaGVzWzJdKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2goW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VTdHlsZSwgXCJwYXJzZVN0eWxlXCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkU3R5bGUoY2hhbGsxMiwgc3R5bGVzKSB7XG4gICAgICBjb25zdCBlbmFibGVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIGxheWVyLnN0eWxlcykge1xuICAgICAgICAgIGVuYWJsZWRbc3R5bGVbMF1dID0gbGF5ZXIuaW52ZXJzZSA/IG51bGwgOiBzdHlsZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnQgPSBjaGFsazEyO1xuICAgICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZXMyXSBvZiBPYmplY3QuZW50cmllcyhlbmFibGVkKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGVzMikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdHlsZU5hbWUgaW4gY3VycmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQ2hhbGsgc3R5bGU6ICR7c3R5bGVOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBzdHlsZXMyLmxlbmd0aCA+IDAgPyBjdXJyZW50W3N0eWxlTmFtZV0oLi4uc3R5bGVzMikgOiBjdXJyZW50W3N0eWxlTmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkU3R5bGUsIFwiYnVpbGRTdHlsZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAoY2hhbGsxMiwgdGVtcG9yYXJ5KSA9PiB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgbGV0IGNodW5rID0gW107XG4gICAgICB0ZW1wb3JhcnkucmVwbGFjZShURU1QTEFURV9SRUdFWCwgKG0sIGVzY2FwZUNoYXJhY3RlciwgaW52ZXJzZSwgc3R5bGUsIGNsb3NlLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGVzY2FwZUNoYXJhY3Rlcikge1xuICAgICAgICAgIGNodW5rLnB1c2godW5lc2NhcGUoZXNjYXBlQ2hhcmFjdGVyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUpIHtcbiAgICAgICAgICBjb25zdCBzdHJpbmcgPSBjaHVuay5qb2luKFwiXCIpO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgY2h1bmtzLnB1c2goc3R5bGVzLmxlbmd0aCA9PT0gMCA/IHN0cmluZyA6IGJ1aWxkU3R5bGUoY2hhbGsxMiwgc3R5bGVzKShzdHJpbmcpKTtcbiAgICAgICAgICBzdHlsZXMucHVzaCh7IGludmVyc2UsIHN0eWxlczogcGFyc2VTdHlsZShzdHlsZSkgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2UpIHtcbiAgICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgZXh0cmFuZW91cyB9IGluIENoYWxrIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rcy5wdXNoKGJ1aWxkU3R5bGUoY2hhbGsxMiwgc3R5bGVzKShjaHVuay5qb2luKFwiXCIpKSk7XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBzdHlsZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsucHVzaChjaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rLmpvaW4oXCJcIikpO1xuICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBgQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbCBpcyBtaXNzaW5nICR7c3R5bGVzLmxlbmd0aH0gY2xvc2luZyBicmFja2V0JHtzdHlsZXMubGVuZ3RoID09PSAxID8gXCJcIiA6IFwic1wifSAoXFxgfVxcYClgO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFsa0A0LjEuMi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zb3VyY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhbGtANC4xLjIvbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmVfYW5zaV9zdHlsZXMoKTtcbiAgICB2YXIgeyBzdGRvdXQ6IHN0ZG91dENvbG9yLCBzdGRlcnI6IHN0ZGVyckNvbG9yIH0gPSByZXF1aXJlX3N1cHBvcnRzX2NvbG9yKCk7XG4gICAgdmFyIHtcbiAgICAgIHN0cmluZ1JlcGxhY2VBbGwsXG4gICAgICBzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXhcbiAgICB9ID0gcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIHsgaXNBcnJheTogaXNBcnJheTIgfSA9IEFycmF5O1xuICAgIHZhciBsZXZlbE1hcHBpbmcgPSBbXG4gICAgICBcImFuc2lcIixcbiAgICAgIFwiYW5zaVwiLFxuICAgICAgXCJhbnNpMjU2XCIsXG4gICAgICBcImFuc2kxNm1cIlxuICAgIF07XG4gICAgdmFyIHN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBhcHBseU9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvYmplY3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMubGV2ZWwgJiYgIShOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubGV2ZWwpICYmIG9wdGlvbnMubGV2ZWwgPj0gMCAmJiBvcHRpb25zLmxldmVsIDw9IDMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgbGV2ZWxgIG9wdGlvbiBzaG91bGQgYmUgYW4gaW50ZWdlciBmcm9tIDAgdG8gM1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbG9yTGV2ZWwgPSBzdGRvdXRDb2xvciA/IHN0ZG91dENvbG9yLmxldmVsIDogMDtcbiAgICAgIG9iamVjdC5sZXZlbCA9IG9wdGlvbnMubGV2ZWwgPT09IHZvaWQgMCA/IGNvbG9yTGV2ZWwgOiBvcHRpb25zLmxldmVsO1xuICAgIH0sIFwiYXBwbHlPcHRpb25zXCIpO1xuICAgIHZhciBDaGFsa0NsYXNzID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENoYWxrQ2xhc3MsIFwiQ2hhbGtDbGFzc1wiKTtcbiAgICB2YXIgY2hhbGtGYWN0b3J5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2hhbGsxMyA9IHt9O1xuICAgICAgYXBwbHlPcHRpb25zKGNoYWxrMTMsIG9wdGlvbnMpO1xuICAgICAgY2hhbGsxMy50ZW1wbGF0ZSA9ICguLi5hcmd1bWVudHNfKSA9PiBjaGFsa1RhZyhjaGFsazEzLnRlbXBsYXRlLCAuLi5hcmd1bWVudHNfKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsazEzLCBDaGFsay5wcm90b3R5cGUpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrMTMudGVtcGxhdGUsIGNoYWxrMTMpO1xuICAgICAgY2hhbGsxMy50ZW1wbGF0ZS5jb25zdHJ1Y3RvciA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGNoYWxrLmNvbnN0cnVjdG9yKClgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgbmV3IGNoYWxrLkluc3RhbmNlKClgIGluc3RlYWQuXCIpO1xuICAgICAgfTtcbiAgICAgIGNoYWxrMTMudGVtcGxhdGUuSW5zdGFuY2UgPSBDaGFsa0NsYXNzO1xuICAgICAgcmV0dXJuIGNoYWxrMTMudGVtcGxhdGU7XG4gICAgfSwgXCJjaGFsa0ZhY3RvcnlcIik7XG4gICAgZnVuY3Rpb24gQ2hhbGsob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNoYWxrRmFjdG9yeShvcHRpb25zKTtcbiAgICB9XG4gICAgX19uYW1lKENoYWxrLCBcIkNoYWxrXCIpO1xuICAgIGZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVdIG9mIE9iamVjdC5lbnRyaWVzKGFuc2lTdHlsZXMpKSB7XG4gICAgICBzdHlsZXNbc3R5bGVOYW1lXSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBjcmVhdGVCdWlsZGVyKHRoaXMsIGNyZWF0ZVN0eWxlcihzdHlsZS5vcGVuLCBzdHlsZS5jbG9zZSwgdGhpcy5fc3R5bGVyKSwgdGhpcy5faXNFbXB0eSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN0eWxlTmFtZSwgeyB2YWx1ZTogYnVpbGRlciB9KTtcbiAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgc3R5bGVzLnZpc2libGUgPSB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBjcmVhdGVCdWlsZGVyKHRoaXMsIHRoaXMuX3N0eWxlciwgdHJ1ZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpc2libGVcIiwgeyB2YWx1ZTogYnVpbGRlciB9KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdXNlZE1vZGVscyA9IFtcInJnYlwiLCBcImhleFwiLCBcImtleXdvcmRcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJod2JcIiwgXCJhbnNpXCIsIFwiYW5zaTI1NlwiXTtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHVzZWRNb2RlbHMpIHtcbiAgICAgIHN0eWxlc1ttb2RlbF0gPSB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCB7IGxldmVsIH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmd1bWVudHNfKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcy5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuY29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuICAgICAgY29uc3QgYmdNb2RlbCA9IFwiYmdcIiArIG1vZGVsWzBdLnRvVXBwZXJDYXNlKCkgKyBtb2RlbC5zbGljZSgxKTtcbiAgICAgIHN0eWxlc1tiZ01vZGVsXSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHsgbGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3VtZW50c18pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlciA9IGNyZWF0ZVN0eWxlcihhbnNpU3R5bGVzLmJnQ29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdKC4uLmFyZ3VtZW50c18pLCBhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBwcm90byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCgpID0+IHtcbiAgICB9LCB7XG4gICAgICAuLi5zdHlsZXMsXG4gICAgICBsZXZlbDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRvci5sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGxldmVsKSB7XG4gICAgICAgICAgdGhpcy5fZ2VuZXJhdG9yLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgY3JlYXRlU3R5bGVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3BlbiwgY2xvc2UsIHBhcmVudCkgPT4ge1xuICAgICAgbGV0IG9wZW5BbGw7XG4gICAgICBsZXQgY2xvc2VBbGw7XG4gICAgICBpZiAocGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgb3BlbkFsbCA9IG9wZW47XG4gICAgICAgIGNsb3NlQWxsID0gY2xvc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuQWxsID0gcGFyZW50Lm9wZW5BbGwgKyBvcGVuO1xuICAgICAgICBjbG9zZUFsbCA9IGNsb3NlICsgcGFyZW50LmNsb3NlQWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgY2xvc2UsXG4gICAgICAgIG9wZW5BbGwsXG4gICAgICAgIGNsb3NlQWxsLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH07XG4gICAgfSwgXCJjcmVhdGVTdHlsZXJcIik7XG4gICAgdmFyIGNyZWF0ZUJ1aWxkZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzZWxmMiwgX3N0eWxlciwgX2lzRW1wdHkpID0+IHtcbiAgICAgIGNvbnN0IGJ1aWxkZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCguLi5hcmd1bWVudHNfKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5Mihhcmd1bWVudHNfWzBdKSAmJiBpc0FycmF5Mihhcmd1bWVudHNfWzBdLnJhdykpIHtcbiAgICAgICAgICByZXR1cm4gYXBwbHlTdHlsZShidWlsZGVyLCBjaGFsa1RhZyhidWlsZGVyLCAuLi5hcmd1bWVudHNfKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5U3R5bGUoYnVpbGRlciwgYXJndW1lbnRzXy5sZW5ndGggPT09IDEgPyBcIlwiICsgYXJndW1lbnRzX1swXSA6IGFyZ3VtZW50c18uam9pbihcIiBcIikpO1xuICAgICAgfSwgXCJidWlsZGVyXCIpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1aWxkZXIsIHByb3RvKTtcbiAgICAgIGJ1aWxkZXIuX2dlbmVyYXRvciA9IHNlbGYyO1xuICAgICAgYnVpbGRlci5fc3R5bGVyID0gX3N0eWxlcjtcbiAgICAgIGJ1aWxkZXIuX2lzRW1wdHkgPSBfaXNFbXB0eTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sIFwiY3JlYXRlQnVpbGRlclwiKTtcbiAgICB2YXIgYXBwbHlTdHlsZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNlbGYyLCBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChzZWxmMi5sZXZlbCA8PSAwIHx8ICFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYyLl9pc0VtcHR5ID8gXCJcIiA6IHN0cmluZztcbiAgICAgIH1cbiAgICAgIGxldCBzdHlsZXIgPSBzZWxmMi5fc3R5bGVyO1xuICAgICAgaWYgKHN0eWxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG9wZW5BbGwsIGNsb3NlQWxsIH0gPSBzdHlsZXI7XG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoXCJcXHgxQlwiKSAhPT0gLTEpIHtcbiAgICAgICAgd2hpbGUgKHN0eWxlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nUmVwbGFjZUFsbChzdHJpbmcsIHN0eWxlci5jbG9zZSwgc3R5bGVyLm9wZW4pO1xuICAgICAgICAgIHN0eWxlciA9IHN0eWxlci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxmSW5kZXggPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIGlmIChsZkluZGV4ICE9PSAtMSkge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXgoc3RyaW5nLCBjbG9zZUFsbCwgb3BlbkFsbCwgbGZJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BlbkFsbCArIHN0cmluZyArIGNsb3NlQWxsO1xuICAgIH0sIFwiYXBwbHlTdHlsZVwiKTtcbiAgICB2YXIgdGVtcGxhdGU7XG4gICAgdmFyIGNoYWxrVGFnID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY2hhbGsxMywgLi4uc3RyaW5ncykgPT4ge1xuICAgICAgY29uc3QgW2ZpcnN0U3RyaW5nXSA9IHN0cmluZ3M7XG4gICAgICBpZiAoIWlzQXJyYXkyKGZpcnN0U3RyaW5nKSB8fCAhaXNBcnJheTIoZmlyc3RTdHJpbmcucmF3KSkge1xuICAgICAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3VtZW50c18gPSBzdHJpbmdzLnNsaWNlKDEpO1xuICAgICAgY29uc3QgcGFydHMgPSBbZmlyc3RTdHJpbmcucmF3WzBdXTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlyc3RTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBTdHJpbmcoYXJndW1lbnRzX1tpIC0gMV0pLnJlcGxhY2UoL1t7fVxcXFxdL2csIFwiXFxcXCQmXCIpLFxuICAgICAgICAgIFN0cmluZyhmaXJzdFN0cmluZy5yYXdbaV0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHJlcXVpcmVfdGVtcGxhdGVzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGUoY2hhbGsxMywgcGFydHMuam9pbihcIlwiKSk7XG4gICAgfSwgXCJjaGFsa1RhZ1wiKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFsay5wcm90b3R5cGUsIHN0eWxlcyk7XG4gICAgdmFyIGNoYWxrMTIgPSBDaGFsaygpO1xuICAgIGNoYWxrMTIuc3VwcG9ydHNDb2xvciA9IHN0ZG91dENvbG9yO1xuICAgIGNoYWxrMTIuc3RkZXJyID0gQ2hhbGsoeyBsZXZlbDogc3RkZXJyQ29sb3IgPyBzdGRlcnJDb2xvci5sZXZlbCA6IDAgfSk7XG4gICAgY2hhbGsxMi5zdGRlcnIuc3VwcG9ydHNDb2xvciA9IHN0ZGVyckNvbG9yO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNoYWxrMTI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaW5kZW50LXN0cmluZ0A0LjAuMC9ub2RlX21vZHVsZXMvaW5kZW50LXN0cmluZy9pbmRleC5qc1xudmFyIHJlcXVpcmVfaW5kZW50X3N0cmluZyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pbmRlbnQtc3RyaW5nQDQuMC4wL25vZGVfbW9kdWxlcy9pbmRlbnQtc3RyaW5nL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChzdHJpbmcsIGNvdW50MiA9IDEsIG9wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGluZGVudDogXCIgXCIsXG4gICAgICAgIGluY2x1ZGVFbXB0eUxpbmVzOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIFxcYGlucHV0XFxgIHRvIGJlIGEgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2Ygc3RyaW5nfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY291bnQyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIFxcYGNvdW50XFxgIHRvIGJlIGEgXFxgbnVtYmVyXFxgLCBnb3QgXFxgJHt0eXBlb2YgY291bnQyfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgXFxgb3B0aW9ucy5pbmRlbnRcXGAgdG8gYmUgYSBcXGBzdHJpbmdcXGAsIGdvdCBcXGAke3R5cGVvZiBvcHRpb25zLmluZGVudH1cXGBgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdleCA9IG9wdGlvbnMuaW5jbHVkZUVtcHR5TGluZXMgPyAvXi9nbSA6IC9eKD8hXFxzKiQpL2dtO1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4LCBvcHRpb25zLmluZGVudC5yZXBlYXQoY291bnQyKSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9qcy1sZXZlbnNodGVpbkAxLjEuNi9ub2RlX21vZHVsZXMvanMtbGV2ZW5zaHRlaW4vaW5kZXguanNcbnZhciByZXF1aXJlX2pzX2xldmVuc2h0ZWluID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzLWxldmVuc2h0ZWluQDEuMS42L25vZGVfbW9kdWxlcy9qcy1sZXZlbnNodGVpbi9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIF9taW4oZDAsIGQxLCBkMiwgYngsIGF5KSB7XG4gICAgICAgIHJldHVybiBkMCA8IGQxIHx8IGQyIDwgZDEgPyBkMCA+IGQyID8gZDIgKyAxIDogZDAgKyAxIDogYnggPT09IGF5ID8gZDEgOiBkMSArIDE7XG4gICAgICB9XG4gICAgICBfX25hbWUoX21pbiwgXCJfbWluXCIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGggPiBiLmxlbmd0aCkge1xuICAgICAgICAgIHZhciB0bXAgPSBhO1xuICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIGIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsYiA9IGIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGEgPiAwICYmIGEuY2hhckNvZGVBdChsYSAtIDEpID09PSBiLmNoYXJDb2RlQXQobGIgLSAxKSkge1xuICAgICAgICAgIGxhLS07XG4gICAgICAgICAgbGItLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxhICYmIGEuY2hhckNvZGVBdChvZmZzZXQpID09PSBiLmNoYXJDb2RlQXQob2Zmc2V0KSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGxhIC09IG9mZnNldDtcbiAgICAgICAgbGIgLT0gb2Zmc2V0O1xuICAgICAgICBpZiAobGEgPT09IDAgfHwgbGIgPCAzKSB7XG4gICAgICAgICAgcmV0dXJuIGxiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHk7XG4gICAgICAgIHZhciBkMDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG4gICAgICAgIHZhciBkMztcbiAgICAgICAgdmFyIGRkO1xuICAgICAgICB2YXIgZHk7XG4gICAgICAgIHZhciBheTtcbiAgICAgICAgdmFyIGJ4MDtcbiAgICAgICAgdmFyIGJ4MTtcbiAgICAgICAgdmFyIGJ4MjtcbiAgICAgICAgdmFyIGJ4MztcbiAgICAgICAgdmFyIHZlY3RvciA9IFtdO1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgbGE7IHkrKykge1xuICAgICAgICAgIHZlY3Rvci5wdXNoKHkgKyAxKTtcbiAgICAgICAgICB2ZWN0b3IucHVzaChhLmNoYXJDb2RlQXQob2Zmc2V0ICsgeSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSB2ZWN0b3IubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICg7IHggPCBsYiAtIDM7ICkge1xuICAgICAgICAgIGJ4MCA9IGIuY2hhckNvZGVBdChvZmZzZXQgKyAoZDAgPSB4KSk7XG4gICAgICAgICAgYngxID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMSA9IHggKyAxKSk7XG4gICAgICAgICAgYngyID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMiA9IHggKyAyKSk7XG4gICAgICAgICAgYngzID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMyA9IHggKyAzKSk7XG4gICAgICAgICAgZGQgPSB4ICs9IDQ7XG4gICAgICAgICAgZm9yICh5ID0gMDsgeSA8IGxlbjsgeSArPSAyKSB7XG4gICAgICAgICAgICBkeSA9IHZlY3Rvclt5XTtcbiAgICAgICAgICAgIGF5ID0gdmVjdG9yW3kgKyAxXTtcbiAgICAgICAgICAgIGQwID0gX21pbihkeSwgZDAsIGQxLCBieDAsIGF5KTtcbiAgICAgICAgICAgIGQxID0gX21pbihkMCwgZDEsIGQyLCBieDEsIGF5KTtcbiAgICAgICAgICAgIGQyID0gX21pbihkMSwgZDIsIGQzLCBieDIsIGF5KTtcbiAgICAgICAgICAgIGRkID0gX21pbihkMiwgZDMsIGRkLCBieDMsIGF5KTtcbiAgICAgICAgICAgIHZlY3Rvclt5XSA9IGRkO1xuICAgICAgICAgICAgZDMgPSBkMjtcbiAgICAgICAgICAgIGQyID0gZDE7XG4gICAgICAgICAgICBkMSA9IGQwO1xuICAgICAgICAgICAgZDAgPSBkeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHggPCBsYjsgKSB7XG4gICAgICAgICAgYngwID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMCA9IHgpKTtcbiAgICAgICAgICBkZCA9ICsreDtcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgbGVuOyB5ICs9IDIpIHtcbiAgICAgICAgICAgIGR5ID0gdmVjdG9yW3ldO1xuICAgICAgICAgICAgdmVjdG9yW3ldID0gZGQgPSBfbWluKGR5LCBkMCwgZGQsIGJ4MCwgdmVjdG9yW3kgKyAxXSk7XG4gICAgICAgICAgICBkMCA9IGR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGQ7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tc0AyLjEuMi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanNcbnZhciByZXF1aXJlX21zID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zQDIuMS4yL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgcyA9IDFlMztcbiAgICB2YXIgbSA9IHMgKiA2MDtcbiAgICB2YXIgaCA9IG0gKiA2MDtcbiAgICB2YXIgZCA9IGggKiAyNDtcbiAgICB2YXIgdyA9IGQgKiA3O1xuICAgIHZhciB5ID0gZCAqIDM2NS4yNTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlMih2YWwpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIiArIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgICAgICk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZTIoc3RyKSB7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICAgICAgc3RyXG4gICAgICApO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgXCJtc1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICBjYXNlIFwieXJzXCI6XG4gICAgICAgIGNhc2UgXCJ5clwiOlxuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiB3O1xuICAgICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBkO1xuICAgICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgY2FzZSBcImhyc1wiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIGg7XG4gICAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgY2FzZSBcIm1pbnNcIjpcbiAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBuICogbTtcbiAgICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgY2FzZSBcInNlY29uZFwiOlxuICAgICAgICBjYXNlIFwic2Vjc1wiOlxuICAgICAgICBjYXNlIFwic2VjXCI6XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBzO1xuICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgICBjYXNlIFwibXNlY3NcIjpcbiAgICAgICAgY2FzZSBcIm1zZWNcIjpcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHBhcnNlMiwgXCJwYXJzZVwiKTtcbiAgICBmdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICAgICAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICAgICAgaWYgKG1zQWJzID49IGQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArIFwiZFwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IGgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArIFwiaFwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IG0pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArIFwibVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArIFwic1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zICsgXCJtc1wiO1xuICAgIH1cbiAgICBfX25hbWUoZm10U2hvcnQsIFwiZm10U2hvcnRcIik7XG4gICAgZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICAgICAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICAgICAgaWYgKG1zQWJzID49IGQpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsIFwiZGF5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IGgpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsIFwiaG91clwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtc0FicyA+PSBtKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCBcIm1pbnV0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtc0FicyA+PSBzKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCBcInNlY29uZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtcyArIFwiIG1zXCI7XG4gICAgfVxuICAgIF9fbmFtZShmbXRMb25nLCBcImZtdExvbmdcIik7XG4gICAgZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICAgICAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyBcIiBcIiArIG5hbWUgKyAoaXNQbHVyYWwgPyBcInNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBfX25hbWUocGx1cmFsLCBcInBsdXJhbFwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qc1xudmFyIHJlcXVpcmVfY29tbW9uID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIGZ1bmN0aW9uIHNldHVwKGVudjIpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gICAgICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gICAgICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gICAgICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlX21zKCk7XG4gICAgICBjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgIE9iamVjdC5rZXlzKGVudjIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52MltrZXldO1xuICAgICAgfSk7XG4gICAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGhhc2ggfD0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gICAgICB9XG4gICAgICBfX25hbWUoc2VsZWN0Q29sb3IsIFwic2VsZWN0Q29sb3JcIik7XG4gICAgICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAgICAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgICAgIGxldCBwcmV2VGltZTtcbiAgICAgICAgbGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgbGV0IG5hbWVzcGFjZXNDYWNoZTtcbiAgICAgICAgbGV0IGVuYWJsZWRDYWNoZTtcbiAgICAgICAgZnVuY3Rpb24gZGVidWcxMyguLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFkZWJ1ZzEzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2VsZjIgPSBkZWJ1ZzEzO1xuICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICAgICAgY29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgICAgIHNlbGYyLmRpZmYgPSBtcztcbiAgICAgICAgICBzZWxmMi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICAgICAgc2VsZjIuY3VyciA9IGN1cnI7XG4gICAgICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoXCIlT1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQyKSA9PiB7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IFwiJSVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXQyXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZjIsIHZhbCk7XG4gICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZjIsIGFyZ3MpO1xuICAgICAgICAgIGNvbnN0IGxvZ0ZuID0gc2VsZjIubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgICAgICBsb2dGbi5hcHBseShzZWxmMiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgX19uYW1lKGRlYnVnMTMsIFwiZGVidWdcIik7XG4gICAgICAgIGRlYnVnMTMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICBkZWJ1ZzEzLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgICAgICBkZWJ1ZzEzLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICAgICAgZGVidWcxMy5leHRlbmQgPSBleHRlbmQ7XG4gICAgICAgIGRlYnVnMTMuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZzEzLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgIG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG4gICAgICAgICAgICAgIGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmFibGVkQ2FjaGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6ICh2KSA9PiB7XG4gICAgICAgICAgICBlbmFibGVPdmVycmlkZSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnMTMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWJ1ZzEzO1xuICAgICAgfVxuICAgICAgX19uYW1lKGNyZWF0ZURlYnVnLCBcImNyZWF0ZURlYnVnXCIpO1xuICAgICAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiOlwiIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gICAgICAgIG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuICAgICAgICByZXR1cm4gbmV3RGVidWc7XG4gICAgICB9XG4gICAgICBfX25hbWUoZXh0ZW5kLCBcImV4dGVuZFwiKTtcbiAgICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09IFwic3RyaW5nXCIgPyBuYW1lc3BhY2VzIDogXCJcIikuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICAgICAgY29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCBcIi4qP1wiKTtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyBcIiRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lc3BhY2VzICsgXCIkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShlbmFibGUsIFwiZW5hYmxlXCIpO1xuICAgICAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IFtcbiAgICAgICAgICAuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuICAgICAgICAgIC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKChuYW1lc3BhY2UpID0+IFwiLVwiICsgbmFtZXNwYWNlKVxuICAgICAgICBdLmpvaW4oXCIsXCIpO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoXCJcIik7XG4gICAgICAgIHJldHVybiBuYW1lc3BhY2VzO1xuICAgICAgfVxuICAgICAgX19uYW1lKGRpc2FibGUsIFwiZGlzYWJsZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSBcIipcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBfX25hbWUoZW5hYmxlZCwgXCJlbmFibGVkXCIpO1xuICAgICAgZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG4gICAgICAgIHJldHVybiByZWdleHAudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sIFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZSh0b05hbWVzcGFjZSwgXCJ0b05hbWVzcGFjZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgICAgX19uYW1lKGNvZXJjZSwgXCJjb2VyY2VcIik7XG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCIpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGRlc3Ryb3ksIFwiZGVzdHJveVwiKTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnO1xuICAgIH1cbiAgICBfX25hbWUoc2V0dXAsIFwic2V0dXBcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gc2V0dXA7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG52YXIgcmVxdWlyZV9icm93c2VyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuICAgICAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFtcbiAgICAgIFwiIzAwMDBDQ1wiLFxuICAgICAgXCIjMDAwMEZGXCIsXG4gICAgICBcIiMwMDMzQ0NcIixcbiAgICAgIFwiIzAwMzNGRlwiLFxuICAgICAgXCIjMDA2NkNDXCIsXG4gICAgICBcIiMwMDY2RkZcIixcbiAgICAgIFwiIzAwOTlDQ1wiLFxuICAgICAgXCIjMDA5OUZGXCIsXG4gICAgICBcIiMwMENDMDBcIixcbiAgICAgIFwiIzAwQ0MzM1wiLFxuICAgICAgXCIjMDBDQzY2XCIsXG4gICAgICBcIiMwMENDOTlcIixcbiAgICAgIFwiIzAwQ0NDQ1wiLFxuICAgICAgXCIjMDBDQ0ZGXCIsXG4gICAgICBcIiMzMzAwQ0NcIixcbiAgICAgIFwiIzMzMDBGRlwiLFxuICAgICAgXCIjMzMzM0NDXCIsXG4gICAgICBcIiMzMzMzRkZcIixcbiAgICAgIFwiIzMzNjZDQ1wiLFxuICAgICAgXCIjMzM2NkZGXCIsXG4gICAgICBcIiMzMzk5Q0NcIixcbiAgICAgIFwiIzMzOTlGRlwiLFxuICAgICAgXCIjMzNDQzAwXCIsXG4gICAgICBcIiMzM0NDMzNcIixcbiAgICAgIFwiIzMzQ0M2NlwiLFxuICAgICAgXCIjMzNDQzk5XCIsXG4gICAgICBcIiMzM0NDQ0NcIixcbiAgICAgIFwiIzMzQ0NGRlwiLFxuICAgICAgXCIjNjYwMENDXCIsXG4gICAgICBcIiM2NjAwRkZcIixcbiAgICAgIFwiIzY2MzNDQ1wiLFxuICAgICAgXCIjNjYzM0ZGXCIsXG4gICAgICBcIiM2NkNDMDBcIixcbiAgICAgIFwiIzY2Q0MzM1wiLFxuICAgICAgXCIjOTkwMENDXCIsXG4gICAgICBcIiM5OTAwRkZcIixcbiAgICAgIFwiIzk5MzNDQ1wiLFxuICAgICAgXCIjOTkzM0ZGXCIsXG4gICAgICBcIiM5OUNDMDBcIixcbiAgICAgIFwiIzk5Q0MzM1wiLFxuICAgICAgXCIjQ0MwMDAwXCIsXG4gICAgICBcIiNDQzAwMzNcIixcbiAgICAgIFwiI0NDMDA2NlwiLFxuICAgICAgXCIjQ0MwMDk5XCIsXG4gICAgICBcIiNDQzAwQ0NcIixcbiAgICAgIFwiI0NDMDBGRlwiLFxuICAgICAgXCIjQ0MzMzAwXCIsXG4gICAgICBcIiNDQzMzMzNcIixcbiAgICAgIFwiI0NDMzM2NlwiLFxuICAgICAgXCIjQ0MzMzk5XCIsXG4gICAgICBcIiNDQzMzQ0NcIixcbiAgICAgIFwiI0NDMzNGRlwiLFxuICAgICAgXCIjQ0M2NjAwXCIsXG4gICAgICBcIiNDQzY2MzNcIixcbiAgICAgIFwiI0NDOTkwMFwiLFxuICAgICAgXCIjQ0M5OTMzXCIsXG4gICAgICBcIiNDQ0NDMDBcIixcbiAgICAgIFwiI0NDQ0MzM1wiLFxuICAgICAgXCIjRkYwMDAwXCIsXG4gICAgICBcIiNGRjAwMzNcIixcbiAgICAgIFwiI0ZGMDA2NlwiLFxuICAgICAgXCIjRkYwMDk5XCIsXG4gICAgICBcIiNGRjAwQ0NcIixcbiAgICAgIFwiI0ZGMDBGRlwiLFxuICAgICAgXCIjRkYzMzAwXCIsXG4gICAgICBcIiNGRjMzMzNcIixcbiAgICAgIFwiI0ZGMzM2NlwiLFxuICAgICAgXCIjRkYzMzk5XCIsXG4gICAgICBcIiNGRjMzQ0NcIixcbiAgICAgIFwiI0ZGMzNGRlwiLFxuICAgICAgXCIjRkY2NjAwXCIsXG4gICAgICBcIiNGRjY2MzNcIixcbiAgICAgIFwiI0ZGOTkwMFwiLFxuICAgICAgXCIjRkY5OTMzXCIsXG4gICAgICBcIiNGRkNDMDBcIixcbiAgICAgIFwiI0ZGQ0MzM1wiXG4gICAgXTtcbiAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xuICAgIH1cbiAgICBfX25hbWUodXNlQ29sb3JzLCBcInVzZUNvbG9yc1wiKTtcbiAgICBmdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICAgIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyBcIiVjXCIgOiBcIlwiKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gXCIgJWNcIiA6IFwiIFwiKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyBcIiVjIFwiIDogXCIgXCIpICsgXCIrXCIgKyBtb2R1bGUyLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcbiAgICAgIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IFwiY29sb3I6IFwiICsgdGhpcy5jb2xvcjtcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIGMsIFwiY29sb3I6IGluaGVyaXRcIik7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgbGV0IGxhc3RDID0gMDtcbiAgICAgIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCAobWF0Y2gpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoID09PSBcIiUlXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgaWYgKG1hdGNoID09PSBcIiVjXCIpIHtcbiAgICAgICAgICBsYXN0QyA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgICB9XG4gICAgX19uYW1lKGZvcm1hdEFyZ3MsIFwiZm9ybWF0QXJnc1wiKTtcbiAgICBleHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oXCJkZWJ1Z1wiLCBuYW1lc3BhY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbShcImRlYnVnXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNhdmUsIFwic2F2ZVwiKTtcbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgbGV0IHI7XG4gICAgICB0cnkge1xuICAgICAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oXCJkZWJ1Z1wiKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgfVxuICAgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiZW52XCIgaW4gcHJvY2Vzcykge1xuICAgICAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgX19uYW1lKGxvYWQsIFwibG9hZFwiKTtcbiAgICBmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShsb2NhbHN0b3JhZ2UsIFwibG9jYWxzdG9yYWdlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfY29tbW9uKCkoZXhwb3J0cyk7XG4gICAgdmFyIHsgZm9ybWF0dGVycyB9ID0gbW9kdWxlMi5leHBvcnRzO1xuICAgIGZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICByZXR1cm4gXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIgKyBlcnJvcjIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qc1xudmFyIHJlcXVpcmVfbm9kZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoXCJ0dHlcIik7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgZXhwb3J0cy5pbml0ID0gaW5pdDtcbiAgICBleHBvcnRzLmxvZyA9IGxvZzQ7XG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICBleHBvcnRzLnNhdmUgPSBzYXZlO1xuICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4gICAgZXhwb3J0cy5kZXN0cm95ID0gdXRpbDIuZGVwcmVjYXRlKFxuICAgICAgKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiXG4gICAgKTtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmVfc3VwcG9ydHNfY29sb3IoKTtcbiAgICAgIGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG4gICAgICAgIGV4cG9ydHMuY29sb3JzID0gW1xuICAgICAgICAgIDIwLFxuICAgICAgICAgIDIxLFxuICAgICAgICAgIDI2LFxuICAgICAgICAgIDI3LFxuICAgICAgICAgIDMyLFxuICAgICAgICAgIDMzLFxuICAgICAgICAgIDM4LFxuICAgICAgICAgIDM5LFxuICAgICAgICAgIDQwLFxuICAgICAgICAgIDQxLFxuICAgICAgICAgIDQyLFxuICAgICAgICAgIDQzLFxuICAgICAgICAgIDQ0LFxuICAgICAgICAgIDQ1LFxuICAgICAgICAgIDU2LFxuICAgICAgICAgIDU3LFxuICAgICAgICAgIDYyLFxuICAgICAgICAgIDYzLFxuICAgICAgICAgIDY4LFxuICAgICAgICAgIDY5LFxuICAgICAgICAgIDc0LFxuICAgICAgICAgIDc1LFxuICAgICAgICAgIDc2LFxuICAgICAgICAgIDc3LFxuICAgICAgICAgIDc4LFxuICAgICAgICAgIDc5LFxuICAgICAgICAgIDgwLFxuICAgICAgICAgIDgxLFxuICAgICAgICAgIDkyLFxuICAgICAgICAgIDkzLFxuICAgICAgICAgIDk4LFxuICAgICAgICAgIDk5LFxuICAgICAgICAgIDExMixcbiAgICAgICAgICAxMTMsXG4gICAgICAgICAgMTI4LFxuICAgICAgICAgIDEyOSxcbiAgICAgICAgICAxMzQsXG4gICAgICAgICAgMTM1LFxuICAgICAgICAgIDE0OCxcbiAgICAgICAgICAxNDksXG4gICAgICAgICAgMTYwLFxuICAgICAgICAgIDE2MSxcbiAgICAgICAgICAxNjIsXG4gICAgICAgICAgMTYzLFxuICAgICAgICAgIDE2NCxcbiAgICAgICAgICAxNjUsXG4gICAgICAgICAgMTY2LFxuICAgICAgICAgIDE2NyxcbiAgICAgICAgICAxNjgsXG4gICAgICAgICAgMTY5LFxuICAgICAgICAgIDE3MCxcbiAgICAgICAgICAxNzEsXG4gICAgICAgICAgMTcyLFxuICAgICAgICAgIDE3MyxcbiAgICAgICAgICAxNzgsXG4gICAgICAgICAgMTc5LFxuICAgICAgICAgIDE4NCxcbiAgICAgICAgICAxODUsXG4gICAgICAgICAgMTk2LFxuICAgICAgICAgIDE5NyxcbiAgICAgICAgICAxOTgsXG4gICAgICAgICAgMTk5LFxuICAgICAgICAgIDIwMCxcbiAgICAgICAgICAyMDEsXG4gICAgICAgICAgMjAyLFxuICAgICAgICAgIDIwMyxcbiAgICAgICAgICAyMDQsXG4gICAgICAgICAgMjA1LFxuICAgICAgICAgIDIwNixcbiAgICAgICAgICAyMDcsXG4gICAgICAgICAgMjA4LFxuICAgICAgICAgIDIwOSxcbiAgICAgICAgICAyMTQsXG4gICAgICAgICAgMjE1LFxuICAgICAgICAgIDIyMCxcbiAgICAgICAgICAyMjFcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICB9XG4gICAgZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xuICAgIH0pLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHByb3AgPSBrZXkuc3Vic3RyaW5nKDYpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcbiAgICAgICAgcmV0dXJuIGsudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gICAgICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgICAgIHZhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgIH1cbiAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgICAgIHJldHVybiBcImNvbG9yc1wiIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6IHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xuICAgIH1cbiAgICBfX25hbWUodXNlQ29sb3JzLCBcInVzZUNvbG9yc1wiKTtcbiAgICBmdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnM6IHVzZUNvbG9yczIgfSA9IHRoaXM7XG4gICAgICBpZiAodXNlQ29sb3JzMikge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jb2xvcjtcbiAgICAgICAgY29uc3QgY29sb3JDb2RlID0gXCJcXHgxQlszXCIgKyAoYyA8IDggPyBjIDogXCI4OzU7XCIgKyBjKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHgxQlswbWA7XG4gICAgICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KFwiXFxuXCIpLmpvaW4oXCJcXG5cIiArIHByZWZpeCk7XG4gICAgICAgIGFyZ3MucHVzaChjb2xvckNvZGUgKyBcIm0rXCIgKyBtb2R1bGUyLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArIFwiXFx4MUJbMG1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArIFwiIFwiICsgYXJnc1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZvcm1hdEFyZ3MsIFwiZm9ybWF0QXJnc1wiKTtcbiAgICBmdW5jdGlvbiBnZXREYXRlKCkge1xuICAgICAgaWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCIgXCI7XG4gICAgfVxuICAgIF9fbmFtZShnZXREYXRlLCBcImdldERhdGVcIik7XG4gICAgZnVuY3Rpb24gbG9nNCguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbDIuZm9ybWF0KC4uLmFyZ3MpICsgXCJcXG5cIik7XG4gICAgfVxuICAgIF9fbmFtZShsb2c0LCBcImxvZ1wiKTtcbiAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNhdmUsIFwic2F2ZVwiKTtcbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xuICAgIH1cbiAgICBfX25hbWUobG9hZCwgXCJsb2FkXCIpO1xuICAgIGZ1bmN0aW9uIGluaXQoZGVidWcxMykge1xuICAgICAgZGVidWcxMy5pbnNwZWN0T3B0cyA9IHt9O1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5czIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVidWcxMy5pbnNwZWN0T3B0c1trZXlzMltpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXMyW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGluaXQsIFwiaW5pdFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2NvbW1vbigpKGV4cG9ydHMpO1xuICAgIHZhciB7IGZvcm1hdHRlcnMgfSA9IG1vZHVsZTIuZXhwb3J0cztcbiAgICBmb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cykuc3BsaXQoXCJcXG5cIikubWFwKChzdHIpID0+IHN0ci50cmltKCkpLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgICAgIHJldHVybiB1dGlsMi5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3JjID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9icm93c2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfbm9kZSgpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pc2V4ZUAyLjAuMC9ub2RlX21vZHVsZXMvaXNleGUvd2luZG93cy5qc1xudmFyIHJlcXVpcmVfd2luZG93cyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pc2V4ZUAyLjAuMC9ub2RlX21vZHVsZXMvaXNleGUvd2luZG93cy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBpc2V4ZTtcbiAgICBpc2V4ZS5zeW5jID0gc3luYztcbiAgICB2YXIgZnMxMSA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICBmdW5jdGlvbiBjaGVja1BhdGhFeHQocGF0aDcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXRoZXh0ID0gb3B0aW9ucy5wYXRoRXh0ICE9PSB2b2lkIDAgPyBvcHRpb25zLnBhdGhFeHQgOiBwcm9jZXNzLmVudi5QQVRIRVhUO1xuICAgICAgaWYgKCFwYXRoZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGF0aGV4dCA9IHBhdGhleHQuc3BsaXQoXCI7XCIpO1xuICAgICAgaWYgKHBhdGhleHQuaW5kZXhPZihcIlwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwYXRoZXh0W2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwICYmIHBhdGg3LnN1YnN0cigtcC5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfX25hbWUoY2hlY2tQYXRoRXh0LCBcImNoZWNrUGF0aEV4dFwiKTtcbiAgICBmdW5jdGlvbiBjaGVja1N0YXQoc3RhdCwgcGF0aDcsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghc3RhdC5pc1N5bWJvbGljTGluaygpICYmICFzdGF0LmlzRmlsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGVja1BhdGhFeHQocGF0aDcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfX25hbWUoY2hlY2tTdGF0LCBcImNoZWNrU3RhdFwiKTtcbiAgICBmdW5jdGlvbiBpc2V4ZShwYXRoNywgb3B0aW9ucywgY2IpIHtcbiAgICAgIGZzMTEuc3RhdChwYXRoNywgZnVuY3Rpb24oZXIsIHN0YXQpIHtcbiAgICAgICAgY2IoZXIsIGVyID8gZmFsc2UgOiBjaGVja1N0YXQoc3RhdCwgcGF0aDcsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaXNleGUsIFwiaXNleGVcIik7XG4gICAgZnVuY3Rpb24gc3luYyhwYXRoNywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNoZWNrU3RhdChmczExLnN0YXRTeW5jKHBhdGg3KSwgcGF0aDcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfX25hbWUoc3luYywgXCJzeW5jXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzZXhlQDIuMC4wL25vZGVfbW9kdWxlcy9pc2V4ZS9tb2RlLmpzXG52YXIgcmVxdWlyZV9tb2RlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzZXhlQDIuMC4wL25vZGVfbW9kdWxlcy9pc2V4ZS9tb2RlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGlzZXhlO1xuICAgIGlzZXhlLnN5bmMgPSBzeW5jO1xuICAgIHZhciBmczExID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGZ1bmN0aW9uIGlzZXhlKHBhdGg3LCBvcHRpb25zLCBjYikge1xuICAgICAgZnMxMS5zdGF0KHBhdGg3LCBmdW5jdGlvbihlciwgc3RhdCkge1xuICAgICAgICBjYihlciwgZXIgPyBmYWxzZSA6IGNoZWNrU3RhdChzdGF0LCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGlzZXhlLCBcImlzZXhlXCIpO1xuICAgIGZ1bmN0aW9uIHN5bmMocGF0aDcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjaGVja1N0YXQoZnMxMS5zdGF0U3luYyhwYXRoNyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfX25hbWUoc3luYywgXCJzeW5jXCIpO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RhdChzdGF0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RhdC5pc0ZpbGUoKSAmJiBjaGVja01vZGUoc3RhdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShjaGVja1N0YXQsIFwiY2hlY2tTdGF0XCIpO1xuICAgIGZ1bmN0aW9uIGNoZWNrTW9kZShzdGF0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kMiA9IHN0YXQubW9kZTtcbiAgICAgIHZhciB1aWQgPSBzdGF0LnVpZDtcbiAgICAgIHZhciBnaWQgPSBzdGF0LmdpZDtcbiAgICAgIHZhciBteVVpZCA9IG9wdGlvbnMudWlkICE9PSB2b2lkIDAgPyBvcHRpb25zLnVpZCA6IHByb2Nlc3MuZ2V0dWlkICYmIHByb2Nlc3MuZ2V0dWlkKCk7XG4gICAgICB2YXIgbXlHaWQgPSBvcHRpb25zLmdpZCAhPT0gdm9pZCAwID8gb3B0aW9ucy5naWQgOiBwcm9jZXNzLmdldGdpZCAmJiBwcm9jZXNzLmdldGdpZCgpO1xuICAgICAgdmFyIHUgPSBwYXJzZUludChcIjEwMFwiLCA4KTtcbiAgICAgIHZhciBnID0gcGFyc2VJbnQoXCIwMTBcIiwgOCk7XG4gICAgICB2YXIgbyA9IHBhcnNlSW50KFwiMDAxXCIsIDgpO1xuICAgICAgdmFyIHVnID0gdSB8IGc7XG4gICAgICB2YXIgcmV0ID0gbW9kMiAmIG8gfHwgbW9kMiAmIGcgJiYgZ2lkID09PSBteUdpZCB8fCBtb2QyICYgdSAmJiB1aWQgPT09IG15VWlkIHx8IG1vZDIgJiB1ZyAmJiBteVVpZCA9PT0gMDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIF9fbmFtZShjaGVja01vZGUsIFwiY2hlY2tNb2RlXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzZXhlQDIuMC4wL25vZGVfbW9kdWxlcy9pc2V4ZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNleGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXNleGVAMi4wLjAvbm9kZV9tb2R1bGVzL2lzZXhlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBmczExID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciBjb3JlO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIgfHwgZ2xvYmFsLlRFU1RJTkdfV0lORE9XUykge1xuICAgICAgY29yZSA9IHJlcXVpcmVfd2luZG93cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3JlID0gcmVxdWlyZV9tb2RlKCk7XG4gICAgfVxuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGlzZXhlO1xuICAgIGlzZXhlLnN5bmMgPSBzeW5jO1xuICAgIGZ1bmN0aW9uIGlzZXhlKHBhdGg3LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAoIWNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIG5vdCBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaXNleGUocGF0aDcsIG9wdGlvbnMgfHwge30sIGZ1bmN0aW9uKGVyLCBpcykge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb3JlKHBhdGg3LCBvcHRpb25zIHx8IHt9LCBmdW5jdGlvbihlciwgaXMpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgZXIgPSBudWxsO1xuICAgICAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoZXIsIGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaXNleGUsIFwiaXNleGVcIik7XG4gICAgZnVuY3Rpb24gc3luYyhwYXRoNywgb3B0aW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvcmUuc3luYyhwYXRoNywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUVycm9ycyB8fCBlci5jb2RlID09PSBcIkVBQ0NFU1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzeW5jLCBcInN5bmNcIik7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2hpY2hAMi4wLjIvbm9kZV9tb2R1bGVzL3doaWNoL3doaWNoLmpzXG52YXIgcmVxdWlyZV93aGljaCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93aGljaEAyLjAuMi9ub2RlX21vZHVsZXMvd2hpY2gvd2hpY2guanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiB8fCBwcm9jZXNzLmVudi5PU1RZUEUgPT09IFwiY3lnd2luXCIgfHwgcHJvY2Vzcy5lbnYuT1NUWVBFID09PSBcIm1zeXNcIjtcbiAgICB2YXIgcGF0aDcgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICB2YXIgQ09MT04gPSBpc1dpbmRvd3MgPyBcIjtcIiA6IFwiOlwiO1xuICAgIHZhciBpc2V4ZSA9IHJlcXVpcmVfaXNleGUoKTtcbiAgICB2YXIgZ2V0Tm90Rm91bmRFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNtZCkgPT4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYG5vdCBmb3VuZDogJHtjbWR9YCksIHsgY29kZTogXCJFTk9FTlRcIiB9KSwgXCJnZXROb3RGb3VuZEVycm9yXCIpO1xuICAgIHZhciBnZXRQYXRoSW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNtZCwgb3B0KSA9PiB7XG4gICAgICBjb25zdCBjb2xvbiA9IG9wdC5jb2xvbiB8fCBDT0xPTjtcbiAgICAgIGNvbnN0IHBhdGhFbnYgPSBjbWQubWF0Y2goL1xcLy8pIHx8IGlzV2luZG93cyAmJiBjbWQubWF0Y2goL1xcXFwvKSA/IFtcIlwiXSA6IFtcbiAgICAgICAgLi4uaXNXaW5kb3dzID8gW3Byb2Nlc3MuY3dkKCldIDogW10sXG4gICAgICAgIC4uLihvcHQucGF0aCB8fCBwcm9jZXNzLmVudi5QQVRIIHx8IFwiXCIpLnNwbGl0KGNvbG9uKVxuICAgICAgXTtcbiAgICAgIGNvbnN0IHBhdGhFeHRFeGUgPSBpc1dpbmRvd3MgPyBvcHQucGF0aEV4dCB8fCBwcm9jZXNzLmVudi5QQVRIRVhUIHx8IFwiLkVYRTsuQ01EOy5CQVQ7LkNPTVwiIDogXCJcIjtcbiAgICAgIGNvbnN0IHBhdGhFeHQgPSBpc1dpbmRvd3MgPyBwYXRoRXh0RXhlLnNwbGl0KGNvbG9uKSA6IFtcIlwiXTtcbiAgICAgIGlmIChpc1dpbmRvd3MpIHtcbiAgICAgICAgaWYgKGNtZC5pbmRleE9mKFwiLlwiKSAhPT0gLTEgJiYgcGF0aEV4dFswXSAhPT0gXCJcIilcbiAgICAgICAgICBwYXRoRXh0LnVuc2hpZnQoXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoRW52LFxuICAgICAgICBwYXRoRXh0LFxuICAgICAgICBwYXRoRXh0RXhlXG4gICAgICB9O1xuICAgIH0sIFwiZ2V0UGF0aEluZm9cIik7XG4gICAgdmFyIHdoaWNoID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY21kLCBvcHQsIGNiKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNiID0gb3B0O1xuICAgICAgICBvcHQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0KVxuICAgICAgICBvcHQgPSB7fTtcbiAgICAgIGNvbnN0IHsgcGF0aEVudiwgcGF0aEV4dCwgcGF0aEV4dEV4ZSB9ID0gZ2V0UGF0aEluZm8oY21kLCBvcHQpO1xuICAgICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpID09PSBwYXRoRW52Lmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gb3B0LmFsbCAmJiBmb3VuZC5sZW5ndGggPyByZXNvbHZlKGZvdW5kKSA6IHJlamVjdChnZXROb3RGb3VuZEVycm9yKGNtZCkpO1xuICAgICAgICBjb25zdCBwcFJhdyA9IHBhdGhFbnZbaV07XG4gICAgICAgIGNvbnN0IHBhdGhQYXJ0ID0gL15cIi4qXCIkLy50ZXN0KHBwUmF3KSA/IHBwUmF3LnNsaWNlKDEsIC0xKSA6IHBwUmF3O1xuICAgICAgICBjb25zdCBwQ21kID0gcGF0aDcuam9pbihwYXRoUGFydCwgY21kKTtcbiAgICAgICAgY29uc3QgcCA9ICFwYXRoUGFydCAmJiAvXlxcLltcXFxcXFwvXS8udGVzdChjbWQpID8gY21kLnNsaWNlKDAsIDIpICsgcENtZCA6IHBDbWQ7XG4gICAgICAgIHJlc29sdmUoc3ViU3RlcChwLCBpLCAwKSk7XG4gICAgICB9KSwgXCJzdGVwXCIpO1xuICAgICAgY29uc3Qgc3ViU3RlcCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHAsIGksIGlpKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpaSA9PT0gcGF0aEV4dC5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3RlcChpICsgMSkpO1xuICAgICAgICBjb25zdCBleHQgPSBwYXRoRXh0W2lpXTtcbiAgICAgICAgaXNleGUocCArIGV4dCwgeyBwYXRoRXh0OiBwYXRoRXh0RXhlIH0sIChlciwgaXMpID0+IHtcbiAgICAgICAgICBpZiAoIWVyICYmIGlzKSB7XG4gICAgICAgICAgICBpZiAob3B0LmFsbClcbiAgICAgICAgICAgICAgZm91bmQucHVzaChwICsgZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocCArIGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHN1YlN0ZXAocCwgaSwgaWkgKyAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIFwic3ViU3RlcFwiKTtcbiAgICAgIHJldHVybiBjYiA/IHN0ZXAoMCkudGhlbigocmVzKSA9PiBjYihudWxsLCByZXMpLCBjYikgOiBzdGVwKDApO1xuICAgIH0sIFwid2hpY2hcIik7XG4gICAgdmFyIHdoaWNoU3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNtZCwgb3B0KSA9PiB7XG4gICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICBjb25zdCB7IHBhdGhFbnYsIHBhdGhFeHQsIHBhdGhFeHRFeGUgfSA9IGdldFBhdGhJbmZvKGNtZCwgb3B0KTtcbiAgICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhFbnYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHBSYXcgPSBwYXRoRW52W2ldO1xuICAgICAgICBjb25zdCBwYXRoUGFydCA9IC9eXCIuKlwiJC8udGVzdChwcFJhdykgPyBwcFJhdy5zbGljZSgxLCAtMSkgOiBwcFJhdztcbiAgICAgICAgY29uc3QgcENtZCA9IHBhdGg3LmpvaW4ocGF0aFBhcnQsIGNtZCk7XG4gICAgICAgIGNvbnN0IHAgPSAhcGF0aFBhcnQgJiYgL15cXC5bXFxcXFxcL10vLnRlc3QoY21kKSA/IGNtZC5zbGljZSgwLCAyKSArIHBDbWQgOiBwQ21kO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdGhFeHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjdXIgPSBwICsgcGF0aEV4dFtqXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXMgPSBpc2V4ZS5zeW5jKGN1ciwgeyBwYXRoRXh0OiBwYXRoRXh0RXhlIH0pO1xuICAgICAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgICAgIGlmIChvcHQuYWxsKVxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHQuYWxsICYmIGZvdW5kLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgaWYgKG9wdC5ub3Rocm93KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHRocm93IGdldE5vdEZvdW5kRXJyb3IoY21kKTtcbiAgICB9LCBcIndoaWNoU3luY1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB3aGljaDtcbiAgICB3aGljaC5zeW5jID0gd2hpY2hTeW5jO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3BhdGgta2V5QDMuMS4xL25vZGVfbW9kdWxlcy9wYXRoLWtleS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcGF0aF9rZXkgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGF0aC1rZXlAMy4xLjEvbm9kZV9tb2R1bGVzL3BhdGgta2V5L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwYXRoS2V5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52IHx8IHByb2Nlc3MuZW52O1xuICAgICAgY29uc3QgcGxhdGZvcm0zID0gb3B0aW9ucy5wbGF0Zm9ybSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xuICAgICAgaWYgKHBsYXRmb3JtMyAhPT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIHJldHVybiBcIlBBVEhcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlbnZpcm9ubWVudCkucmV2ZXJzZSgpLmZpbmQoKGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IFwiUEFUSFwiKSB8fCBcIlBhdGhcIjtcbiAgICB9LCBcInBhdGhLZXlcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcGF0aEtleTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZGVmYXVsdCA9IHBhdGhLZXk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi91dGlsL3Jlc29sdmVDb21tYW5kLmpzXG52YXIgcmVxdWlyZV9yZXNvbHZlQ29tbWFuZCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvcmVzb2x2ZUNvbW1hbmQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHBhdGg3ID0gcmVxdWlyZShcInBhdGhcIik7XG4gICAgdmFyIHdoaWNoID0gcmVxdWlyZV93aGljaCgpO1xuICAgIHZhciBnZXRQYXRoS2V5ID0gcmVxdWlyZV9wYXRoX2tleSgpO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDb21tYW5kQXR0ZW1wdChwYXJzZWQsIHdpdGhvdXRQYXRoRXh0KSB7XG4gICAgICBjb25zdCBlbnYyID0gcGFyc2VkLm9wdGlvbnMuZW52IHx8IHByb2Nlc3MuZW52O1xuICAgICAgY29uc3QgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgIGNvbnN0IGhhc0N1c3RvbUN3ZCA9IHBhcnNlZC5vcHRpb25zLmN3ZCAhPSBudWxsO1xuICAgICAgY29uc3Qgc2hvdWxkU3dpdGNoQ3dkID0gaGFzQ3VzdG9tQ3dkICYmIHByb2Nlc3MuY2hkaXIgIT09IHZvaWQgMCAmJiAhcHJvY2Vzcy5jaGRpci5kaXNhYmxlZDtcbiAgICAgIGlmIChzaG91bGRTd2l0Y2hDd2QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9jZXNzLmNoZGlyKHBhcnNlZC5vcHRpb25zLmN3ZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmVzb2x2ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlZCA9IHdoaWNoLnN5bmMocGFyc2VkLmNvbW1hbmQsIHtcbiAgICAgICAgICBwYXRoOiBlbnYyW2dldFBhdGhLZXkoeyBlbnY6IGVudjIgfSldLFxuICAgICAgICAgIHBhdGhFeHQ6IHdpdGhvdXRQYXRoRXh0ID8gcGF0aDcuZGVsaW1pdGVyIDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHNob3VsZFN3aXRjaEN3ZCkge1xuICAgICAgICAgIHByb2Nlc3MuY2hkaXIoY3dkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gcGF0aDcucmVzb2x2ZShoYXNDdXN0b21Dd2QgPyBwYXJzZWQub3B0aW9ucy5jd2QgOiBcIlwiLCByZXNvbHZlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIF9fbmFtZShyZXNvbHZlQ29tbWFuZEF0dGVtcHQsIFwicmVzb2x2ZUNvbW1hbmRBdHRlbXB0XCIpO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVDb21tYW5kKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVDb21tYW5kQXR0ZW1wdChwYXJzZWQpIHx8IHJlc29sdmVDb21tYW5kQXR0ZW1wdChwYXJzZWQsIHRydWUpO1xuICAgIH1cbiAgICBfX25hbWUocmVzb2x2ZUNvbW1hbmQsIFwicmVzb2x2ZUNvbW1hbmRcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVzb2x2ZUNvbW1hbmQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi91dGlsL2VzY2FwZS5qc1xudmFyIHJlcXVpcmVfZXNjYXBlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvdXRpbC9lc2NhcGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG1ldGFDaGFyc1JlZ0V4cCA9IC8oWygpXFxdWyUhXlwiYDw+Jnw7LCAqP10pL2c7XG4gICAgZnVuY3Rpb24gZXNjYXBlQ29tbWFuZChhcmcyKSB7XG4gICAgICBhcmcyID0gYXJnMi5yZXBsYWNlKG1ldGFDaGFyc1JlZ0V4cCwgXCJeJDFcIik7XG4gICAgICByZXR1cm4gYXJnMjtcbiAgICB9XG4gICAgX19uYW1lKGVzY2FwZUNvbW1hbmQsIFwiZXNjYXBlQ29tbWFuZFwiKTtcbiAgICBmdW5jdGlvbiBlc2NhcGVBcmd1bWVudChhcmcyLCBkb3VibGVFc2NhcGVNZXRhQ2hhcnMpIHtcbiAgICAgIGFyZzIgPSBgJHthcmcyfWA7XG4gICAgICBhcmcyID0gYXJnMi5yZXBsYWNlKC8oXFxcXCopXCIvZywgJyQxJDFcXFxcXCInKTtcbiAgICAgIGFyZzIgPSBhcmcyLnJlcGxhY2UoLyhcXFxcKikkLywgXCIkMSQxXCIpO1xuICAgICAgYXJnMiA9IGBcIiR7YXJnMn1cImA7XG4gICAgICBhcmcyID0gYXJnMi5yZXBsYWNlKG1ldGFDaGFyc1JlZ0V4cCwgXCJeJDFcIik7XG4gICAgICBpZiAoZG91YmxlRXNjYXBlTWV0YUNoYXJzKSB7XG4gICAgICAgIGFyZzIgPSBhcmcyLnJlcGxhY2UobWV0YUNoYXJzUmVnRXhwLCBcIl4kMVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmcyO1xuICAgIH1cbiAgICBfX25hbWUoZXNjYXBlQXJndW1lbnQsIFwiZXNjYXBlQXJndW1lbnRcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzLmNvbW1hbmQgPSBlc2NhcGVDb21tYW5kO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5hcmd1bWVudCA9IGVzY2FwZUFyZ3VtZW50O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoZWJhbmctcmVnZXhAMy4wLjAvbm9kZV9tb2R1bGVzL3NoZWJhbmctcmVnZXgvaW5kZXguanNcbnZhciByZXF1aXJlX3NoZWJhbmdfcmVnZXggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2hlYmFuZy1yZWdleEAzLjAuMC9ub2RlX21vZHVsZXMvc2hlYmFuZy1yZWdleC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAvXiMhKC4qKS87XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2hlYmFuZy1jb21tYW5kQDIuMC4wL25vZGVfbW9kdWxlcy9zaGViYW5nLWNvbW1hbmQvaW5kZXguanNcbnZhciByZXF1aXJlX3NoZWJhbmdfY29tbWFuZCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGViYW5nLWNvbW1hbmRAMi4wLjAvbm9kZV9tb2R1bGVzL3NoZWJhbmctY29tbWFuZC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgc2hlYmFuZ1JlZ2V4ID0gcmVxdWlyZV9zaGViYW5nX3JlZ2V4KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKHN0cmluZyA9IFwiXCIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3RyaW5nLm1hdGNoKHNoZWJhbmdSZWdleCk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgW3BhdGg3LCBhcmd1bWVudF0gPSBtYXRjaFswXS5yZXBsYWNlKC8jISA/LywgXCJcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgY29uc3QgYmluYXJ5ID0gcGF0aDcuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgaWYgKGJpbmFyeSA9PT0gXCJlbnZcIikge1xuICAgICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJndW1lbnQgPyBgJHtiaW5hcnl9ICR7YXJndW1lbnR9YCA6IGJpbmFyeTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvdXRpbC9yZWFkU2hlYmFuZy5qc1xudmFyIHJlcXVpcmVfcmVhZFNoZWJhbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi91dGlsL3JlYWRTaGViYW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmczExID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciBzaGViYW5nQ29tbWFuZCA9IHJlcXVpcmVfc2hlYmFuZ19jb21tYW5kKCk7XG4gICAgZnVuY3Rpb24gcmVhZFNoZWJhbmcoY29tbWFuZCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IDE1MDtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgIGxldCBmZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZkID0gZnMxMS5vcGVuU3luYyhjb21tYW5kLCBcInJcIik7XG4gICAgICAgIGZzMTEucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgc2l6ZSwgMCk7XG4gICAgICAgIGZzMTEuY2xvc2VTeW5jKGZkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGViYW5nQ29tbWFuZChidWZmZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIF9fbmFtZShyZWFkU2hlYmFuZywgXCJyZWFkU2hlYmFuZ1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZWFkU2hlYmFuZztcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3BhcnNlLmpzXG52YXIgcmVxdWlyZV9wYXJzZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3BhcnNlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwYXRoNyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciByZXNvbHZlQ29tbWFuZCA9IHJlcXVpcmVfcmVzb2x2ZUNvbW1hbmQoKTtcbiAgICB2YXIgZXNjYXBlID0gcmVxdWlyZV9lc2NhcGUoKTtcbiAgICB2YXIgcmVhZFNoZWJhbmcgPSByZXF1aXJlX3JlYWRTaGViYW5nKCk7XG4gICAgdmFyIGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuICAgIHZhciBpc0V4ZWN1dGFibGVSZWdFeHAgPSAvXFwuKD86Y29tfGV4ZSkkL2k7XG4gICAgdmFyIGlzQ21kU2hpbVJlZ0V4cCA9IC9ub2RlX21vZHVsZXNbXFxcXC9dLmJpbltcXFxcL11bXlxcXFwvXStcXC5jbWQkL2k7XG4gICAgZnVuY3Rpb24gZGV0ZWN0U2hlYmFuZyhwYXJzZWQpIHtcbiAgICAgIHBhcnNlZC5maWxlID0gcmVzb2x2ZUNvbW1hbmQocGFyc2VkKTtcbiAgICAgIGNvbnN0IHNoZWJhbmcgPSBwYXJzZWQuZmlsZSAmJiByZWFkU2hlYmFuZyhwYXJzZWQuZmlsZSk7XG4gICAgICBpZiAoc2hlYmFuZykge1xuICAgICAgICBwYXJzZWQuYXJncy51bnNoaWZ0KHBhcnNlZC5maWxlKTtcbiAgICAgICAgcGFyc2VkLmNvbW1hbmQgPSBzaGViYW5nO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbW1hbmQocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQuZmlsZTtcbiAgICB9XG4gICAgX19uYW1lKGRldGVjdFNoZWJhbmcsIFwiZGV0ZWN0U2hlYmFuZ1wiKTtcbiAgICBmdW5jdGlvbiBwYXJzZU5vblNoZWxsKHBhcnNlZCkge1xuICAgICAgaWYgKCFpc1dpbikge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbWFuZEZpbGUgPSBkZXRlY3RTaGViYW5nKHBhcnNlZCk7XG4gICAgICBjb25zdCBuZWVkc1NoZWxsID0gIWlzRXhlY3V0YWJsZVJlZ0V4cC50ZXN0KGNvbW1hbmRGaWxlKTtcbiAgICAgIGlmIChwYXJzZWQub3B0aW9ucy5mb3JjZVNoZWxsIHx8IG5lZWRzU2hlbGwpIHtcbiAgICAgICAgY29uc3QgbmVlZHNEb3VibGVFc2NhcGVNZXRhQ2hhcnMgPSBpc0NtZFNoaW1SZWdFeHAudGVzdChjb21tYW5kRmlsZSk7XG4gICAgICAgIHBhcnNlZC5jb21tYW5kID0gcGF0aDcubm9ybWFsaXplKHBhcnNlZC5jb21tYW5kKTtcbiAgICAgICAgcGFyc2VkLmNvbW1hbmQgPSBlc2NhcGUuY29tbWFuZChwYXJzZWQuY29tbWFuZCk7XG4gICAgICAgIHBhcnNlZC5hcmdzID0gcGFyc2VkLmFyZ3MubWFwKChhcmcyKSA9PiBlc2NhcGUuYXJndW1lbnQoYXJnMiwgbmVlZHNEb3VibGVFc2NhcGVNZXRhQ2hhcnMpKTtcbiAgICAgICAgY29uc3Qgc2hlbGxDb21tYW5kID0gW3BhcnNlZC5jb21tYW5kXS5jb25jYXQocGFyc2VkLmFyZ3MpLmpvaW4oXCIgXCIpO1xuICAgICAgICBwYXJzZWQuYXJncyA9IFtcIi9kXCIsIFwiL3NcIiwgXCIvY1wiLCBgXCIke3NoZWxsQ29tbWFuZH1cImBdO1xuICAgICAgICBwYXJzZWQuY29tbWFuZCA9IHByb2Nlc3MuZW52LmNvbXNwZWMgfHwgXCJjbWQuZXhlXCI7XG4gICAgICAgIHBhcnNlZC5vcHRpb25zLndpbmRvd3NWZXJiYXRpbUFyZ3VtZW50cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VOb25TaGVsbCwgXCJwYXJzZU5vblNoZWxsXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlMihjb21tYW5kLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoYXJncyAmJiAhQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBvcHRpb25zID0gYXJncztcbiAgICAgICAgYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgICBhcmdzID0gYXJncyA/IGFyZ3Muc2xpY2UoMCkgOiBbXTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgICAgY29tbWFuZCxcbiAgICAgICAgYXJncyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZmlsZTogdm9pZCAwLFxuICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc2hlbGwgPyBwYXJzZWQgOiBwYXJzZU5vblNoZWxsKHBhcnNlZCk7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZTIsIFwicGFyc2VcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcGFyc2UyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvZW5vZW50LmpzXG52YXIgcmVxdWlyZV9lbm9lbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi9lbm9lbnQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuICAgIGZ1bmN0aW9uIG5vdEZvdW5kRXJyb3Iob3JpZ2luYWwsIHN5c2NhbGwpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgJHtzeXNjYWxsfSAke29yaWdpbmFsLmNvbW1hbmR9IEVOT0VOVGApLCB7XG4gICAgICAgIGNvZGU6IFwiRU5PRU5UXCIsXG4gICAgICAgIGVycm5vOiBcIkVOT0VOVFwiLFxuICAgICAgICBzeXNjYWxsOiBgJHtzeXNjYWxsfSAke29yaWdpbmFsLmNvbW1hbmR9YCxcbiAgICAgICAgcGF0aDogb3JpZ2luYWwuY29tbWFuZCxcbiAgICAgICAgc3Bhd25hcmdzOiBvcmlnaW5hbC5hcmdzXG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKG5vdEZvdW5kRXJyb3IsIFwibm90Rm91bmRFcnJvclwiKTtcbiAgICBmdW5jdGlvbiBob29rQ2hpbGRQcm9jZXNzKGNwLCBwYXJzZWQpIHtcbiAgICAgIGlmICghaXNXaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JpZ2luYWxFbWl0ID0gY3AuZW1pdDtcbiAgICAgIGNwLmVtaXQgPSBmdW5jdGlvbihuYW1lLCBhcmcxKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcImV4aXRcIikge1xuICAgICAgICAgIGNvbnN0IGVyciA9IHZlcmlmeUVOT0VOVChhcmcxLCBwYXJzZWQsIFwic3Bhd25cIik7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRW1pdC5jYWxsKGNwLCBcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEVtaXQuYXBwbHkoY3AsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoaG9va0NoaWxkUHJvY2VzcywgXCJob29rQ2hpbGRQcm9jZXNzXCIpO1xuICAgIGZ1bmN0aW9uIHZlcmlmeUVOT0VOVChzdGF0dXMsIHBhcnNlZCkge1xuICAgICAgaWYgKGlzV2luICYmIHN0YXR1cyA9PT0gMSAmJiAhcGFyc2VkLmZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvdW5kRXJyb3IocGFyc2VkLm9yaWdpbmFsLCBcInNwYXduXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9fbmFtZSh2ZXJpZnlFTk9FTlQsIFwidmVyaWZ5RU5PRU5UXCIpO1xuICAgIGZ1bmN0aW9uIHZlcmlmeUVOT0VOVFN5bmMoc3RhdHVzLCBwYXJzZWQpIHtcbiAgICAgIGlmIChpc1dpbiAmJiBzdGF0dXMgPT09IDEgJiYgIXBhcnNlZC5maWxlKSB7XG4gICAgICAgIHJldHVybiBub3RGb3VuZEVycm9yKHBhcnNlZC5vcmlnaW5hbCwgXCJzcGF3blN5bmNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHZlcmlmeUVOT0VOVFN5bmMsIFwidmVyaWZ5RU5PRU5UU3luY1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBob29rQ2hpbGRQcm9jZXNzLFxuICAgICAgdmVyaWZ5RU5PRU5ULFxuICAgICAgdmVyaWZ5RU5PRU5UU3luYyxcbiAgICAgIG5vdEZvdW5kRXJyb3JcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9pbmRleC5qc1xudmFyIHJlcXVpcmVfY3Jvc3Nfc3Bhd24gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjcCA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuICAgIHZhciBwYXJzZTIgPSByZXF1aXJlX3BhcnNlKCk7XG4gICAgdmFyIGVub2VudCA9IHJlcXVpcmVfZW5vZW50KCk7XG4gICAgZnVuY3Rpb24gc3Bhd24yKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlMihjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNwYXduZWQgPSBjcC5zcGF3bihwYXJzZWQuY29tbWFuZCwgcGFyc2VkLmFyZ3MsIHBhcnNlZC5vcHRpb25zKTtcbiAgICAgIGVub2VudC5ob29rQ2hpbGRQcm9jZXNzKHNwYXduZWQsIHBhcnNlZCk7XG4gICAgICByZXR1cm4gc3Bhd25lZDtcbiAgICB9XG4gICAgX19uYW1lKHNwYXduMiwgXCJzcGF3blwiKTtcbiAgICBmdW5jdGlvbiBzcGF3blN5bmMoY29tbWFuZCwgYXJncywgb3B0aW9ucykge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UyKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3Auc3Bhd25TeW5jKHBhcnNlZC5jb21tYW5kLCBwYXJzZWQuYXJncywgcGFyc2VkLm9wdGlvbnMpO1xuICAgICAgcmVzdWx0LmVycm9yID0gcmVzdWx0LmVycm9yIHx8IGVub2VudC52ZXJpZnlFTk9FTlRTeW5jKHJlc3VsdC5zdGF0dXMsIHBhcnNlZCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUoc3Bhd25TeW5jLCBcInNwYXduU3luY1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzcGF3bjI7XG4gICAgbW9kdWxlMi5leHBvcnRzLnNwYXduID0gc3Bhd24yO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5zeW5jID0gc3Bhd25TeW5jO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5fcGFyc2UgPSBwYXJzZTI7XG4gICAgbW9kdWxlMi5leHBvcnRzLl9lbm9lbnQgPSBlbm9lbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByaXNtYStlbmdpbmVzLXZlcnNpb25ANC4zLjAtMzIuYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYi9ub2RlX21vZHVsZXMvQHByaXNtYS9lbmdpbmVzLXZlcnNpb24vcGFja2FnZS5qc29uXG52YXIgcmVxdWlyZV9wYWNrYWdlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BwcmlzbWErZW5naW5lcy12ZXJzaW9uQDQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGIvbm9kZV9tb2R1bGVzL0BwcmlzbWEvZW5naW5lcy12ZXJzaW9uL3BhY2thZ2UuanNvblwiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBuYW1lOiBcIkBwcmlzbWEvZW5naW5lcy12ZXJzaW9uXCIsXG4gICAgICB2ZXJzaW9uOiBcIjQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIixcbiAgICAgIG1haW46IFwiaW5kZXguanNcIixcbiAgICAgIHR5cGVzOiBcImluZGV4LmQudHNcIixcbiAgICAgIGxpY2Vuc2U6IFwiQXBhY2hlLTIuMFwiLFxuICAgICAgYXV0aG9yOiBcIlRpbSBTdWNoYW5layA8c3VjaGFuZWtAcHJpc21hLmlvPlwiLFxuICAgICAgcHJpc21hOiB7XG4gICAgICAgIGVuZ2luZXNWZXJzaW9uOiBcImM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIlxuICAgICAgfSxcbiAgICAgIHJlcG9zaXRvcnk6IHtcbiAgICAgICAgdHlwZTogXCJnaXRcIixcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvZW5naW5lcy13cmFwcGVyLmdpdFwiLFxuICAgICAgICBkaXJlY3Rvcnk6IFwicGFja2FnZXMvZW5naW5lcy12ZXJzaW9uXCJcbiAgICAgIH0sXG4gICAgICBkZXZEZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgXCJAdHlwZXMvbm9kZVwiOiBcIjE2LjExLjU2XCIsXG4gICAgICAgIHR5cGVzY3JpcHQ6IFwiNC43LjRcIlxuICAgICAgfSxcbiAgICAgIGZpbGVzOiBbXG4gICAgICAgIFwiaW5kZXguanNcIixcbiAgICAgICAgXCJpbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBzY3JpcHRzOiB7XG4gICAgICAgIGJ1aWxkOiBcInRzYyAtZFwiXG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJpc21hK2VuZ2luZXMtdmVyc2lvbkA0LjMuMC0zMi5jODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiL25vZGVfbW9kdWxlcy9AcHJpc21hL2VuZ2luZXMtdmVyc2lvbi9pbmRleC5qc1xudmFyIHJlcXVpcmVfZW5naW5lc192ZXJzaW9uID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BwcmlzbWErZW5naW5lcy12ZXJzaW9uQDQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGIvbm9kZV9tb2R1bGVzL0BwcmlzbWEvZW5naW5lcy12ZXJzaW9uL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmVuZ2luZXNWZXJzaW9uID0gdm9pZCAwO1xuICAgIGV4cG9ydHMuZW5naW5lc1ZlcnNpb24gPSByZXF1aXJlX3BhY2thZ2UoKS5wcmlzbWEuZW5naW5lc1ZlcnNpb247XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyaXAtZmluYWwtbmV3bGluZUAyLjAuMC9ub2RlX21vZHVsZXMvc3RyaXAtZmluYWwtbmV3bGluZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3RyaXBfZmluYWxfbmV3bGluZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpcC1maW5hbC1uZXdsaW5lQDIuMC4wL25vZGVfbW9kdWxlcy9zdHJpcC1maW5hbC1uZXdsaW5lL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChpbnB1dCkgPT4ge1xuICAgICAgY29uc3QgTEYgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBcIlxcblwiIDogXCJcXG5cIi5jaGFyQ29kZUF0KCk7XG4gICAgICBjb25zdCBDUiA9IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IFwiXFxyXCIgOiBcIlxcclwiLmNoYXJDb2RlQXQoKTtcbiAgICAgIGlmIChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gTEYpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpbnB1dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gQ1IpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgwLCBpbnB1dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25wbS1ydW4tcGF0aEA0LjAuMS9ub2RlX21vZHVsZXMvbnBtLXJ1bi1wYXRoL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ucG1fcnVuX3BhdGggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbnBtLXJ1bi1wYXRoQDQuMC4xL25vZGVfbW9kdWxlcy9ucG0tcnVuLXBhdGgvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHBhdGg3ID0gcmVxdWlyZShcInBhdGhcIik7XG4gICAgdmFyIHBhdGhLZXkgPSByZXF1aXJlX3BhdGhfa2V5KCk7XG4gICAgdmFyIG5wbVJ1blBhdGggPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgICAgIHBhdGg6IHByb2Nlc3MuZW52W3BhdGhLZXkoKV0sXG4gICAgICAgIGV4ZWNQYXRoOiBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgbGV0IHByZXZpb3VzO1xuICAgICAgbGV0IGN3ZFBhdGggPSBwYXRoNy5yZXNvbHZlKG9wdGlvbnMuY3dkKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKHByZXZpb3VzICE9PSBjd2RQYXRoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhdGg3LmpvaW4oY3dkUGF0aCwgXCJub2RlX21vZHVsZXMvLmJpblwiKSk7XG4gICAgICAgIHByZXZpb3VzID0gY3dkUGF0aDtcbiAgICAgICAgY3dkUGF0aCA9IHBhdGg3LnJlc29sdmUoY3dkUGF0aCwgXCIuLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4ZWNQYXRoRGlyID0gcGF0aDcucmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5leGVjUGF0aCwgXCIuLlwiKTtcbiAgICAgIHJlc3VsdC5wdXNoKGV4ZWNQYXRoRGlyKTtcbiAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KG9wdGlvbnMucGF0aCkuam9pbihwYXRoNy5kZWxpbWl0ZXIpO1xuICAgIH0sIFwibnBtUnVuUGF0aFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBucG1SdW5QYXRoO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gbnBtUnVuUGF0aDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZW52ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBlbnYyID0geyAuLi5vcHRpb25zLmVudiB9O1xuICAgICAgY29uc3QgcGF0aDggPSBwYXRoS2V5KHsgZW52OiBlbnYyIH0pO1xuICAgICAgb3B0aW9ucy5wYXRoID0gZW52MltwYXRoOF07XG4gICAgICBlbnYyW3BhdGg4XSA9IG1vZHVsZTIuZXhwb3J0cyhvcHRpb25zKTtcbiAgICAgIHJldHVybiBlbnYyO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWltaWMtZm5AMi4xLjAvbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzXG52YXIgcmVxdWlyZV9taW1pY19mbiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW1pYy1mbkAyLjEuMC9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG1pbWljRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh0bywgZnJvbSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwgcHJvcCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvO1xuICAgIH0sIFwibWltaWNGblwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBtaW1pY0ZuO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9vbmV0aW1lQDUuMS4yL25vZGVfbW9kdWxlcy9vbmV0aW1lL2luZGV4LmpzXG52YXIgcmVxdWlyZV9vbmV0aW1lID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL29uZXRpbWVANS4xLjIvbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG1pbWljRm4gPSByZXF1aXJlX21pbWljX2ZuKCk7XG4gICAgdmFyIGNhbGxlZEZ1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBvbmV0aW1lID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZnVuY3Rpb25fLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uXy5kaXNwbGF5TmFtZSB8fCBmdW5jdGlvbl8ubmFtZSB8fCBcIjxhbm9ueW1vdXM+XCI7XG4gICAgICBjb25zdCBvbmV0aW1lMiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oLi4uYXJndW1lbnRzXykge1xuICAgICAgICBjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUyLCArK2NhbGxDb3VudCk7XG4gICAgICAgIGlmIChjYWxsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcbiAgICAgICAgICBmdW5jdGlvbl8gPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGhyb3cgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgIH0sIFwib25ldGltZVwiKTtcbiAgICAgIG1pbWljRm4ob25ldGltZTIsIGZ1bmN0aW9uXyk7XG4gICAgICBjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUyLCBjYWxsQ291bnQpO1xuICAgICAgcmV0dXJuIG9uZXRpbWUyO1xuICAgIH0sIFwib25ldGltZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBvbmV0aW1lO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY2FsbENvdW50ID0gKGZ1bmN0aW9uXykgPT4ge1xuICAgICAgaWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZnVuY3Rpb24gXFxgJHtmdW5jdGlvbl8ubmFtZX1cXGAgaXMgbm90IHdyYXBwZWQgYnkgdGhlIFxcYG9uZXRpbWVcXGAgcGFja2FnZWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxlZEZ1bmN0aW9ucy5nZXQoZnVuY3Rpb25fKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h1bWFuLXNpZ25hbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2h1bWFuLXNpZ25hbHMvYnVpbGQvc3JjL2NvcmUuanNcbnZhciByZXF1aXJlX2NvcmUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvY29yZS5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5TSUdOQUxTID0gdm9pZCAwO1xuICAgIHZhciBTSUdOQUxTID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0hVUFwiLFxuICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGVybWluYWwgY2xvc2VkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHSU5UXCIsXG4gICAgICAgIG51bWJlcjogMixcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJVc2VyIGludGVycnVwdGlvbiB3aXRoIENUUkwtQ1wiLFxuICAgICAgICBzdGFuZGFyZDogXCJhbnNpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHUVVJVFwiLFxuICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZXIgaW50ZXJydXB0aW9uIHdpdGggQ1RSTC1cXFxcXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHSUxMXCIsXG4gICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW52YWxpZCBtYWNoaW5lIGluc3RydWN0aW9uXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImFuc2lcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdUUkFQXCIsXG4gICAgICAgIG51bWJlcjogNSxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRGVidWdnZXIgYnJlYWtwb2ludFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0FCUlRcIixcbiAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBYm9ydGVkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImFuc2lcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdJT1RcIixcbiAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBYm9ydGVkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImJzZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0JVU1wiLFxuICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkJ1cyBlcnJvciBkdWUgdG8gbWlzYWxpZ25lZCwgbm9uLWV4aXN0aW5nIGFkZHJlc3Mgb3IgcGFnaW5nIGVycm9yXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImJzZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0VNVFwiLFxuICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ29tbWFuZCBzaG91bGQgYmUgZW11bGF0ZWQgYnV0IGlzIG5vdCBpbXBsZW1lbnRlZFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0ZQRVwiLFxuICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgZXJyb3JcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYW5zaVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0tJTExcIixcbiAgICAgICAgbnVtYmVyOiA5LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZvcmNlZCB0ZXJtaW5hdGlvblwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiLFxuICAgICAgICBmb3JjZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVVNSMVwiLFxuICAgICAgICBudW1iZXI6IDEwLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFwcGxpY2F0aW9uLXNwZWNpZmljIHNpZ25hbFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1NFR1ZcIixcbiAgICAgICAgbnVtYmVyOiAxMSxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VnbWVudGF0aW9uIGZhdWx0XCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImFuc2lcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdVU1IyXCIsXG4gICAgICAgIG51bWJlcjogMTIsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQXBwbGljYXRpb24tc3BlY2lmaWMgc2lnbmFsXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHUElQRVwiLFxuICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkJyb2tlbiBwaXBlIG9yIHNvY2tldFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0FMUk1cIixcbiAgICAgICAgbnVtYmVyOiAxNCxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaW1lb3V0IG9yIHRpbWVyXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVEVSTVwiLFxuICAgICAgICBudW1iZXI6IDE1LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRlcm1pbmF0aW9uXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImFuc2lcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdTVEtGTFRcIixcbiAgICAgICAgbnVtYmVyOiAxNixcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTdGFjayBpcyBlbXB0eSBvciBvdmVyZmxvd2VkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcIm90aGVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQ0hMRFwiLFxuICAgICAgICBudW1iZXI6IDE3LFxuICAgICAgICBhY3Rpb246IFwiaWdub3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNoaWxkIHByb2Nlc3MgdGVybWluYXRlZCwgcGF1c2VkIG9yIHVucGF1c2VkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQ0xEXCIsXG4gICAgICAgIG51bWJlcjogMTcsXG4gICAgICAgIGFjdGlvbjogXCJpZ25vcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ2hpbGQgcHJvY2VzcyB0ZXJtaW5hdGVkLCBwYXVzZWQgb3IgdW5wYXVzZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdDT05UXCIsXG4gICAgICAgIG51bWJlcjogMTgsXG4gICAgICAgIGFjdGlvbjogXCJ1bnBhdXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVucGF1c2VkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCIsXG4gICAgICAgIGZvcmNlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdTVE9QXCIsXG4gICAgICAgIG51bWJlcjogMTksXG4gICAgICAgIGFjdGlvbjogXCJwYXVzZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJQYXVzZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIixcbiAgICAgICAgZm9yY2VkOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1RTVFBcIixcbiAgICAgICAgbnVtYmVyOiAyMCxcbiAgICAgICAgYWN0aW9uOiBcInBhdXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUGF1c2VkIHVzaW5nIENUUkwtWiBvciBcInN1c3BlbmRcIicsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVFRJTlwiLFxuICAgICAgICBudW1iZXI6IDIxLFxuICAgICAgICBhY3Rpb246IFwicGF1c2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQmFja2dyb3VuZCBwcm9jZXNzIGNhbm5vdCByZWFkIHRlcm1pbmFsIGlucHV0XCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQlJFQUtcIixcbiAgICAgICAgbnVtYmVyOiAyMSxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJVc2VyIGludGVycnVwdGlvbiB3aXRoIENUUkwtQlJFQUtcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdUVE9VXCIsXG4gICAgICAgIG51bWJlcjogMjIsXG4gICAgICAgIGFjdGlvbjogXCJwYXVzZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJCYWNrZ3JvdW5kIHByb2Nlc3MgY2Fubm90IHdyaXRlIHRvIHRlcm1pbmFsIG91dHB1dFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1VSR1wiLFxuICAgICAgICBudW1iZXI6IDIzLFxuICAgICAgICBhY3Rpb246IFwiaWdub3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNvY2tldCByZWNlaXZlZCBvdXQtb2YtYmFuZCBkYXRhXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImJzZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1hDUFVcIixcbiAgICAgICAgbnVtYmVyOiAyNCxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUHJvY2VzcyB0aW1lZCBvdXRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHWEZTWlwiLFxuICAgICAgICBudW1iZXI6IDI1LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWxlIHRvbyBiaWdcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVlRBTFJNXCIsXG4gICAgICAgIG51bWJlcjogMjYsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGltZW91dCBvciB0aW1lclwiLFxuICAgICAgICBzdGFuZGFyZDogXCJic2RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdQUk9GXCIsXG4gICAgICAgIG51bWJlcjogMjcsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGltZW91dCBvciB0aW1lclwiLFxuICAgICAgICBzdGFuZGFyZDogXCJic2RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdXSU5DSFwiLFxuICAgICAgICBudW1iZXI6IDI4LFxuICAgICAgICBhY3Rpb246IFwiaWdub3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRlcm1pbmFsIHdpbmRvdyBzaXplIGNoYW5nZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHSU9cIixcbiAgICAgICAgbnVtYmVyOiAyOSxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJL08gaXMgYXZhaWxhYmxlXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcIm90aGVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHUE9MTFwiLFxuICAgICAgICBudW1iZXI6IDI5LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIldhdGNoZWQgZXZlbnRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdJTkZPXCIsXG4gICAgICAgIG51bWJlcjogMjksXG4gICAgICAgIGFjdGlvbjogXCJpZ25vcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVxdWVzdCBmb3IgcHJvY2VzcyBpbmZvcm1hdGlvblwiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1BXUlwiLFxuICAgICAgICBudW1iZXI6IDMwLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkRldmljZSBydW5uaW5nIG91dCBvZiBwb3dlclwiLFxuICAgICAgICBzdGFuZGFyZDogXCJzeXN0ZW12XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHU1lTXCIsXG4gICAgICAgIG51bWJlcjogMzEsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkludmFsaWQgc3lzdGVtIGNhbGxcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdVTlVTRURcIixcbiAgICAgICAgbnVtYmVyOiAzMSxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnZhbGlkIHN5c3RlbSBjYWxsXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcIm90aGVyXCJcbiAgICAgIH1cbiAgICBdO1xuICAgIGV4cG9ydHMuU0lHTkFMUyA9IFNJR05BTFM7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvcmVhbHRpbWUuanNcbnZhciByZXF1aXJlX3JlYWx0aW1lID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h1bWFuLXNpZ25hbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2h1bWFuLXNpZ25hbHMvYnVpbGQvc3JjL3JlYWx0aW1lLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLlNJR1JUTUFYID0gZXhwb3J0cy5nZXRSZWFsdGltZVNpZ25hbHMgPSB2b2lkIDA7XG4gICAgdmFyIGdldFJlYWx0aW1lU2lnbmFscyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBTSUdSVE1BWCAtIFNJR1JUTUlOICsgMTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIGdldFJlYWx0aW1lU2lnbmFsKTtcbiAgICB9LCBcImdldFJlYWx0aW1lU2lnbmFsc1wiKTtcbiAgICBleHBvcnRzLmdldFJlYWx0aW1lU2lnbmFscyA9IGdldFJlYWx0aW1lU2lnbmFscztcbiAgICB2YXIgZ2V0UmVhbHRpbWVTaWduYWwgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYFNJR1JUJHtpbmRleCArIDF9YCxcbiAgICAgICAgbnVtYmVyOiBTSUdSVE1JTiArIGluZGV4LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFwcGxpY2F0aW9uLXNwZWNpZmljIHNpZ25hbCAocmVhbHRpbWUpXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH07XG4gICAgfSwgXCJnZXRSZWFsdGltZVNpZ25hbFwiKTtcbiAgICB2YXIgU0lHUlRNSU4gPSAzNDtcbiAgICB2YXIgU0lHUlRNQVggPSA2NDtcbiAgICBleHBvcnRzLlNJR1JUTUFYID0gU0lHUlRNQVg7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvc2lnbmFscy5qc1xudmFyIHJlcXVpcmVfc2lnbmFscyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9zaWduYWxzLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmdldFNpZ25hbHMgPSB2b2lkIDA7XG4gICAgdmFyIF9vcyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICB2YXIgX2NvcmUgPSByZXF1aXJlX2NvcmUoKTtcbiAgICB2YXIgX3JlYWx0aW1lID0gcmVxdWlyZV9yZWFsdGltZSgpO1xuICAgIHZhciBnZXRTaWduYWxzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHJlYWx0aW1lU2lnbmFscyA9ICgwLCBfcmVhbHRpbWUuZ2V0UmVhbHRpbWVTaWduYWxzKSgpO1xuICAgICAgY29uc3Qgc2lnbmFscyA9IFsuLi5fY29yZS5TSUdOQUxTLCAuLi5yZWFsdGltZVNpZ25hbHNdLm1hcChub3JtYWxpemVTaWduYWwpO1xuICAgICAgcmV0dXJuIHNpZ25hbHM7XG4gICAgfSwgXCJnZXRTaWduYWxzXCIpO1xuICAgIGV4cG9ydHMuZ2V0U2lnbmFscyA9IGdldFNpZ25hbHM7XG4gICAgdmFyIG5vcm1hbGl6ZVNpZ25hbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oe1xuICAgICAgbmFtZSxcbiAgICAgIG51bWJlcjogZGVmYXVsdE51bWJlcixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgYWN0aW9uLFxuICAgICAgZm9yY2VkID0gZmFsc2UsXG4gICAgICBzdGFuZGFyZFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmFsczogeyBbbmFtZV06IGNvbnN0YW50U2lnbmFsIH1cbiAgICAgIH0gPSBfb3MuY29uc3RhbnRzO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkID0gY29uc3RhbnRTaWduYWwgIT09IHZvaWQgMDtcbiAgICAgIGNvbnN0IG51bWJlciA9IHN1cHBvcnRlZCA/IGNvbnN0YW50U2lnbmFsIDogZGVmYXVsdE51bWJlcjtcbiAgICAgIHJldHVybiB7IG5hbWUsIG51bWJlciwgZGVzY3JpcHRpb24sIHN1cHBvcnRlZCwgYWN0aW9uLCBmb3JjZWQsIHN0YW5kYXJkIH07XG4gICAgfSwgXCJub3JtYWxpemVTaWduYWxcIik7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvbWFpbi5qc1xudmFyIHJlcXVpcmVfbWFpbiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9tYWluLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLnNpZ25hbHNCeU51bWJlciA9IGV4cG9ydHMuc2lnbmFsc0J5TmFtZSA9IHZvaWQgMDtcbiAgICB2YXIgX29zID0gcmVxdWlyZShcIm9zXCIpO1xuICAgIHZhciBfc2lnbmFscyA9IHJlcXVpcmVfc2lnbmFscygpO1xuICAgIHZhciBfcmVhbHRpbWUgPSByZXF1aXJlX3JlYWx0aW1lKCk7XG4gICAgdmFyIGdldFNpZ25hbHNCeU5hbWUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc2lnbmFscyA9ICgwLCBfc2lnbmFscy5nZXRTaWduYWxzKSgpO1xuICAgICAgcmV0dXJuIHNpZ25hbHMucmVkdWNlKGdldFNpZ25hbEJ5TmFtZSwge30pO1xuICAgIH0sIFwiZ2V0U2lnbmFsc0J5TmFtZVwiKTtcbiAgICB2YXIgZ2V0U2lnbmFsQnlOYW1lID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzaWduYWxCeU5hbWVNZW1vLCB7IG5hbWUsIG51bWJlciwgZGVzY3JpcHRpb24sIHN1cHBvcnRlZCwgYWN0aW9uLCBmb3JjZWQsIHN0YW5kYXJkIH0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNpZ25hbEJ5TmFtZU1lbW8sXG4gICAgICAgIFtuYW1lXTogeyBuYW1lLCBudW1iZXIsIGRlc2NyaXB0aW9uLCBzdXBwb3J0ZWQsIGFjdGlvbiwgZm9yY2VkLCBzdGFuZGFyZCB9XG4gICAgICB9O1xuICAgIH0sIFwiZ2V0U2lnbmFsQnlOYW1lXCIpO1xuICAgIHZhciBzaWduYWxzQnlOYW1lID0gZ2V0U2lnbmFsc0J5TmFtZSgpO1xuICAgIGV4cG9ydHMuc2lnbmFsc0J5TmFtZSA9IHNpZ25hbHNCeU5hbWU7XG4gICAgdmFyIGdldFNpZ25hbHNCeU51bWJlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBzaWduYWxzID0gKDAsIF9zaWduYWxzLmdldFNpZ25hbHMpKCk7XG4gICAgICBjb25zdCBsZW5ndGggPSBfcmVhbHRpbWUuU0lHUlRNQVggKyAxO1xuICAgICAgY29uc3Qgc2lnbmFsc0EgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICh2YWx1ZSwgbnVtYmVyKSA9PiBnZXRTaWduYWxCeU51bWJlcihudW1iZXIsIHNpZ25hbHMpKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5zaWduYWxzQSk7XG4gICAgfSwgXCJnZXRTaWduYWxzQnlOdW1iZXJcIik7XG4gICAgdmFyIGdldFNpZ25hbEJ5TnVtYmVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihudW1iZXIsIHNpZ25hbHMpIHtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGZpbmRTaWduYWxCeU51bWJlcihudW1iZXIsIHNpZ25hbHMpO1xuICAgICAgaWYgKHNpZ25hbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHN1cHBvcnRlZCwgYWN0aW9uLCBmb3JjZWQsIHN0YW5kYXJkIH0gPSBzaWduYWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbnVtYmVyXToge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbnVtYmVyLFxuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIHN1cHBvcnRlZCxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgZm9yY2VkLFxuICAgICAgICAgIHN0YW5kYXJkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgXCJnZXRTaWduYWxCeU51bWJlclwiKTtcbiAgICB2YXIgZmluZFNpZ25hbEJ5TnVtYmVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihudW1iZXIsIHNpZ25hbHMpIHtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHNpZ25hbHMuZmluZCgoeyBuYW1lIH0pID0+IF9vcy5jb25zdGFudHMuc2lnbmFsc1tuYW1lXSA9PT0gbnVtYmVyKTtcbiAgICAgIGlmIChzaWduYWwgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2lnbmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpZ25hbHMuZmluZCgoc2lnbmFsQSkgPT4gc2lnbmFsQS5udW1iZXIgPT09IG51bWJlcik7XG4gICAgfSwgXCJmaW5kU2lnbmFsQnlOdW1iZXJcIik7XG4gICAgdmFyIHNpZ25hbHNCeU51bWJlciA9IGdldFNpZ25hbHNCeU51bWJlcigpO1xuICAgIGV4cG9ydHMuc2lnbmFsc0J5TnVtYmVyID0gc2lnbmFsc0J5TnVtYmVyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvZXJyb3IuanNcbnZhciByZXF1aXJlX2Vycm9yID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvZXJyb3IuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgc2lnbmFsc0J5TmFtZSB9ID0gcmVxdWlyZV9tYWluKCk7XG4gICAgdmFyIGdldEVycm9yUHJlZml4ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoeyB0aW1lZE91dCwgdGltZW91dCwgZXJyb3JDb2RlLCBzaWduYWwsIHNpZ25hbERlc2NyaXB0aW9uLCBleGl0Q29kZSwgaXNDYW5jZWxlZCB9KSA9PiB7XG4gICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgcmV0dXJuIGB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fSBtaWxsaXNlY29uZHNgO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2FuY2VsZWQpIHtcbiAgICAgICAgcmV0dXJuIFwid2FzIGNhbmNlbGVkXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JDb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGBmYWlsZWQgd2l0aCAke2Vycm9yQ29kZX1gO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBgd2FzIGtpbGxlZCB3aXRoICR7c2lnbmFsfSAoJHtzaWduYWxEZXNjcmlwdGlvbn0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChleGl0Q29kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBgZmFpbGVkIHdpdGggZXhpdCBjb2RlICR7ZXhpdENvZGV9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuICAgIH0sIFwiZ2V0RXJyb3JQcmVmaXhcIik7XG4gICAgdmFyIG1ha2VFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHtcbiAgICAgIHN0ZG91dCxcbiAgICAgIHN0ZGVycixcbiAgICAgIGFsbCxcbiAgICAgIGVycm9yOiBlcnJvcjIsXG4gICAgICBzaWduYWwsXG4gICAgICBleGl0Q29kZSxcbiAgICAgIGNvbW1hbmQsXG4gICAgICBlc2NhcGVkQ29tbWFuZCxcbiAgICAgIHRpbWVkT3V0LFxuICAgICAgaXNDYW5jZWxlZCxcbiAgICAgIGtpbGxlZCxcbiAgICAgIHBhcnNlZDogeyBvcHRpb25zOiB7IHRpbWVvdXQgfSB9XG4gICAgfSkgPT4ge1xuICAgICAgZXhpdENvZGUgPSBleGl0Q29kZSA9PT0gbnVsbCA/IHZvaWQgMCA6IGV4aXRDb2RlO1xuICAgICAgc2lnbmFsID0gc2lnbmFsID09PSBudWxsID8gdm9pZCAwIDogc2lnbmFsO1xuICAgICAgY29uc3Qgc2lnbmFsRGVzY3JpcHRpb24gPSBzaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25hbHNCeU5hbWVbc2lnbmFsXS5kZXNjcmlwdGlvbjtcbiAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yMiAmJiBlcnJvcjIuY29kZTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldEVycm9yUHJlZml4KHsgdGltZWRPdXQsIHRpbWVvdXQsIGVycm9yQ29kZSwgc2lnbmFsLCBzaWduYWxEZXNjcmlwdGlvbiwgZXhpdENvZGUsIGlzQ2FuY2VsZWQgfSk7XG4gICAgICBjb25zdCBleGVjYU1lc3NhZ2UgPSBgQ29tbWFuZCAke3ByZWZpeH06ICR7Y29tbWFuZH1gO1xuICAgICAgY29uc3QgaXNFcnJvcjIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyb3IyKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xuICAgICAgY29uc3Qgc2hvcnRNZXNzYWdlID0gaXNFcnJvcjIgPyBgJHtleGVjYU1lc3NhZ2V9XG4ke2Vycm9yMi5tZXNzYWdlfWAgOiBleGVjYU1lc3NhZ2U7XG4gICAgICBjb25zdCBtZXNzYWdlID0gW3Nob3J0TWVzc2FnZSwgc3RkZXJyLCBzdGRvdXRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgICAgaWYgKGlzRXJyb3IyKSB7XG4gICAgICAgIGVycm9yMi5vcmlnaW5hbE1lc3NhZ2UgPSBlcnJvcjIubWVzc2FnZTtcbiAgICAgICAgZXJyb3IyLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgZXJyb3IyLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgICAgIGVycm9yMi5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgIGVycm9yMi5lc2NhcGVkQ29tbWFuZCA9IGVzY2FwZWRDb21tYW5kO1xuICAgICAgZXJyb3IyLmV4aXRDb2RlID0gZXhpdENvZGU7XG4gICAgICBlcnJvcjIuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgZXJyb3IyLnNpZ25hbERlc2NyaXB0aW9uID0gc2lnbmFsRGVzY3JpcHRpb247XG4gICAgICBlcnJvcjIuc3Rkb3V0ID0gc3Rkb3V0O1xuICAgICAgZXJyb3IyLnN0ZGVyciA9IHN0ZGVycjtcbiAgICAgIGlmIChhbGwgIT09IHZvaWQgMCkge1xuICAgICAgICBlcnJvcjIuYWxsID0gYWxsO1xuICAgICAgfVxuICAgICAgaWYgKFwiYnVmZmVyZWREYXRhXCIgaW4gZXJyb3IyKSB7XG4gICAgICAgIGRlbGV0ZSBlcnJvcjIuYnVmZmVyZWREYXRhO1xuICAgICAgfVxuICAgICAgZXJyb3IyLmZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvcjIudGltZWRPdXQgPSBCb29sZWFuKHRpbWVkT3V0KTtcbiAgICAgIGVycm9yMi5pc0NhbmNlbGVkID0gaXNDYW5jZWxlZDtcbiAgICAgIGVycm9yMi5raWxsZWQgPSBraWxsZWQgJiYgIXRpbWVkT3V0O1xuICAgICAgcmV0dXJuIGVycm9yMjtcbiAgICB9LCBcIm1ha2VFcnJvclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBtYWtlRXJyb3I7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdGRpby5qc1xudmFyIHJlcXVpcmVfc3RkaW8gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdGRpby5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYWxpYXNlcyA9IFtcInN0ZGluXCIsIFwic3Rkb3V0XCIsIFwic3RkZXJyXCJdO1xuICAgIHZhciBoYXNBbGlhcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdGlvbnMpID0+IGFsaWFzZXMuc29tZSgoYWxpYXMpID0+IG9wdGlvbnNbYWxpYXNdICE9PSB2b2lkIDApLCBcImhhc0FsaWFzXCIpO1xuICAgIHZhciBub3JtYWxpemVTdGRpbyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHN0ZGlvIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHN0ZGlvID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGFsaWFzZXMubWFwKChhbGlhcykgPT4gb3B0aW9uc1thbGlhc10pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0FsaWFzKG9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSXQncyBub3QgcG9zc2libGUgdG8gcHJvdmlkZSBcXGBzdGRpb1xcYCBpbiBjb21iaW5hdGlvbiB3aXRoIG9uZSBvZiAke2FsaWFzZXMubWFwKChhbGlhcykgPT4gYFxcYCR7YWxpYXN9XFxgYCkuam9pbihcIiwgXCIpfWApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzdGRpbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc3RkaW87XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RkaW8pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYHN0ZGlvXFxgIHRvIGJlIG9mIHR5cGUgXFxgc3RyaW5nXFxgIG9yIFxcYEFycmF5XFxgLCBnb3QgXFxgJHt0eXBlb2Ygc3RkaW99XFxgYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChzdGRpby5sZW5ndGgsIGFsaWFzZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICh2YWx1ZSwgaW5kZXgpID0+IHN0ZGlvW2luZGV4XSk7XG4gICAgfSwgXCJub3JtYWxpemVTdGRpb1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBub3JtYWxpemVTdGRpbztcbiAgICBtb2R1bGUyLmV4cG9ydHMubm9kZSA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzdGRpbyA9IG5vcm1hbGl6ZVN0ZGlvKG9wdGlvbnMpO1xuICAgICAgaWYgKHN0ZGlvID09PSBcImlwY1wiKSB7XG4gICAgICAgIHJldHVybiBcImlwY1wiO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZGlvID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0ZGlvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbc3RkaW8sIHN0ZGlvLCBzdGRpbywgXCJpcGNcIl07XG4gICAgICB9XG4gICAgICBpZiAoc3RkaW8uaW5jbHVkZXMoXCJpcGNcIikpIHtcbiAgICAgICAgcmV0dXJuIHN0ZGlvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsuLi5zdGRpbywgXCJpcGNcIl07XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaWduYWwtZXhpdEAzLjAuNy9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvc2lnbmFscy5qc1xudmFyIHJlcXVpcmVfc2lnbmFsczIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2lnbmFsLWV4aXRAMy4wLjcvbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L3NpZ25hbHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gW1xuICAgICAgXCJTSUdBQlJUXCIsXG4gICAgICBcIlNJR0FMUk1cIixcbiAgICAgIFwiU0lHSFVQXCIsXG4gICAgICBcIlNJR0lOVFwiLFxuICAgICAgXCJTSUdURVJNXCJcbiAgICBdO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSBcIndpbjMyXCIpIHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5wdXNoKFxuICAgICAgICBcIlNJR1ZUQUxSTVwiLFxuICAgICAgICBcIlNJR1hDUFVcIixcbiAgICAgICAgXCJTSUdYRlNaXCIsXG4gICAgICAgIFwiU0lHVVNSMlwiLFxuICAgICAgICBcIlNJR1RSQVBcIixcbiAgICAgICAgXCJTSUdTWVNcIixcbiAgICAgICAgXCJTSUdRVUlUXCIsXG4gICAgICAgIFwiU0lHSU9UXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5wdXNoKFxuICAgICAgICBcIlNJR0lPXCIsXG4gICAgICAgIFwiU0lHUE9MTFwiLFxuICAgICAgICBcIlNJR1BXUlwiLFxuICAgICAgICBcIlNJR1NUS0ZMVFwiLFxuICAgICAgICBcIlNJR1VOVVNFRFwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaWduYWwtZXhpdEAzLjAuNy9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvaW5kZXguanNcbnZhciByZXF1aXJlX3NpZ25hbF9leGl0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NpZ25hbC1leGl0QDMuMC43L25vZGVfbW9kdWxlcy9zaWduYWwtZXhpdC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgcHJvY2VzczIgPSBnbG9iYWwucHJvY2VzcztcbiAgICB2YXIgcHJvY2Vzc09rID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihwcm9jZXNzMykge1xuICAgICAgcmV0dXJuIHByb2Nlc3MzICYmIHR5cGVvZiBwcm9jZXNzMyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2VzczMucmVtb3ZlTGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvY2VzczMuZW1pdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9jZXNzMy5yZWFsbHlFeGl0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb2Nlc3MzLmxpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9jZXNzMy5raWxsID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb2Nlc3MzLnBpZCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvY2VzczMub24gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9LCBcInByb2Nlc3NPa1wiKTtcbiAgICBpZiAoIXByb2Nlc3NPayhwcm9jZXNzMikpIHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgICAgc2lnbmFscyA9IHJlcXVpcmVfc2lnbmFsczIoKTtcbiAgICAgIGlzV2luID0gL153aW4vaS50ZXN0KHByb2Nlc3MyLnBsYXRmb3JtKTtcbiAgICAgIEVFID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbiAgICAgIGlmICh0eXBlb2YgRUUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBFRSA9IEVFLkV2ZW50RW1pdHRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzMi5fX3NpZ25hbF9leGl0X2VtaXR0ZXJfXykge1xuICAgICAgICBlbWl0dGVyID0gcHJvY2VzczIuX19zaWduYWxfZXhpdF9lbWl0dGVyX187XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyID0gcHJvY2VzczIuX19zaWduYWxfZXhpdF9lbWl0dGVyX18gPSBuZXcgRUUoKTtcbiAgICAgICAgZW1pdHRlci5jb3VudCA9IDA7XG4gICAgICAgIGVtaXR0ZXIuZW1pdHRlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFlbWl0dGVyLmluZmluaXRlKSB7XG4gICAgICAgIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgICAgICAgZW1pdHRlci5pbmZpbml0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihjYiwgb3B0cykge1xuICAgICAgICBpZiAoIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCBcImZ1bmN0aW9uXCIsIFwiYSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIGZvciBleGl0IGhhbmRsZXJcIik7XG4gICAgICAgIGlmIChsb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldiA9IFwiZXhpdFwiO1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmFsd2F5c0xhc3QpIHtcbiAgICAgICAgICBldiA9IFwiYWZ0ZXJleGl0XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW92ZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldiwgY2IpO1xuICAgICAgICAgIGlmIChlbWl0dGVyLmxpc3RlbmVycyhcImV4aXRcIikubGVuZ3RoID09PSAwICYmIGVtaXR0ZXIubGlzdGVuZXJzKFwiYWZ0ZXJleGl0XCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdW5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcInJlbW92ZVwiKTtcbiAgICAgICAgZW1pdHRlci5vbihldiwgY2IpO1xuICAgICAgICByZXR1cm4gcmVtb3ZlO1xuICAgICAgfTtcbiAgICAgIHVubG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gdW5sb2FkMigpIHtcbiAgICAgICAgaWYgKCFsb2FkZWQgfHwgIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvY2VzczIucmVtb3ZlTGlzdGVuZXIoc2lnLCBzaWdMaXN0ZW5lcnNbc2lnXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzMi5lbWl0ID0gb3JpZ2luYWxQcm9jZXNzRW1pdDtcbiAgICAgICAgcHJvY2VzczIucmVhbGx5RXhpdCA9IG9yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQ7XG4gICAgICAgIGVtaXR0ZXIuY291bnQgLT0gMTtcbiAgICAgIH0sIFwidW5sb2FkXCIpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLnVubG9hZCA9IHVubG9hZDtcbiAgICAgIGVtaXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGVtaXQyKGV2ZW50LCBjb2RlLCBzaWduYWwpIHtcbiAgICAgICAgaWYgKGVtaXR0ZXIuZW1pdHRlZFtldmVudF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5lbWl0dGVkW2V2ZW50XSA9IHRydWU7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChldmVudCwgY29kZSwgc2lnbmFsKTtcbiAgICAgIH0sIFwiZW1pdFwiKTtcbiAgICAgIHNpZ0xpc3RlbmVycyA9IHt9O1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICBzaWdMaXN0ZW5lcnNbc2lnXSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgICAgaWYgKCFwcm9jZXNzT2soZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9jZXNzMi5saXN0ZW5lcnMoc2lnKTtcbiAgICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gZW1pdHRlci5jb3VudCkge1xuICAgICAgICAgICAgdW5sb2FkKCk7XG4gICAgICAgICAgICBlbWl0KFwiZXhpdFwiLCBudWxsLCBzaWcpO1xuICAgICAgICAgICAgZW1pdChcImFmdGVyZXhpdFwiLCBudWxsLCBzaWcpO1xuICAgICAgICAgICAgaWYgKGlzV2luICYmIHNpZyA9PT0gXCJTSUdIVVBcIikge1xuICAgICAgICAgICAgICBzaWcgPSBcIlNJR0lOVFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2VzczIua2lsbChwcm9jZXNzMi5waWQsIHNpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcImxpc3RlbmVyXCIpO1xuICAgICAgfSk7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMuc2lnbmFscyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICAgIH07XG4gICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgIGxvYWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGxvYWQyKCkge1xuICAgICAgICBpZiAobG9hZGVkIHx8ICFwcm9jZXNzT2soZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgIGVtaXR0ZXIuY291bnQgKz0gMTtcbiAgICAgICAgc2lnbmFscyA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzMi5vbihzaWcsIHNpZ0xpc3RlbmVyc1tzaWddKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2VzczIuZW1pdCA9IHByb2Nlc3NFbWl0O1xuICAgICAgICBwcm9jZXNzMi5yZWFsbHlFeGl0ID0gcHJvY2Vzc1JlYWxseUV4aXQ7XG4gICAgICB9LCBcImxvYWRcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgICBvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0ID0gcHJvY2VzczIucmVhbGx5RXhpdDtcbiAgICAgIHByb2Nlc3NSZWFsbHlFeGl0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBwcm9jZXNzUmVhbGx5RXhpdDIoY29kZSkge1xuICAgICAgICBpZiAoIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzczIuZXhpdENvZGUgPSBjb2RlIHx8IDA7XG4gICAgICAgIGVtaXQoXCJleGl0XCIsIHByb2Nlc3MyLmV4aXRDb2RlLCBudWxsKTtcbiAgICAgICAgZW1pdChcImFmdGVyZXhpdFwiLCBwcm9jZXNzMi5leGl0Q29kZSwgbnVsbCk7XG4gICAgICAgIG9yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQuY2FsbChwcm9jZXNzMiwgcHJvY2VzczIuZXhpdENvZGUpO1xuICAgICAgfSwgXCJwcm9jZXNzUmVhbGx5RXhpdFwiKTtcbiAgICAgIG9yaWdpbmFsUHJvY2Vzc0VtaXQgPSBwcm9jZXNzMi5lbWl0O1xuICAgICAgcHJvY2Vzc0VtaXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHByb2Nlc3NFbWl0MihldiwgYXJnMikge1xuICAgICAgICBpZiAoZXYgPT09IFwiZXhpdFwiICYmIHByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICBpZiAoYXJnMiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwcm9jZXNzMi5leGl0Q29kZSA9IGFyZzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXQgPSBvcmlnaW5hbFByb2Nlc3NFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZW1pdChcImV4aXRcIiwgcHJvY2VzczIuZXhpdENvZGUsIG51bGwpO1xuICAgICAgICAgIGVtaXQoXCJhZnRlcmV4aXRcIiwgcHJvY2VzczIuZXhpdENvZGUsIG51bGwpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvY2Vzc0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSwgXCJwcm9jZXNzRW1pdFwiKTtcbiAgICB9XG4gICAgdmFyIGFzc2VydDtcbiAgICB2YXIgc2lnbmFscztcbiAgICB2YXIgaXNXaW47XG4gICAgdmFyIEVFO1xuICAgIHZhciBlbWl0dGVyO1xuICAgIHZhciB1bmxvYWQ7XG4gICAgdmFyIGVtaXQ7XG4gICAgdmFyIHNpZ0xpc3RlbmVycztcbiAgICB2YXIgbG9hZGVkO1xuICAgIHZhciBsb2FkO1xuICAgIHZhciBvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0O1xuICAgIHZhciBwcm9jZXNzUmVhbGx5RXhpdDtcbiAgICB2YXIgb3JpZ2luYWxQcm9jZXNzRW1pdDtcbiAgICB2YXIgcHJvY2Vzc0VtaXQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9raWxsLmpzXG52YXIgcmVxdWlyZV9raWxsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIva2lsbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgb3MzID0gcmVxdWlyZShcIm9zXCIpO1xuICAgIHZhciBvbkV4aXQgPSByZXF1aXJlX3NpZ25hbF9leGl0KCk7XG4gICAgdmFyIERFRkFVTFRfRk9SQ0VfS0lMTF9USU1FT1VUID0gMWUzICogNTtcbiAgICB2YXIgc3Bhd25lZEtpbGwgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChraWxsLCBzaWduYWwgPSBcIlNJR1RFUk1cIiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBraWxsUmVzdWx0ID0ga2lsbChzaWduYWwpO1xuICAgICAgc2V0S2lsbFRpbWVvdXQoa2lsbCwgc2lnbmFsLCBvcHRpb25zLCBraWxsUmVzdWx0KTtcbiAgICAgIHJldHVybiBraWxsUmVzdWx0O1xuICAgIH0sIFwic3Bhd25lZEtpbGxcIik7XG4gICAgdmFyIHNldEtpbGxUaW1lb3V0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoa2lsbCwgc2lnbmFsLCBvcHRpb25zLCBraWxsUmVzdWx0KSA9PiB7XG4gICAgICBpZiAoIXNob3VsZEZvcmNlS2lsbChzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRGb3JjZUtpbGxBZnRlclRpbWVvdXQob3B0aW9ucyk7XG4gICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGtpbGwoXCJTSUdLSUxMXCIpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodC51bnJlZikge1xuICAgICAgICB0LnVucmVmKCk7XG4gICAgICB9XG4gICAgfSwgXCJzZXRLaWxsVGltZW91dFwiKTtcbiAgICB2YXIgc2hvdWxkRm9yY2VLaWxsID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2lnbmFsLCB7IGZvcmNlS2lsbEFmdGVyVGltZW91dCB9LCBraWxsUmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gaXNTaWd0ZXJtKHNpZ25hbCkgJiYgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0ICE9PSBmYWxzZSAmJiBraWxsUmVzdWx0O1xuICAgIH0sIFwic2hvdWxkRm9yY2VLaWxsXCIpO1xuICAgIHZhciBpc1NpZ3Rlcm0gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzaWduYWwpID0+IHtcbiAgICAgIHJldHVybiBzaWduYWwgPT09IG9zMy5jb25zdGFudHMuc2lnbmFscy5TSUdURVJNIHx8IHR5cGVvZiBzaWduYWwgPT09IFwic3RyaW5nXCIgJiYgc2lnbmFsLnRvVXBwZXJDYXNlKCkgPT09IFwiU0lHVEVSTVwiO1xuICAgIH0sIFwiaXNTaWd0ZXJtXCIpO1xuICAgIHZhciBnZXRGb3JjZUtpbGxBZnRlclRpbWVvdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IGZvcmNlS2lsbEFmdGVyVGltZW91dCA9IHRydWUgfSkgPT4ge1xuICAgICAgaWYgKGZvcmNlS2lsbEFmdGVyVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9GT1JDRV9LSUxMX1RJTUVPVVQ7XG4gICAgICB9XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmb3JjZUtpbGxBZnRlclRpbWVvdXQpIHx8IGZvcmNlS2lsbEFmdGVyVGltZW91dCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIFxcYGZvcmNlS2lsbEFmdGVyVGltZW91dFxcYCBvcHRpb24gdG8gYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290IFxcYCR7Zm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fVxcYCAoJHt0eXBlb2YgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0fSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JjZUtpbGxBZnRlclRpbWVvdXQ7XG4gICAgfSwgXCJnZXRGb3JjZUtpbGxBZnRlclRpbWVvdXRcIik7XG4gICAgdmFyIHNwYXduZWRDYW5jZWwgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzcGF3bmVkLCBjb250ZXh0MykgPT4ge1xuICAgICAgY29uc3Qga2lsbFJlc3VsdCA9IHNwYXduZWQua2lsbCgpO1xuICAgICAgaWYgKGtpbGxSZXN1bHQpIHtcbiAgICAgICAgY29udGV4dDMuaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgXCJzcGF3bmVkQ2FuY2VsXCIpO1xuICAgIHZhciB0aW1lb3V0S2lsbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNwYXduZWQsIHNpZ25hbCwgcmVqZWN0KSA9PiB7XG4gICAgICBzcGF3bmVkLmtpbGwoc2lnbmFsKTtcbiAgICAgIHJlamVjdChPYmplY3QuYXNzaWduKG5ldyBFcnJvcihcIlRpbWVkIG91dFwiKSwgeyB0aW1lZE91dDogdHJ1ZSwgc2lnbmFsIH0pKTtcbiAgICB9LCBcInRpbWVvdXRLaWxsXCIpO1xuICAgIHZhciBzZXR1cFRpbWVvdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzcGF3bmVkLCB7IHRpbWVvdXQsIGtpbGxTaWduYWwgPSBcIlNJR1RFUk1cIiB9LCBzcGF3bmVkUHJvbWlzZSkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQgPT09IDAgfHwgdGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzcGF3bmVkUHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dEtpbGwoc3Bhd25lZCwga2lsbFNpZ25hbCwgcmVqZWN0KTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNhZmVTcGF3bmVkUHJvbWlzZSA9IHNwYXduZWRQcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbdGltZW91dFByb21pc2UsIHNhZmVTcGF3bmVkUHJvbWlzZV0pO1xuICAgIH0sIFwic2V0dXBUaW1lb3V0XCIpO1xuICAgIHZhciB2YWxpZGF0ZVRpbWVvdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IHRpbWVvdXQgfSkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQgIT09IHZvaWQgMCAmJiAoIU51bWJlci5pc0Zpbml0ZSh0aW1lb3V0KSB8fCB0aW1lb3V0IDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIFxcYHRpbWVvdXRcXGAgb3B0aW9uIHRvIGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdCBcXGAke3RpbWVvdXR9XFxgICgke3R5cGVvZiB0aW1lb3V0fSlgKTtcbiAgICAgIH1cbiAgICB9LCBcInZhbGlkYXRlVGltZW91dFwiKTtcbiAgICB2YXIgc2V0RXhpdEhhbmRsZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jIChzcGF3bmVkLCB7IGNsZWFudXAsIGRldGFjaGVkIH0sIHRpbWVkUHJvbWlzZSkgPT4ge1xuICAgICAgaWYgKCFjbGVhbnVwIHx8IGRldGFjaGVkKSB7XG4gICAgICAgIHJldHVybiB0aW1lZFByb21pc2U7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1vdmVFeGl0SGFuZGxlciA9IG9uRXhpdCgoKSA9PiB7XG4gICAgICAgIHNwYXduZWQua2lsbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGltZWRQcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICByZW1vdmVFeGl0SGFuZGxlcigpO1xuICAgICAgfSk7XG4gICAgfSwgXCJzZXRFeGl0SGFuZGxlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBzcGF3bmVkS2lsbCxcbiAgICAgIHNwYXduZWRDYW5jZWwsXG4gICAgICBzZXR1cFRpbWVvdXQsXG4gICAgICB2YWxpZGF0ZVRpbWVvdXQsXG4gICAgICBzZXRFeGl0SGFuZGxlclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtc3RyZWFtQDIuMC4xL25vZGVfbW9kdWxlcy9pcy1zdHJlYW0vaW5kZXguanNcbnZhciByZXF1aXJlX2lzX3N0cmVhbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1zdHJlYW1AMi4wLjEvbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTdHJlYW0gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdHJlYW0yKSA9PiBzdHJlYW0yICE9PSBudWxsICYmIHR5cGVvZiBzdHJlYW0yID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0yLnBpcGUgPT09IFwiZnVuY3Rpb25cIiwgXCJpc1N0cmVhbVwiKTtcbiAgICBpc1N0cmVhbS53cml0YWJsZSA9IChzdHJlYW0yKSA9PiBpc1N0cmVhbShzdHJlYW0yKSAmJiBzdHJlYW0yLndyaXRhYmxlICE9PSBmYWxzZSAmJiB0eXBlb2Ygc3RyZWFtMi5fd3JpdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc3RyZWFtMi5fd3JpdGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbiAgICBpc1N0cmVhbS5yZWFkYWJsZSA9IChzdHJlYW0yKSA9PiBpc1N0cmVhbShzdHJlYW0yKSAmJiBzdHJlYW0yLnJlYWRhYmxlICE9PSBmYWxzZSAmJiB0eXBlb2Ygc3RyZWFtMi5fcmVhZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzdHJlYW0yLl9yZWFkYWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xuICAgIGlzU3RyZWFtLmR1cGxleCA9IChzdHJlYW0yKSA9PiBpc1N0cmVhbS53cml0YWJsZShzdHJlYW0yKSAmJiBpc1N0cmVhbS5yZWFkYWJsZShzdHJlYW0yKTtcbiAgICBpc1N0cmVhbS50cmFuc2Zvcm0gPSAoc3RyZWFtMikgPT4gaXNTdHJlYW0uZHVwbGV4KHN0cmVhbTIpICYmIHR5cGVvZiBzdHJlYW0yLl90cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBpc1N0cmVhbTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9nZXQtc3RyZWFtQDYuMC4xL25vZGVfbW9kdWxlcy9nZXQtc3RyZWFtL2J1ZmZlci1zdHJlYW0uanNcbnZhciByZXF1aXJlX2J1ZmZlcl9zdHJlYW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZ2V0LXN0cmVhbUA2LjAuMS9ub2RlX21vZHVsZXMvZ2V0LXN0cmVhbS9idWZmZXItc3RyZWFtLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IFBhc3NUaHJvdWdoOiBQYXNzVGhyb3VnaFN0cmVhbSB9ID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAob3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgY29uc3QgeyBhcnJheSB9ID0gb3B0aW9ucztcbiAgICAgIGxldCB7IGVuY29kaW5nIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgaXNCdWZmZXIgPSBlbmNvZGluZyA9PT0gXCJidWZmZXJcIjtcbiAgICAgIGxldCBvYmplY3RNb2RlID0gZmFsc2U7XG4gICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgb2JqZWN0TW9kZSA9ICEoZW5jb2RpbmcgfHwgaXNCdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcInV0ZjhcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0J1ZmZlcikge1xuICAgICAgICBlbmNvZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW0yID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKHsgb2JqZWN0TW9kZSB9KTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBzdHJlYW0yLnNldEVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBzdHJlYW0yLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICBpZiAob2JqZWN0TW9kZSkge1xuICAgICAgICAgIGxlbmd0aCA9IGNodW5rcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzdHJlYW0yLmdldEJ1ZmZlcmVkVmFsdWUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQnVmZmVyID8gQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkgOiBjaHVua3Muam9pbihcIlwiKTtcbiAgICAgIH07XG4gICAgICBzdHJlYW0yLmdldEJ1ZmZlcmVkTGVuZ3RoID0gKCkgPT4gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHN0cmVhbTI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9nZXQtc3RyZWFtQDYuMC4xL25vZGVfbW9kdWxlcy9nZXQtc3RyZWFtL2luZGV4LmpzXG52YXIgcmVxdWlyZV9nZXRfc3RyZWFtID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1zdHJlYW1ANi4wLjEvbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgY29uc3RhbnRzOiBCdWZmZXJDb25zdGFudHMgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgdmFyIHN0cmVhbTIgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7IHByb21pc2lmeTogcHJvbWlzaWZ5NCB9ID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgdmFyIGJ1ZmZlclN0cmVhbSA9IHJlcXVpcmVfYnVmZmVyX3N0cmVhbSgpO1xuICAgIHZhciBzdHJlYW1QaXBlbGluZVByb21pc2lmaWVkID0gcHJvbWlzaWZ5NChzdHJlYW0yLnBpcGVsaW5lKTtcbiAgICB2YXIgTWF4QnVmZmVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIm1heEJ1ZmZlciBleGNlZWRlZFwiKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJNYXhCdWZmZXJFcnJvclwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE1heEJ1ZmZlckVycm9yLCBcIk1heEJ1ZmZlckVycm9yXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFN0cmVhbTIoaW5wdXRTdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBzdHJlYW1cIik7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBtYXhCdWZmZXI6IEluZmluaXR5LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgeyBtYXhCdWZmZXIgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBzdHJlYW0zID0gYnVmZmVyU3RyZWFtKG9wdGlvbnMpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWplY3RQcm9taXNlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yMiAmJiBzdHJlYW0zLmdldEJ1ZmZlcmVkTGVuZ3RoKCkgPD0gQnVmZmVyQ29uc3RhbnRzLk1BWF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGVycm9yMi5idWZmZXJlZERhdGEgPSBzdHJlYW0zLmdldEJ1ZmZlcmVkVmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVqZWN0KGVycm9yMik7XG4gICAgICAgIH0sIFwicmVqZWN0UHJvbWlzZVwiKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgc3RyZWFtUGlwZWxpbmVQcm9taXNpZmllZChpbnB1dFN0cmVhbSwgc3RyZWFtMyk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICByZWplY3RQcm9taXNlKGVycm9yMik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICBzdHJlYW0zLm9uKFwiZGF0YVwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHN0cmVhbTMuZ2V0QnVmZmVyZWRMZW5ndGgoKSA+IG1heEJ1ZmZlcikge1xuICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShuZXcgTWF4QnVmZmVyRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cmVhbTMuZ2V0QnVmZmVyZWRWYWx1ZSgpO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0U3RyZWFtMiwgXCJnZXRTdHJlYW1cIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZ2V0U3RyZWFtMjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuYnVmZmVyID0gKHN0cmVhbTMsIG9wdGlvbnMpID0+IGdldFN0cmVhbTIoc3RyZWFtMywgeyAuLi5vcHRpb25zLCBlbmNvZGluZzogXCJidWZmZXJcIiB9KTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuYXJyYXkgPSAoc3RyZWFtMywgb3B0aW9ucykgPT4gZ2V0U3RyZWFtMihzdHJlYW0zLCB7IC4uLm9wdGlvbnMsIGFycmF5OiB0cnVlIH0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5NYXhCdWZmZXJFcnJvciA9IE1heEJ1ZmZlckVycm9yO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmdlLXN0cmVhbUAyLjAuMC9ub2RlX21vZHVsZXMvbWVyZ2Utc3RyZWFtL2luZGV4LmpzXG52YXIgcmVxdWlyZV9tZXJnZV9zdHJlYW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWVyZ2Utc3RyZWFtQDIuMC4wL25vZGVfbW9kdWxlcy9tZXJnZS1zdHJlYW0vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgUGFzc1Rocm91Z2ggfSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgdmFyIG91dHB1dCA9IG5ldyBQYXNzVGhyb3VnaCh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICBvdXRwdXQuc2V0TWF4TGlzdGVuZXJzKDApO1xuICAgICAgb3V0cHV0LmFkZCA9IGFkZDI7XG4gICAgICBvdXRwdXQuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgICBvdXRwdXQub24oXCJ1bnBpcGVcIiwgcmVtb3ZlKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChhZGQyKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICBmdW5jdGlvbiBhZGQyKHNvdXJjZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgc291cmNlLmZvckVhY2goYWRkMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZS5vbmNlKFwiZW5kXCIsIHJlbW92ZS5iaW5kKG51bGwsIHNvdXJjZSkpO1xuICAgICAgICBzb3VyY2Uub25jZShcImVycm9yXCIsIG91dHB1dC5lbWl0LmJpbmQob3V0cHV0LCBcImVycm9yXCIpKTtcbiAgICAgICAgc291cmNlLnBpcGUob3V0cHV0LCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgX19uYW1lKGFkZDIsIFwiYWRkXCIpO1xuICAgICAgZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZXMubGVuZ3RoID09IDA7XG4gICAgICB9XG4gICAgICBfX25hbWUoaXNFbXB0eSwgXCJpc0VtcHR5XCIpO1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlKHNvdXJjZSkge1xuICAgICAgICBzb3VyY2VzID0gc291cmNlcy5maWx0ZXIoZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICByZXR1cm4gaXQgIT09IHNvdXJjZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc291cmNlcy5sZW5ndGggJiYgb3V0cHV0LnJlYWRhYmxlKSB7XG4gICAgICAgICAgb3V0cHV0LmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocmVtb3ZlLCBcInJlbW92ZVwiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvc3RyZWFtLmpzXG52YXIgcmVxdWlyZV9zdHJlYW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdHJlYW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzU3RyZWFtID0gcmVxdWlyZV9pc19zdHJlYW0oKTtcbiAgICB2YXIgZ2V0U3RyZWFtMiA9IHJlcXVpcmVfZ2V0X3N0cmVhbSgpO1xuICAgIHZhciBtZXJnZVN0cmVhbSA9IHJlcXVpcmVfbWVyZ2Vfc3RyZWFtKCk7XG4gICAgdmFyIGhhbmRsZUlucHV0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3Bhd25lZCwgaW5wdXQpID0+IHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwIHx8IHNwYXduZWQuc3RkaW4gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJlYW0oaW5wdXQpKSB7XG4gICAgICAgIGlucHV0LnBpcGUoc3Bhd25lZC5zdGRpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGF3bmVkLnN0ZGluLmVuZChpbnB1dCk7XG4gICAgICB9XG4gICAgfSwgXCJoYW5kbGVJbnB1dFwiKTtcbiAgICB2YXIgbWFrZUFsbFN0cmVhbSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNwYXduZWQsIHsgYWxsIH0pID0+IHtcbiAgICAgIGlmICghYWxsIHx8ICFzcGF3bmVkLnN0ZG91dCAmJiAhc3Bhd25lZC5zdGRlcnIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWl4ZWQgPSBtZXJnZVN0cmVhbSgpO1xuICAgICAgaWYgKHNwYXduZWQuc3Rkb3V0KSB7XG4gICAgICAgIG1peGVkLmFkZChzcGF3bmVkLnN0ZG91dCk7XG4gICAgICB9XG4gICAgICBpZiAoc3Bhd25lZC5zdGRlcnIpIHtcbiAgICAgICAgbWl4ZWQuYWRkKHNwYXduZWQuc3RkZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaXhlZDtcbiAgICB9LCBcIm1ha2VBbGxTdHJlYW1cIik7XG4gICAgdmFyIGdldEJ1ZmZlcmVkRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKHN0cmVhbTIsIHN0cmVhbVByb21pc2UpID0+IHtcbiAgICAgIGlmICghc3RyZWFtMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdHJlYW0yLmRlc3Ryb3koKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdHJlYW1Qcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjIuYnVmZmVyZWREYXRhO1xuICAgICAgfVxuICAgIH0sIFwiZ2V0QnVmZmVyZWREYXRhXCIpO1xuICAgIHZhciBnZXRTdHJlYW1Qcm9taXNlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RyZWFtMiwgeyBlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXIgfSkgPT4ge1xuICAgICAgaWYgKCFzdHJlYW0yIHx8ICFidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBnZXRTdHJlYW0yKHN0cmVhbTIsIHsgZW5jb2RpbmcsIG1heEJ1ZmZlciB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTdHJlYW0yLmJ1ZmZlcihzdHJlYW0yLCB7IG1heEJ1ZmZlciB9KTtcbiAgICB9LCBcImdldFN0cmVhbVByb21pc2VcIik7XG4gICAgdmFyIGdldFNwYXduZWRSZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICh7IHN0ZG91dCwgc3RkZXJyLCBhbGwgfSwgeyBlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXIgfSwgcHJvY2Vzc0RvbmUpID0+IHtcbiAgICAgIGNvbnN0IHN0ZG91dFByb21pc2UgPSBnZXRTdHJlYW1Qcm9taXNlKHN0ZG91dCwgeyBlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXIgfSk7XG4gICAgICBjb25zdCBzdGRlcnJQcm9taXNlID0gZ2V0U3RyZWFtUHJvbWlzZShzdGRlcnIsIHsgZW5jb2RpbmcsIGJ1ZmZlciwgbWF4QnVmZmVyIH0pO1xuICAgICAgY29uc3QgYWxsUHJvbWlzZSA9IGdldFN0cmVhbVByb21pc2UoYWxsLCB7IGVuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlcjogbWF4QnVmZmVyICogMiB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChbcHJvY2Vzc0RvbmUsIHN0ZG91dFByb21pc2UsIHN0ZGVyclByb21pc2UsIGFsbFByb21pc2VdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHsgZXJyb3I6IGVycm9yMiwgc2lnbmFsOiBlcnJvcjIuc2lnbmFsLCB0aW1lZE91dDogZXJyb3IyLnRpbWVkT3V0IH0sXG4gICAgICAgICAgZ2V0QnVmZmVyZWREYXRhKHN0ZG91dCwgc3Rkb3V0UHJvbWlzZSksXG4gICAgICAgICAgZ2V0QnVmZmVyZWREYXRhKHN0ZGVyciwgc3RkZXJyUHJvbWlzZSksXG4gICAgICAgICAgZ2V0QnVmZmVyZWREYXRhKGFsbCwgYWxsUHJvbWlzZSlcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSwgXCJnZXRTcGF3bmVkUmVzdWx0XCIpO1xuICAgIHZhciB2YWxpZGF0ZUlucHV0U3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHsgaW5wdXQgfSkgPT4ge1xuICAgICAgaWYgKGlzU3RyZWFtKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGBpbnB1dGAgb3B0aW9uIGNhbm5vdCBiZSBhIHN0cmVhbSBpbiBzeW5jIG1vZGVcIik7XG4gICAgICB9XG4gICAgfSwgXCJ2YWxpZGF0ZUlucHV0U3luY1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBoYW5kbGVJbnB1dCxcbiAgICAgIG1ha2VBbGxTdHJlYW0sXG4gICAgICBnZXRTcGF3bmVkUmVzdWx0LFxuICAgICAgdmFsaWRhdGVJbnB1dFN5bmNcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvcHJvbWlzZS5qc1xudmFyIHJlcXVpcmVfcHJvbWlzZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3Byb21pc2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSAoYXN5bmMgKCkgPT4ge1xuICAgIH0pKCkuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IFtcInRoZW5cIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIl0ubWFwKChwcm9wZXJ0eSkgPT4gW1xuICAgICAgcHJvcGVydHksXG4gICAgICBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuYXRpdmVQcm9taXNlUHJvdG90eXBlLCBwcm9wZXJ0eSlcbiAgICBdKTtcbiAgICB2YXIgbWVyZ2VQcm9taXNlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3Bhd25lZCwgcHJvbWlzZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGRlc2NyaXB0b3JdIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHByb21pc2UgPT09IFwiZnVuY3Rpb25cIiA/ICguLi5hcmdzKSA9PiBSZWZsZWN0LmFwcGx5KGRlc2NyaXB0b3IudmFsdWUsIHByb21pc2UoKSwgYXJncykgOiBkZXNjcmlwdG9yLnZhbHVlLmJpbmQocHJvbWlzZSk7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoc3Bhd25lZCwgcHJvcGVydHksIHsgLi4uZGVzY3JpcHRvciwgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Bhd25lZDtcbiAgICB9LCBcIm1lcmdlUHJvbWlzZVwiKTtcbiAgICB2YXIgZ2V0U3Bhd25lZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzcGF3bmVkKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzcGF3bmVkLm9uKFwiZXhpdFwiLCAoZXhpdENvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoeyBleGl0Q29kZSwgc2lnbmFsIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Bhd25lZC5vbihcImVycm9yXCIsIChlcnJvcjIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzcGF3bmVkLnN0ZGluKSB7XG4gICAgICAgICAgc3Bhd25lZC5zdGRpbi5vbihcImVycm9yXCIsIChlcnJvcjIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBcImdldFNwYXduZWRQcm9taXNlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIG1lcmdlUHJvbWlzZSxcbiAgICAgIGdldFNwYXduZWRQcm9taXNlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL2NvbW1hbmQuanNcbnZhciByZXF1aXJlX2NvbW1hbmQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9jb21tYW5kLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub3JtYWxpemVBcmdzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmlsZSwgYXJncyA9IFtdKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgcmV0dXJuIFtmaWxlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZmlsZSwgLi4uYXJnc107XG4gICAgfSwgXCJub3JtYWxpemVBcmdzXCIpO1xuICAgIHZhciBOT19FU0NBUEVfUkVHRVhQID0gL15bXFx3Li1dKyQvO1xuICAgIHZhciBET1VCTEVfUVVPVEVTX1JFR0VYUCA9IC9cIi9nO1xuICAgIHZhciBlc2NhcGVBcmcgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChhcmcyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGFyZzIgIT09IFwic3RyaW5nXCIgfHwgTk9fRVNDQVBFX1JFR0VYUC50ZXN0KGFyZzIpKSB7XG4gICAgICAgIHJldHVybiBhcmcyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBcIiR7YXJnMi5yZXBsYWNlKERPVUJMRV9RVU9URVNfUkVHRVhQLCAnXFxcXFwiJyl9XCJgO1xuICAgIH0sIFwiZXNjYXBlQXJnXCIpO1xuICAgIHZhciBqb2luQ29tbWFuZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZpbGUsIGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKGZpbGUsIGFyZ3MpLmpvaW4oXCIgXCIpO1xuICAgIH0sIFwiam9pbkNvbW1hbmRcIik7XG4gICAgdmFyIGdldEVzY2FwZWRDb21tYW5kID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmlsZSwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3MoZmlsZSwgYXJncykubWFwKChhcmcyKSA9PiBlc2NhcGVBcmcoYXJnMikpLmpvaW4oXCIgXCIpO1xuICAgIH0sIFwiZ2V0RXNjYXBlZENvbW1hbmRcIik7XG4gICAgdmFyIFNQQUNFU19SRUdFWFAgPSAvICsvZztcbiAgICB2YXIgcGFyc2VDb21tYW5kID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY29tbWFuZCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGNvbW1hbmQudHJpbSgpLnNwbGl0KFNQQUNFU19SRUdFWFApKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuLmVuZHNXaXRoKFwiXFxcXFwiKSkge1xuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBgJHtwcmV2aW91c1Rva2VuLnNsaWNlKDAsIC0xKX0gJHt0b2tlbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9LCBcInBhcnNlQ29tbWFuZFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBqb2luQ29tbWFuZCxcbiAgICAgIGdldEVzY2FwZWRDb21tYW5kLFxuICAgICAgcGFyc2VDb21tYW5kXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvaW5kZXguanNcbnZhciByZXF1aXJlX2V4ZWNhID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGF0aDcgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICB2YXIgY2hpbGRQcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG4gICAgdmFyIGNyb3NzU3Bhd24gPSByZXF1aXJlX2Nyb3NzX3NwYXduKCk7XG4gICAgdmFyIHN0cmlwRmluYWxOZXdsaW5lID0gcmVxdWlyZV9zdHJpcF9maW5hbF9uZXdsaW5lKCk7XG4gICAgdmFyIG5wbVJ1blBhdGggPSByZXF1aXJlX25wbV9ydW5fcGF0aCgpO1xuICAgIHZhciBvbmV0aW1lID0gcmVxdWlyZV9vbmV0aW1lKCk7XG4gICAgdmFyIG1ha2VFcnJvciA9IHJlcXVpcmVfZXJyb3IoKTtcbiAgICB2YXIgbm9ybWFsaXplU3RkaW8gPSByZXF1aXJlX3N0ZGlvKCk7XG4gICAgdmFyIHsgc3Bhd25lZEtpbGwsIHNwYXduZWRDYW5jZWwsIHNldHVwVGltZW91dCwgdmFsaWRhdGVUaW1lb3V0LCBzZXRFeGl0SGFuZGxlciB9ID0gcmVxdWlyZV9raWxsKCk7XG4gICAgdmFyIHsgaGFuZGxlSW5wdXQsIGdldFNwYXduZWRSZXN1bHQsIG1ha2VBbGxTdHJlYW0sIHZhbGlkYXRlSW5wdXRTeW5jIH0gPSByZXF1aXJlX3N0cmVhbSgpO1xuICAgIHZhciB7IG1lcmdlUHJvbWlzZSwgZ2V0U3Bhd25lZFByb21pc2UgfSA9IHJlcXVpcmVfcHJvbWlzZSgpO1xuICAgIHZhciB7IGpvaW5Db21tYW5kLCBwYXJzZUNvbW1hbmQsIGdldEVzY2FwZWRDb21tYW5kIH0gPSByZXF1aXJlX2NvbW1hbmQoKTtcbiAgICB2YXIgREVGQVVMVF9NQVhfQlVGRkVSID0gMWUzICogMWUzICogMTAwO1xuICAgIHZhciBnZXRFbnYyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoeyBlbnY6IGVudk9wdGlvbiwgZXh0ZW5kRW52LCBwcmVmZXJMb2NhbCwgbG9jYWxEaXIsIGV4ZWNQYXRoIH0pID0+IHtcbiAgICAgIGNvbnN0IGVudjIgPSBleHRlbmRFbnYgPyB7IC4uLnByb2Nlc3MuZW52LCAuLi5lbnZPcHRpb24gfSA6IGVudk9wdGlvbjtcbiAgICAgIGlmIChwcmVmZXJMb2NhbCkge1xuICAgICAgICByZXR1cm4gbnBtUnVuUGF0aC5lbnYoeyBlbnY6IGVudjIsIGN3ZDogbG9jYWxEaXIsIGV4ZWNQYXRoIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudjI7XG4gICAgfSwgXCJnZXRFbnZcIik7XG4gICAgdmFyIGhhbmRsZUFyZ3VtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZpbGUsIGFyZ3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gY3Jvc3NTcGF3bi5fcGFyc2UoZmlsZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICBmaWxlID0gcGFyc2VkLmNvbW1hbmQ7XG4gICAgICBhcmdzID0gcGFyc2VkLmFyZ3M7XG4gICAgICBvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBtYXhCdWZmZXI6IERFRkFVTFRfTUFYX0JVRkZFUixcbiAgICAgICAgYnVmZmVyOiB0cnVlLFxuICAgICAgICBzdHJpcEZpbmFsTmV3bGluZTogdHJ1ZSxcbiAgICAgICAgZXh0ZW5kRW52OiB0cnVlLFxuICAgICAgICBwcmVmZXJMb2NhbDogZmFsc2UsXG4gICAgICAgIGxvY2FsRGlyOiBvcHRpb25zLmN3ZCB8fCBwcm9jZXNzLmN3ZCgpLFxuICAgICAgICBleGVjUGF0aDogcHJvY2Vzcy5leGVjUGF0aCxcbiAgICAgICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgICAgICByZWplY3Q6IHRydWUsXG4gICAgICAgIGNsZWFudXA6IHRydWUsXG4gICAgICAgIGFsbDogZmFsc2UsXG4gICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0aW9ucy5lbnYgPSBnZXRFbnYyKG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5zdGRpbyA9IG5vcm1hbGl6ZVN0ZGlvKG9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiAmJiBwYXRoNy5iYXNlbmFtZShmaWxlLCBcIi5leGVcIikgPT09IFwiY21kXCIpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KFwiL3FcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBmaWxlLCBhcmdzLCBvcHRpb25zLCBwYXJzZWQgfTtcbiAgICB9LCBcImhhbmRsZUFyZ3VtZW50c1wiKTtcbiAgICB2YXIgaGFuZGxlT3V0cHV0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucywgdmFsdWUsIGVycm9yMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc3RyaXBGaW5hbE5ld2xpbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0cmlwRmluYWxOZXdsaW5lKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBcImhhbmRsZU91dHB1dFwiKTtcbiAgICB2YXIgZXhlY2EyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmlsZSwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gaGFuZGxlQXJndW1lbnRzKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgY29tbWFuZCA9IGpvaW5Db21tYW5kKGZpbGUsIGFyZ3MpO1xuICAgICAgY29uc3QgZXNjYXBlZENvbW1hbmQgPSBnZXRFc2NhcGVkQ29tbWFuZChmaWxlLCBhcmdzKTtcbiAgICAgIHZhbGlkYXRlVGltZW91dChwYXJzZWQub3B0aW9ucyk7XG4gICAgICBsZXQgc3Bhd25lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNwYXduZWQgPSBjaGlsZFByb2Nlc3Muc3Bhd24ocGFyc2VkLmZpbGUsIHBhcnNlZC5hcmdzLCBwYXJzZWQub3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgY29uc3QgZHVtbXlTcGF3bmVkID0gbmV3IGNoaWxkUHJvY2Vzcy5DaGlsZFByb2Nlc3MoKTtcbiAgICAgICAgY29uc3QgZXJyb3JQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKHtcbiAgICAgICAgICBlcnJvcjogZXJyb3IyLFxuICAgICAgICAgIHN0ZG91dDogXCJcIixcbiAgICAgICAgICBzdGRlcnI6IFwiXCIsXG4gICAgICAgICAgYWxsOiBcIlwiLFxuICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgZXNjYXBlZENvbW1hbmQsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICBpc0NhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgICBraWxsZWQ6IGZhbHNlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlUHJvbWlzZShkdW1teVNwYXduZWQsIGVycm9yUHJvbWlzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGF3bmVkUHJvbWlzZSA9IGdldFNwYXduZWRQcm9taXNlKHNwYXduZWQpO1xuICAgICAgY29uc3QgdGltZWRQcm9taXNlID0gc2V0dXBUaW1lb3V0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLCBzcGF3bmVkUHJvbWlzZSk7XG4gICAgICBjb25zdCBwcm9jZXNzRG9uZSA9IHNldEV4aXRIYW5kbGVyKHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLCB0aW1lZFByb21pc2UpO1xuICAgICAgY29uc3QgY29udGV4dDMgPSB7IGlzQ2FuY2VsZWQ6IGZhbHNlIH07XG4gICAgICBzcGF3bmVkLmtpbGwgPSBzcGF3bmVkS2lsbC5iaW5kKG51bGwsIHNwYXduZWQua2lsbC5iaW5kKHNwYXduZWQpKTtcbiAgICAgIHNwYXduZWQuY2FuY2VsID0gc3Bhd25lZENhbmNlbC5iaW5kKG51bGwsIHNwYXduZWQsIGNvbnRleHQzKTtcbiAgICAgIGNvbnN0IGhhbmRsZVByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgW3sgZXJyb3I6IGVycm9yMiwgZXhpdENvZGUsIHNpZ25hbCwgdGltZWRPdXQgfSwgc3Rkb3V0UmVzdWx0LCBzdGRlcnJSZXN1bHQsIGFsbFJlc3VsdF0gPSBhd2FpdCBnZXRTcGF3bmVkUmVzdWx0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLCBwcm9jZXNzRG9uZSk7XG4gICAgICAgIGNvbnN0IHN0ZG91dCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgc3Rkb3V0UmVzdWx0KTtcbiAgICAgICAgY29uc3Qgc3RkZXJyID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCBzdGRlcnJSZXN1bHQpO1xuICAgICAgICBjb25zdCBhbGwgPSBoYW5kbGVPdXRwdXQocGFyc2VkLm9wdGlvbnMsIGFsbFJlc3VsdCk7XG4gICAgICAgIGlmIChlcnJvcjIgfHwgZXhpdENvZGUgIT09IDAgfHwgc2lnbmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcmV0dXJuZWRFcnJvciA9IG1ha2VFcnJvcih7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IyLFxuICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICBzdGRvdXQsXG4gICAgICAgICAgICBzdGRlcnIsXG4gICAgICAgICAgICBhbGwsXG4gICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgZXNjYXBlZENvbW1hbmQsXG4gICAgICAgICAgICBwYXJzZWQsXG4gICAgICAgICAgICB0aW1lZE91dCxcbiAgICAgICAgICAgIGlzQ2FuY2VsZWQ6IGNvbnRleHQzLmlzQ2FuY2VsZWQsXG4gICAgICAgICAgICBraWxsZWQ6IHNwYXduZWQua2lsbGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFwYXJzZWQub3B0aW9ucy5yZWplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lZEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZXR1cm5lZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICBlc2NhcGVkQ29tbWFuZCxcbiAgICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgICBzdGRvdXQsXG4gICAgICAgICAgc3RkZXJyLFxuICAgICAgICAgIGFsbCxcbiAgICAgICAgICBmYWlsZWQ6IGZhbHNlLFxuICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICBpc0NhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgICBraWxsZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LCBcImhhbmRsZVByb21pc2VcIik7XG4gICAgICBjb25zdCBoYW5kbGVQcm9taXNlT25jZSA9IG9uZXRpbWUoaGFuZGxlUHJvbWlzZSk7XG4gICAgICBoYW5kbGVJbnB1dChzcGF3bmVkLCBwYXJzZWQub3B0aW9ucy5pbnB1dCk7XG4gICAgICBzcGF3bmVkLmFsbCA9IG1ha2VBbGxTdHJlYW0oc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1lcmdlUHJvbWlzZShzcGF3bmVkLCBoYW5kbGVQcm9taXNlT25jZSk7XG4gICAgfSwgXCJleGVjYVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBleGVjYTI7XG4gICAgbW9kdWxlMi5leHBvcnRzLnN5bmMgPSAoZmlsZSwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gaGFuZGxlQXJndW1lbnRzKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgY29tbWFuZCA9IGpvaW5Db21tYW5kKGZpbGUsIGFyZ3MpO1xuICAgICAgY29uc3QgZXNjYXBlZENvbW1hbmQgPSBnZXRFc2NhcGVkQ29tbWFuZChmaWxlLCBhcmdzKTtcbiAgICAgIHZhbGlkYXRlSW5wdXRTeW5jKHBhcnNlZC5vcHRpb25zKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjaGlsZFByb2Nlc3Muc3Bhd25TeW5jKHBhcnNlZC5maWxlLCBwYXJzZWQuYXJncywgcGFyc2VkLm9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcih7XG4gICAgICAgICAgZXJyb3I6IGVycm9yMixcbiAgICAgICAgICBzdGRvdXQ6IFwiXCIsXG4gICAgICAgICAgc3RkZXJyOiBcIlwiLFxuICAgICAgICAgIGFsbDogXCJcIixcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIGVzY2FwZWRDb21tYW5kLFxuICAgICAgICAgIHBhcnNlZCxcbiAgICAgICAgICB0aW1lZE91dDogZmFsc2UsXG4gICAgICAgICAgaXNDYW5jZWxlZDogZmFsc2UsXG4gICAgICAgICAga2lsbGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0ZG91dCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgcmVzdWx0LnN0ZG91dCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIGNvbnN0IHN0ZGVyciA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgcmVzdWx0LnN0ZGVyciwgcmVzdWx0LmVycm9yKTtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IgfHwgcmVzdWx0LnN0YXR1cyAhPT0gMCB8fCByZXN1bHQuc2lnbmFsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVycm9yMiA9IG1ha2VFcnJvcih7XG4gICAgICAgICAgc3Rkb3V0LFxuICAgICAgICAgIHN0ZGVycixcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgICAgIHNpZ25hbDogcmVzdWx0LnNpZ25hbCxcbiAgICAgICAgICBleGl0Q29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIGVzY2FwZWRDb21tYW5kLFxuICAgICAgICAgIHBhcnNlZCxcbiAgICAgICAgICB0aW1lZE91dDogcmVzdWx0LmVycm9yICYmIHJlc3VsdC5lcnJvci5jb2RlID09PSBcIkVUSU1FRE9VVFwiLFxuICAgICAgICAgIGlzQ2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICAgIGtpbGxlZDogcmVzdWx0LnNpZ25hbCAhPT0gbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwYXJzZWQub3B0aW9ucy5yZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hbmQsXG4gICAgICAgIGVzY2FwZWRDb21tYW5kLFxuICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgc3Rkb3V0LFxuICAgICAgICBzdGRlcnIsXG4gICAgICAgIGZhaWxlZDogZmFsc2UsXG4gICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgaXNDYW5jZWxlZDogZmFsc2UsXG4gICAgICAgIGtpbGxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29tbWFuZCA9IChjb21tYW5kLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBbZmlsZSwgLi4uYXJnc10gPSBwYXJzZUNvbW1hbmQoY29tbWFuZCk7XG4gICAgICByZXR1cm4gZXhlY2EyKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzLmNvbW1hbmRTeW5jID0gKGNvbW1hbmQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IFtmaWxlLCAuLi5hcmdzXSA9IHBhcnNlQ29tbWFuZChjb21tYW5kKTtcbiAgICAgIHJldHVybiBleGVjYTIuc3luYyhmaWxlLCBhcmdzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5ub2RlID0gKHNjcmlwdFBhdGgsIGFyZ3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKGFyZ3MgJiYgIUFycmF5LmlzQXJyYXkoYXJncykgJiYgdHlwZW9mIGFyZ3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3M7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0ZGlvID0gbm9ybWFsaXplU3RkaW8ubm9kZShvcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRFeGVjQXJndiA9IHByb2Nlc3MuZXhlY0FyZ3YuZmlsdGVyKChhcmcyKSA9PiAhYXJnMi5zdGFydHNXaXRoKFwiLS1pbnNwZWN0XCIpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZVBhdGggPSBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgICAgICBub2RlT3B0aW9ucyA9IGRlZmF1bHRFeGVjQXJndlxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICByZXR1cm4gZXhlY2EyKFxuICAgICAgICBub2RlUGF0aCxcbiAgICAgICAgW1xuICAgICAgICAgIC4uLm5vZGVPcHRpb25zLFxuICAgICAgICAgIHNjcmlwdFBhdGgsXG4gICAgICAgICAgLi4uQXJyYXkuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbXVxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBzdGRpbjogdm9pZCAwLFxuICAgICAgICAgIHN0ZG91dDogdm9pZCAwLFxuICAgICAgICAgIHN0ZGVycjogdm9pZCAwLFxuICAgICAgICAgIHN0ZGlvLFxuICAgICAgICAgIHNoZWxsOiBmYWxzZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnlfb3BlcmF0aW9uLmpzXG52YXIgcmVxdWlyZV9yZXRyeV9vcGVyYXRpb24gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnlfb3BlcmF0aW9uLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIGZ1bmN0aW9uIFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IGZvcmV2ZXI6IG9wdGlvbnMgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29yaWdpbmFsVGltZW91dHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVvdXRzKSk7XG4gICAgICB0aGlzLl90aW1lb3V0cyA9IHRpbWVvdXRzO1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9tYXhSZXRyeVRpbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lIHx8IEluZmluaXR5O1xuICAgICAgdGhpcy5fZm4gPSBudWxsO1xuICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKFJldHJ5T3BlcmF0aW9uLCBcIlJldHJ5T3BlcmF0aW9uXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFJldHJ5T3BlcmF0aW9uO1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYXR0ZW1wdHMgPSAxO1xuICAgICAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzLnNsaWNlKDApO1xuICAgIH07XG4gICAgUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGltZW91dHMgPSBbXTtcbiAgICAgIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gbnVsbDtcbiAgICB9O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBpZiAoZXJyICYmIGN1cnJlbnRUaW1lIC0gdGhpcy5fb3BlcmF0aW9uU3RhcnQgPj0gdGhpcy5fbWF4UmV0cnlUaW1lKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKGVycik7XG4gICAgICAgIHRoaXMuX2Vycm9ycy51bnNoaWZ0KG5ldyBFcnJvcihcIlJldHJ5T3BlcmF0aW9uIHRpbWVvdXQgb2NjdXJyZWRcIikpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5zaGlmdCgpO1xuICAgICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkVGltZW91dHMpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMuc3BsaWNlKDAsIHRoaXMuX2Vycm9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICB0aW1lb3V0ID0gdGhpcy5fY2FjaGVkVGltZW91dHMuc2xpY2UoLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZjIuX2F0dGVtcHRzKys7XG4gICAgICAgIGlmIChzZWxmMi5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICAgICAgc2VsZjIuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZjIuX29wZXJhdGlvblRpbWVvdXRDYihzZWxmMi5fYXR0ZW1wdHMpO1xuICAgICAgICAgIH0sIHNlbGYyLl9vcGVyYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICBpZiAoc2VsZjIuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgICAgICAgIHNlbGYyLl90aW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYyLl9mbihzZWxmMi5fYXR0ZW1wdHMpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICB0aGlzLl90aW1lci51bnJlZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0T3BzKSB7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgaWYgKHRpbWVvdXRPcHMpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRPcHMudGltZW91dCkge1xuICAgICAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSB0aW1lb3V0T3BzLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVvdXRPcHMuY2IpIHtcbiAgICAgICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSB0aW1lb3V0T3BzLmNiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmMi5fb3BlcmF0aW9uVGltZW91dENiKCk7XG4gICAgICAgIH0sIHNlbGYyLl9vcGVyYXRpb25UaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgUmV0cnlPcGVyYXRpb24udHJ5KCkgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgIHRoaXMuYXR0ZW1wdChmbik7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbikge1xuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWRcIik7XG4gICAgICB0aGlzLmF0dGVtcHQoZm4pO1xuICAgIH07XG4gICAgUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnRyeTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3JzO1xuICAgIH07XG4gICAgUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmF0dGVtcHRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudHMgPSB7fTtcbiAgICAgIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICAgICAgdmFyIG1haW5FcnJvckNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvcjIgPSB0aGlzLl9lcnJvcnNbaV07XG4gICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IyLm1lc3NhZ2U7XG4gICAgICAgIHZhciBjb3VudDIgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcbiAgICAgICAgY291bnRzW21lc3NhZ2VdID0gY291bnQyO1xuICAgICAgICBpZiAoY291bnQyID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICAgICAgbWFpbkVycm9yID0gZXJyb3IyO1xuICAgICAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFpbkVycm9yO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanNcbnZhciByZXF1aXJlX3JldHJ5ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5LmpzXCIoZXhwb3J0cykge1xuICAgIHZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmVfcmV0cnlfb3BlcmF0aW9uKCk7XG4gICAgZXhwb3J0cy5vcGVyYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBSZXRyeU9wZXJhdGlvbih0aW1lb3V0cywge1xuICAgICAgICBmb3JldmVyOiBvcHRpb25zICYmIChvcHRpb25zLmZvcmV2ZXIgfHwgb3B0aW9ucy5yZXRyaWVzID09PSBJbmZpbml0eSksXG4gICAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWYsXG4gICAgICAgIG1heFJldHJ5VGltZTogb3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJ5VGltZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHJldHJpZXM6IDEwLFxuICAgICAgICBmYWN0b3I6IDIsXG4gICAgICAgIG1pblRpbWVvdXQ6IDEgKiAxZTMsXG4gICAgICAgIG1heFRpbWVvdXQ6IEluZmluaXR5LFxuICAgICAgICByYW5kb21pemU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5UaW1lb3V0IGlzIGdyZWF0ZXIgdGhhbiBtYXhUaW1lb3V0XCIpO1xuICAgICAgfVxuICAgICAgdmFyIHRpbWVvdXRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMucmV0cmllczsgaSsrKSB7XG4gICAgICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9yZXZlciAmJiAhdGltZW91dHMubGVuZ3RoKSB7XG4gICAgICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aW1lb3V0cztcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uKGF0dGVtcHQsIG9wdHMpIHtcbiAgICAgIHZhciByYW5kb20yID0gb3B0cy5yYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpICsgMSA6IDE7XG4gICAgICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tMiAqIE1hdGgubWF4KG9wdHMubWluVGltZW91dCwgMSkgKiBNYXRoLnBvdyhvcHRzLmZhY3RvciwgYXR0ZW1wdCkpO1xuICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQsIG9wdHMubWF4VGltZW91dCk7XG4gICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9O1xuICAgIGV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgbWV0aG9kcykge1xuICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBtZXRob2RzID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZHMpIHtcbiAgICAgICAgbWV0aG9kcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtZXRob2RzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gb2JqW21ldGhvZF07XG4gICAgICAgIG9ialttZXRob2RdID0gKC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gcmV0cnlXcmFwcGVyKG9yaWdpbmFsMikge1xuICAgICAgICAgIHZhciBvcCA9IGV4cG9ydHMub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChvcC5yZXRyeShlcnIpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gb3AubWFpbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9wLmF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBvcmlnaW5hbDIuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgXCJyZXRyeVdyYXBwZXJcIikpLmJpbmQob2JqLCBvcmlnaW5hbCk7XG4gICAgICAgIG9ialttZXRob2RdLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmV0cnkyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9yZXRyeSgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3AtcmV0cnlANC42LjIvbm9kZV9tb2R1bGVzL3AtcmV0cnkvaW5kZXguanNcbnZhciByZXF1aXJlX3BfcmV0cnkgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcC1yZXRyeUA0LjYuMi9ub2RlX21vZHVsZXMvcC1yZXRyeS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcmV0cnkgPSByZXF1aXJlX3JldHJ5MigpO1xuICAgIHZhciBuZXR3b3JrRXJyb3JNc2dzID0gW1xuICAgICAgXCJGYWlsZWQgdG8gZmV0Y2hcIixcbiAgICAgIFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIixcbiAgICAgIFwiVGhlIEludGVybmV0IGNvbm5lY3Rpb24gYXBwZWFycyB0byBiZSBvZmZsaW5lLlwiLFxuICAgICAgXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCJcbiAgICBdO1xuICAgIHZhciBBYm9ydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBtZXNzYWdlO1xuICAgICAgICAgICh7IG1lc3NhZ2UgfSA9IG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3Iuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEFib3J0RXJyb3IsIFwiQWJvcnRFcnJvclwiKTtcbiAgICB2YXIgZGVjb3JhdGVFcnJvcldpdGhDb3VudHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlcnJvcjIsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJldHJpZXNMZWZ0ID0gb3B0aW9ucy5yZXRyaWVzIC0gKGF0dGVtcHROdW1iZXIgLSAxKTtcbiAgICAgIGVycm9yMi5hdHRlbXB0TnVtYmVyID0gYXR0ZW1wdE51bWJlcjtcbiAgICAgIGVycm9yMi5yZXRyaWVzTGVmdCA9IHJldHJpZXNMZWZ0O1xuICAgICAgcmV0dXJuIGVycm9yMjtcbiAgICB9LCBcImRlY29yYXRlRXJyb3JXaXRoQ291bnRzXCIpO1xuICAgIHZhciBpc05ldHdvcmtFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGVycm9yTWVzc2FnZSkgPT4gbmV0d29ya0Vycm9yTXNncy5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpLCBcImlzTmV0d29ya0Vycm9yXCIpO1xuICAgIHZhciBwUmV0cnkyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoaW5wdXQsIG9wdGlvbnMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICByZXRyaWVzOiAxMCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJldHJ5Lm9wZXJhdGlvbihvcHRpb25zKTtcbiAgICAgIG9wZXJhdGlvbi5hdHRlbXB0KGFzeW5jIChhdHRlbXB0TnVtYmVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZShhd2FpdCBpbnB1dChhdHRlbXB0TnVtYmVyKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgIGlmICghKGVycm9yMiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoYE5vbi1lcnJvciB3YXMgdGhyb3duOiBcIiR7ZXJyb3IyfVwiLiBZb3Ugc2hvdWxkIG9ubHkgdGhyb3cgZXJyb3JzLmApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIEFib3J0RXJyb3IpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IyLm9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmICFpc05ldHdvcmtFcnJvcihlcnJvcjIubWVzc2FnZSkpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVjb3JhdGVFcnJvcldpdGhDb3VudHMoZXJyb3IyLCBhdHRlbXB0TnVtYmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IG9wdGlvbnMub25GYWlsZWRBdHRlbXB0KGVycm9yMik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yMyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3BlcmF0aW9uLnJldHJ5KGVycm9yMikpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG9wZXJhdGlvbi5tYWluRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgXCJwUmV0cnlcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcFJldHJ5MjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZGVmYXVsdCA9IHBSZXRyeTI7XG4gICAgbW9kdWxlMi5leHBvcnRzLkFib3J0RXJyb3IgPSBBYm9ydEVycm9yO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Fuc2ktcmVnZXhANS4wLjEvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanNcbnZhciByZXF1aXJlX2Fuc2lfcmVnZXggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYW5zaS1yZWdleEA1LjAuMS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAoeyBvbmx5Rmlyc3QgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBbXG4gICAgICAgIFwiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFxuICAgICAgICBcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJcbiAgICAgIF0uam9pbihcInxcIik7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBvbmx5Rmlyc3QgPyB2b2lkIDAgOiBcImdcIik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpcC1hbnNpQDYuMC4xL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zdHJpcF9hbnNpID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmlwLWFuc2lANi4wLjEvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFuc2lSZWdleCA9IHJlcXVpcmVfYW5zaV9yZWdleCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChzdHJpbmcpID0+IHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgPyBzdHJpbmcucmVwbGFjZShhbnNpUmVnZXgoKSwgXCJcIikgOiBzdHJpbmc7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV3LWdpdGh1Yi1pc3N1ZS11cmxAMC4yLjEvbm9kZV9tb2R1bGVzL25ldy1naXRodWItaXNzdWUtdXJsL2luZGV4LmpzXG52YXIgcmVxdWlyZV9uZXdfZ2l0aHViX2lzc3VlX3VybCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXctZ2l0aHViLWlzc3VlLXVybEAwLjIuMS9ub2RlX21vZHVsZXMvbmV3LWdpdGh1Yi1pc3N1ZS11cmwvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHJlcG9Vcmw7XG4gICAgICBpZiAob3B0aW9ucy5yZXBvVXJsKSB7XG4gICAgICAgIHJlcG9VcmwgPSBvcHRpb25zLnJlcG9Vcmw7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudXNlciAmJiBvcHRpb25zLnJlcG8pIHtcbiAgICAgICAgcmVwb1VybCA9IGBodHRwczovL2dpdGh1Yi5jb20vJHtvcHRpb25zLnVzZXJ9LyR7b3B0aW9ucy5yZXBvfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGVpdGhlciB0aGUgYHJlcG9VcmxgIG9wdGlvbiBvciBib3RoIHRoZSBgdXNlcmAgYW5kIGByZXBvYCBvcHRpb25zXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtyZXBvVXJsfS9pc3N1ZXMvbmV3YCk7XG4gICAgICBjb25zdCB0eXBlcyA9IFtcbiAgICAgICAgXCJib2R5XCIsXG4gICAgICAgIFwidGl0bGVcIixcbiAgICAgICAgXCJsYWJlbHNcIixcbiAgICAgICAgXCJ0ZW1wbGF0ZVwiLFxuICAgICAgICBcIm1pbGVzdG9uZVwiLFxuICAgICAgICBcImFzc2lnbmVlXCIsXG4gICAgICAgIFwicHJvamVjdHNcIlxuICAgICAgXTtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBvcHRpb25zW3R5cGVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImxhYmVsc1wiIHx8IHR5cGUgPT09IFwicHJvamVjdHNcIikge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGAke3R5cGV9XFxgIG9wdGlvbiBzaG91bGQgYmUgYW4gYXJyYXlgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZTIuZXhwb3J0cztcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qc1xudmFyIHJlcXVpcmVfc3ltYm9scyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBrQ2xvc2U6IFN5bWJvbChcImNsb3NlXCIpLFxuICAgICAga0Rlc3Ryb3k6IFN5bWJvbChcImRlc3Ryb3lcIiksXG4gICAgICBrRGlzcGF0Y2g6IFN5bWJvbChcImRpc3BhdGNoXCIpLFxuICAgICAga1VybDogU3ltYm9sKFwidXJsXCIpLFxuICAgICAga1dyaXRpbmc6IFN5bWJvbChcIndyaXRpbmdcIiksXG4gICAgICBrUmVzdW1pbmc6IFN5bWJvbChcInJlc3VtaW5nXCIpLFxuICAgICAga1F1ZXVlOiBTeW1ib2woXCJxdWV1ZVwiKSxcbiAgICAgIGtDb25uZWN0OiBTeW1ib2woXCJjb25uZWN0XCIpLFxuICAgICAga0Nvbm5lY3Rpbmc6IFN5bWJvbChcImNvbm5lY3RpbmdcIiksXG4gICAgICBrSGVhZGVyc0xpc3Q6IFN5bWJvbChcImhlYWRlcnMgbGlzdFwiKSxcbiAgICAgIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKFwiZGVmYXVsdCBrZWVwIGFsaXZlIHRpbWVvdXRcIiksXG4gICAgICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKFwibWF4IGtlZXAgYWxpdmUgdGltZW91dFwiKSxcbiAgICAgIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woXCJrZWVwIGFsaXZlIHRpbWVvdXQgdGhyZXNob2xkXCIpLFxuICAgICAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKFwia2VlcCBhbGl2ZSB0aW1lb3V0XCIpLFxuICAgICAga0tlZXBBbGl2ZTogU3ltYm9sKFwia2VlcCBhbGl2ZVwiKSxcbiAgICAgIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKFwiaGVhZGVycyB0aW1lb3V0XCIpLFxuICAgICAga0JvZHlUaW1lb3V0OiBTeW1ib2woXCJib2R5IHRpbWVvdXRcIiksXG4gICAgICBrU2VydmVyTmFtZTogU3ltYm9sKFwic2VydmVyIG5hbWVcIiksXG4gICAgICBrSG9zdDogU3ltYm9sKFwiaG9zdFwiKSxcbiAgICAgIGtOb1JlZjogU3ltYm9sKFwibm8gcmVmXCIpLFxuICAgICAga0JvZHlVc2VkOiBTeW1ib2woXCJ1c2VkXCIpLFxuICAgICAga1J1bm5pbmc6IFN5bWJvbChcInJ1bm5pbmdcIiksXG4gICAgICBrQmxvY2tpbmc6IFN5bWJvbChcImJsb2NraW5nXCIpLFxuICAgICAga1BlbmRpbmc6IFN5bWJvbChcInBlbmRpbmdcIiksXG4gICAgICBrU2l6ZTogU3ltYm9sKFwic2l6ZVwiKSxcbiAgICAgIGtCdXN5OiBTeW1ib2woXCJidXN5XCIpLFxuICAgICAga1F1ZXVlZDogU3ltYm9sKFwicXVldWVkXCIpLFxuICAgICAga0ZyZWU6IFN5bWJvbChcImZyZWVcIiksXG4gICAgICBrQ29ubmVjdGVkOiBTeW1ib2woXCJjb25uZWN0ZWRcIiksXG4gICAgICBrQ2xvc2VkOiBTeW1ib2woXCJjbG9zZWRcIiksXG4gICAgICBrTmVlZERyYWluOiBTeW1ib2woXCJuZWVkIGRyYWluXCIpLFxuICAgICAga1Jlc2V0OiBTeW1ib2woXCJyZXNldFwiKSxcbiAgICAgIGtEZXN0cm95ZWQ6IFN5bWJvbChcImRlc3Ryb3llZFwiKSxcbiAgICAgIGtNYXhIZWFkZXJzU2l6ZTogU3ltYm9sKFwibWF4IGhlYWRlcnMgc2l6ZVwiKSxcbiAgICAgIGtSdW5uaW5nSWR4OiBTeW1ib2woXCJydW5uaW5nIGluZGV4XCIpLFxuICAgICAga1BlbmRpbmdJZHg6IFN5bWJvbChcInBlbmRpbmcgaW5kZXhcIiksXG4gICAgICBrRXJyb3I6IFN5bWJvbChcImVycm9yXCIpLFxuICAgICAga0NsaWVudHM6IFN5bWJvbChcImNsaWVudHNcIiksXG4gICAgICBrQ2xpZW50OiBTeW1ib2woXCJjbGllbnRcIiksXG4gICAgICBrUGFyc2VyOiBTeW1ib2woXCJwYXJzZXJcIiksXG4gICAgICBrT25EZXN0cm95ZWQ6IFN5bWJvbChcImRlc3Ryb3kgY2FsbGJhY2tzXCIpLFxuICAgICAga1BpcGVsaW5pbmc6IFN5bWJvbChcInBpcGVsaW5pZ1wiKSxcbiAgICAgIGtTb2NrZXQ6IFN5bWJvbChcInNvY2tldFwiKSxcbiAgICAgIGtIb3N0SGVhZGVyOiBTeW1ib2woXCJob3N0IGhlYWRlclwiKSxcbiAgICAgIGtDb25uZWN0b3I6IFN5bWJvbChcImNvbm5lY3RvclwiKSxcbiAgICAgIGtTdHJpY3RDb250ZW50TGVuZ3RoOiBTeW1ib2woXCJzdHJpY3QgY29udGVudCBsZW5ndGhcIiksXG4gICAgICBrTWF4UmVkaXJlY3Rpb25zOiBTeW1ib2woXCJtYXhSZWRpcmVjdGlvbnNcIiksXG4gICAgICBrTWF4UmVxdWVzdHM6IFN5bWJvbChcIm1heFJlcXVlc3RzUGVyQ2xpZW50XCIpLFxuICAgICAga1Byb3h5OiBTeW1ib2woXCJwcm94eSBhZ2VudCBvcHRpb25zXCIpLFxuICAgICAga0NvdW50ZXI6IFN5bWJvbChcInNvY2tldCByZXF1ZXN0IGNvdW50ZXJcIilcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9lcnJvcnMuanNcbnZhciByZXF1aXJlX2Vycm9ycyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvZXJyb3JzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBVbmRpY2lFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVbmRpY2lFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShVbmRpY2lFcnJvciwgXCJVbmRpY2lFcnJvclwiKTtcbiAgICB2YXIgQ29ubmVjdFRpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ29ubmVjdFRpbWVvdXRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ29ubmVjdFRpbWVvdXRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiQ29ubmVjdCBUaW1lb3V0IEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9DT05ORUNUX1RJTUVPVVRcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShDb25uZWN0VGltZW91dEVycm9yLCBcIkNvbm5lY3RUaW1lb3V0RXJyb3JcIik7XG4gICAgdmFyIEhlYWRlcnNUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhlYWRlcnNUaW1lb3V0RXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhlYWRlcnNUaW1lb3V0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkhlYWRlcnMgVGltZW91dCBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfSEVBREVSU19USU1FT1VUXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSGVhZGVyc1RpbWVvdXRFcnJvciwgXCJIZWFkZXJzVGltZW91dEVycm9yXCIpO1xuICAgIHZhciBIZWFkZXJzT3ZlcmZsb3dFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSGVhZGVyc092ZXJmbG93RXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhlYWRlcnNPdmVyZmxvd0Vycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJIZWFkZXJzIE92ZXJmbG93IEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSGVhZGVyc092ZXJmbG93RXJyb3IsIFwiSGVhZGVyc092ZXJmbG93RXJyb3JcIik7XG4gICAgdmFyIEJvZHlUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEJvZHlUaW1lb3V0RXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkJvZHlUaW1lb3V0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkJvZHkgVGltZW91dCBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfQk9EWV9USU1FT1VUXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQm9keVRpbWVvdXRFcnJvciwgXCJCb2R5VGltZW91dEVycm9yXCIpO1xuICAgIHZhciBSZXNwb25zZVN0YXR1c0NvZGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJSZXNwb25zZSBTdGF0dXMgQ29kZSBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfUkVTUE9OU0VfU1RBVFVTX0NPREVcIjtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yLCBcIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yXCIpO1xuICAgIHZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZEFyZ3VtZW50RXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkludmFsaWRBcmd1bWVudEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJJbnZhbGlkIEFyZ3VtZW50IEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9JTlZBTElEX0FSR1wiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEludmFsaWRBcmd1bWVudEVycm9yLCBcIkludmFsaWRBcmd1bWVudEVycm9yXCIpO1xuICAgIHZhciBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFJldHVyblZhbHVlRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJJbnZhbGlkIFJldHVybiBWYWx1ZSBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciwgXCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvclwiKTtcbiAgICB2YXIgUmVxdWVzdEFib3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxdWVzdEFib3J0ZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiUmVxdWVzdCBhYm9ydGVkXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9BQk9SVEVEXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVxdWVzdEFib3J0ZWRFcnJvciwgXCJSZXF1ZXN0QWJvcnRlZEVycm9yXCIpO1xuICAgIHZhciBJbmZvcm1hdGlvbmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEluZm9ybWF0aW9uYWxFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW5mb3JtYXRpb25hbEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJSZXF1ZXN0IGluZm9ybWF0aW9uXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9JTkZPXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSW5mb3JtYXRpb25hbEVycm9yLCBcIkluZm9ybWF0aW9uYWxFcnJvclwiKTtcbiAgICB2YXIgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiUmVxdWVzdCBib2R5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBjb250ZW50LWxlbmd0aCBoZWFkZXJcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX1JFUV9DT05URU5UX0xFTkdUSF9NSVNNQVRDSFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciwgXCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIik7XG4gICAgdmFyIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlJlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfUkVTX0NPTlRFTlRfTEVOR1RIX01JU01BVENIXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciwgXCJSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yXCIpO1xuICAgIHZhciBDbGllbnREZXN0cm95ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2xpZW50RGVzdHJveWVkRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkNsaWVudERlc3Ryb3llZEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJUaGUgY2xpZW50IGlzIGRlc3Ryb3llZFwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfREVTVFJPWUVEXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQ2xpZW50RGVzdHJveWVkRXJyb3IsIFwiQ2xpZW50RGVzdHJveWVkRXJyb3JcIik7XG4gICAgdmFyIENsaWVudENsb3NlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDbGllbnRDbG9zZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ2xpZW50Q2xvc2VkRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlRoZSBjbGllbnQgaXMgY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9DTE9TRURcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShDbGllbnRDbG9zZWRFcnJvciwgXCJDbGllbnRDbG9zZWRFcnJvclwiKTtcbiAgICB2YXIgU29ja2V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU29ja2V0RXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNvY2tldEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJTb2NrZXQgZXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX1NPQ0tFVFwiO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShTb2NrZXRFcnJvciwgXCJTb2NrZXRFcnJvclwiKTtcbiAgICB2YXIgTm90U3VwcG9ydGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFN1cHBvcnRlZEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb3RTdXBwb3J0ZWRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiTm90IHN1cHBvcnRlZCBlcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfTk9UX1NVUFBPUlRFRFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE5vdFN1cHBvcnRlZEVycm9yLCBcIk5vdFN1cHBvcnRlZEVycm9yXCIpO1xuICAgIHZhciBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk1pc3NpbmdVcHN0cmVhbUVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJObyB1cHN0cmVhbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQmFsYW5jZWRQb29sXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTVwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yLCBcIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yXCIpO1xuICAgIHZhciBIVFRQUGFyc2VyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhUVFBQYXJzZXJFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSFRUUFBhcnNlckVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdm9pZCAwO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhID8gZGF0YS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEhUVFBQYXJzZXJFcnJvciwgXCJIVFRQUGFyc2VyRXJyb3JcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgSFRUUFBhcnNlckVycm9yLFxuICAgICAgVW5kaWNpRXJyb3IsXG4gICAgICBIZWFkZXJzVGltZW91dEVycm9yLFxuICAgICAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gICAgICBCb2R5VGltZW91dEVycm9yLFxuICAgICAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICAgICAgQ29ubmVjdFRpbWVvdXRFcnJvcixcbiAgICAgIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yLFxuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgICAgIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gICAgICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgICAgIENsaWVudENsb3NlZEVycm9yLFxuICAgICAgSW5mb3JtYXRpb25hbEVycm9yLFxuICAgICAgU29ja2V0RXJyb3IsXG4gICAgICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgICAgIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gICAgICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanNcbnZhciByZXF1aXJlX3V0aWwyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB7IGtEZXN0cm95ZWQsIGtCb2R5VXNlZCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIHsgSW5jb21pbmdNZXNzYWdlIH0gPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICB2YXIgc3RyZWFtMiA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgdmFyIG5ldDIgPSByZXF1aXJlKFwibmV0XCIpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB7IEJsb2IgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgdmFyIG5vZGVVdGlsID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgZnVuY3Rpb24gbm9wKCkge1xuICAgIH1cbiAgICBfX25hbWUobm9wLCBcIm5vcFwiKTtcbiAgICBmdW5jdGlvbiBpc1N0cmVhbShvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIF9fbmFtZShpc1N0cmVhbSwgXCJpc1N0cmVhbVwiKTtcbiAgICBmdW5jdGlvbiBpc0Jsb2JMaWtlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIEJsb2IgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYiB8fCBvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIpICYmIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgICB9XG4gICAgX19uYW1lKGlzQmxvYkxpa2UsIFwiaXNCbG9iTGlrZVwiKTtcbiAgICBmdW5jdGlvbiBpc09iamVjdDModmFsKSB7XG4gICAgICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG4gICAgfVxuICAgIF9fbmFtZShpc09iamVjdDMsIFwiaXNPYmplY3RcIik7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgIH1cbiAgICBfX25hbWUoZW5jb2RlLCBcImVuY29kZVwiKTtcbiAgICBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICBpZiAodXJsLmluY2x1ZGVzKFwiP1wiKSB8fCB1cmwuaW5jbHVkZXMoXCIjXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QzKHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeSBwYXJhbXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0Myh2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFzc2luZyBvYmplY3QgYXMgYSBxdWVyeSBwYXJhbSBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2Ugc2VyaWFsaXplIHRvIHN0cmluZyB1cC1mcm9udFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArIFwiPVwiICsgZW5jb2RlKHYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oXCImXCIpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgdXJsICs9IFwiP1wiICsgc2VyaWFsaXplZFBhcmFtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZFVSTCwgXCJidWlsZFVSTFwiKTtcbiAgICBmdW5jdGlvbiBwYXJzZVVSTCh1cmwpIHtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCB1cmxcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsLnBvcnQgIT0gbnVsbCAmJiB1cmwucG9ydCAhPT0gXCJcIiAmJiAhTnVtYmVyLmlzRmluaXRlKHBhcnNlSW50KHVybC5wb3J0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwb3J0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5wYXRoICE9IG51bGwgJiYgdHlwZW9mIHVybC5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgcGF0aFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgcGF0aG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhvc3RuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9yaWdpblwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghL15odHRwcz86Ly50ZXN0KHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByb3RvY29sXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbCA/IHVybC5wb3J0IDogdXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gNDQzIDogODA7XG4gICAgICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGwgPyB1cmwub3JpZ2luIDogYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdG5hbWV9OiR7cG9ydH1gO1xuICAgICAgICBsZXQgcGF0aDcgPSB1cmwucGF0aCAhPSBudWxsID8gdXJsLnBhdGggOiBgJHt1cmwucGF0aG5hbWUgfHwgXCJcIn0ke3VybC5zZWFyY2ggfHwgXCJcIn1gO1xuICAgICAgICBpZiAob3JpZ2luLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgIG9yaWdpbiA9IG9yaWdpbi5zdWJzdHJpbmcoMCwgb3JpZ2luLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoNyAmJiAhcGF0aDcuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICBwYXRoNyA9IGAvJHtwYXRoN31gO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IG5ldyBVUkwob3JpZ2luICsgcGF0aDcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlVVJMLCBcInBhcnNlVVJMXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlT3JpZ2luKHVybCkge1xuICAgICAgdXJsID0gcGFyc2VVUkwodXJsKTtcbiAgICAgIGlmICh1cmwucGF0aG5hbWUgIT09IFwiL1wiIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCB1cmxcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VPcmlnaW4sIFwicGFyc2VPcmlnaW5cIik7XG4gICAgZnVuY3Rpb24gZ2V0SG9zdG5hbWUoaG9zdCkge1xuICAgICAgaWYgKGhvc3RbMF0gPT09IFwiW1wiKSB7XG4gICAgICAgIGNvbnN0IGlkeDIgPSBob3N0LmluZGV4T2YoXCJdXCIpO1xuICAgICAgICBhc3NlcnQoaWR4MiAhPT0gLTEpO1xuICAgICAgICByZXR1cm4gaG9zdC5zdWJzdHIoMSwgaWR4MiAtIDEpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKFwiOlwiKTtcbiAgICAgIGlmIChpZHggPT09IC0xKVxuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICAgIHJldHVybiBob3N0LnN1YnN0cigwLCBpZHgpO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0SG9zdG5hbWUsIFwiZ2V0SG9zdG5hbWVcIik7XG4gICAgZnVuY3Rpb24gZ2V0U2VydmVyTmFtZShob3N0KSB7XG4gICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGhvc3QsIFwic3RyaW5nXCIpO1xuICAgICAgY29uc3Qgc2VydmVybmFtZSA9IGdldEhvc3RuYW1lKGhvc3QpO1xuICAgICAgaWYgKG5ldDIuaXNJUChzZXJ2ZXJuYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJ2ZXJuYW1lO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0U2VydmVyTmFtZSwgXCJnZXRTZXJ2ZXJOYW1lXCIpO1xuICAgIGZ1bmN0aW9uIGRlZXBDbG9uZTIob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gICAgX19uYW1lKGRlZXBDbG9uZTIsIFwiZGVlcENsb25lXCIpO1xuICAgIGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgX19uYW1lKGlzQXN5bmNJdGVyYWJsZSwgXCJpc0FzeW5jSXRlcmFibGVcIik7XG4gICAgZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIikpO1xuICAgIH1cbiAgICBfX25hbWUoaXNJdGVyYWJsZSwgXCJpc0l0ZXJhYmxlXCIpO1xuICAgIGZ1bmN0aW9uIGJvZHlMZW5ndGgoYm9keSkge1xuICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUuZW5kZWQgPT09IHRydWUgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXRlLmxlbmd0aCkgPyBzdGF0ZS5sZW5ndGggOiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKGJvZHlMZW5ndGgsIFwiYm9keUxlbmd0aFwiKTtcbiAgICBmdW5jdGlvbiBpc0Rlc3Ryb3llZChzdHJlYW0zKSB7XG4gICAgICByZXR1cm4gIXN0cmVhbTMgfHwgISEoc3RyZWFtMy5kZXN0cm95ZWQgfHwgc3RyZWFtM1trRGVzdHJveWVkXSk7XG4gICAgfVxuICAgIF9fbmFtZShpc0Rlc3Ryb3llZCwgXCJpc0Rlc3Ryb3llZFwiKTtcbiAgICBmdW5jdGlvbiBpc1JlYWRhYmxlQWJvcnRlZChzdHJlYW0zKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbTMgJiYgc3RyZWFtMy5fcmVhZGFibGVTdGF0ZTtcbiAgICAgIHJldHVybiBpc0Rlc3Ryb3llZChzdHJlYW0zKSAmJiBzdGF0ZSAmJiAhc3RhdGUuZW5kRW1pdHRlZDtcbiAgICB9XG4gICAgX19uYW1lKGlzUmVhZGFibGVBYm9ydGVkLCBcImlzUmVhZGFibGVBYm9ydGVkXCIpO1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3koc3RyZWFtMywgZXJyKSB7XG4gICAgICBpZiAoIWlzU3RyZWFtKHN0cmVhbTMpIHx8IGlzRGVzdHJveWVkKHN0cmVhbTMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtMy5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzdHJlYW0zKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgICAgc3RyZWFtMy5zb2NrZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbTMuZGVzdHJveShlcnIpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoc3RyZWFtNCwgZXJyMikgPT4ge1xuICAgICAgICAgIHN0cmVhbTQuZW1pdChcImVycm9yXCIsIGVycjIpO1xuICAgICAgICB9LCBzdHJlYW0zLCBlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbTMuZGVzdHJveWVkICE9PSB0cnVlKSB7XG4gICAgICAgIHN0cmVhbTNba0Rlc3Ryb3llZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZGVzdHJveSwgXCJkZXN0cm95XCIpO1xuICAgIHZhciBLRUVQQUxJVkVfVElNRU9VVF9FWFBSID0gL3RpbWVvdXQ9KFxcZCspLztcbiAgICBmdW5jdGlvbiBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQodmFsKSB7XG4gICAgICBjb25zdCBtID0gdmFsLnRvU3RyaW5nKCkubWF0Y2goS0VFUEFMSVZFX1RJTUVPVVRfRVhQUik7XG4gICAgICByZXR1cm4gbSA/IHBhcnNlSW50KG1bMV0sIDEwKSAqIDFlMyA6IG51bGw7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZUtlZXBBbGl2ZVRpbWVvdXQsIFwicGFyc2VLZWVwQWxpdmVUaW1lb3V0XCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzLCBvYmogPSB7fSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgdmFsID0gb2JqW2tleV07XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc1tpICsgMV0pKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNbaSArIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWwucHVzaChoZWFkZXJzW2kgKyAxXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlSGVhZGVycywgXCJwYXJzZUhlYWRlcnNcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzLm1hcCgoaGVhZGVyKSA9PiBoZWFkZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZVJhd0hlYWRlcnMsIFwicGFyc2VSYXdIZWFkZXJzXCIpO1xuICAgIGZ1bmN0aW9uIGlzQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuICAgIF9fbmFtZShpc0J1ZmZlciwgXCJpc0J1ZmZlclwiKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKSB7XG4gICAgICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbm5lY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uQ29ubmVjdCBtZXRob2RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25FcnJvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25FcnJvciBtZXRob2RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gXCJmdW5jdGlvblwiICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25Cb2R5U2VudCBtZXRob2RcIik7XG4gICAgICB9XG4gICAgICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vblVwZ3JhZGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25VcGdyYWRlIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGVhZGVycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkhlYWRlcnMgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkRhdGEgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25EYXRhIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25Db21wbGV0ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkNvbXBsZXRlIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodmFsaWRhdGVIYW5kbGVyLCBcInZhbGlkYXRlSGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiBpc0Rpc3R1cmJlZChib2R5KSB7XG4gICAgICByZXR1cm4gISEoYm9keSAmJiAoc3RyZWFtMi5pc0Rpc3R1cmJlZCA/IHN0cmVhbTIuaXNEaXN0dXJiZWQoYm9keSkgfHwgYm9keVtrQm9keVVzZWRdIDogYm9keVtrQm9keVVzZWRdIHx8IGJvZHkucmVhZGFibGVEaWRSZWFkIHx8IGJvZHkuX3JlYWRhYmxlU3RhdGUgJiYgYm9keS5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCB8fCBpc1JlYWRhYmxlQWJvcnRlZChib2R5KSkpO1xuICAgIH1cbiAgICBfX25hbWUoaXNEaXN0dXJiZWQsIFwiaXNEaXN0dXJiZWRcIik7XG4gICAgZnVuY3Rpb24gaXNFcnJvcmVkKGJvZHkpIHtcbiAgICAgIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0yLmlzRXJyb3JlZCA/IHN0cmVhbTIuaXNFcnJvcmVkKGJvZHkpIDogL3N0YXRlOiAnZXJyb3JlZCcvLnRlc3QoXG4gICAgICAgIG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKTtcbiAgICB9XG4gICAgX19uYW1lKGlzRXJyb3JlZCwgXCJpc0Vycm9yZWRcIik7XG4gICAgZnVuY3Rpb24gaXNSZWFkYWJsZShib2R5KSB7XG4gICAgICByZXR1cm4gISEoYm9keSAmJiAoc3RyZWFtMi5pc1JlYWRhYmxlID8gc3RyZWFtMi5pc1JlYWRhYmxlKGJvZHkpIDogL3N0YXRlOiAncmVhZGFibGUnLy50ZXN0KFxuICAgICAgICBub2RlVXRpbC5pbnNwZWN0KGJvZHkpXG4gICAgICApKSk7XG4gICAgfVxuICAgIF9fbmFtZShpc1JlYWRhYmxlLCBcImlzUmVhZGFibGVcIik7XG4gICAgZnVuY3Rpb24gZ2V0U29ja2V0SW5mbyhzb2NrZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsQWRkcmVzczogc29ja2V0LmxvY2FsQWRkcmVzcyxcbiAgICAgICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgICAgICByZW1vdGVBZGRyZXNzOiBzb2NrZXQucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgcmVtb3RlUG9ydDogc29ja2V0LnJlbW90ZVBvcnQsXG4gICAgICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICAgICAgdGltZW91dDogc29ja2V0LnRpbWVvdXQsXG4gICAgICAgIGJ5dGVzV3JpdHRlbjogc29ja2V0LmJ5dGVzV3JpdHRlbixcbiAgICAgICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoZ2V0U29ja2V0SW5mbywgXCJnZXRTb2NrZXRJbmZvXCIpO1xuICAgIHZhciBSZWFkYWJsZVN0cmVhbTtcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20oaXRlcmFibGUpIHtcbiAgICAgIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKS5SZWFkYWJsZVN0cmVhbTtcbiAgICAgIH1cbiAgICAgIGlmIChSZWFkYWJsZVN0cmVhbS5mcm9tKSB7XG4gICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbS5mcm9tKGl0ZXJhYmxlKTtcbiAgICAgIH1cbiAgICAgIGxldCBpdGVyYXRvcjtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgIHtcbiAgICAgICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5kZXNpcmVkU2l6ZSA+IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuICAgIF9fbmFtZShSZWFkYWJsZVN0cmVhbUZyb20sIFwiUmVhZGFibGVTdHJlYW1Gcm9tXCIpO1xuICAgIGZ1bmN0aW9uIGlzRm9ybURhdGFMaWtlKGNodW5rKSB7XG4gICAgICByZXR1cm4gY2h1bmsgJiYgY2h1bmsuY29uc3RydWN0b3IgJiYgY2h1bmsuY29uc3RydWN0b3IubmFtZSA9PT0gXCJGb3JtRGF0YVwiO1xuICAgIH1cbiAgICBfX25hbWUoaXNGb3JtRGF0YUxpa2UsIFwiaXNGb3JtRGF0YUxpa2VcIik7XG4gICAgdmFyIGtFbnVtZXJhYmxlUHJvcGVydHkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBrRW51bWVyYWJsZVByb3BlcnR5LmVudW1lcmFibGUgPSB0cnVlO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBub3AsXG4gICAgICBpc0Rpc3R1cmJlZCxcbiAgICAgIGlzRXJyb3JlZCxcbiAgICAgIGlzUmVhZGFibGUsXG4gICAgICB0b1VTVlN0cmluZzogbm9kZVV0aWwudG9VU1ZTdHJpbmcgfHwgKCh2YWwpID0+IGAke3ZhbH1gKSxcbiAgICAgIGlzUmVhZGFibGVBYm9ydGVkLFxuICAgICAgaXNCbG9iTGlrZSxcbiAgICAgIHBhcnNlT3JpZ2luLFxuICAgICAgcGFyc2VVUkwsXG4gICAgICBnZXRTZXJ2ZXJOYW1lLFxuICAgICAgaXNTdHJlYW0sXG4gICAgICBpc0l0ZXJhYmxlLFxuICAgICAgaXNBc3luY0l0ZXJhYmxlLFxuICAgICAgaXNEZXN0cm95ZWQsXG4gICAgICBwYXJzZVJhd0hlYWRlcnMsXG4gICAgICBwYXJzZUhlYWRlcnMsXG4gICAgICBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICBkZXN0cm95LFxuICAgICAgYm9keUxlbmd0aCxcbiAgICAgIGRlZXBDbG9uZTogZGVlcENsb25lMixcbiAgICAgIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgICAgIGlzQnVmZmVyLFxuICAgICAgdmFsaWRhdGVIYW5kbGVyLFxuICAgICAgZ2V0U29ja2V0SW5mbyxcbiAgICAgIGlzRm9ybURhdGFMaWtlLFxuICAgICAgYnVpbGRVUkxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvY29uc3RhbnRzLmpzXG52YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9jb25zdGFudHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyA9IFtcIkdFVFwiLCBcIkhFQURcIiwgXCJQT1NUXCJdO1xuICAgIHZhciBudWxsQm9keVN0YXR1cyA9IFsxMDEsIDIwNCwgMjA1LCAzMDRdO1xuICAgIHZhciByZWRpcmVjdFN0YXR1cyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG4gICAgdmFyIHJlZmVycmVyUG9saWN5ID0gW1xuICAgICAgXCJcIixcbiAgICAgIFwibm8tcmVmZXJyZXJcIixcbiAgICAgIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIixcbiAgICAgIFwic2FtZS1vcmlnaW5cIixcbiAgICAgIFwib3JpZ2luXCIsXG4gICAgICBcInN0cmljdC1vcmlnaW5cIixcbiAgICAgIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICBcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcbiAgICAgIFwidW5zYWZlLXVybFwiXG4gICAgXTtcbiAgICB2YXIgcmVxdWVzdFJlZGlyZWN0ID0gW1wiZm9sbG93XCIsIFwibWFudWFsXCIsIFwiZXJyb3JcIl07XG4gICAgdmFyIHNhZmVNZXRob2RzID0gW1wiR0VUXCIsIFwiSEVBRFwiLCBcIk9QVElPTlNcIiwgXCJUUkFDRVwiXTtcbiAgICB2YXIgcmVxdWVzdE1vZGUgPSBbXCJuYXZpZ2F0ZVwiLCBcInNhbWUtb3JpZ2luXCIsIFwibm8tY29yc1wiLCBcImNvcnNcIl07XG4gICAgdmFyIHJlcXVlc3RDcmVkZW50aWFscyA9IFtcIm9taXRcIiwgXCJzYW1lLW9yaWdpblwiLCBcImluY2x1ZGVcIl07XG4gICAgdmFyIHJlcXVlc3RDYWNoZSA9IFtcbiAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgXCJuby1zdG9yZVwiLFxuICAgICAgXCJyZWxvYWRcIixcbiAgICAgIFwibm8tY2FjaGVcIixcbiAgICAgIFwiZm9yY2UtY2FjaGVcIixcbiAgICAgIFwib25seS1pZi1jYWNoZWRcIlxuICAgIF07XG4gICAgdmFyIHJlcXVlc3RCb2R5SGVhZGVyID0gW1xuICAgICAgXCJjb250ZW50LWVuY29kaW5nXCIsXG4gICAgICBcImNvbnRlbnQtbGFuZ3VhZ2VcIixcbiAgICAgIFwiY29udGVudC1sb2NhdGlvblwiLFxuICAgICAgXCJjb250ZW50LXR5cGVcIlxuICAgIF07XG4gICAgdmFyIGZvcmJpZGRlbk1ldGhvZHMgPSBbXCJDT05ORUNUXCIsIFwiVFJBQ0VcIiwgXCJUUkFDS1wiXTtcbiAgICB2YXIgc3VicmVzb3VyY2UgPSBbXG4gICAgICBcImF1ZGlvXCIsXG4gICAgICBcImF1ZGlvd29ya2xldFwiLFxuICAgICAgXCJmb250XCIsXG4gICAgICBcImltYWdlXCIsXG4gICAgICBcIm1hbmlmZXN0XCIsXG4gICAgICBcInBhaW50d29ya2xldFwiLFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIFwic3R5bGVcIixcbiAgICAgIFwidHJhY2tcIixcbiAgICAgIFwidmlkZW9cIixcbiAgICAgIFwieHNsdFwiLFxuICAgICAgXCJcIlxuICAgIF07XG4gICAgdmFyIF9hMztcbiAgICB2YXIgRE9NRXhjZXB0aW9uID0gKF9hMyA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uKSAhPSBudWxsID8gX2EzIDogKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF0b2IoXCJ+XCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKS5jb25zdHJ1Y3RvcjtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIERPTUV4Y2VwdGlvbixcbiAgICAgIHN1YnJlc291cmNlLFxuICAgICAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgICAgIHJlcXVlc3RCb2R5SGVhZGVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3ksXG4gICAgICByZXF1ZXN0UmVkaXJlY3QsXG4gICAgICByZXF1ZXN0TW9kZSxcbiAgICAgIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgICAgIHJlcXVlc3RDYWNoZSxcbiAgICAgIHJlZGlyZWN0U3RhdHVzLFxuICAgICAgY29yc1NhZmVMaXN0ZWRNZXRob2RzLFxuICAgICAgbnVsbEJvZHlTdGF0dXMsXG4gICAgICBzYWZlTWV0aG9kc1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9zeW1ib2xzLmpzXG52YXIgcmVxdWlyZV9zeW1ib2xzMiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3N5bWJvbHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAga1VybDogU3ltYm9sKFwidXJsXCIpLFxuICAgICAga0hlYWRlcnM6IFN5bWJvbChcImhlYWRlcnNcIiksXG4gICAgICBrU2lnbmFsOiBTeW1ib2woXCJzaWduYWxcIiksXG4gICAgICBrU3RhdGU6IFN5bWJvbChcInN0YXRlXCIpLFxuICAgICAga0d1YXJkOiBTeW1ib2woXCJndWFyZFwiKSxcbiAgICAgIGtSZWFsbTogU3ltYm9sKFwicmVhbG1cIilcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvd2ViaWRsLmpzXG52YXIgcmVxdWlyZV93ZWJpZGwgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgdHlwZXMgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciB7IGhhc093biwgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIgd2ViaWRsID0ge307XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMgPSB7fTtcbiAgICB3ZWJpZGwudXRpbCA9IHt9O1xuICAgIHdlYmlkbC5lcnJvcnMgPSB7fTtcbiAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCA9IGZ1bmN0aW9uKGNvbnRleHQzKSB7XG4gICAgICBjb25zdCBwbHVyYWwgPSBjb250ZXh0My50eXBlcy5sZW5ndGggPT09IDEgPyBcIlwiIDogXCIgb25lIG9mXCI7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYCR7Y29udGV4dDMuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8ke3BsdXJhbH06ICR7Y29udGV4dDMudHlwZXMuam9pbihcIiwgXCIpfS5gO1xuICAgICAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBjb250ZXh0My5wcmVmaXgsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQgPSBmdW5jdGlvbihjb250ZXh0Mykge1xuICAgICAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBjb250ZXh0My5wcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dDMudmFsdWV9XCIgaXMgYW4gaW52YWxpZCAke2NvbnRleHQzLnR5cGV9LmBcbiAgICAgIH0pO1xuICAgIH07XG4gICAgd2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiBcIlVuZGVmaW5lZFwiO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHJldHVybiBcIkJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBcIlN0cmluZ1wiO1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuIFwiU3ltYm9sXCI7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gXCJOdW1iZXJcIjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIHJldHVybiBcIkJpZ0ludFwiO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludCA9IGZ1bmN0aW9uKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cyA9IHt9KSB7XG4gICAgICBsZXQgdXBwZXJCb3VuZDtcbiAgICAgIGxldCBsb3dlckJvdW5kO1xuICAgICAgaWYgKGJpdExlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gICAgICAgIGlmIChzaWduZWRuZXNzID09PSBcInVuc2lnbmVkXCIpIHtcbiAgICAgICAgICBsb3dlckJvdW5kID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIDUzKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2lnbmVkbmVzcyA9PT0gXCJ1bnNpZ25lZFwiKSB7XG4gICAgICAgIGxvd2VyQm91bmQgPSAwO1xuICAgICAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIGJpdExlbmd0aCkgLSAxO1xuICAgICAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSkgLSAxO1xuICAgICAgfVxuICAgICAgbGV0IHggPSBOdW1iZXIoVik7XG4gICAgICBpZiAoT2JqZWN0LmlzKC0wLCB4KSkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLmVuZm9yY2VSYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8IHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IFwiSW50ZWdlciBjb252ZXJzaW9uXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGNvbnZlcnQgJHtWfSB0byBhbiBpbnRlZ2VyLmBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeCk7XG4gICAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJJbnRlZ2VyIGNvbnZlcnNpb25cIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gJHtsb3dlckJvdW5kfS0ke3VwcGVyQm91bmR9LCBnb3QgJHt4fS5gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBpZiAoIU51bWJlci5pc05hTih4KSAmJiBvcHRzLmNsYW1wID09PSB0cnVlKSB7XG4gICAgICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHgpICUgMiA9PT0gMCkge1xuICAgICAgICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBNYXRoLmNlaWwoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8IE9iamVjdC5pcygwLCB4KSB8fCB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpO1xuICAgICAgeCA9IHggJSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpO1xuICAgICAgaWYgKHNpZ25lZG5lc3MgPT09IFwic2lnbmVkXCIgJiYgeCA+PSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMSkge1xuICAgICAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIHdlYmlkbC51dGlsLkludGVnZXJQYXJ0ID0gZnVuY3Rpb24obikge1xuICAgICAgY29uc3QgciA9IE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHJldHVybiAtMSAqIHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlciA9IGZ1bmN0aW9uKGNvbnZlcnRlcikge1xuICAgICAgcmV0dXJuIChWKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBcIk9iamVjdFwiKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlNlcXVlbmNlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVmFsdWUgb2YgdHlwZSAke3dlYmlkbC51dGlsLlR5cGUoVil9IGlzIG5vdCBhbiBPYmplY3QuYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IChfYTMgPSBWID09IG51bGwgPyB2b2lkIDAgOiBWW1N5bWJvbC5pdGVyYXRvcl0pID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChWKTtcbiAgICAgICAgY29uc3Qgc2VxID0gW107XG4gICAgICAgIGlmIChtZXRob2QgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWV0aG9kLm5leHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJTZXF1ZW5jZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJPYmplY3QgaXMgbm90IGFuIGl0ZXJhdG9yLlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBtZXRob2QubmV4dCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VxLnB1c2goY29udmVydGVyKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB3ZWJpZGwucmVjb3JkQ29udmVydGVyID0gZnVuY3Rpb24oa2V5Q29udmVydGVyLCB2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgcmV0dXJuIChWKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHt9O1xuICAgICAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShWKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiVW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJOdWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSBcIk9iamVjdFwiKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlJlY29yZFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7Vn0gdG8gYmUgYW4gT2JqZWN0IHR5cGUuYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhWKSkge1xuICAgICAgICAgIGtleSA9IGtleUNvbnZlcnRlcihrZXkpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVDb252ZXJ0ZXIodmFsdWUpO1xuICAgICAgICAgIHJlY29yZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgIH07XG4gICAgfTtcbiAgICB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyID0gZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIChWLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBpKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogaS5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7Vn0gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJHtpLm5hbWV9LmBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVjtcbiAgICAgIH07XG4gICAgfTtcbiAgICB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uKGNvbnZlcnRlcnMpIHtcbiAgICAgIHJldHVybiAoZGljdGlvbmFyeSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShkaWN0aW9uYXJ5KTtcbiAgICAgICAgY29uc3QgZGljdCA9IHt9O1xuICAgICAgICBpZiAodHlwZSAhPT0gXCJOdWxsXCIgJiYgdHlwZSAhPT0gXCJVbmRlZmluZWRcIiAmJiB0eXBlICE9PSBcIk9iamVjdFwiKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIkRpY3Rpb25hcnlcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb252ZXJ0ZXJzKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9ucztcbiAgICAgICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duKGRpY3Rpb25hcnksIGtleSkpIHtcbiAgICAgICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICAgIGhlYWRlcjogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQga2V5IFwiJHtrZXl9XCIuYFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHZhbHVlID0gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0aW9ucywgXCJkZWZhdWx0VmFsdWVcIik7XG4gICAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd2VkVmFsdWVzICYmICFvcHRpb25zLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oXCIsIFwiKX0uYFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGljdDtcbiAgICAgIH07XG4gICAgfTtcbiAgICB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIgPSBmdW5jdGlvbihjb252ZXJ0ZXIpIHtcbiAgICAgIHJldHVybiAoVikgPT4ge1xuICAgICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIoVik7XG4gICAgICB9O1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nID0gZnVuY3Rpb24oViwgb3B0cyA9IHt9KSB7XG4gICAgICBpZiAoViA9PT0gbnVsbCAmJiBvcHRzLmxlZ2FjeU51bGxUb0VtcHR5U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBWID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIHN5bWJvbCB0byBzdHJpbmcuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZyhWKTtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbihWKSB7XG4gICAgICBjb25zdCB4ID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0geC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29udmVydCBhcmd1bWVudCB0byBhIEJ5dGVTdHJpbmcgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGF0aW5kZXggJHtpbmRleH0gaGFzIGEgdmFsdWUgb2YgJHtjaGFyQ29kZX0gd2hpY2ggaXMgZ3JlYXRlciB0aGFuIDI1NS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcgPSB0b1VTVlN0cmluZztcbiAgICB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuID0gZnVuY3Rpb24oVikge1xuICAgICAgY29uc3QgeCA9IEJvb2xlYW4oVik7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLmFueSA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIHJldHVybiBWO1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJsb25nIGxvbmdcIl0gPSBmdW5jdGlvbihWLCBvcHRzKSB7XG4gICAgICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCBcInNpZ25lZFwiLCBvcHRzKTtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJ1bnNpZ25lZCBzaG9ydFwiXSA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMTYsIFwidW5zaWduZWRcIik7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24oViwgb3B0cyA9IHt9KSB7XG4gICAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gXCJPYmplY3RcIiB8fCAhdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSkge1xuICAgICAgICB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICAgIHByZWZpeDogYCR7Vn1gLFxuICAgICAgICAgIGFyZ3VtZW50OiBgJHtWfWAsXG4gICAgICAgICAgdHlwZXM6IFtcIkFycmF5QnVmZmVyXCJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVikpIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogXCJBcnJheUJ1ZmZlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVjtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkgPSBmdW5jdGlvbihWLCBULCBvcHRzID0ge30pIHtcbiAgICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBcIk9iamVjdFwiIHx8ICF0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHwgVi5jb25zdHJ1Y3Rvci5uYW1lICE9PSBULm5hbWUpIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgICBwcmVmaXg6IGAke1QubmFtZX1gLFxuICAgICAgICAgIGFyZ3VtZW50OiBgJHtWfWAsXG4gICAgICAgICAgdHlwZXM6IFtULm5hbWVdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IFwiQXJyYXlCdWZmZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIlNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFY7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyA9IGZ1bmN0aW9uKFYsIG9wdHMgPSB7fSkge1xuICAgICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09IFwiT2JqZWN0XCIgfHwgIXR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogXCJEYXRhVmlld1wiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiT2JqZWN0IGlzIG5vdCBhIERhdGFWaWV3LlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IFwiQXJyYXlCdWZmZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIlNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFY7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbihWLCBvcHRzID0ge30pIHtcbiAgICAgIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlcihWLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5pc1R5cGVkQXJyYXkoVikpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkoViwgVi5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcoViwgb3B0cyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGEgQnVmZmVyU291cmNlLmApO1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCeXRlU3RyaW5nPlwiXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbiAgICApO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XCJdID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCeXRlU3RyaW5nPlwiXVxuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cIl0gPSB3ZWJpZGwucmVjb3JkQ29udmVydGVyKFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbiAgICApO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHdlYmlkbFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzXG52YXIgcmVxdWlyZV9maWxlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZmlsZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBCbG9iIH0gPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuICAgIHZhciB7IHR5cGVzIH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICB2YXIgeyBrU3RhdGUgfSA9IHJlcXVpcmVfc3ltYm9sczIoKTtcbiAgICB2YXIgeyBpc0Jsb2JMaWtlIH0gPSByZXF1aXJlX3V0aWwzKCk7XG4gICAgdmFyIHsgd2ViaWRsIH0gPSByZXF1aXJlX3dlYmlkbCgpO1xuICAgIHZhciBGaWxlID0gY2xhc3MgZXh0ZW5kcyBCbG9iIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIyIGFyZ3VtZW50cyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlQml0cyA9IHdlYmlkbC5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8QmxvYlBhcnQ+XCJdKGZpbGVCaXRzKTtcbiAgICAgICAgZmlsZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZU5hbWUpO1xuICAgICAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuRmlsZVByb3BlcnR5QmFnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBuID0gZmlsZU5hbWU7XG4gICAgICAgIGNvbnN0IGQgPSBvcHRpb25zLmxhc3RNb2RpZmllZDtcbiAgICAgICAgc3VwZXIocHJvY2Vzc0Jsb2JQYXJ0cyhmaWxlQml0cywgb3B0aW9ucyksIHsgdHlwZTogb3B0aW9ucy50eXBlIH0pO1xuICAgICAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICAgICAgbmFtZTogbixcbiAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZTtcbiAgICAgIH1cbiAgICAgIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sYXN0TW9kaWZpZWQ7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoRmlsZSwgXCJGaWxlXCIpO1xuICAgIHZhciBGaWxlTGlrZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGJsb2JMaWtlLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGNvbnN0IG4gPSBmaWxlTmFtZTtcbiAgICAgICAgY29uc3QgdCA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgY29uc3QgZCA9IChfYTMgPSBvcHRpb25zLmxhc3RNb2RpZmllZCkgIT0gbnVsbCA/IF9hMyA6IERhdGUubm93KCk7XG4gICAgICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgICAgICBibG9iTGlrZSxcbiAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgIHR5cGU6IHQsXG4gICAgICAgICAgbGFzdE1vZGlmaWVkOiBkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdHJlYW0oLi4uYXJncykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnN0cmVhbSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGFycmF5QnVmZmVyKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpbGVMaWtlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIHNsaWNlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpbGVMaWtlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zbGljZSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIHRleHQoLi4uYXJncykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnRleHQoLi4uYXJncyk7XG4gICAgICB9XG4gICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpbGVMaWtlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zaXplO1xuICAgICAgfVxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlTGlrZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudHlwZTtcbiAgICAgIH1cbiAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLm5hbWU7XG4gICAgICB9XG4gICAgICBnZXQgbGFzdE1vZGlmaWVkKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZDtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRmlsZVwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEZpbGVMaWtlLCBcIkZpbGVMaWtlXCIpO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKEJsb2IpO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2JQYXJ0ID0gZnVuY3Rpb24oViwgb3B0cykge1xuICAgICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWLCBvcHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgb3B0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVyc1tcInNlcXVlbmNlPEJsb2JQYXJ0PlwiXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2JQYXJ0XG4gICAgKTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5GaWxlUHJvcGVydHlCYWcgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gICAgICB7XG4gICAgICAgIGtleTogXCJsYXN0TW9kaWZpZWRcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1tcImxvbmcgbG9uZ1wiXSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcInR5cGVcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImVuZGluZ3NcIixcbiAgICAgICAgY29udmVydGVyOiAodmFsdWUpID0+IHtcbiAgICAgICAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJuYXRpdmVcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcInRyYW5zcGFyZW50XCJcbiAgICAgIH1cbiAgICBdKTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzQmxvYlBhcnRzKHBhcnRzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcnRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGxldCBzID0gZWxlbWVudDtcbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmRpbmdzID09PSBcIm5hdGl2ZVwiKSB7XG4gICAgICAgICAgICBzID0gY29udmVydExpbmVFbmRpbmdzTmF0aXZlKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBieXRlcy5wdXNoKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihlbGVtZW50KSB8fCB0eXBlcy5pc1R5cGVkQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuYnVmZmVyKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKG5ldyBVaW50OEFycmF5KGVsZW1lbnQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5idWZmZXIsIGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShlbGVtZW50KSkge1xuICAgICAgICAgIGJ5dGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgX19uYW1lKHByb2Nlc3NCbG9iUGFydHMsIFwicHJvY2Vzc0Jsb2JQYXJ0c1wiKTtcbiAgICBmdW5jdGlvbiBjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUocykge1xuICAgICAgbGV0IG5hdGl2ZUxpbmVFbmRpbmcgPSBcIlxcblwiO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICBuYXRpdmVMaW5lRW5kaW5nID0gXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xccj9cXG4vZywgbmF0aXZlTGluZUVuZGluZyk7XG4gICAgfVxuICAgIF9fbmFtZShjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUsIFwiY29udmVydExpbmVFbmRpbmdzTmF0aXZlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsgRmlsZSwgRmlsZUxpa2UgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3V0aWwuanNcbnZhciByZXF1aXJlX3V0aWwzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyByZWRpcmVjdFN0YXR1cyB9ID0gcmVxdWlyZV9jb25zdGFudHMoKTtcbiAgICB2YXIgeyBwZXJmb3JtYW5jZTogcGVyZm9ybWFuY2UzIH0gPSByZXF1aXJlKFwicGVyZl9ob29rc1wiKTtcbiAgICB2YXIgeyBpc0Jsb2JMaWtlLCB0b1VTVlN0cmluZywgUmVhZGFibGVTdHJlYW1Gcm9tIH0gPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsgaXNVaW50OEFycmF5IH0gPSByZXF1aXJlKFwidXRpbC90eXBlc1wiKTtcbiAgICB2YXIgRmlsZTtcbiAgICB2YXIgY3J5cHRvMjtcbiAgICB0cnkge1xuICAgICAgY3J5cHRvMiA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICB2YXIgYmFkUG9ydHMgPSBbXG4gICAgICBcIjFcIixcbiAgICAgIFwiN1wiLFxuICAgICAgXCI5XCIsXG4gICAgICBcIjExXCIsXG4gICAgICBcIjEzXCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjE3XCIsXG4gICAgICBcIjE5XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjIxXCIsXG4gICAgICBcIjIyXCIsXG4gICAgICBcIjIzXCIsXG4gICAgICBcIjI1XCIsXG4gICAgICBcIjM3XCIsXG4gICAgICBcIjQyXCIsXG4gICAgICBcIjQzXCIsXG4gICAgICBcIjUzXCIsXG4gICAgICBcIjY5XCIsXG4gICAgICBcIjc3XCIsXG4gICAgICBcIjc5XCIsXG4gICAgICBcIjg3XCIsXG4gICAgICBcIjk1XCIsXG4gICAgICBcIjEwMVwiLFxuICAgICAgXCIxMDJcIixcbiAgICAgIFwiMTAzXCIsXG4gICAgICBcIjEwNFwiLFxuICAgICAgXCIxMDlcIixcbiAgICAgIFwiMTEwXCIsXG4gICAgICBcIjExMVwiLFxuICAgICAgXCIxMTNcIixcbiAgICAgIFwiMTE1XCIsXG4gICAgICBcIjExN1wiLFxuICAgICAgXCIxMTlcIixcbiAgICAgIFwiMTIzXCIsXG4gICAgICBcIjEzNVwiLFxuICAgICAgXCIxMzdcIixcbiAgICAgIFwiMTM5XCIsXG4gICAgICBcIjE0M1wiLFxuICAgICAgXCIxNjFcIixcbiAgICAgIFwiMTc5XCIsXG4gICAgICBcIjM4OVwiLFxuICAgICAgXCI0MjdcIixcbiAgICAgIFwiNDY1XCIsXG4gICAgICBcIjUxMlwiLFxuICAgICAgXCI1MTNcIixcbiAgICAgIFwiNTE0XCIsXG4gICAgICBcIjUxNVwiLFxuICAgICAgXCI1MjZcIixcbiAgICAgIFwiNTMwXCIsXG4gICAgICBcIjUzMVwiLFxuICAgICAgXCI1MzJcIixcbiAgICAgIFwiNTQwXCIsXG4gICAgICBcIjU0OFwiLFxuICAgICAgXCI1NTRcIixcbiAgICAgIFwiNTU2XCIsXG4gICAgICBcIjU2M1wiLFxuICAgICAgXCI1ODdcIixcbiAgICAgIFwiNjAxXCIsXG4gICAgICBcIjYzNlwiLFxuICAgICAgXCI5ODlcIixcbiAgICAgIFwiOTkwXCIsXG4gICAgICBcIjk5M1wiLFxuICAgICAgXCI5OTVcIixcbiAgICAgIFwiMTcxOVwiLFxuICAgICAgXCIxNzIwXCIsXG4gICAgICBcIjE3MjNcIixcbiAgICAgIFwiMjA0OVwiLFxuICAgICAgXCIzNjU5XCIsXG4gICAgICBcIjQwNDVcIixcbiAgICAgIFwiNTA2MFwiLFxuICAgICAgXCI1MDYxXCIsXG4gICAgICBcIjYwMDBcIixcbiAgICAgIFwiNjU2NlwiLFxuICAgICAgXCI2NjY1XCIsXG4gICAgICBcIjY2NjZcIixcbiAgICAgIFwiNjY2N1wiLFxuICAgICAgXCI2NjY4XCIsXG4gICAgICBcIjY2NjlcIixcbiAgICAgIFwiNjY5N1wiLFxuICAgICAgXCIxMDA4MFwiXG4gICAgXTtcbiAgICBmdW5jdGlvbiByZXNwb25zZVVSTChyZXNwb25zZSkge1xuICAgICAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3Q7XG4gICAgICBjb25zdCBsZW5ndGggPSB1cmxMaXN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPT09IDAgPyBudWxsIDogdXJsTGlzdFtsZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgIH1cbiAgICBfX25hbWUocmVzcG9uc2VVUkwsIFwicmVzcG9uc2VVUkxcIik7XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VMb2NhdGlvblVSTChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gICAgICBpZiAoIXJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoXCJsb2NhdGlvblwiKTtcbiAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPyBuZXcgVVJMKGxvY2F0aW9uLCByZXNwb25zZVVSTChyZXNwb25zZSkpIDogbnVsbDtcbiAgICAgIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsb2NhdGlvbi5oYXNoID0gcmVxdWVzdEZyYWdtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cbiAgICBfX25hbWUocmVzcG9uc2VMb2NhdGlvblVSTCwgXCJyZXNwb25zZUxvY2F0aW9uVVJMXCIpO1xuICAgIGZ1bmN0aW9uIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdDIudXJsTGlzdFtyZXF1ZXN0Mi51cmxMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBfX25hbWUocmVxdWVzdEN1cnJlbnRVUkwsIFwicmVxdWVzdEN1cnJlbnRVUkxcIik7XG4gICAgZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQocmVxdWVzdDIpIHtcbiAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKTtcbiAgICAgIGlmICgvXmh0dHBzPzovLnRlc3QodXJsLnByb3RvY29sKSAmJiBiYWRQb3J0cy5pbmNsdWRlcyh1cmwucG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIFwiYmxvY2tlZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiYWxsb3dlZFwiO1xuICAgIH1cbiAgICBfX25hbWUocmVxdWVzdEJhZFBvcnQsIFwicmVxdWVzdEJhZFBvcnRcIik7XG4gICAgZnVuY3Rpb24gaXNGaWxlTGlrZShvYmplY3QpIHtcbiAgICAgIGlmICghRmlsZSkge1xuICAgICAgICBGaWxlID0gcmVxdWlyZV9maWxlKCkuRmlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBGaWxlIHx8IG9iamVjdCAmJiAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIpICYmIC9eKEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gICAgfVxuICAgIF9fbmFtZShpc0ZpbGVMaWtlLCBcImlzRmlsZUxpa2VcIik7XG4gICAgZnVuY3Rpb24gaXNFcnJvckxpa2Uob2JqZWN0KSB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgRXJyb3IgfHwgKCgoX2EzID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubmFtZSkgPT09IFwiRXJyb3JcIiB8fCAoKF9iMiA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0LmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm5hbWUpID09PSBcIkRPTUV4Y2VwdGlvblwiKTtcbiAgICB9XG4gICAgX19uYW1lKGlzRXJyb3JMaWtlLCBcImlzRXJyb3JMaWtlXCIpO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2Uoc3RhdHVzVGV4dCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdGF0dXNUZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICghKGMgPT09IDkgfHwgYyA+PSAzMiAmJiBjIDw9IDEyNiB8fCBjID49IDEyOCAmJiBjIDw9IDI1NSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoaXNWYWxpZFJlYXNvblBocmFzZSwgXCJpc1ZhbGlkUmVhc29uUGhyYXNlXCIpO1xuICAgIGZ1bmN0aW9uIGlzVG9rZW5DaGFyKGMpIHtcbiAgICAgIHJldHVybiAhKGMgPj0gMTI3IHx8IGMgPD0gMzIgfHwgYyA9PT0gXCIoXCIgfHwgYyA9PT0gXCIpXCIgfHwgYyA9PT0gXCI8XCIgfHwgYyA9PT0gXCI+XCIgfHwgYyA9PT0gXCJAXCIgfHwgYyA9PT0gXCIsXCIgfHwgYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCI6XCIgfHwgYyA9PT0gXCJcXFxcXCIgfHwgYyA9PT0gJ1wiJyB8fCBjID09PSBcIi9cIiB8fCBjID09PSBcIltcIiB8fCBjID09PSBcIl1cIiB8fCBjID09PSBcIj9cIiB8fCBjID09PSBcIj1cIiB8fCBjID09PSBcIntcIiB8fCBjID09PSBcIn1cIik7XG4gICAgfVxuICAgIF9fbmFtZShpc1Rva2VuQ2hhciwgXCJpc1Rva2VuQ2hhclwiKTtcbiAgICBmdW5jdGlvbiBpc1ZhbGlkSFRUUFRva2VuKGNoYXJhY3RlcnMpIHtcbiAgICAgIGlmICghY2hhcmFjdGVycyB8fCB0eXBlb2YgY2hhcmFjdGVycyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IGNoYXJhY3RlcnMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPiAxMjcgfHwgIWlzVG9rZW5DaGFyKGMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKGlzVmFsaWRIVFRQVG9rZW4sIFwiaXNWYWxpZEhUVFBUb2tlblwiKTtcbiAgICBmdW5jdGlvbiBpc1ZhbGlkSGVhZGVyTmFtZShwb3RlbnRpYWxWYWx1ZSkge1xuICAgICAgaWYgKHBvdGVudGlhbFZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgcG90ZW50aWFsVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKGNoYXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKGlzVmFsaWRIZWFkZXJOYW1lLCBcImlzVmFsaWRIZWFkZXJOYW1lXCIpO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZShwb3RlbnRpYWxWYWx1ZSkge1xuICAgICAgaWYgKHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoXCJcdFwiKSB8fCBwb3RlbnRpYWxWYWx1ZS5zdGFydHNXaXRoKFwiIFwiKSB8fCBwb3RlbnRpYWxWYWx1ZS5lbmRzV2l0aChcIlx0XCIpIHx8IHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKFwiIFwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoXCJcXDBcIikgfHwgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoXCJcXHJcIikgfHwgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9fbmFtZShpc1ZhbGlkSGVhZGVyVmFsdWUsIFwiaXNWYWxpZEhlYWRlclZhbHVlXCIpO1xuICAgIGZ1bmN0aW9uIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QocmVxdWVzdDIsIGFjdHVhbFJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBwb2xpY3kgPSBcIlwiO1xuICAgICAgaWYgKHBvbGljeSAhPT0gXCJcIikge1xuICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSA9IHBvbGljeTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsIFwic2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdFwiKTtcbiAgICBmdW5jdGlvbiBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2soKSB7XG4gICAgICByZXR1cm4gXCJhbGxvd2VkXCI7XG4gICAgfVxuICAgIF9fbmFtZShjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssIFwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrXCIpO1xuICAgIGZ1bmN0aW9uIGNvcnNDaGVjaygpIHtcbiAgICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbiAgICB9XG4gICAgX19uYW1lKGNvcnNDaGVjaywgXCJjb3JzQ2hlY2tcIik7XG4gICAgZnVuY3Rpb24gVEFPQ2hlY2soKSB7XG4gICAgICByZXR1cm4gXCJzdWNjZXNzXCI7XG4gICAgfVxuICAgIF9fbmFtZShUQU9DaGVjaywgXCJUQU9DaGVja1wiKTtcbiAgICBmdW5jdGlvbiBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KSB7XG4gICAgICBsZXQgaGVhZGVyID0gbnVsbDtcbiAgICAgIGhlYWRlciA9IGh0dHBSZXF1ZXN0Lm1vZGU7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5zZXQoXCJzZWMtZmV0Y2gtbW9kZVwiLCBoZWFkZXIpO1xuICAgIH1cbiAgICBfX25hbWUoYXBwZW5kRmV0Y2hNZXRhZGF0YSwgXCJhcHBlbmRGZXRjaE1ldGFkYXRhXCIpO1xuICAgIGZ1bmN0aW9uIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIocmVxdWVzdDIpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkT3JpZ2luID0gcmVxdWVzdDIub3JpZ2luO1xuICAgICAgaWYgKHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiY29yc1wiIHx8IHJlcXVlc3QyLm1vZGUgPT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4pIHtcbiAgICAgICAgICByZXF1ZXN0Mi5oZWFkZXJzTGlzdC5hcHBlbmQoXCJPcmlnaW5cIiwgc2VyaWFsaXplZE9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdDIubWV0aG9kICE9PSBcIkdFVFwiICYmIHJlcXVlc3QyLm1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSkge1xuICAgICAgICAgIGNhc2UgXCJuby1yZWZlcnJlclwiOlxuICAgICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIjpcbiAgICAgICAgICBjYXNlIFwic3RyaWN0LW9yaWdpblwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCI6XG4gICAgICAgICAgICBpZiAoL15odHRwczovLnRlc3QocmVxdWVzdDIub3JpZ2luKSAmJiAhL15odHRwczovLnRlc3QocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpKSkge1xuICAgICAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzYW1lLW9yaWdpblwiOlxuICAgICAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3QyLCByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0MikpKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWFsaXplZE9yaWdpbikge1xuICAgICAgICAgIHJlcXVlc3QyLmhlYWRlcnNMaXN0LmFwcGVuZChcIk9yaWdpblwiLCBzZXJpYWxpemVkT3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciwgXCJhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyXCIpO1xuICAgIGZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2UzLm5vdygpO1xuICAgIH1cbiAgICBfX25hbWUoY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsIFwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWVcIik7XG4gICAgZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh0aW1pbmdJbmZvKSB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRpbWU6IChfYTMgPSB0aW1pbmdJbmZvLnN0YXJ0VGltZSkgIT0gbnVsbCA/IF9hMyA6IDAsXG4gICAgICAgIHJlZGlyZWN0U3RhcnRUaW1lOiAwLFxuICAgICAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgICAgIHBvc3RSZWRpcmVjdFN0YXJ0VGltZTogKF9iMiA9IHRpbWluZ0luZm8uc3RhcnRUaW1lKSAhPSBudWxsID8gX2IyIDogMCxcbiAgICAgICAgZmluYWxTZXJ2aWNlV29ya2VyU3RhcnRUaW1lOiAwLFxuICAgICAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICAgICAgZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZTogMCxcbiAgICAgICAgZW5kVGltZTogMCxcbiAgICAgICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgICAgICBkZWNvZGVkQm9keVNpemU6IDAsXG4gICAgICAgIGZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm86IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLCBcImNyZWF0ZU9wYXF1ZVRpbWluZ0luZm9cIik7XG4gICAgZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lcigpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VQb2xpY3lDb250YWluZXIsIFwibWFrZVBvbGljeUNvbnRhaW5lclwiKTtcbiAgICBmdW5jdGlvbiBjbG9uZVBvbGljeUNvbnRhaW5lcigpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgX19uYW1lKGNsb25lUG9saWN5Q29udGFpbmVyLCBcImNsb25lUG9saWN5Q29udGFpbmVyXCIpO1xuICAgIGZ1bmN0aW9uIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdDIpIHtcbiAgICAgIHJldHVybiBcIm5vLXJlZmVycmVyXCI7XG4gICAgfVxuICAgIF9fbmFtZShkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLCBcImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXJcIik7XG4gICAgZnVuY3Rpb24gYnl0ZXNNYXRjaChieXRlcywgbWV0YWRhdGFMaXN0KSB7XG4gICAgICBpZiAoY3J5cHRvMiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdCk7XG4gICAgICBpZiAocGFyc2VkTWV0YWRhdGEgPT09IFwibm8gbWV0YWRhdGFcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHBhcnNlZE1ldGFkYXRhLnNvcnQoKGMsIGQpID0+IGQuYWxnby5sb2NhbGVDb21wYXJlKGMuYWxnbykpO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IGl0ZW0uYWxnbztcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IGl0ZW0uaGFzaDtcbiAgICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBjcnlwdG8yLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICAgICAgaWYgKGFjdHVhbFZhbHVlID09PSBleHBlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX19uYW1lKGJ5dGVzTWF0Y2gsIFwiYnl0ZXNNYXRjaFwiKTtcbiAgICB2YXIgcGFyc2VIYXNoV2l0aE9wdGlvbnMgPSAvKCg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSg/PGhhc2g+W0EtejAtOSsvXXsxfS4qPXsxLDJ9KSkoICtbXFx4MjEtXFx4N2VdPyk/L2k7XG4gICAgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBsZXQgZW1wdHkyID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEhhc2hlcyA9IGNyeXB0bzIuZ2V0SGFzaGVzKCk7XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1ldGFkYXRhLnNwbGl0KFwiIFwiKSkge1xuICAgICAgICBlbXB0eTIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKTtcbiAgICAgICAgaWYgKHBhcnNlZFRva2VuID09PSBudWxsIHx8IHBhcnNlZFRva2VuLmdyb3VwcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ287XG4gICAgICAgIGlmIChzdXBwb3J0ZWRIYXNoZXMuaW5jbHVkZXMoYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVtcHR5MiA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gXCJubyBtZXRhZGF0YVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlTWV0YWRhdGEsIFwicGFyc2VNZXRhZGF0YVwiKTtcbiAgICBmdW5jdGlvbiB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwocmVxdWVzdDIpIHtcbiAgICB9XG4gICAgX19uYW1lKHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCwgXCJ0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkxcIik7XG4gICAgZnVuY3Rpb24gc2FtZU9yaWdpbihBLCBCKSB7XG4gICAgICBpZiAoQS5wcm90b2NvbCA9PT0gQi5wcm90b2NvbCAmJiBBLmhvc3RuYW1lID09PSBCLmhvc3RuYW1lICYmIEEucG9ydCA9PT0gQi5wb3J0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfX25hbWUoc2FtZU9yaWdpbiwgXCJzYW1lT3JpZ2luXCIpO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpIHtcbiAgICAgIGxldCByZXM7XG4gICAgICBsZXQgcmVqO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVzID0gcmVzb2x2ZTtcbiAgICAgICAgcmVqID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXMsIHJlamVjdDogcmVqIH07XG4gICAgfVxuICAgIF9fbmFtZShjcmVhdGVEZWZlcnJlZFByb21pc2UsIFwiY3JlYXRlRGVmZXJyZWRQcm9taXNlXCIpO1xuICAgIGZ1bmN0aW9uIGlzQWJvcnRlZChmZXRjaFBhcmFtcykge1xuICAgICAgcmV0dXJuIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc3RhdGUgPT09IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBfX25hbWUoaXNBYm9ydGVkLCBcImlzQWJvcnRlZFwiKTtcbiAgICBmdW5jdGlvbiBpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykge1xuICAgICAgcmV0dXJuIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc3RhdGUgPT09IFwiYWJvcnRlZFwiIHx8IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuc3RhdGUgPT09IFwidGVybWluYXRlZFwiO1xuICAgIH1cbiAgICBfX25hbWUoaXNDYW5jZWxsZWQsIFwiaXNDYW5jZWxsZWRcIik7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIC9eKERFTEVURXxHRVR8SEVBRHxPUFRJT05TfFBPU1R8UFVUKSQvaS50ZXN0KG1ldGhvZCkgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IG1ldGhvZDtcbiAgICB9XG4gICAgX19uYW1lKG5vcm1hbGl6ZU1ldGhvZCwgXCJub3JtYWxpemVNZXRob2RcIik7XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKHZhbHVlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydCh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsIFwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nXCIpO1xuICAgIHZhciBlc0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTtcbiAgICBmdW5jdGlvbiBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYCduZXh0JyBjYWxsZWQgb24gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSAke25hbWV9IEl0ZXJhdG9yLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiBgJHtuYW1lfSBJdGVyYXRvcmBcbiAgICAgIH07XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoaSwgZXNJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHt9LCBpKTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VJdGVyYXRvciwgXCJtYWtlSXRlcmF0b3JcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gZnVsbHlSZWFkQm9keShib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBib2R5LnN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KGlzVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBsZW5ndGggKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxmaWxsZWRTdGVwcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGJ5dGVzKSA9PiBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgcHJvY2Vzc0JvZHkoYnl0ZXMpO1xuICAgICAgICB9KSwgXCJmdWxmaWxsZWRTdGVwc1wiKTtcbiAgICAgICAgZnVsZmlsbGVkU3RlcHMoQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHByb2Nlc3NCb2R5RXJyb3IoZXJyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmdWxseVJlYWRCb2R5LCBcImZ1bGx5UmVhZEJvZHlcIik7XG4gICAgdmFyIGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKChkaWN0LCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaWN0LCBrZXkpKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBpc0Fib3J0ZWQsXG4gICAgICBpc0NhbmNlbGxlZCxcbiAgICAgIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgICAgIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgICAgIHRvVVNWU3RyaW5nLFxuICAgICAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICAgICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gICAgICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICAgICAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgICAgIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICAgICAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgICAgIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gICAgICBUQU9DaGVjayxcbiAgICAgIGNvcnNDaGVjayxcbiAgICAgIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgICAgIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gICAgICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICAgICAgaXNWYWxpZEhUVFBUb2tlbixcbiAgICAgIHJlcXVlc3RCYWRQb3J0LFxuICAgICAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gICAgICByZXNwb25zZVVSTCxcbiAgICAgIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gICAgICBpc0Jsb2JMaWtlLFxuICAgICAgaXNGaWxlTGlrZSxcbiAgICAgIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gICAgICBzYW1lT3JpZ2luLFxuICAgICAgbm9ybWFsaXplTWV0aG9kLFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICAgICAgbWFrZUl0ZXJhdG9yLFxuICAgICAgaXNWYWxpZEhlYWRlck5hbWUsXG4gICAgICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gICAgICBoYXNPd24sXG4gICAgICBpc0Vycm9yTGlrZSxcbiAgICAgIGZ1bGx5UmVhZEJvZHksXG4gICAgICBieXRlc01hdGNoXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2Zvcm1kYXRhLmpzXG52YXIgcmVxdWlyZV9mb3JtZGF0YSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2Zvcm1kYXRhLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGlzQmxvYkxpa2UsIGlzRmlsZUxpa2UsIHRvVVNWU3RyaW5nLCBtYWtlSXRlcmF0b3IgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIgeyBrU3RhdGUgfSA9IHJlcXVpcmVfc3ltYm9sczIoKTtcbiAgICB2YXIgeyBGaWxlLCBGaWxlTGlrZSB9ID0gcmVxdWlyZV9maWxlKCk7XG4gICAgdmFyIHsgd2ViaWRsIH0gPSByZXF1aXJlX3dlYmlkbCgpO1xuICAgIHZhciB7IEJsb2IgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgdmFyIF9Gb3JtRGF0YSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZvcm0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGZvcm0gIT0gbnVsbCkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiRm9ybURhdGEgY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiBcIkFyZ3VtZW50IDFcIixcbiAgICAgICAgICAgIHR5cGVzOiBbXCJudWxsXCJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trU3RhdGVdID0gW107XG4gICAgICB9XG4gICAgICBhcHBlbmQobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSkgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpO1xuICAgICAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgICBkZWxldGUobmFtZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZGVsZXRlJyBvbiAnRm9ybURhdGEnOiAxIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzW2tTdGF0ZV0pIHtcbiAgICAgICAgICBpZiAoZW50cnkubmFtZSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgbmV4dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trU3RhdGVdID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGdldChuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdnZXQnIG9uICdGb3JtRGF0YSc6IDEgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV1baWR4XS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGdldEFsbChuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdnZXRBbGwnIG9uICdGb3JtRGF0YSc6IDEgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBoYXMobmFtZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnaGFzJyBvbiAnRm9ybURhdGEnOiAxIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSkgIT09IC0xO1xuICAgICAgfVxuICAgICAgc2V0KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSA9IHZvaWQgMCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnc2V0JyBvbiAnRm9ybURhdGEnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmICFpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdzZXQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpID8gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gdG9VU1ZTdHJpbmcoZmlsZW5hbWUpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeTIpID0+IGVudHJ5Mi5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzW2tTdGF0ZV0gPSBbXG4gICAgICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkyKSA9PiBlbnRyeTIubmFtZSAhPT0gbmFtZSlcbiAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgICAgZW50cmllcygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAgICAgbWFrZUl0ZXJhYmxlKHRoaXNba1N0YXRlXSwgXCJlbnRyaWVzXCIpLFxuICAgICAgICAgIFwiRm9ybURhdGFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAga2V5cygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAgICAgbWFrZUl0ZXJhYmxlKHRoaXNba1N0YXRlXSwgXCJrZXlzXCIpLFxuICAgICAgICAgIFwiRm9ybURhdGFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFsdWVzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICAgICBtYWtlSXRlcmFibGUodGhpc1trU3RhdGVdLCBcInZhbHVlc1wiKSxcbiAgICAgICAgICBcIkZvcm1EYXRhXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2goY2FsbGJhY2tGbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdGb3JtRGF0YSc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRnVuY3Rpb24nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgY2FsbGJhY2tGbi5hcHBseSh0aGlzQXJnLCBbdmFsdWUsIGtleSwgdGhpc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgRm9ybURhdGEgPSBfRm9ybURhdGE7XG4gICAgX19uYW1lKEZvcm1EYXRhLCBcIkZvcm1EYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQoRm9ybURhdGEsIFwibmFtZVwiLCBcIkZvcm1EYXRhXCIpO1xuICAgIEZvcm1EYXRhLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gRm9ybURhdGEucHJvdG90eXBlLmVudHJpZXM7XG4gICAgZnVuY3Rpb24gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkge1xuICAgICAgbmFtZSA9IEJ1ZmZlci5mcm9tKG5hbWUpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9iID8gbmV3IEZpbGUoW3ZhbHVlXSwgXCJibG9iXCIsIHsgdHlwZTogdmFsdWUudHlwZSB9KSA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgXCJibG9iXCIsIHsgdHlwZTogdmFsdWUudHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZW5hbWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBGaWxlID8gbmV3IEZpbGUoW3ZhbHVlXSwgZmlsZW5hbWUsIHsgdHlwZTogdmFsdWUudHlwZSB9KSA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIHsgdHlwZTogdmFsdWUudHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VFbnRyeSwgXCJtYWtlRW50cnlcIik7XG4gICAgZnVuY3Rpb24qIG1ha2VJdGVyYWJsZShlbnRyaWVzLCB0eXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImVudHJpZXNcIikge1xuICAgICAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2YWx1ZXNcIikge1xuICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1ha2VJdGVyYWJsZSwgXCJtYWtlSXRlcmFibGVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0geyBGb3JtRGF0YSB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qc1xudmFyIHJlcXVpcmVfYm9keSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2JvZHkuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IFJlYWRhYmxlU3RyZWFtRnJvbSwgdG9VU1ZTdHJpbmcsIGlzQmxvYkxpa2UgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIgeyBGb3JtRGF0YSB9ID0gcmVxdWlyZV9mb3JtZGF0YSgpO1xuICAgIHZhciB7IGtTdGF0ZSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IHdlYmlkbCB9ID0gcmVxdWlyZV93ZWJpZGwoKTtcbiAgICB2YXIgeyBCbG9iIH0gPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuICAgIHZhciB7IGtCb2R5VXNlZCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsgTm90U3VwcG9ydGVkRXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsgaXNFcnJvcmVkIH0gPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgaXNVaW50OEFycmF5LCBpc0FycmF5QnVmZmVyIH0gPSByZXF1aXJlKFwidXRpbC90eXBlc1wiKTtcbiAgICB2YXIgUmVhZGFibGVTdHJlYW07XG4gICAgYXN5bmMgZnVuY3Rpb24qIGJsb2JHZW4oYmxvYikge1xuICAgICAgeWllbGQqIGJsb2Iuc3RyZWFtKCk7XG4gICAgfVxuICAgIF9fbmFtZShibG9iR2VuLCBcImJsb2JHZW5cIik7XG4gICAgZnVuY3Rpb24gZXh0cmFjdEJvZHkob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpLlJlYWRhYmxlU3RyZWFtO1xuICAgICAgfVxuICAgICAgbGV0IHN0cmVhbTIgPSBudWxsO1xuICAgICAgbGV0IGFjdGlvbiA9IG51bGw7XG4gICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgIGxldCBsZW5ndGggPSBudWxsO1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgc291cmNlID0gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3QuYnVmZmVyLnNsaWNlKG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QuYnl0ZU9mZnNldCArIG9iamVjdC5ieXRlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzRm9ybURhdGFMaWtlKG9iamVjdCkpIHtcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSBcIi0tLS1mb3JtZGF0YS11bmRpY2ktXCIgKyBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBgLS0ke2JvdW5kYXJ5fVxcclxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYDtcbiAgICAgICAgY29uc3QgZXNjYXBlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RyKSA9PiBzdHIucmVwbGFjZSgvXFxuL2csIFwiJTBBXCIpLnJlcGxhY2UoL1xcci9nLCBcIiUwRFwiKS5yZXBsYWNlKC9cIi9nLCBcIiUyMlwiKSwgXCJlc2NhcGVcIik7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxpbmVmZWVkcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHZhbHVlKSA9PiB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIlxcclxcblwiKSwgXCJub3JtYWxpemVMaW5lZmVlZHNcIik7XG4gICAgICAgIGFjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24qIChvYmplY3QyKSB7XG4gICAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgeWllbGQgZW5jLmVuY29kZShcbiAgICAgICAgICAgICAgICBwcmVmaXggKyBgOyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cIlxcclxuXFxyXG4ke25vcm1hbGl6ZUxpbmVmZWVkcyh2YWx1ZSl9XFxyXG5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5aWVsZCBlbmMuZW5jb2RlKFxuICAgICAgICAgICAgICAgIHByZWZpeCArIGA7IG5hbWU9XCIke2VzY2FwZShub3JtYWxpemVMaW5lZmVlZHMobmFtZSkpfVwiYCArICh2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2VzY2FwZSh2YWx1ZS5uYW1lKX1cImAgOiBcIlwiKSArIGBcXHJcbkNvbnRlbnQtVHlwZTogJHt2YWx1ZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9XFxyXG5cXHJcbmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgeWllbGQqIGJsb2JHZW4odmFsdWUpO1xuICAgICAgICAgICAgICB5aWVsZCBlbmMuZW5jb2RlKFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBlbmMuZW5jb2RlKGAtLSR7Ym91bmRhcnl9LS1gKTtcbiAgICAgICAgfSwgXCJhY3Rpb25cIik7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgY29udGVudFR5cGUgPSBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PVwiICsgYm91bmRhcnk7XG4gICAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2Uob2JqZWN0KSkge1xuICAgICAgICBhY3Rpb24gPSBibG9iR2VuO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIGxlbmd0aCA9IG9iamVjdC5zaXplO1xuICAgICAgICBpZiAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICBjb250ZW50VHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGtlZXBhbGl2ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWVwYWxpdmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwyLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIlJlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0yID0gb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZSA9IHRvVVNWU3RyaW5nKG9iamVjdCk7XG4gICAgICAgIGNvbnRlbnRUeXBlID0gXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiIHx8IHV0aWwyLmlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBsZXQgaXRlcmF0b3I7XG4gICAgICAgIHN0cmVhbTIgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWlzRXJyb3JlZChzdHJlYW0yKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5kZXNpcmVkU2l6ZSA+IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghc3RyZWFtMikge1xuICAgICAgICBzdHJlYW0yID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzb3VyY2UpIDogc291cmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IHsgc3RyZWFtOiBzdHJlYW0yLCBzb3VyY2UsIGxlbmd0aCB9O1xuICAgICAgcmV0dXJuIFtib2R5LCBjb250ZW50VHlwZV07XG4gICAgfVxuICAgIF9fbmFtZShleHRyYWN0Qm9keSwgXCJleHRyYWN0Qm9keVwiKTtcbiAgICBmdW5jdGlvbiBzYWZlbHlFeHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZShcInN0cmVhbS93ZWJcIikuUmVhZGFibGVTdHJlYW07XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgYXNzZXJ0KCF1dGlsMi5pc0Rpc3R1cmJlZChvYmplY3QpLCBcImRpc3R1cmJlZFwiKTtcbiAgICAgICAgYXNzZXJ0KCFvYmplY3QubG9ja2VkLCBcImxvY2tlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSk7XG4gICAgfVxuICAgIF9fbmFtZShzYWZlbHlFeHRyYWN0Qm9keSwgXCJzYWZlbHlFeHRyYWN0Qm9keVwiKTtcbiAgICBmdW5jdGlvbiBjbG9uZUJvZHkoYm9keSkge1xuICAgICAgY29uc3QgW291dDEsIG91dDJdID0gYm9keS5zdHJlYW0udGVlKCk7XG4gICAgICBib2R5LnN0cmVhbSA9IG91dDE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IG91dDIsXG4gICAgICAgIGxlbmd0aDogYm9keS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShjbG9uZUJvZHksIFwiY2xvbmVCb2R5XCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uKiBjb25zdW1lQm9keShib2R5KSB7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICBpZiAoaXNVaW50OEFycmF5KGJvZHkpKSB7XG4gICAgICAgICAgeWllbGQgYm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzdHJlYW0yID0gYm9keS5zdHJlYW07XG4gICAgICAgICAgaWYgKHV0aWwyLmlzRGlzdHVyYmVkKHN0cmVhbTIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGlzdHVyYmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyZWFtMi5sb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2NrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbTJba0JvZHlVc2VkXSA9IHRydWU7XG4gICAgICAgICAgeWllbGQqIHN0cmVhbTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGNvbnN1bWVCb2R5LCBcImNvbnN1bWVCb2R5XCIpO1xuICAgIGZ1bmN0aW9uIGJvZHlNaXhpbk1ldGhvZHMoaW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIGFzeW5jIGJsb2IoKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheSBjaHVua1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtjaHVua10pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGNodW5rcywgeyB0eXBlOiB0aGlzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpIHx8IFwiXCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGFycmF5QnVmZmVyKCkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB0aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuaGVhZGVycy5oYXMoXCJjb250ZW50LWVuY29kaW5nXCIpO1xuICAgICAgICAgIGlmICghZW5jb2RlZCAmJiBjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IFVpbnQ4QXJyYXkoY29udGVudExlbmd0aCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0MiA9IDA7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheSBjaHVua1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBidWZmZXIyLnNldChjaHVuaywgb2Zmc2V0Mik7XG4gICAgICAgICAgICAgIG9mZnNldDIgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjIuYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheSBjaHVua1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHRleHQoKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkge1xuICAgICAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHREZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCArPSB0ZXh0RGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBqc29uKCkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGF3YWl0IHRoaXMudGV4dCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZm9ybURhdGEoKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICAgIGlmICgvbXVsdGlwYXJ0XFwvZm9ybS1kYXRhLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL2FwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgbGV0IGVudHJpZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiwgeyBpZ25vcmVCT006IHRydWUgfSk7XG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJvZHkodGhpc1trU3RhdGVdLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheSBjaHVua1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCArPSB0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHQgKz0gdGV4dERlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgICAgICAgIGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRleHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcigpLCB7IGNhdXNlOiBlcnIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6IGAke2luc3RhbmNlLm5hbWV9LmZvcm1EYXRhYCxcbiAgICAgICAgICAgICAgdmFsdWU6IFwiQ291bGQgbm90IHBhcnNlIGNvbnRlbnQgYXMgRm9ybURhdGEuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH1cbiAgICBfX25hbWUoYm9keU1peGluTWV0aG9kcywgXCJib2R5TWl4aW5NZXRob2RzXCIpO1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgICAgYm9keToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzW2tTdGF0ZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBib2R5VXNlZDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzW2tTdGF0ZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIXRoaXNba1N0YXRlXS5ib2R5ICYmIHV0aWwyLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1peGluQm9keShwcm90b3R5cGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvdHlwZS5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBfX25hbWUobWl4aW5Cb2R5LCBcIm1peGluQm9keVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBleHRyYWN0Qm9keSxcbiAgICAgIHNhZmVseUV4dHJhY3RCb2R5LFxuICAgICAgY2xvbmVCb2R5LFxuICAgICAgbWl4aW5Cb2R5XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvcmVxdWVzdC5qc1xudmFyIHJlcXVpcmVfcmVxdWVzdCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvcmVxdWVzdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIge1xuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgICBOb3RTdXBwb3J0ZWRFcnJvclxuICAgIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgdG9rZW5SZWdFeHAgPSAvXltcXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XSskLztcbiAgICB2YXIgaGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vO1xuICAgIHZhciBpbnZhbGlkUGF0aFJlZ2V4ID0gL1teXFx1MDAyMS1cXHUwMGZmXS87XG4gICAgdmFyIGtIYW5kbGVyID0gU3ltYm9sKFwiaGFuZGxlclwiKTtcbiAgICB2YXIgY2hhbm5lbHMgPSB7fTtcbiAgICB2YXIgZXh0cmFjdEJvZHk7XG4gICAgdmFyIG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgbm9kZU1ham9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzBdKTtcbiAgICB2YXIgbm9kZU1pbm9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzFdKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZShcImRpYWdub3N0aWNzX2NoYW5uZWxcIik7XG4gICAgICBjaGFubmVscy5jcmVhdGUgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmNyZWF0ZVwiKTtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50ID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6cmVxdWVzdDpib2R5U2VudFwiKTtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmhlYWRlcnNcIik7XG4gICAgICBjaGFubmVscy50cmFpbGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6dHJhaWxlcnNcIik7XG4gICAgICBjaGFubmVscy5lcnJvciA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6ZXJyb3JcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2hhbm5lbHMuY3JlYXRlID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfTtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50ID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfTtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMudHJhaWxlcnMgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuZXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgIH1cbiAgICB2YXIgUmVxdWVzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwge1xuICAgICAgICBwYXRoOiBwYXRoNyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBxdWVyeTogcXVlcnkyLFxuICAgICAgICBpZGVtcG90ZW50LFxuICAgICAgICBibG9ja2luZyxcbiAgICAgICAgdXBncmFkZSxcbiAgICAgICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgICAgIGJvZHlUaW1lb3V0LFxuICAgICAgICB0aHJvd09uRXJyb3JcbiAgICAgIH0sIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoNyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInBhdGggbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoN1swXSAhPT0gXCIvXCIgJiYgIShwYXRoNy5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBwYXRoNy5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpICYmIG1ldGhvZCAhPT0gXCJDT05ORUNUXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJwYXRoIG11c3QgYmUgYW4gYWJzb2x1dGUgVVJMIG9yIHN0YXJ0IHdpdGggYSBzbGFzaFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnZhbGlkUGF0aFJlZ2V4LmV4ZWMocGF0aDcpICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCByZXF1ZXN0IHBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtZXRob2QgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlZ0V4cC5leGVjKG1ldGhvZCkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJlcXVlc3QgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGdyYWRlICYmIHR5cGVvZiB1cGdyYWRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwidXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZWFkZXJzVGltZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgYm9keVRpbWVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzVGltZW91dCA9IGhlYWRlcnNUaW1lb3V0O1xuICAgICAgICB0aGlzLmJvZHlUaW1lb3V0ID0gYm9keVRpbWVvdXQ7XG4gICAgICAgIHRoaXMudGhyb3dPbkVycm9yID0gdGhyb3dPbkVycm9yID09PSB0cnVlO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gYm9keSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keS5idWZmZXIuYnl0ZUxlbmd0aCA/IEJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnl0ZUxlbmd0aCA/IEJ1ZmZlci5mcm9tKGJvZHkpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IHV0aWwyLmlzSXRlcmFibGUoYm9keSkgfHwgdXRpbDIuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiYm9keSBtdXN0IGJlIGEgc3RyaW5nLCBhIEJ1ZmZlciwgYSBSZWFkYWJsZSBzdHJlYW0sIGFuIGl0ZXJhYmxlLCBvciBhbiBhc3luYyBpdGVyYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsO1xuICAgICAgICB0aGlzLnBhdGggPSBxdWVyeTIgPyB1dGlsMi5idWlsZFVSTChwYXRoNywgcXVlcnkyKSA6IHBhdGg3O1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5pZGVtcG90ZW50ID0gaWRlbXBvdGVudCA9PSBudWxsID8gbWV0aG9kID09PSBcIkhFQURcIiB8fCBtZXRob2QgPT09IFwiR0VUXCIgOiBpZGVtcG90ZW50O1xuICAgICAgICB0aGlzLmJsb2NraW5nID0gYmxvY2tpbmcgPT0gbnVsbCA/IGZhbHNlIDogYmxvY2tpbmc7XG4gICAgICAgIHRoaXMuaG9zdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBcIlwiO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImhlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsMi5pc0Zvcm1EYXRhTGlrZSh0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgaWYgKG5vZGVNYWpvciA8IDE2IHx8IG5vZGVNYWpvciA9PT0gMTYgJiYgbm9kZU1pbm9yIDwgOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiRm9ybS1EYXRhIGJvZGllcyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gbm9kZSB2MTYuOCBhbmQgbmV3ZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWV4dHJhY3RCb2R5KSB7XG4gICAgICAgICAgICBleHRyYWN0Qm9keSA9IHJlcXVpcmVfYm9keSgpLmV4dHJhY3RCb2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSk7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGVudFR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzICs9IGBjb250ZW50LXR5cGU6ICR7Y29udGVudFR5cGV9XFxyXG5gO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsMi5pc0Jsb2JMaWtlKGJvZHkpICYmIHRoaXMuY29udGVudFR5cGUgPT0gbnVsbCAmJiBib2R5LnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gYm9keS50eXBlO1xuICAgICAgICAgIHRoaXMuaGVhZGVycyArPSBgY29udGVudC10eXBlOiAke2JvZHkudHlwZX1cXHJcbmA7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbDIudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSk7XG4gICAgICAgIHRoaXMuc2VydmVybmFtZSA9IHV0aWwyLmdldFNlcnZlck5hbWUodGhpcy5ob3N0KTtcbiAgICAgICAgdGhpc1trSGFuZGxlcl0gPSBoYW5kbGVyO1xuICAgICAgICBpZiAoY2hhbm5lbHMuY3JlYXRlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMuY3JlYXRlLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkJvZHlTZW50KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvblJlcXVlc3RTZW50KCkge1xuICAgICAgICBpZiAoY2hhbm5lbHMuYm9keVNlbnQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5ib2R5U2VudC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25Db25uZWN0KGFib3J0KSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZCk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkNvbm5lY3QoYWJvcnQpO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZCk7XG4gICAgICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpO1xuICAgICAgICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLmhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgICBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRGF0YShjaHVuayk7XG4gICAgICB9XG4gICAgICBvblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZCk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KTtcbiAgICAgIH1cbiAgICAgIG9uQ29tcGxldGUodHJhaWxlcnMpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChjaGFubmVscy50cmFpbGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLnRyYWlsZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCB0cmFpbGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db21wbGV0ZSh0cmFpbGVycyk7XG4gICAgICB9XG4gICAgICBvbkVycm9yKGVycm9yMikge1xuICAgICAgICBpZiAoY2hhbm5lbHMuZXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkVycm9yKGVycm9yMik7XG4gICAgICB9XG4gICAgICBhZGRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShSZXF1ZXN0LCBcIlJlcXVlc3RcIik7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcihyZXF1ZXN0Miwga2V5LCB2YWwpIHtcbiAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIuaG9zdCA9PT0gbnVsbCAmJiBrZXkubGVuZ3RoID09PSA0ICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBcImhvc3RcIikge1xuICAgICAgICByZXF1ZXN0Mi5ob3N0ID0gdmFsO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5jb250ZW50TGVuZ3RoID09PSBudWxsICYmIGtleS5sZW5ndGggPT09IDE0ICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtbGVuZ3RoXCIpIHtcbiAgICAgICAgcmVxdWVzdDIuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXF1ZXN0Mi5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY29udGVudC1sZW5ndGggaGVhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QyLmNvbnRlbnRUeXBlID09PSBudWxsICYmIGtleS5sZW5ndGggPT09IDEyICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICYmIGhlYWRlckNoYXJSZWdleC5leGVjKHZhbCkgPT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdDIuY29udGVudFR5cGUgPSB2YWw7XG4gICAgICAgIHJlcXVlc3QyLmhlYWRlcnMgKz0gYCR7a2V5fTogJHt2YWx9XFxyXG5gO1xuICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxNyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc2Zlci1lbmNvZGluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyXCIpO1xuICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb25uZWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwia2VlcC1hbGl2ZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQga2VlcC1hbGl2ZSBoZWFkZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwidXBncmFkZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgdXBncmFkZSBoZWFkZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDYgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiZXhwZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKFwiZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfSBlbHNlIGlmICh0b2tlblJlZ0V4cC5leGVjKGtleSkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZWFkZXIga2V5XCIpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkZXJDaGFyUmVnZXguZXhlYyh2YWwpICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Mi5oZWFkZXJzICs9IGAke2tleX06ICR7dmFsfVxcclxuYDtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHByb2Nlc3NIZWFkZXIsIFwicHJvY2Vzc0hlYWRlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBSZXF1ZXN0O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci5qc1xudmFyIHJlcXVpcmVfZGlzcGF0Y2hlciA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEV2ZW50RW1pdHRlcjQgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI0IHtcbiAgICAgIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICB9XG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKERpc3BhdGNoZXIsIFwiRGlzcGF0Y2hlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci1iYXNlLmpzXG52YXIgcmVxdWlyZV9kaXNwYXRjaGVyX2Jhc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLWJhc2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlX2Rpc3BhdGNoZXIoKTtcbiAgICB2YXIge1xuICAgICAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gICAgICBDbGllbnRDbG9zZWRFcnJvcixcbiAgICAgIEludmFsaWRBcmd1bWVudEVycm9yXG4gICAgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsga0Rlc3Ryb3ksIGtDbG9zZSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIga0Rlc3Ryb3llZCA9IFN5bWJvbChcImRlc3Ryb3llZFwiKTtcbiAgICB2YXIga0Nsb3NlZCA9IFN5bWJvbChcImNsb3NlZFwiKTtcbiAgICB2YXIga09uRGVzdHJveWVkID0gU3ltYm9sKFwib25EZXN0cm95ZWRcIik7XG4gICAgdmFyIGtPbkNsb3NlZCA9IFN5bWJvbChcIm9uQ2xvc2VkXCIpO1xuICAgIHZhciBEaXNwYXRjaGVyQmFzZSA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1trRGVzdHJveWVkXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBbXTtcbiAgICAgICAgdGhpc1trQ2xvc2VkXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW2tPbkNsb3NlZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tEZXN0cm95ZWRdO1xuICAgICAgfVxuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0Nsb3NlZF07XG4gICAgICB9XG4gICAgICBjbG9zZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSwgbnVsbCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICAgIGlmICh0aGlzW2tPbkNsb3NlZF0pIHtcbiAgICAgICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trQ2xvc2VkXSA9IHRydWU7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkNsb3NlZF07XG4gICAgICAgICAgdGhpc1trT25DbG9zZWRdID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJvbkNsb3NlZFwiKTtcbiAgICAgICAgdGhpc1trQ2xvc2VdKCkudGhlbigoKSA9PiB0aGlzLmRlc3Ryb3koKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2sob25DbG9zZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlcnI7XG4gICAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyLCAoZXJyMiwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyMiA/IHJlamVjdChlcnIyKSA6IHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICAgICAgaWYgKHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIGVyciA9IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba0Rlc3Ryb3llZF0gPSB0cnVlO1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG9uRGVzdHJveWVkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25EZXN0cm95ZWRdO1xuICAgICAgICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFwib25EZXN0cm95ZWRcIik7XG4gICAgICAgIHRoaXNba0Rlc3Ryb3ldKGVycikudGhlbigoKSA9PiB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2sob25EZXN0cm95ZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwib3B0cyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXNba0Nsb3NlZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpc1trRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25FcnJvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uRXJyb3IgbWV0aG9kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVyLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShEaXNwYXRjaGVyQmFzZSwgXCJEaXNwYXRjaGVyQmFzZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBEaXNwYXRjaGVyQmFzZTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvcmVkaXJlY3QuanNcbnZhciByZXF1aXJlX3JlZGlyZWN0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9yZWRpcmVjdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsga0JvZHlVc2VkIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgRUUgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuICAgIHZhciByZWRpcmVjdGFibGVTdGF0dXNDb2RlcyA9IFszMDAsIDMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcbiAgICB2YXIga0JvZHkgPSBTeW1ib2woXCJib2R5XCIpO1xuICAgIHZhciBCb2R5QXN5bmNJdGVyYWJsZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGJvZHkpIHtcbiAgICAgICAgdGhpc1trQm9keV0gPSBib2R5O1xuICAgICAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgXCJkaXN0dXJiZWRcIik7XG4gICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWU7XG4gICAgICAgIHlpZWxkKiB0aGlzW2tCb2R5XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShCb2R5QXN5bmNJdGVyYWJsZSwgXCJCb2R5QXN5bmNJdGVyYWJsZVwiKTtcbiAgICB2YXIgUmVkaXJlY3RIYW5kbGVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoZGlzcGF0Y2hlciwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwyLnZhbGlkYXRlSGFuZGxlcihoYW5kbGVyLCBvcHRzLm1ldGhvZCwgb3B0cy51cGdyYWRlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWJvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9O1xuICAgICAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9ucztcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgICBpZiAodXRpbDIuYm9keUxlbmd0aCh0aGlzLm9wdHMuYm9keSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5ib2R5Lm9uKFwiZGF0YVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIEVFLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMub3B0cy5ib2R5LCBcImRhdGFcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5ib2R5ICYmIHR5cGVvZiB0aGlzLm9wdHMuYm9keSAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMub3B0cy5ib2R5KSAmJiB1dGlsMi5pc0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25Db25uZWN0KGFib3J0KSB7XG4gICAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydDtcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uQ29ubmVjdChhYm9ydCwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnkgfSk7XG4gICAgICB9XG4gICAgICBvblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KTtcbiAgICAgIH1cbiAgICAgIG9uRXJyb3IoZXJyb3IyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycm9yMik7XG4gICAgICB9XG4gICAgICBvbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zIHx8IHV0aWwyLmlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSA/IG51bGwgOiBwYXJzZUxvY2F0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsMi5wYXJzZVVSTChuZXcgVVJMKHRoaXMubG9jYXRpb24sIHRoaXMub3B0cy5vcmlnaW4gJiYgbmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpKTtcbiAgICAgICAgY29uc3QgcGF0aDcgPSBzZWFyY2ggPyBgJHtwYXRobmFtZX0ke3NlYXJjaH1gIDogcGF0aG5hbWU7XG4gICAgICAgIHRoaXMub3B0cy5oZWFkZXJzID0gY2xlYW5SZXF1ZXN0SGVhZGVycyh0aGlzLm9wdHMuaGVhZGVycywgc3RhdHVzQ29kZSA9PT0gMzAzLCB0aGlzLm9wdHMub3JpZ2luICE9PSBvcmlnaW4pO1xuICAgICAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGg3O1xuICAgICAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLm9wdHMubWF4UmVkaXJlY3Rpb25zID0gMDtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDMwMyAmJiB0aGlzLm9wdHMubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgIHRoaXMub3B0cy5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICAgIHRoaXMub3B0cy5ib2R5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25EYXRhKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkNvbXBsZXRlKHRyYWlsZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGw7XG4gICAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmRpc3BhdGNoKHRoaXMub3B0cywgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVyLm9uQ29tcGxldGUodHJhaWxlcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkJvZHlTZW50KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXIub25Cb2R5U2VudCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlZGlyZWN0SGFuZGxlciwgXCJSZWRpcmVjdEhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gICAgICBpZiAocmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImxvY2F0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHBhcnNlTG9jYXRpb24sIFwicGFyc2VMb2NhdGlvblwiKTtcbiAgICBmdW5jdGlvbiBzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLmxlbmd0aCA9PT0gNCAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImhvc3RcIiB8fCByZW1vdmVDb250ZW50ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbnRlbnQtXCIpID09PSAwIHx8IHVua25vd25PcmlnaW4gJiYgaGVhZGVyLmxlbmd0aCA9PT0gMTMgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRob3JpemF0aW9uXCIgfHwgdW5rbm93bk9yaWdpbiAmJiBoZWFkZXIubGVuZ3RoID09PSA2ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29va2llXCI7XG4gICAgfVxuICAgIF9fbmFtZShzaG91bGRSZW1vdmVIZWFkZXIsIFwic2hvdWxkUmVtb3ZlSGVhZGVyXCIpO1xuICAgIGZ1bmN0aW9uIGNsZWFuUmVxdWVzdEhlYWRlcnMoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXJzW2ldLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoa2V5LCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGhlYWRlcnMgPT0gbnVsbCwgXCJoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgX19uYW1lKGNsZWFuUmVxdWVzdEhlYWRlcnMsIFwiY2xlYW5SZXF1ZXN0SGVhZGVyc1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBSZWRpcmVjdEhhbmRsZXI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanNcbnZhciByZXF1aXJlX2Nvbm5lY3QgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5ldDIgPSByZXF1aXJlKFwibmV0XCIpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgQ29ubmVjdFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgdGxzO1xuICAgIGZ1bmN0aW9uIGJ1aWxkQ29ubmVjdG9yKHsgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIC4uLm9wdHMgfSkge1xuICAgICAgaWYgKG1heENhY2hlZFNlc3Npb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heENhY2hlZFNlc3Npb25zKSB8fCBtYXhDYWNoZWRTZXNzaW9ucyA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm9cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0geyBwYXRoOiBzb2NrZXRQYXRoLCAuLi5vcHRzIH07XG4gICAgICBjb25zdCBzZXNzaW9uQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGltZW91dCA9IHRpbWVvdXQgPT0gbnVsbCA/IDFlNCA6IHRpbWVvdXQ7XG4gICAgICBtYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zID09IG51bGwgPyAxMDAgOiBtYXhDYWNoZWRTZXNzaW9ucztcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGNvbm5lY3QoeyBob3N0bmFtZTogaG9zdG5hbWUzLCBob3N0LCBwcm90b2NvbCwgcG9ydCwgc2VydmVybmFtZSwgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICBpZiAocHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgICBpZiAoIXRscykge1xuICAgICAgICAgICAgdGxzID0gcmVxdWlyZShcInRsc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVybmFtZSA9IHNlcnZlcm5hbWUgfHwgb3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IHV0aWwyLmdldFNlcnZlck5hbWUoaG9zdCkgfHwgbnVsbDtcbiAgICAgICAgICBjb25zdCBzZXNzaW9uS2V5ID0gc2VydmVybmFtZSB8fCBob3N0bmFtZTM7XG4gICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbDtcbiAgICAgICAgICBhc3NlcnQoc2Vzc2lvbktleSk7XG4gICAgICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogMTYzODQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2VydmVybmFtZSxcbiAgICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsXG4gICAgICAgICAgICBwb3J0OiBwb3J0IHx8IDQ0MyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3RuYW1lM1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNvY2tldC5vbihcInNlc3Npb25cIiwgZnVuY3Rpb24oc2Vzc2lvbjIpIHtcbiAgICAgICAgICAgIGlmIChtYXhDYWNoZWRTZXNzaW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkNhY2hlLnNpemUgPj0gbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogb2xkZXN0S2V5IH0gPSBzZXNzaW9uQ2FjaGUua2V5cygpLm5leHQoKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vzc2lvbkNhY2hlLnNldChzZXNzaW9uS2V5LCBzZXNzaW9uMik7XG4gICAgICAgICAgfSkub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uS2V5ICYmIGVyci5jb2RlICE9PSBcIlVORF9FUlJfSU5GT1wiKSB7XG4gICAgICAgICAgICAgIHNlc3Npb25DYWNoZS5kZWxldGUoc2Vzc2lvbktleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCBcImh0dHBTb2NrZXQgY2FuIG9ubHkgYmUgc2VudCBvbiBUTFMgdXBkYXRlXCIpO1xuICAgICAgICAgIHNvY2tldCA9IG5ldDIuY29ubmVjdCh7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3RuYW1lM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbFRpbWVvdXQgPSBzZXR1cFRpbWVvdXQoKCkgPT4gb25Db25uZWN0VGltZW91dChzb2NrZXQpLCB0aW1lb3V0KTtcbiAgICAgICAgc29ja2V0LnNldE5vRGVsYXkodHJ1ZSkub25jZShwcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwic2VjdXJlQ29ubmVjdFwiIDogXCJjb25uZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICBjYihudWxsLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgIH0sIFwiY29ubmVjdFwiKTtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkQ29ubmVjdG9yLCBcImJ1aWxkQ29ubmVjdG9yXCIpO1xuICAgIGZ1bmN0aW9uIHNldHVwVGltZW91dChvbkNvbm5lY3RUaW1lb3V0MiwgdGltZW91dCkge1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsZXQgczEgPSBudWxsO1xuICAgICAgbGV0IHMyID0gbnVsbDtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzMSA9IHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICAgICAgczIgPSBzZXRJbW1lZGlhdGUoKCkgPT4gb25Db25uZWN0VGltZW91dDIoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdFRpbWVvdXQyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGNsZWFySW1tZWRpYXRlKHMxKTtcbiAgICAgICAgY2xlYXJJbW1lZGlhdGUoczIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKHNldHVwVGltZW91dCwgXCJzZXR1cFRpbWVvdXRcIik7XG4gICAgZnVuY3Rpb24gb25Db25uZWN0VGltZW91dChzb2NrZXQpIHtcbiAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgQ29ubmVjdFRpbWVvdXRFcnJvcigpKTtcbiAgICB9XG4gICAgX19uYW1lKG9uQ29ubmVjdFRpbWVvdXQsIFwib25Db25uZWN0VGltZW91dFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBidWlsZENvbm5lY3RvcjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC91dGlscy5qc1xudmFyIHJlcXVpcmVfdXRpbHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuZW51bVRvTWFwID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGVudW1Ub01hcChvYmopIHtcbiAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX19uYW1lKGVudW1Ub01hcCwgXCJlbnVtVG9NYXBcIik7XG4gICAgZXhwb3J0cy5lbnVtVG9NYXAgPSBlbnVtVG9NYXA7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzXG52YXIgcmVxdWlyZV9jb25zdGFudHMyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SID0gZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBleHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IGV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLk1BUksgPSBleHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5OVU0gPSBleHBvcnRzLkhFWF9NQVAgPSBleHBvcnRzLk5VTV9NQVAgPSBleHBvcnRzLkFMUEhBID0gZXhwb3J0cy5GSU5JU0ggPSBleHBvcnRzLkhfTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EU19SVFNQID0gZXhwb3J0cy5NRVRIT0RTX0lDRSA9IGV4cG9ydHMuTUVUSE9EU19IVFRQID0gZXhwb3J0cy5NRVRIT0RTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5GTEFHUyA9IGV4cG9ydHMuVFlQRSA9IGV4cG9ydHMuRVJST1IgPSB2b2lkIDA7XG4gICAgdmFyIHV0aWxzXzEgPSByZXF1aXJlX3V0aWxzKCk7XG4gICAgdmFyIEVSUk9SO1xuICAgIChmdW5jdGlvbihFUlJPUjIpIHtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVEVSTkFMXCJdID0gMV0gPSBcIklOVEVSTkFMXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiU1RSSUNUXCJdID0gMl0gPSBcIlNUUklDVFwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIkxGX0VYUEVDVEVEXCJdID0gM10gPSBcIkxGX0VYUEVDVEVEXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiXSA9IDRdID0gXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiQ0xPU0VEX0NPTk5FQ1RJT05cIl0gPSA1XSA9IFwiQ0xPU0VEX0NPTk5FQ1RJT05cIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJJTlZBTElEX01FVEhPRFwiXSA9IDZdID0gXCJJTlZBTElEX01FVEhPRFwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfVVJMXCJdID0gN10gPSBcIklOVkFMSURfVVJMXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9DT05TVEFOVFwiXSA9IDhdID0gXCJJTlZBTElEX0NPTlNUQU5UXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9WRVJTSU9OXCJdID0gOV0gPSBcIklOVkFMSURfVkVSU0lPTlwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfSEVBREVSX1RPS0VOXCJdID0gMTBdID0gXCJJTlZBTElEX0hFQURFUl9UT0tFTlwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIl0gPSAxMV0gPSBcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJJTlZBTElEX0NIVU5LX1NJWkVcIl0gPSAxMl0gPSBcIklOVkFMSURfQ0hVTktfU0laRVwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfU1RBVFVTXCJdID0gMTNdID0gXCJJTlZBTElEX1NUQVRVU1wiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfRU9GX1NUQVRFXCJdID0gMTRdID0gXCJJTlZBTElEX0VPRl9TVEFURVwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAxNV0gPSBcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJDQl9NRVNTQUdFX0JFR0lOXCJdID0gMTZdID0gXCJDQl9NRVNTQUdFX0JFR0lOXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiQ0JfSEVBREVSU19DT01QTEVURVwiXSA9IDE3XSA9IFwiQ0JfSEVBREVSU19DT01QTEVURVwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIkNCX01FU1NBR0VfQ09NUExFVEVcIl0gPSAxOF0gPSBcIkNCX01FU1NBR0VfQ09NUExFVEVcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJDQl9DSFVOS19IRUFERVJcIl0gPSAxOV0gPSBcIkNCX0NIVU5LX0hFQURFUlwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIkNCX0NIVU5LX0NPTVBMRVRFXCJdID0gMjBdID0gXCJDQl9DSFVOS19DT01QTEVURVwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIlBBVVNFRFwiXSA9IDIxXSA9IFwiUEFVU0VEXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiUEFVU0VEX1VQR1JBREVcIl0gPSAyMl0gPSBcIlBBVVNFRF9VUEdSQURFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiUEFVU0VEX0gyX1VQR1JBREVcIl0gPSAyM10gPSBcIlBBVVNFRF9IMl9VUEdSQURFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiVVNFUlwiXSA9IDI0XSA9IFwiVVNFUlwiO1xuICAgIH0pKEVSUk9SID0gZXhwb3J0cy5FUlJPUiB8fCAoZXhwb3J0cy5FUlJPUiA9IHt9KSk7XG4gICAgdmFyIFRZUEU7XG4gICAgKGZ1bmN0aW9uKFRZUEUyKSB7XG4gICAgICBUWVBFMltUWVBFMltcIkJPVEhcIl0gPSAwXSA9IFwiQk9USFwiO1xuICAgICAgVFlQRTJbVFlQRTJbXCJSRVFVRVNUXCJdID0gMV0gPSBcIlJFUVVFU1RcIjtcbiAgICAgIFRZUEUyW1RZUEUyW1wiUkVTUE9OU0VcIl0gPSAyXSA9IFwiUkVTUE9OU0VcIjtcbiAgICB9KShUWVBFID0gZXhwb3J0cy5UWVBFIHx8IChleHBvcnRzLlRZUEUgPSB7fSkpO1xuICAgIHZhciBGTEFHUztcbiAgICAoZnVuY3Rpb24oRkxBR1MyKSB7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gMV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgICAgRkxBR1MyW0ZMQUdTMltcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSAyXSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgICAgRkxBR1MyW0ZMQUdTMltcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDRdID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJDSFVOS0VEXCJdID0gOF0gPSBcIkNIVU5LRURcIjtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJVUEdSQURFXCJdID0gMTZdID0gXCJVUEdSQURFXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAzMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiU0tJUEJPRFlcIl0gPSA2NF0gPSBcIlNLSVBCT0RZXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiVFJBSUxJTkdcIl0gPSAxMjhdID0gXCJUUkFJTElOR1wiO1xuICAgICAgRkxBR1MyW0ZMQUdTMltcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gNTEyXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICB9KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xuICAgIHZhciBMRU5JRU5UX0ZMQUdTO1xuICAgIChmdW5jdGlvbihMRU5JRU5UX0ZMQUdTMikge1xuICAgICAgTEVOSUVOVF9GTEFHUzJbTEVOSUVOVF9GTEFHUzJbXCJIRUFERVJTXCJdID0gMV0gPSBcIkhFQURFUlNcIjtcbiAgICAgIExFTklFTlRfRkxBR1MyW0xFTklFTlRfRkxBR1MyW1wiQ0hVTktFRF9MRU5HVEhcIl0gPSAyXSA9IFwiQ0hVTktFRF9MRU5HVEhcIjtcbiAgICAgIExFTklFTlRfRkxBR1MyW0xFTklFTlRfRkxBR1MyW1wiS0VFUF9BTElWRVwiXSA9IDRdID0gXCJLRUVQX0FMSVZFXCI7XG4gICAgfSkoTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyB8fCAoZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge30pKTtcbiAgICB2YXIgTUVUSE9EUztcbiAgICAoZnVuY3Rpb24oTUVUSE9EUzIpIHtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiREVMRVRFXCJdID0gMF0gPSBcIkRFTEVURVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJHRVRcIl0gPSAxXSA9IFwiR0VUXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkhFQURcIl0gPSAyXSA9IFwiSEVBRFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQT1NUXCJdID0gM10gPSBcIlBPU1RcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUFVUXCJdID0gNF0gPSBcIlBVVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJDT05ORUNUXCJdID0gNV0gPSBcIkNPTk5FQ1RcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiT1BUSU9OU1wiXSA9IDZdID0gXCJPUFRJT05TXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlRSQUNFXCJdID0gN10gPSBcIlRSQUNFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkNPUFlcIl0gPSA4XSA9IFwiQ09QWVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJMT0NLXCJdID0gOV0gPSBcIkxPQ0tcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTUtDT0xcIl0gPSAxMF0gPSBcIk1LQ09MXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIk1PVkVcIl0gPSAxMV0gPSBcIk1PVkVcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUFJPUEZJTkRcIl0gPSAxMl0gPSBcIlBST1BGSU5EXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlBST1BQQVRDSFwiXSA9IDEzXSA9IFwiUFJPUFBBVENIXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlNFQVJDSFwiXSA9IDE0XSA9IFwiU0VBUkNIXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlVOTE9DS1wiXSA9IDE1XSA9IFwiVU5MT0NLXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkJJTkRcIl0gPSAxNl0gPSBcIkJJTkRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUkVCSU5EXCJdID0gMTddID0gXCJSRUJJTkRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiVU5CSU5EXCJdID0gMThdID0gXCJVTkJJTkRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiQUNMXCJdID0gMTldID0gXCJBQ0xcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUkVQT1JUXCJdID0gMjBdID0gXCJSRVBPUlRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTUtBQ1RJVklUWVwiXSA9IDIxXSA9IFwiTUtBQ1RJVklUWVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJDSEVDS09VVFwiXSA9IDIyXSA9IFwiQ0hFQ0tPVVRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTUVSR0VcIl0gPSAyM10gPSBcIk1FUkdFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIk0tU0VBUkNIXCJdID0gMjRdID0gXCJNLVNFQVJDSFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJOT1RJRllcIl0gPSAyNV0gPSBcIk5PVElGWVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJTVUJTQ1JJQkVcIl0gPSAyNl0gPSBcIlNVQlNDUklCRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJVTlNVQlNDUklCRVwiXSA9IDI3XSA9IFwiVU5TVUJTQ1JJQkVcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUEFUQ0hcIl0gPSAyOF0gPSBcIlBBVENIXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlBVUkdFXCJdID0gMjldID0gXCJQVVJHRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJNS0NBTEVOREFSXCJdID0gMzBdID0gXCJNS0NBTEVOREFSXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkxJTktcIl0gPSAzMV0gPSBcIkxJTktcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiVU5MSU5LXCJdID0gMzJdID0gXCJVTkxJTktcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiU09VUkNFXCJdID0gMzNdID0gXCJTT1VSQ0VcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUFJJXCJdID0gMzRdID0gXCJQUklcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiREVTQ1JJQkVcIl0gPSAzNV0gPSBcIkRFU0NSSUJFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkFOTk9VTkNFXCJdID0gMzZdID0gXCJBTk5PVU5DRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJTRVRVUFwiXSA9IDM3XSA9IFwiU0VUVVBcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUExBWVwiXSA9IDM4XSA9IFwiUExBWVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQQVVTRVwiXSA9IDM5XSA9IFwiUEFVU0VcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiVEVBUkRPV05cIl0gPSA0MF0gPSBcIlRFQVJET1dOXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkdFVF9QQVJBTUVURVJcIl0gPSA0MV0gPSBcIkdFVF9QQVJBTUVURVJcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiU0VUX1BBUkFNRVRFUlwiXSA9IDQyXSA9IFwiU0VUX1BBUkFNRVRFUlwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJSRURJUkVDVFwiXSA9IDQzXSA9IFwiUkVESVJFQ1RcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUkVDT1JEXCJdID0gNDRdID0gXCJSRUNPUkRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiRkxVU0hcIl0gPSA0NV0gPSBcIkZMVVNIXCI7XG4gICAgfSkoTUVUSE9EUyA9IGV4cG9ydHMuTUVUSE9EUyB8fCAoZXhwb3J0cy5NRVRIT0RTID0ge30pKTtcbiAgICBleHBvcnRzLk1FVEhPRFNfSFRUUCA9IFtcbiAgICAgIE1FVEhPRFMuREVMRVRFLFxuICAgICAgTUVUSE9EUy5HRVQsXG4gICAgICBNRVRIT0RTLkhFQUQsXG4gICAgICBNRVRIT0RTLlBPU1QsXG4gICAgICBNRVRIT0RTLlBVVCxcbiAgICAgIE1FVEhPRFMuQ09OTkVDVCxcbiAgICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICAgIE1FVEhPRFMuVFJBQ0UsXG4gICAgICBNRVRIT0RTLkNPUFksXG4gICAgICBNRVRIT0RTLkxPQ0ssXG4gICAgICBNRVRIT0RTLk1LQ09MLFxuICAgICAgTUVUSE9EUy5NT1ZFLFxuICAgICAgTUVUSE9EUy5QUk9QRklORCxcbiAgICAgIE1FVEhPRFMuUFJPUFBBVENILFxuICAgICAgTUVUSE9EUy5TRUFSQ0gsXG4gICAgICBNRVRIT0RTLlVOTE9DSyxcbiAgICAgIE1FVEhPRFMuQklORCxcbiAgICAgIE1FVEhPRFMuUkVCSU5ELFxuICAgICAgTUVUSE9EUy5VTkJJTkQsXG4gICAgICBNRVRIT0RTLkFDTCxcbiAgICAgIE1FVEhPRFMuUkVQT1JULFxuICAgICAgTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgICAgTUVUSE9EUy5DSEVDS09VVCxcbiAgICAgIE1FVEhPRFMuTUVSR0UsXG4gICAgICBNRVRIT0RTW1wiTS1TRUFSQ0hcIl0sXG4gICAgICBNRVRIT0RTLk5PVElGWSxcbiAgICAgIE1FVEhPRFMuU1VCU0NSSUJFLFxuICAgICAgTUVUSE9EUy5VTlNVQlNDUklCRSxcbiAgICAgIE1FVEhPRFMuUEFUQ0gsXG4gICAgICBNRVRIT0RTLlBVUkdFLFxuICAgICAgTUVUSE9EUy5NS0NBTEVOREFSLFxuICAgICAgTUVUSE9EUy5MSU5LLFxuICAgICAgTUVUSE9EUy5VTkxJTkssXG4gICAgICBNRVRIT0RTLlBSSSxcbiAgICAgIE1FVEhPRFMuU09VUkNFXG4gICAgXTtcbiAgICBleHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgICAgTUVUSE9EUy5TT1VSQ0VcbiAgICBdO1xuICAgIGV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgICAgTUVUSE9EUy5PUFRJT05TLFxuICAgICAgTUVUSE9EUy5ERVNDUklCRSxcbiAgICAgIE1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgICBNRVRIT0RTLlNFVFVQLFxuICAgICAgTUVUSE9EUy5QTEFZLFxuICAgICAgTUVUSE9EUy5QQVVTRSxcbiAgICAgIE1FVEhPRFMuVEVBUkRPV04sXG4gICAgICBNRVRIT0RTLkdFVF9QQVJBTUVURVIsXG4gICAgICBNRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgICBNRVRIT0RTLlJFRElSRUNULFxuICAgICAgTUVUSE9EUy5SRUNPUkQsXG4gICAgICBNRVRIT0RTLkZMVVNILFxuICAgICAgTUVUSE9EUy5HRVQsXG4gICAgICBNRVRIT0RTLlBPU1RcbiAgICBdO1xuICAgIGV4cG9ydHMuTUVUSE9EX01BUCA9IHV0aWxzXzEuZW51bVRvTWFwKE1FVEhPRFMpO1xuICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQID0ge307XG4gICAgT2JqZWN0LmtleXMoZXhwb3J0cy5NRVRIT0RfTUFQKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICgvXkgvLnRlc3Qoa2V5KSkge1xuICAgICAgICBleHBvcnRzLkhfTUVUSE9EX01BUFtrZXldID0gZXhwb3J0cy5NRVRIT0RfTUFQW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIEZJTklTSDtcbiAgICAoZnVuY3Rpb24oRklOSVNIMikge1xuICAgICAgRklOSVNIMltGSU5JU0gyW1wiU0FGRVwiXSA9IDBdID0gXCJTQUZFXCI7XG4gICAgICBGSU5JU0gyW0ZJTklTSDJbXCJTQUZFX1dJVEhfQ0JcIl0gPSAxXSA9IFwiU0FGRV9XSVRIX0NCXCI7XG4gICAgICBGSU5JU0gyW0ZJTklTSDJbXCJVTlNBRkVcIl0gPSAyXSA9IFwiVU5TQUZFXCI7XG4gICAgfSkoRklOSVNIID0gZXhwb3J0cy5GSU5JU0ggfHwgKGV4cG9ydHMuRklOSVNIID0ge30pKTtcbiAgICBleHBvcnRzLkFMUEhBID0gW107XG4gICAgZm9yIChsZXQgaSA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7IGkgPD0gXCJaXCIuY2hhckNvZGVBdCgwKTsgaSsrKSB7XG4gICAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG4gICAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpKTtcbiAgICB9XG4gICAgZXhwb3J0cy5OVU1fTUFQID0ge1xuICAgICAgMDogMCxcbiAgICAgIDE6IDEsXG4gICAgICAyOiAyLFxuICAgICAgMzogMyxcbiAgICAgIDQ6IDQsXG4gICAgICA1OiA1LFxuICAgICAgNjogNixcbiAgICAgIDc6IDcsXG4gICAgICA4OiA4LFxuICAgICAgOTogOVxuICAgIH07XG4gICAgZXhwb3J0cy5IRVhfTUFQID0ge1xuICAgICAgMDogMCxcbiAgICAgIDE6IDEsXG4gICAgICAyOiAyLFxuICAgICAgMzogMyxcbiAgICAgIDQ6IDQsXG4gICAgICA1OiA1LFxuICAgICAgNjogNixcbiAgICAgIDc6IDcsXG4gICAgICA4OiA4LFxuICAgICAgOTogOSxcbiAgICAgIEE6IDEwLFxuICAgICAgQjogMTEsXG4gICAgICBDOiAxMixcbiAgICAgIEQ6IDEzLFxuICAgICAgRTogMTQsXG4gICAgICBGOiAxNSxcbiAgICAgIGE6IDEwLFxuICAgICAgYjogMTEsXG4gICAgICBjOiAxMixcbiAgICAgIGQ6IDEzLFxuICAgICAgZTogMTQsXG4gICAgICBmOiAxNVxuICAgIH07XG4gICAgZXhwb3J0cy5OVU0gPSBbXG4gICAgICBcIjBcIixcbiAgICAgIFwiMVwiLFxuICAgICAgXCIyXCIsXG4gICAgICBcIjNcIixcbiAgICAgIFwiNFwiLFxuICAgICAgXCI1XCIsXG4gICAgICBcIjZcIixcbiAgICAgIFwiN1wiLFxuICAgICAgXCI4XCIsXG4gICAgICBcIjlcIlxuICAgIF07XG4gICAgZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuQUxQSEEuY29uY2F0KGV4cG9ydHMuTlVNKTtcbiAgICBleHBvcnRzLk1BUksgPSBbXCItXCIsIFwiX1wiLCBcIi5cIiwgXCIhXCIsIFwiflwiLCBcIipcIiwgXCInXCIsIFwiKFwiLCBcIilcIl07XG4gICAgZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuQUxQSEFOVU0uY29uY2F0KGV4cG9ydHMuTUFSSykuY29uY2F0KFtcIiVcIiwgXCI7XCIsIFwiOlwiLCBcIiZcIiwgXCI9XCIsIFwiK1wiLCBcIiRcIiwgXCIsXCJdKTtcbiAgICBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IFtcbiAgICAgIFwiIVwiLFxuICAgICAgJ1wiJyxcbiAgICAgIFwiJFwiLFxuICAgICAgXCIlXCIsXG4gICAgICBcIiZcIixcbiAgICAgIFwiJ1wiLFxuICAgICAgXCIoXCIsXG4gICAgICBcIilcIixcbiAgICAgIFwiKlwiLFxuICAgICAgXCIrXCIsXG4gICAgICBcIixcIixcbiAgICAgIFwiLVwiLFxuICAgICAgXCIuXCIsXG4gICAgICBcIi9cIixcbiAgICAgIFwiOlwiLFxuICAgICAgXCI7XCIsXG4gICAgICBcIjxcIixcbiAgICAgIFwiPVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIkBcIixcbiAgICAgIFwiW1wiLFxuICAgICAgXCJcXFxcXCIsXG4gICAgICBcIl1cIixcbiAgICAgIFwiXlwiLFxuICAgICAgXCJfXCIsXG4gICAgICBcImBcIixcbiAgICAgIFwie1wiLFxuICAgICAgXCJ8XCIsXG4gICAgICBcIn1cIixcbiAgICAgIFwiflwiXG4gICAgXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG4gICAgZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSLmNvbmNhdChbXCJcdFwiLCBcIlxcZlwiXSk7XG4gICAgZm9yIChsZXQgaSA9IDEyODsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgZXhwb3J0cy5VUkxfQ0hBUi5wdXNoKGkpO1xuICAgIH1cbiAgICBleHBvcnRzLkhFWCA9IGV4cG9ydHMuTlVNLmNvbmNhdChbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIl0pO1xuICAgIGV4cG9ydHMuU1RSSUNUX1RPS0VOID0gW1xuICAgICAgXCIhXCIsXG4gICAgICBcIiNcIixcbiAgICAgIFwiJFwiLFxuICAgICAgXCIlXCIsXG4gICAgICBcIiZcIixcbiAgICAgIFwiJ1wiLFxuICAgICAgXCIqXCIsXG4gICAgICBcIitcIixcbiAgICAgIFwiLVwiLFxuICAgICAgXCIuXCIsXG4gICAgICBcIl5cIixcbiAgICAgIFwiX1wiLFxuICAgICAgXCJgXCIsXG4gICAgICBcInxcIixcbiAgICAgIFwiflwiXG4gICAgXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG4gICAgZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOLmNvbmNhdChbXCIgXCJdKTtcbiAgICBleHBvcnRzLkhFQURFUl9DSEFSUyA9IFtcIlx0XCJdO1xuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDEyNykge1xuICAgICAgICBleHBvcnRzLkhFQURFUl9DSEFSUy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUy5maWx0ZXIoKGMpID0+IGMgIT09IDQ0KTtcbiAgICBleHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuICAgIGV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SO1xuICAgIHZhciBIRUFERVJfU1RBVEU7XG4gICAgKGZ1bmN0aW9uKEhFQURFUl9TVEFURTIpIHtcbiAgICAgIEhFQURFUl9TVEFURTJbSEVBREVSX1NUQVRFMltcIkdFTkVSQUxcIl0gPSAwXSA9IFwiR0VORVJBTFwiO1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiQ09OTkVDVElPTlwiXSA9IDFdID0gXCJDT05ORUNUSU9OXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJDT05URU5UX0xFTkdUSFwiXSA9IDJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAzXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICAgIEhFQURFUl9TVEFURTJbSEVBREVSX1NUQVRFMltcIlVQR1JBREVcIl0gPSA0XSA9IFwiVVBHUkFERVwiO1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gNV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiQ09OTkVDVElPTl9DTE9TRVwiXSA9IDZdID0gXCJDT05ORUNUSU9OX0NMT1NFXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJDT05ORUNUSU9OX1VQR1JBREVcIl0gPSA3XSA9IFwiQ09OTkVDVElPTl9VUEdSQURFXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCJdID0gOF0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIjtcbiAgICB9KShIRUFERVJfU1RBVEUgPSBleHBvcnRzLkhFQURFUl9TVEFURSB8fCAoZXhwb3J0cy5IRUFERVJfU1RBVEUgPSB7fSkpO1xuICAgIGV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0ge1xuICAgICAgXCJjb25uZWN0aW9uXCI6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICAgXCJjb250ZW50LWxlbmd0aFwiOiBIRUFERVJfU1RBVEUuQ09OVEVOVF9MRU5HVEgsXG4gICAgICBcInByb3h5LWNvbm5lY3Rpb25cIjogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgICBcInRyYW5zZmVyLWVuY29kaW5nXCI6IEhFQURFUl9TVEFURS5UUkFOU0ZFUl9FTkNPRElORyxcbiAgICAgIFwidXBncmFkZVwiOiBIRUFERVJfU1RBVEUuVVBHUkFERVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLndhc20uanNcbnZhciByZXF1aXJlX2xsaHR0cF93YXNtID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC53YXNtLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFwiQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF6azRBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBWUdBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBQUFCQVFjQUFBVUZBQU1FQlFGd0FRNE9CUU1CQUFJR0NBRi9BVUdBdUFRTEIvVUVId1p0WlcxdmNua0NBQXRmYVc1cGRHbGhiR2w2WlFBSkdWOWZhVzVrYVhKbFkzUmZablZ1WTNScGIyNWZkR0ZpYkdVQkFBdHNiR2gwZEhCZmFXNXBkQUFLR0d4c2FIUjBjRjl6YUc5MWJHUmZhMlZsY0Y5aGJHbDJaUUExREd4c2FIUjBjRjloYkd4dll3QU1CbTFoYkd4dll3QTZDMnhzYUhSMGNGOW1jbVZsQUEwRVpuSmxaUUE4RDJ4c2FIUjBjRjluWlhSZmRIbHdaUUFPRld4c2FIUjBjRjluWlhSZmFIUjBjRjl0WVdwdmNnQVBGV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRhVzV2Y2dBUUVXeHNhSFIwY0Y5blpYUmZiV1YwYUc5a0FCRVdiR3hvZEhSd1gyZGxkRjl6ZEdGMGRYTmZZMjlrWlFBU0VteHNhSFIwY0Y5blpYUmZkWEJuY21Ga1pRQVRER3hzYUhSMGNGOXlaWE5sZEFBVURteHNhSFIwY0Y5bGVHVmpkWFJsQUJVVWJHeG9kSFJ3WDNObGRIUnBibWR6WDJsdWFYUUFGZzFzYkdoMGRIQmZabWx1YVhOb0FCY01iR3hvZEhSd1gzQmhkWE5sQUJnTmJHeG9kSFJ3WDNKbGMzVnRaUUFaRzJ4c2FIUjBjRjl5WlhOMWJXVmZZV1owWlhKZmRYQm5jbUZrWlFBYUVHeHNhSFIwY0Y5blpYUmZaWEp5Ym04QUd4ZHNiR2gwZEhCZloyVjBYMlZ5Y205eVgzSmxZWE52YmdBY0YyeHNhSFIwY0Y5elpYUmZaWEp5YjNKZmNtVmhjMjl1QUIwVWJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5d2IzTUFIaEZzYkdoMGRIQmZaWEp5Ym05ZmJtRnRaUUFmRW14c2FIUjBjRjl0WlhSb2IyUmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSVliR3hvZEhSd1gyMWxjM05oWjJWZmJtVmxaSE5mWlc5bUFETUpFd0VBUVFFTERRRUNBd1FGQ3dZSExpb29KQ1lLeHFnQ09BSUFDd2dBRUlpQWdJQUFDeGtBSUFBUXRvQ0FnQUFhSUFBZ0FqWUNOQ0FBSUFFNkFDZ0xIQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQzFnSUNBQUJDQWdJQ0FBQXNwQVFGL1FUZ1F1b0NBZ0FBaUFSQzJnSUNBQUJvZ0FVR0FpSUNBQURZQ05DQUJJQUE2QUNnZ0FRc0tBQ0FBRUx5QWdJQUFDd2NBSUFBdEFDZ0xCd0FnQUMwQUtnc0hBQ0FBTFFBckN3Y0FJQUF0QUNrTEJ3QWdBQzhCTWdzSEFDQUFMUUF1QzBVQkJIOGdBQ2dDR0NFQklBQXRBQzBoQWlBQUxRQW9JUU1nQUNnQ05DRUVJQUFRdG9DQWdBQWFJQUFnQkRZQ05DQUFJQU02QUNnZ0FDQUNPZ0F0SUFBZ0FUWUNHQXNSQUNBQUlBRWdBU0FDYWhDM2dJQ0FBQXRGQUNBQVFnQTNBZ0FnQUVFd2FrSUFOd0lBSUFCQktHcENBRGNDQUNBQVFTQnFRZ0EzQWdBZ0FFRVlha0lBTndJQUlBQkJFR3BDQURjQ0FDQUFRUWhxUWdBM0FnQUxad0VCZjBFQUlRRUNRQ0FBS0FJTURRQUNRQUpBQWtBQ1FDQUFMUUF2RGdNQkFBTUNDeUFBS0FJMElnRkZEUUFnQVNnQ0hDSUJSUTBBSUFBZ0FSR0FnSUNBQUFBaUFRMERDMEVBRHdzUXY0Q0FnQUFBQ3lBQVFmK1JnSUFBTmdJUVFRNGhBUXNnQVFzZUFBSkFJQUFvQWd3TkFDQUFRWVNVZ0lBQU5nSVFJQUJCRlRZQ0RBc0xGZ0FDUUNBQUtBSU1RUlZIRFFBZ0FFRUFOZ0lNQ3dzV0FBSkFJQUFvQWd4QkZrY05BQ0FBUVFBMkFnd0xDd2NBSUFBb0Fnd0xCd0FnQUNnQ0VBc0pBQ0FBSUFFMkFoQUxCd0FnQUNnQ0ZBc2lBQUpBSUFCQkdra05BQkMvZ0lDQUFBQUxJQUJCQW5SQnlKdUFnQUJxS0FJQUN5SUFBa0FnQUVFdVNRMEFFTCtBZ0lBQUFBc2dBRUVDZEVHd25JQ0FBR29vQWdBTEZnQWdBQ0FBTFFBdFFmNEJjU0FCUVFCSGNqb0FMUXNaQUNBQUlBQXRBQzFCL1FGeElBRkJBRWRCQVhSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaeU9nSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUlvSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUhTaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0xDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjNaT0FnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BakFpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRY09RZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJMElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NIQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkIwb2lBZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWlBaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUw4Z0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkJDSEVOQUFKQUlBUkJnQVJ4UlEwQUFrQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNuRU5BRUVGRHd0QkJBOExBa0FnQkVFZ2NRMEFBa0FnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUdjZjJwQjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFRUVFoQlNBRVFZZ0VjVUdBQkVZTkFpQUVRU2h4UlEwQ0MwRUFEd3RCQUVFRElBQXBBeUJRR3lFRkN5QUZDMTBCQW45QkFDRUJBa0FnQUMwQUtFRUJSZzBBSUFBdkFUSWlBa0djZjJwQjVBQkpEUUFnQWtITUFVWU5BQ0FDUWJBQ1JnMEFJQUF2QVRBaUFFSEFBSEVOQUVFQklRRWdBRUdJQkhGQmdBUkdEUUFnQUVFb2NVVWhBUXNnQVF1aUFRRURmd0pBQWtBQ1FDQUFMUUFxUlEwQUlBQXRBQ3RGRFFCQkFDRURJQUF2QVRBaUJFRUNjVVVOQVF3Q0MwRUFJUU1nQUM4Qk1DSUVRUUZ4UlEwQkMwRUJJUU1nQUMwQUtFRUJSZzBBSUFBdkFUSWlCVUdjZjJwQjVBQkpEUUFnQlVITUFVWU5BQ0FGUWJBQ1JnMEFJQVJCd0FCeERRQkJBQ0VESUFSQmlBUnhRWUFFUmcwQUlBUkJLSEZCQUVjaEF3c2dBRUVBT3dFd0lBQkJBRG9BTHlBREM1UUJBUUovQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFFRUFJUUVnQUM4Qk1DSUNRUUp4UlEwQkRBSUxRUUFoQVNBQUx3RXdJZ0pCQVhGRkRRRUxRUUVoQVNBQUxRQW9RUUZHRFFBZ0FDOEJNaUlBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzA4QUlBQkJHR3BDQURjREFDQUFRZ0EzQXdBZ0FFRXdha0lBTndNQUlBQkJLR3BDQURjREFDQUFRU0JxUWdBM0F3QWdBRUVRYWtJQU53TUFJQUJCQ0dwQ0FEY0RBQ0FBUWJ3Qk5nSWNRUUFMZXdFQmZ3SkFJQUFvQWd3aUF3MEFBa0FnQUNnQ0JFVU5BQ0FBSUFFMkFnUUxBa0FnQUNBQklBSVF1SUNBZ0FBaUF3MEFJQUFvQWd3UEN5QUFJQU0yQWh4QkFDRURJQUFvQWdRaUFVVU5BQ0FBSUFFZ0FpQUFLQUlJRVlHQWdJQUFBQ0lCUlEwQUlBQWdBallDRkNBQUlBRTJBZ3dnQVNFREN5QURDOVBPQVFNY2Z3TitCWDhqZ0lDQWdBQkJFR3NpQXlTQWdJQ0FBQ0FCSVFRZ0FTRUZJQUVoQmlBQklRY2dBU0VJSUFFaENTQUJJUW9nQVNFTElBRWhEQ0FCSVEwZ0FTRU9JQUVoRHlBQklSQWdBU0VSSUFFaEVpQUJJUk1nQVNFVUlBRWhGU0FCSVJZZ0FTRVhJQUVoR0NBQklSa2dBU0VhSUFFaEd5QUJJUndnQVNFZEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FDZ0NIQ0llUVg5cURyd0J0d0VCdGdFQ0F3UUZCZ2NJQ1FvTERBME9EeERBQWI4QkVSSVR0UUVVRlJZWEdCa2F2UUc4QVJzY0hSNGZJQ0cwQWJNQklpT3lBYkVCSkNVbUp5Z3BLaXNzTFM0dk1ERXlNelExTmpjNE9UcTRBVHM4UFQ0L1FFRkNRMFJGUmtkSVNVcExURTFPVDFCUlVsTlVWVlpYV0ZsYVcxeGRYbDlnWVdKalpHVm1aMmhwYW10c2JXNXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2Y0QUJnUUdDQVlNQmhBR0ZBWVlCaHdHSUFZa0JpZ0dMQVl3QmpRR09BWThCa0FHUkFaSUJrd0dVQVpVQmxnR1hBWmdCbVFHYUFac0JuQUdkQVo0Qm53R2dBYUVCb2dHakFhUUJwUUdtQWFjQnFBR3BBYW9CcXdHc0FhMEJyZ0d2QVFDNUFRdEJBQ0VlREs4QkMwRVBJUjRNcmdFTFFRNGhIZ3l0QVF0QkVDRWVES3dCQzBFUklSNE1xd0VMUVJRaEhneXFBUXRCRlNFZURLa0JDMEVXSVI0TXFBRUxRUmNoSGd5bkFRdEJHQ0VlREtZQkMwRUlJUjRNcFFFTFFSa2hIZ3lrQVF0QkdpRWVES01CQzBFVElSNE1vZ0VMUVJJaEhneWhBUXRCR3lFZURLQUJDMEVjSVI0TW53RUxRUjBoSGd5ZUFRdEJIaUVlREowQkMwR3FBU0VlREp3QkMwR3JBU0VlREpzQkMwRWdJUjRNbWdFTFFTRWhIZ3laQVF0QklpRWVESmdCQzBFaklSNE1sd0VMUVNRaEhneVdBUXRCclFFaEhneVZBUXRCSlNFZURKUUJDMEVwSVI0TWt3RUxRUTBoSGd5U0FRdEJKaUVlREpFQkMwRW5JUjRNa0FFTFFTZ2hIZ3lQQVF0QkxpRWVESTRCQzBFcUlSNE1qUUVMUWE0QklSNE1qQUVMUVF3aEhneUxBUXRCTHlFZURJb0JDMEVySVI0TWlRRUxRUXNoSGd5SUFRdEJMQ0VlREljQkMwRXRJUjRNaGdFTFFRb2hIZ3lGQVF0Qk1TRWVESVFCQzBFd0lSNE1nd0VMUVFraEhneUNBUXRCSHlFZURJRUJDMEV5SVI0TWdBRUxRVE1oSGd4L0MwRTBJUjRNZmd0Qk5TRWVESDBMUVRZaEhneDhDMEUzSVI0TWV3dEJPQ0VlREhvTFFUa2hIZ3g1QzBFNklSNE1lQXRCckFFaEhneDNDMEU3SVI0TWRndEJQQ0VlREhVTFFUMGhIZ3gwQzBFK0lSNE1jd3RCUHlFZURISUxRY0FBSVI0TWNRdEJ3UUFoSGd4d0MwSENBQ0VlREc4TFFjTUFJUjRNYmd0QnhBQWhIZ3h0QzBFSElSNE1iQXRCeFFBaEhneHJDMEVHSVI0TWFndEJ4Z0FoSGd4cEMwRUZJUjRNYUF0Qnh3QWhIZ3huQzBFRUlSNE1aZ3RCeUFBaEhneGxDMEhKQUNFZURHUUxRY29BSVI0TVl3dEJ5d0FoSGd4aUMwRURJUjRNWVF0QnpBQWhIZ3hnQzBITkFDRWVERjhMUWM0QUlSNE1YZ3RCMEFBaEhneGRDMEhQQUNFZURGd0xRZEVBSVI0TVd3dEIwZ0FoSGd4YUMwRUNJUjRNV1F0QjB3QWhIZ3hZQzBIVUFDRWVERmNMUWRVQUlSNE1WZ3RCMWdBaEhneFZDMEhYQUNFZURGUUxRZGdBSVI0TVV3dEIyUUFoSGd4U0MwSGFBQ0VlREZFTFFkc0FJUjRNVUF0QjNBQWhIZ3hQQzBIZEFDRWVERTRMUWQ0QUlSNE1UUXRCM3dBaEhneE1DMEhnQUNFZURFc0xRZUVBSVI0TVNndEI0Z0FoSGd4SkMwSGpBQ0VlREVnTFFlUUFJUjRNUnd0QjVRQWhIZ3hHQzBIbUFDRWVERVVMUWVjQUlSNE1SQXRCNkFBaEhneERDMEhwQUNFZURFSUxRZW9BSVI0TVFRdEI2d0FoSGd4QUMwSHNBQ0VlREQ4TFFlMEFJUjRNUGd0QjdnQWhIZ3c5QzBIdkFDRWVERHdMUWZBQUlSNE1Pd3RCOFFBaEhndzZDMEh5QUNFZUREa0xRZk1BSVI0TU9BdEI5QUFoSGd3M0MwSDFBQ0VlRERZTFFmWUFJUjRNTlF0Qjl3QWhIZ3cwQzBINEFDRWVERE1MUWZrQUlSNE1NZ3RCK2dBaEhnd3hDMEg3QUNFZUREQUxRZndBSVI0TUx3dEIvUUFoSGd3dUMwSCtBQ0VlREMwTFFmOEFJUjRNTEF0QmdBRWhIZ3dyQzBHQkFTRWVEQ29MUVlJQklSNE1LUXRCZ3dFaEhnd29DMEdFQVNFZURDY0xRWVVCSVI0TUpndEJoZ0VoSGd3bEMwR0hBU0VlRENRTFFZZ0JJUjRNSXd0QmlRRWhIZ3dpQzBHS0FTRWVEQ0VMUVlzQklSNE1JQXRCakFFaEhnd2ZDMEdOQVNFZURCNExRWTRCSVI0TUhRdEJqd0VoSGd3Y0MwR1FBU0VlREJzTFFaRUJJUjRNR2d0QmtnRWhIZ3daQzBHVEFTRWVEQmdMUVpRQklSNE1Gd3RCbFFFaEhnd1dDMEdXQVNFZURCVUxRWmNCSVI0TUZBdEJtQUVoSGd3VEMwR1pBU0VlREJJTFFaMEJJUjRNRVF0Qm1nRWhIZ3dRQzBFQklSNE1Ed3RCbXdFaEhnd09DMEdjQVNFZURBMExRWjRCSVI0TURBdEJvQUVoSGd3TEMwR2ZBU0VlREFvTFFhRUJJUjRNQ1F0Qm9nRWhIZ3dJQzBHakFTRWVEQWNMUWFRQklSNE1CZ3RCcFFFaEhnd0ZDMEdtQVNFZURBUUxRYWNCSVI0TUF3dEJxQUVoSGd3Q0MwR3BBU0VlREFFTFFhOEJJUjRMQTBBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnSGc2d0FRQUJBZ01FQlFZSENBa0tDd3dORGc4UUVSSVRGQlVXRnhnYUhCNGZJQ01rSlNZbktDa3FMQzB1THpEN0FqUTJPRGs4UDBGQ1EwUkZSa2RJU1VwTFRFMU9UMUJSVWxOVlYxbGNYVjVnWW1Oa1pXWm5hR3RzYlc1dmNIRnljM1IxZG5kNGVYcDdmSDErZjRBQmdRR0NBWU1CaEFHRkFZWUJod0dJQVlrQmlnR0xBWXdCalFHT0FZOEJrQUdSQVpJQmt3R1VBWlVCbGdHWEFaZ0JtUUdhQVpzQm5BR2RBWjRCbndHZ0FhRUJvZ0dqQWFRQnBRR21BYWNCcUFHcEFhb0Jxd0dzQWEwQnJnR3ZBYkFCc1FHeUFiUUJ0UUcyQWJjQnVBRzVBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBZG9CNEFIaEFlUUI4UUc5QXIwQ0N5QUJJZ2dnQWtjTndnRkJ2QUVoSGd5VkF3c2dBU0llSUFKSERiRUJRYXdCSVI0TWxBTUxJQUVpQVNBQ1J3MW5RZUlBSVI0TWt3TUxJQUVpQVNBQ1J3MWRRZG9BSVI0TWtnTUxJQUVpQVNBQ1J3MVdRZFVBSVI0TWtRTUxJQUVpQVNBQ1J3MVNRZE1BSVI0TWtBTUxJQUVpQVNBQ1J3MVBRZEVBSVI0TWp3TUxJQUVpQVNBQ1J3MU1RYzhBSVI0TWpnTUxJQUVpQVNBQ1J3MFFRUXdoSGd5TkF3c2dBU0lCSUFKSERUTkJPQ0VlREl3REN5QUJJZ0VnQWtjTkwwRTFJUjRNaXdNTElBRWlBU0FDUncwbVFUSWhIZ3lLQXdzZ0FTSUJJQUpIRFNSQkx5RWVESWtEQ3lBQklnRWdBa2NOSFVFa0lSNE1pQU1MSUFBdEFDNUJBVVlOL1FJTXh3RUxJQUFnQVNJQklBSVF0SUNBZ0FCQkFVY050QUVNdFFFTElBQWdBU0lCSUFJUXJZQ0FnQUFpSGcyMUFTQUJJUUVNc0FJTEFrQWdBU0lCSUFKSERRQkJCaUVlRElVREN5QUFJQUZCQVdvaUFTQUNFTENBZ0lBQUloNE50Z0VnQVNFQkRBOExJQUJDQURjRElFRVRJUjRNOHdJTElBRWlIaUFDUncwSlFROGhIZ3lDQXdzQ1FDQUJJZ0VnQWtZTkFDQUJRUUZxSVFGQkVTRWVEUElDQzBFSElSNE1nUU1MSUFCQ0FDQUFLUU1nSWg4Z0FpQUJJaDVyclNJZ2ZTSWhJQ0VnSDFZYk53TWdJQjhnSUZZaUlrVU5zd0ZCQ0NFZURJQURDd0pBSUFFaUFTQUNSZzBBSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVRVZJUjRNOEFJTFFRa2hIZ3ovQWdzZ0FTRUJJQUFwQXlCUURiSUJJQUVoQVF5dEFnc0NRQ0FCSWdFZ0FrY05BRUVMSVI0TS9nSUxJQUFnQVVFQmFpSUJJQUlRcjRDQWdBQWlIZzJ5QVNBQklRRU1yUUlMQTBBQ1FDQUJMUUFBUWZDZGdJQUFhaTBBQUNJZVFRRkdEUUFnSGtFQ1J3MjBBU0FCUVFGcUlRRU1Bd3NnQVVFQmFpSUJJQUpIRFFBTFFRd2hIZ3o4QWdzQ1FDQUJJZ0VnQWtjTkFFRU5JUjRNL0FJTEFrQUNRQ0FCTFFBQUloNUJjMm9PRkFHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCdGdHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCdGdFQXRBRUxJQUZCQVdvaEFReTBBUXNnQVVFQmFpRUJDMEVZSVI0TTZnSUxBa0FnQVNJZUlBSkhEUUJCRGlFZURQb0NDMElBSVI4Z0hpRUJBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBZUxRQUFRVkJxRGpmSUFjY0JBQUVDQXdRRkJnZStBcjRDdmdLK0FyNEN2Z0srQWdnSkNnc01EYjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSU9EeEFSRWhPK0FndENBaUVmRE1jQkMwSURJUjhNeGdFTFFnUWhId3pGQVF0Q0JTRWZETVFCQzBJR0lSOE13d0VMUWdjaEh3ekNBUXRDQ0NFZkRNRUJDMElKSVI4TXdBRUxRZ29oSHd5L0FRdENDeUVmREw0QkMwSU1JUjhNdlFFTFFnMGhId3k4QVF0Q0RpRWZETHNCQzBJUElSOE11Z0VMUWdvaEh3eTVBUXRDQ3lFZkRMZ0JDMElNSVI4TXR3RUxRZzBoSHd5MkFRdENEaUVmRExVQkMwSVBJUjhNdEFFTFFnQWhId0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0hpMEFBRUZRYWc0M3h3SEdBUUFCQWdNRUJRWUh5QUhJQWNnQnlBSElBY2dCeUFFSUNRb0xEQTNJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0JEZzhRRVJJVHlBRUxRZ0loSHd6R0FRdENBeUVmRE1VQkMwSUVJUjhNeEFFTFFnVWhId3pEQVF0Q0JpRWZETUlCQzBJSElSOE13UUVMUWdnaEh3ekFBUXRDQ1NFZkRMOEJDMElLSVI4TXZnRUxRZ3NoSHd5OUFRdENEQ0VmREx3QkMwSU5JUjhNdXdFTFFnNGhId3k2QVF0Q0R5RWZETGtCQzBJS0lSOE11QUVMUWdzaEh3eTNBUXRDRENFZkRMWUJDMElOSVI4TXRRRUxRZzRoSHd5MEFRdENEeUVmRExNQkN5QUFRZ0FnQUNrRElDSWZJQUlnQVNJZWE2MGlJSDBpSVNBaElCOVdHemNESUNBZklDQldJaUpGRGJRQlFSRWhIZ3ozQWdzQ1FDQUJJZ0VnQWtZTkFDQUFRWW1BZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCR3lFZURPY0NDMEVTSVI0TTlnSUxJQUFnQVNJZUlBSVFzb0NBZ0FCQmYyb09CYVlCQUtJQ0FiTUJ0QUVMUVJJaEhnemtBZ3NnQUVFQk9nQXZJQjRoQVF6eUFnc2dBU0lCSUFKSERiUUJRUlloSGd6eUFnc2dBU0ljSUFKSERSbEJPU0VlRFBFQ0N3SkFJQUVpQVNBQ1J3MEFRUm9oSGd6eEFnc2dBRUVBTmdJRUlBQkJpb0NBZ0FBMkFnZ2dBQ0FCSUFFUXFvQ0FnQUFpSGcyMkFTQUJJUUVNdVFFTEFrQWdBU0llSUFKSERRQkJHeUVlRFBBQ0N3SkFJQjR0QUFBaUFVRWdSdzBBSUI1QkFXb2hBUXdhQ3lBQlFRbEhEYllCSUI1QkFXb2hBUXdaQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVF3VUMwRWNJUjRNN2dJTEFrQWdBU0llSUFKSERRQkJIU0VlRE80Q0N3SkFJQjR0QUFBaUFVRUpSdzBBSUI0aEFRelNBZ3NnQVVFZ1J3MjFBU0FlSVFFTTBRSUxBa0FnQVNJQklBSkhEUUJCSGlFZURPMENDeUFCTFFBQVFRcEhEYmdCSUFGQkFXb2hBUXlnQWdzZ0FTSUJJQUpIRGJnQlFTSWhIZ3pyQWdzRFFBSkFJQUV0QUFBaUhrRWdSZzBBQWtBZ0hrRjJhZzRFQUw0QnZnRUF2QUVMSUFFaEFRekVBUXNnQVVFQmFpSUJJQUpIRFFBTFFTUWhIZ3pxQWd0QkpTRWVJQUVpSXlBQ1JnM3BBaUFDSUNOcklBQW9BZ0FpSkdvaEpTQWpJU1lnSkNFQkFrQURRQ0FtTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFmQ2ZnSUFBYWkwQUFFY05BU0FCUVFOR0RkWUNJQUZCQVdvaEFTQW1RUUZxSWlZZ0FrY05BQXNnQUNBbE5nSUFET29DQ3lBQVFRQTJBZ0FnSmlFQkRMc0JDMEVtSVI0Z0FTSWpJQUpHRGVnQ0lBSWdJMnNnQUNnQ0FDSWthaUVsSUNNaEppQWtJUUVDUUFOQUlDWXRBQUFpSWtFZ2NpQWlJQ0pCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCOUorQWdBQnFMUUFBUncwQklBRkJDRVlOdlFFZ0FVRUJhaUVCSUNaQkFXb2lKaUFDUncwQUN5QUFJQ1UyQWdBTTZRSUxJQUJCQURZQ0FDQW1JUUVNdWdFTFFTY2hIaUFCSWlNZ0FrWU41d0lnQWlBamF5QUFLQUlBSWlScUlTVWdJeUVtSUNRaEFRSkFBMEFnSmkwQUFDSWlRU0J5SUNJZ0lrRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVSFFwb0NBQUdvdEFBQkhEUUVnQVVFRlJnMjlBU0FCUVFGcUlRRWdKa0VCYWlJbUlBSkhEUUFMSUFBZ0pUWUNBQXpvQWdzZ0FFRUFOZ0lBSUNZaEFReTVBUXNDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUVHQW9vQ0FBR290QUFBaUhrRUJSZzBBSUI1QkFrWU5DaUFCSVFFTXdRRUxJQUZCQVdvaUFTQUNSdzBBQzBFaklSNE01d0lMUVNNaEhnem1BZ3NDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUNJZVFTQkdEUUFnSGtGMmFnNEV2UUcrQWI0QnZRRytBUXNnQVVFQmFpSUJJQUpIRFFBTFFTc2hIZ3ptQWd0Qkt5RWVET1VDQ3dOQUFrQWdBUzBBQUNJZVFTQkdEUUFnSGtFSlJ3MERDeUFCUVFGcUlnRWdBa2NOQUF0Qkx5RWVET1FDQ3dOQUFrQWdBUzBBQUNJZVFTQkdEUUFDUUFKQUlCNUJkbW9PQkw0QkFRRytBUUFMSUI1QkxFWU52d0VMSUFFaEFRd0VDeUFCUVFGcUlnRWdBa2NOQUF0Qk1pRWVET01DQ3lBQklRRU12d0VMUVRNaEhpQUJJaVlnQWtZTjRRSWdBaUFtYXlBQUtBSUFJaU5xSVNRZ0ppRWlJQ01oQVFKQUEwQWdJaTBBQUVFZ2NpQUJRWUNrZ0lBQWFpMEFBRWNOQVNBQlFRWkdEZEFDSUFGQkFXb2hBU0FpUVFGcUlpSWdBa2NOQUFzZ0FDQWtOZ0lBRE9JQ0N5QUFRUUEyQWdBZ0lpRUJDMEVySVI0TTBBSUxBa0FnQVNJZElBSkhEUUJCTkNFZURPQUNDeUFBUVlxQWdJQUFOZ0lJSUFBZ0hUWUNCQ0FkSVFFZ0FDMEFMRUYvYWc0RXJ3RzVBYnNCdlFISEFnc2dBVUVCYWlFQkRLNEJDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBSWg1QklISWdIaUFlUWI5L2FrSC9BWEZCR2trYlFmOEJjU0llUVFsR0RRQWdIa0VnUmcwQUFrQUNRQUpBQWtBZ0hrR2RmMm9PRXdBREF3TURBd01EQVFNREF3TURBd01EQXdJREN5QUJRUUZxSVFGQkppRWVETk1DQ3lBQlFRRnFJUUZCSnlFZUROSUNDeUFCUVFGcUlRRkJLQ0VlRE5FQ0N5QUJJUUVNc2dFTElBRkJBV29pQVNBQ1J3MEFDMEVvSVI0TTNnSUxRU2doSGd6ZEFnc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBRUdBb0lDQUFHb3RBQUJCQVVZTkFDQUJJUUVNdHdFTElBRkJBV29pQVNBQ1J3MEFDMEV3SVI0TTNRSUxRVEFoSGd6Y0Fnc0NRQU5BQWtBZ0FTMEFBRUYzYWc0WUFBTEJBc0VDeHdMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDd1FMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDd1FJQXdRSUxJQUZCQVdvaUFTQUNSdzBBQzBFMUlSNE0zQUlMSUFGQkFXb2hBUXRCSVNFZURNb0NDeUFCSWdFZ0FrY051UUZCTnlFZUROa0NDd05BQWtBZ0FTMEFBRUdRcElDQUFHb3RBQUJCQVVZTkFDQUJJUUVNa0FJTElBRkJBV29pQVNBQ1J3MEFDMEU0SVI0TTJBSUxJQnd0QUFBaUhrRWdSZzJhQVNBZVFUcEhEY1lDSUFBb0FnUWhBU0FBUVFBMkFnUWdBQ0FCSUJ3UXFJQ0FnQUFpQVEyMkFTQWNRUUZxSVFFTXVBRUxJQUFnQVNBQ0VLbUFnSUFBR2d0QkNpRWVETVVDQzBFNklSNGdBU0ltSUFKR0RkUUNJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhIQ0FqSVFFQ1FBTkFJQnd0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQmtLYUFnQUJxTFFBQVJ3M0VBaUFCUVFWR0RRRWdBVUVCYWlFQklCeEJBV29pSENBQ1J3MEFDeUFBSUNRMkFnQU0xUUlMSUFCQkFEWUNBQ0FBUVFFNkFDd2dKaUFqYTBFR2FpRUJETDRDQzBFN0lSNGdBU0ltSUFKR0RkTUNJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhIQ0FqSVFFQ1FBTkFJQnd0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQmxxYUFnQUJxTFFBQVJ3M0RBaUFCUVFsR0RRRWdBVUVCYWlFQklCeEJBV29pSENBQ1J3MEFDeUFBSUNRMkFnQU0xQUlMSUFCQkFEWUNBQ0FBUVFJNkFDd2dKaUFqYTBFS2FpRUJETDBDQ3dKQUlBRWlIQ0FDUncwQVFUd2hIZ3pUQWdzQ1FBSkFJQnd0QUFBaUFVRWdjaUFCSUFGQnYzOXFRZjhCY1VFYVNSdEIvd0Z4UVpKL2FnNEhBTU1Dd3dMREFzTUN3d0lCd3dJTElCeEJBV29oQVVFeUlSNE13d0lMSUJ4QkFXb2hBVUV6SVI0TXdnSUxRVDBoSGlBQklpWWdBa1lOMFFJZ0FpQW1heUFBS0FJQUlpTnFJU1FnSmlFY0lDTWhBUU5BSUJ3dEFBQWlJa0VnY2lBaUlDSkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvS2FBZ0FCcUxRQUFSdzNBQWlBQlFRRkdEYlFDSUFGQkFXb2hBU0FjUVFGcUlod2dBa2NOQUFzZ0FDQWtOZ0lBRE5FQ0MwRStJUjRnQVNJbUlBSkdEZEFDSUFJZ0ptc2dBQ2dDQUNJamFpRWtJQ1loSENBaklRRUNRQU5BSUJ3dEFBQWlJa0VnY2lBaUlDSkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvcWFBZ0FCcUxRQUFSdzNBQWlBQlFRNUdEUUVnQVVFQmFpRUJJQnhCQVdvaUhDQUNSdzBBQ3lBQUlDUTJBZ0FNMFFJTElBQkJBRFlDQUNBQVFRRTZBQ3dnSmlBamEwRVBhaUVCRExvQ0MwRS9JUjRnQVNJbUlBSkdEYzhDSUFJZ0ptc2dBQ2dDQUNJamFpRWtJQ1loSENBaklRRUNRQU5BSUJ3dEFBQWlJa0VnY2lBaUlDSkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJ3S2FBZ0FCcUxRQUFSdzIvQWlBQlFROUdEUUVnQVVFQmFpRUJJQnhCQVdvaUhDQUNSdzBBQ3lBQUlDUTJBZ0FNMEFJTElBQkJBRFlDQUNBQVFRTTZBQ3dnSmlBamEwRVFhaUVCRExrQ0MwSEFBQ0VlSUFFaUppQUNSZzNPQWlBQ0lDWnJJQUFvQWdBaUkyb2hKQ0FtSVJ3Z0l5RUJBa0FEUUNBY0xRQUFJaUpCSUhJZ0lpQWlRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRZENtZ0lBQWFpMEFBRWNOdmdJZ0FVRUZSZzBCSUFGQkFXb2hBU0FjUVFGcUlod2dBa2NOQUFzZ0FDQWtOZ0lBRE04Q0N5QUFRUUEyQWdBZ0FFRUVPZ0FzSUNZZ0kydEJCbW9oQVF5NEFnc0NRQ0FCSWh3Z0FrY05BRUhCQUNFZURNNENDd0pBQWtBQ1FBSkFJQnd0QUFBaUFVRWdjaUFCSUFGQnYzOXFRZjhCY1VFYVNSdEIvd0Z4UVoxL2FnNFRBTUFDd0FMQUFzQUN3QUxBQXNBQ3dBTEFBc0FDd0FMQUFnSEFBc0FDd0FJQ0E4QUNDeUFjUVFGcUlRRkJOU0VlRE1BQ0N5QWNRUUZxSVFGQk5pRWVETDhDQ3lBY1FRRnFJUUZCTnlFZURMNENDeUFjUVFGcUlRRkJPQ0VlREwwQ0N3SkFJQUVpQVNBQ1JnMEFJQUJCaTRDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFNUlSNE12UUlMUWNJQUlSNE16QUlMSUFFaUFTQUNSdzJ2QVVIRUFDRWVETXNDQzBIRkFDRWVJQUVpSmlBQ1JnM0tBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JU0lnSXlFQkFrQURRQ0FpTFFBQUlBRkIxcWFBZ0FCcUxRQUFSdzIwQVNBQlFRRkdEUUVnQVVFQmFpRUJJQ0pCQVdvaUlpQUNSdzBBQ3lBQUlDUTJBZ0FNeXdJTElBQkJBRFlDQUNBbUlDTnJRUUpxSVFFTXJ3RUxBa0FnQVNJQklBSkhEUUJCeHdBaEhnektBZ3NnQVMwQUFFRUtSdzJ6QVNBQlFRRnFJUUVNcndFTEFrQWdBU0lCSUFKSERRQkJ5QUFoSGd6SkFnc0NRQUpBSUFFdEFBQkJkbW9PQkFHMEFiUUJBTFFCQ3lBQlFRRnFJUUZCUFNFZURMa0NDeUFCUVFGcUlRRU1yZ0VMQWtBZ0FTSUJJQUpIRFFCQnlRQWhIZ3pJQWd0QkFDRWVBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJMUUFBUVZCcURncTdBYm9CQUFFQ0F3UUZCZ2U4QVF0QkFpRWVETG9CQzBFRElSNE11UUVMUVFRaEhneTRBUXRCQlNFZURMY0JDMEVHSVI0TXRnRUxRUWNoSGd5MUFRdEJDQ0VlRExRQkMwRUpJUjRNc3dFTEFrQWdBU0lCSUFKSERRQkJ5Z0FoSGd6SEFnc2dBUzBBQUVFdVJ3MjBBU0FCUVFGcUlRRU1nQUlMQWtBZ0FTSUJJQUpIRFFCQnl3QWhIZ3pHQWd0QkFDRWVBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJMUUFBUVZCcURncTlBYndCQUFFQ0F3UUZCZ2UrQVF0QkFpRWVETHdCQzBFRElSNE11d0VMUVFRaEhneTZBUXRCQlNFZURMa0JDMEVHSVI0TXVBRUxRUWNoSGd5M0FRdEJDQ0VlRExZQkMwRUpJUjRNdFFFTFFjd0FJUjRnQVNJbUlBSkdEY1FDSUFJZ0ptc2dBQ2dDQUNJamFpRWtJQ1loQVNBaklTSURRQ0FCTFFBQUlDSkI0cWFBZ0FCcUxRQUFSdzI0QVNBaVFRTkdEYmNCSUNKQkFXb2hJaUFCUVFGcUlnRWdBa2NOQUFzZ0FDQWtOZ0lBRE1RQ0MwSE5BQ0VlSUFFaUppQUNSZzNEQWlBQ0lDWnJJQUFvQWdBaUkyb2hKQ0FtSVFFZ0l5RWlBMEFnQVMwQUFDQWlRZWFtZ0lBQWFpMEFBRWNOdHdFZ0lrRUNSZzI1QVNBaVFRRnFJU0lnQVVFQmFpSUJJQUpIRFFBTElBQWdKRFlDQUF6REFndEJ6Z0FoSGlBQklpWWdBa1lOd2dJZ0FpQW1heUFBS0FJQUlpTnFJU1FnSmlFQklDTWhJZ05BSUFFdEFBQWdJa0hwcG9DQUFHb3RBQUJIRGJZQklDSkJBMFlOdVFFZ0lrRUJhaUVpSUFGQkFXb2lBU0FDUncwQUN5QUFJQ1EyQWdBTXdnSUxBMEFDUUNBQkxRQUFJaDVCSUVZTkFBSkFBa0FDUUNBZVFiaC9hZzRMQUFHNkFib0J1Z0c2QWJvQnVnRzZBYm9CQXJvQkN5QUJRUUZxSVFGQndnQWhIZ3kxQWdzZ0FVRUJhaUVCUWNNQUlSNE10QUlMSUFGQkFXb2hBVUhFQUNFZURMTUNDeUFCUVFGcUlnRWdBa2NOQUF0Qnp3QWhIZ3pCQWdzQ1FDQUJJZ0VnQWtZTkFDQUFJQUZCQVdvaUFTQUNFS1dBZ0lBQUdpQUJJUUZCQnlFZURMRUNDMEhRQUNFZURNQUNDd05BQWtBZ0FTMEFBRUh3cG9DQUFHb3RBQUFpSGtFQlJnMEFJQjVCZm1vT0E3a0J1Z0c3QWJ3QkN5QUJRUUZxSWdFZ0FrY05BQXRCMFFBaEhneS9BZ3NDUUNBQklnRWdBa1lOQUNBQlFRRnFJUUVNQXd0QjBnQWhIZ3krQWdzRFFBSkFJQUV0QUFCQjhLaUFnQUJxTFFBQUloNUJBVVlOQUFKQUlCNUJmbW9PQkx3QnZRRytBUUMvQVFzZ0FTRUJRY1lBSVI0TXJ3SUxJQUZCQVdvaUFTQUNSdzBBQzBIVEFDRWVETDBDQ3dKQUlBRWlBU0FDUncwQVFkUUFJUjRNdlFJTEFrQWdBUzBBQUNJZVFYWnFEaHFrQWI4QnZ3R21BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYlFCdndHL0FRQzlBUXNnQVVFQmFpRUJDMEVHSVI0TXF3SUxBMEFDUUNBQkxRQUFRZkNxZ0lBQWFpMEFBRUVCUmcwQUlBRWhBUXo2QVFzZ0FVRUJhaUlCSUFKSERRQUxRZFVBSVI0TXVnSUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQU1MUWRZQUlSNE11UUlMQWtBZ0FTSUJJQUpIRFFCQjF3QWhIZ3k1QWdzZ0FVRUJhaUVCREFFTEFrQWdBU0lCSUFKSERRQkIyQUFoSGd5NEFnc2dBVUVCYWlFQkMwRUVJUjRNcGdJTEFrQWdBU0lpSUFKSERRQkIyUUFoSGd5MkFnc2dJaUVCQWtBQ1FBSkFJQ0l0QUFCQjhLeUFnQUJxTFFBQVFYOXFEZ2UrQWI4QndBRUErQUVCQXNFQkN5QWlRUUZxSVFFTUNnc2dJa0VCYWlFQkRMY0JDMEVBSVI0Z0FFRUFOZ0ljSUFCQjhZNkFnQUEyQWhBZ0FFRUhOZ0lNSUFBZ0lrRUJhallDRkF5MUFnc0NRQU5BQWtBZ0FTMEFBRUh3cklDQUFHb3RBQUFpSGtFRVJnMEFBa0FDUUNBZVFYOXFEZ2U4QWIwQnZnSERBUUFFQWNNQkN5QUJJUUZCeVFBaEhneW9BZ3NnQVVFQmFpRUJRY3NBSVI0TXB3SUxJQUZCQVdvaUFTQUNSdzBBQzBIYUFDRWVETFVDQ3lBQlFRRnFJUUVNdFFFTEFrQWdBU0lpSUFKSERRQkIyd0FoSGd5MEFnc2dJaTBBQUVFdlJ3MitBU0FpUVFGcUlRRU1CZ3NDUUNBQklpSWdBa2NOQUVIY0FDRWVETE1DQ3dKQUlDSXRBQUFpQVVFdlJ3MEFJQ0pCQVdvaEFVSE1BQ0VlREtNQ0N5QUJRWFpxSWdGQkZrc052UUZCQVNBQmRFR0pnSUFDY1VVTnZRRU1rd0lMQWtBZ0FTSUJJQUpHRFFBZ0FVRUJhaUVCUWMwQUlSNE1vZ0lMUWQwQUlSNE1zUUlMQWtBZ0FTSWlJQUpIRFFCQjN3QWhIZ3l4QWdzZ0lpRUJBa0FnSWkwQUFFSHdzSUNBQUdvdEFBQkJmMm9PQTVJQzhBRUF2Z0VMUWRBQUlSNE1vQUlMQWtBZ0FTSWlJQUpHRFFBRFFBSkFJQ0l0QUFCQjhLNkFnQUJxTFFBQUlnRkJBMFlOQUFKQUlBRkJmMm9PQXBRQ0FMOEJDeUFpSVFGQnpnQWhIZ3lpQWdzZ0lrRUJhaUlpSUFKSERRQUxRZDRBSVI0TXNBSUxRZDRBSVI0TXJ3SUxBa0FnQVNJQklBSkdEUUFnQUVHTWdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFjOEFJUjRNbndJTFFlQUFJUjRNcmdJTEFrQWdBU0lCSUFKSERRQkI0UUFoSGd5dUFnc2dBRUdNZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCQzBFRElSNE1uQUlMQTBBZ0FTMEFBRUVnUncyTUFpQUJRUUZxSWdFZ0FrY05BQXRCNGdBaEhneXJBZ3NDUUNBQklnRWdBa2NOQUVIakFDRWVES3NDQ3lBQkxRQUFRU0JIRGJnQklBRkJBV29oQVF6VUFRc0NRQ0FCSWdnZ0FrY05BRUhrQUNFZURLb0NDeUFJTFFBQVFjd0FSdzI3QVNBSVFRRnFJUUZCRXlFZURMa0JDMEhsQUNFZUlBRWlJaUFDUmcyb0FpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQTBBZ0NDMEFBQ0FCUWZDeWdJQUFhaTBBQUVjTnVnRWdBVUVGUmcyNEFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSXpZQ0FBeW9BZ3NDUUNBQklnZ2dBa2NOQUVIbUFDRWVES2dDQ3dKQUFrQWdDQzBBQUVHOWYyb09EQUM3QWJzQnV3RzdBYnNCdXdHN0Fic0J1d0c3QVFHN0FRc2dDRUVCYWlFQlFkUUFJUjRNbUFJTElBaEJBV29oQVVIVkFDRWVESmNDQzBIbkFDRWVJQUVpSWlBQ1JnMm1BaUFDSUNKcklBQW9BZ0FpSm1vaEl5QWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkI3Yk9BZ0FCcUxRQUFSdzI1QVNBQlFRSkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNcHdJTElBQkJBRFlDQUNBaUlDWnJRUU5xSVFGQkVDRWVETFlCQzBIb0FDRWVJQUVpSWlBQ1JnMmxBaUFDSUNKcklBQW9BZ0FpSm1vaEl5QWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkI5cktBZ0FCcUxRQUFSdzI0QVNBQlFRVkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNcGdJTElBQkJBRFlDQUNBaUlDWnJRUVpxSVFGQkZpRWVETFVCQzBIcEFDRWVJQUVpSWlBQ1JnMmtBaUFDSUNKcklBQW9BZ0FpSm1vaEl5QWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkIvTEtBZ0FCcUxRQUFSdzIzQVNBQlFRTkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNcFFJTElBQkJBRFlDQUNBaUlDWnJRUVJxSVFGQkJTRWVETFFCQ3dKQUlBRWlDQ0FDUncwQVFlb0FJUjRNcEFJTElBZ3RBQUJCMlFCSERiVUJJQWhCQVdvaEFVRUlJUjRNc3dFTEFrQWdBU0lJSUFKSERRQkI2d0FoSGd5akFnc0NRQUpBSUFndEFBQkJzbjlxRGdNQXRnRUJ0Z0VMSUFoQkFXb2hBVUhaQUNFZURKTUNDeUFJUVFGcUlRRkIyZ0FoSGd5U0Fnc0NRQ0FCSWdnZ0FrY05BRUhzQUNFZURLSUNDd0pBQWtBZ0NDMEFBRUc0ZjJvT0NBQzFBYlVCdFFHMUFiVUJ0UUVCdFFFTElBaEJBV29oQVVIWUFDRWVESklDQ3lBSVFRRnFJUUZCMndBaEhneVJBZ3RCN1FBaEhpQUJJaUlnQWtZTm9BSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFKQUEwQWdDQzBBQUNBQlFZQ3pnSUFBYWkwQUFFY05zd0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFES0VDQzBFQUlSNGdBRUVBTmdJQUlDSWdKbXRCQTJvaEFReXdBUXRCN2dBaEhpQUJJaUlnQWtZTm53SWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFKQUEwQWdDQzBBQUNBQlFZT3pnSUFBYWkwQUFFY05zZ0VnQVVFRVJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFES0FDQ3lBQVFRQTJBZ0FnSWlBbWEwRUZhaUVCUVNNaEhneXZBUXNDUUNBQklnZ2dBa2NOQUVIdkFDRWVESjhDQ3dKQUFrQWdDQzBBQUVHMGYyb09DQUN5QWJJQnNnR3lBYklCc2dFQnNnRUxJQWhCQVdvaEFVSGRBQ0VlREk4Q0N5QUlRUUZxSVFGQjNnQWhIZ3lPQWdzQ1FDQUJJZ2dnQWtjTkFFSHdBQ0VlREo0Q0N5QUlMUUFBUWNVQVJ3MnZBU0FJUVFGcUlRRU0zZ0VMUWZFQUlSNGdBU0lpSUFKR0Rad0NJQUlnSW1zZ0FDZ0NBQ0ltYWlFaklDSWhDQ0FtSVFFQ1FBTkFJQWd0QUFBZ0FVR0lzNENBQUdvdEFBQkhEYThCSUFGQkEwWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0l6WUNBQXlkQWdzZ0FFRUFOZ0lBSUNJZ0ptdEJCR29oQVVFdElSNE1yQUVMUWZJQUlSNGdBU0lpSUFKR0Rac0NJQUlnSW1zZ0FDZ0NBQ0ltYWlFaklDSWhDQ0FtSVFFQ1FBTkFJQWd0QUFBZ0FVSFFzNENBQUdvdEFBQkhEYTRCSUFGQkNFWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0l6WUNBQXljQWdzZ0FFRUFOZ0lBSUNJZ0ptdEJDV29oQVVFcElSNE1xd0VMQWtBZ0FTSUJJQUpIRFFCQjh3QWhIZ3liQWd0QkFTRWVJQUV0QUFCQjN3QkhEYW9CSUFGQkFXb2hBUXpjQVF0QjlBQWhIaUFCSWlJZ0FrWU5tUUlnQWlBaWF5QUFLQUlBSWlacUlTTWdJaUVJSUNZaEFRTkFJQWd0QUFBZ0FVR01zNENBQUdvdEFBQkhEYXNCSUFGQkFVWU45d0VnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNbVFJTEFrQWdBU0llSUFKSERRQkI5UUFoSGd5WkFnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFZNnpnSUFBYWkwQUFFY05xd0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRZlVBSVI0TW1RSUxJQUJCQURZQ0FDQWVJQ0pyUVFOcUlRRkJBaUVlREtnQkN3SkFJQUVpSGlBQ1J3MEFRZllBSVI0TW1BSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVSHdzNENBQUdvdEFBQkhEYW9CSUFGQkFVWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUgyQUNFZURKZ0NDeUFBUVFBMkFnQWdIaUFpYTBFQ2FpRUJRUjhoSGd5bkFRc0NRQ0FCSWg0Z0FrY05BRUgzQUNFZURKY0NDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkI4ck9BZ0FCcUxRQUFSdzJwQVNBQlFRRkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCOXdBaEhneVhBZ3NnQUVFQU5nSUFJQjRnSW10QkFtb2hBVUVKSVI0TXBnRUxBa0FnQVNJSUlBSkhEUUJCK0FBaEhneVdBZ3NDUUFKQUlBZ3RBQUJCdDM5cURnY0FxUUdwQWFrQnFRR3BBUUdwQVFzZ0NFRUJhaUVCUWVZQUlSNE1oZ0lMSUFoQkFXb2hBVUhuQUNFZURJVUNDd0pBSUFFaUhpQUNSdzBBUWZrQUlSNE1sUUlMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUdSczRDQUFHb3RBQUJIRGFjQklBRkJCVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVINUFDRWVESlVDQ3lBQVFRQTJBZ0FnSGlBaWEwRUdhaUVCUVJnaEhneWtBUXNDUUNBQkloNGdBa2NOQUVINkFDRWVESlFDQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCbDdPQWdBQnFMUUFBUncybUFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQitnQWhIZ3lVQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJBMm9oQVVFWElSNE1vd0VMQWtBZ0FTSWVJQUpIRFFCQit3QWhIZ3lUQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUVpxemdJQUFhaTBBQUVjTnBRRWdBVUVHUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFmc0FJUjRNa3dJTElBQkJBRFlDQUNBZUlDSnJRUWRxSVFGQkZTRWVES0lCQ3dKQUlBRWlIaUFDUncwQVFmd0FJUjRNa2dJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHaHM0Q0FBR290QUFCSERhUUJJQUZCQlVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFSDhBQ0VlREpJQ0N5QUFRUUEyQWdBZ0hpQWlhMEVHYWlFQlFSNGhIZ3loQVFzQ1FDQUJJZ2dnQWtjTkFFSDlBQ0VlREpFQ0N5QUlMUUFBUWN3QVJ3MmlBU0FJUVFGcUlRRkJDaUVlREtBQkN3SkFJQUVpQ0NBQ1J3MEFRZjRBSVI0TWtBSUxBa0FDUUNBSUxRQUFRYjkvYWc0UEFLTUJvd0dqQWFNQm93R2pBYU1Cb3dHakFhTUJvd0dqQWFNQkFhTUJDeUFJUVFGcUlRRkI3QUFoSGd5QUFnc2dDRUVCYWlFQlFlMEFJUjRNL3dFTEFrQWdBU0lJSUFKSERRQkIvd0FoSGd5UEFnc0NRQUpBSUFndEFBQkJ2MzlxRGdNQW9nRUJvZ0VMSUFoQkFXb2hBVUhyQUNFZURQOEJDeUFJUVFGcUlRRkI3Z0FoSGd6K0FRc0NRQ0FCSWg0Z0FrY05BRUdBQVNFZURJNENDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkJwN09BZ0FCcUxRQUFSdzJnQVNBQlFRRkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCZ0FFaEhneU9BZ3NnQUVFQU5nSUFJQjRnSW10QkFtb2hBVUVMSVI0TW5RRUxBa0FnQVNJSUlBSkhEUUJCZ1FFaEhneU5BZ3NDUUFKQUFrQUNRQ0FJTFFBQVFWTnFEaU1Bb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQVFHaUFhSUJvZ0dpQWFJQkFxSUJvZ0dpQVFPaUFRc2dDRUVCYWlFQlFla0FJUjRNL3dFTElBaEJBV29oQVVIcUFDRWVEUDRCQ3lBSVFRRnFJUUZCN3dBaEhnejlBUXNnQ0VFQmFpRUJRZkFBSVI0TS9BRUxBa0FnQVNJZUlBSkhEUUJCZ2dFaEhneU1BZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRYW16Z0lBQWFpMEFBRWNObmdFZ0FVRUVSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUVlJQklSNE1qQUlMSUFCQkFEWUNBQ0FlSUNKclFRVnFJUUZCR1NFZURKc0JDd0pBSUFFaUlpQUNSdzBBUVlNQklSNE1pd0lMSUFJZ0ltc2dBQ2dDQUNJbWFpRWVJQ0loQ0NBbUlRRUNRQU5BSUFndEFBQWdBVUd1czRDQUFHb3RBQUJIRFowQklBRkJCVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdIallDQUVHREFTRWVESXNDQ3lBQVFRQTJBZ0JCQmlFZUlDSWdKbXRCQm1vaEFReWFBUXNDUUNBQkloNGdBa2NOQUVHRUFTRWVESW9DQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCdExPQWdBQnFMUUFBUncyY0FTQUJRUUZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQmhBRWhIZ3lLQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJBbW9oQVVFY0lSNE1tUUVMQWtBZ0FTSWVJQUpIRFFCQmhRRWhIZ3lKQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUWJhemdJQUFhaTBBQUVjTm13RWdBVUVCUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFZVUJJUjRNaVFJTElBQkJBRFlDQUNBZUlDSnJRUUpxSVFGQkp5RWVESmdCQ3dKQUlBRWlDQ0FDUncwQVFZWUJJUjRNaUFJTEFrQUNRQ0FJTFFBQVFheC9hZzRDQUFHYkFRc2dDRUVCYWlFQlFmUUFJUjRNK0FFTElBaEJBV29oQVVIMUFDRWVEUGNCQ3dKQUlBRWlIaUFDUncwQVFZY0JJUjRNaHdJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHNHM0Q0FBR290QUFCSERaa0JJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFR0hBU0VlREljQ0N5QUFRUUEyQWdBZ0hpQWlhMEVDYWlFQlFTWWhIZ3lXQVFzQ1FDQUJJaDRnQWtjTkFFR0lBU0VlRElZQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQnVyT0FnQUJxTFFBQVJ3MllBU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkJpQUVoSGd5R0Fnc2dBRUVBTmdJQUlCNGdJbXRCQW1vaEFVRURJUjRNbFFFTEFrQWdBU0llSUFKSERRQkJpUUVoSGd5RkFnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFlMnpnSUFBYWkwQUFFY05sd0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRWWtCSVI0TWhRSUxJQUJCQURZQ0FDQWVJQ0pyUVFOcUlRRkJEQ0VlREpRQkN3SkFJQUVpSGlBQ1J3MEFRWW9CSVI0TWhBSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVRzhzNENBQUdvdEFBQkhEWllCSUFGQkEwWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUdLQVNFZURJUUNDeUFBUVFBMkFnQWdIaUFpYTBFRWFpRUJRUTBoSGd5VEFRc0NRQ0FCSWdnZ0FrY05BRUdMQVNFZURJTUNDd0pBQWtBZ0NDMEFBRUc2ZjJvT0N3Q1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnRUJsZ0VMSUFoQkFXb2hBVUg1QUNFZURQTUJDeUFJUVFGcUlRRkIrZ0FoSGd6eUFRc0NRQ0FCSWdnZ0FrY05BRUdNQVNFZURJSUNDeUFJTFFBQVFkQUFSdzJUQVNBSVFRRnFJUUVNeEFFTEFrQWdBU0lJSUFKSERRQkJqUUVoSGd5QkFnc0NRQUpBSUFndEFBQkJ0MzlxRGdjQmxBR1VBWlFCbEFHVUFRQ1VBUXNnQ0VFQmFpRUJRZndBSVI0TThRRUxJQWhCQVdvaEFVRWlJUjRNa0FFTEFrQWdBU0llSUFKSERRQkJqZ0VoSGd5QUFnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFjQ3pnSUFBYWkwQUFFY05rZ0VnQVVFQlJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRWTRCSVI0TWdBSUxJQUJCQURZQ0FDQWVJQ0pyUVFKcUlRRkJIU0VlREk4QkN3SkFJQUVpQ0NBQ1J3MEFRWThCSVI0TS93RUxBa0FDUUNBSUxRQUFRYTUvYWc0REFKSUJBWklCQ3lBSVFRRnFJUUZCL2dBaEhnenZBUXNnQ0VFQmFpRUJRUVFoSGd5T0FRc0NRQ0FCSWdnZ0FrY05BRUdRQVNFZURQNEJDd0pBQWtBQ1FBSkFBa0FnQ0MwQUFFRy9mMm9PRlFDVUFaUUJsQUdVQVpRQmxBR1VBWlFCbEFHVUFRR1VBWlFCQXBRQmxBRURsQUdVQVFTVUFRc2dDRUVCYWlFQlFmWUFJUjRNOFFFTElBaEJBV29oQVVIM0FDRWVEUEFCQ3lBSVFRRnFJUUZCK0FBaEhnenZBUXNnQ0VFQmFpRUJRZjBBSVI0TTdnRUxJQWhCQVdvaEFVSC9BQ0VlRE8wQkN3SkFJQVFnQWtjTkFFR1JBU0VlRFAwQkN5QUNJQVJySUFBb0FnQWlIbW9oSWlBRUlRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQjdiT0FnQUJxTFFBQVJ3MlBBU0FCUVFKR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNJMkFnQkJrUUVoSGd6OUFRc2dBRUVBTmdJQUlBUWdIbXRCQTJvaEFVRVJJUjRNakFFTEFrQWdCU0FDUncwQVFaSUJJUjRNL0FFTElBSWdCV3NnQUNnQ0FDSWVhaUVpSUFVaENDQWVJUUVDUUFOQUlBZ3RBQUFnQVVIQ3M0Q0FBR290QUFCSERZNEJJQUZCQWtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR1NBU0VlRFB3QkN5QUFRUUEyQWdBZ0JTQWVhMEVEYWlFQlFTd2hIZ3lMQVFzQ1FDQUdJQUpIRFFCQmt3RWhIZ3o3QVFzZ0FpQUdheUFBS0FJQUloNXFJU0lnQmlFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWNXemdJQUFhaTBBQUVjTmpRRWdBVUVFUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFaTUJJUjRNK3dFTElBQkJBRFlDQUNBR0lCNXJRUVZxSVFGQkt5RWVESW9CQ3dKQUlBY2dBa2NOQUVHVUFTRWVEUG9CQ3lBQ0lBZHJJQUFvQWdBaUhtb2hJaUFISVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCeXJPQWdBQnFMUUFBUncyTUFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQmxBRWhIZ3o2QVFzZ0FFRUFOZ0lBSUFjZ0htdEJBMm9oQVVFVUlSNE1pUUVMQWtBZ0NDQUNSdzBBUVpVQklSNE0rUUVMQWtBQ1FBSkFBa0FnQ0MwQUFFRytmMm9PRHdBQkFvNEJqZ0dPQVk0QmpnR09BWTRCamdHT0FZNEJqZ0VEamdFTElBaEJBV29oQkVHQkFTRWVET3NCQ3lBSVFRRnFJUVZCZ2dFaEhnenFBUXNnQ0VFQmFpRUdRWU1CSVI0TTZRRUxJQWhCQVdvaEIwR0VBU0VlRE9nQkN3SkFJQWdnQWtjTkFFR1dBU0VlRFBnQkN5QUlMUUFBUWNVQVJ3MkpBU0FJUVFGcUlRZ011d0VMQWtBZ0NTQUNSdzBBUVpjQklSNE05d0VMSUFJZ0NXc2dBQ2dDQUNJZWFpRWlJQWtoQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhOczRDQUFHb3RBQUJIRFlrQklBRkJBa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHWEFTRWVEUGNCQ3lBQVFRQTJBZ0FnQ1NBZWEwRURhaUVCUVE0aEhneUdBUXNDUUNBSUlBSkhEUUJCbUFFaEhnejJBUXNnQ0MwQUFFSFFBRWNOaHdFZ0NFRUJhaUVCUVNVaEhneUZBUXNDUUNBS0lBSkhEUUJCbVFFaEhnejFBUXNnQWlBS2F5QUFLQUlBSWg1cUlTSWdDaUVJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZEN6Z0lBQWFpMEFBRWNOaHdFZ0FVRUlSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUVprQklSNE05UUVMSUFCQkFEWUNBQ0FLSUI1clFRbHFJUUZCS2lFZURJUUJDd0pBSUFnZ0FrY05BRUdhQVNFZURQUUJDd0pBQWtBZ0NDMEFBRUdyZjJvT0N3Q0hBWWNCaHdHSEFZY0Jod0dIQVljQmh3RUJod0VMSUFoQkFXb2hDRUdJQVNFZURPUUJDeUFJUVFGcUlRcEJpUUVoSGd6akFRc0NRQ0FJSUFKSERRQkJtd0VoSGd6ekFRc0NRQUpBSUFndEFBQkJ2MzlxRGhRQWhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQkFZWUJDeUFJUVFGcUlRbEJod0VoSGd6akFRc2dDRUVCYWlFSVFZb0JJUjRNNGdFTEFrQWdDeUFDUncwQVFad0JJUjRNOGdFTElBSWdDMnNnQUNnQ0FDSWVhaUVpSUFzaENDQWVJUUVDUUFOQUlBZ3RBQUFnQVVIWnM0Q0FBR290QUFCSERZUUJJQUZCQTBZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR2NBU0VlRFBJQkN5QUFRUUEyQWdBZ0N5QWVhMEVFYWlFQlFTRWhIZ3lCQVFzQ1FDQU1JQUpIRFFCQm5RRWhIZ3p4QVFzZ0FpQU1heUFBS0FJQUloNXFJU0lnRENFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWQyemdJQUFhaTBBQUVjTmd3RWdBVUVHUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFaMEJJUjRNOFFFTElBQkJBRFlDQUNBTUlCNXJRUWRxSVFGQkdpRWVESUFCQ3dKQUlBZ2dBa2NOQUVHZUFTRWVEUEFCQ3dKQUFrQUNRQ0FJTFFBQVFidC9hZzRSQUlRQmhBR0VBWVFCaEFHRUFZUUJoQUdFQVFHRUFZUUJoQUdFQVlRQkFvUUJDeUFJUVFGcUlRaEJpd0VoSGd6aEFRc2dDRUVCYWlFTFFZd0JJUjRNNEFFTElBaEJBV29oREVHTkFTRWVETjhCQ3dKQUlBMGdBa2NOQUVHZkFTRWVETzhCQ3lBQ0lBMXJJQUFvQWdBaUhtb2hJaUFOSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCNUxPQWdBQnFMUUFBUncyQkFTQUJRUVZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQm53RWhIZ3p2QVFzZ0FFRUFOZ0lBSUEwZ0htdEJCbW9oQVVFb0lSNE1mZ3NDUUNBT0lBSkhEUUJCb0FFaEhnenVBUXNnQWlBT2F5QUFLQUlBSWg1cUlTSWdEaUVJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZXF6Z0lBQWFpMEFBRWNOZ0FFZ0FVRUNSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUWFBQklSNE03Z0VMSUFCQkFEWUNBQ0FPSUI1clFRTnFJUUZCQnlFZURIMExBa0FnQ0NBQ1J3MEFRYUVCSVI0TTdRRUxBa0FDUUNBSUxRQUFRYnQvYWc0T0FJQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVFHQUFRc2dDRUVCYWlFTlFZOEJJUjRNM1FFTElBaEJBV29oRGtHUUFTRWVETndCQ3dKQUlBOGdBa2NOQUVHaUFTRWVET3dCQ3lBQ0lBOXJJQUFvQWdBaUhtb2hJaUFQSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCN2JPQWdBQnFMUUFBUncxK0lBRkJBa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHaUFTRWVET3dCQ3lBQVFRQTJBZ0FnRHlBZWEwRURhaUVCUVJJaEhneDdDd0pBSUJBZ0FrY05BRUdqQVNFZURPc0JDeUFDSUJCcklBQW9BZ0FpSG1vaElpQVFJUWdnSGlFQkFrQURRQ0FJTFFBQUlBRkI4TE9BZ0FCcUxRQUFSdzE5SUFGQkFVWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUdqQVNFZURPc0JDeUFBUVFBMkFnQWdFQ0FlYTBFQ2FpRUJRU0FoSGd4NkN3SkFJQkVnQWtjTkFFR2tBU0VlRE9vQkN5QUNJQkZySUFBb0FnQWlIbW9oSWlBUklRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQjhyT0FnQUJxTFFBQVJ3MThJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR2tBU0VlRE9vQkN5QUFRUUEyQWdBZ0VTQWVhMEVDYWlFQlFROGhIZ3g1Q3dKQUlBZ2dBa2NOQUVHbEFTRWVET2tCQ3dKQUFrQWdDQzBBQUVHM2Yyb09Cd0I4Zkh4OGZBRjhDeUFJUVFGcUlSQkJrd0VoSGd6WkFRc2dDRUVCYWlFUlFaUUJJUjRNMkFFTEFrQWdFaUFDUncwQVFhWUJJUjRNNkFFTElBSWdFbXNnQUNnQ0FDSWVhaUVpSUJJaENDQWVJUUVDUUFOQUlBZ3RBQUFnQVVIMHM0Q0FBR290QUFCSERYb2dBVUVIUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFhWUJJUjRNNkFFTElBQkJBRFlDQUNBU0lCNXJRUWhxSVFGQkd5RWVESGNMQWtBZ0NDQUNSdzBBUWFjQklSNE01d0VMQWtBQ1FBSkFJQWd0QUFCQnZuOXFEaElBZTN0N2UzdDdlM3Q3QVh0N2UzdDdld0o3Q3lBSVFRRnFJUTlCa2dFaEhnellBUXNnQ0VFQmFpRUlRWlVCSVI0TTF3RUxJQWhCQVdvaEVrR1dBU0VlRE5ZQkN3SkFJQWdnQWtjTkFFR29BU0VlRE9ZQkN5QUlMUUFBUWM0QVJ3MTNJQWhCQVdvaENBeXFBUXNDUUNBSUlBSkhEUUJCcVFFaEhnemxBUXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUlMUUFBUWI5L2FnNFZBQUVDQTRZQkJBVUdoZ0dHQVlZQkJ3Z0pDZ3VHQVF3TkRnK0dBUXNnQ0VFQmFpRUJRZFlBSVI0TTR3RUxJQWhCQVdvaEFVSFhBQ0VlRE9JQkN5QUlRUUZxSVFGQjNBQWhIZ3poQVFzZ0NFRUJhaUVCUWVBQUlSNE00QUVMSUFoQkFXb2hBVUhoQUNFZUROOEJDeUFJUVFGcUlRRkI1QUFoSGd6ZUFRc2dDRUVCYWlFQlFlVUFJUjRNM1FFTElBaEJBV29oQVVIb0FDRWVETndCQ3lBSVFRRnFJUUZCOFFBaEhnemJBUXNnQ0VFQmFpRUJRZklBSVI0TTJnRUxJQWhCQVdvaEFVSHpBQ0VlRE5rQkN5QUlRUUZxSVFGQmdBRWhIZ3pZQVFzZ0NFRUJhaUVJUVlZQklSNE0xd0VMSUFoQkFXb2hDRUdPQVNFZUROWUJDeUFJUVFGcUlRaEJrUUVoSGd6VkFRc2dDRUVCYWlFSVFaZ0JJUjRNMUFFTEFrQWdGQ0FDUncwQVFhc0JJUjRNNUFFTElCUkJBV29oRXd4M0N3TkFBa0FnSGkwQUFFRjJhZzRFZHdBQWVnQUxJQjVCQVdvaUhpQUNSdzBBQzBHc0FTRWVET0lCQ3dKQUlCVWdBa1lOQUNBQVFZMkFnSUFBTmdJSUlBQWdGVFlDQkNBVklRRkJBU0VlRE5JQkMwR3RBU0VlRE9FQkN3SkFJQlVnQWtjTkFFR3VBU0VlRE9FQkN3SkFBa0FnRlMwQUFFRjJhZzRFQWFzQnF3RUFxd0VMSUJWQkFXb2hGQXg0Q3lBVlFRRnFJUk1NZEFzZ0FDQVRJQUlRcDRDQWdBQWFJQk1oQVF4RkN3SkFJQlVnQWtjTkFFR3ZBU0VlRE44QkN3SkFBa0FnRlMwQUFFRjJhZzRYQVhsNUFYbDVlWGw1ZVhsNWVYbDVlWGw1ZVhsNWVRQjVDeUFWUVFGcUlSVUxRWndCSVI0TXpnRUxBa0FnRmlBQ1J3MEFRYkVCSVI0TTNnRUxJQll0QUFCQklFY05keUFBUVFBN0FUSWdGa0VCYWlFQlFhQUJJUjRNelFFTElBRWhKZ0pBQTBBZ0ppSVZJQUpHRFFFZ0ZTMEFBRUZRYWtIL0FYRWlIa0VLVHcyb0FRSkFJQUF2QVRJaUlrR1pNMHNOQUNBQUlDSkJDbXdpSWpzQk1pQWVRZi8vQTNNZ0lrSCsvd054U1EwQUlCVkJBV29oSmlBQUlDSWdIbW9pSGpzQk1pQWVRZi8vQTNGQjZBZEpEUUVMQzBFQUlSNGdBRUVBTmdJY0lBQkJuWW1BZ0FBMkFoQWdBRUVOTmdJTUlBQWdGVUVCYWpZQ0ZBemRBUXRCc0FFaEhnemNBUXNDUUNBWElBSkhEUUJCc2dFaEhnemNBUXRCQUNFZUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBWExRQUFRVkJxRGdwL2ZnQUJBZ01FQlFZSGdBRUxRUUloSGd4K0MwRURJUjRNZlF0QkJDRWVESHdMUVFVaEhneDdDMEVHSVI0TWVndEJCeUVlREhrTFFRZ2hIZ3g0QzBFSklSNE1kd3NDUUNBWUlBSkhEUUJCc3dFaEhnemJBUXNnR0MwQUFFRXVSdzE0SUJoQkFXb2hGd3ltQVFzQ1FDQVpJQUpIRFFCQnRBRWhIZ3phQVF0QkFDRWVBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQVpMUUFBUVZCcURncUJBWUFCQUFFQ0F3UUZCZ2VDQVF0QkFpRWVESUFCQzBFRElSNE1md3RCQkNFZURINExRUVVoSGd4OUMwRUdJUjRNZkF0QkJ5RWVESHNMUVFnaEhneDZDMEVKSVI0TWVRc0NRQ0FJSUFKSERRQkJ0UUVoSGd6WkFRc2dBaUFJYXlBQUtBSUFJaUpxSVNZZ0NDRVpJQ0loSGdOQUlCa3RBQUFnSGtIOHM0Q0FBR290QUFCSERYc2dIa0VFUmcyMEFTQWVRUUZxSVI0Z0dVRUJhaUlaSUFKSERRQUxJQUFnSmpZQ0FFRzFBU0VlRE5nQkN3SkFJQm9nQWtjTkFFRzJBU0VlRE5nQkN5QUNJQnBySUFBb0FnQWlIbW9oSWlBYUlRZ2dIaUVCQTBBZ0NDMEFBQ0FCUVlHMGdJQUFhaTBBQUVjTmV5QUJRUUZHRGJZQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFiWUJJUjRNMXdFTEFrQWdHeUFDUncwQVFiY0JJUjRNMXdFTElBSWdHMnNnQUNnQ0FDSVphaUVpSUJzaENDQVpJUjREUUNBSUxRQUFJQjVCZzdTQWdBQnFMUUFBUncxNklCNUJBa1lOZkNBZVFRRnFJUjRnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHM0FTRWVETllCQ3dKQUlBZ2dBa2NOQUVHNEFTRWVETllCQ3dKQUFrQWdDQzBBQUVHN2Yyb09FQUI3ZTN0N2UzdDdlM3Q3ZTN0N2V3RjdDeUFJUVFGcUlScEJwUUVoSGd6R0FRc2dDRUVCYWlFYlFhWUJJUjRNeFFFTEFrQWdDQ0FDUncwQVFia0JJUjRNMVFFTElBZ3RBQUJCeUFCSERYZ2dDRUVCYWlFSURLSUJDd0pBSUFnZ0FrY05BRUc2QVNFZUROUUJDeUFJTFFBQVFjZ0FSZzJpQVNBQVFRRTZBQ2dNbVFFTEEwQUNRQ0FJTFFBQVFYWnFEZ1FBZW5vQWVnc2dDRUVCYWlJSUlBSkhEUUFMUWJ3QklSNE0wZ0VMSUFCQkFEb0FMeUFBTFFBdFFRUnhSUTNJQVFzZ0FFRUFPZ0F2SUFFaEFReDVDeUFlUVJWR0Rha0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR3JqSUNBQURZQ0VDQUFRUkkyQWd4QkFDRWVETThCQ3dKQUlBQWdIaUFDRUsyQWdJQUFJZ0VOQUNBZUlRRU14UUVMQWtBZ0FVRVZSdzBBSUFCQkF6WUNIQ0FBSUI0MkFoUWdBRUhXa29DQUFEWUNFQ0FBUVJVMkFneEJBQ0VlRE04QkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQnE0eUFnQUEyQWhBZ0FFRVNOZ0lNUVFBaEhnek9BUXNnSGtFVlJnMmxBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJpSXlBZ0FBMkFoQWdBRUVVTmdJTVFRQWhIZ3pOQVFzZ0FDZ0NCQ0VtSUFCQkFEWUNCQ0FlSUIrbmFpSWpJUUVnQUNBbUlCNGdJeUFpR3lJZUVLNkFnSUFBSWlKRkRYb2dBRUVITmdJY0lBQWdIallDRkNBQUlDSTJBZ3hCQUNFZURNd0JDeUFBSUFBdkFUQkJnQUZ5T3dFd0lBRWhBUXd4Q3lBZVFSVkdEYUVCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhGaTRDQUFEWUNFQ0FBUVJNMkFneEJBQ0VlRE1vQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmk0dUFnQUEyQWhBZ0FFRUNOZ0lNUVFBaEhnekpBUXNnSGtFN1J3MEJJQUZCQVdvaEFRdEJDQ0VlRExjQkMwRUFJUjRnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYU9RZ0lBQU5nSVFJQUJCRERZQ0RBekdBUXRDQVNFZkN5QWVRUUZxSVFFQ1FDQUFLUU1nSWlCQy8vLy8vLy8vLy84UFZnMEFJQUFnSUVJRWhpQWZoRGNESUNBQklRRU1kd3NnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWW1KZ0lBQU5nSVFJQUJCRERZQ0RFRUFJUjRNeEFFTElBQkJBRFlDSENBQUlCNDJBaFFnQUVHamtJQ0FBRFlDRUNBQVFRdzJBZ3hCQUNFZURNTUJDeUFBS0FJRUlTWWdBRUVBTmdJRUlCNGdINmRxSWlNaEFTQUFJQ1lnSGlBaklDSWJJaDRRcm9DQWdBQWlJa1VOYmlBQVFRVTJBaHdnQUNBZU5nSVVJQUFnSWpZQ0RFRUFJUjRNd2dFTElBQkJBRFlDSENBQUlCNDJBaFFnQUVIZGxJQ0FBRFlDRUNBQVFRODJBZ3hCQUNFZURNRUJDeUFBSUI0Z0FoQ3RnSUNBQUNJQkRRRWdIaUVCQzBFUElSNE1yd0VMQWtBZ0FVRVZSdzBBSUFCQkFqWUNIQ0FBSUI0MkFoUWdBRUhXa29DQUFEWUNFQ0FBUVJVMkFneEJBQ0VlREw4QkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQnE0eUFnQUEyQWhBZ0FFRVNOZ0lNUVFBaEhneStBUXNnQVVFQmFpRWVBa0FnQUM4Qk1DSUJRWUFCY1VVTkFBSkFJQUFnSGlBQ0VMQ0FnSUFBSWdFTkFDQWVJUUVNYXdzZ0FVRVZSdzJYQVNBQVFRVTJBaHdnQUNBZU5nSVVJQUJCdnBLQWdBQTJBaEFnQUVFVk5nSU1RUUFoSGd5K0FRc0NRQ0FCUWFBRWNVR2dCRWNOQUNBQUxRQXRRUUp4RFFBZ0FFRUFOZ0ljSUFBZ0hqWUNGQ0FBUWV5UGdJQUFOZ0lRSUFCQkJEWUNERUVBSVI0TXZnRUxJQUFnSGlBQ0VMR0FnSUFBR2lBZUlRRUNRQUpBQWtBQ1FBSkFJQUFnSGlBQ0VLeUFnSUFBRGhZQ0FRQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUURCQXNnQUVFQk9nQXVDeUFBSUFBdkFUQkJ3QUJ5T3dFd0lCNGhBUXRCSFNFZURLOEJDeUFBUVJVMkFod2dBQ0FlTmdJVUlBQkI0WkdBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3krQVFzZ0FFRUFOZ0ljSUFBZ0hqWUNGQ0FBUWJHTGdJQUFOZ0lRSUFCQkVUWUNERUVBSVI0TXZRRUxJQUF0QUMxQkFYRkZEUUZCcWdFaEhneXNBUXNDUUNBY0lBSkdEUUFEUUFKQUlCd3RBQUJCSUVZTkFDQWNJUUVNcUFFTElCeEJBV29pSENBQ1J3MEFDMEVYSVI0TXZBRUxRUmNoSGd5N0FRc2dBQ2dDQkNFQklBQkJBRFlDQkNBQUlBRWdIQkNvZ0lDQUFDSUJSUTJRQVNBQVFSZzJBaHdnQUNBQk5nSU1JQUFnSEVFQmFqWUNGRUVBSVI0TXVnRUxJQUJCR1RZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneTVBUXNnSGlFQlFRRWhJZ0pBQWtBQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZm1vT0J3WUZCUU1CQWdBRkN5QUFJQUF2QVRCQkNISTdBVEFNQXd0QkFpRWlEQUVMUVFRaElnc2dBRUVCT2dBc0lBQWdBQzhCTUNBaWNqc0JNQXNnSGlFQkMwRWdJUjRNcVFFTElBQkJBRFlDSENBQUlCNDJBaFFnQUVHQmo0Q0FBRFlDRUNBQVFRczJBZ3hCQUNFZURMZ0JDeUFlSVFGQkFTRWlBa0FDUUFKQUFrQUNRQ0FBTFFBc1FYdHFEZ1FDQUFFREJRdEJBaUVpREFFTFFRUWhJZ3NnQUVFQk9nQXNJQUFnQUM4Qk1DQWljanNCTUF3QkN5QUFJQUF2QVRCQkNISTdBVEFMSUI0aEFRdEJxd0VoSGd5bUFRc2dBQ0FCSUFJUXE0Q0FnQUFhREJzTEFrQWdBU0llSUFKR0RRQWdIaUVCQWtBQ1FDQWVMUUFBUVhacURnUUJhbW9BYWdzZ0hrRUJhaUVCQzBFZUlSNE1wUUVMUWNNQUlSNE10QUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdSa1lDQUFEWUNFQ0FBUVFNMkFneEJBQ0VlRExNQkN3SkFJQUV0QUFCQkRVY05BQ0FBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXFvQ0FnQUFpSGcwQUlBRkJBV29oQVF4cEN5QUFRUjQyQWh3Z0FDQWVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSNE1zd0VMSUFFaEFTQUFMUUF0UVFGeFJRMnVBVUd0QVNFZURLSUJDd0pBSUFFaUFTQUNSdzBBUVI4aEhneXlBUXNDUUFKQUEwQUNRQ0FCTFFBQVFYWnFEZ1FDQUFBREFBc2dBVUVCYWlJQklBSkhEUUFMUVI4aEhneXpBUXNnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLcUFnSUFBSWg0TkFDQUJJUUVNYUFzZ0FFRWVOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlRExJQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcW9DQWdBQWlIZzBBSUFGQkFXb2hBUXhuQ3lBQVFSNDJBaHdnQUNBZU5nSU1JQUFnQVVFQmFqWUNGRUVBSVI0TXNRRUxJQjVCTEVjTkFTQUJRUUZxSVI1QkFTRUJBa0FDUUFKQUFrQUNRQ0FBTFFBc1FYdHFEZ1FEQVFJRUFBc2dIaUVCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUJCQVRvQUxDQUFJQUF2QVRBZ0FYSTdBVEFnSGlFQkRBRUxJQUFnQUM4Qk1FRUljanNCTUNBZUlRRUxRUzRoSGd5ZkFRc2dBRUVBT2dBc0lBRWhBUXRCS1NFZURKMEJDeUFBUVFBMkFnQWdJeUFrYTBFSmFpRUJRUVVoSGd5WUFRc2dBRUVBTmdJQUlDTWdKR3RCQm1vaEFVRUhJUjRNbHdFTElBQWdBQzhCTUVFZ2Nqc0JNQ0FCSVFFTUFnc2dBQ2dDQkNFSUlBQkJBRFlDQkFKQUlBQWdDQ0FCRUtxQWdJQUFJZ2dOQUNBQklRRU1uUUVMSUFCQktqWUNIQ0FBSUFFMkFoUWdBQ0FJTmdJTVFRQWhIZ3lwQVFzZ0FFRUlPZ0FzSUFFaEFRdEJKU0VlREpjQkN3SkFJQUF0QUNoQkFVWU5BQ0FCSVFFTUJBc2dBQzBBTFVFSWNVVU5lQ0FCSVFFTUF3c2dBQzBBTUVFZ2NRMTVRYTRCSVI0TWxRRUxBa0FnSFNBQ1JnMEFBa0FEUUFKQUlCMHRBQUJCVUdvaUFVSC9BWEZCQ2trTkFDQWRJUUZCS2lFZURKZ0JDeUFBS1FNZ0loOUNtYlBtekptejVzd1pWZzBCSUFBZ0gwSUtmaUlmTndNZ0lCOGdBYTBpSUVKL2hVS0Fmb1JXRFFFZ0FDQWZJQ0JDL3dHRGZEY0RJQ0FkUVFGcUloMGdBa2NOQUF0QkxDRWVES1lCQ3lBQUtBSUVJUWdnQUVFQU5nSUVJQUFnQ0NBZFFRRnFJZ0VRcW9DQWdBQWlDQTE2SUFFaEFReVpBUXRCTENFZURLUUJDd0pBSUFBdkFUQWlBVUVJY1VVTkFDQUFMUUFvUVFGSERRQWdBQzBBTFVFSWNVVU5kUXNnQUNBQlFmZjdBM0ZCZ0FSeU93RXdJQjBoQVF0QkxDRWVESklCQ3lBQUlBQXZBVEJCRUhJN0FUQU1od0VMSUFCQk5qWUNIQ0FBSUFFMkFnd2dBQ0FjUVFGcU5nSVVRUUFoSGd5Z0FRc2dBUzBBQUVFNlJ3MENJQUFvQWdRaEhpQUFRUUEyQWdRZ0FDQWVJQUVRcUlDQWdBQWlIZzBCSUFGQkFXb2hBUXRCTVNFZURJNEJDeUFBUVRZMkFod2dBQ0FlTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUjRNblFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHSGpvQ0FBRFlDRUNBQVFRbzJBZ3hCQUNFZURKd0JDeUFCUVFGcUlRRUxJQUJCZ0JJN0FTb2dBQ0FCSUFJUXBZQ0FnQUFhSUFFaEFRdEJyQUVoSGd5SkFRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtTQWdJQUFJaDROQUNBQklRRU1VQXNnQUVIRUFEWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3lZQVFzZ0FFRUFOZ0ljSUFBZ0lqWUNGQ0FBUWVXWWdJQUFOZ0lRSUFCQkJ6WUNEQ0FBUVFBMkFnQkJBQ0VlREpjQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFReFBDeUFBUWNVQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESllCQzBFQUlSNGdBRUVBTmdJY0lBQWdBVFlDRkNBQVFldU5nSUFBTmdJUUlBQkJDVFlDREF5VkFRdEJBU0VlQ3lBQUlCNDZBQ3NnQVVFQmFpRUJJQUF0QUNsQklrWU5pd0VNVEFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWFLTmdJQUFOZ0lRSUFCQkNUWUNERUVBSVI0TWtnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEZpb0NBQURZQ0VDQUFRUWsyQWd4QkFDRWVESkVCQzBFQklSNExJQUFnSGpvQUtpQUJRUUZxSVFFTVNnc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFiaU5nSUFBTmdJUUlBQkJDVFlDREVFQUlSNE1qZ0VMSUFCQkFEWUNBQ0FtSUNOclFRUnFJUUVDUUNBQUxRQXBRU05QRFFBZ0FTRUJERW9MSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUd2aVlDQUFEWUNFQ0FBUVFnMkFneEJBQ0VlREkwQkN5QUFRUUEyQWdBTFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1WnVBZ0FBMkFoQWdBRUVJTmdJTURJc0JDeUFBUVFBMkFnQWdKaUFqYTBFRGFpRUJBa0FnQUMwQUtVRWhSdzBBSUFFaEFReEhDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkI5NG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhIZ3lLQVFzZ0FFRUFOZ0lBSUNZZ0kydEJCR29oQVFKQUlBQXRBQ2tpSGtGZGFrRUxUdzBBSUFFaEFReEdDd0pBSUI1QkJrc05BRUVCSUI1MFFjb0FjVVVOQUNBQklRRU1SZ3RCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIVGlZQ0FBRFlDRUNBQVFRZzJBZ3dNaVFFTElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkRFWUxJQUJCMEFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1pQUVMSUFBb0FnUWhIaUFBUVFBMkFnUUNRQ0FBSUI0Z0FSQ2tnSUNBQUNJZURRQWdBU0VCREQ4TElBQkJ4QUEyQWh3Z0FDQUJOZ0lVSUFBZ0hqWUNERUVBSVI0TWh3RUxJQUFvQWdRaEhpQUFRUUEyQWdRQ1FDQUFJQjRnQVJDa2dJQ0FBQ0llRFFBZ0FTRUJERDhMSUFCQnhRQTJBaHdnQUNBQk5nSVVJQUFnSGpZQ0RFRUFJUjRNaGdFTElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkRFTUxJQUJCMEFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1oUUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdpaW9DQUFEWUNFQ0FBUVFjMkFneEJBQ0VlRElRQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFRdzdDeUFBUWNRQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESU1CQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF3N0N5QUFRY1VBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURJSUJDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXcvQ3lBQVFkQUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlRElFQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnVJaUFnQUEyQWhBZ0FFRUhOZ0lNUVFBaEhneUFBUXNnSGtFL1J3MEJJQUZCQVdvaEFRdEJCU0VlREc0TFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIwNCtBZ0FBMkFoQWdBRUVITmdJTURIMExJQUFvQWdRaEhpQUFRUUEyQWdRQ1FDQUFJQjRnQVJDa2dJQ0FBQ0llRFFBZ0FTRUJERFFMSUFCQnhBQTJBaHdnQUNBQk5nSVVJQUFnSGpZQ0RFRUFJUjRNZkFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS1NBZ0lBQUloNE5BQ0FCSVFFTU5Bc2dBRUhGQURZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneDdDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXc0Q3lBQVFkQUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlREhvTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdJaENrZ0lDQUFDSUJEUUFnSWlFQkRERUxJQUJCeEFBMkFod2dBQ0FpTmdJVUlBQWdBVFlDREVFQUlSNE1lUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBaUVLU0FnSUFBSWdFTkFDQWlJUUVNTVFzZ0FFSEZBRFlDSENBQUlDSTJBaFFnQUNBQk5nSU1RUUFoSGd4NEN5QUFLQUlFSVFFZ0FFRUFOZ0lFQWtBZ0FDQUJJQ0lRcElDQWdBQWlBUTBBSUNJaEFRdzFDeUFBUWRBQU5nSWNJQUFnSWpZQ0ZDQUFJQUUyQWd4QkFDRWVESGNMSUFCQkFEWUNIQ0FBSUNJMkFoUWdBRUhRaklDQUFEWUNFQ0FBUVFjMkFneEJBQ0VlREhZTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIUWpJQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFZURIVUxRUUFoSGlBQVFRQTJBaHdnQUNBaU5nSVVJQUJCdjVTQWdBQTJBaEFnQUVFSE5nSU1ESFFMSUFCQkFEWUNIQ0FBSUNJMkFoUWdBRUcvbElDQUFEWUNFQ0FBUVFjMkFneEJBQ0VlREhNTElBQkJBRFlDSENBQUlDSTJBaFFnQUVIVWpvQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFZURISUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEJrNENBQURZQ0VDQUFRUVkyQWd4QkFDRWVESEVMSUFCQkFEWUNBQ0FpSUNaclFRWnFJUUZCSkNFZUN5QUFJQjQ2QUNrZ0FTRUJERTRMSUFCQkFEWUNBQXRCQUNFZUlBQkJBRFlDSENBQUlBZzJBaFFnQUVHa2xJQ0FBRFlDRUNBQVFRWTJBZ3dNYlFzZ0FDZ0NCQ0VUSUFCQkFEWUNCQ0FBSUJNZ0hoQ21nSUNBQUNJVERRRWdIa0VCYWlFVEMwR2RBU0VlREZzTElBQkJxZ0UyQWh3Z0FDQVROZ0lNSUFBZ0hrRUJhallDRkVFQUlSNE1hZ3NnQUNnQ0JDRVVJQUJCQURZQ0JDQUFJQlFnSGhDbWdJQ0FBQ0lVRFFFZ0hrRUJhaUVVQzBHYUFTRWVERmdMSUFCQnF3RTJBaHdnQUNBVU5nSU1JQUFnSGtFQmFqWUNGRUVBSVI0TVp3c2dBRUVBTmdJY0lBQWdGVFlDRkNBQVFmT0tnSUFBTmdJUUlBQkJEVFlDREVFQUlSNE1aZ3NnQUVFQU5nSWNJQUFnRmpZQ0ZDQUFRYzZOZ0lBQU5nSVFJQUJCQ1RZQ0RFRUFJUjRNWlF0QkFTRWVDeUFBSUI0NkFDc2dGMEVCYWlFV0RDNExJQUJCQURZQ0hDQUFJQmMyQWhRZ0FFR2lqWUNBQURZQ0VDQUFRUWsyQWd4QkFDRWVER0lMSUFCQkFEWUNIQ0FBSUJnMkFoUWdBRUhGaW9DQUFEWUNFQ0FBUVFrMkFneEJBQ0VlREdFTFFRRWhIZ3NnQUNBZU9nQXFJQmxCQVdvaEdBd3NDeUFBUVFBMkFod2dBQ0FaTmdJVUlBQkJ1STJBZ0FBMkFoQWdBRUVKTmdJTVFRQWhIZ3hlQ3lBQVFRQTJBaHdnQUNBWk5nSVVJQUJCdVp1QWdBQTJBaEFnQUVFSU5nSU1JQUJCQURZQ0FFRUFJUjRNWFFzZ0FFRUFOZ0lBQzBFQUlSNGdBRUVBTmdJY0lBQWdDRFlDRkNBQVFZdVVnSUFBTmdJUUlBQkJDRFlDREF4YkN5QUFRUUk2QUNnZ0FFRUFOZ0lBSUJzZ0dXdEJBMm9oR1F3MkN5QUFRUUk2QUM4Z0FDQUlJQUlRbzRDQWdBQWlIZzBCUWE4QklSNE1TUXNnQUMwQUtFRi9hZzRDSGlBZkN5QWVRUlZIRFNjZ0FFRzdBVFlDSENBQUlBZzJBaFFnQUVHbmtvQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFZURGY0xRUUFoSGd4R0MwRUNJUjRNUlF0QkRpRWVERVFMUVJBaEhneERDMEVjSVI0TVFndEJGQ0VlREVFTFFSWWhIZ3hBQzBFWElSNE1Qd3RCR1NFZURENExRUm9oSGd3OUMwRTZJUjRNUEF0Qkl5RWVERHNMUVNRaEhndzZDMEV3SVI0TU9RdEJPeUVlRERnTFFUd2hIZ3czQzBFK0lSNE1OZ3RCUHlFZUREVUxRY0FBSVI0TU5BdEJ3UUFoSGd3ekMwSEZBQ0VlRERJTFFjY0FJUjRNTVF0QnlBQWhIZ3d3QzBIS0FDRWVEQzhMUWQ4QUlSNE1MZ3RCNGdBaEhnd3RDMEg3QUNFZURDd0xRWVVCSVI0TUt3dEJsd0VoSGd3cUMwR1pBU0VlRENrTFFha0JJUjRNS0F0QnBBRWhIZ3duQzBHYkFTRWVEQ1lMUVo0QklSNE1KUXRCbndFaEhnd2tDMEdoQVNFZURDTUxRYUlCSVI0TUlndEJwd0VoSGd3aEMwR29BU0VlRENBTElBQkJBRFlDSENBQUlBZzJBaFFnQUVIbWk0Q0FBRFlDRUNBQVFSQTJBZ3hCQUNFZURDOExJQUJCQURZQ0JDQUFJQjBnSFJDcWdJQ0FBQ0lCUlEwQklBQkJMVFlDSENBQUlBRTJBZ3dnQUNBZFFRRnFOZ0lVUVFBaEhnd3VDeUFBS0FJRUlRZ2dBRUVBTmdJRUFrQWdBQ0FJSUFFUXFvQ0FnQUFpQ0VVTkFDQUFRUzQyQWh3Z0FDQUlOZ0lNSUFBZ0FVRUJhallDRkVFQUlSNE1MZ3NnQVVFQmFpRUJEQjRMSUIxQkFXb2hBUXdlQ3lBQVFRQTJBaHdnQUNBZE5nSVVJQUJCdW8rQWdBQTJBaEFnQUVFRU5nSU1RUUFoSGd3ckN5QUFRU2syQWh3Z0FDQUJOZ0lVSUFBZ0NEWUNERUVBSVI0TUtnc2dIRUVCYWlFQkRCNExJQUJCQ2pZQ0hDQUFJQUUyQWhRZ0FFR1Jrb0NBQURZQ0VDQUFRUlUyQWd4QkFDRWVEQ2dMSUFCQkVEWUNIQ0FBSUFFMkFoUWdBRUcra29DQUFEWUNFQ0FBUVJVMkFneEJBQ0VlRENjTElBQkJBRFlDSENBQUlCNDJBaFFnQUVHSWpJQ0FBRFlDRUNBQVFSUTJBZ3hCQUNFZURDWUxJQUJCQkRZQ0hDQUFJQUUyQWhRZ0FFSFdrb0NBQURZQ0VDQUFRUlUyQWd4QkFDRWVEQ1VMSUFCQkFEWUNBQ0FJSUNKclFRVnFJUmtMUWFNQklSNE1Fd3NnQUVFQU5nSUFJQ0lnSm10QkFtb2hBVUhqQUNFZURCSUxJQUJCQURZQ0FDQUFRWUVFT3dFb0lCb2dIbXRCQW1vaEFRdEIwd0FoSGd3UUN5QUJJUUVDUUNBQUxRQXBRUVZIRFFCQjBnQWhIZ3dRQzBIUkFDRWVEQThMUVFBaEhpQUFRUUEyQWh3Z0FFRzZqb0NBQURZQ0VDQUFRUWMyQWd3Z0FDQWlRUUZxTmdJVURCNExJQUJCQURZQ0FDQW1JQ05yUVFKcUlRRkJOQ0VlREEwTElBRWhBUXRCTFNFZURBc0xBa0FnQVNJZElBSkdEUUFEUUFKQUlCMHRBQUJCZ0tLQWdBQnFMUUFBSWdGQkFVWU5BQ0FCUVFKSERRTWdIVUVCYWlFQkRBUUxJQjFCQVdvaUhTQUNSdzBBQzBFeElSNE1Hd3RCTVNFZURCb0xJQUJCQURvQUxDQWRJUUVNQVF0QkRDRWVEQWdMUVM4aEhnd0hDeUFCUVFGcUlRRkJJaUVlREFZTFFSOGhIZ3dGQ3lBQVFRQTJBZ0FnSXlBa2EwRUVhaUVCUVFZaEhnc2dBQ0FlT2dBc0lBRWhBVUVOSVI0TUF3c2dBRUVBTmdJQUlDWWdJMnRCQjJvaEFVRUxJUjRNQWdzZ0FFRUFOZ0lBQ3lBQVFRQTZBQ3dnSENFQlFRa2hIZ3dBQ3d0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFRzRrWUNBQURZQ0VDQUFRUTgyQWd3TURndEJBQ0VlSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUc0a1lDQUFEWUNFQ0FBUVE4MkFnd01EUXRCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVHV2o0Q0FBRFlDRUNBQVFRczJBZ3dNREF0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSHhpSUNBQURZQ0VDQUFRUXMyQWd3TUN3dEJBQ0VlSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdJallDQUFEWUNFQ0FBUVFvMkFnd01DZ3NnQUVFQ05nSWNJQUFnQVRZQ0ZDQUFRZkNTZ0lBQU5nSVFJQUJCRmpZQ0RFRUFJUjRNQ1F0QkFTRWVEQWdMUWNZQUlSNGdBU0lCSUFKR0RRY2dBMEVJYWlBQUlBRWdBa0hZcG9DQUFFRUtFTG1BZ0lBQUlBTW9BZ3doQVNBREtBSUlEZ01CQndJQUN4Qy9nSUNBQUFBTElBQkJBRFlDSENBQVFZbVRnSUFBTmdJUUlBQkJGellDRENBQUlBRkJBV28yQWhSQkFDRWVEQVVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdlazRDQUFEWUNFQ0FBUVFrMkFneEJBQ0VlREFRTEFrQWdBU0lCSUFKSERRQkJJU0VlREFRTEFrQWdBUzBBQUVFS1JnMEFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSHVqSUNBQURZQ0VDQUFRUW8yQWd4QkFDRWVEQVFMSUFBb0FnUWhDQ0FBUVFBMkFnUWdBQ0FJSUFFUXFvQ0FnQUFpQ0EwQklBRkJBV29oQVF0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSHFrSUNBQURZQ0VDQUFRUmsyQWd3TUFnc2dBRUVnTmdJY0lBQWdDRFlDRENBQUlBRkJBV28yQWhSQkFDRWVEQUVMQWtBZ0FTSUJJQUpIRFFCQkZDRWVEQUVMSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFUVJNaEhnc2dBMEVRYWlTQWdJQ0FBQ0FlQzY4QkFRSi9JQUVvQWdBaEJnSkFBa0FnQWlBRFJnMEFJQVFnQm1vaEJDQUdJQU5xSUFKcklRY2dBaUFHUVg5eklBVnFJZ1pxSVFVRFFBSkFJQUl0QUFBZ0JDMEFBRVlOQUVFQ0lRUU1Bd3NDUUNBR0RRQkJBQ0VFSUFVaEFnd0RDeUFHUVg5cUlRWWdCRUVCYWlFRUlBSkJBV29pQWlBRFJ3MEFDeUFISVFZZ0F5RUNDeUFBUVFFMkFnQWdBU0FHTmdJQUlBQWdBallDQkE4TElBRkJBRFlDQUNBQUlBUTJBZ0FnQUNBQ05nSUVDd29BSUFBUXU0Q0FnQUFMbFRjQkMzOGpnSUNBZ0FCQkVHc2lBU1NBZ0lDQUFBSkFRUUFvQXFDMGdJQUFEUUJCQUJDK2dJQ0FBRUdBdUlTQUFHc2lBa0haQUVrTkFFRUFJUU1DUUVFQUtBTGd0NENBQUNJRURRQkJBRUovTndMc3Q0Q0FBRUVBUW9DQWhJQ0FnTUFBTndMa3Q0Q0FBRUVBSUFGQkNHcEJjSEZCMktyVnFnVnpJZ1EyQXVDM2dJQUFRUUJCQURZQzlMZUFnQUJCQUVFQU5nTEV0NENBQUF0QkFDQUNOZ0xNdDRDQUFFRUFRWUM0aElBQU5nTEl0NENBQUVFQVFZQzRoSUFBTmdLWXRJQ0FBRUVBSUFRMkFxeTBnSUFBUVFCQmZ6WUNxTFNBZ0FBRFFDQURRY1MwZ0lBQWFpQURRYmkwZ0lBQWFpSUVOZ0lBSUFRZ0EwR3d0SUNBQUdvaUJUWUNBQ0FEUWJ5MGdJQUFhaUFGTmdJQUlBTkJ6TFNBZ0FCcUlBTkJ3TFNBZ0FCcUlnVTJBZ0FnQlNBRU5nSUFJQU5CMUxTQWdBQnFJQU5CeUxTQWdBQnFJZ1EyQWdBZ0JDQUZOZ0lBSUFOQjBMU0FnQUJxSUFRMkFnQWdBMEVnYWlJRFFZQUNSdzBBQzBHQXVJU0FBRUY0UVlDNGhJQUFhMEVQY1VFQVFZQzRoSUFBUVFocVFROXhHeUlEYWlJRVFRUnFJQUlnQTJ0QlNHb2lBMEVCY2pZQ0FFRUFRUUFvQXZDM2dJQUFOZ0trdElDQUFFRUFJQVEyQXFDMGdJQUFRUUFnQXpZQ2xMU0FnQUFnQWtHQXVJU0FBR3BCVEdwQk9EWUNBQXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBRUhzQVVzTkFBSkFRUUFvQW9pMGdJQUFJZ1pCRUNBQVFSTnFRWEJ4SUFCQkMwa2JJZ0pCQTNZaUJIWWlBMEVEY1VVTkFDQURRUUZ4SUFSeVFRRnpJZ1ZCQTNRaUFFRzR0SUNBQUdvb0FnQWlCRUVJYWlFREFrQUNRQ0FFS0FJSUlnSWdBRUd3dElDQUFHb2lBRWNOQUVFQUlBWkJmaUFGZDNFMkFvaTBnSUFBREFFTElBQWdBallDQ0NBQ0lBQTJBZ3dMSUFRZ0JVRURkQ0lGUVFOeU5nSUVJQVFnQldwQkJHb2lCQ0FFS0FJQVFRRnlOZ0lBREF3TElBSkJBQ2dDa0xTQWdBQWlCMDBOQVFKQUlBTkZEUUFDUUFKQUlBTWdCSFJCQWlBRWRDSURRUUFnQTJ0eWNTSURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtb2lCVUVEZENJQVFiaTBnSUFBYWlnQ0FDSUVLQUlJSWdNZ0FFR3d0SUNBQUdvaUFFY05BRUVBSUFaQmZpQUZkM0VpQmpZQ2lMU0FnQUFNQVFzZ0FDQUROZ0lJSUFNZ0FEWUNEQXNnQkVFSWFpRURJQVFnQWtFRGNqWUNCQ0FFSUFWQkEzUWlCV29nQlNBQ2F5SUZOZ0lBSUFRZ0Ftb2lBQ0FGUVFGeU5nSUVBa0FnQjBVTkFDQUhRUU4ySWdoQkEzUkJzTFNBZ0FCcUlRSkJBQ2dDbkxTQWdBQWhCQUpBQWtBZ0JrRUJJQWgwSWdoeERRQkJBQ0FHSUFoeU5nS0l0SUNBQUNBQ0lRZ01BUXNnQWlnQ0NDRUlDeUFJSUFRMkFnd2dBaUFFTmdJSUlBUWdBallDRENBRUlBZzJBZ2dMUVFBZ0FEWUNuTFNBZ0FCQkFDQUZOZ0tRdElDQUFBd01DMEVBS0FLTXRJQ0FBQ0lKUlEwQklBbEJBQ0FKYTNGQmYyb2lBeUFEUVF4MlFSQnhJZ04ySWdSQkJYWkJDSEVpQlNBRGNpQUVJQVYySWdOQkFuWkJCSEVpQkhJZ0F5QUVkaUlEUVFGMlFRSnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQmNTSUVjaUFESUFSMmFrRUNkRUc0dG9DQUFHb29BZ0FpQUNnQ0JFRjRjU0FDYXlFRUlBQWhCUUpBQTBBQ1FDQUZLQUlRSWdNTkFDQUZRUlJxS0FJQUlnTkZEUUlMSUFNb0FnUkJlSEVnQW1zaUJTQUVJQVVnQkVraUJSc2hCQ0FESUFBZ0JSc2hBQ0FESVFVTUFBc0xJQUFvQWhnaENnSkFJQUFvQWd3aUNDQUFSZzBBUVFBb0FwaTBnSUFBSUFBb0FnZ2lBMHNhSUFnZ0F6WUNDQ0FESUFnMkFnd01Dd3NDUUNBQVFSUnFJZ1VvQWdBaUF3MEFJQUFvQWhBaUEwVU5BeUFBUVJCcUlRVUxBMEFnQlNFTElBTWlDRUVVYWlJRktBSUFJZ01OQUNBSVFSQnFJUVVnQ0NnQ0VDSUREUUFMSUF0QkFEWUNBQXdLQzBGL0lRSWdBRUcvZjBzTkFDQUFRUk5xSWdOQmNIRWhBa0VBS0FLTXRJQ0FBQ0lIUlEwQVFRQWhDd0pBSUFKQmdBSkpEUUJCSHlFTElBSkIvLy8vQjBzTkFDQURRUWgySWdNZ0EwR0EvajlxUVJCMlFRaHhJZ04wSWdRZ0JFR0E0QjlxUVJCMlFRUnhJZ1IwSWdVZ0JVR0FnQTlxUVJCMlFRSnhJZ1YwUVE5MklBTWdCSElnQlhKcklnTkJBWFFnQWlBRFFSVnFka0VCY1hKQkhHb2hDd3RCQUNBQ2F5RUVBa0FDUUFKQUFrQWdDMEVDZEVHNHRvQ0FBR29vQWdBaUJRMEFRUUFoQTBFQUlRZ01BUXRCQUNFRElBSkJBRUVaSUF0QkFYWnJJQXRCSDBZYmRDRUFRUUFoQ0FOQUFrQWdCU2dDQkVGNGNTQUNheUlHSUFSUERRQWdCaUVFSUFVaENDQUdEUUJCQUNFRUlBVWhDQ0FGSVFNTUF3c2dBeUFGUVJScUtBSUFJZ1lnQmlBRklBQkJIWFpCQkhGcVFSQnFLQUlBSWdWR0d5QURJQVliSVFNZ0FFRUJkQ0VBSUFVTkFBc0xBa0FnQXlBSWNnMEFRUUFoQ0VFQ0lBdDBJZ05CQUNBRGEzSWdCM0VpQTBVTkF5QURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRlFRVjJRUWh4SWdBZ0EzSWdCU0FBZGlJRFFRSjJRUVJ4SWdWeUlBTWdCWFlpQTBFQmRrRUNjU0lGY2lBRElBVjJJZ05CQVhaQkFYRWlCWElnQXlBRmRtcEJBblJCdUxhQWdBQnFLQUlBSVFNTElBTkZEUUVMQTBBZ0F5Z0NCRUY0Y1NBQ2F5SUdJQVJKSVFBQ1FDQURLQUlRSWdVTkFDQURRUlJxS0FJQUlRVUxJQVlnQkNBQUd5RUVJQU1nQ0NBQUd5RUlJQVVoQXlBRkRRQUxDeUFJUlEwQUlBUkJBQ2dDa0xTQWdBQWdBbXRQRFFBZ0NDZ0NHQ0VMQWtBZ0NDZ0NEQ0lBSUFoR0RRQkJBQ2dDbUxTQWdBQWdDQ2dDQ0NJRFN4b2dBQ0FETmdJSUlBTWdBRFlDREF3SkN3SkFJQWhCRkdvaUJTZ0NBQ0lERFFBZ0NDZ0NFQ0lEUlEwRElBaEJFR29oQlFzRFFDQUZJUVlnQXlJQVFSUnFJZ1VvQWdBaUF3MEFJQUJCRUdvaEJTQUFLQUlRSWdNTkFBc2dCa0VBTmdJQURBZ0xBa0JCQUNnQ2tMU0FnQUFpQXlBQ1NRMEFRUUFvQXB5MGdJQUFJUVFDUUFKQUlBTWdBbXNpQlVFUVNRMEFJQVFnQW1vaUFDQUZRUUZ5TmdJRVFRQWdCVFlDa0xTQWdBQkJBQ0FBTmdLY3RJQ0FBQ0FFSUFOcUlBVTJBZ0FnQkNBQ1FRTnlOZ0lFREFFTElBUWdBMEVEY2pZQ0JDQURJQVJxUVFScUlnTWdBeWdDQUVFQmNqWUNBRUVBUVFBMkFweTBnSUFBUVFCQkFEWUNrTFNBZ0FBTElBUkJDR29oQXd3S0N3SkFRUUFvQXBTMGdJQUFJZ0FnQWswTkFFRUFLQUtndElDQUFDSURJQUpxSWdRZ0FDQUNheUlGUVFGeU5nSUVRUUFnQlRZQ2xMU0FnQUJCQUNBRU5nS2d0SUNBQUNBRElBSkJBM0kyQWdRZ0EwRUlhaUVEREFvTEFrQUNRRUVBS0FMZ3Q0Q0FBRVVOQUVFQUtBTG90NENBQUNFRURBRUxRUUJDZnpjQzdMZUFnQUJCQUVLQWdJU0FnSURBQURjQzVMZUFnQUJCQUNBQlFReHFRWEJ4UWRpcTFhb0ZjellDNExlQWdBQkJBRUVBTmdMMHQ0Q0FBRUVBUVFBMkFzUzNnSUFBUVlDQUJDRUVDMEVBSVFNQ1FDQUVJQUpCeHdCcUlnZHFJZ1pCQUNBRWF5SUxjU0lJSUFKTERRQkJBRUV3TmdMNHQ0Q0FBQXdLQ3dKQVFRQW9Bc0MzZ0lBQUlnTkZEUUFDUUVFQUtBSzR0NENBQUNJRUlBaHFJZ1VnQkUwTkFDQUZJQU5ORFFFTFFRQWhBMEVBUVRBMkF2aTNnSUFBREFvTFFRQXRBTVMzZ0lBQVFRUnhEUVFDUUFKQUFrQkJBQ2dDb0xTQWdBQWlCRVVOQUVISXQ0Q0FBQ0VEQTBBQ1FDQURLQUlBSWdVZ0JFc05BQ0FGSUFNb0FnUnFJQVJMRFFNTElBTW9BZ2dpQXcwQUN3dEJBQkMrZ0lDQUFDSUFRWDlHRFFVZ0NDRUdBa0JCQUNnQzVMZUFnQUFpQTBGL2FpSUVJQUJ4UlEwQUlBZ2dBR3NnQkNBQWFrRUFJQU5yY1dvaEJnc2dCaUFDVFEwRklBWkIvdi8vL3dkTERRVUNRRUVBS0FMQXQ0Q0FBQ0lEUlEwQVFRQW9BcmkzZ0lBQUlnUWdCbW9pQlNBRVRRMEdJQVVnQTBzTkJnc2dCaEMrZ0lDQUFDSURJQUJIRFFFTUJ3c2dCaUFBYXlBTGNTSUdRZjcvLy84SFN3MEVJQVlRdm9DQWdBQWlBQ0FES0FJQUlBTW9BZ1JxUmcwRElBQWhBd3NDUUNBRFFYOUdEUUFnQWtISUFHb2dCazBOQUFKQUlBY2dCbXRCQUNnQzZMZUFnQUFpQkdwQkFDQUVhM0VpQkVIKy8vLy9CMDBOQUNBRElRQU1Cd3NDUUNBRUVMNkFnSUFBUVg5R0RRQWdCQ0FHYWlFR0lBTWhBQXdIQzBFQUlBWnJFTDZBZ0lBQUdnd0VDeUFESVFBZ0EwRi9SdzBGREFNTFFRQWhDQXdIQzBFQUlRQU1CUXNnQUVGL1J3MENDMEVBUVFBb0FzUzNnSUFBUVFSeU5nTEV0NENBQUFzZ0NFSCsvLy8vQjBzTkFTQUlFTDZBZ0lBQUlRQkJBQkMrZ0lDQUFDRURJQUJCZjBZTkFTQURRWDlHRFFFZ0FDQURUdzBCSUFNZ0FHc2lCaUFDUVRocVRRMEJDMEVBUVFBb0FyaTNnSUFBSUFacUlnTTJBcmkzZ0lBQUFrQWdBMEVBS0FLOHQ0Q0FBRTBOQUVFQUlBTTJBcnkzZ0lBQUN3SkFBa0FDUUFKQVFRQW9BcUMwZ0lBQUlnUkZEUUJCeUxlQWdBQWhBd05BSUFBZ0F5Z0NBQ0lGSUFNb0FnUWlDR3BHRFFJZ0F5Z0NDQ0lERFFBTUF3c0xBa0FDUUVFQUtBS1l0SUNBQUNJRFJRMEFJQUFnQTA4TkFRdEJBQ0FBTmdLWXRJQ0FBQXRCQUNFRFFRQWdCallDekxlQWdBQkJBQ0FBTmdMSXQ0Q0FBRUVBUVg4MkFxaTBnSUFBUVFCQkFDZ0M0TGVBZ0FBMkFxeTBnSUFBUVFCQkFEWUMxTGVBZ0FBRFFDQURRY1MwZ0lBQWFpQURRYmkwZ0lBQWFpSUVOZ0lBSUFRZ0EwR3d0SUNBQUdvaUJUWUNBQ0FEUWJ5MGdJQUFhaUFGTmdJQUlBTkJ6TFNBZ0FCcUlBTkJ3TFNBZ0FCcUlnVTJBZ0FnQlNBRU5nSUFJQU5CMUxTQWdBQnFJQU5CeUxTQWdBQnFJZ1EyQWdBZ0JDQUZOZ0lBSUFOQjBMU0FnQUJxSUFRMkFnQWdBMEVnYWlJRFFZQUNSdzBBQ3lBQVFYZ2dBR3RCRDNGQkFDQUFRUWhxUVE5eEd5SURhaUlFSUFZZ0EydEJTR29pQTBFQmNqWUNCRUVBUVFBb0F2QzNnSUFBTmdLa3RJQ0FBRUVBSUFRMkFxQzBnSUFBUVFBZ0F6WUNsTFNBZ0FBZ0JpQUFha0ZNYWtFNE5nSUFEQUlMSUFNdEFBeEJDSEVOQUNBRklBUkxEUUFnQUNBRVRRMEFJQVJCZUNBRWEwRVBjVUVBSUFSQkNHcEJEM0ViSWdWcUlnQkJBQ2dDbExTQWdBQWdCbW9pQ3lBRmF5SUZRUUZ5TmdJRUlBTWdDQ0FHYWpZQ0JFRUFRUUFvQXZDM2dJQUFOZ0trdElDQUFFRUFJQVUyQXBTMGdJQUFRUUFnQURZQ29MU0FnQUFnQ3lBRWFrRUVha0U0TmdJQURBRUxBa0FnQUVFQUtBS1l0SUNBQUNJTFR3MEFRUUFnQURZQ21MU0FnQUFnQUNFTEN5QUFJQVpxSVFoQnlMZUFnQUFoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQXlnQ0FDQUlSZzBCSUFNb0FnZ2lBdzBBREFJTEN5QURMUUFNUVFoeFJRMEJDMEhJdDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlnVWdCRXNOQXdzZ0F5Z0NDQ0VEREFBTEN5QURJQUEyQWdBZ0F5QURLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViYWlJR0lBSkJBM0kyQWdRZ0NFRjRJQWhyUVE5eFFRQWdDRUVJYWtFUGNSdHFJZ2dnQmlBQ2FpSUNheUVGQWtBZ0JDQUlSdzBBUVFBZ0FqWUNvTFNBZ0FCQkFFRUFLQUtVdElDQUFDQUZhaUlETmdLVXRJQ0FBQ0FDSUFOQkFYSTJBZ1FNQXdzQ1FFRUFLQUtjdElDQUFDQUlSdzBBUVFBZ0FqWUNuTFNBZ0FCQkFFRUFLQUtRdElDQUFDQUZhaUlETmdLUXRJQ0FBQ0FDSUFOQkFYSTJBZ1FnQWlBRGFpQUROZ0lBREFNTEFrQWdDQ2dDQkNJRFFRTnhRUUZIRFFBZ0EwRjRjU0VIQWtBQ1FDQURRZjhCU3cwQUlBZ29BZ2dpQkNBRFFRTjJJZ3RCQTNSQnNMU0FnQUJxSWdCR0dnSkFJQWdvQWd3aUF5QUVSdzBBUVFCQkFDZ0NpTFNBZ0FCQmZpQUxkM0UyQW9pMGdJQUFEQUlMSUFNZ0FFWWFJQU1nQkRZQ0NDQUVJQU0yQWd3TUFRc2dDQ2dDR0NFSkFrQUNRQ0FJS0FJTUlnQWdDRVlOQUNBTElBZ29BZ2dpQTBzYUlBQWdBellDQ0NBRElBQTJBZ3dNQVFzQ1FDQUlRUlJxSWdNb0FnQWlCQTBBSUFoQkVHb2lBeWdDQUNJRURRQkJBQ0VBREFFTEEwQWdBeUVMSUFRaUFFRVVhaUlES0FJQUlnUU5BQ0FBUVJCcUlRTWdBQ2dDRUNJRURRQUxJQXRCQURZQ0FBc2dDVVVOQUFKQUFrQWdDQ2dDSENJRVFRSjBRYmkyZ0lBQWFpSURLQUlBSUFoSERRQWdBeUFBTmdJQUlBQU5BVUVBUVFBb0FveTBnSUFBUVg0Z0JIZHhOZ0tNdElDQUFBd0NDeUFKUVJCQkZDQUpLQUlRSUFoR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFrMkFoZ0NRQ0FJS0FJUUlnTkZEUUFnQUNBRE5nSVFJQU1nQURZQ0dBc2dDQ2dDRkNJRFJRMEFJQUJCRkdvZ0F6WUNBQ0FESUFBMkFoZ0xJQWNnQldvaEJTQUlJQWRxSVFnTElBZ2dDQ2dDQkVGK2NUWUNCQ0FDSUFWcUlBVTJBZ0FnQWlBRlFRRnlOZ0lFQWtBZ0JVSC9BVXNOQUNBRlFRTjJJZ1JCQTNSQnNMU0FnQUJxSVFNQ1FBSkFRUUFvQW9pMGdJQUFJZ1ZCQVNBRWRDSUVjUTBBUVFBZ0JTQUVjallDaUxTQWdBQWdBeUVFREFFTElBTW9BZ2doQkFzZ0JDQUNOZ0lNSUFNZ0FqWUNDQ0FDSUFNMkFnd2dBaUFFTmdJSURBTUxRUjhoQXdKQUlBVkIvLy8vQjBzTkFDQUZRUWgySWdNZ0EwR0EvajlxUVJCMlFRaHhJZ04wSWdRZ0JFR0E0QjlxUVJCMlFRUnhJZ1IwSWdBZ0FFR0FnQTlxUVJCMlFRSnhJZ0IwUVE5MklBTWdCSElnQUhKcklnTkJBWFFnQlNBRFFSVnFka0VCY1hKQkhHb2hBd3NnQWlBRE5nSWNJQUpDQURjQ0VDQURRUUowUWJpMmdJQUFhaUVFQWtCQkFDZ0NqTFNBZ0FBaUFFRUJJQU4wSWdoeERRQWdCQ0FDTmdJQVFRQWdBQ0FJY2pZQ2pMU0FnQUFnQWlBRU5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUF3c2dCVUVBUVJrZ0EwRUJkbXNnQTBFZlJodDBJUU1nQkNnQ0FDRUFBMEFnQUNJRUtBSUVRWGh4SUFWR0RRSWdBMEVkZGlFQUlBTkJBWFFoQXlBRUlBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQUkyQWdBZ0FpQUVOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BZ3NnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lDeUFHSUFOclFVaHFJZ05CQVhJMkFnUWdDRUZNYWtFNE5nSUFJQVFnQlVFM0lBVnJRUTl4UVFBZ0JVRkpha0VQY1J0cVFVRnFJZ2dnQ0NBRVFSQnFTUnNpQ0VFak5nSUVRUUJCQUNnQzhMZUFnQUEyQXFTMGdJQUFRUUFnQ3pZQ29MU0FnQUJCQUNBRE5nS1V0SUNBQUNBSVFSQnFRUUFwQXRDM2dJQUFOd0lBSUFoQkFDa0N5TGVBZ0FBM0FnaEJBQ0FJUVFocU5nTFF0NENBQUVFQUlBWTJBc3kzZ0lBQVFRQWdBRFlDeUxlQWdBQkJBRUVBTmdMVXQ0Q0FBQ0FJUVNScUlRTURRQ0FEUVFjMkFnQWdCU0FEUVFScUlnTkxEUUFMSUFnZ0JFWU5BeUFJSUFnb0FnUkJmbkUyQWdRZ0NDQUlJQVJySWdZMkFnQWdCQ0FHUVFGeU5nSUVBa0FnQmtIL0FVc05BQ0FHUVFOMklnVkJBM1JCc0xTQWdBQnFJUU1DUUFKQVFRQW9Bb2kwZ0lBQUlnQkJBU0FGZENJRmNRMEFRUUFnQUNBRmNqWUNpTFNBZ0FBZ0F5RUZEQUVMSUFNb0FnZ2hCUXNnQlNBRU5nSU1JQU1nQkRZQ0NDQUVJQU0yQWd3Z0JDQUZOZ0lJREFRTFFSOGhBd0pBSUFaQi8vLy9CMHNOQUNBR1FRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1VnQlVHQTRCOXFRUkIyUVFSeElnVjBJZ0FnQUVHQWdBOXFRUkIyUVFKeElnQjBRUTkySUFNZ0JYSWdBSEpySWdOQkFYUWdCaUFEUVJWcWRrRUJjWEpCSEdvaEF3c2dCRUlBTndJUUlBUkJIR29nQXpZQ0FDQURRUUowUWJpMmdJQUFhaUVGQWtCQkFDZ0NqTFNBZ0FBaUFFRUJJQU4wSWdoeERRQWdCU0FFTmdJQVFRQWdBQ0FJY2pZQ2pMU0FnQUFnQkVFWWFpQUZOZ0lBSUFRZ0JEWUNDQ0FFSUFRMkFnd01CQXNnQmtFQVFSa2dBMEVCZG1zZ0EwRWZSaHQwSVFNZ0JTZ0NBQ0VBQTBBZ0FDSUZLQUlFUVhoeElBWkdEUU1nQTBFZGRpRUFJQU5CQVhRaEF5QUZJQUJCQkhGcVFSQnFJZ2dvQWdBaUFBMEFDeUFJSUFRMkFnQWdCRUVZYWlBRk5nSUFJQVFnQkRZQ0RDQUVJQVEyQWdnTUF3c2dCQ2dDQ0NJRElBSTJBZ3dnQkNBQ05nSUlJQUpCQURZQ0dDQUNJQVEyQWd3Z0FpQUROZ0lJQ3lBR1FRaHFJUU1NQlFzZ0JTZ0NDQ0lESUFRMkFnd2dCU0FFTmdJSUlBUkJHR3BCQURZQ0FDQUVJQVUyQWd3Z0JDQUROZ0lJQzBFQUtBS1V0SUNBQUNJRElBSk5EUUJCQUNnQ29MU0FnQUFpQkNBQ2FpSUZJQU1nQW1zaUEwRUJjallDQkVFQUlBTTJBcFMwZ0lBQVFRQWdCVFlDb0xTQWdBQWdCQ0FDUVFOeU5nSUVJQVJCQ0dvaEF3d0RDMEVBSVFOQkFFRXdOZ0w0dDRDQUFBd0NDd0pBSUF0RkRRQUNRQUpBSUFnZ0NDZ0NIQ0lGUVFKMFFiaTJnSUFBYWlJREtBSUFSdzBBSUFNZ0FEWUNBQ0FBRFFGQkFDQUhRWDRnQlhkeElnYzJBb3kwZ0lBQURBSUxJQXRCRUVFVUlBc29BaEFnQ0VZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQ3pZQ0dBSkFJQWdvQWhBaUEwVU5BQ0FBSUFNMkFoQWdBeUFBTmdJWUN5QUlRUlJxS0FJQUlnTkZEUUFnQUVFVWFpQUROZ0lBSUFNZ0FEWUNHQXNDUUFKQUlBUkJEMHNOQUNBSUlBUWdBbW9pQTBFRGNqWUNCQ0FESUFocVFRUnFJZ01nQXlnQ0FFRUJjallDQUF3QkN5QUlJQUpxSWdBZ0JFRUJjallDQkNBSUlBSkJBM0kyQWdRZ0FDQUVhaUFFTmdJQUFrQWdCRUgvQVVzTkFDQUVRUU4ySWdSQkEzUkJzTFNBZ0FCcUlRTUNRQUpBUVFBb0FvaTBnSUFBSWdWQkFTQUVkQ0lFY1EwQVFRQWdCU0FFY2pZQ2lMU0FnQUFnQXlFRURBRUxJQU1vQWdnaEJBc2dCQ0FBTmdJTUlBTWdBRFlDQ0NBQUlBTTJBZ3dnQUNBRU5nSUlEQUVMUVI4aEF3SkFJQVJCLy8vL0Iwc05BQ0FFUVFoMklnTWdBMEdBL2o5cVFSQjJRUWh4SWdOMElnVWdCVUdBNEI5cVFSQjJRUVJ4SWdWMElnSWdBa0dBZ0E5cVFSQjJRUUp4SWdKMFFROTJJQU1nQlhJZ0FuSnJJZ05CQVhRZ0JDQURRUlZxZGtFQmNYSkJIR29oQXdzZ0FDQUROZ0ljSUFCQ0FEY0NFQ0FEUVFKMFFiaTJnSUFBYWlFRkFrQWdCMEVCSUFOMElnSnhEUUFnQlNBQU5nSUFRUUFnQnlBQ2NqWUNqTFNBZ0FBZ0FDQUZOZ0lZSUFBZ0FEWUNDQ0FBSUFBMkFnd01BUXNnQkVFQVFSa2dBMEVCZG1zZ0EwRWZSaHQwSVFNZ0JTZ0NBQ0VDQWtBRFFDQUNJZ1VvQWdSQmVIRWdCRVlOQVNBRFFSMTJJUUlnQTBFQmRDRURJQVVnQWtFRWNXcEJFR29pQmlnQ0FDSUNEUUFMSUFZZ0FEWUNBQ0FBSUFVMkFoZ2dBQ0FBTmdJTUlBQWdBRFlDQ0F3QkN5QUZLQUlJSWdNZ0FEWUNEQ0FGSUFBMkFnZ2dBRUVBTmdJWUlBQWdCVFlDRENBQUlBTTJBZ2dMSUFoQkNHb2hBd3dCQ3dKQUlBcEZEUUFDUUFKQUlBQWdBQ2dDSENJRlFRSjBRYmkyZ0lBQWFpSURLQUlBUncwQUlBTWdDRFlDQUNBSURRRkJBQ0FKUVg0Z0JYZHhOZ0tNdElDQUFBd0NDeUFLUVJCQkZDQUtLQUlRSUFCR0cyb2dDRFlDQUNBSVJRMEJDeUFJSUFvMkFoZ0NRQ0FBS0FJUUlnTkZEUUFnQ0NBRE5nSVFJQU1nQ0RZQ0dBc2dBRUVVYWlnQ0FDSURSUTBBSUFoQkZHb2dBellDQUNBRElBZzJBaGdMQWtBQ1FDQUVRUTlMRFFBZ0FDQUVJQUpxSWdOQkEzSTJBZ1FnQXlBQWFrRUVhaUlESUFNb0FnQkJBWEkyQWdBTUFRc2dBQ0FDYWlJRklBUkJBWEkyQWdRZ0FDQUNRUU55TmdJRUlBVWdCR29nQkRZQ0FBSkFJQWRGRFFBZ0IwRURkaUlJUVFOMFFiQzBnSUFBYWlFQ1FRQW9BcHkwZ0lBQUlRTUNRQUpBUVFFZ0NIUWlDQ0FHY1EwQVFRQWdDQ0FHY2pZQ2lMU0FnQUFnQWlFSURBRUxJQUlvQWdnaENBc2dDQ0FETmdJTUlBSWdBellDQ0NBRElBSTJBZ3dnQXlBSU5nSUlDMEVBSUFVMkFweTBnSUFBUVFBZ0JEWUNrTFNBZ0FBTElBQkJDR29oQXdzZ0FVRVFhaVNBZ0lDQUFDQURDd29BSUFBUXZZQ0FnQUFMOEEwQkIzOENRQ0FBUlEwQUlBQkJlR29pQVNBQVFYeHFLQUlBSWdKQmVIRWlBR29oQXdKQUlBSkJBWEVOQUNBQ1FRTnhSUTBCSUFFZ0FTZ0NBQ0lDYXlJQlFRQW9BcGkwZ0lBQUlnUkpEUUVnQWlBQWFpRUFBa0JCQUNnQ25MU0FnQUFnQVVZTkFBSkFJQUpCL3dGTERRQWdBU2dDQ0NJRUlBSkJBM1lpQlVFRGRFR3d0SUNBQUdvaUJrWWFBa0FnQVNnQ0RDSUNJQVJIRFFCQkFFRUFLQUtJdElDQUFFRitJQVYzY1RZQ2lMU0FnQUFNQXdzZ0FpQUdSaG9nQWlBRU5nSUlJQVFnQWpZQ0RBd0NDeUFCS0FJWUlRY0NRQUpBSUFFb0Fnd2lCaUFCUmcwQUlBUWdBU2dDQ0NJQ1N4b2dCaUFDTmdJSUlBSWdCallDREF3QkN3SkFJQUZCRkdvaUFpZ0NBQ0lFRFFBZ0FVRVFhaUlDS0FJQUlnUU5BRUVBSVFZTUFRc0RRQ0FDSVFVZ0JDSUdRUlJxSWdJb0FnQWlCQTBBSUFaQkVHb2hBaUFHS0FJUUlnUU5BQXNnQlVFQU5nSUFDeUFIUlEwQkFrQUNRQ0FCS0FJY0lnUkJBblJCdUxhQWdBQnFJZ0lvQWdBZ0FVY05BQ0FDSUFZMkFnQWdCZzBCUVFCQkFDZ0NqTFNBZ0FCQmZpQUVkM0UyQW95MGdJQUFEQU1MSUFkQkVFRVVJQWNvQWhBZ0FVWWJhaUFHTmdJQUlBWkZEUUlMSUFZZ0J6WUNHQUpBSUFFb0FoQWlBa1VOQUNBR0lBSTJBaEFnQWlBR05nSVlDeUFCS0FJVUlnSkZEUUVnQmtFVWFpQUNOZ0lBSUFJZ0JqWUNHQXdCQ3lBREtBSUVJZ0pCQTNGQkEwY05BQ0FESUFKQmZuRTJBZ1JCQUNBQU5nS1F0SUNBQUNBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUR3c2dBeUFCVFEwQUlBTW9BZ1FpQWtFQmNVVU5BQUpBQWtBZ0FrRUNjUTBBQWtCQkFDZ0NvTFNBZ0FBZ0EwY05BRUVBSUFFMkFxQzBnSUFBUVFCQkFDZ0NsTFNBZ0FBZ0FHb2lBRFlDbExTQWdBQWdBU0FBUVFGeU5nSUVJQUZCQUNnQ25MU0FnQUJIRFFOQkFFRUFOZ0tRdElDQUFFRUFRUUEyQXB5MGdJQUFEd3NDUUVFQUtBS2N0SUNBQUNBRFJ3MEFRUUFnQVRZQ25MU0FnQUJCQUVFQUtBS1F0SUNBQUNBQWFpSUFOZ0tRdElDQUFDQUJJQUJCQVhJMkFnUWdBU0FBYWlBQU5nSUFEd3NnQWtGNGNTQUFhaUVBQWtBQ1FDQUNRZjhCU3cwQUlBTW9BZ2dpQkNBQ1FRTjJJZ1ZCQTNSQnNMU0FnQUJxSWdaR0dnSkFJQU1vQWd3aUFpQUVSdzBBUVFCQkFDZ0NpTFNBZ0FCQmZpQUZkM0UyQW9pMGdJQUFEQUlMSUFJZ0JrWWFJQUlnQkRZQ0NDQUVJQUkyQWd3TUFRc2dBeWdDR0NFSEFrQUNRQ0FES0FJTUlnWWdBMFlOQUVFQUtBS1l0SUNBQUNBREtBSUlJZ0pMR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0EwRVVhaUlDS0FJQUlnUU5BQ0FEUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUFDUUFKQUlBTW9BaHdpQkVFQ2RFRzR0b0NBQUdvaUFpZ0NBQ0FEUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTXRJQ0FBRUYrSUFSM2NUWUNqTFNBZ0FBTUFnc2dCMEVRUVJRZ0J5Z0NFQ0FEUmh0cUlBWTJBZ0FnQmtVTkFRc2dCaUFITmdJWUFrQWdBeWdDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBTW9BaFFpQWtVTkFDQUdRUlJxSUFJMkFnQWdBaUFHTmdJWUN5QUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVJQUZCQUNnQ25MU0FnQUJIRFFGQkFDQUFOZ0tRdElDQUFBOExJQU1nQWtGK2NUWUNCQ0FCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFQ3dKQUlBQkIvd0ZMRFFBZ0FFRURkaUlDUVFOMFFiQzBnSUFBYWlFQUFrQUNRRUVBS0FLSXRJQ0FBQ0lFUVFFZ0FuUWlBbkVOQUVFQUlBUWdBbkkyQW9pMGdJQUFJQUFoQWd3QkN5QUFLQUlJSVFJTElBSWdBVFlDRENBQUlBRTJBZ2dnQVNBQU5nSU1JQUVnQWpZQ0NBOExRUjhoQWdKQUlBQkIvLy8vQjBzTkFDQUFRUWgySWdJZ0FrR0EvajlxUVJCMlFRaHhJZ0owSWdRZ0JFR0E0QjlxUVJCMlFRUnhJZ1IwSWdZZ0JrR0FnQTlxUVJCMlFRSnhJZ1owUVE5MklBSWdCSElnQm5KcklnSkJBWFFnQUNBQ1FSVnFka0VCY1hKQkhHb2hBZ3NnQVVJQU53SVFJQUZCSEdvZ0FqWUNBQ0FDUVFKMFFiaTJnSUFBYWlFRUFrQUNRRUVBS0FLTXRJQ0FBQ0lHUVFFZ0FuUWlBM0VOQUNBRUlBRTJBZ0JCQUNBR0lBTnlOZ0tNdElDQUFDQUJRUmhxSUFRMkFnQWdBU0FCTmdJSUlBRWdBVFlDREF3QkN5QUFRUUJCR1NBQ1FRRjJheUFDUVI5R0czUWhBaUFFS0FJQUlRWUNRQU5BSUFZaUJDZ0NCRUY0Y1NBQVJnMEJJQUpCSFhZaEJpQUNRUUYwSVFJZ0JDQUdRUVJ4YWtFUWFpSURLQUlBSWdZTkFBc2dBeUFCTmdJQUlBRkJHR29nQkRZQ0FDQUJJQUUyQWd3Z0FTQUJOZ0lJREFFTElBUW9BZ2dpQUNBQk5nSU1JQVFnQVRZQ0NDQUJRUmhxUVFBMkFnQWdBU0FFTmdJTUlBRWdBRFlDQ0F0QkFFRUFLQUtvdElDQUFFRi9haUlCUVg4Z0FSczJBcWkwZ0lBQUN3dE9BQUpBSUFBTkFEOEFRUkIwRHdzQ1FDQUFRZi8vQTNFTkFDQUFRWDlNRFFBQ1FDQUFRUkIyUUFBaUFFRi9SdzBBUVFCQk1EWUMrTGVBZ0FCQmZ3OExJQUJCRUhRUEN4Qy9nSUNBQUFBTEJBQUFBQXNMaml3QkFFR0FDQXVHTEFFQUFBQUNBQUFBQXdBQUFBUUFBQUFGQUFBQUJnQUFBQWNBQUFBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQnhkV1Z5ZVFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJKdlpIa0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ2IzWmxjbVpzYjNjQVEyaDFibXNnYzJsNlpTQnZkbVZ5Wm14dmR3QlNaWE53YjI1elpTQnZkbVZ5Wm14dmR3QkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdTRlJVVUM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdVbFJUVUM5NExuZ2djbVZ4ZFdWemRBQkZlSEJsWTNSbFpDQlRUMVZTUTBVZ2JXVjBhRzlrSUdadmNpQkpRMFV2ZUM1NElISmxjWFZsYzNRQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQm1jbUZuYldWdWRDQnpkR0Z5ZEFCRmVIQmxZM1JsWkNCa2IzUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOXpkR0YwZFhNQVNXNTJZV3hwWkNCeVpYTndiMjV6WlNCemRHRjBkWE1BU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnY0dGeVlXMWxkR1Z5Y3dCVmMyVnlJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOW9aV0ZrWlhKZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgySmxaMmx1WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JWYm1WNGNHVmpkR1ZrSUdOb1lYSWdhVzRnZFhKc0lITmxjblpsY2dCSmJuWmhiR2xrSUdobFlXUmxjaUIyWVd4MVpTQmphR0Z5QUVsdWRtRnNhV1FnYUdWaFpHVnlJR1pwWld4a0lHTm9ZWElBU1c1MllXeHBaQ0J0YVc1dmNpQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXRnFiM0lnZG1WeWMybHZiZ0JGZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCMlpYSnphVzl1QUVWNGNHVmpkR1ZrSUVOU1RFWWdZV1owWlhJZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUdobFlXUmxjaUIwYjJ0bGJnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzVnliQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYVc0Z2RYSnNBRlZ1Wlhod1pXTjBaV1FnYzNSaGNuUWdZMmhoY2lCcGJpQjFjbXdBUkc5MVlteGxJRUFnYVc0Z2RYSnNBRVZ0Y0hSNUlFTnZiblJsYm5RdFRHVnVaM1JvQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlFTnZiblJsYm5RdFRHVnVaM1JvQUVSMWNHeHBZMkYwWlNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhCaGRHZ0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQm9aV0ZrWlhJZ2RtRnNkV1VBVFdsemMybHVaeUJsZUhCbFkzUmxaQ0JNUmlCaFpuUmxjaUJvWldGa1pYSWdkbUZzZFdVQVNXNTJZV3hwWkNCZ1ZISmhibk5tWlhJdFJXNWpiMlJwYm1kZ0lHaGxZV1JsY2lCMllXeDFaUUJRWVhWelpXUWdZbmtnYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFCSmJuWmhiR2xrSUVWUFJpQnpkR0YwWlFCdmJsOWphSFZ1YTE5b1pXRmtaWElnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlpWldkcGJpQndZWFZ6WlFCdmJsOWphSFZ1YTE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5dFpYTnpZV2RsWDJOdmJYQnNaWFJsSUhCaGRYTmxBRkJoZFhObElHOXVJRU5QVGs1RlExUXZWWEJuY21Ga1pRQlFZWFZ6WlNCdmJpQlFVa2t2VlhCbmNtRmtaUUJGZUhCbFkzUmxaQ0JJVkZSUUx6SWdRMjl1Ym1WamRHbHZiaUJRY21WbVlXTmxBRVY0Y0dWamRHVmtJSE53WVdObElHRm1kR1Z5SUcxbGRHaHZaQUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMmhsWVdSbGNsOW1hV1ZzWkFCUVlYVnpaV1FBU1c1MllXeHBaQ0IzYjNKa0lHVnVZMjkxYm5SbGNtVmtBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHVnVZMjkxYm5SbGNtVmtBRlZ1Wlhod1pXTjBaV1FnWTJoaGNpQnBiaUIxY213Z2MyTm9aVzFoQUZKbGNYVmxjM1FnYUdGeklHbHVkbUZzYVdRZ1lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bllBQk5TMEZEVkVsV1NWUlpBRU5QVUZrQVRrOVVTVVpaQUZCTVFWa0FVRlZVQUVOSVJVTkxUMVZVQUZCUFUxUUFVa1ZRVDFKVUFFaFFSVjlKVGxaQlRFbEVYME5QVGxOVVFVNVVBRWRGVkFCSVVFVmZVMVJTU1VOVUFGSkZSRWxTUlVOVUFFTlBUazVGUTFRQVNGQkZYMGxPVmtGTVNVUmZVMVJCVkZWVEFFOVFWRWxQVGxNQVUwVlVYMUJCVWtGTlJWUkZVZ0JIUlZSZlVFRlNRVTFGVkVWU0FFaFFSVjlWVTBWU0FFaFFSVjlEUWw5RFNGVk9TMTlJUlVGRVJWSUFUVXREUVV4RlRrUkJVZ0JUUlZSVlVBQlVSVUZTUkU5WFRnQklVRVZmUTB4UFUwVkVYME5QVGs1RlExUkpUMDRBU0ZCRlgwbE9Wa0ZNU1VSZlZrVlNVMGxQVGdCSVVFVmZRMEpmVFVWVFUwRkhSVjlDUlVkSlRnQklVRVZmU1U1V1FVeEpSRjlJUlVGRVJWSmZWRTlMUlU0QVNGQkZYMGxPVmtGTVNVUmZWVkpNQUUxTFEwOU1BRUZEVEFCSVVFVmZTVTVVUlZKT1FVd0FTRkJGWDA5TEFGVk9URWxPU3dCVlRreFBRMHNBVUZKSkFFaFFSVjlKVGxaQlRFbEVYME5QVGxSRlRsUmZURVZPUjFSSUFFaFFSVjlWVGtWWVVFVkRWRVZFWDBOUFRsUkZUbFJmVEVWT1IxUklBRVpNVlZOSUFGQlNUMUJRUVZSRFNBQk5MVk5GUVZKRFNBQklVRVZmU1U1V1FVeEpSRjlVVWtGT1UwWkZVbDlGVGtOUFJFbE9Sd0JGZUhCbFkzUmxaQ0JEVWt4R0FFaFFSVjlKVGxaQlRFbEVYME5JVlU1TFgxTkpXa1VBVFU5V1JRQklVRVZmUTBKZlNFVkJSRVZTVTE5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwMUZVMU5CUjBWZlEwOU5VRXhGVkVVQVJFVk1SVlJGQUVoUVJWOUpUbFpCVEVsRVgwVlBSbDlUVkVGVVJRQlFRVlZUUlFCUVZWSkhSUUJOUlZKSFJRQklVRVZmVUVGVlUwVkVYMVZRUjFKQlJFVUFTRkJGWDFCQlZWTkZSRjlJTWw5VlVFZFNRVVJGQUZOUFZWSkRSUUJCVGs1UFZVNURSUUJVVWtGRFJRQkVSVk5EVWtsQ1JRQlZUbE5WUWxORFVrbENSUUJTUlVOUFVrUUFTRkJGWDBsT1ZrRk1TVVJmVFVWVVNFOUVBRkJTVDFCR1NVNUVBRlZPUWtsT1JBQlNSVUpKVGtRQVNGQkZYME5TWDBWWVVFVkRWRVZFQUVoUVJWOU1SbDlGV0ZCRlExUkZSQUJJVUVWZlVFRlZVMFZFQUVoRlFVUUFSWGh3WldOMFpXUWdTRlJVVUM4QTNBc0FBTThMQUFEVENnQUFtUTBBQUJBTUFBQmRDd0FBWHcwQUFMVUxBQUM2Q2dBQWN3c0FBSndMQUFEMUN3QUFjd3dBQU84S0FBRGNEQUFBUnd3QUFJY0xBQUNQREFBQXZRd0FBQzhMQUFDbkRBQUFxUTBBQUFRTkFBQVhEUUFBSmdzQUFJa05BQURWREFBQXp3b0FBTFFOQUFDdUNnQUFvUW9BQU9jS0FBQUNDd0FBUFEwQUFKQUtBQURzQ3dBQXhRc0FBSW9NQUFCeURRQUFOQXdBQUVBTUFBRHFDd0FBaEEwQUFJSU5BQUI3RFFBQXl3c0FBTE1LQUFDRkNnQUFwUW9BQVA0TUFBQStEQUFBbFFvQUFFNE5BQUJNRFFBQU9Bd0FBUGdNQUFCREN3QUE1UXNBQU9NTEFBQXREUUFBOFFzQUFFTU5BQUEwRFFBQVRnc0FBSndLQUFEeURBQUFWQXNBQUJnTEFBQUtDd0FBM2dvQUFGZ05BQUF1REFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJiRzl6WldWbGNDMWhiR2wyWlFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQlkyaDFibXRsWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVBQVFFQkFRRUFBQUVCQUFFQkFBRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmxZM1JwYjI1bGJuUXRiR1Z1WjNSb2IyNXliM2g1TFdOdmJtNWxZM1JwYjI0QUFBQUFBQUFBQUFBQUFBQUFBQUJ5WVc1elptVnlMV1Z1WTI5a2FXNW5jR2R5WVdSbERRb05DZzBLVTAwTkNnMEtWRlJRTDBORkwxUlRVQzhBQUFBQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUlBQVFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFRRUZBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUFBUUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNRUFBQUVCQVFFQkFRRUJBUUVCQVVFQkFRRUJBUUVCQVFFQkFRQUJBQUdCd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJPVDFWT1EwVkZRMHRQVlZST1JVTlVSVlJGUTFKSlFrVk1WVk5JUlZSRlFVUlRSVUZTUTBoU1IwVkRWRWxXU1ZSWlRFVk9SRUZTVmtWUFZFbEdXVkJVU1U5T1UwTklVMFZCV1ZOVVFWUkRTRWRGVDFKRVNWSkZRMVJQVWxSU1EwaFFRVkpCVFVWVVJWSlZVa05GUWxORFVrbENSVUZTUkU5WFRrRkRSVWxPUkU1TFEwdFZRbE5EVWtsQ1JVaFVWRkF2UVVSVVVDOD1cIjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHBfc2ltZC53YXNtLmpzXG52YXIgcmVxdWlyZV9sbGh0dHBfc2ltZF93YXNtID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cF9zaW1kLndhc20uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gXCJBR0Z6YlFFQUFBQUJNQWhnQVg4QmYyQURmMzkvQVg5Z0JIOS9mMzhCZjJBQUFHQURmMzkvQUdBQmZ3QmdBbjkvQUdBR2YzOS9mMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFDQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXprNEF3TUVBQUFGQUFBQUFBQUFCUUVGQUFVRkJRQUFCZ0FBQUFZR0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBQUJBUWNBQUFVRkFBTUVCUUZ3QVE0T0JRTUJBQUlHQ0FGL0FVR0F1QVFMQi9VRUh3WnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFKR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUtHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQTFER3hzYUhSMGNGOWhiR3h2WXdBTUJtMWhiR3h2WXdBNkMyeHNhSFIwY0Y5bWNtVmxBQTBFWm5KbFpRQThEMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU9GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBUEZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FRRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJFV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFTRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBVERHeHNhSFIwY0Y5eVpYTmxkQUFVRG14c2FIUjBjRjlsZUdWamRYUmxBQlVVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZnMXNiR2gwZEhCZlptbHVhWE5vQUJjTWJHeG9kSFJ3WDNCaGRYTmxBQmdOYkd4b2RIUndYM0psYzNWdFpRQVpHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFhRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR3hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FjRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQjBVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhoRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWZFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFnR214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5b1pXRmtaWEp6QUNFaGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyTm9kVzVyWldSZmJHVnVaM1JvQUNJWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQURNSkV3RUFRUUVMRFFFQ0F3UUZDd1lITGlvb0pDWUt1S2dDT0FJQUN3Z0FFSWlBZ0lBQUN4a0FJQUFRdG9DQWdBQWFJQUFnQWpZQ05DQUFJQUU2QUNnTEhBQWdBQ0FBTHdFeUlBQXRBQzRnQUJDMWdJQ0FBQkNBZ0lDQUFBc3BBUUYvUVRnUXVvQ0FnQUFpQVJDMmdJQ0FBQm9nQVVHQWlJQ0FBRFlDTkNBQklBQTZBQ2dnQVFzS0FDQUFFTHlBZ0lBQUN3Y0FJQUF0QUNnTEJ3QWdBQzBBS2dzSEFDQUFMUUFyQ3djQUlBQXRBQ2tMQndBZ0FDOEJNZ3NIQUNBQUxRQXVDMFVCQkg4Z0FDZ0NHQ0VCSUFBdEFDMGhBaUFBTFFBb0lRTWdBQ2dDTkNFRUlBQVF0b0NBZ0FBYUlBQWdCRFlDTkNBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBc1JBQ0FBSUFFZ0FTQUNhaEMzZ0lDQUFBcytBUUY3SUFEOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBaUFmMExBZ0FnQUVFd2FrSUFOd0lBSUFCQklHb2dBZjBMQWdBZ0FFRVFhaUFCL1FzQ0FBdG5BUUYvUVFBaEFRSkFJQUFvQWd3TkFBSkFBa0FDUUFKQUlBQXRBQzhPQXdFQUF3SUxJQUFvQWpRaUFVVU5BQ0FCS0FJY0lnRkZEUUFnQUNBQkVZQ0FnSUFBQUNJQkRRTUxRUUFQQ3hDL2dJQ0FBQUFMSUFCQi81R0FnQUEyQWhCQkRpRUJDeUFCQ3g0QUFrQWdBQ2dDREEwQUlBQkJoSlNBZ0FBMkFoQWdBRUVWTmdJTUN3c1dBQUpBSUFBb0FneEJGVWNOQUNBQVFRQTJBZ3dMQ3hZQUFrQWdBQ2dDREVFV1J3MEFJQUJCQURZQ0RBc0xCd0FnQUNnQ0RBc0hBQ0FBS0FJUUN3a0FJQUFnQVRZQ0VBc0hBQ0FBS0FJVUN5SUFBa0FnQUVFYVNRMEFFTCtBZ0lBQUFBc2dBRUVDZEVISW00Q0FBR29vQWdBTElnQUNRQ0FBUVM1SkRRQVF2NENBZ0FBQUN5QUFRUUowUWJDY2dJQUFhaWdDQUFzV0FDQUFJQUF0QUMxQi9nRnhJQUZCQUVkeU9nQXRDeGtBSUFBZ0FDMEFMVUg5QVhFZ0FVRUFSMEVCZEhJNkFDMExMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0FDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSUVJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQm5JNkFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDQ0NJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRZEtLZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJc0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0Fnd2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIZGs0Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NNQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUlRSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkJ3NUNBZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWpRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0ZDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSWNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BaGdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSFNpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDSUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJa0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMFVCQVg4Q1FBSkFJQUF2QVRCQkZIRkJGRWNOQUVFQklRTWdBQzBBS0VFQlJnMEJJQUF2QVRKQjVRQkdJUU1NQVFzZ0FDMEFLVUVGUmlFREN5QUFJQU02QUM1QkFBdnlBUUVEZjBFQklRTUNRQ0FBTHdFd0lnUkJDSEVOQUNBQUtRTWdRZ0JTSVFNTEFrQUNRQ0FBTFFBdVJRMEFRUUVoQlNBQUxRQXBRUVZHRFFGQkFTRUZJQVJCd0FCeFJTQURjVUVCUncwQkMwRUFJUVVnQkVIQUFIRU5BRUVDSVFVZ0JFRUljUTBBQWtBZ0JFR0FCSEZGRFFBQ1FDQUFMUUFvUVFGSERRQWdBQzBBTFVFS2NRMEFRUVVQQzBFRUR3c0NRQ0FFUVNCeERRQUNRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUFRWngvYWtIa0FFa05BQ0FBUWN3QlJnMEFJQUJCc0FKR0RRQkJCQ0VGSUFSQmlBUnhRWUFFUmcwQ0lBUkJLSEZGRFFJTFFRQVBDMEVBUVFNZ0FDa0RJRkFiSVFVTElBVUxYUUVDZjBFQUlRRUNRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZJQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1pSUZRWngvYWtIa0FFa05BQ0FGUWN3QlJnMEFJQVZCc0FKR0RRQWdCRUhBQUhFTkFFRUFJUU1nQkVHSUJIRkJnQVJHRFFBZ0JFRW9jVUVBUnlFREN5QUFRUUE3QVRBZ0FFRUFPZ0F2SUFNTGxBRUJBbjhDUUFKQUFrQWdBQzBBS2tVTkFDQUFMUUFyUlEwQVFRQWhBU0FBTHdFd0lnSkJBbkZGRFFFTUFndEJBQ0VCSUFBdkFUQWlBa0VCY1VVTkFRdEJBU0VCSUFBdEFDaEJBVVlOQUNBQUx3RXlJZ0JCbkg5cVFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BQ0FDUWNBQWNRMEFRUUFoQVNBQ1FZZ0VjVUdBQkVZTkFDQUNRU2h4UVFCSElRRUxJQUVMU0FFQmV5QUFRUkJxL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBSWdIOUN3TUFJQUFnQWYwTEF3QWdBRUV3YWtJQU53TUFJQUJCSUdvZ0FmMExBd0FnQUVHOEFUWUNIRUVBQzNzQkFYOENRQ0FBS0FJTUlnTU5BQUpBSUFBb0FnUkZEUUFnQUNBQk5nSUVDd0pBSUFBZ0FTQUNFTGlBZ0lBQUlnTU5BQ0FBS0FJTUR3c2dBQ0FETmdJY1FRQWhBeUFBS0FJRUlnRkZEUUFnQUNBQklBSWdBQ2dDQ0JHQmdJQ0FBQUFpQVVVTkFDQUFJQUkyQWhRZ0FDQUJOZ0lNSUFFaEF3c2dBd3ZUemdFREhIOERmZ1YvSTRDQWdJQUFRUkJySWdNa2dJQ0FnQUFnQVNFRUlBRWhCU0FCSVFZZ0FTRUhJQUVoQ0NBQklRa2dBU0VLSUFFaEN5QUJJUXdnQVNFTklBRWhEaUFCSVE4Z0FTRVFJQUVoRVNBQklSSWdBU0VUSUFFaEZDQUJJUlVnQVNFV0lBRWhGeUFCSVJnZ0FTRVpJQUVoR2lBQklSc2dBU0VjSUFFaEhRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQW9BaHdpSGtGL2FnNjhBYmNCQWJZQkFnTUVCUVlIQ0FrS0N3d05EZzhRd0FHL0FSRVNFN1VCRkJVV0Z4Z1pHcjBCdkFFYkhCMGVIeUFodEFHekFTSWpzZ0d4QVNRbEppY29LU29yTEMwdUx6QXhNak0wTlRZM09EazZ1QUU3UEQwK1AwQkJRa05FUlVaSFNFbEtTMHhOVGs5UVVWSlRWRlZXVjFoWldsdGNYVjVmWUdGaVkyUmxabWRvYVdwcmJHMXViM0J4Y25OMGRYWjNlSGw2ZTN4OWZuK0FBWUVCZ2dHREFZUUJoUUdHQVljQmlBR0pBWW9CaXdHTUFZMEJqZ0dQQVpBQmtRR1NBWk1CbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndFQXVRRUxRUUFoSGd5dkFRdEJEeUVlREs0QkMwRU9JUjRNclFFTFFSQWhIZ3lzQVF0QkVTRWVES3NCQzBFVUlSNE1xZ0VMUVJVaEhneXBBUXRCRmlFZURLZ0JDMEVYSVI0TXB3RUxRUmdoSGd5bUFRdEJDQ0VlREtVQkMwRVpJUjRNcEFFTFFSb2hIZ3lqQVF0QkV5RWVES0lCQzBFU0lSNE1vUUVMUVJzaEhneWdBUXRCSENFZURKOEJDMEVkSVI0TW5nRUxRUjRoSGd5ZEFRdEJxZ0VoSGd5Y0FRdEJxd0VoSGd5YkFRdEJJQ0VlREpvQkMwRWhJUjRNbVFFTFFTSWhIZ3lZQVF0Qkl5RWVESmNCQzBFa0lSNE1sZ0VMUWEwQklSNE1sUUVMUVNVaEhneVVBUXRCS1NFZURKTUJDMEVOSVI0TWtnRUxRU1loSGd5UkFRdEJKeUVlREpBQkMwRW9JUjRNandFTFFTNGhIZ3lPQVF0QktpRWVESTBCQzBHdUFTRWVESXdCQzBFTUlSNE1pd0VMUVM4aEhneUtBUXRCS3lFZURJa0JDMEVMSVI0TWlBRUxRU3doSGd5SEFRdEJMU0VlRElZQkMwRUtJUjRNaFFFTFFURWhIZ3lFQVF0Qk1DRWVESU1CQzBFSklSNE1nZ0VMUVI4aEhneUJBUXRCTWlFZURJQUJDMEV6SVI0TWZ3dEJOQ0VlREg0TFFUVWhIZ3g5QzBFMklSNE1mQXRCTnlFZURIc0xRVGdoSGd4NkMwRTVJUjRNZVF0Qk9pRWVESGdMUWF3QklSNE1kd3RCT3lFZURIWUxRVHdoSGd4MUMwRTlJUjRNZEF0QlBpRWVESE1MUVQ4aEhneHlDMEhBQUNFZURIRUxRY0VBSVI0TWNBdEJ3Z0FoSGd4dkMwSERBQ0VlREc0TFFjUUFJUjRNYlF0QkJ5RWVER3dMUWNVQUlSNE1hd3RCQmlFZURHb0xRY1lBSVI0TWFRdEJCU0VlREdnTFFjY0FJUjRNWnd0QkJDRWVER1lMUWNnQUlSNE1aUXRCeVFBaEhneGtDMEhLQUNFZURHTUxRY3NBSVI0TVlndEJBeUVlREdFTFFjd0FJUjRNWUF0QnpRQWhIZ3hmQzBIT0FDRWVERjRMUWRBQUlSNE1YUXRCendBaEhneGNDMEhSQUNFZURGc0xRZElBSVI0TVdndEJBaUVlREZrTFFkTUFJUjRNV0F0QjFBQWhIZ3hYQzBIVkFDRWVERllMUWRZQUlSNE1WUXRCMXdBaEhneFVDMEhZQUNFZURGTUxRZGtBSVI0TVVndEIyZ0FoSGd4UkMwSGJBQ0VlREZBTFFkd0FJUjRNVHd0QjNRQWhIZ3hPQzBIZUFDRWVERTBMUWQ4QUlSNE1UQXRCNEFBaEhneExDMEhoQUNFZURFb0xRZUlBSVI0TVNRdEI0d0FoSGd4SUMwSGtBQ0VlREVjTFFlVUFJUjRNUmd0QjVnQWhIZ3hGQzBIbkFDRWVERVFMUWVnQUlSNE1Rd3RCNlFBaEhneENDMEhxQUNFZURFRUxRZXNBSVI0TVFBdEI3QUFoSGd3L0MwSHRBQ0VlREQ0TFFlNEFJUjRNUFF0Qjd3QWhIZ3c4QzBId0FDRWVERHNMUWZFQUlSNE1PZ3RCOGdBaEhndzVDMEh6QUNFZUREZ0xRZlFBSVI0TU53dEI5UUFoSGd3MkMwSDJBQ0VlRERVTFFmY0FJUjRNTkF0QitBQWhIZ3d6QzBINUFDRWVERElMUWZvQUlSNE1NUXRCK3dBaEhnd3dDMEg4QUNFZURDOExRZjBBSVI0TUxndEIvZ0FoSGd3dEMwSC9BQ0VlREN3TFFZQUJJUjRNS3d0QmdRRWhIZ3dxQzBHQ0FTRWVEQ2tMUVlNQklSNE1LQXRCaEFFaEhnd25DMEdGQVNFZURDWUxRWVlCSVI0TUpRdEJod0VoSGd3a0MwR0lBU0VlRENNTFFZa0JJUjRNSWd0QmlnRWhIZ3doQzBHTEFTRWVEQ0FMUVl3QklSNE1Id3RCalFFaEhnd2VDMEdPQVNFZURCMExRWThCSVI0TUhBdEJrQUVoSGd3YkMwR1JBU0VlREJvTFFaSUJJUjRNR1F0Qmt3RWhIZ3dZQzBHVUFTRWVEQmNMUVpVQklSNE1GZ3RCbGdFaEhnd1ZDMEdYQVNFZURCUUxRWmdCSVI0TUV3dEJtUUVoSGd3U0MwR2RBU0VlREJFTFFab0JJUjRNRUF0QkFTRWVEQThMUVpzQklSNE1EZ3RCbkFFaEhnd05DMEdlQVNFZURBd0xRYUFCSVI0TUN3dEJud0VoSGd3S0MwR2hBU0VlREFrTFFhSUJJUjRNQ0F0Qm93RWhIZ3dIQzBHa0FTRWVEQVlMUWFVQklSNE1CUXRCcGdFaEhnd0VDMEduQVNFZURBTUxRYWdCSVI0TUFndEJxUUVoSGd3QkMwR3ZBU0VlQ3dOQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUI0T3NBRUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdod2VIeUFqSkNVbUp5Z3BLaXd0TGk4dyt3STBOamc1UEQ5QlFrTkVSVVpIU0VsS1MweE5UazlRVVZKVFZWZFpYRjFlWUdKalpHVm1aMmhyYkcxdWIzQnhjbk4wZFhaM2VIbDZlM3g5Zm4rQUFZRUJnZ0dEQVlRQmhRR0dBWWNCaUFHSkFZb0Jpd0dNQVkwQmpnR1BBWkFCa1FHU0FaTUJsQUdWQVpZQmx3R1lBWmtCbWdHYkFad0JuUUdlQVo4Qm9BR2hBYUlCb3dHa0FhVUJwZ0duQWFnQnFRR3FBYXNCckFHdEFhNEJyd0d3QWJFQnNnRzBBYlVCdGdHM0FiZ0J1UUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hhQWVBQjRRSGtBZkVCdlFLOUFnc2dBU0lJSUFKSERjSUJRYndCSVI0TWxRTUxJQUVpSGlBQ1J3MnhBVUdzQVNFZURKUURDeUFCSWdFZ0FrY05aMEhpQUNFZURKTURDeUFCSWdFZ0FrY05YVUhhQUNFZURKSURDeUFCSWdFZ0FrY05Wa0hWQUNFZURKRURDeUFCSWdFZ0FrY05Va0hUQUNFZURKQURDeUFCSWdFZ0FrY05UMEhSQUNFZURJOERDeUFCSWdFZ0FrY05URUhQQUNFZURJNERDeUFCSWdFZ0FrY05FRUVNSVI0TWpRTUxJQUVpQVNBQ1J3MHpRVGdoSGd5TUF3c2dBU0lCSUFKSERTOUJOU0VlRElzREN5QUJJZ0VnQWtjTkprRXlJUjRNaWdNTElBRWlBU0FDUncwa1FTOGhIZ3lKQXdzZ0FTSUJJQUpIRFIxQkpDRWVESWdEQ3lBQUxRQXVRUUZHRGYwQ0RNY0JDeUFBSUFFaUFTQUNFTFNBZ0lBQVFRRkhEYlFCRExVQkN5QUFJQUVpQVNBQ0VLMkFnSUFBSWg0TnRRRWdBU0VCRExBQ0N3SkFJQUVpQVNBQ1J3MEFRUVloSGd5RkF3c2dBQ0FCUVFGcUlnRWdBaEN3Z0lDQUFDSWVEYllCSUFFaEFRd1BDeUFBUWdBM0F5QkJFeUVlRFBNQ0N5QUJJaDRnQWtjTkNVRVBJUjRNZ2dNTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQlFSRWhIZ3p5QWd0QkJ5RWVESUVEQ3lBQVFnQWdBQ2tESUNJZklBSWdBU0llYTYwaUlIMGlJU0FoSUI5V0d6Y0RJQ0FmSUNCV0lpSkZEYk1CUVFnaEhneUFBd3NDUUNBQklnRWdBa1lOQUNBQVFZbUFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJGU0VlRFBBQ0MwRUpJUjRNL3dJTElBRWhBU0FBS1FNZ1VBMnlBU0FCSVFFTXJRSUxBa0FnQVNJQklBSkhEUUJCQ3lFZURQNENDeUFBSUFGQkFXb2lBU0FDRUsrQWdJQUFJaDROc2dFZ0FTRUJESzBDQ3dOQUFrQWdBUzBBQUVId25ZQ0FBR290QUFBaUhrRUJSZzBBSUI1QkFrY050QUVnQVVFQmFpRUJEQU1MSUFGQkFXb2lBU0FDUncwQUMwRU1JUjRNL0FJTEFrQWdBU0lCSUFKSERRQkJEU0VlRFB3Q0N3SkFBa0FnQVMwQUFDSWVRWE5xRGhRQnRnRzJBYllCdGdHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCdGdHMkFiWUJ0Z0cyQWJZQkFMUUJDeUFCUVFGcUlRRU10QUVMSUFGQkFXb2hBUXRCR0NFZURPb0NDd0pBSUFFaUhpQUNSdzBBUVE0aEhnejZBZ3RDQUNFZklCNGhBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0hpMEFBRUZRYWc0M3lBSEhBUUFCQWdNRUJRWUh2Z0srQXI0Q3ZnSytBcjRDdmdJSUNRb0xEQTIrQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNENEZzhRRVJJVHZnSUxRZ0loSHd6SEFRdENBeUVmRE1ZQkMwSUVJUjhNeFFFTFFnVWhId3pFQVF0Q0JpRWZETU1CQzBJSElSOE13Z0VMUWdnaEh3ekJBUXRDQ1NFZkRNQUJDMElLSVI4TXZ3RUxRZ3NoSHd5K0FRdENEQ0VmREwwQkMwSU5JUjhNdkFFTFFnNGhId3k3QVF0Q0R5RWZETG9CQzBJS0lSOE11UUVMUWdzaEh3eTRBUXRDRENFZkRMY0JDMElOSVI4TXRnRUxRZzRoSHd5MUFRdENEeUVmRExRQkMwSUFJUjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlCNHRBQUJCVUdvT044Y0J4Z0VBQVFJREJBVUdCOGdCeUFISUFjZ0J5QUhJQWNnQkNBa0tDd3dOeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBUTRQRUJFU0U4Z0JDMElDSVI4TXhnRUxRZ01oSHd6RkFRdENCQ0VmRE1RQkMwSUZJUjhNd3dFTFFnWWhId3pDQVF0Q0J5RWZETUVCQzBJSUlSOE13QUVMUWdraEh3eS9BUXRDQ2lFZkRMNEJDMElMSVI4TXZRRUxRZ3doSHd5OEFRdENEU0VmRExzQkMwSU9JUjhNdWdFTFFnOGhId3k1QVF0Q0NpRWZETGdCQzBJTElSOE10d0VMUWd3aEh3eTJBUXRDRFNFZkRMVUJDMElPSVI4TXRBRUxRZzhoSHd5ekFRc2dBRUlBSUFBcEF5QWlIeUFDSUFFaUhtdXRJaUI5SWlFZ0lTQWZWaHMzQXlBZ0h5QWdWaUlpUlEyMEFVRVJJUjRNOXdJTEFrQWdBU0lCSUFKR0RRQWdBRUdKZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUVJzaEhnem5BZ3RCRWlFZURQWUNDeUFBSUFFaUhpQUNFTEtBZ0lBQVFYOXFEZ1dtQVFDaUFnR3pBYlFCQzBFU0lSNE01QUlMSUFCQkFUb0FMeUFlSVFFTThnSUxJQUVpQVNBQ1J3MjBBVUVXSVI0TThnSUxJQUVpSENBQ1J3MFpRVGtoSGd6eEFnc0NRQ0FCSWdFZ0FrY05BRUVhSVI0TThRSUxJQUJCQURZQ0JDQUFRWXFBZ0lBQU5nSUlJQUFnQVNBQkVLcUFnSUFBSWg0TnRnRWdBU0VCRExrQkN3SkFJQUVpSGlBQ1J3MEFRUnNoSGd6d0Fnc0NRQ0FlTFFBQUlnRkJJRWNOQUNBZVFRRnFJUUVNR2dzZ0FVRUpSdzIyQVNBZVFRRnFJUUVNR1FzQ1FDQUJJZ0VnQWtZTkFDQUJRUUZxSVFFTUZBdEJIQ0VlRE80Q0N3SkFJQUVpSGlBQ1J3MEFRUjBoSGd6dUFnc0NRQ0FlTFFBQUlnRkJDVWNOQUNBZUlRRU0wZ0lMSUFGQklFY050UUVnSGlFQkRORUNDd0pBSUFFaUFTQUNSdzBBUVI0aEhnenRBZ3NnQVMwQUFFRUtSdzI0QVNBQlFRRnFJUUVNb0FJTElBRWlBU0FDUncyNEFVRWlJUjRNNndJTEEwQUNRQ0FCTFFBQUloNUJJRVlOQUFKQUlCNUJkbW9PQkFDK0FiNEJBTHdCQ3lBQklRRU14QUVMSUFGQkFXb2lBU0FDUncwQUMwRWtJUjRNNmdJTFFTVWhIaUFCSWlNZ0FrWU42UUlnQWlBamF5QUFLQUlBSWlScUlTVWdJeUVtSUNRaEFRSkFBMEFnSmkwQUFDSWlRU0J5SUNJZ0lrRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVSHduNENBQUdvdEFBQkhEUUVnQVVFRFJnM1dBaUFCUVFGcUlRRWdKa0VCYWlJbUlBSkhEUUFMSUFBZ0pUWUNBQXpxQWdzZ0FFRUFOZ0lBSUNZaEFReTdBUXRCSmlFZUlBRWlJeUFDUmczb0FpQUNJQ05ySUFBb0FnQWlKR29oSlNBaklTWWdKQ0VCQWtBRFFDQW1MUUFBSWlKQklISWdJaUFpUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZTZmdJQUFhaTBBQUVjTkFTQUJRUWhHRGIwQklBRkJBV29oQVNBbVFRRnFJaVlnQWtjTkFBc2dBQ0FsTmdJQURPa0NDeUFBUVFBMkFnQWdKaUVCRExvQkMwRW5JUjRnQVNJaklBSkdEZWNDSUFJZ0kyc2dBQ2dDQUNJa2FpRWxJQ01oSmlBa0lRRUNRQU5BSUNZdEFBQWlJa0VnY2lBaUlDSkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkIwS2FBZ0FCcUxRQUFSdzBCSUFGQkJVWU52UUVnQVVFQmFpRUJJQ1pCQVdvaUppQUNSdzBBQ3lBQUlDVTJBZ0FNNkFJTElBQkJBRFlDQUNBbUlRRU11UUVMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFCQmdLS0FnQUJxTFFBQUloNUJBVVlOQUNBZVFRSkdEUW9nQVNFQkRNRUJDeUFCUVFGcUlnRWdBa2NOQUF0Qkl5RWVET2NDQzBFaklSNE01Z0lMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFBaUhrRWdSZzBBSUI1QmRtb09CTDBCdmdHK0FiMEJ2Z0VMSUFGQkFXb2lBU0FDUncwQUMwRXJJUjRNNWdJTFFTc2hIZ3psQWdzRFFBSkFJQUV0QUFBaUhrRWdSZzBBSUI1QkNVY05Bd3NnQVVFQmFpSUJJQUpIRFFBTFFTOGhIZ3prQWdzRFFBSkFJQUV0QUFBaUhrRWdSZzBBQWtBQ1FDQWVRWFpxRGdTK0FRRUJ2Z0VBQ3lBZVFTeEdEYjhCQ3lBQklRRU1CQXNnQVVFQmFpSUJJQUpIRFFBTFFUSWhIZ3pqQWdzZ0FTRUJETDhCQzBFeklSNGdBU0ltSUFKR0RlRUNJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhJaUFqSVFFQ1FBTkFJQ0l0QUFCQklISWdBVUdBcElDQUFHb3RBQUJIRFFFZ0FVRUdSZzNRQWlBQlFRRnFJUUVnSWtFQmFpSWlJQUpIRFFBTElBQWdKRFlDQUF6aUFnc2dBRUVBTmdJQUlDSWhBUXRCS3lFZUROQUNDd0pBSUFFaUhTQUNSdzBBUVRRaEhnemdBZ3NnQUVHS2dJQ0FBRFlDQ0NBQUlCMDJBZ1FnSFNFQklBQXRBQ3hCZjJvT0JLOEJ1UUc3QWIwQnh3SUxJQUZCQVdvaEFReXVBUXNDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUNJZVFTQnlJQjRnSGtHL2YycEIvd0Z4UVJwSkcwSC9BWEVpSGtFSlJnMEFJQjVCSUVZTkFBSkFBa0FDUUFKQUlCNUJuWDlxRGhNQUF3TURBd01EQXdFREF3TURBd01EQXdNQ0F3c2dBVUVCYWlFQlFTWWhIZ3pUQWdzZ0FVRUJhaUVCUVNjaEhnelNBZ3NnQVVFQmFpRUJRU2doSGd6UkFnc2dBU0VCRExJQkN5QUJRUUZxSWdFZ0FrY05BQXRCS0NFZURONENDMEVvSVI0TTNRSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUJCZ0tDQWdBQnFMUUFBUVFGR0RRQWdBU0VCRExjQkN5QUJRUUZxSWdFZ0FrY05BQXRCTUNFZUROMENDMEV3SVI0TTNBSUxBa0FEUUFKQUlBRXRBQUJCZDJvT0dBQUN3UUxCQXNjQ3dRTEJBc0VDd1FMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDd1FMQkFzRUN3UUxCQXNFQ0FNRUNDeUFCUVFGcUlnRWdBa2NOQUF0Qk5TRWVETndDQ3lBQlFRRnFJUUVMUVNFaEhnektBZ3NnQVNJQklBSkhEYmtCUVRjaEhnelpBZ3NEUUFKQUlBRXRBQUJCa0tTQWdBQnFMUUFBUVFGR0RRQWdBU0VCREpBQ0N5QUJRUUZxSWdFZ0FrY05BQXRCT0NFZUROZ0NDeUFjTFFBQUloNUJJRVlObWdFZ0hrRTZSdzNHQWlBQUtBSUVJUUVnQUVFQU5nSUVJQUFnQVNBY0VLaUFnSUFBSWdFTnRnRWdIRUVCYWlFQkRMZ0JDeUFBSUFFZ0FoQ3BnSUNBQUJvTFFRb2hIZ3pGQWd0Qk9pRWVJQUVpSmlBQ1JnM1VBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUndnSXlFQkFrQURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFaQ21nSUFBYWkwQUFFY054QUlnQVVFRlJnMEJJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETlVDQ3lBQVFRQTJBZ0FnQUVFQk9nQXNJQ1lnSTJ0QkJtb2hBUXkrQWd0Qk95RWVJQUVpSmlBQ1JnM1RBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUndnSXlFQkFrQURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFaYW1nSUFBYWkwQUFFY053d0lnQVVFSlJnMEJJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETlFDQ3lBQVFRQTJBZ0FnQUVFQ09nQXNJQ1lnSTJ0QkNtb2hBUXk5QWdzQ1FDQUJJaHdnQWtjTkFFRThJUjRNMHdJTEFrQUNRQ0FjTFFBQUlnRkJJSElnQVNBQlFiOS9ha0gvQVhGQkdra2JRZjhCY1VHU2Yyb09Cd0REQXNNQ3d3TERBc01DQWNNQ0N5QWNRUUZxSVFGQk1pRWVETU1DQ3lBY1FRRnFJUUZCTXlFZURNSUNDMEU5SVI0Z0FTSW1JQUpHRGRFQ0lBSWdKbXNnQUNnQ0FDSWphaUVrSUNZaEhDQWpJUUVEUUNBY0xRQUFJaUpCSUhJZ0lpQWlRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUNtZ0lBQWFpMEFBRWNOd0FJZ0FVRUJSZzIwQWlBQlFRRnFJUUVnSEVFQmFpSWNJQUpIRFFBTElBQWdKRFlDQUF6UkFndEJQaUVlSUFFaUppQUNSZzNRQWlBQ0lDWnJJQUFvQWdBaUkyb2hKQ0FtSVJ3Z0l5RUJBa0FEUUNBY0xRQUFJaUpCSUhJZ0lpQWlRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUttZ0lBQWFpMEFBRWNOd0FJZ0FVRU9SZzBCSUFGQkFXb2hBU0FjUVFGcUlod2dBa2NOQUFzZ0FDQWtOZ0lBRE5FQ0N5QUFRUUEyQWdBZ0FFRUJPZ0FzSUNZZ0kydEJEMm9oQVF5NkFndEJQeUVlSUFFaUppQUNSZzNQQWlBQ0lDWnJJQUFvQWdBaUkyb2hKQ0FtSVJ3Z0l5RUJBa0FEUUNBY0xRQUFJaUpCSUhJZ0lpQWlRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRY0NtZ0lBQWFpMEFBRWNOdndJZ0FVRVBSZzBCSUFGQkFXb2hBU0FjUVFGcUlod2dBa2NOQUFzZ0FDQWtOZ0lBRE5BQ0N5QUFRUUEyQWdBZ0FFRURPZ0FzSUNZZ0kydEJFR29oQVF5NUFndEJ3QUFoSGlBQklpWWdBa1lOemdJZ0FpQW1heUFBS0FJQUlpTnFJU1FnSmlFY0lDTWhBUUpBQTBBZ0hDMEFBQ0lpUVNCeUlDSWdJa0cvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhRcG9DQUFHb3RBQUJIRGI0Q0lBRkJCVVlOQVNBQlFRRnFJUUVnSEVFQmFpSWNJQUpIRFFBTElBQWdKRFlDQUF6UEFnc2dBRUVBTmdJQUlBQkJCRG9BTENBbUlDTnJRUVpxSVFFTXVBSUxBa0FnQVNJY0lBSkhEUUJCd1FBaEhnek9BZ3NDUUFKQUFrQUNRQ0FjTFFBQUlnRkJJSElnQVNBQlFiOS9ha0gvQVhGQkdra2JRZjhCY1VHZGYyb09Fd0RBQXNBQ3dBTEFBc0FDd0FMQUFzQUN3QUxBQXNBQ3dBSUJ3QUxBQXNBQ0FnUEFBZ3NnSEVFQmFpRUJRVFVoSGd6QUFnc2dIRUVCYWlFQlFUWWhIZ3kvQWdzZ0hFRUJhaUVCUVRjaEhneStBZ3NnSEVFQmFpRUJRVGdoSGd5OUFnc0NRQ0FCSWdFZ0FrWU5BQ0FBUVl1QWdJQUFOZ0lJSUFBZ0FUWUNCQ0FCSVFGQk9TRWVETDBDQzBIQ0FDRWVETXdDQ3lBQklnRWdBa2NOcndGQnhBQWhIZ3pMQWd0QnhRQWhIaUFCSWlZZ0FrWU55Z0lnQWlBbWF5QUFLQUlBSWlOcUlTUWdKaUVpSUNNaEFRSkFBMEFnSWkwQUFDQUJRZGFtZ0lBQWFpMEFBRWNOdEFFZ0FVRUJSZzBCSUFGQkFXb2hBU0FpUVFGcUlpSWdBa2NOQUFzZ0FDQWtOZ0lBRE1zQ0N5QUFRUUEyQWdBZ0ppQWphMEVDYWlFQkRLOEJDd0pBSUFFaUFTQUNSdzBBUWNjQUlSNE15Z0lMSUFFdEFBQkJDa2NOc3dFZ0FVRUJhaUVCREs4QkN3SkFJQUVpQVNBQ1J3MEFRY2dBSVI0TXlRSUxBa0FDUUNBQkxRQUFRWFpxRGdRQnRBRzBBUUMwQVFzZ0FVRUJhaUVCUVQwaEhneTVBZ3NnQVVFQmFpRUJESzRCQ3dKQUlBRWlBU0FDUncwQVFja0FJUjRNeUFJTFFRQWhIZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVGUWFnNEt1d0c2QVFBQkFnTUVCUVlIdkFFTFFRSWhIZ3k2QVF0QkF5RWVETGtCQzBFRUlSNE11QUVMUVFVaEhneTNBUXRCQmlFZURMWUJDMEVISVI0TXRRRUxRUWdoSGd5MEFRdEJDU0VlRExNQkN3SkFJQUVpQVNBQ1J3MEFRY29BSVI0TXh3SUxJQUV0QUFCQkxrY050QUVnQVVFQmFpRUJESUFDQ3dKQUlBRWlBU0FDUncwQVFjc0FJUjRNeGdJTFFRQWhIZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVGUWFnNEt2UUc4QVFBQkFnTUVCUVlIdmdFTFFRSWhIZ3k4QVF0QkF5RWVETHNCQzBFRUlSNE11Z0VMUVFVaEhneTVBUXRCQmlFZURMZ0JDMEVISVI0TXR3RUxRUWdoSGd5MkFRdEJDU0VlRExVQkMwSE1BQ0VlSUFFaUppQUNSZzNFQWlBQ0lDWnJJQUFvQWdBaUkyb2hKQ0FtSVFFZ0l5RWlBMEFnQVMwQUFDQWlRZUttZ0lBQWFpMEFBRWNOdUFFZ0lrRURSZzIzQVNBaVFRRnFJU0lnQVVFQmFpSUJJQUpIRFFBTElBQWdKRFlDQUF6RUFndEJ6UUFoSGlBQklpWWdBa1lOd3dJZ0FpQW1heUFBS0FJQUlpTnFJU1FnSmlFQklDTWhJZ05BSUFFdEFBQWdJa0htcG9DQUFHb3RBQUJIRGJjQklDSkJBa1lOdVFFZ0lrRUJhaUVpSUFGQkFXb2lBU0FDUncwQUN5QUFJQ1EyQWdBTXd3SUxRYzRBSVI0Z0FTSW1JQUpHRGNJQ0lBSWdKbXNnQUNnQ0FDSWphaUVrSUNZaEFTQWpJU0lEUUNBQkxRQUFJQ0pCNmFhQWdBQnFMUUFBUncyMkFTQWlRUU5HRGJrQklDSkJBV29oSWlBQlFRRnFJZ0VnQWtjTkFBc2dBQ0FrTmdJQURNSUNDd05BQWtBZ0FTMEFBQ0llUVNCR0RRQUNRQUpBQWtBZ0hrRzRmMm9PQ3dBQnVnRzZBYm9CdWdHNkFib0J1Z0c2QVFLNkFRc2dBVUVCYWlFQlFjSUFJUjRNdFFJTElBRkJBV29oQVVIREFDRWVETFFDQ3lBQlFRRnFJUUZCeEFBaEhneXpBZ3NnQVVFQmFpSUJJQUpIRFFBTFFjOEFJUjRNd1FJTEFrQWdBU0lCSUFKR0RRQWdBQ0FCUVFGcUlnRWdBaENsZ0lDQUFCb2dBU0VCUVFjaEhneXhBZ3RCMEFBaEhnekFBZ3NEUUFKQUlBRXRBQUJCOEthQWdBQnFMUUFBSWg1QkFVWU5BQ0FlUVg1cURnTzVBYm9CdXdHOEFRc2dBVUVCYWlJQklBSkhEUUFMUWRFQUlSNE12d0lMQWtBZ0FTSUJJQUpHRFFBZ0FVRUJhaUVCREFNTFFkSUFJUjRNdmdJTEEwQUNRQ0FCTFFBQVFmQ29nSUFBYWkwQUFDSWVRUUZHRFFBQ1FDQWVRWDVxRGdTOEFiMEJ2Z0VBdndFTElBRWhBVUhHQUNFZURLOENDeUFCUVFGcUlnRWdBa2NOQUF0QjB3QWhIZ3k5QWdzQ1FDQUJJZ0VnQWtjTkFFSFVBQ0VlREwwQ0N3SkFJQUV0QUFBaUhrRjJhZzRhcEFHL0FiOEJwZ0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cwQWI4QnZ3RUF2UUVMSUFGQkFXb2hBUXRCQmlFZURLc0NDd05BQWtBZ0FTMEFBRUh3cW9DQUFHb3RBQUJCQVVZTkFDQUJJUUVNK2dFTElBRkJBV29pQVNBQ1J3MEFDMEhWQUNFZURMb0NDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBUXdEQzBIV0FDRWVETGtDQ3dKQUlBRWlBU0FDUncwQVFkY0FJUjRNdVFJTElBRkJBV29oQVF3QkN3SkFJQUVpQVNBQ1J3MEFRZGdBSVI0TXVBSUxJQUZCQVdvaEFRdEJCQ0VlREtZQ0N3SkFJQUVpSWlBQ1J3MEFRZGtBSVI0TXRnSUxJQ0loQVFKQUFrQUNRQ0FpTFFBQVFmQ3NnSUFBYWkwQUFFRi9hZzRIdmdHL0FjQUJBUGdCQVFMQkFRc2dJa0VCYWlFQkRBb0xJQ0pCQVdvaEFReTNBUXRCQUNFZUlBQkJBRFlDSENBQVFmR09nSUFBTmdJUUlBQkJCellDRENBQUlDSkJBV28yQWhRTXRRSUxBa0FEUUFKQUlBRXRBQUJCOEt5QWdBQnFMUUFBSWg1QkJFWU5BQUpBQWtBZ0hrRi9hZzRIdkFHOUFiNEJ3d0VBQkFIREFRc2dBU0VCUWNrQUlSNE1xQUlMSUFGQkFXb2hBVUhMQUNFZURLY0NDeUFCUVFGcUlnRWdBa2NOQUF0QjJnQWhIZ3kxQWdzZ0FVRUJhaUVCRExVQkN3SkFJQUVpSWlBQ1J3MEFRZHNBSVI0TXRBSUxJQ0l0QUFCQkwwY052Z0VnSWtFQmFpRUJEQVlMQWtBZ0FTSWlJQUpIRFFCQjNBQWhIZ3l6QWdzQ1FDQWlMUUFBSWdGQkwwY05BQ0FpUVFGcUlRRkJ6QUFoSGd5akFnc2dBVUYyYWlJQlFSWkxEYjBCUVFFZ0FYUkJpWUNBQW5GRkRiMEJESk1DQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVVITkFDRWVES0lDQzBIZEFDRWVETEVDQ3dKQUlBRWlJaUFDUncwQVFkOEFJUjRNc1FJTElDSWhBUUpBSUNJdEFBQkI4TENBZ0FCcUxRQUFRWDlxRGdPU0F2QUJBTDRCQzBIUUFDRWVES0FDQ3dKQUlBRWlJaUFDUmcwQUEwQUNRQ0FpTFFBQVFmQ3VnSUFBYWkwQUFDSUJRUU5HRFFBQ1FDQUJRWDlxRGdLVUFnQy9BUXNnSWlFQlFjNEFJUjRNb2dJTElDSkJBV29pSWlBQ1J3MEFDMEhlQUNFZURMQUNDMEhlQUNFZURLOENDd0pBSUFFaUFTQUNSZzBBSUFCQmpJQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVSFBBQ0VlREo4Q0MwSGdBQ0VlREs0Q0N3SkFJQUVpQVNBQ1J3MEFRZUVBSVI0TXJnSUxJQUJCaklDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVF0QkF5RWVESndDQ3dOQUlBRXRBQUJCSUVjTmpBSWdBVUVCYWlJQklBSkhEUUFMUWVJQUlSNE1xd0lMQWtBZ0FTSUJJQUpIRFFCQjR3QWhIZ3lyQWdzZ0FTMEFBRUVnUncyNEFTQUJRUUZxSVFFTTFBRUxBa0FnQVNJSUlBSkhEUUJCNUFBaEhneXFBZ3NnQ0MwQUFFSE1BRWNOdXdFZ0NFRUJhaUVCUVJNaEhneTVBUXRCNVFBaEhpQUJJaUlnQWtZTnFBSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFOQUlBZ3RBQUFnQVVId3NvQ0FBR290QUFCSERib0JJQUZCQlVZTnVBRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1xQUlMQWtBZ0FTSUlJQUpIRFFCQjVnQWhIZ3lvQWdzQ1FBSkFJQWd0QUFCQnZYOXFEZ3dBdXdHN0Fic0J1d0c3QWJzQnV3RzdBYnNCdXdFQnV3RUxJQWhCQVdvaEFVSFVBQ0VlREpnQ0N5QUlRUUZxSVFGQjFRQWhIZ3lYQWd0QjV3QWhIaUFCSWlJZ0FrWU5wZ0lnQWlBaWF5QUFLQUlBSWlacUlTTWdJaUVJSUNZaEFRSkFBMEFnQ0MwQUFDQUJRZTJ6Z0lBQWFpMEFBRWNOdVFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWpOZ0lBREtjQ0N5QUFRUUEyQWdBZ0lpQW1hMEVEYWlFQlFSQWhIZ3kyQVF0QjZBQWhIaUFCSWlJZ0FrWU5wUUlnQWlBaWF5QUFLQUlBSWlacUlTTWdJaUVJSUNZaEFRSkFBMEFnQ0MwQUFDQUJRZmF5Z0lBQWFpMEFBRWNOdUFFZ0FVRUZSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWpOZ0lBREtZQ0N5QUFRUUEyQWdBZ0lpQW1hMEVHYWlFQlFSWWhIZ3kxQVF0QjZRQWhIaUFCSWlJZ0FrWU5wQUlnQWlBaWF5QUFLQUlBSWlacUlTTWdJaUVJSUNZaEFRSkFBMEFnQ0MwQUFDQUJRZnl5Z0lBQWFpMEFBRWNOdHdFZ0FVRURSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWpOZ0lBREtVQ0N5QUFRUUEyQWdBZ0lpQW1hMEVFYWlFQlFRVWhIZ3kwQVFzQ1FDQUJJZ2dnQWtjTkFFSHFBQ0VlREtRQ0N5QUlMUUFBUWRrQVJ3MjFBU0FJUVFGcUlRRkJDQ0VlRExNQkN3SkFJQUVpQ0NBQ1J3MEFRZXNBSVI0TW93SUxBa0FDUUNBSUxRQUFRYkovYWc0REFMWUJBYllCQ3lBSVFRRnFJUUZCMlFBaEhneVRBZ3NnQ0VFQmFpRUJRZG9BSVI0TWtnSUxBa0FnQVNJSUlBSkhEUUJCN0FBaEhneWlBZ3NDUUFKQUlBZ3RBQUJCdUg5cURnZ0F0UUcxQWJVQnRRRzFBYlVCQWJVQkN5QUlRUUZxSVFGQjJBQWhIZ3lTQWdzZ0NFRUJhaUVCUWRzQUlSNE1rUUlMUWUwQUlSNGdBU0lpSUFKR0RhQUNJQUlnSW1zZ0FDZ0NBQ0ltYWlFaklDSWhDQ0FtSVFFQ1FBTkFJQWd0QUFBZ0FVR0FzNENBQUdvdEFBQkhEYk1CSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0l6WUNBQXloQWd0QkFDRWVJQUJCQURZQ0FDQWlJQ1pyUVFOcUlRRU1zQUVMUWU0QUlSNGdBU0lpSUFKR0RaOENJQUlnSW1zZ0FDZ0NBQ0ltYWlFaklDSWhDQ0FtSVFFQ1FBTkFJQWd0QUFBZ0FVR0RzNENBQUdvdEFBQkhEYklCSUFGQkJFWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0l6WUNBQXlnQWdzZ0FFRUFOZ0lBSUNJZ0ptdEJCV29oQVVFaklSNE1yd0VMQWtBZ0FTSUlJQUpIRFFCQjd3QWhIZ3lmQWdzQ1FBSkFJQWd0QUFCQnRIOXFEZ2dBc2dHeUFiSUJzZ0d5QWJJQkFiSUJDeUFJUVFGcUlRRkIzUUFoSGd5UEFnc2dDRUVCYWlFQlFkNEFJUjRNamdJTEFrQWdBU0lJSUFKSERRQkI4QUFoSGd5ZUFnc2dDQzBBQUVIRkFFY05yd0VnQ0VFQmFpRUJETjRCQzBIeEFDRWVJQUVpSWlBQ1JnMmNBaUFDSUNKcklBQW9BZ0FpSm1vaEl5QWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkJpTE9BZ0FCcUxRQUFSdzJ2QVNBQlFRTkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNblFJTElBQkJBRFlDQUNBaUlDWnJRUVJxSVFGQkxTRWVES3dCQzBIeUFDRWVJQUVpSWlBQ1JnMmJBaUFDSUNKcklBQW9BZ0FpSm1vaEl5QWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkIwTE9BZ0FCcUxRQUFSdzJ1QVNBQlFRaEdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDTTJBZ0FNbkFJTElBQkJBRFlDQUNBaUlDWnJRUWxxSVFGQktTRWVES3NCQ3dKQUlBRWlBU0FDUncwQVFmTUFJUjRNbXdJTFFRRWhIaUFCTFFBQVFkOEFSdzJxQVNBQlFRRnFJUUVNM0FFTFFmUUFJUjRnQVNJaUlBSkdEWmtDSUFJZ0ltc2dBQ2dDQUNJbWFpRWpJQ0loQ0NBbUlRRURRQ0FJTFFBQUlBRkJqTE9BZ0FCcUxRQUFSdzJyQVNBQlFRRkdEZmNCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWpOZ0lBREprQ0N3SkFJQUVpSGlBQ1J3MEFRZlVBSVI0TW1RSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVR09zNENBQUdvdEFBQkhEYXNCSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUgxQUNFZURKa0NDeUFBUVFBMkFnQWdIaUFpYTBFRGFpRUJRUUloSGd5b0FRc0NRQ0FCSWg0Z0FrY05BRUgyQUNFZURKZ0NDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkI4TE9BZ0FCcUxRQUFSdzJxQVNBQlFRRkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCOWdBaEhneVlBZ3NnQUVFQU5nSUFJQjRnSW10QkFtb2hBVUVmSVI0TXB3RUxBa0FnQVNJZUlBSkhEUUJCOXdBaEhneVhBZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRZkt6Z0lBQWFpMEFBRWNOcVFFZ0FVRUJSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUWZjQUlSNE1sd0lMSUFCQkFEWUNBQ0FlSUNKclFRSnFJUUZCQ1NFZURLWUJDd0pBSUFFaUNDQUNSdzBBUWZnQUlSNE1sZ0lMQWtBQ1FDQUlMUUFBUWJkL2FnNEhBS2tCcVFHcEFha0JxUUVCcVFFTElBaEJBV29oQVVIbUFDRWVESVlDQ3lBSVFRRnFJUUZCNXdBaEhneUZBZ3NDUUNBQkloNGdBa2NOQUVINUFDRWVESlVDQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCa2JPQWdBQnFMUUFBUncybkFTQUJRUVZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQitRQWhIZ3lWQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJCbW9oQVVFWUlSNE1wQUVMQWtBZ0FTSWVJQUpIRFFCQitnQWhIZ3lVQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUVplemdJQUFhaTBBQUVjTnBnRWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFmb0FJUjRNbEFJTElBQkJBRFlDQUNBZUlDSnJRUU5xSVFGQkZ5RWVES01CQ3dKQUlBRWlIaUFDUncwQVFmc0FJUjRNa3dJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHYXM0Q0FBR290QUFCSERhVUJJQUZCQmtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFSDdBQ0VlREpNQ0N5QUFRUUEyQWdBZ0hpQWlhMEVIYWlFQlFSVWhIZ3lpQVFzQ1FDQUJJaDRnQWtjTkFFSDhBQ0VlREpJQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQm9iT0FnQUJxTFFBQVJ3MmtBU0FCUVFWR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkIvQUFoSGd5U0Fnc2dBRUVBTmdJQUlCNGdJbXRCQm1vaEFVRWVJUjRNb1FFTEFrQWdBU0lJSUFKSERRQkIvUUFoSGd5UkFnc2dDQzBBQUVITUFFY05vZ0VnQ0VFQmFpRUJRUW9oSGd5Z0FRc0NRQ0FCSWdnZ0FrY05BRUgrQUNFZURKQUNDd0pBQWtBZ0NDMEFBRUcvZjJvT0R3Q2pBYU1Cb3dHakFhTUJvd0dqQWFNQm93R2pBYU1Cb3dHakFRR2pBUXNnQ0VFQmFpRUJRZXdBSVI0TWdBSUxJQWhCQVdvaEFVSHRBQ0VlRFA4QkN3SkFJQUVpQ0NBQ1J3MEFRZjhBSVI0TWp3SUxBa0FDUUNBSUxRQUFRYjkvYWc0REFLSUJBYUlCQ3lBSVFRRnFJUUZCNndBaEhnei9BUXNnQ0VFQmFpRUJRZTRBSVI0TS9nRUxBa0FnQVNJZUlBSkhEUUJCZ0FFaEhneU9BZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRYWV6Z0lBQWFpMEFBRWNOb0FFZ0FVRUJSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUVlBQklSNE1qZ0lMSUFCQkFEWUNBQ0FlSUNKclFRSnFJUUZCQ3lFZURKMEJDd0pBSUFFaUNDQUNSdzBBUVlFQklSNE1qUUlMQWtBQ1FBSkFBa0FnQ0MwQUFFRlRhZzRqQUtJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dFQm9nR2lBYUlCb2dHaUFRS2lBYUlCb2dFRG9nRUxJQWhCQVdvaEFVSHBBQ0VlRFA4QkN5QUlRUUZxSVFGQjZnQWhIZ3orQVFzZ0NFRUJhaUVCUWU4QUlSNE0vUUVMSUFoQkFXb2hBVUh3QUNFZURQd0JDd0pBSUFFaUhpQUNSdzBBUVlJQklSNE1qQUlMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUdwczRDQUFHb3RBQUJIRFo0QklBRkJCRVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVHQ0FTRWVESXdDQ3lBQVFRQTJBZ0FnSGlBaWEwRUZhaUVCUVJraEhneWJBUXNDUUNBQklpSWdBa2NOQUVHREFTRWVESXNDQ3lBQ0lDSnJJQUFvQWdBaUptb2hIaUFpSVFnZ0ppRUJBa0FEUUNBSUxRQUFJQUZCcnJPQWdBQnFMUUFBUncyZEFTQUJRUVZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQjQyQWdCQmd3RWhIZ3lMQWdzZ0FFRUFOZ0lBUVFZaEhpQWlJQ1pyUVFacUlRRU1tZ0VMQWtBZ0FTSWVJQUpIRFFCQmhBRWhIZ3lLQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUWJTemdJQUFhaTBBQUVjTm5BRWdBVUVCUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFZUUJJUjRNaWdJTElBQkJBRFlDQUNBZUlDSnJRUUpxSVFGQkhDRWVESmtCQ3dKQUlBRWlIaUFDUncwQVFZVUJJUjRNaVFJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHMnM0Q0FBR290QUFCSERac0JJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFR0ZBU0VlRElrQ0N5QUFRUUEyQWdBZ0hpQWlhMEVDYWlFQlFTY2hIZ3lZQVFzQ1FDQUJJZ2dnQWtjTkFFR0dBU0VlRElnQ0N3SkFBa0FnQ0MwQUFFR3NmMm9PQWdBQm13RUxJQWhCQVdvaEFVSDBBQ0VlRFBnQkN5QUlRUUZxSVFGQjlRQWhIZ3ozQVFzQ1FDQUJJaDRnQWtjTkFFR0hBU0VlREljQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQnVMT0FnQUJxTFFBQVJ3MlpBU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkJod0VoSGd5SEFnc2dBRUVBTmdJQUlCNGdJbXRCQW1vaEFVRW1JUjRNbGdFTEFrQWdBU0llSUFKSERRQkJpQUVoSGd5R0Fnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFicXpnSUFBYWkwQUFFY05tQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRWWdCSVI0TWhnSUxJQUJCQURZQ0FDQWVJQ0pyUVFKcUlRRkJBeUVlREpVQkN3SkFJQUVpSGlBQ1J3MEFRWWtCSVI0TWhRSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVSHRzNENBQUdvdEFBQkhEWmNCSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUdKQVNFZURJVUNDeUFBUVFBMkFnQWdIaUFpYTBFRGFpRUJRUXdoSGd5VUFRc0NRQ0FCSWg0Z0FrY05BRUdLQVNFZURJUUNDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkJ2TE9BZ0FCcUxRQUFSdzJXQVNBQlFRTkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCaWdFaEhneUVBZ3NnQUVFQU5nSUFJQjRnSW10QkJHb2hBVUVOSVI0TWt3RUxBa0FnQVNJSUlBSkhEUUJCaXdFaEhneURBZ3NDUUFKQUlBZ3RBQUJCdW45cURnc0FsZ0dXQVpZQmxnR1dBWllCbGdHV0FaWUJBWllCQ3lBSVFRRnFJUUZCK1FBaEhnenpBUXNnQ0VFQmFpRUJRZm9BSVI0TThnRUxBa0FnQVNJSUlBSkhEUUJCakFFaEhneUNBZ3NnQ0MwQUFFSFFBRWNOa3dFZ0NFRUJhaUVCRE1RQkN3SkFJQUVpQ0NBQ1J3MEFRWTBCSVI0TWdRSUxBa0FDUUNBSUxRQUFRYmQvYWc0SEFaUUJsQUdVQVpRQmxBRUFsQUVMSUFoQkFXb2hBVUg4QUNFZURQRUJDeUFJUVFGcUlRRkJJaUVlREpBQkN3SkFJQUVpSGlBQ1J3MEFRWTRCSVI0TWdBSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVSEFzNENBQUdvdEFBQkhEWklCSUFGQkFVWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUdPQVNFZURJQUNDeUFBUVFBMkFnQWdIaUFpYTBFQ2FpRUJRUjBoSGd5UEFRc0NRQ0FCSWdnZ0FrY05BRUdQQVNFZURQOEJDd0pBQWtBZ0NDMEFBRUd1ZjJvT0F3Q1NBUUdTQVFzZ0NFRUJhaUVCUWY0QUlSNE03d0VMSUFoQkFXb2hBVUVFSVI0TWpnRUxBa0FnQVNJSUlBSkhEUUJCa0FFaEhneitBUXNDUUFKQUFrQUNRQUpBSUFndEFBQkJ2MzlxRGhVQWxBR1VBWlFCbEFHVUFaUUJsQUdVQVpRQmxBRUJsQUdVQVFLVUFaUUJBNVFCbEFFRWxBRUxJQWhCQVdvaEFVSDJBQ0VlRFBFQkN5QUlRUUZxSVFGQjl3QWhIZ3p3QVFzZ0NFRUJhaUVCUWZnQUlSNE03d0VMSUFoQkFXb2hBVUg5QUNFZURPNEJDeUFJUVFGcUlRRkIvd0FoSGd6dEFRc0NRQ0FFSUFKSERRQkJrUUVoSGd6OUFRc2dBaUFFYXlBQUtBSUFJaDVxSVNJZ0JDRUlJQjRoQVFKQUEwQWdDQzBBQUNBQlFlMnpnSUFBYWkwQUFFY05qd0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBaU5nSUFRWkVCSVI0TS9RRUxJQUJCQURZQ0FDQUVJQjVyUVFOcUlRRkJFU0VlREl3QkN3SkFJQVVnQWtjTkFFR1NBU0VlRFB3QkN5QUNJQVZySUFBb0FnQWlIbW9oSWlBRklRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQndyT0FnQUJxTFFBQVJ3Mk9BU0FCUVFKR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNJMkFnQkJrZ0VoSGd6OEFRc2dBRUVBTmdJQUlBVWdIbXRCQTJvaEFVRXNJUjRNaXdFTEFrQWdCaUFDUncwQVFaTUJJUjRNK3dFTElBSWdCbXNnQUNnQ0FDSWVhaUVpSUFZaENDQWVJUUVDUUFOQUlBZ3RBQUFnQVVIRnM0Q0FBR290QUFCSERZMEJJQUZCQkVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR1RBU0VlRFBzQkN5QUFRUUEyQWdBZ0JpQWVhMEVGYWlFQlFTc2hIZ3lLQVFzQ1FDQUhJQUpIRFFCQmxBRWhIZ3o2QVFzZ0FpQUhheUFBS0FJQUloNXFJU0lnQnlFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWNxemdJQUFhaTBBQUVjTmpBRWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFaUUJJUjRNK2dFTElBQkJBRFlDQUNBSElCNXJRUU5xSVFGQkZDRWVESWtCQ3dKQUlBZ2dBa2NOQUVHVkFTRWVEUGtCQ3dKQUFrQUNRQUpBSUFndEFBQkJ2bjlxRGc4QUFRS09BWTRCamdHT0FZNEJqZ0dPQVk0QmpnR09BWTRCQTQ0QkN5QUlRUUZxSVFSQmdRRWhIZ3pyQVFzZ0NFRUJhaUVGUVlJQklSNE02Z0VMSUFoQkFXb2hCa0dEQVNFZURPa0JDeUFJUVFGcUlRZEJoQUVoSGd6b0FRc0NRQ0FJSUFKSERRQkJsZ0VoSGd6NEFRc2dDQzBBQUVIRkFFY05pUUVnQ0VFQmFpRUlETHNCQ3dKQUlBa2dBa2NOQUVHWEFTRWVEUGNCQ3lBQ0lBbHJJQUFvQWdBaUhtb2hJaUFKSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCemJPQWdBQnFMUUFBUncySkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQmx3RWhIZ3ozQVFzZ0FFRUFOZ0lBSUFrZ0htdEJBMm9oQVVFT0lSNE1oZ0VMQWtBZ0NDQUNSdzBBUVpnQklSNE05Z0VMSUFndEFBQkIwQUJIRFljQklBaEJBV29oQVVFbElSNE1oUUVMQWtBZ0NpQUNSdzBBUVprQklSNE05UUVMSUFJZ0Ntc2dBQ2dDQUNJZWFpRWlJQW9oQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhRczRDQUFHb3RBQUJIRFljQklBRkJDRVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHWkFTRWVEUFVCQ3lBQVFRQTJBZ0FnQ2lBZWEwRUphaUVCUVNvaEhneUVBUXNDUUNBSUlBSkhEUUJCbWdFaEhnejBBUXNDUUFKQUlBZ3RBQUJCcTM5cURnc0Fod0dIQVljQmh3R0hBWWNCaHdHSEFZY0JBWWNCQ3lBSVFRRnFJUWhCaUFFaEhnemtBUXNnQ0VFQmFpRUtRWWtCSVI0TTR3RUxBa0FnQ0NBQ1J3MEFRWnNCSVI0TTh3RUxBa0FDUUNBSUxRQUFRYjkvYWc0VUFJWUJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FRR0dBUXNnQ0VFQmFpRUpRWWNCSVI0TTR3RUxJQWhCQVdvaENFR0tBU0VlRE9JQkN3SkFJQXNnQWtjTkFFR2NBU0VlRFBJQkN5QUNJQXRySUFBb0FnQWlIbW9oSWlBTElRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQjJiT0FnQUJxTFFBQVJ3MkVBU0FCUVFOR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNJMkFnQkJuQUVoSGd6eUFRc2dBRUVBTmdJQUlBc2dIbXRCQkdvaEFVRWhJUjRNZ1FFTEFrQWdEQ0FDUncwQVFaMEJJUjRNOFFFTElBSWdER3NnQUNnQ0FDSWVhaUVpSUF3aENDQWVJUUVDUUFOQUlBZ3RBQUFnQVVIZHM0Q0FBR290QUFCSERZTUJJQUZCQmtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR2RBU0VlRFBFQkN5QUFRUUEyQWdBZ0RDQWVhMEVIYWlFQlFSb2hIZ3lBQVFzQ1FDQUlJQUpIRFFCQm5nRWhIZ3p3QVFzQ1FBSkFBa0FnQ0MwQUFFRzdmMm9PRVFDRUFZUUJoQUdFQVlRQmhBR0VBWVFCaEFFQmhBR0VBWVFCaEFHRUFRS0VBUXNnQ0VFQmFpRUlRWXNCSVI0TTRRRUxJQWhCQVdvaEMwR01BU0VlRE9BQkN5QUlRUUZxSVF4QmpRRWhIZ3pmQVFzQ1FDQU5JQUpIRFFCQm53RWhIZ3p2QVFzZ0FpQU5heUFBS0FJQUloNXFJU0lnRFNFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWVTemdJQUFhaTBBQUVjTmdRRWdBVUVGUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFaOEJJUjRNN3dFTElBQkJBRFlDQUNBTklCNXJRUVpxSVFGQktDRWVESDRMQWtBZ0RpQUNSdzBBUWFBQklSNE03Z0VMSUFJZ0Rtc2dBQ2dDQUNJZWFpRWlJQTRoQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhxczRDQUFHb3RBQUJIRFlBQklBRkJBa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHZ0FTRWVETzRCQ3lBQVFRQTJBZ0FnRGlBZWEwRURhaUVCUVFjaEhneDlDd0pBSUFnZ0FrY05BRUdoQVNFZURPMEJDd0pBQWtBZ0NDMEFBRUc3ZjJvT0RnQ0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FFQmdBRUxJQWhCQVdvaERVR1BBU0VlRE4wQkN5QUlRUUZxSVE1QmtBRWhIZ3pjQVFzQ1FDQVBJQUpIRFFCQm9nRWhIZ3pzQVFzZ0FpQVBheUFBS0FJQUloNXFJU0lnRHlFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWUyemdJQUFhaTBBQUVjTmZpQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQm9nRWhIZ3pzQVFzZ0FFRUFOZ0lBSUE4Z0htdEJBMm9oQVVFU0lSNE1ld3NDUUNBUUlBSkhEUUJCb3dFaEhnenJBUXNnQWlBUWF5QUFLQUlBSWg1cUlTSWdFQ0VJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZkN6Z0lBQWFpMEFBRWNOZlNBQlFRRkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCb3dFaEhnenJBUXNnQUVFQU5nSUFJQkFnSG10QkFtb2hBVUVnSVI0TWVnc0NRQ0FSSUFKSERRQkJwQUVoSGd6cUFRc2dBaUFSYXlBQUtBSUFJaDVxSVNJZ0VTRUlJQjRoQVFKQUEwQWdDQzBBQUNBQlFmS3pnSUFBYWkwQUFFY05mQ0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNJMkFnQkJwQUVoSGd6cUFRc2dBRUVBTmdJQUlCRWdIbXRCQW1vaEFVRVBJUjRNZVFzQ1FDQUlJQUpIRFFCQnBRRWhIZ3pwQVFzQ1FBSkFJQWd0QUFCQnQzOXFEZ2NBZkh4OGZId0JmQXNnQ0VFQmFpRVFRWk1CSVI0TTJRRUxJQWhCQVdvaEVVR1VBU0VlRE5nQkN3SkFJQklnQWtjTkFFR21BU0VlRE9nQkN5QUNJQkpySUFBb0FnQWlIbW9oSWlBU0lRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQjlMT0FnQUJxTFFBQVJ3MTZJQUZCQjBZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR21BU0VlRE9nQkN5QUFRUUEyQWdBZ0VpQWVhMEVJYWlFQlFSc2hIZ3gzQ3dKQUlBZ2dBa2NOQUVHbkFTRWVET2NCQ3dKQUFrQUNRQ0FJTFFBQVFiNS9hZzRTQUh0N2UzdDdlM3Q3ZXdGN2UzdDdlM3NDZXdzZ0NFRUJhaUVQUVpJQklSNE0yQUVMSUFoQkFXb2hDRUdWQVNFZUROY0JDeUFJUVFGcUlSSkJsZ0VoSGd6V0FRc0NRQ0FJSUFKSERRQkJxQUVoSGd6bUFRc2dDQzBBQUVIT0FFY05keUFJUVFGcUlRZ01xZ0VMQWtBZ0NDQUNSdzBBUWFrQklSNE01UUVMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdDQzBBQUVHL2Yyb09GUUFCQWdPR0FRUUZCb1lCaGdHR0FRY0lDUW9MaGdFTURRNFBoZ0VMSUFoQkFXb2hBVUhXQUNFZURPTUJDeUFJUVFGcUlRRkIxd0FoSGd6aUFRc2dDRUVCYWlFQlFkd0FJUjRNNFFFTElBaEJBV29oQVVIZ0FDRWVET0FCQ3lBSVFRRnFJUUZCNFFBaEhnemZBUXNnQ0VFQmFpRUJRZVFBSVI0TTNnRUxJQWhCQVdvaEFVSGxBQ0VlRE4wQkN5QUlRUUZxSVFGQjZBQWhIZ3pjQVFzZ0NFRUJhaUVCUWZFQUlSNE0yd0VMSUFoQkFXb2hBVUh5QUNFZUROb0JDeUFJUVFGcUlRRkI4d0FoSGd6WkFRc2dDRUVCYWlFQlFZQUJJUjRNMkFFTElBaEJBV29oQ0VHR0FTRWVETmNCQ3lBSVFRRnFJUWhCamdFaEhneldBUXNnQ0VFQmFpRUlRWkVCSVI0TTFRRUxJQWhCQVdvaENFR1lBU0VlRE5RQkN3SkFJQlFnQWtjTkFFR3JBU0VlRE9RQkN5QVVRUUZxSVJNTWR3c0RRQUpBSUI0dEFBQkJkbW9PQkhjQUFIb0FDeUFlUVFGcUloNGdBa2NOQUF0QnJBRWhIZ3ppQVFzQ1FDQVZJQUpHRFFBZ0FFR05nSUNBQURZQ0NDQUFJQlUyQWdRZ0ZTRUJRUUVoSGd6U0FRdEJyUUVoSGd6aEFRc0NRQ0FWSUFKSERRQkJyZ0VoSGd6aEFRc0NRQUpBSUJVdEFBQkJkbW9PQkFHckFhc0JBS3NCQ3lBVlFRRnFJUlFNZUFzZ0ZVRUJhaUVUREhRTElBQWdFeUFDRUtlQWdJQUFHaUFUSVFFTVJRc0NRQ0FWSUFKSERRQkJyd0VoSGd6ZkFRc0NRQUpBSUJVdEFBQkJkbW9PRndGNWVRRjVlWGw1ZVhsNWVYbDVlWGw1ZVhsNWVYa0FlUXNnRlVFQmFpRVZDMEdjQVNFZURNNEJDd0pBSUJZZ0FrY05BRUd4QVNFZURONEJDeUFXTFFBQVFTQkhEWGNnQUVFQU93RXlJQlpCQVdvaEFVR2dBU0VlRE0wQkN5QUJJU1lDUUFOQUlDWWlGU0FDUmcwQklCVXRBQUJCVUdwQi93RnhJaDVCQ2s4TnFBRUNRQ0FBTHdFeUlpSkJtVE5MRFFBZ0FDQWlRUXBzSWlJN0FUSWdIa0gvL3dOeklDSkIvdjhEY1VrTkFDQVZRUUZxSVNZZ0FDQWlJQjVxSWg0N0FUSWdIa0gvL3dOeFFlZ0hTUTBCQ3d0QkFDRWVJQUJCQURZQ0hDQUFRWjJKZ0lBQU5nSVFJQUJCRFRZQ0RDQUFJQlZCQVdvMkFoUU0zUUVMUWJBQklSNE0zQUVMQWtBZ0Z5QUNSdzBBUWJJQklSNE0zQUVMUVFBaEhnSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0Z5MEFBRUZRYWc0S2YzNEFBUUlEQkFVR0I0QUJDMEVDSVI0TWZndEJBeUVlREgwTFFRUWhIZ3g4QzBFRklSNE1ld3RCQmlFZURIb0xRUWNoSGd4NUMwRUlJUjRNZUF0QkNTRWVESGNMQWtBZ0dDQUNSdzBBUWJNQklSNE0yd0VMSUJndEFBQkJMa2NOZUNBWVFRRnFJUmNNcGdFTEFrQWdHU0FDUncwQVFiUUJJUjRNMmdFTFFRQWhIZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdHUzBBQUVGUWFnNEtnUUdBQVFBQkFnTUVCUVlIZ2dFTFFRSWhIZ3lBQVF0QkF5RWVESDhMUVFRaEhneCtDMEVGSVI0TWZRdEJCaUVlREh3TFFRY2hIZ3g3QzBFSUlSNE1lZ3RCQ1NFZURIa0xBa0FnQ0NBQ1J3MEFRYlVCSVI0TTJRRUxJQUlnQ0dzZ0FDZ0NBQ0lpYWlFbUlBZ2hHU0FpSVI0RFFDQVpMUUFBSUI1Qi9MT0FnQUJxTFFBQVJ3MTdJQjVCQkVZTnRBRWdIa0VCYWlFZUlCbEJBV29pR1NBQ1J3MEFDeUFBSUNZMkFnQkJ0UUVoSGd6WUFRc0NRQ0FhSUFKSERRQkJ0Z0VoSGd6WUFRc2dBaUFhYXlBQUtBSUFJaDVxSVNJZ0dpRUlJQjRoQVFOQUlBZ3RBQUFnQVVHQnRJQ0FBR290QUFCSERYc2dBVUVCUmcyMkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFRzJBU0VlRE5jQkN3SkFJQnNnQWtjTkFFRzNBU0VlRE5jQkN5QUNJQnRySUFBb0FnQWlHV29oSWlBYklRZ2dHU0VlQTBBZ0NDMEFBQ0FlUVlPMGdJQUFhaTBBQUVjTmVpQWVRUUpHRFh3Z0hrRUJhaUVlSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQnR3RWhIZ3pXQVFzQ1FDQUlJQUpIRFFCQnVBRWhIZ3pXQVFzQ1FBSkFJQWd0QUFCQnUzOXFEaEFBZTN0N2UzdDdlM3Q3ZTN0N2Uzc0Jld3NnQ0VFQmFpRWFRYVVCSVI0TXhnRUxJQWhCQVdvaEcwR21BU0VlRE1VQkN3SkFJQWdnQWtjTkFFRzVBU0VlRE5VQkN5QUlMUUFBUWNnQVJ3MTRJQWhCQVdvaENBeWlBUXNDUUNBSUlBSkhEUUJCdWdFaEhnelVBUXNnQ0MwQUFFSElBRVlOb2dFZ0FFRUJPZ0FvREprQkN3TkFBa0FnQ0MwQUFFRjJhZzRFQUhwNkFIb0xJQWhCQVdvaUNDQUNSdzBBQzBHOEFTRWVETklCQ3lBQVFRQTZBQzhnQUMwQUxVRUVjVVVOeUFFTElBQkJBRG9BTHlBQklRRU1lUXNnSGtFVlJnMnBBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJxNHlBZ0FBMkFoQWdBRUVTTmdJTVFRQWhIZ3pQQVFzQ1FDQUFJQjRnQWhDdGdJQ0FBQ0lCRFFBZ0hpRUJETVVCQ3dKQUlBRkJGVWNOQUNBQVFRTTJBaHdnQUNBZU5nSVVJQUJCMXBLQWdBQTJBaEFnQUVFVk5nSU1RUUFoSGd6UEFRc2dBRUVBTmdJY0lBQWdIallDRkNBQVFhdU1nSUFBTmdJUUlBQkJFallDREVFQUlSNE16Z0VMSUI1QkZVWU5wUUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWWlNZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUjRNelFFTElBQW9BZ1FoSmlBQVFRQTJBZ1FnSGlBZnAyb2lJeUVCSUFBZ0ppQWVJQ01nSWhzaUhoQ3VnSUNBQUNJaVJRMTZJQUJCQnpZQ0hDQUFJQjQyQWhRZ0FDQWlOZ0lNUVFBaEhnek1BUXNnQUNBQUx3RXdRWUFCY2pzQk1DQUJJUUVNTVFzZ0hrRVZSZzJoQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCeFl1QWdBQTJBaEFnQUVFVE5nSU1RUUFoSGd6S0FRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFZdUxnSUFBTmdJUUlBQkJBallDREVFQUlSNE15UUVMSUI1Qk8wY05BU0FCUVFGcUlRRUxRUWdoSGd5M0FRdEJBQ0VlSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdqa0lDQUFEWUNFQ0FBUVF3MkFnd014Z0VMUWdFaEh3c2dIa0VCYWlFQkFrQWdBQ2tESUNJZ1F2Ly8vLy8vLy8vL0QxWU5BQ0FBSUNCQ0JJWWdINFEzQXlBZ0FTRUJESGNMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdKaVlDQUFEWUNFQ0FBUVF3MkFneEJBQ0VlRE1RQkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQm81Q0FnQUEyQWhBZ0FFRU1OZ0lNUVFBaEhnekRBUXNnQUNnQ0JDRW1JQUJCQURZQ0JDQWVJQituYWlJaklRRWdBQ0FtSUI0Z0l5QWlHeUllRUs2QWdJQUFJaUpGRFc0Z0FFRUZOZ0ljSUFBZ0hqWUNGQ0FBSUNJMkFneEJBQ0VlRE1JQkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQjNaU0FnQUEyQWhBZ0FFRVBOZ0lNUVFBaEhnekJBUXNnQUNBZUlBSVFyWUNBZ0FBaUFRMEJJQjRoQVF0QkR5RWVESzhCQ3dKQUlBRkJGVWNOQUNBQVFRSTJBaHdnQUNBZU5nSVVJQUJCMXBLQWdBQTJBaEFnQUVFVk5nSU1RUUFoSGd5L0FRc2dBRUVBTmdJY0lBQWdIallDRkNBQVFhdU1nSUFBTmdJUUlBQkJFallDREVFQUlSNE12Z0VMSUFGQkFXb2hIZ0pBSUFBdkFUQWlBVUdBQVhGRkRRQUNRQ0FBSUI0Z0FoQ3dnSUNBQUNJQkRRQWdIaUVCREdzTElBRkJGVWNObHdFZ0FFRUZOZ0ljSUFBZ0hqWUNGQ0FBUWI2U2dJQUFOZ0lRSUFCQkZUWUNERUVBSVI0TXZnRUxBa0FnQVVHZ0JIRkJvQVJIRFFBZ0FDMEFMVUVDY1EwQUlBQkJBRFlDSENBQUlCNDJBaFFnQUVIc2o0Q0FBRFlDRUNBQVFRUTJBZ3hCQUNFZURMNEJDeUFBSUI0Z0FoQ3hnSUNBQUJvZ0hpRUJBa0FDUUFKQUFrQUNRQ0FBSUI0Z0FoQ3NnSUNBQUE0V0FnRUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBd1FMSUFCQkFUb0FMZ3NnQUNBQUx3RXdRY0FBY2pzQk1DQWVJUUVMUVIwaEhneXZBUXNnQUVFVk5nSWNJQUFnSGpZQ0ZDQUFRZUdSZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUjRNdmdFTElBQkJBRFlDSENBQUlCNDJBaFFnQUVHeGk0Q0FBRFlDRUNBQVFSRTJBZ3hCQUNFZURMMEJDeUFBTFFBdFFRRnhSUTBCUWFvQklSNE1yQUVMQWtBZ0hDQUNSZzBBQTBBQ1FDQWNMUUFBUVNCR0RRQWdIQ0VCREtnQkN5QWNRUUZxSWh3Z0FrY05BQXRCRnlFZURMd0JDMEVYSVI0TXV3RUxJQUFvQWdRaEFTQUFRUUEyQWdRZ0FDQUJJQndRcUlDQWdBQWlBVVVOa0FFZ0FFRVlOZ0ljSUFBZ0FUWUNEQ0FBSUJ4QkFXbzJBaFJCQUNFZURMb0JDeUFBUVJrMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE11UUVMSUI0aEFVRUJJU0lDUUFKQUFrQUNRQUpBQWtBQ1FDQUFMUUFzUVg1cURnY0dCUVVEQVFJQUJRc2dBQ0FBTHdFd1FRaHlPd0V3REFNTFFRSWhJZ3dCQzBFRUlTSUxJQUJCQVRvQUxDQUFJQUF2QVRBZ0luSTdBVEFMSUI0aEFRdEJJQ0VlREtrQkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQmdZK0FnQUEyQWhBZ0FFRUxOZ0lNUVFBaEhneTRBUXNnSGlFQlFRRWhJZ0pBQWtBQ1FBSkFBa0FnQUMwQUxFRjdhZzRFQWdBQkF3VUxRUUloSWd3QkMwRUVJU0lMSUFCQkFUb0FMQ0FBSUFBdkFUQWdJbkk3QVRBTUFRc2dBQ0FBTHdFd1FRaHlPd0V3Q3lBZUlRRUxRYXNCSVI0TXBnRUxJQUFnQVNBQ0VLdUFnSUFBR2d3YkN3SkFJQUVpSGlBQ1JnMEFJQjRoQVFKQUFrQWdIaTBBQUVGMmFnNEVBV3BxQUdvTElCNUJBV29oQVF0QkhpRWVES1VCQzBIREFDRWVETFFCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCa1pHQWdBQTJBaEFnQUVFRE5nSU1RUUFoSGd5ekFRc0NRQ0FCTFFBQVFRMUhEUUFnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLcUFnSUFBSWg0TkFDQUJRUUZxSVFFTWFRc2dBRUVlTmdJY0lBQWdIallDRENBQUlBRkJBV28yQWhSQkFDRWVETE1CQ3lBQklRRWdBQzBBTFVFQmNVVU5yZ0ZCclFFaEhneWlBUXNDUUNBQklnRWdBa2NOQUVFZklSNE1zZ0VMQWtBQ1FBTkFBa0FnQVMwQUFFRjJhZzRFQWdBQUF3QUxJQUZCQVdvaUFTQUNSdzBBQzBFZklSNE1zd0VMSUFBb0FnUWhIaUFBUVFBMkFnUUNRQ0FBSUI0Z0FSQ3FnSUNBQUNJZURRQWdBU0VCREdnTElBQkJIallDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd5eUFRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtxQWdJQUFJaDROQUNBQlFRRnFJUUVNWndzZ0FFRWVOZ0ljSUFBZ0hqWUNEQ0FBSUFGQkFXbzJBaFJCQUNFZURMRUJDeUFlUVN4SERRRWdBVUVCYWlFZVFRRWhBUUpBQWtBQ1FBSkFBa0FnQUMwQUxFRjdhZzRFQXdFQ0JBQUxJQjRoQVF3RUMwRUNJUUVNQVF0QkJDRUJDeUFBUVFFNkFDd2dBQ0FBTHdFd0lBRnlPd0V3SUI0aEFRd0JDeUFBSUFBdkFUQkJDSEk3QVRBZ0hpRUJDMEV1SVI0TW53RUxJQUJCQURvQUxDQUJJUUVMUVNraEhneWRBUXNnQUVFQU5nSUFJQ01nSkd0QkNXb2hBVUVGSVI0TW1BRUxJQUJCQURZQ0FDQWpJQ1JyUVFacUlRRkJCeUVlREpjQkN5QUFJQUF2QVRCQklISTdBVEFnQVNFQkRBSUxJQUFvQWdRaENDQUFRUUEyQWdRQ1FDQUFJQWdnQVJDcWdJQ0FBQ0lJRFFBZ0FTRUJESjBCQ3lBQVFTbzJBaHdnQUNBQk5nSVVJQUFnQ0RZQ0RFRUFJUjRNcVFFTElBQkJDRG9BTENBQklRRUxRU1VoSGd5WEFRc0NRQ0FBTFFBb1FRRkdEUUFnQVNFQkRBUUxJQUF0QUMxQkNIRkZEWGdnQVNFQkRBTUxJQUF0QURCQklIRU5lVUd1QVNFZURKVUJDd0pBSUIwZ0FrWU5BQUpBQTBBQ1FDQWRMUUFBUVZCcUlnRkIvd0Z4UVFwSkRRQWdIU0VCUVNvaEhneVlBUXNnQUNrRElDSWZRcG16NXN5WnMrYk1HVllOQVNBQUlCOUNDbjRpSHpjRElDQWZJQUd0SWlCQ2Y0VkNnSDZFVmcwQklBQWdIeUFnUXY4QmczdzNBeUFnSFVFQmFpSWRJQUpIRFFBTFFTd2hIZ3ltQVFzZ0FDZ0NCQ0VJSUFCQkFEWUNCQ0FBSUFnZ0hVRUJhaUlCRUtxQWdJQUFJZ2dOZWlBQklRRU1tUUVMUVN3aEhneWtBUXNDUUNBQUx3RXdJZ0ZCQ0hGRkRRQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNIRkZEWFVMSUFBZ0FVSDMrd054UVlBRWNqc0JNQ0FkSVFFTFFTd2hIZ3lTQVFzZ0FDQUFMd0V3UVJCeU93RXdESWNCQ3lBQVFUWTJBaHdnQUNBQk5nSU1JQUFnSEVFQmFqWUNGRUVBSVI0TW9BRUxJQUV0QUFCQk9rY05BaUFBS0FJRUlSNGdBRUVBTmdJRUlBQWdIaUFCRUtpQWdJQUFJaDROQVNBQlFRRnFJUUVMUVRFaEhneU9BUXNnQUVFMk5nSWNJQUFnSGpZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VlREowQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmg0NkFnQUEyQWhBZ0FFRUtOZ0lNUVFBaEhneWNBUXNnQVVFQmFpRUJDeUFBUVlBU093RXFJQUFnQVNBQ0VLV0FnSUFBR2lBQklRRUxRYXdCSVI0TWlRRUxJQUFvQWdRaEhpQUFRUUEyQWdRQ1FDQUFJQjRnQVJDa2dJQ0FBQ0llRFFBZ0FTRUJERkFMSUFCQnhBQTJBaHdnQUNBQk5nSVVJQUFnSGpZQ0RFRUFJUjRNbUFFTElBQkJBRFlDSENBQUlDSTJBaFFnQUVIbG1JQ0FBRFlDRUNBQVFRYzJBZ3dnQUVFQU5nSUFRUUFoSGd5WEFRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtTQWdJQUFJaDROQUNBQklRRU1Ud3NnQUVIRkFEWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3lXQVF0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSHJqWUNBQURZQ0VDQUFRUWsyQWd3TWxRRUxRUUVoSGdzZ0FDQWVPZ0FySUFGQkFXb2hBU0FBTFFBcFFTSkdEWXNCREV3TElBQkJBRFlDSENBQUlBRTJBaFFnQUVHaWpZQ0FBRFlDRUNBQVFRazJBZ3hCQUNFZURKSUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4WXFBZ0FBMkFoQWdBRUVKTmdJTVFRQWhIZ3lSQVF0QkFTRWVDeUFBSUI0NkFDb2dBVUVCYWlFQkRFb0xJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFRzRqWUNBQURZQ0VDQUFRUWsyQWd4QkFDRWVESTRCQ3lBQVFRQTJBZ0FnSmlBamEwRUVhaUVCQWtBZ0FDMEFLVUVqVHcwQUlBRWhBUXhLQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCcjRtQWdBQTJBaEFnQUVFSU5nSU1RUUFoSGd5TkFRc2dBRUVBTmdJQUMwRUFJUjRnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYm1iZ0lBQU5nSVFJQUJCQ0RZQ0RBeUxBUXNnQUVFQU5nSUFJQ1lnSTJ0QkEyb2hBUUpBSUFBdEFDbEJJVWNOQUNBQklRRU1Sd3NnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZmVKZ0lBQU5nSVFJQUJCQ0RZQ0RFRUFJUjRNaWdFTElBQkJBRFlDQUNBbUlDTnJRUVJxSVFFQ1FDQUFMUUFwSWg1QlhXcEJDMDhOQUNBQklRRU1SZ3NDUUNBZVFRWkxEUUJCQVNBZWRFSEtBSEZGRFFBZ0FTRUJERVlMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjA0bUFnQUEyQWhBZ0FFRUlOZ0lNRElrQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFReEdDeUFBUWRBQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESWdCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF3L0N5QUFRY1FBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURJY0JDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXcvQ3lBQVFjVUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlRElZQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFReERDeUFBUWRBQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESVVCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCb29xQWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd5RUFRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtTQWdJQUFJaDROQUNBQklRRU1Pd3NnQUVIRUFEWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3lEQVFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS1NBZ0lBQUloNE5BQ0FCSVFFTU93c2dBRUhGQURZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneUNBUXNnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLU0FnSUFBSWg0TkFDQUJJUUVNUHdzZ0FFSFFBRFlDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd5QkFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFiaUlnSUFBTmdJUUlBQkJCellDREVFQUlSNE1nQUVMSUI1QlAwY05BU0FCUVFGcUlRRUxRUVVoSGd4dUMwRUFJUjRnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZE9QZ0lBQU5nSVFJQUJCQnpZQ0RBeDlDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXcwQ3lBQVFjUUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlREh3TElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkREUUxJQUJCeFFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1ld3NnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLU0FnSUFBSWg0TkFDQUJJUUVNT0FzZ0FFSFFBRFlDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd4NkN5QUFLQUlFSVFFZ0FFRUFOZ0lFQWtBZ0FDQUJJQ0lRcElDQWdBQWlBUTBBSUNJaEFRd3hDeUFBUWNRQU5nSWNJQUFnSWpZQ0ZDQUFJQUUyQWd4QkFDRWVESGtMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0loQ2tnSUNBQUNJQkRRQWdJaUVCRERFTElBQkJ4UUEyQWh3Z0FDQWlOZ0lVSUFBZ0FUWUNERUVBSVI0TWVBc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FpRUtTQWdJQUFJZ0VOQUNBaUlRRU1OUXNnQUVIUUFEWUNIQ0FBSUNJMkFoUWdBQ0FCTmdJTVFRQWhIZ3gzQ3lBQVFRQTJBaHdnQUNBaU5nSVVJQUJCMEl5QWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd4MkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjBJeUFnQUEyQWhBZ0FFRUhOZ0lNUVFBaEhneDFDMEVBSVI0Z0FFRUFOZ0ljSUFBZ0lqWUNGQ0FBUWIrVWdJQUFOZ0lRSUFCQkJ6WUNEQXgwQ3lBQVFRQTJBaHdnQUNBaU5nSVVJQUJCdjVTQWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd4ekN5QUFRUUEyQWh3Z0FDQWlOZ0lVSUFCQjFJNkFnQUEyQWhBZ0FFRUhOZ0lNUVFBaEhneHlDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ3Wk9BZ0FBMkFoQWdBRUVHTmdJTVFRQWhIZ3h4Q3lBQVFRQTJBZ0FnSWlBbWEwRUdhaUVCUVNRaEhnc2dBQ0FlT2dBcElBRWhBUXhPQ3lBQVFRQTJBZ0FMUVFBaEhpQUFRUUEyQWh3Z0FDQUlOZ0lVSUFCQnBKU0FnQUEyQWhBZ0FFRUdOZ0lNREcwTElBQW9BZ1FoRXlBQVFRQTJBZ1FnQUNBVElCNFFwb0NBZ0FBaUV3MEJJQjVCQVdvaEV3dEJuUUVoSGd4YkN5QUFRYW9CTmdJY0lBQWdFellDRENBQUlCNUJBV28yQWhSQkFDRWVER29MSUFBb0FnUWhGQ0FBUVFBMkFnUWdBQ0FVSUI0UXBvQ0FnQUFpRkEwQklCNUJBV29oRkF0Qm1nRWhIZ3hZQ3lBQVFhc0JOZ0ljSUFBZ0ZEWUNEQ0FBSUI1QkFXbzJBaFJCQUNFZURHY0xJQUJCQURZQ0hDQUFJQlUyQWhRZ0FFSHppb0NBQURZQ0VDQUFRUTAyQWd4QkFDRWVER1lMSUFCQkFEWUNIQ0FBSUJZMkFoUWdBRUhPallDQUFEWUNFQ0FBUVFrMkFneEJBQ0VlREdVTFFRRWhIZ3NnQUNBZU9nQXJJQmRCQVdvaEZnd3VDeUFBUVFBMkFod2dBQ0FYTmdJVUlBQkJvbzJBZ0FBMkFoQWdBRUVKTmdJTVFRQWhIZ3hpQ3lBQVFRQTJBaHdnQUNBWU5nSVVJQUJCeFlxQWdBQTJBaEFnQUVFSk5nSU1RUUFoSGd4aEMwRUJJUjRMSUFBZ0hqb0FLaUFaUVFGcUlSZ01MQXNnQUVFQU5nSWNJQUFnR1RZQ0ZDQUFRYmlOZ0lBQU5nSVFJQUJCQ1RZQ0RFRUFJUjRNWGdzZ0FFRUFOZ0ljSUFBZ0dUWUNGQ0FBUWJtYmdJQUFOZ0lRSUFCQkNEWUNEQ0FBUVFBMkFnQkJBQ0VlREYwTElBQkJBRFlDQUF0QkFDRWVJQUJCQURZQ0hDQUFJQWcyQWhRZ0FFR0xsSUNBQURZQ0VDQUFRUWcyQWd3TVd3c2dBRUVDT2dBb0lBQkJBRFlDQUNBYklCbHJRUU5xSVJrTU5nc2dBRUVDT2dBdklBQWdDQ0FDRUtPQWdJQUFJaDROQVVHdkFTRWVERWtMSUFBdEFDaEJmMm9PQWg0Z0h3c2dIa0VWUncwbklBQkJ1d0UyQWh3Z0FDQUlOZ0lVSUFCQnA1S0FnQUEyQWhBZ0FFRVZOZ0lNUVFBaEhneFhDMEVBSVI0TVJndEJBaUVlREVVTFFRNGhIZ3hFQzBFUUlSNE1Rd3RCSENFZURFSUxRUlFoSGd4QkMwRVdJUjRNUUF0QkZ5RWVERDhMUVJraEhndytDMEVhSVI0TVBRdEJPaUVlRER3TFFTTWhIZ3c3QzBFa0lSNE1PZ3RCTUNFZUREa0xRVHNoSGd3NEMwRThJUjRNTnd0QlBpRWVERFlMUVQ4aEhndzFDMEhBQUNFZUREUUxRY0VBSVI0TU13dEJ4UUFoSGd3eUMwSEhBQ0VlRERFTFFjZ0FJUjRNTUF0QnlnQWhIZ3d2QzBIZkFDRWVEQzRMUWVJQUlSNE1MUXRCK3dBaEhnd3NDMEdGQVNFZURDc0xRWmNCSVI0TUtndEJtUUVoSGd3cEMwR3BBU0VlRENnTFFhUUJJUjRNSnd0Qm13RWhIZ3dtQzBHZUFTRWVEQ1VMUVo4QklSNE1KQXRCb1FFaEhnd2pDMEdpQVNFZURDSUxRYWNCSVI0TUlRdEJxQUVoSGd3Z0N5QUFRUUEyQWh3Z0FDQUlOZ0lVSUFCQjVvdUFnQUEyQWhBZ0FFRVFOZ0lNUVFBaEhnd3ZDeUFBUVFBMkFnUWdBQ0FkSUIwUXFvQ0FnQUFpQVVVTkFTQUFRUzAyQWh3Z0FDQUJOZ0lNSUFBZ0hVRUJhallDRkVFQUlSNE1MZ3NnQUNnQ0JDRUlJQUJCQURZQ0JBSkFJQUFnQ0NBQkVLcUFnSUFBSWdoRkRRQWdBRUV1TmdJY0lBQWdDRFlDRENBQUlBRkJBV28yQWhSQkFDRWVEQzRMSUFGQkFXb2hBUXdlQ3lBZFFRRnFJUUVNSGdzZ0FFRUFOZ0ljSUFBZ0hUWUNGQ0FBUWJxUGdJQUFOZ0lRSUFCQkJEWUNERUVBSVI0TUt3c2dBRUVwTmdJY0lBQWdBVFlDRkNBQUlBZzJBZ3hCQUNFZURDb0xJQnhCQVdvaEFRd2VDeUFBUVFvMkFod2dBQ0FCTmdJVUlBQkJrWktBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3dvQ3lBQVFSQTJBaHdnQUNBQk5nSVVJQUJCdnBLQWdBQTJBaEFnQUVFVk5nSU1RUUFoSGd3bkN5QUFRUUEyQWh3Z0FDQWVOZ0lVSUFCQmlJeUFnQUEyQWhBZ0FFRVVOZ0lNUVFBaEhnd21DeUFBUVFRMkFod2dBQ0FCTmdJVUlBQkIxcEtBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3dsQ3lBQVFRQTJBZ0FnQ0NBaWEwRUZhaUVaQzBHakFTRWVEQk1MSUFCQkFEWUNBQ0FpSUNaclFRSnFJUUZCNHdBaEhnd1NDeUFBUVFBMkFnQWdBRUdCQkRzQktDQWFJQjVyUVFKcUlRRUxRZE1BSVI0TUVBc2dBU0VCQWtBZ0FDMEFLVUVGUncwQVFkSUFJUjRNRUF0QjBRQWhIZ3dQQzBFQUlSNGdBRUVBTmdJY0lBQkJ1bzZBZ0FBMkFoQWdBRUVITmdJTUlBQWdJa0VCYWpZQ0ZBd2VDeUFBUVFBMkFnQWdKaUFqYTBFQ2FpRUJRVFFoSGd3TkN5QUJJUUVMUVMwaEhnd0xDd0pBSUFFaUhTQUNSZzBBQTBBQ1FDQWRMUUFBUVlDaWdJQUFhaTBBQUNJQlFRRkdEUUFnQVVFQ1J3MERJQjFCQVdvaEFRd0VDeUFkUVFGcUloMGdBa2NOQUF0Qk1TRWVEQnNMUVRFaEhnd2FDeUFBUVFBNkFDd2dIU0VCREFFTFFRd2hIZ3dJQzBFdklSNE1Cd3NnQVVFQmFpRUJRU0loSGd3R0MwRWZJUjRNQlFzZ0FFRUFOZ0lBSUNNZ0pHdEJCR29oQVVFR0lSNExJQUFnSGpvQUxDQUJJUUZCRFNFZURBTUxJQUJCQURZQ0FDQW1JQ05yUVFkcUlRRkJDeUVlREFJTElBQkJBRFlDQUFzZ0FFRUFPZ0FzSUJ3aEFVRUpJUjRNQUFzTFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1SkdBZ0FBMkFoQWdBRUVQTmdJTURBNExRUUFoSGlBQVFRQTJBaHdnQUNBQk5nSVVJQUJCdUpHQWdBQTJBaEFnQUVFUE5nSU1EQTBMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxvK0FnQUEyQWhBZ0FFRUxOZ0lNREF3TFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkI4WWlBZ0FBMkFoQWdBRUVMTmdJTURBc0xRUUFoSGlBQVFRQTJBaHdnQUNBQk5nSVVJQUJCaUkyQWdBQTJBaEFnQUVFS05nSU1EQW9MSUFCQkFqWUNIQ0FBSUFFMkFoUWdBRUh3a29DQUFEWUNFQ0FBUVJZMkFneEJBQ0VlREFrTFFRRWhIZ3dJQzBIR0FDRWVJQUVpQVNBQ1JnMEhJQU5CQ0dvZ0FDQUJJQUpCMkthQWdBQkJDaEM1Z0lDQUFDQURLQUlNSVFFZ0F5Z0NDQTREQVFjQ0FBc1F2NENBZ0FBQUN5QUFRUUEyQWh3Z0FFR0prNENBQURZQ0VDQUFRUmMyQWd3Z0FDQUJRUUZxTmdJVVFRQWhIZ3dGQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbnBPQWdBQTJBaEFnQUVFSk5nSU1RUUFoSGd3RUN3SkFJQUVpQVNBQ1J3MEFRU0VoSGd3RUN3SkFJQUV0QUFCQkNrWU5BQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI3b3lBZ0FBMkFoQWdBRUVLTmdJTVFRQWhIZ3dFQ3lBQUtBSUVJUWdnQUVFQU5nSUVJQUFnQ0NBQkVLcUFnSUFBSWdnTkFTQUJRUUZxSVFFTFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkI2cENBZ0FBMkFoQWdBRUVaTmdJTURBSUxJQUJCSURZQ0hDQUFJQWcyQWd3Z0FDQUJRUUZxTmdJVVFRQWhIZ3dCQ3dKQUlBRWlBU0FDUncwQVFSUWhIZ3dCQ3lBQVFZbUFnSUFBTmdJSUlBQWdBVFlDQkVFVElSNExJQU5CRUdva2dJQ0FnQUFnSGd1dkFRRUNmeUFCS0FJQUlRWUNRQUpBSUFJZ0EwWU5BQ0FFSUFacUlRUWdCaUFEYWlBQ2F5RUhJQUlnQmtGL2N5QUZhaUlHYWlFRkEwQUNRQ0FDTFFBQUlBUXRBQUJHRFFCQkFpRUVEQU1MQWtBZ0JnMEFRUUFoQkNBRklRSU1Bd3NnQmtGL2FpRUdJQVJCQVdvaEJDQUNRUUZxSWdJZ0EwY05BQXNnQnlFR0lBTWhBZ3NnQUVFQk5nSUFJQUVnQmpZQ0FDQUFJQUkyQWdRUEN5QUJRUUEyQWdBZ0FDQUVOZ0lBSUFBZ0FqWUNCQXNLQUNBQUVMdUFnSUFBQzVVM0FRdC9JNENBZ0lBQVFSQnJJZ0VrZ0lDQWdBQUNRRUVBS0FLZ3RJQ0FBQTBBUVFBUXZvQ0FnQUJCZ0xpRWdBQnJJZ0pCMlFCSkRRQkJBQ0VEQWtCQkFDZ0M0TGVBZ0FBaUJBMEFRUUJDZnpjQzdMZUFnQUJCQUVLQWdJU0FnSURBQURjQzVMZUFnQUJCQUNBQlFRaHFRWEJ4UWRpcTFhb0ZjeUlFTmdMZ3Q0Q0FBRUVBUVFBMkF2UzNnSUFBUVFCQkFEWUN4TGVBZ0FBTFFRQWdBallDekxlQWdBQkJBRUdBdUlTQUFEWUN5TGVBZ0FCQkFFR0F1SVNBQURZQ21MU0FnQUJCQUNBRU5nS3N0SUNBQUVFQVFYODJBcWkwZ0lBQUEwQWdBMEhFdElDQUFHb2dBMEc0dElDQUFHb2lCRFlDQUNBRUlBTkJzTFNBZ0FCcUlnVTJBZ0FnQTBHOHRJQ0FBR29nQlRZQ0FDQURRY3kwZ0lBQWFpQURRY0MwZ0lBQWFpSUZOZ0lBSUFVZ0JEWUNBQ0FEUWRTMGdJQUFhaUFEUWNpMGdJQUFhaUlFTmdJQUlBUWdCVFlDQUNBRFFkQzBnSUFBYWlBRU5nSUFJQU5CSUdvaUEwR0FBa2NOQUF0QmdMaUVnQUJCZUVHQXVJU0FBR3RCRDNGQkFFR0F1SVNBQUVFSWFrRVBjUnNpQTJvaUJFRUVhaUFDSUFOclFVaHFJZ05CQVhJMkFnQkJBRUVBS0FMd3Q0Q0FBRFlDcExTQWdBQkJBQ0FFTmdLZ3RJQ0FBRUVBSUFNMkFwUzBnSUFBSUFKQmdMaUVnQUJxUVV4cVFUZzJBZ0FMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCN0FGTERRQUNRRUVBS0FLSXRJQ0FBQ0lHUVJBZ0FFRVRha0Z3Y1NBQVFRdEpHeUlDUVFOMklnUjJJZ05CQTNGRkRRQWdBMEVCY1NBRWNrRUJjeUlGUVFOMElnQkJ1TFNBZ0FCcUtBSUFJZ1JCQ0dvaEF3SkFBa0FnQkNnQ0NDSUNJQUJCc0xTQWdBQnFJZ0JIRFFCQkFDQUdRWDRnQlhkeE5nS0l0SUNBQUF3QkN5QUFJQUkyQWdnZ0FpQUFOZ0lNQ3lBRUlBVkJBM1FpQlVFRGNqWUNCQ0FFSUFWcVFRUnFJZ1FnQkNnQ0FFRUJjallDQUF3TUN5QUNRUUFvQXBDMGdJQUFJZ2RORFFFQ1FDQURSUTBBQWtBQ1FDQURJQVIwUVFJZ0JIUWlBMEVBSUFOcmNuRWlBMEVBSUFOcmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJFRUZka0VJY1NJRklBTnlJQVFnQlhZaUEwRUNka0VFY1NJRWNpQURJQVIySWdOQkFYWkJBbkVpQkhJZ0F5QUVkaUlEUVFGMlFRRnhJZ1J5SUFNZ0JIWnFJZ1ZCQTNRaUFFRzR0SUNBQUdvb0FnQWlCQ2dDQ0NJRElBQkJzTFNBZ0FCcUlnQkhEUUJCQUNBR1FYNGdCWGR4SWdZMkFvaTBnSUFBREFFTElBQWdBellDQ0NBRElBQTJBZ3dMSUFSQkNHb2hBeUFFSUFKQkEzSTJBZ1FnQkNBRlFRTjBJZ1ZxSUFVZ0Ftc2lCVFlDQUNBRUlBSnFJZ0FnQlVFQmNqWUNCQUpBSUFkRkRRQWdCMEVEZGlJSVFRTjBRYkMwZ0lBQWFpRUNRUUFvQXB5MGdJQUFJUVFDUUFKQUlBWkJBU0FJZENJSWNRMEFRUUFnQmlBSWNqWUNpTFNBZ0FBZ0FpRUlEQUVMSUFJb0FnZ2hDQXNnQ0NBRU5nSU1JQUlnQkRZQ0NDQUVJQUkyQWd3Z0JDQUlOZ0lJQzBFQUlBQTJBcHkwZ0lBQVFRQWdCVFlDa0xTQWdBQU1EQXRCQUNnQ2pMU0FnQUFpQ1VVTkFTQUpRUUFnQ1d0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtcEJBblJCdUxhQWdBQnFLQUlBSWdBb0FnUkJlSEVnQW1zaEJDQUFJUVVDUUFOQUFrQWdCU2dDRUNJRERRQWdCVUVVYWlnQ0FDSURSUTBDQ3lBREtBSUVRWGh4SUFKcklnVWdCQ0FGSUFSSklnVWJJUVFnQXlBQUlBVWJJUUFnQXlFRkRBQUxDeUFBS0FJWUlRb0NRQ0FBS0FJTUlnZ2dBRVlOQUVFQUtBS1l0SUNBQUNBQUtBSUlJZ05MR2lBSUlBTTJBZ2dnQXlBSU5nSU1EQXNMQWtBZ0FFRVVhaUlGS0FJQUlnTU5BQ0FBS0FJUUlnTkZEUU1nQUVFUWFpRUZDd05BSUFVaEN5QURJZ2hCRkdvaUJTZ0NBQ0lERFFBZ0NFRVFhaUVGSUFnb0FoQWlBdzBBQ3lBTFFRQTJBZ0FNQ2d0QmZ5RUNJQUJCdjM5TERRQWdBRUVUYWlJRFFYQnhJUUpCQUNnQ2pMU0FnQUFpQjBVTkFFRUFJUXNDUUNBQ1FZQUNTUTBBUVI4aEN5QUNRZi8vL3dkTERRQWdBMEVJZGlJRElBTkJnUDQvYWtFUWRrRUljU0lEZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJRklBVkJnSUFQYWtFUWRrRUNjU0lGZEVFUGRpQURJQVJ5SUFWeWF5SURRUUYwSUFJZ0EwRVZhblpCQVhGeVFSeHFJUXNMUVFBZ0Ftc2hCQUpBQWtBQ1FBSkFJQXRCQW5SQnVMYUFnQUJxS0FJQUlnVU5BRUVBSVFOQkFDRUlEQUVMUVFBaEF5QUNRUUJCR1NBTFFRRjJheUFMUVI5R0czUWhBRUVBSVFnRFFBSkFJQVVvQWdSQmVIRWdBbXNpQmlBRVR3MEFJQVloQkNBRklRZ2dCZzBBUVFBaEJDQUZJUWdnQlNFRERBTUxJQU1nQlVFVWFpZ0NBQ0lHSUFZZ0JTQUFRUjEyUVFSeGFrRVFhaWdDQUNJRlJoc2dBeUFHR3lFRElBQkJBWFFoQUNBRkRRQUxDd0pBSUFNZ0NISU5BRUVBSVFoQkFpQUxkQ0lEUVFBZ0EydHlJQWR4SWdORkRRTWdBMEVBSUFOcmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJVRUZka0VJY1NJQUlBTnlJQVVnQUhZaUEwRUNka0VFY1NJRmNpQURJQVYySWdOQkFYWkJBbkVpQlhJZ0F5QUZkaUlEUVFGMlFRRnhJZ1Z5SUFNZ0JYWnFRUUowUWJpMmdJQUFhaWdDQUNFREN5QURSUTBCQ3dOQUlBTW9BZ1JCZUhFZ0Ftc2lCaUFFU1NFQUFrQWdBeWdDRUNJRkRRQWdBMEVVYWlnQ0FDRUZDeUFHSUFRZ0FCc2hCQ0FESUFnZ0FCc2hDQ0FGSVFNZ0JRMEFDd3NnQ0VVTkFDQUVRUUFvQXBDMGdJQUFJQUpyVHcwQUlBZ29BaGdoQ3dKQUlBZ29BZ3dpQUNBSVJnMEFRUUFvQXBpMGdJQUFJQWdvQWdnaUEwc2FJQUFnQXpZQ0NDQURJQUEyQWd3TUNRc0NRQ0FJUVJScUlnVW9BZ0FpQXcwQUlBZ29BaEFpQTBVTkF5QUlRUkJxSVFVTEEwQWdCU0VHSUFNaUFFRVVhaUlGS0FJQUlnTU5BQ0FBUVJCcUlRVWdBQ2dDRUNJRERRQUxJQVpCQURZQ0FBd0lDd0pBUVFBb0FwQzBnSUFBSWdNZ0Fra05BRUVBS0FLY3RJQ0FBQ0VFQWtBQ1FDQURJQUpySWdWQkVFa05BQ0FFSUFKcUlnQWdCVUVCY2pZQ0JFRUFJQVUyQXBDMGdJQUFRUUFnQURZQ25MU0FnQUFnQkNBRGFpQUZOZ0lBSUFRZ0FrRURjallDQkF3QkN5QUVJQU5CQTNJMkFnUWdBeUFFYWtFRWFpSURJQU1vQWdCQkFYSTJBZ0JCQUVFQU5nS2N0SUNBQUVFQVFRQTJBcEMwZ0lBQUN5QUVRUWhxSVFNTUNnc0NRRUVBS0FLVXRJQ0FBQ0lBSUFKTkRRQkJBQ2dDb0xTQWdBQWlBeUFDYWlJRUlBQWdBbXNpQlVFQmNqWUNCRUVBSUFVMkFwUzBnSUFBUVFBZ0JEWUNvTFNBZ0FBZ0F5QUNRUU55TmdJRUlBTkJDR29oQXd3S0N3SkFBa0JCQUNnQzRMZUFnQUJGRFFCQkFDZ0M2TGVBZ0FBaEJBd0JDMEVBUW44M0F1eTNnSUFBUVFCQ2dJQ0VnSUNBd0FBM0F1UzNnSUFBUVFBZ0FVRU1ha0Z3Y1VIWXF0V3FCWE0yQXVDM2dJQUFRUUJCQURZQzlMZUFnQUJCQUVFQU5nTEV0NENBQUVHQWdBUWhCQXRCQUNFREFrQWdCQ0FDUWNjQWFpSUhhaUlHUVFBZ0JHc2lDM0VpQ0NBQ1N3MEFRUUJCTURZQytMZUFnQUFNQ2dzQ1FFRUFLQUxBdDRDQUFDSURSUTBBQWtCQkFDZ0N1TGVBZ0FBaUJDQUlhaUlGSUFSTkRRQWdCU0FEVFEwQkMwRUFJUU5CQUVFd05nTDR0NENBQUF3S0MwRUFMUURFdDRDQUFFRUVjUTBFQWtBQ1FBSkFRUUFvQXFDMGdJQUFJZ1JGRFFCQnlMZUFnQUFoQXdOQUFrQWdBeWdDQUNJRklBUkxEUUFnQlNBREtBSUVhaUFFU3cwREN5QURLQUlJSWdNTkFBc0xRUUFRdm9DQWdBQWlBRUYvUmcwRklBZ2hCZ0pBUVFBb0F1UzNnSUFBSWdOQmYyb2lCQ0FBY1VVTkFDQUlJQUJySUFRZ0FHcEJBQ0FEYTNGcUlRWUxJQVlnQWswTkJTQUdRZjcvLy84SFN3MEZBa0JCQUNnQ3dMZUFnQUFpQTBVTkFFRUFLQUs0dDRDQUFDSUVJQVpxSWdVZ0JFME5CaUFGSUFOTERRWUxJQVlRdm9DQWdBQWlBeUFBUncwQkRBY0xJQVlnQUdzZ0MzRWlCa0grLy8vL0Iwc05CQ0FHRUw2QWdJQUFJZ0FnQXlnQ0FDQURLQUlFYWtZTkF5QUFJUU1MQWtBZ0EwRi9SZzBBSUFKQnlBQnFJQVpORFFBQ1FDQUhJQVpyUVFBb0F1aTNnSUFBSWdScVFRQWdCR3R4SWdSQi92Ly8vd2RORFFBZ0F5RUFEQWNMQWtBZ0JCQytnSUNBQUVGL1JnMEFJQVFnQm1vaEJpQURJUUFNQnd0QkFDQUdheEMrZ0lDQUFCb01CQXNnQXlFQUlBTkJmMGNOQlF3REMwRUFJUWdNQnd0QkFDRUFEQVVMSUFCQmYwY05BZ3RCQUVFQUtBTEV0NENBQUVFRWNqWUN4TGVBZ0FBTElBaEIvdi8vL3dkTERRRWdDQkMrZ0lDQUFDRUFRUUFRdm9DQWdBQWhBeUFBUVg5R0RRRWdBMEYvUmcwQklBQWdBMDhOQVNBRElBQnJJZ1lnQWtFNGFrME5BUXRCQUVFQUtBSzR0NENBQUNBR2FpSUROZ0s0dDRDQUFBSkFJQU5CQUNnQ3ZMZUFnQUJORFFCQkFDQUROZ0s4dDRDQUFBc0NRQUpBQWtBQ1FFRUFLQUtndElDQUFDSUVSUTBBUWNpM2dJQUFJUU1EUUNBQUlBTW9BZ0FpQlNBREtBSUVJZ2hxUmcwQ0lBTW9BZ2dpQXcwQURBTUxDd0pBQWtCQkFDZ0NtTFNBZ0FBaUEwVU5BQ0FBSUFOUERRRUxRUUFnQURZQ21MU0FnQUFMUVFBaEEwRUFJQVkyQXN5M2dJQUFRUUFnQURZQ3lMZUFnQUJCQUVGL05nS290SUNBQUVFQVFRQW9BdUMzZ0lBQU5nS3N0SUNBQUVFQVFRQTJBdFMzZ0lBQUEwQWdBMEhFdElDQUFHb2dBMEc0dElDQUFHb2lCRFlDQUNBRUlBTkJzTFNBZ0FCcUlnVTJBZ0FnQTBHOHRJQ0FBR29nQlRZQ0FDQURRY3kwZ0lBQWFpQURRY0MwZ0lBQWFpSUZOZ0lBSUFVZ0JEWUNBQ0FEUWRTMGdJQUFhaUFEUWNpMGdJQUFhaUlFTmdJQUlBUWdCVFlDQUNBRFFkQzBnSUFBYWlBRU5nSUFJQU5CSUdvaUEwR0FBa2NOQUFzZ0FFRjRJQUJyUVE5eFFRQWdBRUVJYWtFUGNSc2lBMm9pQkNBR0lBTnJRVWhxSWdOQkFYSTJBZ1JCQUVFQUtBTHd0NENBQURZQ3BMU0FnQUJCQUNBRU5nS2d0SUNBQUVFQUlBTTJBcFMwZ0lBQUlBWWdBR3BCVEdwQk9EWUNBQXdDQ3lBRExRQU1RUWh4RFFBZ0JTQUVTdzBBSUFBZ0JFME5BQ0FFUVhnZ0JHdEJEM0ZCQUNBRVFRaHFRUTl4R3lJRmFpSUFRUUFvQXBTMGdJQUFJQVpxSWdzZ0JXc2lCVUVCY2pZQ0JDQURJQWdnQm1vMkFnUkJBRUVBS0FMd3Q0Q0FBRFlDcExTQWdBQkJBQ0FGTmdLVXRJQ0FBRUVBSUFBMkFxQzBnSUFBSUFzZ0JHcEJCR3BCT0RZQ0FBd0JDd0pBSUFCQkFDZ0NtTFNBZ0FBaUMwOE5BRUVBSUFBMkFwaTBnSUFBSUFBaEN3c2dBQ0FHYWlFSVFjaTNnSUFBSVFNQ1FBSkFBa0FDUUFKQUFrQUNRQU5BSUFNb0FnQWdDRVlOQVNBREtBSUlJZ01OQUF3Q0N3c2dBeTBBREVFSWNVVU5BUXRCeUxlQWdBQWhBd05BQWtBZ0F5Z0NBQ0lGSUFSTERRQWdCU0FES0FJRWFpSUZJQVJMRFFNTElBTW9BZ2doQXd3QUN3c2dBeUFBTmdJQUlBTWdBeWdDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZCQUNBQVFRaHFRUTl4RzJvaUJpQUNRUU55TmdJRUlBaEJlQ0FJYTBFUGNVRUFJQWhCQ0dwQkQzRWJhaUlJSUFZZ0Ftb2lBbXNoQlFKQUlBUWdDRWNOQUVFQUlBSTJBcUMwZ0lBQVFRQkJBQ2dDbExTQWdBQWdCV29pQXpZQ2xMU0FnQUFnQWlBRFFRRnlOZ0lFREFNTEFrQkJBQ2dDbkxTQWdBQWdDRWNOQUVFQUlBSTJBcHkwZ0lBQVFRQkJBQ2dDa0xTQWdBQWdCV29pQXpZQ2tMU0FnQUFnQWlBRFFRRnlOZ0lFSUFJZ0Eyb2dBellDQUF3REN3SkFJQWdvQWdRaUEwRURjVUVCUncwQUlBTkJlSEVoQndKQUFrQWdBMEgvQVVzTkFDQUlLQUlJSWdRZ0EwRURkaUlMUVFOMFFiQzBnSUFBYWlJQVJob0NRQ0FJS0FJTUlnTWdCRWNOQUVFQVFRQW9Bb2kwZ0lBQVFYNGdDM2R4TmdLSXRJQ0FBQXdDQ3lBRElBQkdHaUFESUFRMkFnZ2dCQ0FETmdJTURBRUxJQWdvQWhnaENRSkFBa0FnQ0NnQ0RDSUFJQWhHRFFBZ0N5QUlLQUlJSWdOTEdpQUFJQU0yQWdnZ0F5QUFOZ0lNREFFTEFrQWdDRUVVYWlJREtBSUFJZ1FOQUNBSVFSQnFJZ01vQWdBaUJBMEFRUUFoQUF3QkN3TkFJQU1oQ3lBRUlnQkJGR29pQXlnQ0FDSUVEUUFnQUVFUWFpRURJQUFvQWhBaUJBMEFDeUFMUVFBMkFnQUxJQWxGRFFBQ1FBSkFJQWdvQWh3aUJFRUNkRUc0dG9DQUFHb2lBeWdDQUNBSVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUVFQUtBS010SUNBQUVGK0lBUjNjVFlDakxTQWdBQU1BZ3NnQ1VFUVFSUWdDU2dDRUNBSVJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSk5nSVlBa0FnQ0NnQ0VDSURSUTBBSUFBZ0F6WUNFQ0FESUFBMkFoZ0xJQWdvQWhRaUEwVU5BQ0FBUVJScUlBTTJBZ0FnQXlBQU5nSVlDeUFISUFWcUlRVWdDQ0FIYWlFSUN5QUlJQWdvQWdSQmZuRTJBZ1FnQWlBRmFpQUZOZ0lBSUFJZ0JVRUJjallDQkFKQUlBVkIvd0ZMRFFBZ0JVRURkaUlFUVFOMFFiQzBnSUFBYWlFREFrQUNRRUVBS0FLSXRJQ0FBQ0lGUVFFZ0JIUWlCSEVOQUVFQUlBVWdCSEkyQW9pMGdJQUFJQU1oQkF3QkN5QURLQUlJSVFRTElBUWdBallDRENBRElBSTJBZ2dnQWlBRE5nSU1JQUlnQkRZQ0NBd0RDMEVmSVFNQ1FDQUZRZi8vL3dkTERRQWdCVUVJZGlJRElBTkJnUDQvYWtFUWRrRUljU0lEZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQURJQVJ5SUFCeWF5SURRUUYwSUFVZ0EwRVZhblpCQVhGeVFSeHFJUU1MSUFJZ0F6WUNIQ0FDUWdBM0FoQWdBMEVDZEVHNHRvQ0FBR29oQkFKQVFRQW9Bb3kwZ0lBQUlnQkJBU0FEZENJSWNRMEFJQVFnQWpZQ0FFRUFJQUFnQ0hJMkFveTBnSUFBSUFJZ0JEWUNHQ0FDSUFJMkFnZ2dBaUFDTmdJTURBTUxJQVZCQUVFWklBTkJBWFpySUFOQkgwWWJkQ0VESUFRb0FnQWhBQU5BSUFBaUJDZ0NCRUY0Y1NBRlJnMENJQU5CSFhZaEFDQURRUUYwSVFNZ0JDQUFRUVJ4YWtFUWFpSUlLQUlBSWdBTkFBc2dDQ0FDTmdJQUlBSWdCRFlDR0NBQ0lBSTJBZ3dnQWlBQ05nSUlEQUlMSUFCQmVDQUFhMEVQY1VFQUlBQkJDR3BCRDNFYklnTnFJZ3NnQmlBRGEwRklhaUlEUVFGeU5nSUVJQWhCVEdwQk9EWUNBQ0FFSUFWQk55QUZhMEVQY1VFQUlBVkJTV3BCRDNFYmFrRkJhaUlJSUFnZ0JFRVFha2tiSWdoQkl6WUNCRUVBUVFBb0F2QzNnSUFBTmdLa3RJQ0FBRUVBSUFzMkFxQzBnSUFBUVFBZ0F6WUNsTFNBZ0FBZ0NFRVFha0VBS1FMUXQ0Q0FBRGNDQUNBSVFRQXBBc2kzZ0lBQU53SUlRUUFnQ0VFSWFqWUMwTGVBZ0FCQkFDQUdOZ0xNdDRDQUFFRUFJQUEyQXNpM2dJQUFRUUJCQURZQzFMZUFnQUFnQ0VFa2FpRURBMEFnQTBFSE5nSUFJQVVnQTBFRWFpSURTdzBBQ3lBSUlBUkdEUU1nQ0NBSUtBSUVRWDV4TmdJRUlBZ2dDQ0FFYXlJR05nSUFJQVFnQmtFQmNqWUNCQUpBSUFaQi93RkxEUUFnQmtFRGRpSUZRUU4wUWJDMGdJQUFhaUVEQWtBQ1FFRUFLQUtJdElDQUFDSUFRUUVnQlhRaUJYRU5BRUVBSUFBZ0JYSTJBb2kwZ0lBQUlBTWhCUXdCQ3lBREtBSUlJUVVMSUFVZ0JEWUNEQ0FESUFRMkFnZ2dCQ0FETmdJTUlBUWdCVFlDQ0F3RUMwRWZJUU1DUUNBR1FmLy8vd2RMRFFBZ0JrRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBRElBVnlJQUJ5YXlJRFFRRjBJQVlnQTBFVmFuWkJBWEZ5UVJ4cUlRTUxJQVJDQURjQ0VDQUVRUnhxSUFNMkFnQWdBMEVDZEVHNHRvQ0FBR29oQlFKQVFRQW9Bb3kwZ0lBQUlnQkJBU0FEZENJSWNRMEFJQVVnQkRZQ0FFRUFJQUFnQ0hJMkFveTBnSUFBSUFSQkdHb2dCVFlDQUNBRUlBUTJBZ2dnQkNBRU5nSU1EQVFMSUFaQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQUFOQUlBQWlCU2dDQkVGNGNTQUdSZzBESUFOQkhYWWhBQ0FEUVFGMElRTWdCU0FBUVFSeGFrRVFhaUlJS0FJQUlnQU5BQXNnQ0NBRU5nSUFJQVJCR0dvZ0JUWUNBQ0FFSUFRMkFnd2dCQ0FFTmdJSURBTUxJQVFvQWdnaUF5QUNOZ0lNSUFRZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFFTmdJTUlBSWdBellDQ0FzZ0JrRUlhaUVEREFVTElBVW9BZ2dpQXlBRU5nSU1JQVVnQkRZQ0NDQUVRUmhxUVFBMkFnQWdCQ0FGTmdJTUlBUWdBellDQ0F0QkFDZ0NsTFNBZ0FBaUF5QUNUUTBBUVFBb0FxQzBnSUFBSWdRZ0Ftb2lCU0FESUFKcklnTkJBWEkyQWdSQkFDQUROZ0tVdElDQUFFRUFJQVUyQXFDMGdJQUFJQVFnQWtFRGNqWUNCQ0FFUVFocUlRTU1Bd3RCQUNFRFFRQkJNRFlDK0xlQWdBQU1BZ3NDUUNBTFJRMEFBa0FDUUNBSUlBZ29BaHdpQlVFQ2RFRzR0b0NBQUdvaUF5Z0NBRWNOQUNBRElBQTJBZ0FnQUEwQlFRQWdCMEYrSUFWM2NTSUhOZ0tNdElDQUFBd0NDeUFMUVJCQkZDQUxLQUlRSUFoR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFzMkFoZ0NRQ0FJS0FJUUlnTkZEUUFnQUNBRE5nSVFJQU1nQURZQ0dBc2dDRUVVYWlnQ0FDSURSUTBBSUFCQkZHb2dBellDQUNBRElBQTJBaGdMQWtBQ1FDQUVRUTlMRFFBZ0NDQUVJQUpxSWdOQkEzSTJBZ1FnQXlBSWFrRUVhaUlESUFNb0FnQkJBWEkyQWdBTUFRc2dDQ0FDYWlJQUlBUkJBWEkyQWdRZ0NDQUNRUU55TmdJRUlBQWdCR29nQkRZQ0FBSkFJQVJCL3dGTERRQWdCRUVEZGlJRVFRTjBRYkMwZ0lBQWFpRURBa0FDUUVFQUtBS0l0SUNBQUNJRlFRRWdCSFFpQkhFTkFFRUFJQVVnQkhJMkFvaTBnSUFBSUFNaEJBd0JDeUFES0FJSUlRUUxJQVFnQURZQ0RDQURJQUEyQWdnZ0FDQUROZ0lNSUFBZ0JEWUNDQXdCQzBFZklRTUNRQ0FFUWYvLy93ZExEUUFnQkVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUNJQUpCZ0lBUGFrRVFka0VDY1NJQ2RFRVBkaUFESUFWeUlBSnlheUlEUVFGMElBUWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBQWdBellDSENBQVFnQTNBaEFnQTBFQ2RFRzR0b0NBQUdvaEJRSkFJQWRCQVNBRGRDSUNjUTBBSUFVZ0FEWUNBRUVBSUFjZ0FuSTJBb3kwZ0lBQUlBQWdCVFlDR0NBQUlBQTJBZ2dnQUNBQU5nSU1EQUVMSUFSQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQWdKQUEwQWdBaUlGS0FJRVFYaHhJQVJHRFFFZ0EwRWRkaUVDSUFOQkFYUWhBeUFGSUFKQkJIRnFRUkJxSWdZb0FnQWlBZzBBQ3lBR0lBQTJBZ0FnQUNBRk5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTUFRc2dCU2dDQ0NJRElBQTJBZ3dnQlNBQU5nSUlJQUJCQURZQ0dDQUFJQVUyQWd3Z0FDQUROZ0lJQ3lBSVFRaHFJUU1NQVFzQ1FDQUtSUTBBQWtBQ1FDQUFJQUFvQWh3aUJVRUNkRUc0dG9DQUFHb2lBeWdDQUVjTkFDQURJQWcyQWdBZ0NBMEJRUUFnQ1VGK0lBVjNjVFlDakxTQWdBQU1BZ3NnQ2tFUVFSUWdDaWdDRUNBQVJodHFJQWcyQWdBZ0NFVU5BUXNnQ0NBS05nSVlBa0FnQUNnQ0VDSURSUTBBSUFnZ0F6WUNFQ0FESUFnMkFoZ0xJQUJCRkdvb0FnQWlBMFVOQUNBSVFSUnFJQU0yQWdBZ0F5QUlOZ0lZQ3dKQUFrQWdCRUVQU3cwQUlBQWdCQ0FDYWlJRFFRTnlOZ0lFSUFNZ0FHcEJCR29pQXlBREtBSUFRUUZ5TmdJQURBRUxJQUFnQW1vaUJTQUVRUUZ5TmdJRUlBQWdBa0VEY2pZQ0JDQUZJQVJxSUFRMkFnQUNRQ0FIUlEwQUlBZEJBM1lpQ0VFRGRFR3d0SUNBQUdvaEFrRUFLQUtjdElDQUFDRURBa0FDUUVFQklBaDBJZ2dnQm5FTkFFRUFJQWdnQm5JMkFvaTBnSUFBSUFJaENBd0JDeUFDS0FJSUlRZ0xJQWdnQXpZQ0RDQUNJQU0yQWdnZ0F5QUNOZ0lNSUFNZ0NEWUNDQXRCQUNBRk5nS2N0SUNBQUVFQUlBUTJBcEMwZ0lBQUN5QUFRUWhxSVFNTElBRkJFR29rZ0lDQWdBQWdBd3NLQUNBQUVMMkFnSUFBQy9BTkFRZC9Ba0FnQUVVTkFDQUFRWGhxSWdFZ0FFRjhhaWdDQUNJQ1FYaHhJZ0JxSVFNQ1FDQUNRUUZ4RFFBZ0FrRURjVVVOQVNBQklBRW9BZ0FpQW1zaUFVRUFLQUtZdElDQUFDSUVTUTBCSUFJZ0FHb2hBQUpBUVFBb0FweTBnSUFBSUFGR0RRQUNRQ0FDUWY4QlN3MEFJQUVvQWdnaUJDQUNRUU4ySWdWQkEzUkJzTFNBZ0FCcUlnWkdHZ0pBSUFFb0Fnd2lBaUFFUncwQVFRQkJBQ2dDaUxTQWdBQkJmaUFGZDNFMkFvaTBnSUFBREFNTElBSWdCa1lhSUFJZ0JEWUNDQ0FFSUFJMkFnd01BZ3NnQVNnQ0dDRUhBa0FDUUNBQktBSU1JZ1lnQVVZTkFDQUVJQUVvQWdnaUFrc2FJQVlnQWpZQ0NDQUNJQVkyQWd3TUFRc0NRQ0FCUVJScUlnSW9BZ0FpQkEwQUlBRkJFR29pQWlnQ0FDSUVEUUJCQUNFR0RBRUxBMEFnQWlFRklBUWlCa0VVYWlJQ0tBSUFJZ1FOQUNBR1FSQnFJUUlnQmlnQ0VDSUVEUUFMSUFWQkFEWUNBQXNnQjBVTkFRSkFBa0FnQVNnQ0hDSUVRUUowUWJpMmdJQUFhaUlDS0FJQUlBRkhEUUFnQWlBR05nSUFJQVlOQVVFQVFRQW9Bb3kwZ0lBQVFYNGdCSGR4TmdLTXRJQ0FBQXdEQ3lBSFFSQkJGQ0FIS0FJUUlBRkdHMm9nQmpZQ0FDQUdSUTBDQ3lBR0lBYzJBaGdDUUNBQktBSVFJZ0pGRFFBZ0JpQUNOZ0lRSUFJZ0JqWUNHQXNnQVNnQ0ZDSUNSUTBCSUFaQkZHb2dBallDQUNBQ0lBWTJBaGdNQVFzZ0F5Z0NCQ0lDUVFOeFFRTkhEUUFnQXlBQ1FYNXhOZ0lFUVFBZ0FEWUNrTFNBZ0FBZ0FTQUFhaUFBTmdJQUlBRWdBRUVCY2pZQ0JBOExJQU1nQVUwTkFDQURLQUlFSWdKQkFYRkZEUUFDUUFKQUlBSkJBbkVOQUFKQVFRQW9BcUMwZ0lBQUlBTkhEUUJCQUNBQk5nS2d0SUNBQUVFQVFRQW9BcFMwZ0lBQUlBQnFJZ0EyQXBTMGdJQUFJQUVnQUVFQmNqWUNCQ0FCUVFBb0FweTBnSUFBUncwRFFRQkJBRFlDa0xTQWdBQkJBRUVBTmdLY3RJQ0FBQThMQWtCQkFDZ0NuTFNBZ0FBZ0EwY05BRUVBSUFFMkFweTBnSUFBUVFCQkFDZ0NrTFNBZ0FBZ0FHb2lBRFlDa0xTQWdBQWdBU0FBUVFGeU5nSUVJQUVnQUdvZ0FEWUNBQThMSUFKQmVIRWdBR29oQUFKQUFrQWdBa0gvQVVzTkFDQURLQUlJSWdRZ0FrRURkaUlGUVFOMFFiQzBnSUFBYWlJR1Job0NRQ0FES0FJTUlnSWdCRWNOQUVFQVFRQW9Bb2kwZ0lBQVFYNGdCWGR4TmdLSXRJQ0FBQXdDQ3lBQ0lBWkdHaUFDSUFRMkFnZ2dCQ0FDTmdJTURBRUxJQU1vQWhnaEJ3SkFBa0FnQXlnQ0RDSUdJQU5HRFFCQkFDZ0NtTFNBZ0FBZ0F5Z0NDQ0lDU3hvZ0JpQUNOZ0lJSUFJZ0JqWUNEQXdCQ3dKQUlBTkJGR29pQWlnQ0FDSUVEUUFnQTBFUWFpSUNLQUlBSWdRTkFFRUFJUVlNQVFzRFFDQUNJUVVnQkNJR1FSUnFJZ0lvQWdBaUJBMEFJQVpCRUdvaEFpQUdLQUlRSWdRTkFBc2dCVUVBTmdJQUN5QUhSUTBBQWtBQ1FDQURLQUljSWdSQkFuUkJ1TGFBZ0FCcUlnSW9BZ0FnQTBjTkFDQUNJQVkyQWdBZ0JnMEJRUUJCQUNnQ2pMU0FnQUJCZmlBRWQzRTJBb3kwZ0lBQURBSUxJQWRCRUVFVUlBY29BaEFnQTBZYmFpQUdOZ0lBSUFaRkRRRUxJQVlnQnpZQ0dBSkFJQU1vQWhBaUFrVU5BQ0FHSUFJMkFoQWdBaUFHTmdJWUN5QURLQUlVSWdKRkRRQWdCa0VVYWlBQ05nSUFJQUlnQmpZQ0dBc2dBU0FBYWlBQU5nSUFJQUVnQUVFQmNqWUNCQ0FCUVFBb0FweTBnSUFBUncwQlFRQWdBRFlDa0xTQWdBQVBDeUFESUFKQmZuRTJBZ1FnQVNBQWFpQUFOZ0lBSUFFZ0FFRUJjallDQkFzQ1FDQUFRZjhCU3cwQUlBQkJBM1lpQWtFRGRFR3d0SUNBQUdvaEFBSkFBa0JCQUNnQ2lMU0FnQUFpQkVFQklBSjBJZ0p4RFFCQkFDQUVJQUp5TmdLSXRJQ0FBQ0FBSVFJTUFRc2dBQ2dDQ0NFQ0N5QUNJQUUyQWd3Z0FDQUJOZ0lJSUFFZ0FEWUNEQ0FCSUFJMkFnZ1BDMEVmSVFJQ1FDQUFRZi8vL3dkTERRQWdBRUVJZGlJQ0lBSkJnUDQvYWtFUWRrRUljU0lDZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJR0lBWkJnSUFQYWtFUWRrRUNjU0lHZEVFUGRpQUNJQVJ5SUFaeWF5SUNRUUYwSUFBZ0FrRVZhblpCQVhGeVFSeHFJUUlMSUFGQ0FEY0NFQ0FCUVJ4cUlBSTJBZ0FnQWtFQ2RFRzR0b0NBQUdvaEJBSkFBa0JCQUNnQ2pMU0FnQUFpQmtFQklBSjBJZ054RFFBZ0JDQUJOZ0lBUVFBZ0JpQURjallDakxTQWdBQWdBVUVZYWlBRU5nSUFJQUVnQVRZQ0NDQUJJQUUyQWd3TUFRc2dBRUVBUVJrZ0FrRUJkbXNnQWtFZlJodDBJUUlnQkNnQ0FDRUdBa0FEUUNBR0lnUW9BZ1JCZUhFZ0FFWU5BU0FDUVIxMklRWWdBa0VCZENFQ0lBUWdCa0VFY1dwQkVHb2lBeWdDQUNJR0RRQUxJQU1nQVRZQ0FDQUJRUmhxSUFRMkFnQWdBU0FCTmdJTUlBRWdBVFlDQ0F3QkN5QUVLQUlJSWdBZ0FUWUNEQ0FFSUFFMkFnZ2dBVUVZYWtFQU5nSUFJQUVnQkRZQ0RDQUJJQUEyQWdnTFFRQkJBQ2dDcUxTQWdBQkJmMm9pQVVGL0lBRWJOZ0tvdElDQUFBc0xUZ0FDUUNBQURRQS9BRUVRZEE4TEFrQWdBRUgvL3dOeERRQWdBRUYvVEEwQUFrQWdBRUVRZGtBQUlnQkJmMGNOQUVFQVFUQTJBdmkzZ0lBQVFYOFBDeUFBUVJCMER3c1F2NENBZ0FBQUN3UUFBQUFMQzQ0c0FRQkJnQWdMaGl3QkFBQUFBZ0FBQUFNQUFBQUVBQUFBQlFBQUFBWUFBQUFIQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2djWFZsY25rQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5aWIyUjVBRU52Ym5SbGJuUXRUR1Z1WjNSb0lHOTJaWEptYkc5M0FFTm9kVzVySUhOcGVtVWdiM1psY21ac2IzY0FVbVZ6Y0c5dWMyVWdiM1psY21ac2IzY0FTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRWhVVkZBdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRkpVVTFBdmVDNTRJSEpsY1hWbGMzUUFSWGh3WldOMFpXUWdVMDlWVWtORklHMWxkR2h2WkNCbWIzSWdTVU5GTDNndWVDQnlaWEYxWlhOMEFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2dabkpoWjIxbGJuUWdjM1JoY25RQVJYaHdaV04wWldRZ1pHOTBBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZjM1JoZEhWekFFbHVkbUZzYVdRZ2NtVnpjRzl1YzJVZ2MzUmhkSFZ6QUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUhCaGNtRnRaWFJsY25NQVZYTmxjaUJqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZhR1ZoWkdWeVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWlaV2RwYm1BZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBVlc1bGVIQmxZM1JsWkNCamFHRnlJR2x1SUhWeWJDQnpaWEoyWlhJQVNXNTJZV3hwWkNCb1pXRmtaWElnZG1Gc2RXVWdZMmhoY2dCSmJuWmhiR2xrSUdobFlXUmxjaUJtYVdWc1pDQmphR0Z5QUVsdWRtRnNhV1FnYldsdWIzSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lHMWhhbTl5SUhabGNuTnBiMjRBUlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCRFVreEdJR0ZtZEdWeUlIWmxjbk5wYjI0QVNXNTJZV3hwWkNCb1pXRmtaWElnZEc5clpXNEFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOTFjbXdBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWEp6SUdsdUlIVnliQUJWYm1WNGNHVmpkR1ZrSUhOMFlYSjBJR05vWVhJZ2FXNGdkWEpzQUVSdmRXSnNaU0JBSUdsdUlIVnliQUJGYlhCMGVTQkRiMjUwWlc1MExVeGxibWQwYUFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQkRiMjUwWlc1MExVeGxibWQwYUFCRWRYQnNhV05oZEdVZ1EyOXVkR1Z1ZEMxTVpXNW5kR2dBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCd1lYUm9BRU52Ym5SbGJuUXRUR1Z1WjNSb0lHTmhiaWQwSUdKbElIQnlaWE5sYm5RZ2QybDBhQ0JVY21GdWMyWmxjaTFGYm1OdlpHbHVad0JKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJ6YVhwbEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmFHVmhaR1Z5WDNaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdRMUlnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnVEVZZ1lXWjBaWElnYUdWaFpHVnlJSFpoYkhWbEFFbHVkbUZzYVdRZ1lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bllDQm9aV0ZrWlhJZ2RtRnNkV1VBVUdGMWMyVmtJR0o1SUc5dVgyaGxZV1JsY25OZlkyOXRjR3hsZEdVQVNXNTJZV3hwWkNCRlQwWWdjM1JoZEdVQWIyNWZZMmgxYm10ZmFHVmhaR1Z5SUhCaGRYTmxBRzl1WDIxbGMzTmhaMlZmWW1WbmFXNGdjR0YxYzJVQWIyNWZZMmgxYm10ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlNCd1lYVnpaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJGZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCdFpYUm9iMlFBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZabWxsYkdRQVVHRjFjMlZrQUVsdWRtRnNhV1FnZDI5eVpDQmxibU52ZFc1MFpYSmxaQUJKYm5aaGJHbGtJRzFsZEdodlpDQmxibU52ZFc1MFpYSmxaQUJWYm1WNGNHVmpkR1ZrSUdOb1lYSWdhVzRnZFhKc0lITmphR1Z0WVFCU1pYRjFaWE4wSUdoaGN5QnBiblpoYkdsa0lHQlVjbUZ1YzJabGNpMUZibU52WkdsdVoyQUFUVXRCUTFSSlZrbFVXUUJEVDFCWkFFNVBWRWxHV1FCUVRFRlpBRkJWVkFCRFNFVkRTMDlWVkFCUVQxTlVBRkpGVUU5U1ZBQklVRVZmU1U1V1FVeEpSRjlEVDA1VFZFRk9WQUJIUlZRQVNGQkZYMU5VVWtsRFZBQlNSVVJKVWtWRFZBQkRUMDVPUlVOVUFFaFFSVjlKVGxaQlRFbEVYMU5VUVZSVlV3QlBVRlJKVDA1VEFGTkZWRjlRUVZKQlRVVlVSVklBUjBWVVgxQkJVa0ZOUlZSRlVnQklVRVZmVlZORlVnQklVRVZmUTBKZlEwaFZUa3RmU0VWQlJFVlNBRTFMUTBGTVJVNUVRVklBVTBWVVZWQUFWRVZCVWtSUFYwNEFTRkJGWDBOTVQxTkZSRjlEVDA1T1JVTlVTVTlPQUVoUVJWOUpUbFpCVEVsRVgxWkZVbE5KVDA0QVNGQkZYME5DWDAxRlUxTkJSMFZmUWtWSFNVNEFTRkJGWDBsT1ZrRk1TVVJmU0VWQlJFVlNYMVJQUzBWT0FFaFFSVjlKVGxaQlRFbEVYMVZTVEFCTlMwTlBUQUJCUTB3QVNGQkZYMGxPVkVWU1RrRk1BRWhRUlY5UFN3QlZUa3hKVGtzQVZVNU1UME5MQUZCU1NRQklVRVZmU1U1V1FVeEpSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQklVRVZmVlU1RldGQkZRMVJGUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJHVEZWVFNBQlFVazlRVUVGVVEwZ0FUUzFUUlVGU1EwZ0FTRkJGWDBsT1ZrRk1TVVJmVkZKQlRsTkdSVkpmUlU1RFQwUkpUa2NBUlhod1pXTjBaV1FnUTFKTVJnQklVRVZmU1U1V1FVeEpSRjlEU0ZWT1MxOVRTVnBGQUUxUFZrVUFTRkJGWDBOQ1gwaEZRVVJGVWxOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYME5QVFZCTVJWUkZBRWhRUlY5RFFsOU5SVk5UUVVkRlgwTlBUVkJNUlZSRkFFUkZURVZVUlFCSVVFVmZTVTVXUVV4SlJGOUZUMFpmVTFSQlZFVUFVRUZWVTBVQVVGVlNSMFVBVFVWU1IwVUFTRkJGWDFCQlZWTkZSRjlWVUVkU1FVUkZBRWhRUlY5UVFWVlRSVVJmU0RKZlZWQkhVa0ZFUlFCVFQxVlNRMFVBUVU1T1QxVk9RMFVBVkZKQlEwVUFSRVZUUTFKSlFrVUFWVTVUVlVKVFExSkpRa1VBVWtWRFQxSkVBRWhRUlY5SlRsWkJURWxFWDAxRlZFaFBSQUJRVWs5UVJrbE9SQUJWVGtKSlRrUUFVa1ZDU1U1RUFFaFFSVjlEVWw5RldGQkZRMVJGUkFCSVVFVmZURVpmUlZoUVJVTlVSVVFBU0ZCRlgxQkJWVk5GUkFCSVJVRkVBRVY0Y0dWamRHVmtJRWhVVkZBdkFOd0xBQURQQ3dBQTB3b0FBSmtOQUFBUURBQUFYUXNBQUY4TkFBQzFDd0FBdWdvQUFITUxBQUNjQ3dBQTlRc0FBSE1NQUFEdkNnQUEzQXdBQUVjTUFBQ0hDd0FBand3QUFMME1BQUF2Q3dBQXB3d0FBS2tOQUFBRURRQUFGdzBBQUNZTEFBQ0pEUUFBMVF3QUFNOEtBQUMwRFFBQXJnb0FBS0VLQUFEbkNnQUFBZ3NBQUQwTkFBQ1FDZ0FBN0FzQUFNVUxBQUNLREFBQWNnMEFBRFFNQUFCQURBQUE2Z3NBQUlRTkFBQ0NEUUFBZXcwQUFNc0xBQUN6Q2dBQWhRb0FBS1VLQUFEK0RBQUFQZ3dBQUpVS0FBQk9EUUFBVEEwQUFEZ01BQUQ0REFBQVF3c0FBT1VMQUFEakN3QUFMUTBBQVBFTEFBQkREUUFBTkEwQUFFNExBQUNjQ2dBQThnd0FBRlFMQUFBWUN3QUFDZ3NBQU40S0FBQllEUUFBTGd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBV3h2YzJWbFpYQXRZV3hwZG1VQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVDQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFXTm9kVzVyWldRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQUFFQkFRRUJBQUFCQVFBQkFRQUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaV04wYVc5dVpXNTBMV3hsYm1kMGFHOXVjbTk0ZVMxamIyNXVaV04wYVc5dUFBQUFBQUFBQUFBQUFBQUFBQUFBY21GdWMyWmxjaTFsYm1OdlpHbHVaM0JuY21Ga1pRMEtEUW9OQ2xOTkRRb05DbFJVVUM5RFJTOVVVMUF2QUFBQUFBQUFBQUFBQUFBQUFRSUFBUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUVDQUFFREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBRUJCUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBQUVBQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREJBQUFCQVFFQkFRRUJBUUVCQVFGQkFRRUJBUUVCQVFFQkFRRUFBUUFCZ2NFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQ0FBQUFBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVGs5VlRrTkZSVU5MVDFWVVRrVkRWRVZVUlVOU1NVSkZURlZUU0VWVVJVRkVVMFZCVWtOSVVrZEZRMVJKVmtsVVdVeEZUa1JCVWxaRlQxUkpSbGxRVkVsUFRsTkRTRk5GUVZsVFZFRlVRMGhIUlU5U1JFbFNSVU5VVDFKVVVrTklVRUZTUVUxRlZFVlNWVkpEUlVKVFExSkpRa1ZCVWtSUFYwNUJRMFZKVGtST1MwTkxWVUpUUTFKSlFrVklWRlJRTDBGRVZGQXZcIjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NsaWVudC5qc1xudmFyIHJlcXVpcmVfY2xpZW50ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2xpZW50LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciBuZXQyID0gcmVxdWlyZShcIm5ldFwiKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIFJlcXVlc3QgPSByZXF1aXJlX3JlcXVlc3QoKTtcbiAgICB2YXIgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlX2Rpc3BhdGNoZXJfYmFzZSgpO1xuICAgIHZhciBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlX3JlZGlyZWN0KCk7XG4gICAgdmFyIHtcbiAgICAgIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgICAgIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgICAgIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gICAgICBIZWFkZXJzVGltZW91dEVycm9yLFxuICAgICAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gICAgICBTb2NrZXRFcnJvcixcbiAgICAgIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgICAgIEJvZHlUaW1lb3V0RXJyb3IsXG4gICAgICBIVFRQUGFyc2VyRXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlX2Nvbm5lY3QoKTtcbiAgICB2YXIge1xuICAgICAga1VybCxcbiAgICAgIGtSZXNldCxcbiAgICAgIGtTZXJ2ZXJOYW1lLFxuICAgICAga0NsaWVudCxcbiAgICAgIGtCdXN5LFxuICAgICAga1BhcnNlcixcbiAgICAgIGtDb25uZWN0LFxuICAgICAga0Jsb2NraW5nLFxuICAgICAga1Jlc3VtaW5nLFxuICAgICAga1J1bm5pbmcsXG4gICAgICBrUGVuZGluZyxcbiAgICAgIGtTaXplLFxuICAgICAga1dyaXRpbmcsXG4gICAgICBrUXVldWUsXG4gICAgICBrQ29ubmVjdGVkLFxuICAgICAga0Nvbm5lY3RpbmcsXG4gICAgICBrTmVlZERyYWluLFxuICAgICAga05vUmVmLFxuICAgICAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICAgICAga0hvc3RIZWFkZXIsXG4gICAgICBrUGVuZGluZ0lkeCxcbiAgICAgIGtSdW5uaW5nSWR4LFxuICAgICAga0Vycm9yLFxuICAgICAga1BpcGVsaW5pbmcsXG4gICAgICBrU29ja2V0LFxuICAgICAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAgICAgIGtNYXhIZWFkZXJzU2l6ZSxcbiAgICAgIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICAgICAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gICAgICBrSGVhZGVyc1RpbWVvdXQsXG4gICAgICBrQm9keVRpbWVvdXQsXG4gICAgICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAgICAgIGtDb25uZWN0b3IsXG4gICAgICBrTWF4UmVkaXJlY3Rpb25zLFxuICAgICAga01heFJlcXVlc3RzLFxuICAgICAga0NvdW50ZXIsXG4gICAgICBrQ2xvc2UsXG4gICAgICBrRGVzdHJveSxcbiAgICAgIGtEaXNwYXRjaFxuICAgIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woXCJrQ2xvc2VkUmVzb2x2ZVwiKTtcbiAgICB2YXIgY2hhbm5lbHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZShcImRpYWdub3N0aWNzX2NoYW5uZWxcIik7XG4gICAgICBjaGFubmVscy5zZW5kSGVhZGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpzZW5kSGVhZGVyc1wiKTtcbiAgICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdFwiKTtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvciA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3JcIik7XG4gICAgICBjaGFubmVscy5jb25uZWN0ZWQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpjbGllbnQ6Y29ubmVjdGVkXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNoYW5uZWxzLnNlbmRIZWFkZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfTtcbiAgICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfTtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH07XG4gICAgfVxuICAgIHZhciBDbGllbnQgPSBjbGFzcyBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHVybCwge1xuICAgICAgICBtYXhIZWFkZXJTaXplLFxuICAgICAgICBoZWFkZXJzVGltZW91dCxcbiAgICAgICAgc29ja2V0VGltZW91dCxcbiAgICAgICAgcmVxdWVzdFRpbWVvdXQsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICBib2R5VGltZW91dCxcbiAgICAgICAgaWRsZVRpbWVvdXQsXG4gICAgICAgIGtlZXBBbGl2ZSxcbiAgICAgICAga2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgbWF4S2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAga2VlcEFsaXZlTWF4VGltZW91dCxcbiAgICAgICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgcGlwZWxpbmluZyxcbiAgICAgICAgdGxzLFxuICAgICAgICBzdHJpY3RDb250ZW50TGVuZ3RoLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgICAgICBjb25uZWN0OiBjb25uZWN0MixcbiAgICAgICAgbWF4UmVxdWVzdHNQZXJDbGllbnRcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoa2VlcEFsaXZlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBrZWVwQWxpdmUsIHVzZSBwaXBlbGluaW5nPTAgaW5zdGVhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgc29ja2V0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFRpbWVvdXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZGxlVGltZW91dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgaWRsZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVUaW1lb3V0IGluc3RlYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG1heEtlZXBBbGl2ZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVNYXhUaW1lb3V0IGluc3RlYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEhlYWRlclNpemUgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKG1heEhlYWRlclNpemUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBtYXhIZWFkZXJTaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXRQYXRoICE9IG51bGwgJiYgdHlwZW9mIHNvY2tldFBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNvY2tldFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3RUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdFRpbWVvdXQpIHx8IGNvbm5lY3RUaW1lb3V0IDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbm5lY3RUaW1lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQga2VlcEFsaXZlVGltZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcEFsaXZlTWF4VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZU1heFRpbWVvdXQpIHx8IGtlZXBBbGl2ZU1heFRpbWVvdXQgPD0gMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImhlYWRlcnNUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdDIgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdDIgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29ubmVjdDIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFJlcXVlc3RzUGVyQ2xpZW50ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlcXVlc3RzUGVyQ2xpZW50KSB8fCBtYXhSZXF1ZXN0c1BlckNsaWVudCA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4UmVxdWVzdHNQZXJDbGllbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3QyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25uZWN0MiA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRscyxcbiAgICAgICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAgICAgLi4uY29ubmVjdDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tVcmxdID0gdXRpbDIucGFyc2VPcmlnaW4odXJsKTtcbiAgICAgICAgdGhpc1trQ29ubmVjdG9yXSA9IGNvbm5lY3QyO1xuICAgICAgICB0aGlzW2tTb2NrZXRdID0gbnVsbDtcbiAgICAgICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMTtcbiAgICAgICAgdGhpc1trTWF4SGVhZGVyc1NpemVdID0gbWF4SGVhZGVyU2l6ZSB8fCAxNjM4NDtcbiAgICAgICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dDtcbiAgICAgICAgdGhpc1trS2VlcEFsaXZlTWF4VGltZW91dF0gPSBrZWVwQWxpdmVNYXhUaW1lb3V0ID09IG51bGwgPyA2ZTUgOiBrZWVwQWxpdmVNYXhUaW1lb3V0O1xuICAgICAgICB0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSA9IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgPT0gbnVsbCA/IDFlMyA6IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF07XG4gICAgICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbDtcbiAgICAgICAgdGhpc1trUmVzdW1pbmddID0gMDtcbiAgICAgICAgdGhpc1trTmVlZERyYWluXSA9IDA7XG4gICAgICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6IFwiXCJ9XFxyXG5gO1xuICAgICAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzZTQ7XG4gICAgICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDNlNDtcbiAgICAgICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aDtcbiAgICAgICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9ucztcbiAgICAgICAgdGhpc1trTWF4UmVxdWVzdHNdID0gbWF4UmVxdWVzdHNQZXJDbGllbnQ7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgdGhpc1trUXVldWVdID0gW107XG4gICAgICAgIHRoaXNba1J1bm5pbmdJZHhdID0gMDtcbiAgICAgICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwO1xuICAgICAgfVxuICAgICAgZ2V0IHBpcGVsaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQaXBlbGluaW5nXTtcbiAgICAgIH1cbiAgICAgIHNldCBwaXBlbGluaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXNba1BpcGVsaW5pbmddID0gdmFsdWU7XG4gICAgICAgIHJlc3VtZSh0aGlzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGdldCBba1BlbmRpbmddKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trUXVldWVdLmxlbmd0aCAtIHRoaXNba1BlbmRpbmdJZHhdO1xuICAgICAgfVxuICAgICAgZ2V0IFtrUnVubmluZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQZW5kaW5nSWR4XSAtIHRoaXNba1J1bm5pbmdJZHhdO1xuICAgICAgfVxuICAgICAgZ2V0IFtrU2l6ZV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF07XG4gICAgICB9XG4gICAgICBnZXQgW2tDb25uZWN0ZWRdKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzW2tTb2NrZXRdICYmICF0aGlzW2tDb25uZWN0aW5nXSAmJiAhdGhpc1trU29ja2V0XS5kZXN0cm95ZWQ7XG4gICAgICB9XG4gICAgICBnZXQgW2tCdXN5XSgpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpc1trU29ja2V0XTtcbiAgICAgICAgcmV0dXJuIHNvY2tldCAmJiAoc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba0Jsb2NraW5nXSkgfHwgdGhpc1trU2l6ZV0gPj0gKHRoaXNba1BpcGVsaW5pbmddIHx8IDEpIHx8IHRoaXNba1BlbmRpbmddID4gMDtcbiAgICAgIH1cbiAgICAgIFtrQ29ubmVjdF0oY2IpIHtcbiAgICAgICAgY29ubmVjdCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY29ubmVjdFwiLCBjYik7XG4gICAgICB9XG4gICAgICBba0Rpc3BhdGNoXShvcHRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gdGhpc1trTWF4UmVkaXJlY3Rpb25zXSB9ID0gb3B0cztcbiAgICAgICAgaWYgKG1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICAgIGhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKHRoaXMsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgdGhpc1trVXJsXS5vcmlnaW47XG4gICAgICAgIGNvbnN0IHJlcXVlc3QyID0gbmV3IFJlcXVlc3Qob3JpZ2luLCBvcHRzLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdDIpO1xuICAgICAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbDIuYm9keUxlbmd0aChyZXF1ZXN0Mi5ib2R5KSA9PSBudWxsICYmIHV0aWwyLmlzSXRlcmFibGUocmVxdWVzdDIuYm9keSkpIHtcbiAgICAgICAgICB0aGlzW2tSZXN1bWluZ10gPSAxO1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bWUodGhpcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba1Jlc3VtaW5nXSAmJiB0aGlzW2tOZWVkRHJhaW5dICE9PSAyICYmIHRoaXNba0J1c3ldKSB7XG4gICAgICAgICAgdGhpc1trTmVlZERyYWluXSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyO1xuICAgICAgfVxuICAgICAgYXN5bmMgW2tDbG9zZV0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGlmICghdGhpc1trU2l6ZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveShyZXNvbHZlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Rlc3Ryb3ldKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXNba1F1ZXVlXS5zcGxpY2UodGhpc1trUGVuZGluZ0lkeF0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QyID0gcmVxdWVzdHNbaV07XG4gICAgICAgICAgICBlcnJvclJlcXVlc3QodGhpcywgcmVxdWVzdDIsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0oKTtcbiAgICAgICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIFwiY2FsbGJhY2tcIik7XG4gICAgICAgICAgaWYgKCF0aGlzW2tTb2NrZXRdKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kodGhpc1trU29ja2V0XS5vbihcImNsb3NlXCIsIGNhbGxiYWNrKSwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdW1lKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShDbGllbnQsIFwiQ2xpZW50XCIpO1xuICAgIHZhciBjb25zdGFudHMgPSByZXF1aXJlX2NvbnN0YW50czIoKTtcbiAgICB2YXIgRU1QVFlfQlVGID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGxhenlsbGh0dHAoKSB7XG4gICAgICBjb25zdCBsbGh0dHBXYXNtRGF0YSA9IHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEID8gcmVxdWlyZV9sbGh0dHBfd2FzbSgpIDogdm9pZCAwO1xuICAgICAgbGV0IG1vZDI7XG4gICAgICB0cnkge1xuICAgICAgICBtb2QyID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShyZXF1aXJlX2xsaHR0cF9zaW1kX3dhc20oKSwgXCJiYXNlNjRcIikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBtb2QyID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShsbGh0dHBXYXNtRGF0YSB8fCByZXF1aXJlX2xsaHR0cF93YXNtKCksIFwiYmFzZTY0XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2QyLCB7XG4gICAgICAgIGVudjoge1xuICAgICAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXNtX29uX3N0YXR1czogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0cjtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25TdGF0dXMoY3VycmVudEJ1ZmZlclJlZi5zbGljZShzdGFydCwgZW5kKSkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0cjtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJGaWVsZChjdXJyZW50QnVmZmVyUmVmLnNsaWNlKHN0YXJ0LCBlbmQpKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FzbV9vbl9oZWFkZXJfdmFsdWU6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHI7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIGxlbjtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUoY3VycmVudEJ1ZmZlclJlZi5zbGljZShzdGFydCwgZW5kKSkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25faGVhZGVyc19jb21wbGV0ZTogKHAsIHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyc0NvbXBsZXRlKHN0YXR1c0NvZGUsIEJvb2xlYW4odXBncmFkZSksIEJvb2xlYW4oc2hvdWxkS2VlcEFsaXZlKSkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25fYm9keTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0cjtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25Cb2R5KGN1cnJlbnRCdWZmZXJSZWYuc2xpY2Uoc3RhcnQsIGVuZCkpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6IChwKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKSB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShsYXp5bGxodHRwLCBcImxhenlsbGh0dHBcIik7XG4gICAgdmFyIGxsaHR0cEluc3RhbmNlID0gbnVsbDtcbiAgICB2YXIgbGxodHRwUHJvbWlzZSA9IGxhenlsbGh0dHAoKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gICAgdmFyIGN1cnJlbnRQYXJzZXIgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QnVmZmVyUmVmID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJ1ZmZlclNpemUgPSAwO1xuICAgIHZhciBjdXJyZW50QnVmZmVyUHRyID0gbnVsbDtcbiAgICB2YXIgVElNRU9VVF9IRUFERVJTID0gMTtcbiAgICB2YXIgVElNRU9VVF9CT0RZID0gMjtcbiAgICB2YXIgVElNRU9VVF9JRExFID0gMztcbiAgICB2YXIgUGFyc2VyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY2xpZW50LCBzb2NrZXQsIHsgZXhwb3J0czogZXhwb3J0czIgfSkge1xuICAgICAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGNsaWVudFtrTWF4SGVhZGVyc1NpemVdKSAmJiBjbGllbnRba01heEhlYWRlcnNTaXplXSA+IDApO1xuICAgICAgICB0aGlzLmxsaHR0cCA9IGV4cG9ydHMyO1xuICAgICAgICB0aGlzLnB0ciA9IHRoaXMubGxodHRwLmxsaHR0cF9hbGxvYyhjb25zdGFudHMuVFlQRS5SRVNQT05TRSk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy51cGdyYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhlYWRlcnNTaXplID0gMDtcbiAgICAgICAgdGhpcy5oZWFkZXJzTWF4U2l6ZSA9IGNsaWVudFtrTWF4SGVhZGVyc1NpemVdO1xuICAgICAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc3VtZSA9IHRoaXMucmVzdW1lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgPSBcIlwiO1xuICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBcIlwiO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCh2YWx1ZSwgdHlwZSkge1xuICAgICAgICB0aGlzLnRpbWVvdXRUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRpbWVvdXRWYWx1ZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChvblBhcnNlclRpbWVvdXQsIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICAgICAgdGhpcy50aW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGltZW91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuZGVzdHJveWVkIHx8ICF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbCk7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpO1xuICAgICAgICB0aGlzLmxsaHR0cC5sbGh0dHBfcmVzdW1lKHRoaXMucHRyKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMudGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCkgfHwgRU1QVFlfQlVGKTtcbiAgICAgICAgdGhpcy5yZWFkTW9yZSgpO1xuICAgICAgfVxuICAgICAgcmVhZE1vcmUoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wdHIpIHtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuc29ja2V0LnJlYWQoKTtcbiAgICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV4ZWN1dGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGVjdXRlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpO1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnBhdXNlZCk7XG4gICAgICAgIGNvbnN0IHsgc29ja2V0LCBsbGh0dHAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IGN1cnJlbnRCdWZmZXJTaXplKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRCdWZmZXJQdHIpIHtcbiAgICAgICAgICAgIGxsaHR0cC5mcmVlKGN1cnJlbnRCdWZmZXJQdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50QnVmZmVyU2l6ZSA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQwOTYpICogNDA5NjtcbiAgICAgICAgICBjdXJyZW50QnVmZmVyUHRyID0gbGxodHRwLm1hbGxvYyhjdXJyZW50QnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIGN1cnJlbnRCdWZmZXJQdHIsIGN1cnJlbnRCdWZmZXJTaXplKS5zZXQoZGF0YSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IGRhdGE7XG4gICAgICAgICAgICBjdXJyZW50UGFyc2VyID0gdGhpcztcbiAgICAgICAgICAgIHJldCA9IGxsaHR0cC5sbGh0dHBfZXhlY3V0ZSh0aGlzLnB0ciwgY3VycmVudEJ1ZmZlclB0ciwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9wb3ModGhpcy5wdHIpIC0gY3VycmVudEJ1ZmZlclB0cjtcbiAgICAgICAgICBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEX1VQR1JBREUpIHtcbiAgICAgICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEuc2xpY2Uob2Zmc2V0KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNvY2tldC51bnNoaWZ0KGRhdGEuc2xpY2Uob2Zmc2V0KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IGNvbnN0YW50cy5FUlJPUi5PSykge1xuICAgICAgICAgICAgY29uc3QgcHRyID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcmVhc29uKHRoaXMucHRyKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChwdHIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGVuID0gbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIHB0cikuaW5kZXhPZigwKTtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBIVFRQUGFyc2VyRXJyb3IobWVzc2FnZSwgY29uc3RhbnRzLkVSUk9SW3JldF0sIGRhdGEuc2xpY2Uob2Zmc2V0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluaXNoKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyc2VyID0gdGhpcztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudFBhcnNlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHRoaXMuc29ja2V0LCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbCk7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpO1xuICAgICAgICB0aGlzLmxsaHR0cC5sbGh0dHBfZnJlZSh0aGlzLnB0cik7XG4gICAgICAgIHRoaXMucHRyID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvblN0YXR1cyhidWYpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gYnVmLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBvbk1lc3NhZ2VCZWdpbigpIHtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0Mikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25IZWFkZXJGaWVsZChidWYpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKChsZW4gJiAxKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1Zik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJWYWx1ZShidWYpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGg7XG4gICAgICAgIGlmICgobGVuICYgMSkgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpO1xuICAgICAgICAgIGxlbiArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5oZWFkZXJzW2xlbiAtIDJdO1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJrZWVwLWFsaXZlXCIpIHtcbiAgICAgICAgICB0aGlzLmtlZXBBbGl2ZSArPSBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtbGVuZ3RoXCIpIHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggKz0gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrSGVhZGVyKGxlbikge1xuICAgICAgICB0aGlzLmhlYWRlcnNTaXplICs9IGxlbjtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3kodGhpcy5zb2NrZXQsIG5ldyBIZWFkZXJzT3ZlcmZsb3dFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25VcGdyYWRlKGhlYWQpIHtcbiAgICAgICAgY29uc3QgeyB1cGdyYWRlLCBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzQ29kZSB9ID0gdGhpcztcbiAgICAgICAgYXNzZXJ0KHVwZ3JhZGUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBhc3NlcnQocmVxdWVzdDIpO1xuICAgICAgICBhc3NlcnQoIXNvY2tldC5kZXN0cm95ZWQpO1xuICAgICAgICBhc3NlcnQoc29ja2V0ID09PSBjbGllbnRba1NvY2tldF0pO1xuICAgICAgICBhc3NlcnQoIXRoaXMucGF1c2VkKTtcbiAgICAgICAgYXNzZXJ0KHJlcXVlc3QyLnVwZ3JhZGUgfHwgcmVxdWVzdDIubWV0aG9kID09PSBcIkNPTk5FQ1RcIik7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbDtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gW107XG4gICAgICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwO1xuICAgICAgICBzb2NrZXQudW5zaGlmdChoZWFkKTtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLmRlc3Ryb3koKTtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbDtcbiAgICAgICAgc29ja2V0W2tDbGllbnRdID0gbnVsbDtcbiAgICAgICAgc29ja2V0W2tFcnJvcl0gPSBudWxsO1xuICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKS5yZW1vdmVMaXN0ZW5lcihcInJlYWRhYmxlXCIsIG9uU29ja2V0UmVhZGFibGUpLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uU29ja2V0RW5kKS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICBjbGllbnRba1NvY2tldF0gPSBudWxsO1xuICAgICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbDtcbiAgICAgICAgY2xpZW50LmVtaXQoXCJkaXNjb25uZWN0XCIsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoXCJ1cGdyYWRlXCIpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXF1ZXN0Mi5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdW1lKGNsaWVudCk7XG4gICAgICB9XG4gICAgICBvbkhlYWRlcnNDb21wbGV0ZShzdGF0dXNDb2RlLCB1cGdyYWRlLCBzaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzVGV4dCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0Mikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoIXRoaXMudXBncmFkZSk7XG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXR1c0NvZGUgPCAyMDApO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcihcImJhZCByZXNwb25zZVwiLCB1dGlsMi5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZ3JhZGUgJiYgIXJlcXVlc3QyLnVwZ3JhZGUpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKFwiYmFkIHVwZ3JhZGVcIiwgdXRpbDIuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSk7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLCBUSU1FT1VUX0hFQURFUlMpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IHNob3VsZEtlZXBBbGl2ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzQ29kZSA+PSAyMDApIHtcbiAgICAgICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QyLmJvZHlUaW1lb3V0ICE9IG51bGwgPyByZXF1ZXN0Mi5ib2R5VGltZW91dCA6IGNsaWVudFtrQm9keVRpbWVvdXRdO1xuICAgICAgICAgIHRoaXMuc2V0VGltZW91dChib2R5VGltZW91dCwgVElNRU9VVF9CT0RZKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5tZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpO1xuICAgICAgICAgIHRoaXMudXBncmFkZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSk7XG4gICAgICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDA7XG4gICAgICAgIGlmIChzaG91bGRLZWVwQWxpdmUgJiYgY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwyLnBhcnNlS2VlcEFsaXZlVGltZW91dCh0aGlzLmtlZXBBbGl2ZSkgOiBudWxsO1xuICAgICAgICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlTWF4VGltZW91dF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdXNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhdXNlID0gcmVxdWVzdDIub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBlcnIpO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdDIubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgICAgIGFzc2VydChzb2NrZXRba1Jlc2V0XSk7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlO1xuICAgICAgICAgIHJlc3VtZShjbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXVzZSA/IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQgOiAwO1xuICAgICAgfVxuICAgICAgb25Cb2R5KGJ1Zikge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBhc3NlcnQocmVxdWVzdDIpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9CT0RZKTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKTtcbiAgICAgICAgdGhpcy5ieXRlc1JlYWQgKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocmVxdWVzdDIub25EYXRhKGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBlcnIpO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25NZXNzYWdlQ29tcGxldGUoKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIHN0YXR1c0NvZGUsIHVwZ3JhZGUsIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGgsIGJ5dGVzUmVhZCwgc2hvdWxkS2VlcEFsaXZlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCAmJiAoIXN0YXR1c0NvZGUgfHwgc2hvdWxkS2VlcEFsaXZlKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBncmFkZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBhc3NlcnQocmVxdWVzdDIpO1xuICAgICAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmJ5dGVzUmVhZCA9IDA7XG4gICAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IFwiXCI7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlID0gXCJcIjtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gW107XG4gICAgICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdDIubWV0aG9kICE9PSBcIkhFQURcIiAmJiBjb250ZW50TGVuZ3RoICYmIGJ5dGVzUmVhZCAhPT0gcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcXVlc3QyLm9uQ29tcGxldGUoaGVhZGVycyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsO1xuICAgICAgICBpZiAoc29ja2V0W2tXcml0aW5nXSkge1xuICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjbGllbnRba1J1bm5pbmddLCAwKTtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcihcInJlc2V0XCIpKTtcbiAgICAgICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRDtcbiAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoXCJyZXNldFwiKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ja2V0W2tSZXNldF0gJiYgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCkge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKFwicmVzZXRcIikpO1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEO1xuICAgICAgICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gPT09IDEpIHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUocmVzdW1lLCBjbGllbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VtZShjbGllbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUGFyc2VyLCBcIlBhcnNlclwiKTtcbiAgICBmdW5jdGlvbiBvblBhcnNlclRpbWVvdXQocGFyc2VyKSB7XG4gICAgICBjb25zdCB7IHNvY2tldCwgdGltZW91dFR5cGUsIGNsaWVudCB9ID0gcGFyc2VyO1xuICAgICAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgaWYgKCFzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldC53cml0YWJsZU5lZWREcmFpbiB8fCBjbGllbnRba1J1bm5pbmddID4gMSkge1xuICAgICAgICAgIGFzc2VydCghcGFyc2VyLnBhdXNlZCwgXCJjYW5ub3QgYmUgcGF1c2VkIHdoaWxlIHdhaXRpbmcgZm9yIGhlYWRlcnNcIik7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBIZWFkZXJzVGltZW91dEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpIHtcbiAgICAgICAgaWYgKCFwYXJzZXIucGF1c2VkKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBCb2R5VGltZW91dEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDAgJiYgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdKTtcbiAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoXCJzb2NrZXQgaWRsZSB0aW1lb3V0XCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG9uUGFyc2VyVGltZW91dCwgXCJvblBhcnNlclRpbWVvdXRcIik7XG4gICAgZnVuY3Rpb24gb25Tb2NrZXRSZWFkYWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICBwYXJzZXIucmVhZE1vcmUoKTtcbiAgICB9XG4gICAgX19uYW1lKG9uU29ja2V0UmVhZGFibGUsIFwib25Tb2NrZXRSZWFkYWJsZVwiKTtcbiAgICBmdW5jdGlvbiBvblNvY2tldEVycm9yKGVycikge1xuICAgICAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpcztcbiAgICAgIGFzc2VydChlcnIuY29kZSAhPT0gXCJFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEXCIpO1xuICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OUkVTRVRcIiAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgICBwYXJzZXIuZmluaXNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXNba0Vycm9yXSA9IGVycjtcbiAgICAgIG9uRXJyb3IodGhpc1trQ2xpZW50XSwgZXJyKTtcbiAgICB9XG4gICAgX19uYW1lKG9uU29ja2V0RXJyb3IsIFwib25Tb2NrZXRFcnJvclwiKTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKGNsaWVudCwgZXJyKSB7XG4gICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBlcnIuY29kZSAhPT0gXCJVTkRfRVJSX0lORk9cIiAmJiBlcnIuY29kZSAhPT0gXCJVTkRfRVJSX1NPQ0tFVFwiKSB7XG4gICAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmdJZHhdID09PSBjbGllbnRba1J1bm5pbmdJZHhdKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0MiA9IHJlcXVlc3RzW2ldO1xuICAgICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChjbGllbnRba1NpemVdID09PSAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG9uRXJyb3IsIFwib25FcnJvclwiKTtcbiAgICBmdW5jdGlvbiBvblNvY2tldEVuZCgpIHtcbiAgICAgIGNvbnN0IHsgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICBpZiAocGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgICAgcGFyc2VyLmZpbmlzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1dGlsMi5kZXN0cm95KHRoaXMsIG5ldyBTb2NrZXRFcnJvcihcIm90aGVyIHNpZGUgY2xvc2VkXCIsIHV0aWwyLmdldFNvY2tldEluZm8odGhpcykpKTtcbiAgICB9XG4gICAgX19uYW1lKG9uU29ja2V0RW5kLCBcIm9uU29ja2V0RW5kXCIpO1xuICAgIGZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UoKSB7XG4gICAgICBjb25zdCB7IFtrQ2xpZW50XTogY2xpZW50IH0gPSB0aGlzO1xuICAgICAgdGhpc1trUGFyc2VyXS5kZXN0cm95KCk7XG4gICAgICB0aGlzW2tQYXJzZXJdID0gbnVsbDtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoXCJjbG9zZWRcIiwgdXRpbDIuZ2V0U29ja2V0SW5mbyh0aGlzKSk7XG4gICAgICBjbGllbnRba1NvY2tldF0gPSBudWxsO1xuICAgICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QyID0gcmVxdWVzdHNbaV07XG4gICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgZXJyLmNvZGUgIT09IFwiVU5EX0VSUl9JTkZPXCIpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXTtcbiAgICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGw7XG4gICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIpO1xuICAgICAgfVxuICAgICAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF07XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCk7XG4gICAgICBjbGllbnQuZW1pdChcImRpc2Nvbm5lY3RcIiwgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKTtcbiAgICAgIHJlc3VtZShjbGllbnQpO1xuICAgIH1cbiAgICBfX25hbWUob25Tb2NrZXRDbG9zZSwgXCJvblNvY2tldENsb3NlXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoY2xpZW50KSB7XG4gICAgICBhc3NlcnQoIWNsaWVudFtrQ29ubmVjdGluZ10pO1xuICAgICAgYXNzZXJ0KCFjbGllbnRba1NvY2tldF0pO1xuICAgICAgbGV0IHsgaG9zdCwgaG9zdG5hbWU6IGhvc3RuYW1lMywgcHJvdG9jb2wsIHBvcnQgfSA9IGNsaWVudFtrVXJsXTtcbiAgICAgIGlmIChob3N0bmFtZTNbMF0gPT09IFwiW1wiKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGhvc3RuYW1lMy5pbmRleE9mKFwiXVwiKTtcbiAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpO1xuICAgICAgICBjb25zdCBpcCA9IGhvc3RuYW1lMy5zdWJzdHIoMSwgaWR4IC0gMSk7XG4gICAgICAgIGFzc2VydChuZXQyLmlzSVAoaXApKTtcbiAgICAgICAgaG9zdG5hbWUzID0gaXA7XG4gICAgICB9XG4gICAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gdHJ1ZTtcbiAgICAgIGlmIChjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QucHVibGlzaCh7XG4gICAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiBob3N0bmFtZTMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiBob3N0bmFtZTMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdXG4gICAgICAgICAgfSwgKGVyciwgc29ja2V0MikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoc29ja2V0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgICAgICAgbGxodHRwSW5zdGFuY2UgPSBhd2FpdCBsbGh0dHBQcm9taXNlO1xuICAgICAgICAgIGxsaHR0cFByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0KHNvY2tldCk7XG4gICAgICAgIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldDtcbiAgICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZTtcbiAgICAgICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlO1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IGZhbHNlO1xuICAgICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlO1xuICAgICAgICBzb2NrZXRba0Vycm9yXSA9IG51bGw7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXSA9IG5ldyBQYXJzZXIoY2xpZW50LCBzb2NrZXQsIGxsaHR0cEluc3RhbmNlKTtcbiAgICAgICAgc29ja2V0W2tDbGllbnRdID0gY2xpZW50O1xuICAgICAgICBzb2NrZXRba0NvdW50ZXJdID0gMDtcbiAgICAgICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXTtcbiAgICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcikub24oXCJyZWFkYWJsZVwiLCBvblNvY2tldFJlYWRhYmxlKS5vbihcImVuZFwiLCBvblNvY2tldEVuZCkub24oXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZC5wdWJsaXNoKHtcbiAgICAgICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lMyxcbiAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudC5lbWl0KFwiY29ubmVjdFwiLCBjbGllbnRba1VybF0sIFtjbGllbnRdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5jb25uZWN0RXJyb3IucHVibGlzaCh7XG4gICAgICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICAgIGhvc3RuYW1lOiBob3N0bmFtZTMsXG4gICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSURcIikge1xuICAgICAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKTtcbiAgICAgICAgICB3aGlsZSAoY2xpZW50W2tQZW5kaW5nXSA+IDAgJiYgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV0uc2VydmVybmFtZSA9PT0gY2xpZW50W2tTZXJ2ZXJOYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdKytdO1xuICAgICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRXJyb3IoY2xpZW50LCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudC5lbWl0KFwiY29ubmVjdGlvbkVycm9yXCIsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycik7XG4gICAgICB9XG4gICAgICByZXN1bWUoY2xpZW50KTtcbiAgICB9XG4gICAgX19uYW1lKGNvbm5lY3QsIFwiY29ubmVjdFwiKTtcbiAgICBmdW5jdGlvbiBlbWl0RHJhaW4oY2xpZW50KSB7XG4gICAgICBjbGllbnRba05lZWREcmFpbl0gPSAwO1xuICAgICAgY2xpZW50LmVtaXQoXCJkcmFpblwiLCBjbGllbnRba1VybF0sIFtjbGllbnRdKTtcbiAgICB9XG4gICAgX19uYW1lKGVtaXREcmFpbiwgXCJlbWl0RHJhaW5cIik7XG4gICAgZnVuY3Rpb24gcmVzdW1lKGNsaWVudCwgc3luYykge1xuICAgICAgaWYgKGNsaWVudFtrUmVzdW1pbmddID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNsaWVudFtrUmVzdW1pbmddID0gMjtcbiAgICAgIF9yZXN1bWUoY2xpZW50LCBzeW5jKTtcbiAgICAgIGNsaWVudFtrUmVzdW1pbmddID0gMDtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmdJZHhdID4gMjU2KSB7XG4gICAgICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKTtcbiAgICAgICAgY2xpZW50W2tQZW5kaW5nSWR4XSAtPSBjbGllbnRba1J1bm5pbmdJZHhdO1xuICAgICAgICBjbGllbnRba1J1bm5pbmdJZHhdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlc3VtZSwgXCJyZXN1bWVcIik7XG4gICAgZnVuY3Rpb24gX3Jlc3VtZShjbGllbnQsIHN5bmMpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50LmNsb3NlZCAmJiAhY2xpZW50W2tTaXplXSkge1xuICAgICAgICAgIGNsaWVudC5kZXN0cm95KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XTtcbiAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICAgICAgICBzb2NrZXQudW5yZWYoKTtcbiAgICAgICAgICAgICAgc29ja2V0W2tOb1JlZl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgICAgICAgc29ja2V0LnJlZigpO1xuICAgICAgICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfSURMRSkge1xuICAgICAgICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfSURMRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QzID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV07XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNUaW1lb3V0ID0gcmVxdWVzdDMuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCA/IHJlcXVlc3QzLmhlYWRlcnNUaW1lb3V0IDogY2xpZW50W2tIZWFkZXJzVGltZW91dF07XG4gICAgICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS5zZXRUaW1lb3V0KGhlYWRlcnNUaW1lb3V0LCBUSU1FT1VUX0hFQURFUlMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50W2tCdXN5XSkge1xuICAgICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpZW50W2tOZWVkRHJhaW5dID09PSAyKSB7XG4gICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDE7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXREcmFpbiwgY2xpZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdERyYWluKGNsaWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID49IChjbGllbnRba1BpcGVsaW5pbmddIHx8IDEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QyID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV07XG4gICAgICAgIGlmIChjbGllbnRba1VybF0ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgJiYgY2xpZW50W2tTZXJ2ZXJOYW1lXSAhPT0gcmVxdWVzdDIuc2VydmVybmFtZSkge1xuICAgICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRba1NlcnZlck5hbWVdID0gcmVxdWVzdDIuc2VydmVybmFtZTtcbiAgICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5zZXJ2ZXJuYW1lICE9PSByZXF1ZXN0Mi5zZXJ2ZXJuYW1lKSB7XG4gICAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcihcInNlcnZlcm5hbWUgY2hhbmdlZFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba0Nvbm5lY3RpbmddKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgY29ubmVjdChjbGllbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuZGVzdHJveWVkIHx8IHNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmICFyZXF1ZXN0Mi5pZGVtcG90ZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdDIudXBncmFkZSB8fCByZXF1ZXN0Mi5tZXRob2QgPT09IFwiQ09OTkVDVFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbDIuaXNTdHJlYW0ocmVxdWVzdDIuYm9keSkgJiYgdXRpbDIuYm9keUxlbmd0aChyZXF1ZXN0Mi5ib2R5KSA9PT0gMCkge1xuICAgICAgICAgIHJlcXVlc3QyLmJvZHkub24oXCJkYXRhXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICB9KS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1dGlsMi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3QyLmJvZHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAodXRpbDIuaXNTdHJlYW0ocmVxdWVzdDIuYm9keSkgfHwgdXRpbDIuaXNBc3luY0l0ZXJhYmxlKHJlcXVlc3QyLmJvZHkpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcXVlc3QyLmFib3J0ZWQgJiYgd3JpdGUoY2xpZW50LCByZXF1ZXN0MikpIHtcbiAgICAgICAgICBjbGllbnRba1BlbmRpbmdJZHhdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUGVuZGluZ0lkeF0sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShfcmVzdW1lLCBcIl9yZXN1bWVcIik7XG4gICAgZnVuY3Rpb24gd3JpdGUoY2xpZW50LCByZXF1ZXN0Mikge1xuICAgICAgY29uc3QgeyBib2R5LCBtZXRob2QsIHBhdGg6IHBhdGg3LCBob3N0LCB1cGdyYWRlLCBoZWFkZXJzLCBibG9ja2luZyB9ID0gcmVxdWVzdDI7XG4gICAgICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IG1ldGhvZCA9PT0gXCJQVVRcIiB8fCBtZXRob2QgPT09IFwiUE9TVFwiIHx8IG1ldGhvZCA9PT0gXCJQQVRDSFwiO1xuICAgICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvZHkucmVhZCgwKTtcbiAgICAgIH1cbiAgICAgIGxldCBjb250ZW50TGVuZ3RoID0gdXRpbDIuYm9keUxlbmd0aChib2R5KTtcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0Mi5jb250ZW50TGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgJiYgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIGNvbnRlbnRMZW5ndGggPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLmNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgcmVxdWVzdDIuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF07XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0Mi5vbkNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5hYm9ydGVkIHx8IHJlcXVlc3QyLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0MiwgZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKFwiYWJvcnRlZFwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSBcIkNPTk5FQ1RcIikge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50W2tNYXhSZXF1ZXN0c10gJiYgc29ja2V0W2tDb3VudGVyXSsrID49IGNsaWVudFtrTWF4UmVxdWVzdHNdKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja2luZykge1xuICAgICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGg3fSBIVFRQLzEuMVxcclxuYDtcbiAgICAgIGlmICh0eXBlb2YgaG9zdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcbmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgKz0gY2xpZW50W2tIb3N0SGVhZGVyXTtcbiAgICAgIH1cbiAgICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIGhlYWRlciArPSBgY29ubmVjdGlvbjogdXBncmFkZVxcclxudXBncmFkZTogJHt1cGdyYWRlfVxcclxuYDtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgICBoZWFkZXIgKz0gXCJjb25uZWN0aW9uOiBrZWVwLWFsaXZlXFxyXFxuXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgKz0gXCJjb25uZWN0aW9uOiBjbG9zZVxcclxcblwiO1xuICAgICAgfVxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVyICs9IGhlYWRlcnM7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbHMuc2VuZEhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHJlcXVlc3QyLCBoZWFkZXJzOiBoZWFkZXIsIHNvY2tldCB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcblxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gbnVsbCwgXCJubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGhcIik7XG4gICAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdDIub25SZXF1ZXN0U2VudCgpO1xuICAgICAgfSBlbHNlIGlmICh1dGlsMi5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCBcImJ1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKTtcbiAgICAgICAgc29ja2V0LmNvcmsoKTtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxuXFxyXG5gLCBcImFzY2lpXCIpO1xuICAgICAgICBzb2NrZXQud3JpdGUoYm9keSk7XG4gICAgICAgIHNvY2tldC51bmNvcmsoKTtcbiAgICAgICAgcmVxdWVzdDIub25Cb2R5U2VudChib2R5KTtcbiAgICAgICAgcmVxdWVzdDIub25SZXF1ZXN0U2VudCgpO1xuICAgICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd3JpdGVJdGVyYWJsZSh7IGJvZHk6IGJvZHkuc3RyZWFtKCksIGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdDIsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2IoeyBib2R5LCBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgd3JpdGVTdHJlYW0oeyBib2R5LCBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSk7XG4gICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICAgICAgd3JpdGVJdGVyYWJsZSh7IGJvZHksIGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdDIsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKHdyaXRlLCBcIndyaXRlXCIpO1xuICAgIGZ1bmN0aW9uIHdyaXRlU3RyZWFtKHsgYm9keSwgY2xpZW50LCByZXF1ZXN0OiByZXF1ZXN0Miwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsIFwic3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtcbiAgICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pO1xuICAgICAgY29uc3Qgb25EYXRhID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFzc2VydCghZmluaXNoZWQpO1xuICAgICAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHRoaXMsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIFwib25EYXRhXCIpO1xuICAgICAgY29uc3Qgb25EcmFpbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGFzc2VydCghZmluaXNoZWQpO1xuICAgICAgICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICAgICAgICBib2R5LnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBcIm9uRHJhaW5cIik7XG4gICAgICBjb25zdCBvbkFib3J0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgb25GaW5pc2hlZChuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgIH0sIFwib25BYm9ydFwiKTtcbiAgICAgIGNvbnN0IG9uRmluaXNoZWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBhc3NlcnQoc29ja2V0LmRlc3Ryb3llZCB8fCBzb2NrZXRba1dyaXRpbmddICYmIGNsaWVudFtrUnVubmluZ10gPD0gMSk7XG4gICAgICAgIHNvY2tldC5vZmYoXCJkcmFpblwiLCBvbkRyYWluKS5vZmYoXCJlcnJvclwiLCBvbkZpbmlzaGVkKTtcbiAgICAgICAgYm9keS5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25EYXRhKS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbkZpbmlzaGVkKS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRmluaXNoZWQpLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25BYm9ydCk7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdyaXRlci5lbmQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgZXJyID0gZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5kZXN0cm95KGVycik7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlICE9PSBcIlVORF9FUlJfSU5GT1wiIHx8IGVyci5tZXNzYWdlICE9PSBcInJlc2V0XCIpKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShib2R5LCBlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFwib25GaW5pc2hlZFwiKTtcbiAgICAgIGJvZHkub24oXCJkYXRhXCIsIG9uRGF0YSkub24oXCJlbmRcIiwgb25GaW5pc2hlZCkub24oXCJlcnJvclwiLCBvbkZpbmlzaGVkKS5vbihcImNsb3NlXCIsIG9uQWJvcnQpO1xuICAgICAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgICAgIGJvZHkucmVzdW1lKCk7XG4gICAgICB9XG4gICAgICBzb2NrZXQub24oXCJkcmFpblwiLCBvbkRyYWluKS5vbihcImVycm9yXCIsIG9uRmluaXNoZWQpO1xuICAgIH1cbiAgICBfX25hbWUod3JpdGVTdHJlYW0sIFwid3JpdGVTdHJlYW1cIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iKHsgYm9keSwgY2xpZW50LCByZXF1ZXN0OiByZXF1ZXN0Miwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LnNpemUsIFwiYmxvYiBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSk7XG4gICAgICAgIHNvY2tldC5jb3JrKCk7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcblxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlcik7XG4gICAgICAgIHNvY2tldC51bmNvcmsoKTtcbiAgICAgICAgcmVxdWVzdDIub25Cb2R5U2VudChidWZmZXIpO1xuICAgICAgICByZXF1ZXN0Mi5vblJlcXVlc3RTZW50KCk7XG4gICAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdW1lKGNsaWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh3cml0ZUJsb2IsIFwid3JpdGVCbG9iXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUoeyBib2R5LCBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgXCJpdGVyYXRvciBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWRcIik7XG4gICAgICBsZXQgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgZnVuY3Rpb24gb25EcmFpbigpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKG9uRHJhaW4sIFwib25EcmFpblwiKTtcbiAgICAgIGNvbnN0IHdhaXRGb3JEcmFpbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpO1xuICAgICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgICByZWplY3Qoc29ja2V0W2tFcnJvcl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgfSksIFwid2FpdEZvckRyYWluXCIpO1xuICAgICAgc29ja2V0Lm9uKFwiY2xvc2VcIiwgb25EcmFpbikub24oXCJkcmFpblwiLCBvbkRyYWluKTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IHNvY2tldCwgcmVxdWVzdDogcmVxdWVzdDIsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5lbmQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB3cml0ZXIuZGVzdHJveShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc29ja2V0Lm9mZihcImNsb3NlXCIsIG9uRHJhaW4pLm9mZihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUod3JpdGVJdGVyYWJsZSwgXCJ3cml0ZUl0ZXJhYmxlXCIpO1xuICAgIHZhciBBc3luY1dyaXRlciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHsgc29ja2V0LCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBjb250ZW50TGVuZ3RoO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgICAgICB0aGlzLmV4cGVjdHNQYXlsb2FkID0gZXhwZWN0c1BheWxvYWQ7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICBzb2NrZXRba1dyaXRpbmddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHsgc29ja2V0LCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gKyBsZW4gPiBjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXG5gLCBcImFzY2lpXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXG5cXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKGBcXHJcbiR7bGVuLnRvU3RyaW5nKDE2KX1cXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gbGVuO1xuICAgICAgICBjb25zdCByZXQgPSBzb2NrZXQud3JpdGUoY2h1bmspO1xuICAgICAgICByZXF1ZXN0Mi5vbkJvZHlTZW50KGNodW5rKTtcbiAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGVuZCgpIHtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgYnl0ZXNXcml0dGVuLCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyLCByZXF1ZXN0OiByZXF1ZXN0MiB9ID0gdGhpcztcbiAgICAgICAgcmVxdWVzdDIub25SZXF1ZXN0U2VudCgpO1xuICAgICAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2U7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgICAgICBpZiAoZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcblxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoXCJcXHJcXG4wXFxyXFxuXFxyXFxuXCIsIFwiYXNjaWlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bWUoY2xpZW50KTtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQgfSA9IHRoaXM7XG4gICAgICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddIDw9IDEsIFwicGlwZWxpbmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGlzIHJlcXVlc3RcIik7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShBc3luY1dyaXRlciwgXCJBc3luY1dyaXRlclwiKTtcbiAgICBmdW5jdGlvbiBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0MiwgZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0Mi5vbkVycm9yKGVycik7XG4gICAgICAgIGFzc2VydChyZXF1ZXN0Mi5hYm9ydGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgY2xpZW50LmVtaXQoXCJlcnJvclwiLCBlcnIyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGVycm9yUmVxdWVzdCwgXCJlcnJvclJlcXVlc3RcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQ2xpZW50O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbm9kZS9maXhlZC1xdWV1ZS5qc1xudmFyIHJlcXVpcmVfZml4ZWRfcXVldWUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9ub2RlL2ZpeGVkLXF1ZXVlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBrU2l6ZSA9IDIwNDg7XG4gICAgdmFyIGtNYXNrID0ga1NpemUgLSAxO1xuICAgIHZhciBGaXhlZENpcmN1bGFyQnVmZmVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYm90dG9tID0gMDtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgQXJyYXkoa1NpemUpO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSB0aGlzLmJvdHRvbTtcbiAgICAgIH1cbiAgICAgIGlzRnVsbCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRvcCArIDEgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tO1xuICAgICAgfVxuICAgICAgcHVzaChkYXRhKSB7XG4gICAgICAgIHRoaXMubGlzdFt0aGlzLnRvcF0gPSBkYXRhO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wICsgMSAmIGtNYXNrO1xuICAgICAgfVxuICAgICAgc2hpZnQoKSB7XG4gICAgICAgIGNvbnN0IG5leHRJdGVtID0gdGhpcy5saXN0W3RoaXMuYm90dG9tXTtcbiAgICAgICAgaWYgKG5leHRJdGVtID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMubGlzdFt0aGlzLmJvdHRvbV0gPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5ib3R0b20gKyAxICYga01hc2s7XG4gICAgICAgIHJldHVybiBuZXh0SXRlbTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShGaXhlZENpcmN1bGFyQnVmZmVyLCBcIkZpeGVkQ2lyY3VsYXJCdWZmZXJcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShjbGFzcyBGaXhlZFF1ZXVlIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgICAgfVxuICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0ID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWQucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHNoaWZ0KCkge1xuICAgICAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsO1xuICAgICAgICBjb25zdCBuZXh0ID0gdGFpbC5zaGlmdCgpO1xuICAgICAgICBpZiAodGFpbC5pc0VtcHR5KCkgJiYgdGFpbC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy50YWlsID0gdGFpbC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgIH0sIFwiRml4ZWRRdWV1ZVwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wtc3RhdHMuanNcbnZhciByZXF1aXJlX3Bvb2xfc3RhdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLXN0YXRzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciB7IGtGcmVlLCBrQ29ubmVjdGVkLCBrUGVuZGluZywga1F1ZXVlZCwga1J1bm5pbmcsIGtTaXplIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIga1Bvb2wgPSBTeW1ib2woXCJwb29sXCIpO1xuICAgIHZhciBQb29sU3RhdHMgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihwb29sKSB7XG4gICAgICAgIHRoaXNba1Bvb2xdID0gcG9vbDtcbiAgICAgIH1cbiAgICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQb29sXVtrQ29ubmVjdGVkXTtcbiAgICAgIH1cbiAgICAgIGdldCBmcmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trUG9vbF1ba0ZyZWVdO1xuICAgICAgfVxuICAgICAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQb29sXVtrUGVuZGluZ107XG4gICAgICB9XG4gICAgICBnZXQgcXVldWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trUG9vbF1ba1F1ZXVlZF07XG4gICAgICB9XG4gICAgICBnZXQgcnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tSdW5uaW5nXTtcbiAgICAgIH1cbiAgICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trUG9vbF1ba1NpemVdO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFBvb2xTdGF0cywgXCJQb29sU3RhdHNcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUG9vbFN0YXRzO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1iYXNlLmpzXG52YXIgcmVxdWlyZV9wb29sX2Jhc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLWJhc2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZV9kaXNwYXRjaGVyX2Jhc2UoKTtcbiAgICB2YXIgRml4ZWRRdWV1ZSA9IHJlcXVpcmVfZml4ZWRfcXVldWUoKTtcbiAgICB2YXIgeyBrQ29ubmVjdGVkLCBrU2l6ZSwga1J1bm5pbmcsIGtQZW5kaW5nLCBrUXVldWVkLCBrQnVzeSwga0ZyZWUsIGtVcmwsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIFBvb2xTdGF0cyA9IHJlcXVpcmVfcG9vbF9zdGF0cygpO1xuICAgIHZhciBrQ2xpZW50cyA9IFN5bWJvbChcImNsaWVudHNcIik7XG4gICAgdmFyIGtOZWVkRHJhaW4gPSBTeW1ib2woXCJuZWVkRHJhaW5cIik7XG4gICAgdmFyIGtRdWV1ZSA9IFN5bWJvbChcInF1ZXVlXCIpO1xuICAgIHZhciBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbChcImNsb3NlZCByZXNvbHZlXCIpO1xuICAgIHZhciBrT25EcmFpbiA9IFN5bWJvbChcIm9uRHJhaW5cIik7XG4gICAgdmFyIGtPbkNvbm5lY3QgPSBTeW1ib2woXCJvbkNvbm5lY3RcIik7XG4gICAgdmFyIGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woXCJvbkRpc2Nvbm5lY3RcIik7XG4gICAgdmFyIGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbChcIm9uQ29ubmVjdGlvbkVycm9yXCIpO1xuICAgIHZhciBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbChcImdldCBkaXNwYXRjaGVyXCIpO1xuICAgIHZhciBrQWRkQ2xpZW50ID0gU3ltYm9sKFwiYWRkIGNsaWVudFwiKTtcbiAgICB2YXIga1JlbW92ZUNsaWVudCA9IFN5bWJvbChcInJlbW92ZSBjbGllbnRcIik7XG4gICAgdmFyIGtTdGF0cyA9IFN5bWJvbChcInN0YXRzXCIpO1xuICAgIHZhciBQb29sQmFzZSA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXNba1F1ZXVlXSA9IG5ldyBGaXhlZFF1ZXVlKCk7XG4gICAgICAgIHRoaXNba0NsaWVudHNdID0gW107XG4gICAgICAgIHRoaXNba1F1ZXVlZF0gPSAwO1xuICAgICAgICBjb25zdCBwb29sID0gdGhpcztcbiAgICAgICAgdGhpc1trT25EcmFpbl0gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIG9uRHJhaW4ob3JpZ2luLCB0YXJnZXRzKSB7XG4gICAgICAgICAgY29uc3QgcXVldWUgPSBwb29sW2tRdWV1ZV07XG4gICAgICAgICAgbGV0IG5lZWREcmFpbiA9IGZhbHNlO1xuICAgICAgICAgIHdoaWxlICghbmVlZERyYWluKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvb2xba1F1ZXVlZF0tLTtcbiAgICAgICAgICAgIG5lZWREcmFpbiA9ICF0aGlzLmRpc3BhdGNoKGl0ZW0ub3B0cywgaXRlbS5oYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1trTmVlZERyYWluXSA9IG5lZWREcmFpbjtcbiAgICAgICAgICBpZiAoIXRoaXNba05lZWREcmFpbl0gJiYgcG9vbFtrTmVlZERyYWluXSkge1xuICAgICAgICAgICAgcG9vbFtrTmVlZERyYWluXSA9IGZhbHNlO1xuICAgICAgICAgICAgcG9vbC5lbWl0KFwiZHJhaW5cIiwgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9vbFtrQ2xvc2VkUmVzb2x2ZV0gJiYgcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChwb29sW2tDbGllbnRzXS5tYXAoKGMpID0+IGMuY2xvc2UoKSkpLnRoZW4ocG9vbFtrQ2xvc2VkUmVzb2x2ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJvbkRyYWluXCIpO1xuICAgICAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgIHBvb2wuZW1pdChcImNvbm5lY3RcIiwgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICAgICAgcG9vbC5lbWl0KFwiZGlzY29ubmVjdFwiLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICAgICAgcG9vbC5lbWl0KFwiY29ubmVjdGlvbkVycm9yXCIsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tTdGF0c10gPSBuZXcgUG9vbFN0YXRzKHRoaXMpO1xuICAgICAgfVxuICAgICAgZ2V0IFtrQnVzeV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tOZWVkRHJhaW5dO1xuICAgICAgfVxuICAgICAgZ2V0IFtrQ29ubmVjdGVkXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcigoY2xpZW50KSA9PiBjbGllbnRba0Nvbm5lY3RlZF0pLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGdldCBba0ZyZWVdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKChjbGllbnQpID0+IGNsaWVudFtrQ29ubmVjdGVkXSAmJiAhY2xpZW50W2tOZWVkRHJhaW5dKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBnZXQgW2tQZW5kaW5nXSgpIHtcbiAgICAgICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF07XG4gICAgICAgIGZvciAoY29uc3QgeyBba1BlbmRpbmddOiBwZW5kaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgICAgICByZXQgKz0gcGVuZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgZ2V0IFtrUnVubmluZ10oKSB7XG4gICAgICAgIGxldCByZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgW2tSdW5uaW5nXTogcnVubmluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICAgICAgcmV0ICs9IHJ1bm5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGdldCBba1NpemVdKCkge1xuICAgICAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXTtcbiAgICAgICAgZm9yIChjb25zdCB7IFtrU2l6ZV06IHNpemUgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgICAgIHJldCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0c107XG4gICAgICB9XG4gICAgICBhc3luYyBba0Nsb3NlXSgpIHtcbiAgICAgICAgaWYgKHRoaXNba1F1ZXVlXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKChjKSA9PiBjLmNsb3NlKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXN5bmMgW2tEZXN0cm95XShlcnIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1trUXVldWVdLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS5oYW5kbGVyLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKChjKSA9PiBjLmRlc3Ryb3koZXJyKSkpO1xuICAgICAgfVxuICAgICAgW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trR2V0RGlzcGF0Y2hlcl0oKTtcbiAgICAgICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWU7XG4gICAgICAgICAgdGhpc1trUXVldWVdLnB1c2goeyBvcHRzLCBoYW5kbGVyIH0pO1xuICAgICAgICAgIHRoaXNba1F1ZXVlZF0rKztcbiAgICAgICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgICAgIGRpc3BhdGNoZXJba05lZWREcmFpbl0gPSB0cnVlO1xuICAgICAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXNba05lZWREcmFpbl07XG4gICAgICB9XG4gICAgICBba0FkZENsaWVudF0oY2xpZW50KSB7XG4gICAgICAgIGNsaWVudC5vbihcImRyYWluXCIsIHRoaXNba09uRHJhaW5dKS5vbihcImNvbm5lY3RcIiwgdGhpc1trT25Db25uZWN0XSkub24oXCJkaXNjb25uZWN0XCIsIHRoaXNba09uRGlzY29ubmVjdF0pLm9uKFwiY29ubmVjdGlvbkVycm9yXCIsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSk7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLnB1c2goY2xpZW50KTtcbiAgICAgICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgICAgIHRoaXNba09uRHJhaW5dKGNsaWVudFtrVXJsXSwgW3RoaXMsIGNsaWVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgW2tSZW1vdmVDbGllbnRdKGNsaWVudCkge1xuICAgICAgICBjbGllbnQuY2xvc2UoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXNba0NsaWVudHNdLmluZGV4T2YoY2xpZW50KTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRoaXNba0NsaWVudHNdLnNvbWUoKGRpc3BhdGNoZXIpID0+ICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShQb29sQmFzZSwgXCJQb29sQmFzZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBQb29sQmFzZSxcbiAgICAgIGtDbGllbnRzLFxuICAgICAga05lZWREcmFpbixcbiAgICAgIGtBZGRDbGllbnQsXG4gICAgICBrUmVtb3ZlQ2xpZW50LFxuICAgICAga0dldERpc3BhdGNoZXJcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qc1xudmFyIHJlcXVpcmVfcG9vbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHtcbiAgICAgIFBvb2xCYXNlLFxuICAgICAga0NsaWVudHMsXG4gICAgICBrTmVlZERyYWluLFxuICAgICAga0FkZENsaWVudCxcbiAgICAgIGtHZXREaXNwYXRjaGVyXG4gICAgfSA9IHJlcXVpcmVfcG9vbF9iYXNlKCk7XG4gICAgdmFyIENsaWVudCA9IHJlcXVpcmVfY2xpZW50KCk7XG4gICAgdmFyIHtcbiAgICAgIEludmFsaWRBcmd1bWVudEVycm9yXG4gICAgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IGtVcmwgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBidWlsZENvbm5lY3RvciA9IHJlcXVpcmVfY29ubmVjdCgpO1xuICAgIHZhciBrT3B0aW9ucyA9IFN5bWJvbChcIm9wdGlvbnNcIik7XG4gICAgdmFyIGtDb25uZWN0aW9ucyA9IFN5bWJvbChcImNvbm5lY3Rpb25zXCIpO1xuICAgIHZhciBrRmFjdG9yeSA9IFN5bWJvbChcImZhY3RvcnlcIik7XG4gICAgZnVuY3Rpb24gZGVmYXVsdEZhY3Rvcnkob3JpZ2luLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpO1xuICAgIH1cbiAgICBfX25hbWUoZGVmYXVsdEZhY3RvcnksIFwiZGVmYXVsdEZhY3RvcnlcIik7XG4gICAgdmFyIFBvb2wgPSBjbGFzcyBleHRlbmRzIFBvb2xCYXNlIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwge1xuICAgICAgICBjb25uZWN0aW9ucyxcbiAgICAgICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgICAgICBjb25uZWN0LFxuICAgICAgICBjb25uZWN0VGltZW91dCxcbiAgICAgICAgdGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNvbm5lY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4udGxzLFxuICAgICAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQgPT0gbnVsbCA/IDFlNCA6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAgICAgLi4uY29ubmVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGw7XG4gICAgICAgIHRoaXNba1VybF0gPSB1dGlsMi5wYXJzZU9yaWdpbihvcmlnaW4pO1xuICAgICAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbDIuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0IH07XG4gICAgICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeTtcbiAgICAgIH1cbiAgICAgIFtrR2V0RGlzcGF0Y2hlcl0oKSB7XG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZCgoZGlzcGF0Y2hlcjIpID0+ICFkaXNwYXRjaGVyMltrTmVlZERyYWluXSk7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzW2tDb25uZWN0aW9uc10gfHwgdGhpc1trQ2xpZW50c10ubGVuZ3RoIDwgdGhpc1trQ29ubmVjdGlvbnNdKSB7XG4gICAgICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKTtcbiAgICAgICAgICB0aGlzW2tBZGRDbGllbnRdKGRpc3BhdGNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFBvb2wsIFwiUG9vbFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBQb29sO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qc1xudmFyIHJlcXVpcmVfYmFsYW5jZWRfcG9vbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2JhbGFuY2VkLXBvb2wuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHtcbiAgICAgIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yLFxuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIge1xuICAgICAgUG9vbEJhc2UsXG4gICAgICBrQ2xpZW50cyxcbiAgICAgIGtOZWVkRHJhaW4sXG4gICAgICBrQWRkQ2xpZW50LFxuICAgICAga1JlbW92ZUNsaWVudCxcbiAgICAgIGtHZXREaXNwYXRjaGVyXG4gICAgfSA9IHJlcXVpcmVfcG9vbF9iYXNlKCk7XG4gICAgdmFyIFBvb2wgPSByZXF1aXJlX3Bvb2woKTtcbiAgICB2YXIgeyBrVXJsIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgeyBwYXJzZU9yaWdpbiB9ID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciBrRmFjdG9yeSA9IFN5bWJvbChcImZhY3RvcnlcIik7XG4gICAgdmFyIGtPcHRpb25zID0gU3ltYm9sKFwib3B0aW9uc1wiKTtcbiAgICB2YXIga0dyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IFN5bWJvbChcImtHcmVhdGVzdENvbW1vbkRpdmlzb3JcIik7XG4gICAgdmFyIGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKFwia0N1cnJlbnRXZWlnaHRcIik7XG4gICAgdmFyIGtJbmRleCA9IFN5bWJvbChcImtJbmRleFwiKTtcbiAgICB2YXIga1dlaWdodCA9IFN5bWJvbChcImtXZWlnaHRcIik7XG4gICAgdmFyIGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woXCJrTWF4V2VpZ2h0UGVyU2VydmVyXCIpO1xuICAgIHZhciBrRXJyb3JQZW5hbHR5ID0gU3ltYm9sKFwia0Vycm9yUGVuYWx0eVwiKTtcbiAgICBmdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IoYSwgYikge1xuICAgICAgaWYgKGIgPT09IDApXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgcmV0dXJuIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYik7XG4gICAgfVxuICAgIF9fbmFtZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIFwiZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yXCIpO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5KG9yaWdpbiwgb3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cyk7XG4gICAgfVxuICAgIF9fbmFtZShkZWZhdWx0RmFjdG9yeSwgXCJkZWZhdWx0RmFjdG9yeVwiKTtcbiAgICB2YXIgQmFsYW5jZWRQb29sID0gY2xhc3MgZXh0ZW5kcyBQb29sQmFzZSB7XG4gICAgICBjb25zdHJ1Y3Rvcih1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXNba09wdGlvbnNdID0gb3B0cztcbiAgICAgICAgdGhpc1trSW5kZXhdID0gLTE7XG4gICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gMDtcbiAgICAgICAgdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSA9IHRoaXNba09wdGlvbnNdLm1heFdlaWdodFBlclNlcnZlciB8fCAxMDA7XG4gICAgICAgIHRoaXNba0Vycm9yUGVuYWx0eV0gPSB0aGlzW2tPcHRpb25zXS5lcnJvclBlbmFsdHkgfHwgMTU7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh1cHN0cmVhbXMpKSB7XG4gICAgICAgICAgdXBzdHJlYW1zID0gW3Vwc3RyZWFtc107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5O1xuICAgICAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgICAgIHRoaXMuYWRkVXBzdHJlYW0odXBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKCk7XG4gICAgICB9XG4gICAgICBhZGRVcHN0cmVhbSh1cHN0cmVhbSkge1xuICAgICAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW47XG4gICAgICAgIGlmICh0aGlzW2tDbGllbnRzXS5maW5kKChwb29sMikgPT4gcG9vbDJba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJiBwb29sMi5jbG9zZWQgIT09IHRydWUgJiYgcG9vbDIuZGVzdHJveWVkICE9PSB0cnVlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tGYWN0b3J5XSh1cHN0cmVhbU9yaWdpbiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpc1trT3B0aW9uc10pKTtcbiAgICAgICAgdGhpc1trQWRkQ2xpZW50XShwb29sKTtcbiAgICAgICAgcG9vbC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb29sLm9uKFwiY29ubmVjdGlvbkVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5tYXgoMSwgcG9vbFtrV2VpZ2h0XSAtIHRoaXNba0Vycm9yUGVuYWx0eV0pO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb29sLm9uKFwiZGlzY29ubmVjdFwiLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl07XG4gICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gXCJVTkRfRVJSX1NPQ0tFVFwiKSB7XG4gICAgICAgICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5tYXgoMSwgcG9vbFtrV2VpZ2h0XSAtIHRoaXNba0Vycm9yUGVuYWx0eV0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgICAgIGNsaWVudFtrV2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKSB7XG4gICAgICAgIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl0gPSB0aGlzW2tDbGllbnRzXS5tYXAoKHApID0+IHBba1dlaWdodF0pLnJlZHVjZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIDApO1xuICAgICAgfVxuICAgICAgcmVtb3ZlVXBzdHJlYW0odXBzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luO1xuICAgICAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c10uZmluZCgocG9vbDIpID0+IHBvb2wyW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiYgcG9vbDIuY2xvc2VkICE9PSB0cnVlICYmIHBvb2wyLmRlc3Ryb3llZCAhPT0gdHJ1ZSk7XG4gICAgICAgIGlmIChwb29sKSB7XG4gICAgICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGdldCB1cHN0cmVhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoKGRpc3BhdGNoZXIpID0+IGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlKS5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKTtcbiAgICAgIH1cbiAgICAgIFtrR2V0RGlzcGF0Y2hlcl0oKSB7XG4gICAgICAgIGlmICh0aGlzW2tDbGllbnRzXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZCgoZGlzcGF0Y2hlcjIpID0+ICFkaXNwYXRjaGVyMltrTmVlZERyYWluXSAmJiBkaXNwYXRjaGVyMi5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlcjIuZGVzdHJveWVkICE9PSB0cnVlKTtcbiAgICAgICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKChwb29sKSA9PiBwb29sW2tOZWVkRHJhaW5dKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSk7XG4gICAgICAgIGlmIChhbGxDbGllbnRzQnVzeSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGxldCBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0NsaWVudHNdLmZpbmRJbmRleCgocG9vbCkgPT4gIXBvb2xba05lZWREcmFpbl0pO1xuICAgICAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpc1trSW5kZXhdID0gKHRoaXNba0luZGV4XSArIDEpICUgdGhpc1trQ2xpZW50c10ubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dO1xuICAgICAgICAgIGlmIChwb29sW2tXZWlnaHRdID4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgICBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl07XG4gICAgICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb29sW2tXZWlnaHRdID49IHRoaXNba0N1cnJlbnRXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9vbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF07XG4gICAgICAgIHRoaXNba0luZGV4XSA9IG1heFdlaWdodEluZGV4O1xuICAgICAgICByZXR1cm4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEJhbGFuY2VkUG9vbCwgXCJCYWxhbmNlZFBvb2xcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQmFsYW5jZWRQb29sO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZi5qc1xudmFyIHJlcXVpcmVfZGlzcGF0Y2hlcl93ZWFrcmVmID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBrQ29ubmVjdGVkLCBrU2l6ZSB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIENvbXBhdFdlYWtSZWYgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBkZXJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVba0Nvbm5lY3RlZF0gPT09IDAgJiYgdGhpcy52YWx1ZVtrU2l6ZV0gPT09IDAgPyB2b2lkIDAgOiB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENvbXBhdFdlYWtSZWYsIFwiQ29tcGF0V2Vha1JlZlwiKTtcbiAgICB2YXIgQ29tcGF0RmluYWxpemVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoZmluYWxpemVyKSB7XG4gICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXIoZGlzcGF0Y2hlciwga2V5KSB7XG4gICAgICAgIGRpc3BhdGNoZXIub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2hlcltrQ29ubmVjdGVkXSA9PT0gMCAmJiBkaXNwYXRjaGVyW2tTaXplXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZXIoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENvbXBhdEZpbmFsaXplciwgXCJDb21wYXRGaW5hbGl6ZXJcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBXZWFrUmVmOiBnbG9iYWwuV2Vha1JlZiB8fCBDb21wYXRXZWFrUmVmLFxuICAgICAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5IHx8IENvbXBhdEZpbmFsaXplclxuICAgICAgfTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYWdlbnQuanNcbnZhciByZXF1aXJlX2FnZW50ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYWdlbnQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsga0NsaWVudHMsIGtSdW5uaW5nLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmVfZGlzcGF0Y2hlcl9iYXNlKCk7XG4gICAgdmFyIFBvb2wgPSByZXF1aXJlX3Bvb2woKTtcbiAgICB2YXIgQ2xpZW50ID0gcmVxdWlyZV9jbGllbnQoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmVfcmVkaXJlY3QoKTtcbiAgICB2YXIgeyBXZWFrUmVmOiBXZWFrUmVmMiwgRmluYWxpemF0aW9uUmVnaXN0cnkgfSA9IHJlcXVpcmVfZGlzcGF0Y2hlcl93ZWFrcmVmKCkoKTtcbiAgICB2YXIga09uQ29ubmVjdCA9IFN5bWJvbChcIm9uQ29ubmVjdFwiKTtcbiAgICB2YXIga09uRGlzY29ubmVjdCA9IFN5bWJvbChcIm9uRGlzY29ubmVjdFwiKTtcbiAgICB2YXIga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKFwib25Db25uZWN0aW9uRXJyb3JcIik7XG4gICAgdmFyIGtNYXhSZWRpcmVjdGlvbnMgPSBTeW1ib2woXCJtYXhSZWRpcmVjdGlvbnNcIik7XG4gICAgdmFyIGtPbkRyYWluID0gU3ltYm9sKFwib25EcmFpblwiKTtcbiAgICB2YXIga0ZhY3RvcnkgPSBTeW1ib2woXCJmYWN0b3J5XCIpO1xuICAgIHZhciBrRmluYWxpemVyID0gU3ltYm9sKFwiZmluYWxpemVyXCIpO1xuICAgIHZhciBrT3B0aW9ucyA9IFN5bWJvbChcIm9wdGlvbnNcIik7XG4gICAgZnVuY3Rpb24gZGVmYXVsdEZhY3Rvcnkob3JpZ2luLCBvcHRzKSB7XG4gICAgICByZXR1cm4gb3B0cyAmJiBvcHRzLmNvbm5lY3Rpb25zID09PSAxID8gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpIDogbmV3IFBvb2wob3JpZ2luLCBvcHRzKTtcbiAgICB9XG4gICAgX19uYW1lKGRlZmF1bHRGYWN0b3J5LCBcImRlZmF1bHRGYWN0b3J5XCIpO1xuICAgIHZhciBBZ2VudCA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAgICAgY29uc3RydWN0b3IoeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIG1heFJlZGlyZWN0aW9ucyA9IDAsIGNvbm5lY3QsIC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29ubmVjdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImNvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbDIuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0IH07XG4gICAgICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnM7XG4gICAgICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeTtcbiAgICAgICAgdGhpc1trQ2xpZW50c10gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzW2tGaW5hbGl6ZXJdID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAocmVmICE9PSB2b2lkIDAgJiYgcmVmLmRlcmVmKCkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpc1trQ2xpZW50c10uZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWdlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzW2tPbkRyYWluXSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgICAgICBhZ2VudC5lbWl0KFwiZHJhaW5cIiwgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgICAgICBhZ2VudC5lbWl0KFwiY29ubmVjdFwiLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICAgICAgYWdlbnQuZW1pdChcImRpc2Nvbm5lY3RcIiwgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdLCBlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgICAgICBhZ2VudC5lbWl0KFwiY29ubmVjdGlvbkVycm9yXCIsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSwgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGdldCBba1J1bm5pbmddKCkge1xuICAgICAgICBsZXQgcmV0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKTtcbiAgICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICByZXQgKz0gY2xpZW50W2tSdW5uaW5nXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIFtrRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKG9wdHMub3JpZ2luICYmICh0eXBlb2Ygb3B0cy5vcmlnaW4gPT09IFwic3RyaW5nXCIgfHwgb3B0cy5vcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgICAga2V5ID0gU3RyaW5nKG9wdHMub3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJvcHRzLm9yaWdpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBVUkwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpO1xuICAgICAgICBsZXQgZGlzcGF0Y2hlciA9IHJlZiA/IHJlZi5kZXJlZigpIDogbnVsbDtcbiAgICAgICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9wdHMub3JpZ2luLCB0aGlzW2tPcHRpb25zXSkub24oXCJkcmFpblwiLCB0aGlzW2tPbkRyYWluXSkub24oXCJjb25uZWN0XCIsIHRoaXNba09uQ29ubmVjdF0pLm9uKFwiZGlzY29ubmVjdFwiLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKS5vbihcImNvbm5lY3Rpb25FcnJvclwiLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pO1xuICAgICAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIG5ldyBXZWFrUmVmMihkaXNwYXRjaGVyKSk7XG4gICAgICAgICAgdGhpc1trRmluYWxpemVyXS5yZWdpc3RlcihkaXNwYXRjaGVyLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gdGhpc1trTWF4UmVkaXJlY3Rpb25zXSB9ID0gb3B0cztcbiAgICAgICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmIG1heFJlZGlyZWN0aW9ucyAhPT0gMCkge1xuICAgICAgICAgIG9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9O1xuICAgICAgICAgIGhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKHRoaXMsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcik7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Nsb3NlXSgpIHtcbiAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpO1xuICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIGNsb3NlUHJvbWlzZXMucHVzaChjbGllbnQuY2xvc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNsb3NlUHJvbWlzZXMpO1xuICAgICAgfVxuICAgICAgYXN5bmMgW2tEZXN0cm95XShlcnIpIHtcbiAgICAgICAgY29uc3QgZGVzdHJveVByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goY2xpZW50LmRlc3Ryb3koZXJyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQWdlbnQsIFwiQWdlbnRcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQWdlbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanNcbnZhciByZXF1aXJlX3JlYWRhYmxlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7IFJlcXVlc3RBYm9ydGVkRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBSZWFkYWJsZVN0cmVhbUZyb20sIHRvVVNWU3RyaW5nIH0gPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIEJsb2I7XG4gICAgdmFyIGtDb25zdW1lID0gU3ltYm9sKFwia0NvbnN1bWVcIik7XG4gICAgdmFyIGtSZWFkaW5nID0gU3ltYm9sKFwia1JlYWRpbmdcIik7XG4gICAgdmFyIGtCb2R5ID0gU3ltYm9sKFwia0JvZHlcIik7XG4gICAgdmFyIGtBYm9ydCA9IFN5bWJvbChcImFib3J0XCIpO1xuICAgIHZhciBrQ29udGVudFR5cGUgPSBTeW1ib2woXCJrQ29udGVudFR5cGVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShjbGFzcyBCb2R5UmVhZGFibGUgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gICAgICBjb25zdHJ1Y3RvcihyZXN1bWUsIGFib3J0LCBjb250ZW50VHlwZSA9IFwiXCIpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgICAgIHJlYWQ6IHJlc3VtZSxcbiAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpc1trQWJvcnRdID0gYWJvcnQ7XG4gICAgICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbDtcbiAgICAgICAgdGhpc1trQm9keV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tDb250ZW50VHlwZV0gPSBjb250ZW50VHlwZTtcbiAgICAgICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzW2tBYm9ydF0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZGVzdHJveShlcnIpO1xuICAgICAgfVxuICAgICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXYgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgICBvbihldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXYgPT09IFwiZGF0YVwiIHx8IGV2ID09PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgICAgICB0aGlzW2tSZWFkaW5nXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2LCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGFkZExpc3RlbmVyKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2LCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIG9mZihldiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZXYgPT09IFwiZGF0YVwiIHx8IGV2ID09PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgICAgICB0aGlzW2tSZWFkaW5nXSA9IHRoaXMubGlzdGVuZXJDb3VudChcImRhdGFcIikgPiAwIHx8IHRoaXMubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpID4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2LCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIHB1c2goY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNba0NvbnN1bWVdICYmIGNodW5rICE9PSBudWxsICYmIHRoaXMucmVhZGFibGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zdW1lUHVzaCh0aGlzW2tDb25zdW1lXSwgY2h1bmspO1xuICAgICAgICAgIHJldHVybiB0aGlzW2tSZWFkaW5nXSA/IHN1cGVyLnB1c2goY2h1bmspIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucHVzaChjaHVuayk7XG4gICAgICB9XG4gICAgICBhc3luYyB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gY29uc3VtZSh0aGlzLCBcInRleHRcIik7XG4gICAgICB9XG4gICAgICBhc3luYyBqc29uKCkge1xuICAgICAgICByZXR1cm4gY29uc3VtZSh0aGlzLCBcImpzb25cIik7XG4gICAgICB9XG4gICAgICBhc3luYyBibG9iKCkge1xuICAgICAgICByZXR1cm4gY29uc3VtZSh0aGlzLCBcImJsb2JcIik7XG4gICAgICB9XG4gICAgICBhc3luYyBhcnJheUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWUodGhpcywgXCJhcnJheUJ1ZmZlclwiKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGZvcm1EYXRhKCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGdldCBib2R5VXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwyLmlzRGlzdHVyYmVkKHRoaXMpO1xuICAgICAgfVxuICAgICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGlmICghdGhpc1trQm9keV0pIHtcbiAgICAgICAgICB0aGlzW2tCb2R5XSA9IFJlYWRhYmxlU3RyZWFtRnJvbSh0aGlzKTtcbiAgICAgICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgICAgIHRoaXNba0JvZHldLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXNba0JvZHldLmxvY2tlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tCb2R5XTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGR1bXAob3B0cykge1xuICAgICAgICBsZXQgbGltaXQgPSBvcHRzICYmIE51bWJlci5pc0Zpbml0ZShvcHRzLmxpbWl0KSA/IG9wdHMubGltaXQgOiAyNjIxNDQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsaW1pdCAtPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuayk7XG4gICAgICAgICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFwiQm9keVJlYWRhYmxlXCIpO1xuICAgIGZ1bmN0aW9uIGlzTG9ja2VkKHNlbGYyKSB7XG4gICAgICByZXR1cm4gc2VsZjJba0JvZHldICYmIHNlbGYyW2tCb2R5XS5sb2NrZWQgPT09IHRydWUgfHwgc2VsZjJba0NvbnN1bWVdO1xuICAgIH1cbiAgICBfX25hbWUoaXNMb2NrZWQsIFwiaXNMb2NrZWRcIik7XG4gICAgZnVuY3Rpb24gaXNVbnVzYWJsZShzZWxmMikge1xuICAgICAgcmV0dXJuIHV0aWwyLmlzRGlzdHVyYmVkKHNlbGYyKSB8fCBpc0xvY2tlZChzZWxmMik7XG4gICAgfVxuICAgIF9fbmFtZShpc1VudXNhYmxlLCBcImlzVW51c2FibGVcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZShzdHJlYW0yLCB0eXBlKSB7XG4gICAgICBpZiAoaXNVbnVzYWJsZShzdHJlYW0yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidW51c2FibGVcIik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoIXN0cmVhbTJba0NvbnN1bWVdKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHN0cmVhbTJba0NvbnN1bWVdID0ge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICBib2R5OiBbXVxuICAgICAgICB9O1xuICAgICAgICBzdHJlYW0yLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgZXJyKTtcbiAgICAgICAgfSkub24oXCJjbG9zZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpc1trQ29uc3VtZV0uYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjb25zdW1lU3RhcnQsIHN0cmVhbTJba0NvbnN1bWVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoY29uc3VtZSwgXCJjb25zdW1lXCIpO1xuICAgIGZ1bmN0aW9uIGNvbnN1bWVTdGFydChjb25zdW1lMikge1xuICAgICAgaWYgKGNvbnN1bWUyLmJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBfcmVhZGFibGVTdGF0ZTogc3RhdGUgfSA9IGNvbnN1bWUyLnN0cmVhbTtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2Ygc3RhdGUuYnVmZmVyKSB7XG4gICAgICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUyLCBjaHVuayk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN1bWUyLnN0cmVhbS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdW1lMi5zdHJlYW0ucmVzdW1lKCk7XG4gICAgICB3aGlsZSAoY29uc3VtZTIuc3RyZWFtLnJlYWQoKSAhPSBudWxsKSB7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb25zdW1lU3RhcnQsIFwiY29uc3VtZVN0YXJ0XCIpO1xuICAgIGZ1bmN0aW9uIGNvbnN1bWVFbmQoY29uc3VtZTIpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgYm9keSwgcmVzb2x2ZSwgc3RyZWFtOiBzdHJlYW0yLCBsZW5ndGggfSA9IGNvbnN1bWUyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b1VTVlN0cmluZyhCdWZmZXIuY29uY2F0KGJvZHkpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoQnVmZmVyLmNvbmNhdChib2R5KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYXJyYXlCdWZmZXJcIikge1xuICAgICAgICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgZm9yIChjb25zdCBidWYgb2YgYm9keSkge1xuICAgICAgICAgICAgZHN0LnNldChidWYsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoZHN0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJsb2JcIikge1xuICAgICAgICAgIGlmICghQmxvYikge1xuICAgICAgICAgICAgQmxvYiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQmxvYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShuZXcgQmxvYihib2R5LCB7IHR5cGU6IHN0cmVhbTJba0NvbnRlbnRUeXBlXSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3VtZUZpbmlzaChjb25zdW1lMik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3RyZWFtMi5kZXN0cm95KGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb25zdW1lRW5kLCBcImNvbnN1bWVFbmRcIik7XG4gICAgZnVuY3Rpb24gY29uc3VtZVB1c2goY29uc3VtZTIsIGNodW5rKSB7XG4gICAgICBjb25zdW1lMi5sZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgY29uc3VtZTIuYm9keS5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgX19uYW1lKGNvbnN1bWVQdXNoLCBcImNvbnN1bWVQdXNoXCIpO1xuICAgIGZ1bmN0aW9uIGNvbnN1bWVGaW5pc2goY29uc3VtZTIsIGVycikge1xuICAgICAgaWYgKGNvbnN1bWUyLmJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zdW1lMi5yZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN1bWUyLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWUyLnR5cGUgPSBudWxsO1xuICAgICAgY29uc3VtZTIuc3RyZWFtID0gbnVsbDtcbiAgICAgIGNvbnN1bWUyLnJlc29sdmUgPSBudWxsO1xuICAgICAgY29uc3VtZTIucmVqZWN0ID0gbnVsbDtcbiAgICAgIGNvbnN1bWUyLmxlbmd0aCA9IDA7XG4gICAgICBjb25zdW1lMi5ib2R5ID0gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKGNvbnN1bWVGaW5pc2gsIFwiY29uc3VtZUZpbmlzaFwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hYm9ydC1zaWduYWwuanNcbnZhciByZXF1aXJlX2Fib3J0X3NpZ25hbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hYm9ydC1zaWduYWwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHsgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIga0xpc3RlbmVyID0gU3ltYm9sKFwia0xpc3RlbmVyXCIpO1xuICAgIHZhciBrU2lnbmFsID0gU3ltYm9sKFwia1NpZ25hbFwiKTtcbiAgICBmdW5jdGlvbiBhYm9ydChzZWxmMikge1xuICAgICAgaWYgKHNlbGYyLmFib3J0KSB7XG4gICAgICAgIHNlbGYyLmFib3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmMi5vbkVycm9yKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYWJvcnQsIFwiYWJvcnRcIik7XG4gICAgZnVuY3Rpb24gYWRkU2lnbmFsKHNlbGYyLCBzaWduYWwpIHtcbiAgICAgIHNlbGYyW2tTaWduYWxdID0gbnVsbDtcbiAgICAgIHNlbGYyW2tMaXN0ZW5lcl0gPSBudWxsO1xuICAgICAgaWYgKCFzaWduYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0KHNlbGYyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZjJba1NpZ25hbF0gPSBzaWduYWw7XG4gICAgICBzZWxmMltrTGlzdGVuZXJdID0gKCkgPT4ge1xuICAgICAgICBhYm9ydChzZWxmMik7XG4gICAgICB9O1xuICAgICAgaWYgKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHNlbGYyW2tTaWduYWxdKSB7XG4gICAgICAgIHNlbGYyW2tTaWduYWxdLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBzZWxmMltrTGlzdGVuZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYyW2tTaWduYWxdLmFkZExpc3RlbmVyKFwiYWJvcnRcIiwgc2VsZjJba0xpc3RlbmVyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShhZGRTaWduYWwsIFwiYWRkU2lnbmFsXCIpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZVNpZ25hbChzZWxmMikge1xuICAgICAgaWYgKCFzZWxmMltrU2lnbmFsXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgaW4gc2VsZjJba1NpZ25hbF0pIHtcbiAgICAgICAgc2VsZjJba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHNlbGYyW2tMaXN0ZW5lcl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZjJba1NpZ25hbF0ucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLCBzZWxmMltrTGlzdGVuZXJdKTtcbiAgICAgIH1cbiAgICAgIHNlbGYyW2tTaWduYWxdID0gbnVsbDtcbiAgICAgIHNlbGYyW2tMaXN0ZW5lcl0gPSBudWxsO1xuICAgIH1cbiAgICBfX25hbWUocmVtb3ZlU2lnbmFsLCBcInJlbW92ZVNpZ25hbFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBhZGRTaWduYWwsXG4gICAgICByZW1vdmVTaWduYWxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzXG52YXIgcmVxdWlyZV9hcGlfcmVxdWVzdCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcmVxdWVzdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUmVhZGFibGUgPSByZXF1aXJlX3JlYWRhYmxlKCk7XG4gICAgdmFyIHtcbiAgICAgIEludmFsaWRBcmd1bWVudEVycm9yLFxuICAgICAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgICAgIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yXG4gICAgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IEFzeW5jUmVzb3VyY2U6IEFzeW5jUmVzb3VyY2UyIH0gPSByZXF1aXJlKFwiYXN5bmNfaG9va3NcIik7XG4gICAgdmFyIHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmVfYWJvcnRfc2lnbmFsKCk7XG4gICAgdmFyIFJlcXVlc3RIYW5kbGVyMiA9IGNsYXNzIGV4dGVuZHMgQXN5bmNSZXNvdXJjZTIge1xuICAgICAgY29uc3RydWN0b3Iob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciB9ID0gb3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1ldGhvZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25JbmZvIGNhbGxiYWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXBlcihcIlVORElDSV9SRVFVRVNUXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAodXRpbDIuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keS5vbihcImVycm9yXCIsIHV0aWwyLm5vcCksIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMudHJhaWxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3I7XG4gICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICAgIGJvZHkub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIG9uQ29ubmVjdChhYm9ydCwgY29udGV4dDMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ID0gYWJvcnQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQzO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGFib3J0LCBjb250ZXh0OiBjb250ZXh0MyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMyID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnM6IGhlYWRlcnMyIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJzZWRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBjb25zdCBib2R5ID0gbmV3IFJlYWRhYmxlKHJlc3VtZSwgYWJvcnQsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzID0gYm9keTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSBcInJhd1wiID8gdXRpbDIucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbDIucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpO1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKFxuICAgICAgICAgICAgICBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHRyYWlsZXJzOiB0aGlzLnRyYWlsZXJzLFxuICAgICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uRGF0YShjaHVuaykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIG9uQ29tcGxldGUodHJhaWxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXMgfSA9IHRoaXM7XG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgdXRpbDIucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKTtcbiAgICAgICAgcmVzLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICBvbkVycm9yKGVycikge1xuICAgICAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIGJvZHksIG9wYXF1ZSB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmVzLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KGJvZHksIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShSZXF1ZXN0SGFuZGxlcjIsIFwiUmVxdWVzdEhhbmRsZXJcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrKHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH0pIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSAyMDQgfHwgIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGJvZHkuZHVtcCgpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6IFwiXCJ9YCwgc3RhdHVzQ29kZSwgaGVhZGVycykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY29udGVudFR5cGUuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgYm9keS5qc29uKCk7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiBcIlwifWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBib2R5LnRleHQoKTtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6IFwiXCJ9YCwgc3RhdHVzQ29kZSwgaGVhZGVycywgcGF5bG9hZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgICBib2R5LmR1bXAoKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogXCJcIn1gLCBzdGF0dXNDb2RlLCBoZWFkZXJzKSk7XG4gICAgfVxuICAgIF9fbmFtZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIFwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrXCIpO1xuICAgIGZ1bmN0aW9uIHJlcXVlc3QyKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3QyLmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBSZXF1ZXN0SGFuZGxlcjIob3B0cywgY2FsbGJhY2spKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZXF1ZXN0MiwgXCJyZXF1ZXN0XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVlc3QyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1zdHJlYW0uanNcbnZhciByZXF1aXJlX2FwaV9zdHJlYW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBmaW5pc2hlZCB9ID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiAgICB2YXIge1xuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgICAgIFJlcXVlc3RBYm9ydGVkRXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgQXN5bmNSZXNvdXJjZTogQXN5bmNSZXNvdXJjZTIgfSA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbiAgICB2YXIgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZV9hYm9ydF9zaWduYWwoKTtcbiAgICB2YXIgU3RyZWFtSGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgQXN5bmNSZXNvdXJjZTIge1xuICAgICAgY29uc3RydWN0b3Iob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmYWN0b3J5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwic2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkNPTk5FQ1RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBtZXRob2RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uSW5mbyBjYWxsYmFja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VwZXIoXCJVTkRJQ0lfU1RSRUFNXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAodXRpbDIuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keS5vbihcImVycm9yXCIsIHV0aWwyLm5vcCksIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhaWxlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsO1xuICAgICAgICBpZiAodXRpbDIuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgICBib2R5Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbCk7XG4gICAgICB9XG4gICAgICBvbkNvbm5lY3QoYWJvcnQsIGNvbnRleHQzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hYm9ydCA9IGFib3J0O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0MztcbiAgICAgIH1cbiAgICAgIG9uSGVhZGVycyhzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUpIHtcbiAgICAgICAgY29uc3QgeyBmYWN0b3J5LCBvcGFxdWUsIGNvbnRleHQ6IGNvbnRleHQzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyczIgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVyczogaGVhZGVyczIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhY3RvcnkgPSBudWxsO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGZhY3RvcnksIG51bGwsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlcyB8fCB0eXBlb2YgcmVzLndyaXRlICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlcy5lbmQgIT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVzLm9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoXCJleHBlY3RlZCBXcml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXMub24oXCJkcmFpblwiLCByZXN1bWUpO1xuICAgICAgICBmaW5pc2hlZChyZXMsIHsgcmVhZGFibGU6IGZhbHNlIH0sIChlcnIpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCByZXM6IHJlczIsIG9wYXF1ZTogb3BhcXVlMiwgdHJhaWxlcnMsIGFib3J0IH0gPSB0aGlzO1xuICAgICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFyZXMyLnJlYWRhYmxlKSB7XG4gICAgICAgICAgICB1dGlsMi5kZXN0cm95KHJlczIsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWU6IG9wYXF1ZTIsIHRyYWlsZXJzIH0pO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdm9pZCAwID8gcmVzLndyaXRhYmxlTmVlZERyYWluIDogcmVzLl93cml0YWJsZVN0YXRlICYmIHJlcy5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW47XG4gICAgICAgIHJldHVybiBuZWVkRHJhaW4gIT09IHRydWU7XG4gICAgICB9XG4gICAgICBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgY29uc3QgeyByZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZXMud3JpdGUoY2h1bmspO1xuICAgICAgfVxuICAgICAgb25Db21wbGV0ZSh0cmFpbGVycykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYWlsZXJzID0gdXRpbDIucGFyc2VIZWFkZXJzKHRyYWlsZXJzKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgfVxuICAgICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXM7XG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHJlcywgZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KGJvZHksIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShTdHJlYW1IYW5kbGVyLCBcIlN0cmVhbUhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gc3RyZWFtMihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzdHJlYW0yLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBTdHJlYW1IYW5kbGVyKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWU7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc3RyZWFtMiwgXCJzdHJlYW1cIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gc3RyZWFtMjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcGlwZWxpbmUuanNcbnZhciByZXF1aXJlX2FwaV9waXBlbGluZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcGlwZWxpbmUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHtcbiAgICAgIFJlYWRhYmxlLFxuICAgICAgRHVwbGV4LFxuICAgICAgUGFzc1Rocm91Z2hcbiAgICB9ID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiAgICB2YXIge1xuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgICAgIFJlcXVlc3RBYm9ydGVkRXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgQXN5bmNSZXNvdXJjZTogQXN5bmNSZXNvdXJjZTIgfSA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbiAgICB2YXIgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZV9hYm9ydF9zaWduYWwoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIga1Jlc3VtZSA9IFN5bWJvbChcInJlc3VtZVwiKTtcbiAgICB2YXIgUGlwZWxpbmVSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpc1trUmVzdW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBfcmVhZCgpIHtcbiAgICAgICAgY29uc3QgeyBba1Jlc3VtZV06IHJlc3VtZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3VtZSkge1xuICAgICAgICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsO1xuICAgICAgICAgIHJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3JlYWQoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShQaXBlbGluZVJlcXVlc3QsIFwiUGlwZWxpbmVSZXF1ZXN0XCIpO1xuICAgIHZhciBQaXBlbGluZVJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gICAgICBjb25zdHJ1Y3RvcihyZXN1bWUpIHtcbiAgICAgICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpc1trUmVzdW1lXSA9IHJlc3VtZTtcbiAgICAgIH1cbiAgICAgIF9yZWFkKCkge1xuICAgICAgICB0aGlzW2tSZXN1bWVdKCk7XG4gICAgICB9XG4gICAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUGlwZWxpbmVSZXNwb25zZSwgXCJQaXBlbGluZVJlc3BvbnNlXCIpO1xuICAgIHZhciBQaXBlbGluZUhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIEFzeW5jUmVzb3VyY2UyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHM7XG4gICAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwic2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBtZXRob2RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uSW5mbyBjYWxsYmFja1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcIlVORElDSV9QSVBFTElORVwiKTtcbiAgICAgICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGw7XG4gICAgICAgIHRoaXMucmVxID0gbmV3IFBpcGVsaW5lUmVxdWVzdCgpLm9uKFwiZXJyb3JcIiwgdXRpbDIubm9wKTtcbiAgICAgICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgICAgICByZWFkYWJsZU9iamVjdE1vZGU6IG9wdHMub2JqZWN0TW9kZSxcbiAgICAgICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoYm9keSAmJiBib2R5LnJlc3VtZSkge1xuICAgICAgICAgICAgICBib2R5LnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChyZXEucHVzaChjaHVuaywgZW5jb2RpbmcpIHx8IHJlcS5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcVtrUmVzdW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzdHJveTogKGVyciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSwgcmVxLCByZXMsIHJldCwgYWJvcnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWVyciAmJiAhcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydCAmJiBlcnIpIHtcbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keSwgZXJyKTtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmVxLCBlcnIpO1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShyZXMsIGVycik7XG4gICAgICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oXCJwcmVmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzO1xuICAgICAgICAgIHJlcS5wdXNoKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIG9uQ29ubmVjdChhYm9ydCwgY29udGV4dDMpIHtcbiAgICAgICAgY29uc3QgeyByZXQsIHJlcyB9ID0gdGhpcztcbiAgICAgICAgYXNzZXJ0KCFyZXMsIFwicGlwZWxpbmUgY2Fubm90IGJlIHJldHJpZWRcIik7XG4gICAgICAgIGlmIChyZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ID0gYWJvcnQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQzO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSkge1xuICAgICAgICBjb25zdCB7IG9wYXF1ZSwgaGFuZGxlciwgY29udGV4dDogY29udGV4dDMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcyA9IG5ldyBQaXBlbGluZVJlc3BvbnNlKHJlc3VtZSk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSBcInJhd1wiID8gdXRpbDIucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbDIucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpO1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShoYW5kbGVyLCBudWxsLCB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICAgIGJvZHk6IHRoaXMucmVzLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dDNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5yZXMub24oXCJlcnJvclwiLCB1dGlsMi5ub3ApO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkub24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcihcImV4cGVjdGVkIFJlYWRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcmV0LCBib2R5OiBib2R5MiB9ID0gdGhpcztcbiAgICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5Mi5wYXVzZSkge1xuICAgICAgICAgICAgYm9keTIucGF1c2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmV0LCBlcnIpO1xuICAgICAgICB9KS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0LnB1c2gobnVsbCk7XG4gICAgICAgIH0pLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzO1xuICAgICAgICAgIGlmICghcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgICB1dGlsMi5kZXN0cm95KHJldCwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIG9uRGF0YShjaHVuaykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIG9uQ29tcGxldGUodHJhaWxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXMgfSA9IHRoaXM7XG4gICAgICAgIHJlcy5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgICAgIHV0aWwyLmRlc3Ryb3kocmV0LCBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFBpcGVsaW5lSGFuZGxlciwgXCJQaXBlbGluZUhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gcGlwZWxpbmUob3B0cywgaGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGlwZWxpbmVIYW5kbGVyID0gbmV3IFBpcGVsaW5lSGFuZGxlcihvcHRzLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lSGFuZGxlci5yZXQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpLmRlc3Ryb3koZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHBpcGVsaW5lLCBcInBpcGVsaW5lXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBpcGVsaW5lO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS11cGdyYWRlLmpzXG52YXIgcmVxdWlyZV9hcGlfdXBncmFkZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktdXBncmFkZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsgQXN5bmNSZXNvdXJjZTogQXN5bmNSZXNvdXJjZTIgfSA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmVfYWJvcnRfc2lnbmFsKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIFVwZ3JhZGVIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBBc3luY1Jlc291cmNlMiB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHM7XG4gICAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwic2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKFwiVU5ESUNJX1VQR1JBREVcIik7XG4gICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGw7XG4gICAgICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpO1xuICAgICAgfVxuICAgICAgb25Db25uZWN0KGFib3J0LCBjb250ZXh0Mykge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9uSGVhZGVycygpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKFwiYmFkIHVwZ3JhZGVcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBvblVwZ3JhZGUoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dDogY29udGV4dDMgfSA9IHRoaXM7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChzdGF0dXNDb2RlLCAxMDEpO1xuICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzO1xuICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoVXBncmFkZUhhbmRsZXIsIFwiVXBncmFkZUhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gdXBncmFkZShvcHRzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB1cGdyYWRlLmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cGdyYWRlSGFuZGxlciA9IG5ldyBVcGdyYWRlSGFuZGxlcihvcHRzLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCBcIkdFVFwiLFxuICAgICAgICAgIHVwZ3JhZGU6IG9wdHMucHJvdG9jb2wgfHwgXCJXZWJzb2NrZXRcIlxuICAgICAgICB9LCB1cGdyYWRlSGFuZGxlcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWU7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodXBncmFkZSwgXCJ1cGdyYWRlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHVwZ3JhZGU7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanNcbnZhciByZXF1aXJlX2FwaV9jb25uZWN0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1jb25uZWN0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBBc3luY1Jlc291cmNlOiBBc3luY1Jlc291cmNlMiB9ID0gcmVxdWlyZShcImFzeW5jX2hvb2tzXCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZV9hYm9ydF9zaWduYWwoKTtcbiAgICB2YXIgQ29ubmVjdEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIEFzeW5jUmVzb3VyY2UyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3B0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0cztcbiAgICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoXCJVTkRJQ0lfQ09OTkVDVFwiKTtcbiAgICAgICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbCk7XG4gICAgICB9XG4gICAgICBvbkNvbm5lY3QoYWJvcnQsIGNvbnRleHQzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hYm9ydCA9IGFib3J0O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0MztcbiAgICAgIH1cbiAgICAgIG9uSGVhZGVycygpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKFwiYmFkIGNvbm5lY3RcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBvblVwZ3JhZGUoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dDogY29udGV4dDMgfSA9IHRoaXM7XG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgc29ja2V0LFxuICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0M1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENvbm5lY3RIYW5kbGVyLCBcIkNvbm5lY3RIYW5kbGVyXCIpO1xuICAgIGZ1bmN0aW9uIGNvbm5lY3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSBuZXcgQ29ubmVjdEhhbmRsZXIob3B0cywgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgbWV0aG9kOiBcIkNPTk5FQ1RcIiB9LCBjb25uZWN0SGFuZGxlcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWU7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY29ubmVjdCwgXCJjb25uZWN0XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNvbm5lY3Q7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanNcbnZhciByZXF1aXJlX2FwaSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMucmVxdWVzdCA9IHJlcXVpcmVfYXBpX3JlcXVlc3QoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuc3RyZWFtID0gcmVxdWlyZV9hcGlfc3RyZWFtKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZV9hcGlfcGlwZWxpbmUoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMudXBncmFkZSA9IHJlcXVpcmVfYXBpX3VwZ3JhZGUoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29ubmVjdCA9IHJlcXVpcmVfYXBpX2Nvbm5lY3QoKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1lcnJvcnMuanNcbnZhciByZXF1aXJlX21vY2tfZXJyb3JzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgTW9ja05vdE1hdGNoZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTW9ja05vdE1hdGNoZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTW9ja05vdE1hdGNoZWRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiVGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggYW55IHJlZ2lzdGVyZWQgbW9jayBkaXNwYXRjaGVzXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRURcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrTm90TWF0Y2hlZEVycm9yLCBcIk1vY2tOb3RNYXRjaGVkRXJyb3JcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgTW9ja05vdE1hdGNoZWRFcnJvclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qc1xudmFyIHJlcXVpcmVfbW9ja19zeW1ib2xzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXN5bWJvbHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAga0FnZW50OiBTeW1ib2woXCJhZ2VudFwiKSxcbiAgICAgIGtPcHRpb25zOiBTeW1ib2woXCJvcHRpb25zXCIpLFxuICAgICAga0ZhY3Rvcnk6IFN5bWJvbChcImZhY3RvcnlcIiksXG4gICAgICBrRGlzcGF0Y2hlczogU3ltYm9sKFwiZGlzcGF0Y2hlc1wiKSxcbiAgICAgIGtEaXNwYXRjaEtleTogU3ltYm9sKFwiZGlzcGF0Y2gga2V5XCIpLFxuICAgICAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woXCJkZWZhdWx0IGhlYWRlcnNcIiksXG4gICAgICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woXCJkZWZhdWx0IHRyYWlsZXJzXCIpLFxuICAgICAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbChcImNvbnRlbnQgbGVuZ3RoXCIpLFxuICAgICAga01vY2tBZ2VudDogU3ltYm9sKFwibW9jayBhZ2VudFwiKSxcbiAgICAgIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbChcIm1vY2sgYWdlbnQgc2V0XCIpLFxuICAgICAga01vY2tBZ2VudEdldDogU3ltYm9sKFwibW9jayBhZ2VudCBnZXRcIiksXG4gICAgICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woXCJtb2NrIGRpc3BhdGNoXCIpLFxuICAgICAga0Nsb3NlOiBTeW1ib2woXCJjbG9zZVwiKSxcbiAgICAgIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woXCJvcmlnaW5hbCBhZ2VudCBjbG9zZVwiKSxcbiAgICAgIGtPcmlnaW46IFN5bWJvbChcIm9yaWdpblwiKSxcbiAgICAgIGtJc01vY2tBY3RpdmU6IFN5bWJvbChcImlzIG1vY2sgYWN0aXZlXCIpLFxuICAgICAga05ldENvbm5lY3Q6IFN5bWJvbChcIm5ldCBjb25uZWN0XCIpLFxuICAgICAga0dldE5ldENvbm5lY3Q6IFN5bWJvbChcImdldCBuZXQgY29ubmVjdFwiKSxcbiAgICAgIGtDb25uZWN0ZWQ6IFN5bWJvbChcImNvbm5lY3RlZFwiKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanNcbnZhciByZXF1aXJlX21vY2tfdXRpbHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgTW9ja05vdE1hdGNoZWRFcnJvciB9ID0gcmVxdWlyZV9tb2NrX2Vycm9ycygpO1xuICAgIHZhciB7XG4gICAgICBrRGlzcGF0Y2hlcyxcbiAgICAgIGtNb2NrQWdlbnQsXG4gICAgICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAgICAgIGtPcmlnaW4sXG4gICAgICBrR2V0TmV0Q29ubmVjdFxuICAgIH0gPSByZXF1aXJlX21vY2tfc3ltYm9scygpO1xuICAgIHZhciB7IGJ1aWxkVVJMLCBub3AgfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICBmdW5jdGlvbiBtYXRjaFZhbHVlKG1hdGNoLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbWF0Y2ggPT09IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBtYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbWF0Y2godmFsdWUpID09PSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfX25hbWUobWF0Y2hWYWx1ZSwgXCJtYXRjaFZhbHVlXCIpO1xuICAgIGZ1bmN0aW9uIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCksIGhlYWRlclZhbHVlXTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIF9fbmFtZShsb3dlckNhc2VFbnRyaWVzLCBcImxvd2VyQ2FzZUVudHJpZXNcIik7XG4gICAgZnVuY3Rpb24gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIGtleSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzW2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlcnMuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKVtrZXkudG9Mb2NhbGVMb3dlckNhc2UoKV07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShnZXRIZWFkZXJCeU5hbWUsIFwiZ2V0SGVhZGVyQnlOYW1lXCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKSB7XG4gICAgICBjb25zdCBjbG9uZTIgPSBoZWFkZXJzLnNsaWNlKCk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2xvbmUyLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgICAgICBlbnRyaWVzLnB1c2goW2Nsb25lMltpbmRleF0sIGNsb25lMltpbmRleCArIDFdXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRIZWFkZXJzRnJvbUFycmF5LCBcImJ1aWxkSGVhZGVyc0Zyb21BcnJheVwiKTtcbiAgICBmdW5jdGlvbiBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoMiwgaGVhZGVycykge1xuICAgICAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2gyLmhlYWRlcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgIGhlYWRlcnMgPSBidWlsZEhlYWRlcnNGcm9tQXJyYXkoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vY2tEaXNwYXRjaDIuaGVhZGVycyhoZWFkZXJzID8gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKSA6IHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoMi5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2NrRGlzcGF0Y2gyLmhlYWRlcnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbbWF0Y2hIZWFkZXJOYW1lLCBtYXRjaEhlYWRlclZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtb2NrRGlzcGF0Y2gyLmhlYWRlcnMpKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUobWF0Y2hIZWFkZXJzLCBcIm1hdGNoSGVhZGVyc1wiKTtcbiAgICBmdW5jdGlvbiBzYWZlVXJsKHBhdGg3KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGg3ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXRoNztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGhTZWdtZW50cyA9IHBhdGg3LnNwbGl0KFwiP1wiKTtcbiAgICAgIGlmIChwYXRoU2VnbWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBwYXRoNztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoU2VnbWVudHMucG9wKCkpO1xuICAgICAgcXAuc29ydCgpO1xuICAgICAgcmV0dXJuIFsuLi5wYXRoU2VnbWVudHMsIHFwLnRvU3RyaW5nKCldLmpvaW4oXCI/XCIpO1xuICAgIH1cbiAgICBfX25hbWUoc2FmZVVybCwgXCJzYWZlVXJsXCIpO1xuICAgIGZ1bmN0aW9uIG1hdGNoS2V5KG1vY2tEaXNwYXRjaDIsIHsgcGF0aDogcGF0aDcsIG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KSB7XG4gICAgICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaDIucGF0aCwgcGF0aDcpO1xuICAgICAgY29uc3QgbWV0aG9kTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaDIubWV0aG9kLCBtZXRob2QpO1xuICAgICAgY29uc3QgYm9keU1hdGNoID0gdHlwZW9mIG1vY2tEaXNwYXRjaDIuYm9keSAhPT0gXCJ1bmRlZmluZWRcIiA/IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoMi5ib2R5LCBib2R5KSA6IHRydWU7XG4gICAgICBjb25zdCBoZWFkZXJzTWF0Y2ggPSBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoMiwgaGVhZGVycyk7XG4gICAgICByZXR1cm4gcGF0aE1hdGNoICYmIG1ldGhvZE1hdGNoICYmIGJvZHlNYXRjaCAmJiBoZWFkZXJzTWF0Y2g7XG4gICAgfVxuICAgIF9fbmFtZShtYXRjaEtleSwgXCJtYXRjaEtleVwiKTtcbiAgICBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEoZGF0YSkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGdldFJlc3BvbnNlRGF0YSwgXCJnZXRSZXNwb25zZURhdGFcIik7XG4gICAgZnVuY3Rpb24gZ2V0TW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgICAgIGNvbnN0IGJhc2VQYXRoID0ga2V5LnF1ZXJ5ID8gYnVpbGRVUkwoa2V5LnBhdGgsIGtleS5xdWVyeSkgOiBrZXkucGF0aDtcbiAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHR5cGVvZiBiYXNlUGF0aCA9PT0gXCJzdHJpbmdcIiA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGg7XG4gICAgICBsZXQgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IGNvbnN1bWVkIH0pID0+ICFjb25zdW1lZCkuZmlsdGVyKCh7IHBhdGg6IHBhdGg3IH0pID0+IG1hdGNoVmFsdWUoc2FmZVVybChwYXRoNyksIHJlc29sdmVkUGF0aCkpO1xuICAgICAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSk7XG4gICAgICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9J2ApO1xuICAgICAgfVxuICAgICAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiID8gbWF0Y2hWYWx1ZShib2R5LCBrZXkuYm9keSkgOiB0cnVlKTtcbiAgICAgIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBib2R5ICcke2tleS5ib2R5fSdgKTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKG1vY2tEaXNwYXRjaDIpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gyLCBrZXkuaGVhZGVycykpO1xuICAgICAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7dHlwZW9mIGtleS5oZWFkZXJzID09PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkoa2V5LmhlYWRlcnMpIDoga2V5LmhlYWRlcnN9J2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXTtcbiAgICB9XG4gICAgX19uYW1lKGdldE1vY2tEaXNwYXRjaCwgXCJnZXRNb2NrRGlzcGF0Y2hcIik7XG4gICAgZnVuY3Rpb24gYWRkTW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgICAgIGNvbnN0IGJhc2VEYXRhID0geyB0aW1lc0ludm9rZWQ6IDAsIHRpbWVzOiAxLCBwZXJzaXN0OiBmYWxzZSwgY29uc3VtZWQ6IGZhbHNlIH07XG4gICAgICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiID8geyBjYWxsYmFjazogZGF0YSB9IDogeyAuLi5kYXRhIH07XG4gICAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSB7IC4uLmJhc2VEYXRhLCAuLi5rZXksIHBlbmRpbmc6IHRydWUsIGRhdGE6IHsgZXJyb3I6IG51bGwsIC4uLnJlcGx5RGF0YSB9IH07XG4gICAgICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaCk7XG4gICAgICByZXR1cm4gbmV3TW9ja0Rpc3BhdGNoO1xuICAgIH1cbiAgICBfX25hbWUoYWRkTW9ja0Rpc3BhdGNoLCBcImFkZE1vY2tEaXNwYXRjaFwiKTtcbiAgICBmdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2gobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICAgICAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoKGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoS2V5KGRpc3BhdGNoLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShkZWxldGVNb2NrRGlzcGF0Y2gsIFwiZGVsZXRlTW9ja0Rpc3BhdGNoXCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkS2V5KG9wdHMpIHtcbiAgICAgIGNvbnN0IHsgcGF0aDogcGF0aDcsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnk6IHF1ZXJ5MiB9ID0gb3B0cztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHBhdGg3LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeTJcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShidWlsZEtleSwgXCJidWlsZEtleVwiKTtcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyhkYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChrZXlWYWx1ZVBhaXJzLCBba2V5LCB2YWx1ZV0pID0+IFsuLi5rZXlWYWx1ZVBhaXJzLCBrZXksIHZhbHVlXSwgW10pO1xuICAgIH1cbiAgICBfX25hbWUoZ2VuZXJhdGVLZXlWYWx1ZXMsIFwiZ2VuZXJhdGVLZXlWYWx1ZXNcIik7XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzVGV4dChzdGF0dXNDb2RlKSB7XG4gICAgICBzd2l0Y2ggKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgcmV0dXJuIFwiQ29udGludWVcIjtcbiAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgcmV0dXJuIFwiU3dpdGNoaW5nIFByb3RvY29sc1wiO1xuICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9jZXNzaW5nXCI7XG4gICAgICAgIGNhc2UgMTAzOlxuICAgICAgICAgIHJldHVybiBcIkVhcmx5IEhpbnRzXCI7XG4gICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgIHJldHVybiBcIk9LXCI7XG4gICAgICAgIGNhc2UgMjAxOlxuICAgICAgICAgIHJldHVybiBcIkNyZWF0ZWRcIjtcbiAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgcmV0dXJuIFwiQWNjZXB0ZWRcIjtcbiAgICAgICAgY2FzZSAyMDM6XG4gICAgICAgICAgcmV0dXJuIFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIjtcbiAgICAgICAgY2FzZSAyMDQ6XG4gICAgICAgICAgcmV0dXJuIFwiTm8gQ29udGVudFwiO1xuICAgICAgICBjYXNlIDIwNTpcbiAgICAgICAgICByZXR1cm4gXCJSZXNldCBDb250ZW50XCI7XG4gICAgICAgIGNhc2UgMjA2OlxuICAgICAgICAgIHJldHVybiBcIlBhcnRpYWwgQ29udGVudFwiO1xuICAgICAgICBjYXNlIDIwNzpcbiAgICAgICAgICByZXR1cm4gXCJNdWx0aS1TdGF0dXNcIjtcbiAgICAgICAgY2FzZSAyMDg6XG4gICAgICAgICAgcmV0dXJuIFwiQWxyZWFkeSBSZXBvcnRlZFwiO1xuICAgICAgICBjYXNlIDIyNjpcbiAgICAgICAgICByZXR1cm4gXCJJTSBVc2VkXCI7XG4gICAgICAgIGNhc2UgMzAwOlxuICAgICAgICAgIHJldHVybiBcIk11bHRpcGxlIENob2ljZVwiO1xuICAgICAgICBjYXNlIDMwMTpcbiAgICAgICAgICByZXR1cm4gXCJNb3ZlZCBQZXJtYW5lbnRseVwiO1xuICAgICAgICBjYXNlIDMwMjpcbiAgICAgICAgICByZXR1cm4gXCJGb3VuZFwiO1xuICAgICAgICBjYXNlIDMwMzpcbiAgICAgICAgICByZXR1cm4gXCJTZWUgT3RoZXJcIjtcbiAgICAgICAgY2FzZSAzMDQ6XG4gICAgICAgICAgcmV0dXJuIFwiTm90IE1vZGlmaWVkXCI7XG4gICAgICAgIGNhc2UgMzA1OlxuICAgICAgICAgIHJldHVybiBcIlVzZSBQcm94eVwiO1xuICAgICAgICBjYXNlIDMwNjpcbiAgICAgICAgICByZXR1cm4gXCJ1bnVzZWRcIjtcbiAgICAgICAgY2FzZSAzMDc6XG4gICAgICAgICAgcmV0dXJuIFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCI7XG4gICAgICAgIGNhc2UgMzA4OlxuICAgICAgICAgIHJldHVybiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiO1xuICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICByZXR1cm4gXCJCYWQgUmVxdWVzdFwiO1xuICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICByZXR1cm4gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICAgICAgY2FzZSA0MDI6XG4gICAgICAgICAgcmV0dXJuIFwiUGF5bWVudCBSZXF1aXJlZFwiO1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICByZXR1cm4gXCJGb3JiaWRkZW5cIjtcbiAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgcmV0dXJuIFwiTm90IEZvdW5kXCI7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgIHJldHVybiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiO1xuICAgICAgICBjYXNlIDQwNjpcbiAgICAgICAgICByZXR1cm4gXCJOb3QgQWNjZXB0YWJsZVwiO1xuICAgICAgICBjYXNlIDQwNzpcbiAgICAgICAgICByZXR1cm4gXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiO1xuICAgICAgICBjYXNlIDQwODpcbiAgICAgICAgICByZXR1cm4gXCJSZXF1ZXN0IFRpbWVvdXRcIjtcbiAgICAgICAgY2FzZSA0MDk6XG4gICAgICAgICAgcmV0dXJuIFwiQ29uZmxpY3RcIjtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgcmV0dXJuIFwiR29uZVwiO1xuICAgICAgICBjYXNlIDQxMTpcbiAgICAgICAgICByZXR1cm4gXCJMZW5ndGggUmVxdWlyZWRcIjtcbiAgICAgICAgY2FzZSA0MTI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiO1xuICAgICAgICBjYXNlIDQxMzpcbiAgICAgICAgICByZXR1cm4gXCJQYXlsb2FkIFRvbyBMYXJnZVwiO1xuICAgICAgICBjYXNlIDQxNDpcbiAgICAgICAgICByZXR1cm4gXCJVUkkgVG9vIExhcmdlXCI7XG4gICAgICAgIGNhc2UgNDE1OlxuICAgICAgICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIjtcbiAgICAgICAgY2FzZSA0MTY6XG4gICAgICAgICAgcmV0dXJuIFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCI7XG4gICAgICAgIGNhc2UgNDE3OlxuICAgICAgICAgIHJldHVybiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiO1xuICAgICAgICBjYXNlIDQxODpcbiAgICAgICAgICByZXR1cm4gXCJJJ20gYSB0ZWFwb3RcIjtcbiAgICAgICAgY2FzZSA0MjE6XG4gICAgICAgICAgcmV0dXJuIFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiO1xuICAgICAgICBjYXNlIDQyMjpcbiAgICAgICAgICByZXR1cm4gXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiO1xuICAgICAgICBjYXNlIDQyMzpcbiAgICAgICAgICByZXR1cm4gXCJMb2NrZWRcIjtcbiAgICAgICAgY2FzZSA0MjQ6XG4gICAgICAgICAgcmV0dXJuIFwiRmFpbGVkIERlcGVuZGVuY3lcIjtcbiAgICAgICAgY2FzZSA0MjU6XG4gICAgICAgICAgcmV0dXJuIFwiVG9vIEVhcmx5XCI7XG4gICAgICAgIGNhc2UgNDI2OlxuICAgICAgICAgIHJldHVybiBcIlVwZ3JhZGUgUmVxdWlyZWRcIjtcbiAgICAgICAgY2FzZSA0Mjg6XG4gICAgICAgICAgcmV0dXJuIFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCI7XG4gICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgIHJldHVybiBcIlRvbyBNYW55IFJlcXVlc3RzXCI7XG4gICAgICAgIGNhc2UgNDMxOlxuICAgICAgICAgIHJldHVybiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIjtcbiAgICAgICAgY2FzZSA0NTE6XG4gICAgICAgICAgcmV0dXJuIFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIjtcbiAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgcmV0dXJuIFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCI7XG4gICAgICAgIGNhc2UgNTAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBJbXBsZW1lbnRlZFwiO1xuICAgICAgICBjYXNlIDUwMjpcbiAgICAgICAgICByZXR1cm4gXCJCYWQgR2F0ZXdheVwiO1xuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgICByZXR1cm4gXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCI7XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgIHJldHVybiBcIkdhdGV3YXkgVGltZW91dFwiO1xuICAgICAgICBjYXNlIDUwNTpcbiAgICAgICAgICByZXR1cm4gXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiO1xuICAgICAgICBjYXNlIDUwNjpcbiAgICAgICAgICByZXR1cm4gXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiO1xuICAgICAgICBjYXNlIDUwNzpcbiAgICAgICAgICByZXR1cm4gXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiO1xuICAgICAgICBjYXNlIDUwODpcbiAgICAgICAgICByZXR1cm4gXCJMb29wIERldGVjdGVkXCI7XG4gICAgICAgIGNhc2UgNTEwOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBFeHRlbmRlZFwiO1xuICAgICAgICBjYXNlIDUxMTpcbiAgICAgICAgICByZXR1cm4gXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZ2V0U3RhdHVzVGV4dCwgXCJnZXRTdGF0dXNUZXh0XCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlKGJvZHkpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBib2R5KSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICB9XG4gICAgX19uYW1lKGdldFJlc3BvbnNlLCBcImdldFJlc3BvbnNlXCIpO1xuICAgIGZ1bmN0aW9uIG1vY2tEaXNwYXRjaChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSBidWlsZEtleShvcHRzKTtcbiAgICAgIGNvbnN0IG1vY2tEaXNwYXRjaDIgPSBnZXRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIGtleSk7XG4gICAgICBtb2NrRGlzcGF0Y2gyLnRpbWVzSW52b2tlZCsrO1xuICAgICAgaWYgKG1vY2tEaXNwYXRjaDIuZGF0YS5jYWxsYmFjaykge1xuICAgICAgICBtb2NrRGlzcGF0Y2gyLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaDIuZGF0YSwgLi4ubW9ja0Rpc3BhdGNoMi5kYXRhLmNhbGxiYWNrKG9wdHMpIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yOiBlcnJvcjIgfSwgZGVsYXksIHBlcnNpc3QgfSA9IG1vY2tEaXNwYXRjaDI7XG4gICAgICBjb25zdCB7IHRpbWVzSW52b2tlZCwgdGltZXMgfSA9IG1vY2tEaXNwYXRjaDI7XG4gICAgICBtb2NrRGlzcGF0Y2gyLmNvbnN1bWVkID0gIXBlcnNpc3QgJiYgdGltZXNJbnZva2VkID49IHRpbWVzO1xuICAgICAgbW9ja0Rpc3BhdGNoMi5wZW5kaW5nID0gdGltZXNJbnZva2VkIDwgdGltZXM7XG4gICAgICBpZiAoZXJyb3IyICE9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KTtcbiAgICAgICAgaGFuZGxlci5vbkVycm9yKGVycm9yMik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIiAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlUmVwbHkodGhpc1trRGlzcGF0Y2hlc10pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVSZXBseShtb2NrRGlzcGF0Y2hlcykge1xuICAgICAgICBjb25zdCBvcHRzSGVhZGVycyA9IEFycmF5LmlzQXJyYXkob3B0cy5oZWFkZXJzKSA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpIDogb3B0cy5oZWFkZXJzO1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoXG4gICAgICAgICAgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIiA/IGRhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KSA6IGRhdGFcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVHJhaWxlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyh0cmFpbGVycyk7XG4gICAgICAgIGhhbmRsZXIuYWJvcnQgPSBub3A7XG4gICAgICAgIGhhbmRsZXIub25IZWFkZXJzKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKTtcbiAgICAgICAgaGFuZGxlci5vbkRhdGEoQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSk7XG4gICAgICAgIGhhbmRsZXIub25Db21wbGV0ZShyZXNwb25zZVRyYWlsZXJzKTtcbiAgICAgICAgZGVsZXRlTW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXkpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGhhbmRsZVJlcGx5LCBcImhhbmRsZVJlcGx5XCIpO1xuICAgICAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgfVxuICAgICAgX19uYW1lKHJlc3VtZSwgXCJyZXN1bWVcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKG1vY2tEaXNwYXRjaCwgXCJtb2NrRGlzcGF0Y2hcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2goKSB7XG4gICAgICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF07XG4gICAgICBjb25zdCBvcmlnaW4gPSB0aGlzW2tPcmlnaW5dO1xuICAgICAgY29uc3Qgb3JpZ2luYWxEaXNwYXRjaCA9IHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gZGlzcGF0Y2gob3B0cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1vY2tEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIE1vY2tOb3RNYXRjaGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV0Q29ubmVjdCA9IGFnZW50W2tHZXROZXRDb25uZWN0XSgpO1xuICAgICAgICAgICAgICBpZiAobmV0Q29ubmVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvcjIubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yMi5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBvcmlnaW4pYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9LCBcImRpc3BhdGNoXCIpO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRNb2NrRGlzcGF0Y2gsIFwiYnVpbGRNb2NrRGlzcGF0Y2hcIik7XG4gICAgZnVuY3Rpb24gY2hlY2tOZXRDb25uZWN0KG5ldENvbm5lY3QsIG9yaWdpbikge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChvcmlnaW4pO1xuICAgICAgaWYgKG5ldENvbm5lY3QgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV0Q29ubmVjdCkgJiYgbmV0Q29ubmVjdC5zb21lKChtYXRjaGVyKSA9PiBtYXRjaFZhbHVlKG1hdGNoZXIsIHVybC5ob3N0KSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShjaGVja05ldENvbm5lY3QsIFwiY2hlY2tOZXRDb25uZWN0XCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkTW9ja09wdGlvbnMob3B0cykge1xuICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBhZ2VudCwgLi4ubW9ja09wdGlvbnMgfSA9IG9wdHM7XG4gICAgICAgIHJldHVybiBtb2NrT3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkTW9ja09wdGlvbnMsIFwiYnVpbGRNb2NrT3B0aW9uc1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBnZXRSZXNwb25zZURhdGEsXG4gICAgICBnZXRNb2NrRGlzcGF0Y2gsXG4gICAgICBhZGRNb2NrRGlzcGF0Y2gsXG4gICAgICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gICAgICBidWlsZEtleSxcbiAgICAgIGdlbmVyYXRlS2V5VmFsdWVzLFxuICAgICAgbWF0Y2hWYWx1ZSxcbiAgICAgIGdldFJlc3BvbnNlLFxuICAgICAgZ2V0U3RhdHVzVGV4dCxcbiAgICAgIG1vY2tEaXNwYXRjaCxcbiAgICAgIGJ1aWxkTW9ja0Rpc3BhdGNoLFxuICAgICAgY2hlY2tOZXRDb25uZWN0LFxuICAgICAgYnVpbGRNb2NrT3B0aW9ucyxcbiAgICAgIGdldEhlYWRlckJ5TmFtZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanNcbnZhciByZXF1aXJlX21vY2tfaW50ZXJjZXB0b3IgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlX21vY2tfdXRpbHMoKTtcbiAgICB2YXIge1xuICAgICAga0Rpc3BhdGNoZXMsXG4gICAgICBrRGlzcGF0Y2hLZXksXG4gICAgICBrRGVmYXVsdEhlYWRlcnMsXG4gICAgICBrRGVmYXVsdFRyYWlsZXJzLFxuICAgICAga0NvbnRlbnRMZW5ndGgsXG4gICAgICBrTW9ja0Rpc3BhdGNoXG4gICAgfSA9IHJlcXVpcmVfbW9ja19zeW1ib2xzKCk7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsgYnVpbGRVUkwgfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgTW9ja1Njb3BlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IobW9ja0Rpc3BhdGNoKSB7XG4gICAgICAgIHRoaXNba01vY2tEaXNwYXRjaF0gPSBtb2NrRGlzcGF0Y2g7XG4gICAgICB9XG4gICAgICBkZWxheSh3YWl0SW5Ncykge1xuICAgICAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHdhaXRJbk1zKSB8fCB3YWl0SW5NcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwid2FpdEluTXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5NcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwZXJzaXN0KCkge1xuICAgICAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnBlcnNpc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRpbWVzKHJlcGVhdFRpbWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwZWF0VGltZXMgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJyZXBlYXRUaW1lcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trTW9ja0Rpc3BhdGNoXS50aW1lcyA9IHJlcGVhdFRpbWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrU2NvcGUsIFwiTW9ja1Njb3BlXCIpO1xuICAgIHZhciBNb2NrSW50ZXJjZXB0b3IgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJvcHRzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwib3B0cy5wYXRoIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgb3B0cy5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKG9wdHMucXVlcnkpIHtcbiAgICAgICAgICAgIG9wdHMucGF0aCA9IGJ1aWxkVVJMKG9wdHMucGF0aCwgb3B0cy5xdWVyeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwob3B0cy5wYXRoLCBcImRhdGE6Ly9cIik7XG4gICAgICAgICAgICBvcHRzLnBhdGggPSBwYXJzZWRVUkwucGF0aG5hbWUgKyBwYXJzZWRVUkwuc2VhcmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgb3B0cy5tZXRob2QgPSBvcHRzLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba0Rpc3BhdGNoS2V5XSA9IGJ1aWxkS2V5KG9wdHMpO1xuICAgICAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IG1vY2tEaXNwYXRjaGVzO1xuICAgICAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSB7fTtcbiAgICAgICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHt9O1xuICAgICAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShkYXRhKTtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyBcImNvbnRlbnQtbGVuZ3RoXCI6IHJlc3BvbnNlRGF0YS5sZW5ndGggfSA6IHt9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzW2tEZWZhdWx0SGVhZGVyc10sIC4uLmNvbnRlbnRMZW5ndGgsIC4uLnJlc3BvbnNlT3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXR1c0NvZGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzdGF0dXNDb2RlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJkYXRhIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlT3B0aW9ucyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInJlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVwbHkocmVwbHlEYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlEYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkRGF0YSA9IHJlcGx5RGF0YShvcHRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWREYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInJlcGx5IG9wdGlvbnMgY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlMiwgZGF0YTogZGF0YTIgPSBcIlwiLCByZXNwb25zZU9wdGlvbnM6IHJlc3BvbnNlT3B0aW9uczIgPSB7fSB9ID0gcmVzb2x2ZWREYXRhO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhzdGF0dXNDb2RlMiwgZGF0YTIsIHJlc3BvbnNlT3B0aW9uczIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZTIsIGRhdGEyLCByZXNwb25zZU9wdGlvbnMyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCBcIndyYXBwZWREZWZhdWx0c0NhbGxiYWNrXCIpO1xuICAgICAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaDIgPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzdGF0dXNDb2RlLCBkYXRhID0gXCJcIiwgcmVzcG9uc2VPcHRpb25zID0ge31dID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hEYXRhID0gdGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIGRpc3BhdGNoRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaCk7XG4gICAgICB9XG4gICAgICByZXBseVdpdGhFcnJvcihlcnJvcjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcjIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJlcnJvciBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHsgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRSZXBseUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJoZWFkZXJzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSBoZWFkZXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRSZXBseVRyYWlsZXJzKHRyYWlsZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhaWxlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ0cmFpbGVycyBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHRyYWlsZXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlcGx5Q29udGVudExlbmd0aCgpIHtcbiAgICAgICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrSW50ZXJjZXB0b3IsIFwiTW9ja0ludGVyY2VwdG9yXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3I7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1jbGllbnQuanNcbnZhciByZXF1aXJlX21vY2tfY2xpZW50ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWNsaWVudC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBwcm9taXNpZnk6IHByb21pc2lmeTQgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciBDbGllbnQgPSByZXF1aXJlX2NsaWVudCgpO1xuICAgIHZhciB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlX21vY2tfdXRpbHMoKTtcbiAgICB2YXIge1xuICAgICAga0Rpc3BhdGNoZXMsXG4gICAgICBrTW9ja0FnZW50LFxuICAgICAga0Nsb3NlLFxuICAgICAga09yaWdpbmFsQ2xvc2UsXG4gICAgICBrT3JpZ2luLFxuICAgICAga09yaWdpbmFsRGlzcGF0Y2gsXG4gICAgICBrQ29ubmVjdGVkXG4gICAgfSA9IHJlcXVpcmVfbW9ja19zeW1ib2xzKCk7XG4gICAgdmFyIHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlX21vY2tfaW50ZXJjZXB0b3IoKTtcbiAgICB2YXIgU3ltYm9scyA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBNb2NrQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBDbGllbnQge1xuICAgICAgY29uc3RydWN0b3Iob3JpZ2luLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9yaWdpbiwgb3B0cyk7XG4gICAgICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudDtcbiAgICAgICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpbjtcbiAgICAgICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXTtcbiAgICAgICAgdGhpc1trQ29ubmVjdGVkXSA9IDE7XG4gICAgICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaDtcbiAgICAgICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXTtcbiAgICAgIH1cbiAgICAgIGludGVyY2VwdChvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKG9wdHMsIHRoaXNba0Rpc3BhdGNoZXNdKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrQ2xvc2VdKCkge1xuICAgICAgICBhd2FpdCBwcm9taXNpZnk0KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpO1xuICAgICAgICB0aGlzW2tDb25uZWN0ZWRdID0gMDtcbiAgICAgICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoTW9ja0NsaWVudCwgXCJNb2NrQ2xpZW50XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE1vY2tDbGllbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qc1xudmFyIHJlcXVpcmVfbW9ja19wb29sID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgcHJvbWlzaWZ5OiBwcm9taXNpZnk0IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICB2YXIgUG9vbCA9IHJlcXVpcmVfcG9vbCgpO1xuICAgIHZhciB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlX21vY2tfdXRpbHMoKTtcbiAgICB2YXIge1xuICAgICAga0Rpc3BhdGNoZXMsXG4gICAgICBrTW9ja0FnZW50LFxuICAgICAga0Nsb3NlLFxuICAgICAga09yaWdpbmFsQ2xvc2UsXG4gICAgICBrT3JpZ2luLFxuICAgICAga09yaWdpbmFsRGlzcGF0Y2gsXG4gICAgICBrQ29ubmVjdGVkXG4gICAgfSA9IHJlcXVpcmVfbW9ja19zeW1ib2xzKCk7XG4gICAgdmFyIHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlX21vY2tfaW50ZXJjZXB0b3IoKTtcbiAgICB2YXIgU3ltYm9scyA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBNb2NrUG9vbCA9IGNsYXNzIGV4dGVuZHMgUG9vbCB7XG4gICAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3JpZ2luLCBvcHRzKTtcbiAgICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50O1xuICAgICAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luO1xuICAgICAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdO1xuICAgICAgICB0aGlzW2tDb25uZWN0ZWRdID0gMTtcbiAgICAgICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoO1xuICAgICAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV07XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdO1xuICAgICAgfVxuICAgICAgaW50ZXJjZXB0KG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pO1xuICAgICAgfVxuICAgICAgYXN5bmMgW2tDbG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHByb21pc2lmeTQodGhpc1trT3JpZ2luYWxDbG9zZV0pKCk7XG4gICAgICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwO1xuICAgICAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrUG9vbCwgXCJNb2NrUG9vbFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBNb2NrUG9vbDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGx1cmFsaXplci5qc1xudmFyIHJlcXVpcmVfcGx1cmFsaXplciA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGx1cmFsaXplci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgc2luZ3VsYXJzID0ge1xuICAgICAgcHJvbm91bjogXCJpdFwiLFxuICAgICAgaXM6IFwiaXNcIixcbiAgICAgIHdhczogXCJ3YXNcIixcbiAgICAgIHRoaXM6IFwidGhpc1wiXG4gICAgfTtcbiAgICB2YXIgcGx1cmFscyA9IHtcbiAgICAgIHByb25vdW46IFwidGhleVwiLFxuICAgICAgaXM6IFwiYXJlXCIsXG4gICAgICB3YXM6IFwid2VyZVwiLFxuICAgICAgdGhpczogXCJ0aGVzZVwiXG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGNsYXNzIFBsdXJhbGl6ZXIge1xuICAgICAgY29uc3RydWN0b3Ioc2luZ3VsYXIsIHBsdXJhbCkge1xuICAgICAgICB0aGlzLnNpbmd1bGFyID0gc2luZ3VsYXI7XG4gICAgICAgIHRoaXMucGx1cmFsID0gcGx1cmFsO1xuICAgICAgfVxuICAgICAgcGx1cmFsaXplKGNvdW50Mikge1xuICAgICAgICBjb25zdCBvbmUgPSBjb3VudDIgPT09IDE7XG4gICAgICAgIGNvbnN0IGtleXMyID0gb25lID8gc2luZ3VsYXJzIDogcGx1cmFscztcbiAgICAgICAgY29uc3Qgbm91biA9IG9uZSA/IHRoaXMuc2luZ3VsYXIgOiB0aGlzLnBsdXJhbDtcbiAgICAgICAgcmV0dXJuIHsgLi4ua2V5czIsIGNvdW50OiBjb3VudDIsIG5vdW4gfTtcbiAgICAgIH1cbiAgICB9LCBcIlBsdXJhbGl6ZXJcIik7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qc1xudmFyIHJlcXVpcmVfcGVuZGluZ19pbnRlcmNlcHRvcnNfZm9ybWF0dGVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7IENvbnNvbGUgfSA9IHJlcXVpcmUoXCJjb25zb2xlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoY2xhc3MgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcih7IGRpc2FibGVDb2xvcnMgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICAgICAgY2IobnVsbCwgY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IENvbnNvbGUoe1xuICAgICAgICAgIHN0ZG91dDogdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvbG9yczogIWRpc2FibGVDb2xvcnMgJiYgIXByb2Nlc3MuZW52LkNJXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvcm1hdChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgICAgIGNvbnN0IHdpdGhQcmV0dHlIZWFkZXJzID0gcGVuZGluZ0ludGVyY2VwdG9ycy5tYXAoXG4gICAgICAgICAgKHsgbWV0aG9kLCBwYXRoOiBwYXRoNywgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICAgICAgTWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBPcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgIFBhdGg6IHBhdGg3LFxuICAgICAgICAgICAgXCJTdGF0dXMgY29kZVwiOiBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgUGVyc2lzdGVudDogcGVyc2lzdCA/IFwiXFx1MjcwNVwiIDogXCJcXHUyNzRDXCIsXG4gICAgICAgICAgICBJbnZvY2F0aW9uczogdGltZXNJbnZva2VkLFxuICAgICAgICAgICAgUmVtYWluaW5nOiBwZXJzaXN0ID8gSW5maW5pdHkgOiB0aW1lcyAtIHRpbWVzSW52b2tlZFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRhYmxlKHdpdGhQcmV0dHlIZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sIFwiUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlclwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1hZ2VudC5qc1xudmFyIHJlcXVpcmVfbW9ja19hZ2VudCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1hZ2VudC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBrQ2xpZW50cyB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIEFnZW50ID0gcmVxdWlyZV9hZ2VudCgpO1xuICAgIHZhciB7XG4gICAgICBrQWdlbnQsXG4gICAgICBrTW9ja0FnZW50U2V0LFxuICAgICAga01vY2tBZ2VudEdldCxcbiAgICAgIGtEaXNwYXRjaGVzLFxuICAgICAga0lzTW9ja0FjdGl2ZSxcbiAgICAgIGtOZXRDb25uZWN0LFxuICAgICAga0dldE5ldENvbm5lY3QsXG4gICAgICBrT3B0aW9ucyxcbiAgICAgIGtGYWN0b3J5XG4gICAgfSA9IHJlcXVpcmVfbW9ja19zeW1ib2xzKCk7XG4gICAgdmFyIE1vY2tDbGllbnQgPSByZXF1aXJlX21vY2tfY2xpZW50KCk7XG4gICAgdmFyIE1vY2tQb29sID0gcmVxdWlyZV9tb2NrX3Bvb2woKTtcbiAgICB2YXIgeyBtYXRjaFZhbHVlLCBidWlsZE1vY2tPcHRpb25zIH0gPSByZXF1aXJlX21vY2tfdXRpbHMoKTtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlX2Rpc3BhdGNoZXIoKTtcbiAgICB2YXIgUGx1cmFsaXplciA9IHJlcXVpcmVfcGx1cmFsaXplcigpO1xuICAgIHZhciBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gcmVxdWlyZV9wZW5kaW5nX2ludGVyY2VwdG9yc19mb3JtYXR0ZXIoKTtcbiAgICB2YXIgRmFrZVdlYWtSZWYgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBkZXJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoRmFrZVdlYWtSZWYsIFwiRmFrZVdlYWtSZWZcIik7XG4gICAgdmFyIE1vY2tBZ2VudCA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWU7XG4gICAgICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlO1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmFnZW50ICYmIHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50ID0gb3B0cyAmJiBvcHRzLmFnZW50ID8gb3B0cy5hZ2VudCA6IG5ldyBBZ2VudChvcHRzKTtcbiAgICAgICAgdGhpc1trQWdlbnRdID0gYWdlbnQ7XG4gICAgICAgIHRoaXNba0NsaWVudHNdID0gYWdlbnRba0NsaWVudHNdO1xuICAgICAgICB0aGlzW2tPcHRpb25zXSA9IGJ1aWxkTW9ja09wdGlvbnMob3B0cyk7XG4gICAgICB9XG4gICAgICBnZXQob3JpZ2luKSB7XG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pO1xuICAgICAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKTtcbiAgICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0KG9wdHMub3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKTtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVuYWJsZU5ldENvbm5lY3QobWF0Y2hlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hdGNoZXIgPT09IFwiZnVuY3Rpb25cIiB8fCBtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpc1trTmV0Q29ubmVjdF0pKSB7XG4gICAgICAgICAgICB0aGlzW2tOZXRDb25uZWN0XS5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IFttYXRjaGVyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiVW5zdXBwb3J0ZWQgbWF0Y2hlci4gTXVzdCBiZSBvbmUgb2YgU3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRpc2FibGVOZXRDb25uZWN0KCkge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2V0IGlzTW9ja0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0lzTW9ja0FjdGl2ZV07XG4gICAgICB9XG4gICAgICBba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKSB7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIG5ldyBGYWtlV2Vha1JlZihkaXNwYXRjaGVyKSk7XG4gICAgICB9XG4gICAgICBba0ZhY3RvcnldKG9yaWdpbikge1xuICAgICAgICBjb25zdCBtb2NrT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhZ2VudDogdGhpcyB9LCB0aGlzW2tPcHRpb25zXSk7XG4gICAgICAgIHJldHVybiB0aGlzW2tPcHRpb25zXSAmJiB0aGlzW2tPcHRpb25zXS5jb25uZWN0aW9ucyA9PT0gMSA/IG5ldyBNb2NrQ2xpZW50KG9yaWdpbiwgbW9ja09wdGlvbnMpIDogbmV3IE1vY2tQb29sKG9yaWdpbiwgbW9ja09wdGlvbnMpO1xuICAgICAgfVxuICAgICAgW2tNb2NrQWdlbnRHZXRdKG9yaWdpbikge1xuICAgICAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQob3JpZ2luKTtcbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIHJldHVybiByZWYuZGVyZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShcImh0dHA6Ly9sb2NhbGhvc3Q6OTk5OVwiKTtcbiAgICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcik7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5TWF0Y2hlciwgbm9uRXhwbGljaXRSZWZdIG9mIEFycmF5LmZyb20odGhpc1trQ2xpZW50c10pKSB7XG4gICAgICAgICAgY29uc3Qgbm9uRXhwbGljaXREaXNwYXRjaGVyID0gbm9uRXhwbGljaXRSZWYuZGVyZWYoKTtcbiAgICAgICAgICBpZiAobm9uRXhwbGljaXREaXNwYXRjaGVyICYmIHR5cGVvZiBrZXlNYXRjaGVyICE9PSBcInN0cmluZ1wiICYmIG1hdGNoVmFsdWUoa2V5TWF0Y2hlciwgb3JpZ2luKSkge1xuICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9yaWdpbik7XG4gICAgICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcik7XG4gICAgICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IG5vbkV4cGxpY2l0RGlzcGF0Y2hlcltrRGlzcGF0Y2hlc107XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFtrR2V0TmV0Q29ubmVjdF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tOZXRDb25uZWN0XTtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdJbnRlcmNlcHRvcnMoKSB7XG4gICAgICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpLmZsYXRNYXAoKFtvcmlnaW4sIHNjb3BlXSkgPT4gc2NvcGUuZGVyZWYoKVtrRGlzcGF0Y2hlc10ubWFwKChkaXNwYXRjaCkgPT4gKHsgLi4uZGlzcGF0Y2gsIG9yaWdpbiB9KSkpLmZpbHRlcigoeyBwZW5kaW5nIH0pID0+IHBlbmRpbmcpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzKHsgcGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IG5ldyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyKCkgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdJbnRlcmNlcHRvcnMoKTtcbiAgICAgICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsdXJhbGl6ZXIgPSBuZXcgUGx1cmFsaXplcihcImludGVyY2VwdG9yXCIsIFwiaW50ZXJjZXB0b3JzXCIpLnBsdXJhbGl6ZShwZW5kaW5nLmxlbmd0aCk7XG4gICAgICAgIHRocm93IG5ldyBVbmRpY2lFcnJvcihgXG4ke3BsdXJhbGl6ZXIuY291bnR9ICR7cGx1cmFsaXplci5ub3VufSAke3BsdXJhbGl6ZXIuaXN9IHBlbmRpbmc6XG5cbiR7cGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlci5mb3JtYXQocGVuZGluZyl9XG5gLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoTW9ja0FnZW50LCBcIk1vY2tBZ2VudFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBNb2NrQWdlbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wcm94eS1hZ2VudC5qc1xudmFyIHJlcXVpcmVfcHJveHlfYWdlbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wcm94eS1hZ2VudC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBrQ2xvc2UsIGtEZXN0cm95IH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgQ2xpZW50ID0gcmVxdWlyZV9hZ2VudCgpO1xuICAgIHZhciBBZ2VudCA9IHJlcXVpcmVfYWdlbnQoKTtcbiAgICB2YXIgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlX2Rpc3BhdGNoZXJfYmFzZSgpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBidWlsZENvbm5lY3RvciA9IHJlcXVpcmVfY29ubmVjdCgpO1xuICAgIHZhciBrQWdlbnQgPSBTeW1ib2woXCJwcm94eSBhZ2VudFwiKTtcbiAgICB2YXIga0NsaWVudCA9IFN5bWJvbChcInByb3h5IGNsaWVudFwiKTtcbiAgICB2YXIga1Byb3h5SGVhZGVycyA9IFN5bWJvbChcInByb3h5IGhlYWRlcnNcIik7XG4gICAgdmFyIGtSZXF1ZXN0VGxzID0gU3ltYm9sKFwicmVxdWVzdCB0bHMgc2V0dGluZ3NcIik7XG4gICAgdmFyIGtQcm94eVRscyA9IFN5bWJvbChcInByb3h5IHRscyBzZXR0aW5nc1wiKTtcbiAgICB2YXIga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbChcImNvbm5lY3QgZW5kcG9pbnQgZnVuY3Rpb25cIik7XG4gICAgZnVuY3Rpb24gZGVmYXVsdFByb3RvY29sUG9ydChwcm90b2NvbCkge1xuICAgICAgcmV0dXJuIHByb3RvY29sID09PSBcImh0dHBzOlwiID8gNDQzIDogODA7XG4gICAgfVxuICAgIF9fbmFtZShkZWZhdWx0UHJvdG9jb2xQb3J0LCBcImRlZmF1bHRQcm90b2NvbFBvcnRcIik7XG4gICAgdmFyIFByb3h5QWdlbnQgPSBjbGFzcyBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG9wdHMgPSB7IHVyaTogb3B0cyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cyB8fCAhb3B0cy51cmkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJQcm94eSBvcHRzLnVyaSBpcyBtYW5kYXRvcnlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trUmVxdWVzdFRsc10gPSBvcHRzLnJlcXVlc3RUbHM7XG4gICAgICAgIHRoaXNba1Byb3h5VGxzXSA9IG9wdHMucHJveHlUbHM7XG4gICAgICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSB7fTtcbiAgICAgICAgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bXCJwcm94eS1hdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7b3B0cy5hdXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIHBvcnQgfSA9IG5ldyBVUkwob3B0cy51cmkpO1xuICAgICAgICBjb25zdCBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnByb3h5VGxzIH0pO1xuICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnJlcXVlc3RUbHMgfSk7XG4gICAgICAgIHRoaXNba0NsaWVudF0gPSBuZXcgQ2xpZW50KHsgb3JpZ2luOiBvcHRzLm9yaWdpbiwgY29ubmVjdCB9KTtcbiAgICAgICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KHtcbiAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgIGNvbm5lY3Q6IGFzeW5jIChvcHRzMiwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ZWRIb3N0ID0gb3B0czIuaG9zdDtcbiAgICAgICAgICAgIGlmICghb3B0czIucG9ydCkge1xuICAgICAgICAgICAgICByZXF1ZXN0ZWRIb3N0ICs9IGA6JHtkZWZhdWx0UHJvdG9jb2xQb3J0KG9wdHMyLnByb3RvY29sKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICAgICAgcGF0aDogcmVxdWVzdGVkSG9zdCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IG9wdHMyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAuLi50aGlzW2tQcm94eUhlYWRlcnNdLFxuICAgICAgICAgICAgICAgICAgaG9zdDogb3B0czIuaG9zdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgfSkuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKFwiUHJveHkgcmVzcG9uc2UgIT09IDIwMCB3aGVuIEhUVFAgVHVubmVsaW5nXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3B0czIucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgc2VydmVybmFtZTtcbiAgICAgICAgICAgICAgaWYgKHRoaXNba1JlcXVlc3RUbHNdKSB7XG4gICAgICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMyLnNlcnZlcm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSh7IC4uLm9wdHMyLCBzZXJ2ZXJuYW1lLCBodHRwU29ja2V0OiBzb2NrZXQgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKG9wdHMub3JpZ2luKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVyczIob3B0cy5oZWFkZXJzKTtcbiAgICAgICAgdGhyb3dJZlByb3h5QXV0aElzU2VudChoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICBob3N0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Nsb3NlXSgpIHtcbiAgICAgICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IHRoaXNba0NsaWVudF0uY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrRGVzdHJveV0oKSB7XG4gICAgICAgIGF3YWl0IHRoaXNba0FnZW50XS5kZXN0cm95KCk7XG4gICAgICAgIGF3YWl0IHRoaXNba0NsaWVudF0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFByb3h5QWdlbnQsIFwiUHJveHlBZ2VudFwiKTtcbiAgICBmdW5jdGlvbiBidWlsZEhlYWRlcnMyKGhlYWRlcnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnNQYWlyID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnNQYWlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZEhlYWRlcnMyLCBcImJ1aWxkSGVhZGVyc1wiKTtcbiAgICBmdW5jdGlvbiB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGV4aXN0UHJveHlBdXRoID0gaGVhZGVycyAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKS5maW5kKChrZXkpID0+IGtleS50b0xvd2VyQ2FzZSgpID09PSBcInByb3h5LWF1dGhvcml6YXRpb25cIik7XG4gICAgICBpZiAoZXhpc3RQcm94eUF1dGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiUHJveHktQXV0aG9yaXphdGlvbiBzaG91bGQgYmUgc2VudCBpbiBQcm94eUFnZW50IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodGhyb3dJZlByb3h5QXV0aElzU2VudCwgXCJ0aHJvd0lmUHJveHlBdXRoSXNTZW50XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFByb3h5QWdlbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanNcbnZhciByZXF1aXJlX2dsb2JhbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2dsb2JhbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoXCJ1bmRpY2kuZ2xvYmFsRGlzcGF0Y2hlci4xXCIpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBBZ2VudCA9IHJlcXVpcmVfYWdlbnQoKTtcbiAgICBpZiAoZ2V0R2xvYmFsRGlzcGF0Y2hlcigpID09PSB2b2lkIDApIHtcbiAgICAgIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IEFnZW50KCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyKGFnZW50KSB7XG4gICAgICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkFyZ3VtZW50IGFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50XCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbERpc3BhdGNoZXIsIHtcbiAgICAgICAgdmFsdWU6IGFnZW50LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoc2V0R2xvYmFsRGlzcGF0Y2hlciwgXCJzZXRHbG9iYWxEaXNwYXRjaGVyXCIpO1xuICAgIGZ1bmN0aW9uIGdldEdsb2JhbERpc3BhdGNoZXIoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEaXNwYXRjaGVyXTtcbiAgICB9XG4gICAgX19uYW1lKGdldEdsb2JhbERpc3BhdGNoZXIsIFwiZ2V0R2xvYmFsRGlzcGF0Y2hlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICAgICAgZ2V0R2xvYmFsRGlzcGF0Y2hlclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9oZWFkZXJzLmpzXG52YXIgcmVxdWlyZV9oZWFkZXJzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaGVhZGVycy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciB7IGtHdWFyZCB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIge1xuICAgICAgbWFrZUl0ZXJhdG9yLFxuICAgICAgaXNWYWxpZEhlYWRlck5hbWUsXG4gICAgICBpc1ZhbGlkSGVhZGVyVmFsdWVcbiAgICB9ID0gcmVxdWlyZV91dGlsMygpO1xuICAgIHZhciB7IHdlYmlkbCB9ID0gcmVxdWlyZV93ZWJpZGwoKTtcbiAgICB2YXIga0hlYWRlcnNNYXAgPSBTeW1ib2woXCJoZWFkZXJzIG1hcFwiKTtcbiAgICB2YXIga0hlYWRlcnNTb3J0ZWRNYXAgPSBTeW1ib2woXCJoZWFkZXJzIG1hcCBzb3J0ZWRcIik7XG4gICAgZnVuY3Rpb24gaGVhZGVyVmFsdWVOb3JtYWxpemUocG90ZW50aWFsVmFsdWUpIHtcbiAgICAgIHJldHVybiBwb3RlbnRpYWxWYWx1ZS5yZXBsYWNlKFxuICAgICAgICAvXltcXHJcXG5cXHQgXSt8W1xcclxcblxcdCBdKyQvZyxcbiAgICAgICAgXCJcIlxuICAgICAgKTtcbiAgICB9XG4gICAgX19uYW1lKGhlYWRlclZhbHVlTm9ybWFsaXplLCBcImhlYWRlclZhbHVlTm9ybWFsaXplXCIpO1xuICAgIGZ1bmN0aW9uIGZpbGwoaGVhZGVycywgb2JqZWN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIG9iamVjdCkge1xuICAgICAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogXCJIZWFkZXJzIGNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kICR7aGVhZGVyLmxlbmd0aH0uYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMgY29uc3RydWN0b3JcIixcbiAgICAgICAgICBhcmd1bWVudDogXCJBcmd1bWVudCAxXCIsXG4gICAgICAgICAgdHlwZXM6IFtcInNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PlwiLCBcInJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlwiXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZpbGwsIFwiZmlsbFwiKTtcbiAgICB2YXIgSGVhZGVyc0xpc3QgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdFtrSGVhZGVyc01hcF0pO1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gaW5pdFtrSGVhZGVyc1NvcnRlZE1hcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXQpO1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGFpbnMobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uaGFzKG5hbWUpO1xuICAgICAgfVxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNNYXBdLmNsZWFyKCk7XG4gICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGw7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGV4aXN0czQgPSB0aGlzW2tIZWFkZXJzTWFwXS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChleGlzdHM0KSB7XG4gICAgICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KG5hbWUsIGAke2V4aXN0czR9LCAke3ZhbHVlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChuYW1lLCBgJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbDtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBkZWxldGUobmFtZSkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGw7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgICBnZXQobmFtZSkge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hMyA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChuYW1lKSkgIT0gbnVsbCA/IF9hMyA6IG51bGw7XG4gICAgICB9XG4gICAgICBoYXMobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uaGFzKG5hbWUpO1xuICAgICAgfVxuICAgICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmtleXMoKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpO1xuICAgICAgfVxuICAgICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmVudHJpZXMoKTtcbiAgICAgIH1cbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF1bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEhlYWRlcnNMaXN0LCBcIkhlYWRlcnNMaXN0XCIpO1xuICAgIHZhciBIZWFkZXJzID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoaW5pdCA9IHZvaWQgMCkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzTGlzdF0gPSBuZXcgSGVhZGVyc0xpc3QoKTtcbiAgICAgICAgdGhpc1trR3VhcmRdID0gXCJub25lXCI7XG4gICAgICAgIGlmIChpbml0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQoaW5pdCk7XG4gICAgICAgICAgZmlsbCh0aGlzLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgICAgYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kJyBvbiAnSGVhZGVycyc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMuYXBwZW5kXCIsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyIG5hbWVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMuYXBwZW5kXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyIHZhbHVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trR3VhcmRdID09PSBcImltbXV0YWJsZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImltbXV0YWJsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09IFwicmVxdWVzdC1uby1jb3JzXCIpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBkZWxldGUobmFtZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RlbGV0ZScgb24gJ0hlYWRlcnMnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSk7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycy5kZWxldGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXIgbmFtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gXCJpbW11dGFibGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbW11dGFibGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSBcInJlcXVlc3Qtbm8tY29yc1wiKSB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzW2tIZWFkZXJzTGlzdF0uY29udGFpbnMobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgICBnZXQobmFtZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldCcgb24gJ0hlYWRlcnMnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSk7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycy5nZXRcIixcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXIgbmFtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgICBoYXMobmFtZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2hhcycgb24gJ0hlYWRlcnMnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSk7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycy5oYXNcIixcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXIgbmFtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKTtcbiAgICAgIH1cbiAgICAgIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0hlYWRlcnMnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgICAgIHByZWZpeDogXCJIZWFkZXJzLnNldFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlciBuYW1lXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgICAgIHByZWZpeDogXCJIZWFkZXJzLnNldFwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlciB2YWx1ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gXCJpbW11dGFibGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbW11dGFibGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSBcInJlcXVlc3Qtbm8tY29yc1wiKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZ2V0IFtrSGVhZGVyc1NvcnRlZE1hcF0oKSB7XG4gICAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgICAgKF9iMiA9IChfYTMgPSB0aGlzW2tIZWFkZXJzTGlzdF0pW2tIZWFkZXJzU29ydGVkTWFwXSkgIT0gbnVsbCA/IF9iMiA6IF9hM1trSGVhZGVyc1NvcnRlZE1hcF0gPSBuZXcgTWFwKFsuLi50aGlzW2tIZWFkZXJzTGlzdF1dLnNvcnQoKGEsIGIpID0+IGFbMF0gPCBiWzBdID8gLTEgOiAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdO1xuICAgICAgfVxuICAgICAga2V5cygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLmtleXMoKSwgXCJIZWFkZXJzXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWVzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpc1trSGVhZGVyc1NvcnRlZE1hcF0udmFsdWVzKCksIFwiSGVhZGVyc1wiKTtcbiAgICAgIH1cbiAgICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzW2tIZWFkZXJzU29ydGVkTWFwXS5lbnRyaWVzKCksIFwiSGVhZGVyc1wiKTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2goY2FsbGJhY2tGbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnSGVhZGVycyc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnSGVhZGVycyc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwga2V5LCB0aGlzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF07XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSGVhZGVycywgXCJIZWFkZXJzXCIpO1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG4gICAgICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgdmFsdWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgZW50cmllczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGZvckVhY2g6IGtFbnVtZXJhYmxlUHJvcGVydHlcbiAgICB9KTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdCA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSBcIk9iamVjdFwiKSB7XG4gICAgICAgIGlmIChWW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cIl0oVik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzW1wicmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XCJdKFYpO1xuICAgICAgfVxuICAgICAgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMgY29uc3RydWN0b3JcIixcbiAgICAgICAgYXJndW1lbnQ6IFwiQXJndW1lbnQgMVwiLFxuICAgICAgICB0eXBlczogW1wic2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XCIsIFwicmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XCJdXG4gICAgICB9KTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGZpbGwsXG4gICAgICBIZWFkZXJzLFxuICAgICAgSGVhZGVyc0xpc3RcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanNcbnZhciByZXF1aXJlX3Jlc3BvbnNlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgSGVhZGVycywgSGVhZGVyc0xpc3QsIGZpbGwgfSA9IHJlcXVpcmVfaGVhZGVycygpO1xuICAgIHZhciB7IGV4dHJhY3RCb2R5LCBjbG9uZUJvZHksIG1peGluQm9keSB9ID0gcmVxdWlyZV9ib2R5KCk7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWwyO1xuICAgIHZhciB7XG4gICAgICByZXNwb25zZVVSTCxcbiAgICAgIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gICAgICBpc0NhbmNlbGxlZCxcbiAgICAgIGlzQWJvcnRlZCxcbiAgICAgIGlzQmxvYkxpa2UsXG4gICAgICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gICAgICBpc0Vycm9yTGlrZVxuICAgIH0gPSByZXF1aXJlX3V0aWwzKCk7XG4gICAgdmFyIHtcbiAgICAgIHJlZGlyZWN0U3RhdHVzLFxuICAgICAgbnVsbEJvZHlTdGF0dXMsXG4gICAgICBET01FeGNlcHRpb25cbiAgICB9ID0gcmVxdWlyZV9jb25zdGFudHMoKTtcbiAgICB2YXIgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IHdlYmlkbCB9ID0gcmVxdWlyZV93ZWJpZGwoKTtcbiAgICB2YXIgeyBGb3JtRGF0YSB9ID0gcmVxdWlyZV9mb3JtZGF0YSgpO1xuICAgIHZhciB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsgdHlwZXMgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gfHwgcmVxdWlyZShcInN0cmVhbS93ZWJcIikuUmVhZGFibGVTdHJlYW07XG4gICAgdmFyIFJlc3BvbnNlID0gY2xhc3Mge1xuICAgICAgc3RhdGljIGVycm9yKCkge1xuICAgICAgICBjb25zdCByZWxldmFudFJlYWxtID0geyBzZXR0aW5nc09iamVjdDoge30gfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IG1ha2VOZXR3b3JrRXJyb3IoKTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG07XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdDtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSBcImltbXV0YWJsZVwiO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG07XG4gICAgICAgIHJldHVybiByZXNwb25zZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBqc29uKGRhdGEsIGluaXQgPSB7fSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdqc29uJyBvbiAnUmVzcG9uc2UnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgMCBwcmVzZW50LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoXCJ1dGYtOFwiKS5lbmNvZGUoXG4gICAgICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcyk7XG4gICAgICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9O1xuICAgICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSBcInJlc3BvbnNlXCI7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlT2JqZWN0LCBpbml0LCB7IGJvZHk6IGJvZHlbMF0sIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VPYmplY3Q7XG4gICAgICB9XG4gICAgICBzdGF0aWMgcmVkaXJlY3QodXJsLCBzdGF0dXMgPSAzMDIpIHtcbiAgICAgICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ3JlZGlyZWN0JyBvbiAnUmVzcG9uc2UnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybCk7XG4gICAgICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzW1widW5zaWduZWQgc2hvcnRcIl0oc3RhdHVzKTtcbiAgICAgICAgbGV0IHBhcnNlZFVSTDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSBcIiArIHVybCksIHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG07XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gXCJpbW11dGFibGVcIjtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZWRVUkwudG9TdHJpbmcoKTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoXCJsb2NhdGlvblwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdG9yKGJvZHkgPSBudWxsLCBpbml0ID0ge30pIHtcbiAgICAgICAgaWYgKGJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICBib2R5ID0gd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KTtcbiAgICAgICAgdGhpc1trUmVhbG1dID0geyBzZXR0aW5nc09iamVjdDoge30gfTtcbiAgICAgICAgdGhpc1trU3RhdGVdID0gbWFrZVJlc3BvbnNlKHt9KTtcbiAgICAgICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycygpO1xuICAgICAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gXCJyZXNwb25zZVwiO1xuICAgICAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gdGhpc1trU3RhdGVdLmhlYWRlcnNMaXN0O1xuICAgICAgICB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dO1xuICAgICAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpO1xuICAgICAgICAgIGJvZHlXaXRoVHlwZSA9IHsgYm9keTogZXh0cmFjdGVkQm9keSwgdHlwZSB9O1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxpemVSZXNwb25zZSh0aGlzLCBpbml0LCBib2R5V2l0aFR5cGUpO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udHlwZTtcbiAgICAgIH1cbiAgICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cmwgPSByZXNwb25zZVVSTCh0aGlzW2tTdGF0ZV0pO1xuICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGdldCByZWRpcmVjdGVkKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnVybExpc3QubGVuZ3RoID4gMTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzO1xuICAgICAgfVxuICAgICAgZ2V0IG9rKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1trU3RhdGVdLnN0YXR1cyA8PSAyOTk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHVzVGV4dCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNUZXh0O1xuICAgICAgfVxuICAgICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXTtcbiAgICAgIH1cbiAgICAgIGNsb25lKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCB0aGlzLmJvZHkgJiYgdGhpcy5ib2R5LmxvY2tlZCkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJSZXNwb25zZS5jbG9uZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UodGhpc1trU3RhdGVdKTtcbiAgICAgICAgY29uc3QgY2xvbmVkUmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKTtcbiAgICAgICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IGNsb25lZFJlc3BvbnNlO1xuICAgICAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrUmVhbG1dID0gdGhpc1trUmVhbG1dO1xuICAgICAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IGNsb25lZFJlc3BvbnNlLmhlYWRlcnNMaXN0O1xuICAgICAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IHRoaXNba0hlYWRlcnNdW2tHdWFyZF07XG4gICAgICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXTtcbiAgICAgICAgcmV0dXJuIGNsb25lZFJlc3BvbnNlT2JqZWN0O1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlc3BvbnNlLCBcIlJlc3BvbnNlXCIpO1xuICAgIG1peGluQm9keShSZXNwb25zZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG4gICAgICB0eXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgc3RhdHVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgb2s6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgc3RhdHVzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNsb25lUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJSZXNwb25zZShcbiAgICAgICAgICBjbG9uZVJlc3BvbnNlKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpLFxuICAgICAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgLi4ucmVzcG9uc2UsIGJvZHk6IG51bGwgfSk7XG4gICAgICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkocmVzcG9uc2UuYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UmVzcG9uc2U7XG4gICAgfVxuICAgIF9fbmFtZShjbG9uZVJlc3BvbnNlLCBcImNsb25lUmVzcG9uc2VcIik7XG4gICAgZnVuY3Rpb24gbWFrZVJlc3BvbnNlKGluaXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIHRpbWluZ0FsbG93UGFzc2VkOiBmYWxzZSxcbiAgICAgICAgcmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIHRpbWluZ0luZm86IG51bGwsXG4gICAgICAgIGNhY2hlU3RhdGU6IFwiXCIsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiXCIsXG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0ID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpIDogbmV3IEhlYWRlcnNMaXN0KCksXG4gICAgICAgIHVybExpc3Q6IGluaXQudXJsTGlzdCA/IFsuLi5pbml0LnVybExpc3RdIDogW11cbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShtYWtlUmVzcG9uc2UsIFwibWFrZVJlc3BvbnNlXCIpO1xuICAgIGZ1bmN0aW9uIG1ha2VOZXR3b3JrRXJyb3IocmVhc29uKSB7XG4gICAgICBjb25zdCBpc0Vycm9yMiA9IGlzRXJyb3JMaWtlKHJlYXNvbik7XG4gICAgICByZXR1cm4gbWFrZVJlc3BvbnNlKHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgIGVycm9yOiBpc0Vycm9yMiA/IHJlYXNvbiA6IG5ldyBFcnJvcihyZWFzb24gPyBTdHJpbmcocmVhc29uKSA6IHJlYXNvbiwge1xuICAgICAgICAgIGNhdXNlOiBpc0Vycm9yMiA/IHJlYXNvbiA6IHZvaWQgMFxuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnRlZDogcmVhc29uICYmIHJlYXNvbi5uYW1lID09PSBcIkFib3J0RXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShtYWtlTmV0d29ya0Vycm9yLCBcIm1ha2VOZXR3b3JrRXJyb3JcIik7XG4gICAgZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgaW50ZXJuYWxSZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgIC4uLnN0YXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgaW4gc3RhdGUgPyBzdGF0ZVtwXSA6IHRhcmdldFtwXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgICAgICBhc3NlcnQoIShwIGluIHN0YXRlKSk7XG4gICAgICAgICAgdGFyZ2V0W3BdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUobWFrZUZpbHRlcmVkUmVzcG9uc2UsIFwibWFrZUZpbHRlcmVkUmVzcG9uc2VcIik7XG4gICAgZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcImJhc2ljXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAgICAgdHlwZTogXCJiYXNpY1wiLFxuICAgICAgICAgIGhlYWRlcnNMaXN0OiByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb3JzXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAgICAgdHlwZTogXCJjb3JzXCIsXG4gICAgICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9wYXF1ZVwiKSB7XG4gICAgICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgICAgIHR5cGU6IFwib3BhcXVlXCIsXG4gICAgICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IFwiXCIsXG4gICAgICAgICAgYm9keTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvcGFxdWVyZWRpcmVjdFwiKSB7XG4gICAgICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgICAgIHR5cGU6IFwib3BhcXVlcmVkaXJlY3RcIixcbiAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgc3RhdHVzVGV4dDogXCJcIixcbiAgICAgICAgICBoZWFkZXJzTGlzdDogW10sXG4gICAgICAgICAgYm9keTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaWx0ZXJSZXNwb25zZSwgXCJmaWx0ZXJSZXNwb25zZVwiKTtcbiAgICBmdW5jdGlvbiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpIHtcbiAgICAgIGFzc2VydChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpO1xuICAgICAgcmV0dXJuIGlzQWJvcnRlZChmZXRjaFBhcmFtcykgPyBtYWtlTmV0d29ya0Vycm9yKG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIikpIDogbWFrZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZWQucmVhc29uKTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciwgXCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3JcIik7XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gICAgICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5pdFtcInN0YXR1c1wiXSBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiAyMDAgdG8gNTk5LCBpbmNsdXNpdmUuJyk7XG4gICAgICB9XG4gICAgICBpZiAoXCJzdGF0dXNUZXh0XCIgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzVmFsaWRSZWFzb25QaHJhc2UoU3RyaW5nKGluaXQuc3RhdHVzVGV4dCkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzVGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwic3RhdHVzXCIgaW4gaW5pdCAmJiBpbml0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzID0gaW5pdC5zdGF0dXM7XG4gICAgICB9XG4gICAgICBpZiAoXCJzdGF0dXNUZXh0XCIgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgICAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHQ7XG4gICAgICB9XG4gICAgICBpZiAoXCJoZWFkZXJzXCIgaW4gaW5pdCAmJiBpbml0LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICBmaWxsKHJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QsIGluaXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICBpZiAobnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJSZXNwb25zZSBjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2Vba1N0YXRlXS5ib2R5ID0gYm9keS5ib2R5O1xuICAgICAgICBpZiAoYm9keS50eXBlICE9IG51bGwgJiYgIXJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgICAgICAgcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoXCJjb250ZW50LXR5cGVcIiwgYm9keS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5pdGlhbGl6ZVJlc3BvbnNlLCBcImluaXRpYWxpemVSZXNwb25zZVwiKTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5SZWFkYWJsZVN0cmVhbSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gICAgICBSZWFkYWJsZVN0cmVhbVxuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICAgICAgRm9ybURhdGFcbiAgICApO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gICAgICBVUkxTZWFyY2hQYXJhbXNcbiAgICApO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQgPSBmdW5jdGlvbihWKSB7XG4gICAgICBpZiAodHlwZW9mIFYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikgfHwgdHlwZXMuaXNUeXBlZEFycmF5KFYpIHx8IHR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKTtcbiAgICAgIH1cbiAgICAgIGlmIChWIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhKFYpO1xuICAgICAgfVxuICAgICAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyhWKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoVik7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdCA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGlmIChWIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYpO1xuICAgICAgfVxuICAgICAgaWYgKFYgPT0gbnVsbCA/IHZvaWQgMCA6IFZbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBWO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQoVik7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gICAgICB7XG4gICAgICAgIGtleTogXCJzdGF0dXNcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1tcInVuc2lnbmVkIHNob3J0XCJdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDIwMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcInN0YXR1c1RleHRcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJoZWFkZXJzXCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgICAgIH1cbiAgICBdKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBtYWtlTmV0d29ya0Vycm9yLFxuICAgICAgbWFrZVJlc3BvbnNlLFxuICAgICAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICAgICAgZmlsdGVyUmVzcG9uc2UsXG4gICAgICBSZXNwb25zZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXF1ZXN0LmpzXG52YXIgcmVxdWlyZV9yZXF1ZXN0MiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3JlcXVlc3QuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgZXh0cmFjdEJvZHksIG1peGluQm9keSwgY2xvbmVCb2R5IH0gPSByZXF1aXJlX2JvZHkoKTtcbiAgICB2YXIgeyBIZWFkZXJzLCBmaWxsOiBmaWxsSGVhZGVycywgSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmVfaGVhZGVycygpO1xuICAgIHZhciB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlX2Rpc3BhdGNoZXJfd2Vha3JlZigpKCk7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7XG4gICAgICBpc1ZhbGlkSFRUUFRva2VuLFxuICAgICAgc2FtZU9yaWdpbixcbiAgICAgIG5vcm1hbGl6ZU1ldGhvZFxuICAgIH0gPSByZXF1aXJlX3V0aWwzKCk7XG4gICAgdmFyIHtcbiAgICAgIGZvcmJpZGRlbk1ldGhvZHMsXG4gICAgICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gICAgICByZWZlcnJlclBvbGljeSxcbiAgICAgIHJlcXVlc3RSZWRpcmVjdCxcbiAgICAgIHJlcXVlc3RNb2RlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdENhY2hlXG4gICAgfSA9IHJlcXVpcmVfY29uc3RhbnRzKCk7XG4gICAgdmFyIHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbDI7XG4gICAgdmFyIHsga0hlYWRlcnMsIGtTaWduYWwsIGtTdGF0ZSwga0d1YXJkLCBrUmVhbG0gfSA9IHJlcXVpcmVfc3ltYm9sczIoKTtcbiAgICB2YXIgeyB3ZWJpZGwgfSA9IHJlcXVpcmVfd2ViaWRsKCk7XG4gICAgdmFyIHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgVHJhbnNmb3JtU3RyZWFtO1xuICAgIHZhciBrSW5pdCA9IFN5bWJvbChcImluaXRcIik7XG4gICAgdmFyIHJlcXVlc3RGaW5hbGl6ZXIgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHsgc2lnbmFsLCBhYm9ydCB9KSA9PiB7XG4gICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgICB9KTtcbiAgICB2YXIgUmVxdWVzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGlucHV0LCBpbml0ID0ge30pIHtcbiAgICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgICBpZiAoaW5wdXQgPT09IGtJbml0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0KTtcbiAgICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQpO1xuICAgICAgICB0aGlzW2tSZWFsbV0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9O1xuICAgICAgICBsZXQgcmVxdWVzdDIgPSBudWxsO1xuICAgICAgICBsZXQgZmFsbGJhY2tNb2RlID0gbnVsbDtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5iYXNlVXJsO1xuICAgICAgICBsZXQgc2lnbmFsID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGxldCBwYXJzZWRVUkw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQsIGJhc2VVcmwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSBcIiArIGlucHV0LCB7IGNhdXNlOiBlcnIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgfHwgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBcIlJlcXVlc3QgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBVUkwgdGhhdCBpbmNsdWRlcyBjcmVkZW50aWFsczogXCIgKyBpbnB1dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdDIgPSBtYWtlUmVxdWVzdCh7IHVybExpc3Q6IFtwYXJzZWRVUkxdIH0pO1xuICAgICAgICAgIGZhbGxiYWNrTW9kZSA9IFwiY29yc1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpO1xuICAgICAgICAgIHJlcXVlc3QyID0gaW5wdXRba1N0YXRlXTtcbiAgICAgICAgICBzaWduYWwgPSBpbnB1dFtrU2lnbmFsXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3Qub3JpZ2luO1xuICAgICAgICBsZXQgd2luZG93MiA9IFwiY2xpZW50XCI7XG4gICAgICAgIGlmICgoKF9iMiA9IChfYTMgPSByZXF1ZXN0Mi53aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIubmFtZSkgPT09IFwiRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFwiICYmIHNhbWVPcmlnaW4ocmVxdWVzdDIud2luZG93LCBvcmlnaW4pKSB7XG4gICAgICAgICAgd2luZG93MiA9IHJlcXVlc3QyLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC53aW5kb3cgIT09IHZvaWQgMCAmJiBpbml0LndpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ3dpbmRvdycgb3B0aW9uICcke3dpbmRvdzJ9JyBtdXN0IGJlIG51bGxgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC53aW5kb3cgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHdpbmRvdzIgPSBcIm5vLXdpbmRvd1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QyID0gbWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdDIubWV0aG9kLFxuICAgICAgICAgIGhlYWRlcnNMaXN0OiByZXF1ZXN0Mi5oZWFkZXJzTGlzdCxcbiAgICAgICAgICB1bnNhZmVSZXF1ZXN0OiByZXF1ZXN0Mi51bnNhZmVSZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudDogdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LFxuICAgICAgICAgIHdpbmRvdzogd2luZG93MixcbiAgICAgICAgICBwcmlvcml0eTogcmVxdWVzdDIucHJpb3JpdHksXG4gICAgICAgICAgb3JpZ2luOiByZXF1ZXN0Mi5vcmlnaW4sXG4gICAgICAgICAgcmVmZXJyZXI6IHJlcXVlc3QyLnJlZmVycmVyLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICBtb2RlOiByZXF1ZXN0Mi5tb2RlLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiByZXF1ZXN0Mi5jcmVkZW50aWFscyxcbiAgICAgICAgICBjYWNoZTogcmVxdWVzdDIuY2FjaGUsXG4gICAgICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QyLnJlZGlyZWN0LFxuICAgICAgICAgIGludGVncml0eTogcmVxdWVzdDIuaW50ZWdyaXR5LFxuICAgICAgICAgIGtlZXBhbGl2ZTogcmVxdWVzdDIua2VlcGFsaXZlLFxuICAgICAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QyLnJlbG9hZE5hdmlnYXRpb24sXG4gICAgICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QyLmhpc3RvcnlOYXZpZ2F0aW9uLFxuICAgICAgICAgIHVybExpc3Q6IFsuLi5yZXF1ZXN0Mi51cmxMaXN0XVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocmVxdWVzdDIubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0Mi5tb2RlID0gXCJzYW1lLW9yaWdpblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0Mi5yZWxvYWROYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgcmVxdWVzdDIuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICByZXF1ZXN0Mi5vcmlnaW4gPSBcImNsaWVudFwiO1xuICAgICAgICAgIHJlcXVlc3QyLnJlZmVycmVyID0gXCJjbGllbnRcIjtcbiAgICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSA9IFwiXCI7XG4gICAgICAgICAgcmVxdWVzdDIudXJsID0gcmVxdWVzdDIudXJsTGlzdFtyZXF1ZXN0Mi51cmxMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHJlcXVlc3QyLnVybExpc3QgPSBbcmVxdWVzdDIudXJsXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyO1xuICAgICAgICAgIGlmIChyZWZlcnJlciA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmVxdWVzdDIucmVmZXJyZXIgPSBcIm5vLXJlZmVycmVyXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRSZWZlcnJlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlciwgYmFzZVVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke3JlZmVycmVyfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLCB7IGNhdXNlOiBlcnIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlciA9IHBhcnNlZFJlZmVycmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5yZWZlcnJlclBvbGljeSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVxdWVzdDIucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5O1xuICAgICAgICAgIGlmICghcmVmZXJyZXJQb2xpY3kuaW5jbHVkZXMocmVxdWVzdDIucmVmZXJyZXJQb2xpY3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IFRoZSBwcm92aWRlZCB2YWx1ZSAnJHtyZXF1ZXN0Mi5yZWZlcnJlclBvbGljeX0nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBSZWZlcnJlclBvbGljeS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgaWYgKGluaXQubW9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbW9kZSA9IGluaXQubW9kZTtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RNb2RlLmluY2x1ZGVzKG1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IFRoZSBwcm92aWRlZCB2YWx1ZSAnJHtyZXF1ZXN0Mi5tb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIFJlcXVlc3RNb2RlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSBmYWxsYmFja01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgPT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJSZXF1ZXN0IGNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcImludmFsaWQgcmVxdWVzdCBtb2RlIG5hdmlnYXRlLlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJlcXVlc3QyLm1vZGUgPSBtb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LmNyZWRlbnRpYWxzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXF1ZXN0Mi5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHM7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0Q3JlZGVudGlhbHMuaW5jbHVkZXMocmVxdWVzdDIuY3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IFRoZSBwcm92aWRlZCB2YWx1ZSAnJHtyZXF1ZXN0Mi5jcmVkZW50aWFsc30nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBSZXF1ZXN0Q3JlZGVudGlhbHMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQuY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlcXVlc3QyLmNhY2hlID0gaW5pdC5jYWNoZTtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RDYWNoZS5pbmNsdWRlcyhyZXF1ZXN0Mi5jYWNoZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogVGhlIHByb3ZpZGVkIHZhbHVlICcke3JlcXVlc3QyLmNhY2hlfScgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIFJlcXVlc3RDYWNoZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdDIuY2FjaGUgPT09IFwib25seS1pZi1jYWNoZWRcIiAmJiByZXF1ZXN0Mi5tb2RlICE9PSBcInNhbWUtb3JpZ2luXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCInb25seS1pZi1jYWNoZWQnIGNhbiBiZSBzZXQgb25seSB3aXRoICdzYW1lLW9yaWdpbicgbW9kZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5yZWRpcmVjdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVxdWVzdDIucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0O1xuICAgICAgICAgIGlmICghcmVxdWVzdFJlZGlyZWN0LmluY2x1ZGVzKHJlcXVlc3QyLnJlZGlyZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiBUaGUgcHJvdmlkZWQgdmFsdWUgJyR7cmVxdWVzdDIucmVkaXJlY3R9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgUmVxdWVzdFJlZGlyZWN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LmludGVncml0eSAhPT0gdm9pZCAwICYmIGluaXQuaW50ZWdyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICByZXF1ZXN0Mi5pbnRlZ3JpdHkgPSBTdHJpbmcoaW5pdC5pbnRlZ3JpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LmtlZXBhbGl2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVxdWVzdDIua2VlcGFsaXZlID0gQm9vbGVhbihpbml0LmtlZXBhbGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQubWV0aG9kICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBsZXQgbWV0aG9kID0gaW5pdC5tZXRob2Q7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKGluaXQubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKGAnJHtpbml0Lm1ldGhvZH0nIGlzIG5vdCBhIHZhbGlkIEhUVFAgbWV0aG9kLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9yYmlkZGVuTWV0aG9kcy5pbmRleE9mKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihgJyR7aW5pdC5tZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKGluaXQubWV0aG9kKTtcbiAgICAgICAgICByZXF1ZXN0Mi5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQuc2lnbmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBzaWduYWwgPSBpbml0LnNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tTdGF0ZV0gPSByZXF1ZXN0MjtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXNba1NpZ25hbF0gPSBhYy5zaWduYWw7XG4gICAgICAgIHRoaXNba1NpZ25hbF1ba1JlYWxtXSA9IHRoaXNba1JlYWxtXTtcbiAgICAgICAgaWYgKHNpZ25hbCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFzaWduYWwgfHwgdHlwZW9mIHNpZ25hbC5hYm9ydGVkICE9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogbWVtYmVyIHNpZ25hbCBpcyBub3Qgb2YgdHlwZSBBYm9ydFNpZ25hbC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYy5hYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYWJvcnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IGFjLmFib3J0KHNpZ25hbC5yZWFzb24pLCBcImFib3J0XCIpO1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmVxdWVzdEZpbmFsaXplci5yZWdpc3Rlcih0aGlzLCB7IHNpZ25hbCwgYWJvcnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlcXVlc3QyLmhlYWRlcnNMaXN0O1xuICAgICAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gXCJyZXF1ZXN0XCI7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV07XG4gICAgICAgIGlmIChtb2RlID09PSBcIm5vLWNvcnNcIikge1xuICAgICAgICAgIGlmICghY29yc1NhZmVMaXN0ZWRNZXRob2RzLmluY2x1ZGVzKHJlcXVlc3QyLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGAnJHtyZXF1ZXN0Mi5tZXRob2R9IGlzIHVuc3VwcG9ydGVkIGluIG5vLWNvcnMgbW9kZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gXCJyZXF1ZXN0LW5vLWNvcnNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzW2tIZWFkZXJzXSk7XG4gICAgICAgICAgaWYgKGluaXQuaGVhZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdLmNsZWFyKCk7XG4gICAgICAgICAgaWYgKGhlYWRlcnMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJIZWFkZXJzXCIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxIZWFkZXJzKHRoaXNba0hlYWRlcnNdLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRCb2R5ID0gaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXRba1N0YXRlXS5ib2R5IDogbnVsbDtcbiAgICAgICAgaWYgKChpbml0LmJvZHkgIT09IHZvaWQgMCAmJiBpbml0LmJvZHkgIT0gbnVsbCB8fCBpbnB1dEJvZHkgIT0gbnVsbCkgJiYgKHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCByZXF1ZXN0Mi5tZXRob2QgPT09IFwiSEVBRFwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbml0Qm9keSA9IG51bGw7XG4gICAgICAgIGlmIChpbml0LmJvZHkgIT09IHZvaWQgMCAmJiBpbml0LmJvZHkgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShcbiAgICAgICAgICAgIGluaXQuYm9keSxcbiAgICAgICAgICAgIHJlcXVlc3QyLmtlZXBhbGl2ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5pdEJvZHkgPSBleHRyYWN0ZWRCb2R5O1xuICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhdGhpc1trSGVhZGVyc10uaGFzKFwiY29udGVudC10eXBlXCIpKSB7XG4gICAgICAgICAgICB0aGlzW2tIZWFkZXJzXS5hcHBlbmQoXCJjb250ZW50LXR5cGVcIiwgY29udGVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dE9ySW5pdEJvZHkgPSBpbml0Qm9keSAhPSBudWxsID8gaW5pdEJvZHkgOiBpbnB1dEJvZHk7XG4gICAgICAgIGlmIChpbnB1dE9ySW5pdEJvZHkgIT0gbnVsbCAmJiBpbnB1dE9ySW5pdEJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdDIubW9kZSAhPT0gXCJzYW1lLW9yaWdpblwiICYmIHJlcXVlc3QyLm1vZGUgIT09IFwiY29yc1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnSWYgcmVxdWVzdCBpcyBtYWRlIGZyb20gUmVhZGFibGVTdHJlYW0sIG1vZGUgc2hvdWxkIGJlIFwic2FtZS1vcmlnaW5cIiBvciBcImNvcnNcIidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QyLnVzZUNPUlNQcmVmbGlnaHRGbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmluYWxCb2R5ID0gaW5wdXRPckluaXRCb2R5O1xuICAgICAgICBpZiAoaW5pdEJvZHkgPT0gbnVsbCAmJiBpbnB1dEJvZHkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh1dGlsMi5pc0Rpc3R1cmJlZChpbnB1dEJvZHkuc3RyZWFtKSB8fCBpbnB1dEJvZHkuc3RyZWFtLmxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJDYW5ub3QgY29uc3RydWN0IGEgUmVxdWVzdCB3aXRoIGEgUmVxdWVzdCBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVHJhbnNmb3JtU3RyZWFtKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKS5UcmFuc2Zvcm1TdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICAgIGlucHV0Qm9keS5zdHJlYW0ucGlwZVRocm91Z2goaWRlbnRpdHlUcmFuc2Zvcm0pO1xuICAgICAgICAgIGZpbmFsQm9keSA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogaW5wdXRCb2R5LnNvdXJjZSxcbiAgICAgICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgICAgIHN0cmVhbTogaWRlbnRpdHlUcmFuc2Zvcm0ucmVhZGFibGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba1N0YXRlXS5ib2R5ID0gZmluYWxCb2R5O1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLm1ldGhvZDtcbiAgICAgIH1cbiAgICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS51cmwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXTtcbiAgICAgIH1cbiAgICAgIGdldCBkZXN0aW5hdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmRlc3RpbmF0aW9uO1xuICAgICAgfVxuICAgICAgZ2V0IHJlZmVycmVyKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09IFwibm8tcmVmZXJyZXJcIikge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09IFwiY2xpZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJhYm91dDpjbGllbnRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBnZXQgcmVmZXJyZXJQb2xpY3koKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlclBvbGljeTtcbiAgICAgIH1cbiAgICAgIGdldCBtb2RlKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubW9kZTtcbiAgICAgIH1cbiAgICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jcmVkZW50aWFscztcbiAgICAgIH1cbiAgICAgIGdldCBjYWNoZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNhY2hlO1xuICAgICAgfVxuICAgICAgZ2V0IHJlZGlyZWN0KCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVkaXJlY3Q7XG4gICAgICB9XG4gICAgICBnZXQgaW50ZWdyaXR5KCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaW50ZWdyaXR5O1xuICAgICAgfVxuICAgICAgZ2V0IGtlZXBhbGl2ZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmtlZXBhbGl2ZTtcbiAgICAgIH1cbiAgICAgIGdldCBpc1JlbG9hZE5hdmlnYXRpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWxvYWROYXZpZ2F0aW9uO1xuICAgICAgfVxuICAgICAgZ2V0IGlzSGlzdG9yeU5hdmlnYXRpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5oaXN0b3J5TmF2aWdhdGlvbjtcbiAgICAgIH1cbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1NpZ25hbF07XG4gICAgICB9XG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCAoKF9hMyA9IHRoaXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5sb2NrZWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVudXNhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpc1trU3RhdGVdKTtcbiAgICAgICAgY29uc3QgY2xvbmVkUmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGtJbml0KTtcbiAgICAgICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVxdWVzdDtcbiAgICAgICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrUmVhbG1dID0gdGhpc1trUmVhbG1dO1xuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSBjbG9uZWRSZXF1ZXN0LmhlYWRlcnNMaXN0O1xuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gdGhpc1trSGVhZGVyc11ba0d1YXJkXTtcbiAgICAgICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba0hlYWRlcnNdW2tSZWFsbV07XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgYWMuYWJvcnQodGhpcy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU2lnbmFsXSA9IGFjLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIGNsb25lZFJlcXVlc3RPYmplY3Q7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVxdWVzdCwgXCJSZXF1ZXN0XCIpO1xuICAgIG1peGluQm9keShSZXF1ZXN0KTtcbiAgICBmdW5jdGlvbiBtYWtlUmVxdWVzdChpbml0KSB7XG4gICAgICBjb25zdCByZXF1ZXN0MiA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBsb2NhbFVSTHNPbmx5OiBmYWxzZSxcbiAgICAgICAgdW5zYWZlUmVxdWVzdDogZmFsc2UsXG4gICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgIGNsaWVudDogbnVsbCxcbiAgICAgICAgcmVzZXJ2ZWRDbGllbnQ6IG51bGwsXG4gICAgICAgIHJlcGxhY2VzQ2xpZW50SWQ6IFwiXCIsXG4gICAgICAgIHdpbmRvdzogXCJjbGllbnRcIixcbiAgICAgICAga2VlcGFsaXZlOiBmYWxzZSxcbiAgICAgICAgc2VydmljZVdvcmtlcnM6IFwiYWxsXCIsXG4gICAgICAgIGluaXRpYXRvcjogXCJcIixcbiAgICAgICAgZGVzdGluYXRpb246IFwiXCIsXG4gICAgICAgIHByaW9yaXR5OiBudWxsLFxuICAgICAgICBvcmlnaW46IFwiY2xpZW50XCIsXG4gICAgICAgIHBvbGljeUNvbnRhaW5lcjogXCJjbGllbnRcIixcbiAgICAgICAgcmVmZXJyZXI6IFwiY2xpZW50XCIsXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBcIlwiLFxuICAgICAgICBtb2RlOiBcIm5vLWNvcnNcIixcbiAgICAgICAgdXNlQ09SU1ByZWZsaWdodEZsYWc6IGZhbHNlLFxuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICB1c2VDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgIGNhY2hlOiBcImRlZmF1bHRcIixcbiAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgIGludGVncml0eTogXCJcIixcbiAgICAgICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiBcIlwiLFxuICAgICAgICBwYXJzZXJNZXRhZGF0YTogXCJcIixcbiAgICAgICAgcmVsb2FkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIGhpc3RvcnlOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgdXNlckFjdGl2YXRpb246IGZhbHNlLFxuICAgICAgICB0YWludGVkT3JpZ2luOiBmYWxzZSxcbiAgICAgICAgcmVkaXJlY3RDb3VudDogMCxcbiAgICAgICAgcmVzcG9uc2VUYWludGluZzogXCJiYXNpY1wiLFxuICAgICAgICBwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbjogZmFsc2UsXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB0aW1pbmdBbGxvd0ZhaWxlZDogZmFsc2UsXG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0ID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpIDogbmV3IEhlYWRlcnNMaXN0KClcbiAgICAgIH07XG4gICAgICByZXF1ZXN0Mi51cmwgPSByZXF1ZXN0Mi51cmxMaXN0WzBdO1xuICAgICAgcmV0dXJuIHJlcXVlc3QyO1xuICAgIH1cbiAgICBfX25hbWUobWFrZVJlcXVlc3QsIFwibWFrZVJlcXVlc3RcIik7XG4gICAgZnVuY3Rpb24gY2xvbmVSZXF1ZXN0KHJlcXVlc3QyKSB7XG4gICAgICBjb25zdCBuZXdSZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyAuLi5yZXF1ZXN0MiwgYm9keTogbnVsbCB9KTtcbiAgICAgIGlmIChyZXF1ZXN0Mi5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgbmV3UmVxdWVzdC5ib2R5ID0gY2xvbmVCb2R5KHJlcXVlc3QyLmJvZHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1JlcXVlc3Q7XG4gICAgfVxuICAgIF9fbmFtZShjbG9uZVJlcXVlc3QsIFwiY2xvbmVSZXF1ZXN0XCIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gICAgICBtZXRob2Q6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgcmVkaXJlY3Q6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eVxuICAgIH0pO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3QgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICAgICAgUmVxdWVzdFxuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8gPSBmdW5jdGlvbihWKSB7XG4gICAgICBpZiAodHlwZW9mIFYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKTtcbiAgICAgIH1cbiAgICAgIGlmIChWIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdChWKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVik7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gICAgICBBYm9ydFNpZ25hbFxuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gICAgICB7XG4gICAgICAgIGtleTogXCJtZXRob2RcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiaGVhZGVyc1wiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiYm9keVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcihcbiAgICAgICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwicmVmZXJyZXJcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJyZWZlcnJlclBvbGljeVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogW1xuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgXCJuby1yZWZlcnJlclwiLFxuICAgICAgICAgIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIixcbiAgICAgICAgICBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgICAgXCJvcmlnaW5cIixcbiAgICAgICAgICBcInN0cmljdC1vcmlnaW5cIixcbiAgICAgICAgICBcIm9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgICAgICAgIFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgICAgICAgIFwidW5zYWZlLXVybFwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJtb2RlXCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgICAgICBhbGxvd2VkVmFsdWVzOiBbXG4gICAgICAgICAgXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICAgIFwiY29yc1wiLFxuICAgICAgICAgIFwibm8tY29yc1wiLFxuICAgICAgICAgIFwibmF2aWdhdGVcIixcbiAgICAgICAgICBcIndlYnNvY2tldFwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJjcmVkZW50aWFsc1wiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogW1xuICAgICAgICAgIFwib21pdFwiLFxuICAgICAgICAgIFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICBcImluY2x1ZGVcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiY2FjaGVcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcbiAgICAgICAgICBcImRlZmF1bHRcIixcbiAgICAgICAgICBcIm5vLXN0b3JlXCIsXG4gICAgICAgICAgXCJyZWxvYWRcIixcbiAgICAgICAgICBcIm5vLWNhY2hlXCIsXG4gICAgICAgICAgXCJmb3JjZS1jYWNoZVwiLFxuICAgICAgICAgIFwib25seS1pZi1jYWNoZWRcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwicmVkaXJlY3RcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcbiAgICAgICAgICBcImZvbGxvd1wiLFxuICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICBcIm1hbnVhbFwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJrZWVwYWxpdmVcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwic2lnbmFsXCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgICAgIChzaWduYWwpID0+IHdlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsKFxuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgeyBzdHJpY3Q6IGZhbHNlIH1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJ3aW5kb3dcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgICAgIH1cbiAgICBdKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7IFJlcXVlc3QsIG1ha2VSZXF1ZXN0IH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzXG52YXIgcmVxdWlyZV9kYXRhVVJMID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZGF0YVVSTC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgeyBhdG9iOiBhdG9iMiB9ID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGZ1bmN0aW9uIGRhdGFVUkxQcm9jZXNzb3IoZGF0YVVSTCkge1xuICAgICAgYXNzZXJ0KGRhdGFVUkwucHJvdG9jb2wgPT09IFwiZGF0YTpcIik7XG4gICAgICBsZXQgaW5wdXQgPSBVUkxTZXJpYWxpemVyKGRhdGFVUkwsIHRydWUpO1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSg1KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9O1xuICAgICAgbGV0IG1pbWVUeXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IFwiLFwiLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgICk7XG4gICAgICBjb25zdCBtaW1lVHlwZUxlbmd0aCA9IG1pbWVUeXBlLmxlbmd0aDtcbiAgICAgIG1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvXihcXHUwMDIwKSt8KFxcdTAwMjApKyQvZywgXCJcIik7XG4gICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcImZhaWx1cmVcIjtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICBjb25zdCBlbmNvZGVkQm9keSA9IGlucHV0LnNsaWNlKG1pbWVUeXBlTGVuZ3RoICsgMSk7XG4gICAgICBsZXQgYm9keSA9IHN0cmluZ1BlcmNlbnREZWNvZGUoZW5jb2RlZEJvZHkpO1xuICAgICAgaWYgKC87KFxcdTAwMjApezAsfWJhc2U2NCQvaS50ZXN0KG1pbWVUeXBlKSkge1xuICAgICAgICBjb25zdCBzdHJpbmdCb2R5ID0gZGVjb2RlVVJJQ29tcG9uZW50KG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShib2R5KSk7XG4gICAgICAgIGJvZHkgPSBmb3JnaXZpbmdCYXNlNjQoc3RyaW5nQm9keSk7XG4gICAgICAgIGlmIChib2R5ID09PSBcImZhaWx1cmVcIikge1xuICAgICAgICAgIHJldHVybiBcImZhaWx1cmVcIjtcbiAgICAgICAgfVxuICAgICAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC02KTtcbiAgICAgICAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC8oXFx1MDAyMCkrJC8sIFwiXCIpO1xuICAgICAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKFwiO1wiKSkge1xuICAgICAgICBtaW1lVHlwZSA9IFwidGV4dC9wbGFpblwiICsgbWltZVR5cGU7XG4gICAgICB9XG4gICAgICBsZXQgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKTtcbiAgICAgIGlmIChtaW1lVHlwZVJlY29yZCA9PT0gXCJmYWlsdXJlXCIpIHtcbiAgICAgICAgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKFwidGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWltZVR5cGU6IG1pbWVUeXBlUmVjb3JkLCBib2R5IH07XG4gICAgfVxuICAgIF9fbmFtZShkYXRhVVJMUHJvY2Vzc29yLCBcImRhdGFVUkxQcm9jZXNzb3JcIik7XG4gICAgZnVuY3Rpb24gVVJMU2VyaWFsaXplcih1cmwsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gICAgICBsZXQgb3V0cHV0ID0gdXJsLnByb3RvY29sO1xuICAgICAgaWYgKHVybC5ob3N0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0cHV0ICs9IFwiLy9cIjtcbiAgICAgICAgaWYgKHVybC51c2VybmFtZS5sZW5ndGggPiAwIHx8IHVybC5wYXNzd29yZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3V0cHV0ICs9IHVybC51c2VybmFtZTtcbiAgICAgICAgICBpZiAodXJsLnBhc3N3b3JkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIjpcIiArIHVybC5wYXNzd29yZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0ICs9IFwiQFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBkZWNvZGVVUklDb21wb25lbnQodXJsLmhvc3QpO1xuICAgICAgICBpZiAodXJsLnBvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG91dHB1dCArPSBcIjpcIiArIHVybC5wb3J0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXJsLmhvc3QubGVuZ3RoID09PSAwICYmIHVybC5wYXRobmFtZS5sZW5ndGggPiAxICYmIHVybC5ocmVmLnNsaWNlKHVybC5wcm90b2NvbC5sZW5ndGggKyAxKVswXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgb3V0cHV0ICs9IFwiLy5cIjtcbiAgICAgIH1cbiAgICAgIG91dHB1dCArPSB1cmwucGF0aG5hbWU7XG4gICAgICBpZiAodXJsLnNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dHB1dCArPSB1cmwuc2VhcmNoO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2x1ZGVGcmFnbWVudCA9PT0gZmFsc2UgJiYgdXJsLmhhc2gubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXRwdXQgKz0gdXJsLmhhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBfX25hbWUoVVJMU2VyaWFsaXplciwgXCJVUkxTZXJpYWxpemVyXCIpO1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoY29uZGl0aW9uLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0pKSB7XG4gICAgICAgIHJlc3VsdCArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl07XG4gICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUoY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cywgXCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzXCIpO1xuICAgIGZ1bmN0aW9uIHN0cmluZ1BlcmNlbnREZWNvZGUoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgICAgcmV0dXJuIHBlcmNlbnREZWNvZGUoYnl0ZXMpO1xuICAgIH1cbiAgICBfX25hbWUoc3RyaW5nUGVyY2VudERlY29kZSwgXCJzdHJpbmdQZXJjZW50RGVjb2RlXCIpO1xuICAgIGZ1bmN0aW9uIHBlcmNlbnREZWNvZGUoaW5wdXQpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBieXRlID0gaW5wdXRbaV07XG4gICAgICAgIGlmIChieXRlICE9PSAzNykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGJ5dGUgPT09IDM3ICYmICEvXlswLTlBLUZhLWZdezJ9JC9pLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpICsgMV0sIGlucHV0W2kgKyAyXSkpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goMzcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5leHRUd29CeXRlcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXRbaSArIDFdLCBpbnB1dFtpICsgMl0pO1xuICAgICAgICAgIGNvbnN0IGJ5dGVQb2ludCA9IE51bWJlci5wYXJzZUludChuZXh0VHdvQnl0ZXMsIDE2KTtcbiAgICAgICAgICBvdXRwdXQucHVzaChieXRlUG9pbnQpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShvdXRwdXQpO1xuICAgIH1cbiAgICBfX25hbWUocGVyY2VudERlY29kZSwgXCJwZXJjZW50RGVjb2RlXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlTUlNRVR5cGUoaW5wdXQpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH07XG4gICAgICBjb25zdCB0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IFwiL1wiLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgICk7XG4gICAgICBpZiAodHlwZS5sZW5ndGggPT09IDAgfHwgIS9eWyEjJCUmJyorLS5eX3x+QS16MC05XSskLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBcImZhaWx1cmVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gXCJmYWlsdXJlXCI7XG4gICAgICB9XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrO1xuICAgICAgbGV0IHN1YnR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gXCI7XCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKTtcbiAgICAgIHN1YnR5cGUgPSBzdWJ0eXBlLnRyaW0oKTtcbiAgICAgIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhL15bISMkJSYnKistLl5ffH5BLXowLTldKyQvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFpbHVyZVwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgICAgIHR5cGU6IHR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgc3VidHlwZTogc3VidHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwYXJhbWV0ZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgICB9O1xuICAgICAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAgICAgKGNoYXIpID0+IC8oXFx1MDAwQXxcXHUwMDBEfFxcdTAwMDl8XFx1MDAyMCkvLnRlc3QoY2hhciksXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHBhcmFtZXRlck5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSBcIjtcIiAmJiBjaGFyICE9PSBcIj1cIixcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSBcIjtcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtZXRlclZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJykge1xuICAgICAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhpbnB1dCwgcG9zaXRpb24pO1xuICAgICAgICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gXCI7XCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gXCI7XCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYXJhbWV0ZXJWYWx1ZSA9IHBhcmFtZXRlclZhbHVlLnRyaW0oKTtcbiAgICAgICAgICBpZiAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtZXRlck5hbWUubGVuZ3RoICE9PSAwICYmIC9eWyEjJCUmJyorLS5eX3x+QS16MC05XSskLy50ZXN0KHBhcmFtZXRlck5hbWUpICYmICEvXihcXHUwMDA5fFxceHswMDIwfS1cXHh7MDA3RX18XFx4ezAwODB9LVxceHswMEZGfSkrJC8udGVzdChwYXJhbWV0ZXJWYWx1ZSkgJiYgIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKHBhcmFtZXRlck5hbWUpKSB7XG4gICAgICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZU1JTUVUeXBlLCBcInBhcnNlTUlNRVR5cGVcIik7XG4gICAgZnVuY3Rpb24gZm9yZ2l2aW5nQmFzZTY0KGRhdGEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL1tcXHUwMDA5XFx1MDAwQVxcdTAwMENcXHUwMDBEXFx1MDAyMF0vZywgXCJcIik7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggJSA0ID09PSAwKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLz0/PSQvLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFpbHVyZVwiO1xuICAgICAgfVxuICAgICAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gXCJmYWlsdXJlXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBiaW5hcnkgPSBhdG9iMihkYXRhKTtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IGJpbmFyeS5sZW5ndGg7IGJ5dGUrKykge1xuICAgICAgICBieXRlc1tieXRlXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGJ5dGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBfX25hbWUoZm9yZ2l2aW5nQmFzZTY0LCBcImZvcmdpdmluZ0Jhc2U2NFwiKTtcbiAgICBmdW5jdGlvbiBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlKSB7XG4gICAgICBjb25zdCBwb3NpdGlvblN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb247XG4gICAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgICAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJyk7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSBcIlxcXFxcIixcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVvdGVPckJhY2tzbGFzaCA9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXTtcbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgICAgaWYgKHF1b3RlT3JCYWNrc2xhc2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCJcXFxcXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dO1xuICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcIicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFjdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dC5zbGljZShwb3NpdGlvblN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbik7XG4gICAgfVxuICAgIF9fbmFtZShjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLCBcImNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmdcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgZGF0YVVSTFByb2Nlc3NvcixcbiAgICAgIFVSTFNlcmlhbGl6ZXIsXG4gICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLFxuICAgICAgc3RyaW5nUGVyY2VudERlY29kZSxcbiAgICAgIHBhcnNlTUlNRVR5cGUsXG4gICAgICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2luZGV4LmpzXG52YXIgcmVxdWlyZV9mZXRjaCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7XG4gICAgICBSZXNwb25zZSxcbiAgICAgIG1ha2VOZXR3b3JrRXJyb3IsXG4gICAgICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gICAgICBmaWx0ZXJSZXNwb25zZSxcbiAgICAgIG1ha2VSZXNwb25zZVxuICAgIH0gPSByZXF1aXJlX3Jlc3BvbnNlKCk7XG4gICAgdmFyIHsgSGVhZGVycyB9ID0gcmVxdWlyZV9oZWFkZXJzKCk7XG4gICAgdmFyIHsgUmVxdWVzdCwgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmVfcmVxdWVzdDIoKTtcbiAgICB2YXIgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuICAgIHZhciB7XG4gICAgICBieXRlc01hdGNoLFxuICAgICAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgICAgIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICAgICAgcmVxdWVzdEJhZFBvcnQsXG4gICAgICBUQU9DaGVjayxcbiAgICAgIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gICAgICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICAgICAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gICAgICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICAgICAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICAgICAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgICAgIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gICAgICBjb3JzQ2hlY2ssXG4gICAgICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gICAgICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICAgICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gICAgICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gICAgICBpc0Jsb2JMaWtlLFxuICAgICAgc2FtZU9yaWdpbixcbiAgICAgIGlzQ2FuY2VsbGVkLFxuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNFcnJvckxpa2UsXG4gICAgICBmdWxseVJlYWRCb2R5XG4gICAgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB7IHNhZmVseUV4dHJhY3RCb2R5LCBleHRyYWN0Qm9keSB9ID0gcmVxdWlyZV9ib2R5KCk7XG4gICAgdmFyIHtcbiAgICAgIHJlZGlyZWN0U3RhdHVzLFxuICAgICAgbnVsbEJvZHlTdGF0dXMsXG4gICAgICBzYWZlTWV0aG9kcyxcbiAgICAgIHJlcXVlc3RCb2R5SGVhZGVyLFxuICAgICAgc3VicmVzb3VyY2UsXG4gICAgICBET01FeGNlcHRpb25cbiAgICB9ID0gcmVxdWlyZV9jb25zdGFudHMoKTtcbiAgICB2YXIgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBFRSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4gICAgdmFyIHsgUmVhZGFibGUsIHBpcGVsaW5lIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7IGlzRXJyb3JlZCwgaXNSZWFkYWJsZSB9ID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IGRhdGFVUkxQcm9jZXNzb3IgfSA9IHJlcXVpcmVfZGF0YVVSTCgpO1xuICAgIHZhciB7IFRyYW5zZm9ybVN0cmVhbSB9ID0gcmVxdWlyZShcInN0cmVhbS93ZWJcIik7XG4gICAgdmFyIHJlc29sdmVPYmplY3RVUkw7XG4gICAgdmFyIFJlYWRhYmxlU3RyZWFtO1xuICAgIHZhciBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIik7XG4gICAgdmFyIG5vZGVNYWpvciA9IE51bWJlcihub2RlVmVyc2lvblswXSk7XG4gICAgdmFyIG5vZGVNaW5vciA9IE51bWJlcihub2RlVmVyc2lvblsxXSk7XG4gICAgdmFyIEZldGNoID0gY2xhc3MgZXh0ZW5kcyBFRSB7XG4gICAgICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZHVtcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJvbmdvaW5nXCI7XG4gICAgICB9XG4gICAgICB0ZXJtaW5hdGUocmVhc29uKSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcIm9uZ29pbmdcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gXCJ0ZXJtaW5hdGVkXCI7XG4gICAgICAgIChfYTMgPSB0aGlzLmNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZGVzdHJveShyZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXQoXCJ0ZXJtaW5hdGVkXCIsIHJlYXNvbik7XG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwib25nb2luZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImFib3J0ZWRcIjtcbiAgICAgICAgKF9hMyA9IHRoaXMuY29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5kZXN0cm95KHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdChcInRlcm1pbmF0ZWRcIiwgcmVhc29uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShGZXRjaCwgXCJGZXRjaFwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaDIoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZmV0Y2gnIG9uICdXaW5kb3cnOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgbGV0IHJlcXVlc3RPYmplY3Q7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwLnJlamVjdChlKTtcbiAgICAgICAgcmV0dXJuIHAucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcXVlc3QyID0gcmVxdWVzdE9iamVjdFtrU3RhdGVdO1xuICAgICAgaWYgKHJlcXVlc3RPYmplY3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0MiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBwLnByb21pc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBnbG9iYWxPYmplY3QgPSByZXF1ZXN0Mi5jbGllbnQuZ2xvYmFsT2JqZWN0O1xuICAgICAgaWYgKCgoX2EzID0gZ2xvYmFsT2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxPYmplY3QuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubmFtZSkgPT09IFwiU2VydmljZVdvcmtlckdsb2JhbFNjb3BlXCIpIHtcbiAgICAgICAgcmVxdWVzdDIuc2VydmljZVdvcmtlcnMgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICAgIGxldCByZXNwb25zZU9iamVjdCA9IG51bGw7XG4gICAgICBjb25zdCByZWxldmFudFJlYWxtID0gbnVsbDtcbiAgICAgIGxldCBsb2NhbGx5QWJvcnRlZCA9IGZhbHNlO1xuICAgICAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgcmVxdWVzdE9iamVjdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgbG9jYWxseUFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdDIsIHJlc3BvbnNlT2JqZWN0KTtcbiAgICAgICAgICBpZiAoY29udHJvbGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGhhbmRsZUZldGNoRG9uZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHJlc3BvbnNlKSA9PiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyhyZXNwb25zZSwgXCJmZXRjaFwiKSwgXCJoYW5kbGVGZXRjaERvbmVcIik7XG4gICAgICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAobG9jYWxseUFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QyLCByZXNwb25zZU9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBwLnJlamVjdChcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcihcImZldGNoIGZhaWxlZFwiKSwgeyBjYXVzZTogcmVzcG9uc2UuZXJyb3IgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gcmVzcG9uc2U7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0O1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IFwiaW1tdXRhYmxlXCI7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgcC5yZXNvbHZlKHJlc3BvbnNlT2JqZWN0KTtcbiAgICAgIH0sIFwicHJvY2Vzc1Jlc3BvbnNlXCIpO1xuICAgICAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdDIsXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgICAgIGRpc3BhdGNoZXI6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHAucHJvbWlzZTtcbiAgICB9XG4gICAgX19uYW1lKGZldGNoMiwgXCJmZXRjaFwiKTtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyhyZXNwb25zZSwgaW5pdGlhdG9yVHlwZSA9IFwib3RoZXJcIikge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSBcImVycm9yXCIgJiYgcmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoISgoX2EzID0gcmVzcG9uc2UudXJsTGlzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXTtcbiAgICAgIGxldCB0aW1pbmdJbmZvID0gcmVzcG9uc2UudGltaW5nSW5mbztcbiAgICAgIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZTtcbiAgICAgIGlmICghL15odHRwcz86Ly50ZXN0KG9yaWdpbmFsVVJMLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRpbWluZ0luZm8udGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAgICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNhY2hlU3RhdGUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UudGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKTtcbiAgICAgIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvO1xuICAgICAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgICAgICB0aW1pbmdJbmZvLFxuICAgICAgICBvcmlnaW5hbFVSTCxcbiAgICAgICAgaW5pdGlhdG9yVHlwZSxcbiAgICAgICAgZ2xvYmFsVGhpcyxcbiAgICAgICAgY2FjaGVTdGF0ZVxuICAgICAgKTtcbiAgICB9XG4gICAgX19uYW1lKGZpbmFsaXplQW5kUmVwb3J0VGltaW5nLCBcImZpbmFsaXplQW5kUmVwb3J0VGltaW5nXCIpO1xuICAgIGZ1bmN0aW9uIG1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSwgZ2xvYmFsVGhpczIsIGNhY2hlU3RhdGUpIHtcbiAgICAgIGlmIChub2RlTWFqb3IgPj0gMTggJiYgbm9kZU1pbm9yID49IDIpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFya1Jlc291cmNlVGltaW5nKHRpbWluZ0luZm8sIG9yaWdpbmFsVVJMLCBpbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzMiwgY2FjaGVTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShtYXJrUmVzb3VyY2VUaW1pbmcsIFwibWFya1Jlc291cmNlVGltaW5nXCIpO1xuICAgIGZ1bmN0aW9uIGFib3J0RmV0Y2gocCwgcmVxdWVzdDIsIHJlc3BvbnNlT2JqZWN0KSB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICBjb25zdCBlcnJvcjIgPSBuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpO1xuICAgICAgcC5yZWplY3QoZXJyb3IyKTtcbiAgICAgIGlmIChyZXF1ZXN0Mi5ib2R5ICE9IG51bGwgJiYgaXNSZWFkYWJsZSgoX2EzID0gcmVxdWVzdDIuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5zdHJlYW0pKSB7XG4gICAgICAgIHJlcXVlc3QyLmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcjIpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiRVJSX0lOVkFMSURfU1RBVEVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlT2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZU9iamVjdFtrU3RhdGVdO1xuICAgICAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKChfYjIgPSByZXNwb25zZS5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnN0cmVhbSkpIHtcbiAgICAgICAgcmVzcG9uc2UuYm9keS5zdHJlYW0uY2FuY2VsKGVycm9yMikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJFUlJfSU5WQUxJRF9TVEFURVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShhYm9ydEZldGNoLCBcImFib3J0RmV0Y2hcIik7XG4gICAgZnVuY3Rpb24gZmV0Y2hpbmcoe1xuICAgICAgcmVxdWVzdDogcmVxdWVzdDIsXG4gICAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICAgIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAgICAgcHJvY2Vzc1Jlc3BvbnNlLFxuICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgICB1c2VQYXJhbGxlbFF1ZXVlID0gZmFsc2UsXG4gICAgICBkaXNwYXRjaGVyXG4gICAgfSkge1xuICAgICAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gICAgICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgIGxldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSA9IGZhbHNlO1xuICAgICAgaWYgKHJlcXVlc3QyLmNsaWVudCAhPSBudWxsKSB7XG4gICAgICAgIHRhc2tEZXN0aW5hdGlvbiA9IHJlcXVlc3QyLmNsaWVudC5nbG9iYWxPYmplY3Q7XG4gICAgICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gcmVxdWVzdDIuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVuVGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KTtcbiAgICAgIGNvbnN0IHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICAgICAgc3RhcnRUaW1lOiBjdXJyZW5UaW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgICAgICBjb250cm9sbGVyOiBuZXcgRmV0Y2goZGlzcGF0Y2hlciksXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QyLFxuICAgICAgICB0aW1pbmdJbmZvLFxuICAgICAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICAgICAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgICAgICAgdGFza0Rlc3RpbmF0aW9uLFxuICAgICAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICAgICAgfTtcbiAgICAgIGFzc2VydCghcmVxdWVzdDIuYm9keSB8fCByZXF1ZXN0Mi5ib2R5LnN0cmVhbSk7XG4gICAgICBpZiAocmVxdWVzdDIud2luZG93ID09PSBcImNsaWVudFwiKSB7XG4gICAgICAgIHJlcXVlc3QyLndpbmRvdyA9ICgoX2MgPSAoX2IyID0gKF9hMyA9IHJlcXVlc3QyLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5nbG9iYWxPYmplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5uYW1lKSA9PT0gXCJXaW5kb3dcIiA/IHJlcXVlc3QyLmNsaWVudCA6IFwibm8td2luZG93XCI7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIub3JpZ2luID09PSBcImNsaWVudFwiKSB7XG4gICAgICAgIHJlcXVlc3QyLm9yaWdpbiA9IChfZCA9IHJlcXVlc3QyLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5wb2xpY3lDb250YWluZXIgPT09IFwiY2xpZW50XCIpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QyLmNsaWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVxdWVzdDIucG9saWN5Q29udGFpbmVyID0gY2xvbmVQb2xpY3lDb250YWluZXIoXG4gICAgICAgICAgICByZXF1ZXN0Mi5jbGllbnQucG9saWN5Q29udGFpbmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0Mi5wb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVxdWVzdDIuaGVhZGVyc0xpc3QuaGFzKFwiYWNjZXB0XCIpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gXCIqLypcIjtcbiAgICAgICAgcmVxdWVzdDIuaGVhZGVyc0xpc3QuYXBwZW5kKFwiYWNjZXB0XCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVxdWVzdDIuaGVhZGVyc0xpc3QuaGFzKFwiYWNjZXB0LWxhbmd1YWdlXCIpKSB7XG4gICAgICAgIHJlcXVlc3QyLmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1sYW5ndWFnZVwiLCBcIipcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIucHJpb3JpdHkgPT09IG51bGwpIHtcbiAgICAgIH1cbiAgICAgIGlmIChzdWJyZXNvdXJjZS5pbmNsdWRlcyhyZXF1ZXN0Mi5kZXN0aW5hdGlvbikpIHtcbiAgICAgIH1cbiAgICAgIG1haW5GZXRjaChmZXRjaFBhcmFtcykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlcjtcbiAgICB9XG4gICAgX19uYW1lKGZldGNoaW5nLCBcImZldGNoaW5nXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG1haW5GZXRjaChmZXRjaFBhcmFtcywgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2hQYXJhbXMucmVxdWVzdDtcbiAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICBpZiAocmVxdWVzdDIubG9jYWxVUkxzT25seSAmJiAhL14oYWJvdXR8YmxvYnxkYXRhKTovLnRlc3QocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpLnByb3RvY29sKSkge1xuICAgICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoXCJsb2NhbCBVUkxzIG9ubHlcIik7XG4gICAgICB9XG4gICAgICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwocmVxdWVzdDIpO1xuICAgICAgaWYgKHJlcXVlc3RCYWRQb3J0KHJlcXVlc3QyKSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKFwiYmFkIHBvcnRcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIucmVmZXJyZXJQb2xpY3kgPT09IFwiXCIpIHtcbiAgICAgICAgcmVxdWVzdDIucmVmZXJyZXJQb2xpY3kgPSByZXF1ZXN0Mi5wb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3k7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIucmVmZXJyZXIgIT09IFwibm8tcmVmZXJyZXJcIikge1xuICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdDIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgICAgIGlmIChzYW1lT3JpZ2luKGN1cnJlbnRVUkwsIHJlcXVlc3QyLnVybCkgJiYgcmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJiYXNpY1wiIHx8IGN1cnJlbnRVUkwucHJvdG9jb2wgPT09IFwiZGF0YTpcIiB8fCAocmVxdWVzdDIubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiIHx8IHJlcXVlc3QyLm1vZGUgPT09IFwid2Vic29ja2V0XCIpKSB7XG4gICAgICAgICAgICByZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID0gXCJiYXNpY1wiO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcXVlc3QyLm1vZGUgPT09IFwic2FtZS1vcmlnaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3JlcXVlc3QgbW9kZSBjYW5ub3QgYmUgXCJzYW1lLW9yaWdpblwiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5tb2RlID09PSBcIm5vLWNvcnNcIikge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QyLnJlZGlyZWN0ICE9PSBcImZvbGxvd1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9IFwib3BhcXVlXCI7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIS9eaHR0cHM/Oi8udGVzdChyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0MikucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcIlVSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID0gXCJjb3JzXCI7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGh0dHBGZXRjaChmZXRjaFBhcmFtcyk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDAgJiYgIXJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiY29yc1wiKSB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiYmFzaWNcIikge1xuICAgICAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsIFwiYmFzaWNcIik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJjb3JzXCIpIHtcbiAgICAgICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCBcImNvcnNcIik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJvcGFxdWVcIikge1xuICAgICAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsIFwib3BhcXVlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpbnRlcm5hbFJlc3BvbnNlID0gcmVzcG9uc2Uuc3RhdHVzID09PSAwID8gcmVzcG9uc2UgOiByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlO1xuICAgICAgaWYgKGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0LnB1c2goLi4ucmVxdWVzdDIudXJsTGlzdCk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlcXVlc3QyLnRpbWluZ0FsbG93RmFpbGVkKSB7XG4gICAgICAgIHJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSBcIm9wYXF1ZVwiICYmIGludGVybmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgJiYgaW50ZXJuYWxSZXNwb25zZS5yYW5nZVJlcXVlc3RlZCAmJiAhcmVxdWVzdDIuaGVhZGVycy5oYXMoXCJyYW5nZVwiKSkge1xuICAgICAgICByZXNwb25zZSA9IGludGVybmFsUmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmIChyZXF1ZXN0Mi5tZXRob2QgPT09IFwiSEVBRFwiIHx8IHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJDT05ORUNUXCIgfHwgbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMpKSkge1xuICAgICAgICBpbnRlcm5hbFJlc3BvbnNlLmJvZHkgPSBudWxsO1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLmludGVncml0eSkge1xuICAgICAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocmVhc29uKSA9PiBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pKSwgXCJwcm9jZXNzQm9keUVycm9yXCIpO1xuICAgICAgICBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJvcGFxdWVcIiB8fCByZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICBwcm9jZXNzQm9keUVycm9yKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChieXRlcykgPT4ge1xuICAgICAgICAgIGlmICghYnl0ZXNNYXRjaChieXRlcywgcmVxdWVzdDIuaW50ZWdyaXR5KSkge1xuICAgICAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihcImludGVncml0eSBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXTtcbiAgICAgICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICB9LCBcInByb2Nlc3NCb2R5XCIpO1xuICAgICAgICBhd2FpdCBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShtYWluRmV0Y2gsIFwibWFpbkZldGNoXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKSB7XG4gICAgICBjb25zdCB7IHJlcXVlc3Q6IHJlcXVlc3QyIH0gPSBmZXRjaFBhcmFtcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdG9jb2w6IHNjaGVtZSxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGg3XG4gICAgICB9ID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgY2FzZSBcImFib3V0OlwiOiB7XG4gICAgICAgICAgaWYgKHBhdGg3ID09PSBcImJsYW5rXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtYWtlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk9LXCIsXG4gICAgICAgICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgICAgICAgW1wiY29udGVudC10eXBlXCIsIFwidGV4dC9odG1sO2NoYXJzZXQ9dXRmLThcIl1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwLnVybExpc3QgPSBbbmV3IFVSTChcImFib3V0OmJsYW5rXCIpXTtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcImludmFsaWQgcGF0aCBjYWxsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJsb2I6XCI6IHtcbiAgICAgICAgICByZXNvbHZlT2JqZWN0VVJMID0gcmVzb2x2ZU9iamVjdFVSTCB8fCByZXF1aXJlKFwiYnVmZmVyXCIpLnJlc29sdmVPYmplY3RVUkw7XG4gICAgICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKTtcbiAgICAgICAgICBpZiAoY3VycmVudFVSTC5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBibG9iID0gcmVzb2x2ZU9iamVjdFVSTChjdXJyZW50VVJMLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5tZXRob2QgIT09IFwiR0VUXCIgfHwgIWlzQmxvYkxpa2UoYmxvYikpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiaW52YWxpZCBtZXRob2RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzVGV4dDogXCJPS1wiLCB1cmxMaXN0OiBbY3VycmVudFVSTF0gfSk7XG4gICAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KFwiY29udGVudC1sZW5ndGhcIiwgYCR7YmxvYi5zaXplfWApO1xuICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldChcImNvbnRlbnQtdHlwZVwiLCBibG9iLnR5cGUpO1xuICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBleHRyYWN0Qm9keShibG9iKVswXTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRhdGE6XCI6IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgICAgIGNvbnN0IGRhdGFVUkxTdHJ1Y3QgPSBkYXRhVVJMUHJvY2Vzc29yKGN1cnJlbnRVUkwpO1xuICAgICAgICAgIGlmIChkYXRhVVJMU3RydWN0ID09PSBcImZhaWx1cmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXCJmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IG1pbWVUeXBlIH0gPSBkYXRhVVJMU3RydWN0O1xuICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IGAke21pbWVUeXBlLnR5cGV9LyR7bWltZVR5cGUuc3VidHlwZX1gO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlUGFyYW1zID0gW107XG4gICAgICAgICAgaWYgKG1pbWVUeXBlLnBhcmFtZXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlICs9IFwiO1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtaW1lVHlwZS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZVBhcmFtcy5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlUGFyYW1zLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGVudFR5cGUgKz0gY29udGVudFR5cGVQYXJhbXMuam9pbihcIixcIik7XG4gICAgICAgICAgcmV0dXJuIG1ha2VSZXNwb25zZSh7XG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk9LXCIsXG4gICAgICAgICAgICBoZWFkZXJzTGlzdDogW1xuICAgICAgICAgICAgICBbXCJjb250ZW50LXR5cGVcIiwgY29udGVudFR5cGVdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYm9keTogZXh0cmFjdEJvZHkoZGF0YVVSTFN0cnVjdC5ib2R5KVswXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaWxlOlwiOiB7XG4gICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQuLi4geWV0Li4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgaHR0cEZldGNoKGZldGNoUGFyYW1zKS5jYXRjaCgoZXJyKSA9PiBtYWtlTmV0d29ya0Vycm9yKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcInVua25vd24gc2NoZW1lXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzY2hlbWVGZXRjaCwgXCJzY2hlbWVGZXRjaFwiKTtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVJlc3BvbnNlKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lICE9IG51bGwpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZShyZXNwb25zZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZmluYWxpemVSZXNwb25zZSwgXCJmaW5hbGl6ZVJlc3BvbnNlXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICByZXNwb25zZS51cmxMaXN0ID0gW2ZldGNoUGFyYW1zLnJlcXVlc3QudXJsTGlzdFswXV07XG4gICAgICAgIHJlc3BvbnNlLnRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICAgICAgICBzdGFydFRpbWU6IGZldGNoUGFyYW1zLnRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgIT0gbnVsbCkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keShyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICB9LCBcInByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVwiKTtcbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfSwgXCJpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobVwiKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2Zvcm06IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtLFxuICAgICAgICAgIGZsdXNoOiBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbTogcmVzcG9uc2UuYm9keS5zdHJlYW0ucGlwZVRocm91Z2godHJhbnNmb3JtU3RyZWFtKSB9O1xuICAgICAgfVxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChudWxsT3JCeXRlcykgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkocmVzcG9uc2UsIG51bGxPckJ5dGVzKSwgXCJwcm9jZXNzQm9keVwiKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZhaWx1cmUpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5KHJlc3BvbnNlLCBmYWlsdXJlKSwgXCJwcm9jZXNzQm9keUVycm9yXCIpO1xuICAgICAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc0JvZHkobnVsbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmZXRjaEZpbmFsZSwgXCJmZXRjaEZpbmFsZVwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2hQYXJhbXMucmVxdWVzdDtcbiAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICBsZXQgYWN0dWFsUmVzcG9uc2UgPSBudWxsO1xuICAgICAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm87XG4gICAgICBpZiAocmVxdWVzdDIuc2VydmljZVdvcmtlcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVxdWVzdDIucmVkaXJlY3QgPT09IFwiZm9sbG93XCIpIHtcbiAgICAgICAgICByZXF1ZXN0Mi5zZXJ2aWNlV29ya2VycyA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcyk7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcImNvcnNcIiAmJiBjb3JzQ2hlY2socmVxdWVzdDIsIHJlc3BvbnNlKSA9PT0gXCJmYWlsdXJlXCIpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcImNvcnMgZmFpbHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVEFPQ2hlY2socmVxdWVzdDIsIHJlc3BvbnNlKSA9PT0gXCJmYWlsdXJlXCIpIHtcbiAgICAgICAgICByZXF1ZXN0Mi50aW1pbmdBbGxvd0ZhaWxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJvcGFxdWVcIiB8fCByZXNwb25zZS50eXBlID09PSBcIm9wYXF1ZVwiKSAmJiBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2soXG4gICAgICAgIHJlcXVlc3QyLm9yaWdpbixcbiAgICAgICAgcmVxdWVzdDIuY2xpZW50LFxuICAgICAgICByZXF1ZXN0Mi5kZXN0aW5hdGlvbixcbiAgICAgICAgYWN0dWFsUmVzcG9uc2VcbiAgICAgICkgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiYmxvY2tlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRpcmVjdFN0YXR1cy5pbmNsdWRlcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5yZWRpcmVjdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKFwidW5leHBlY3RlZCByZWRpcmVjdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5yZWRpcmVjdCA9PT0gXCJtYW51YWxcIikge1xuICAgICAgICAgIHJlc3BvbnNlID0gYWN0dWFsUmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdDIucmVkaXJlY3QgPT09IFwiZm9sbG93XCIpIHtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm87XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIF9fbmFtZShodHRwRmV0Y2gsIFwiaHR0cEZldGNoXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0O1xuICAgICAgY29uc3QgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSA6IHJlc3BvbnNlO1xuICAgICAgbGV0IGxvY2F0aW9uVVJMO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgICAgIGFjdHVhbFJlc3BvbnNlLFxuICAgICAgICAgIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKS5oYXNoXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsb2NhdGlvblVSTCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmICghL15odHRwcz86Ly50ZXN0KGxvY2F0aW9uVVJMLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcIlVSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLnJlZGlyZWN0Q291bnQgPT09IDIwKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwicmVkaXJlY3QgY291bnQgZXhjZWVkZWRcIik7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Mi5yZWRpcmVjdENvdW50ICs9IDE7XG4gICAgICBpZiAocmVxdWVzdDIubW9kZSA9PT0gXCJjb3JzXCIgJiYgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJiAhc2FtZU9yaWdpbihyZXF1ZXN0MiwgbG9jYXRpb25VUkwpKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiY29yc1wiICYmIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZCkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmIHJlcXVlc3QyLmJvZHkgIT0gbnVsbCAmJiByZXF1ZXN0Mi5ib2R5LnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCk7XG4gICAgICB9XG4gICAgICBpZiAoWzMwMSwgMzAyXS5pbmNsdWRlcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpICYmIHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJQT1NUXCIgfHwgYWN0dWFsUmVzcG9uc2Uuc3RhdHVzID09PSAzMDMgJiYgIVtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMocmVxdWVzdDIubWV0aG9kKSkge1xuICAgICAgICByZXF1ZXN0Mi5tZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICByZXF1ZXN0Mi5ib2R5ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcXVlc3RCb2R5SGVhZGVyKSB7XG4gICAgICAgICAgcmVxdWVzdDIuaGVhZGVyc0xpc3QuZGVsZXRlKGhlYWRlck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIuYm9keSAhPSBudWxsKSB7XG4gICAgICAgIGFzc2VydChyZXF1ZXN0Mi5ib2R5LnNvdXJjZSk7XG4gICAgICAgIHJlcXVlc3QyLmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShyZXF1ZXN0Mi5ib2R5LnNvdXJjZSlbMF07XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mbztcbiAgICAgIHRpbWluZ0luZm8ucmVkaXJlY3RFbmRUaW1lID0gdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSk7XG4gICAgICBpZiAodGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9PT0gMCkge1xuICAgICAgICB0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID0gdGltaW5nSW5mby5zdGFydFRpbWU7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Mi51cmxMaXN0LnB1c2gobG9jYXRpb25VUkwpO1xuICAgICAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0MiwgYWN0dWFsUmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIG1haW5GZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSk7XG4gICAgfVxuICAgIF9fbmFtZShodHRwUmVkaXJlY3RGZXRjaCwgXCJodHRwUmVkaXJlY3RGZXRjaFwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcywgaXNBdXRoZW50aWNhdGlvbkZldGNoID0gZmFsc2UsIGlzTmV3Q29ubmVjdGlvbkZldGNoID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2hQYXJhbXMucmVxdWVzdDtcbiAgICAgIGxldCBodHRwRmV0Y2hQYXJhbXMgPSBudWxsO1xuICAgICAgbGV0IGh0dHBSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICBjb25zdCBodHRwQ2FjaGUgPSBudWxsO1xuICAgICAgY29uc3QgcmV2YWxpZGF0aW5nRmxhZyA9IGZhbHNlO1xuICAgICAgaWYgKHJlcXVlc3QyLndpbmRvdyA9PT0gXCJuby13aW5kb3dcIiAmJiByZXF1ZXN0Mi5yZWRpcmVjdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGh0dHBGZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zO1xuICAgICAgICBodHRwUmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHR0cFJlcXVlc3QgPSBtYWtlUmVxdWVzdChyZXF1ZXN0Mik7XG4gICAgICAgIGh0dHBGZXRjaFBhcmFtcyA9IHsgLi4uZmV0Y2hQYXJhbXMgfTtcbiAgICAgICAgaHR0cEZldGNoUGFyYW1zLnJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY2x1ZGVDcmVkZW50aWFscyA9IHJlcXVlc3QyLmNyZWRlbnRpYWxzID09PSBcImluY2x1ZGVcIiB8fCByZXF1ZXN0Mi5jcmVkZW50aWFscyA9PT0gXCJzYW1lLW9yaWdpblwiICYmIHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiYmFzaWNcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBodHRwUmVxdWVzdC5ib2R5ID8gaHR0cFJlcXVlc3QuYm9keS5sZW5ndGggOiBudWxsO1xuICAgICAgbGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IG51bGw7XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuYm9keSA9PSBudWxsICYmIFtcIlBPU1RcIiwgXCJQVVRcIl0uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gU3RyaW5nKGNvbnRlbnRMZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImNvbnRlbnQtbGVuZ3RoXCIsIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGh0dHBSZXF1ZXN0LmtlZXBhbGl2ZSkge1xuICAgICAgfVxuICAgICAgaWYgKGh0dHBSZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcInJlZmVyZXJcIiwgaHR0cFJlcXVlc3QucmVmZXJyZXIuaHJlZik7XG4gICAgICB9XG4gICAgICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyKGh0dHBSZXF1ZXN0KTtcbiAgICAgIGFwcGVuZEZldGNoTWV0YWRhdGEoaHR0cFJlcXVlc3QpO1xuICAgICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJ1c2VyLWFnZW50XCIpKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcInVzZXItYWdlbnRcIiwgXCJ1bmRpY2lcIik7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09IFwiZGVmYXVsdFwiICYmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJpZi1tb2RpZmllZC1zaW5jZVwiKSB8fCBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJpZi1ub25lLW1hdGNoXCIpIHx8IGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcImlmLXVubW9kaWZpZWQtc2luY2VcIikgfHwgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwiaWYtbWF0Y2hcIikgfHwgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwiaWYtcmFuZ2VcIikpKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gXCJuby1zdG9yZVwiO1xuICAgICAgfVxuICAgICAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlID09PSBcIm5vLWNhY2hlXCIgJiYgIWh0dHBSZXF1ZXN0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uICYmICFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJjYWNoZS1jb250cm9sXCIpKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImNhY2hlLWNvbnRyb2xcIiwgXCJtYXgtYWdlPTBcIik7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09IFwibm8tc3RvcmVcIiB8fCBodHRwUmVxdWVzdC5jYWNoZSA9PT0gXCJyZWxvYWRcIikge1xuICAgICAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcInByYWdtYVwiKSkge1xuICAgICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcInByYWdtYVwiLCBcIm5vLWNhY2hlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwiY2FjaGUtY29udHJvbFwiKSkge1xuICAgICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImNhY2hlLWNvbnRyb2xcIiwgXCJuby1jYWNoZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcInJhbmdlXCIpKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1lbmNvZGluZ1wiLCBcImlkZW50aXR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJhY2NlcHQtZW5jb2RpbmdcIikpIHtcbiAgICAgICAgaWYgKC9eaHR0cHM6Ly50ZXN0KHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KS5wcm90b2NvbCkpIHtcbiAgICAgICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoXCJhY2NlcHQtZW5jb2RpbmdcIiwgXCJiciwgZ3ppcCwgZGVmbGF0ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoXCJhY2NlcHQtZW5jb2RpbmdcIiwgXCJnemlwLCBkZWZsYXRlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzKSB7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QubW9kZSAhPT0gXCJuby1zdG9yZVwiICYmIGh0dHBSZXF1ZXN0Lm1vZGUgIT09IFwicmVsb2FkXCIpIHtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChodHRwUmVxdWVzdC5tb2RlID09PSBcIm9ubHktaWYtY2FjaGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcIm9ubHkgaWYgY2FjaGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcndhcmRSZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrRmV0Y2goXG4gICAgICAgICAgaHR0cEZldGNoUGFyYW1zLFxuICAgICAgICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICAgICAgICBpc05ld0Nvbm5lY3Rpb25GZXRjaFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNhZmVNZXRob2RzLmluY2x1ZGVzKGh0dHBSZXF1ZXN0Lm1ldGhvZCkgJiYgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA8PSAzOTkpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2YWxpZGF0aW5nRmxhZyAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3BvbnNlID0gZm9yd2FyZFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwb25zZS51cmxMaXN0ID0gWy4uLmh0dHBSZXF1ZXN0LnVybExpc3RdO1xuICAgICAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcInJhbmdlXCIpKSB7XG4gICAgICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLnJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA3KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi53aW5kb3cgPT09IFwibm8td2luZG93XCIpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcInByb3h5IGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIxICYmICFpc05ld0Nvbm5lY3Rpb25GZXRjaCAmJiAocmVxdWVzdDIuYm9keSA9PSBudWxsIHx8IHJlcXVlc3QyLmJvZHkuc291cmNlICE9IG51bGwpKSB7XG4gICAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKFxuICAgICAgICAgIGZldGNoUGFyYW1zLFxuICAgICAgICAgIGlzQXV0aGVudGljYXRpb25GZXRjaCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIF9fbmFtZShodHRwTmV0d29ya09yQ2FjaGVGZXRjaCwgXCJodHRwTmV0d29ya09yQ2FjaGVGZXRjaFwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya0ZldGNoKGZldGNoUGFyYW1zLCBpbmNsdWRlQ3JlZGVudGlhbHMgPSBmYWxzZSwgZm9yY2VOZXdDb25uZWN0aW9uID0gZmFsc2UpIHtcbiAgICAgIGFzc2VydCghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uIHx8IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95ZWQpO1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uID0ge1xuICAgICAgICBhYm9ydDogbnVsbCxcbiAgICAgICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICAgICAgZGVzdHJveShlcnIpIHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIChfYTMgPSB0aGlzLmFib3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcywgZXJyICE9IG51bGwgPyBlcnIgOiBuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0MiA9IGZldGNoUGFyYW1zLnJlcXVlc3Q7XG4gICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm87XG4gICAgICBjb25zdCBodHRwQ2FjaGUgPSBudWxsO1xuICAgICAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgIHJlcXVlc3QyLmNhY2hlID0gXCJuby1zdG9yZVwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IGZvcmNlTmV3Q29ubmVjdGlvbiA/IFwieWVzXCIgOiBcIm5vXCI7XG4gICAgICBpZiAocmVxdWVzdDIubW9kZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgfSBlbHNlIHtcbiAgICAgIH1cbiAgICAgIGxldCByZXF1ZXN0Qm9keSA9IG51bGw7XG4gICAgICBpZiAocmVxdWVzdDIuYm9keSA9PSBudWxsICYmIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0JvZHlDaHVuayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24qIChieXRlcykge1xuICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBieXRlcztcbiAgICAgICAgICAoX2EzID0gZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChmZXRjaFBhcmFtcywgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0sIFwicHJvY2Vzc0JvZHlDaHVua1wiKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0VuZE9mQm9keSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJwcm9jZXNzRW5kT2ZCb2R5XCIpO1xuICAgICAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZSkgPT4ge1xuICAgICAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcInByb2Nlc3NCb2R5RXJyb3JcIik7XG4gICAgICAgIHJlcXVlc3RCb2R5ID0gYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBieXRlcyBvZiByZXF1ZXN0Mi5ib2R5LnN0cmVhbSkge1xuICAgICAgICAgICAgICB5aWVsZCogcHJvY2Vzc0JvZHlDaHVuayhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzRW5kT2ZCb2R5KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwcm9jZXNzQm9keUVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGJvZHksIHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSA9IGF3YWl0IGRpc3BhdGNoKHsgYm9keTogcmVxdWVzdEJvZHkgfSk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gYm9keVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0ID0gKCkgPT4gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1bGxBbGdvcml0aG0gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUoKTtcbiAgICAgIH0sIFwicHVsbEFsZ29yaXRobVwiKTtcbiAgICAgIGNvbnN0IGNhbmNlbEFsZ29yaXRobSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9LCBcImNhbmNlbEFsZ29yaXRobVwiKTtcbiAgICAgIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKS5SZWFkYWJsZVN0cmVhbTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbTIgPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgIHtcbiAgICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBhd2FpdCBwdWxsQWxnb3JpdGhtKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICAgYXdhaXQgY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbTogc3RyZWFtMiB9O1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbihcInRlcm1pbmF0ZWRcIiwgb25BYm9ydGVkKTtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzID0gZG9uZSA/IHZvaWQgMCA6IHZhbHVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgJiYgIXRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplKSB7XG4gICAgICAgICAgICAgIGJ5dGVzID0gdm9pZCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnl0ZXMgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChieXRlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoIS9Db250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkLy50ZXN0KGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltaW5nSW5mby5kZWNvZGVkQm9keVNpemUgKz0gKF9hMyA9IGJ5dGVzID09IG51bGwgPyB2b2lkIDAgOiBieXRlcy5ieXRlTGVuZ3RoKSAhPSBudWxsID8gX2EzIDogMDtcbiAgICAgICAgICBpZiAoaXNFcnJvckxpa2UoYnl0ZXMpKSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShieXRlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgICAgICAgaWYgKGlzRXJyb3JlZChzdHJlYW0yKSkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBvbkFib3J0ZWQocmVhc29uKSB7XG4gICAgICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgcmVzcG9uc2UuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtMikpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IERPTUV4Y2VwdGlvbihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtMikpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihuZXcgVHlwZUVycm9yKFwidGVybWluYXRlZFwiLCB7XG4gICAgICAgICAgICAgIGNhdXNlOiBpc0Vycm9yTGlrZShyZWFzb24pID8gcmVhc29uIDogdm9pZCAwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBfX25hbWUob25BYm9ydGVkLCBcIm9uQWJvcnRlZFwiKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGRpc3BhdGNoKHsgYm9keSB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlci5kaXNwYXRjaChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXRoOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Mi5tZXRob2QsXG4gICAgICAgICAgICBib2R5OiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXIuaXNNb2NrQWN0aXZlID8gcmVxdWVzdDIuYm9keSAmJiByZXF1ZXN0Mi5ib2R5LnNvdXJjZSA6IGJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiBbLi4ucmVxdWVzdDIuaGVhZGVyc0xpc3RdLmZsYXQoKSxcbiAgICAgICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgICAgIGJvZHlUaW1lb3V0OiAzZTUsXG4gICAgICAgICAgICBoZWFkZXJzVGltZW91dDogM2U1XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgYWJvcnQ6IG51bGwsXG4gICAgICAgICAgICBvbkNvbm5lY3QoYWJvcnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyO1xuICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydChuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKFwidGVybWluYXRlZFwiLCBhYm9ydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSGVhZGVycyhzdGF0dXMsIGhlYWRlcnNMaXN0LCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1cyA8IDIwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgY29kaW5ncyA9IFtdO1xuICAgICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzTGlzdC5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNMaXN0W24gKyAwXS50b1N0cmluZyhcImxhdGluMVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBoZWFkZXJzTGlzdFtuICsgMV0udG9TdHJpbmcoXCJsYXRpbjFcIik7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtZW5jb2RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgY29kaW5ncyA9IHZhbC5zcGxpdChcIixcIikubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJsb2NhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYm9keSA9IG5ldyBSZWFkYWJsZSh7IHJlYWQ6IHJlc3VtZSB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZGVjb2RlcnMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3QyLm1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgcmVxdWVzdDIubWV0aG9kICE9PSBcIkNPTk5FQ1RcIiAmJiAhbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoc3RhdHVzKSAmJiAhKHJlcXVlc3QyLnJlZGlyZWN0ID09PSBcImZvbGxvd1wiICYmIGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29kaW5nIG9mIGNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgvKHgtKT9nemlwLy50ZXN0KGNvZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUd1bnppcCgpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoLyh4LSk/ZGVmbGF0ZS8udGVzdChjb2RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVJbmZsYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09IFwiYnJcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzTGlzdDogaGVhZGVyc1trSGVhZGVyc0xpc3RdLFxuICAgICAgICAgICAgICAgIGJvZHk6IGRlY29kZXJzLmxlbmd0aCA/IHBpcGVsaW5lKHRoaXMuYm9keSwgLi4uZGVjb2RlcnMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB9KSA6IHRoaXMuYm9keS5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EYXRhKGNodW5rKSB7XG4gICAgICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBjaHVuaztcbiAgICAgICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUgKz0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKFwidGVybWluYXRlZFwiLCB0aGlzLmFib3J0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcihlcnJvcjIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZihcInRlcm1pbmF0ZWRcIiwgdGhpcy5hYm9ydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF9hMyA9IHRoaXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5kZXN0cm95KGVycm9yMik7XG4gICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycm9yMik7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoZGlzcGF0Y2gsIFwiZGlzcGF0Y2hcIik7XG4gICAgfVxuICAgIF9fbmFtZShodHRwTmV0d29ya0ZldGNoLCBcImh0dHBOZXR3b3JrRmV0Y2hcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZmV0Y2gyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qc1xudmFyIHJlcXVpcmVfdW5kaWNpID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgQ2xpZW50ID0gcmVxdWlyZV9jbGllbnQoKTtcbiAgICB2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmVfZGlzcGF0Y2hlcigpO1xuICAgIHZhciBlcnJvcnMgPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBQb29sID0gcmVxdWlyZV9wb29sKCk7XG4gICAgdmFyIEJhbGFuY2VkUG9vbCA9IHJlcXVpcmVfYmFsYW5jZWRfcG9vbCgpO1xuICAgIHZhciBBZ2VudCA9IHJlcXVpcmVfYWdlbnQoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IGVycm9ycztcbiAgICB2YXIgYXBpID0gcmVxdWlyZV9hcGkoKTtcbiAgICB2YXIgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlX2Nvbm5lY3QoKTtcbiAgICB2YXIgTW9ja0NsaWVudCA9IHJlcXVpcmVfbW9ja19jbGllbnQoKTtcbiAgICB2YXIgTW9ja0FnZW50ID0gcmVxdWlyZV9tb2NrX2FnZW50KCk7XG4gICAgdmFyIE1vY2tQb29sID0gcmVxdWlyZV9tb2NrX3Bvb2woKTtcbiAgICB2YXIgbW9ja0Vycm9ycyA9IHJlcXVpcmVfbW9ja19lcnJvcnMoKTtcbiAgICB2YXIgUHJveHlBZ2VudCA9IHJlcXVpcmVfcHJveHlfYWdlbnQoKTtcbiAgICB2YXIgeyBnZXRHbG9iYWxEaXNwYXRjaGVyLCBzZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlX2dsb2JhbCgpO1xuICAgIHZhciBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIik7XG4gICAgdmFyIG5vZGVNYWpvciA9IE51bWJlcihub2RlVmVyc2lvblswXSk7XG4gICAgdmFyIG5vZGVNaW5vciA9IE51bWJlcihub2RlVmVyc2lvblsxXSk7XG4gICAgT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuRGlzcGF0Y2hlciA9IERpc3BhdGNoZXI7XG4gICAgbW9kdWxlMi5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuUG9vbCA9IFBvb2w7XG4gICAgbW9kdWxlMi5leHBvcnRzLkJhbGFuY2VkUG9vbCA9IEJhbGFuY2VkUG9vbDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuQWdlbnQgPSBBZ2VudDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuUHJveHlBZ2VudCA9IFByb3h5QWdlbnQ7XG4gICAgbW9kdWxlMi5leHBvcnRzLmJ1aWxkQ29ubmVjdG9yID0gYnVpbGRDb25uZWN0b3I7XG4gICAgbW9kdWxlMi5leHBvcnRzLmVycm9ycyA9IGVycm9ycztcbiAgICBmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlcihmbikge1xuICAgICAgcmV0dXJuICh1cmwsIG9wdHMsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBoYW5kbGVyID0gb3B0cztcbiAgICAgICAgICBvcHRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB1cmwgIT09IFwib2JqZWN0XCIgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCB1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3B0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHMucGF0aFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBhdGg3ID0gb3B0cy5wYXRoO1xuICAgICAgICAgIGlmICghb3B0cy5wYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBwYXRoNyA9IGAvJHtwYXRoN31gO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cmwgPSBuZXcgVVJMKHV0aWwyLnBhcnNlT3JpZ2luKHVybCkub3JpZ2luICsgcGF0aDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgPyB1cmwgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXJsID0gdXRpbDIucGFyc2VVUkwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzO1xuICAgICAgICBpZiAoYWdlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBvcHRzLmFnZW50LiBEaWQgeW91IG1lYW4gb3B0cy5jbGllbnQ/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGRpc3BhdGNoZXIsIHtcbiAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgICAgICBwYXRoOiB1cmwuc2VhcmNoID8gYCR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH1gIDogdXJsLnBhdGhuYW1lLFxuICAgICAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgKG9wdHMuYm9keSA/IFwiUFVUXCIgOiBcIkdFVFwiKVxuICAgICAgICB9LCBoYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShtYWtlRGlzcGF0Y2hlciwgXCJtYWtlRGlzcGF0Y2hlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXI7XG4gICAgbW9kdWxlMi5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyO1xuICAgIGlmIChub2RlTWFqb3IgPiAxNiB8fCBub2RlTWFqb3IgPT09IDE2ICYmIG5vZGVNaW5vciA+PSA4KSB7XG4gICAgICBsZXQgZmV0Y2hJbXBsID0gbnVsbDtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5mZXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24gZmV0Y2gyKHJlc291cmNlKSB7XG4gICAgICAgIGlmICghZmV0Y2hJbXBsKSB7XG4gICAgICAgICAgZmV0Y2hJbXBsID0gcmVxdWlyZV9mZXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLmRpc3BhdGNoZXIgfHwgZ2V0R2xvYmFsRGlzcGF0Y2hlcigpO1xuICAgICAgICByZXR1cm4gZmV0Y2hJbXBsLmFwcGx5KGRpc3BhdGNoZXIsIGFyZ3VtZW50cyk7XG4gICAgICB9LCBcImZldGNoXCIpO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLkhlYWRlcnMgPSByZXF1aXJlX2hlYWRlcnMoKS5IZWFkZXJzO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLlJlc3BvbnNlID0gcmVxdWlyZV9yZXNwb25zZSgpLlJlc3BvbnNlO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLlJlcXVlc3QgPSByZXF1aXJlX3JlcXVlc3QyKCkuUmVxdWVzdDtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5Gb3JtRGF0YSA9IHJlcXVpcmVfZm9ybWRhdGEoKS5Gb3JtRGF0YTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5GaWxlID0gcmVxdWlyZV9maWxlKCkuRmlsZTtcbiAgICB9XG4gICAgbW9kdWxlMi5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdCk7XG4gICAgbW9kdWxlMi5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSk7XG4gICAgbW9kdWxlMi5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdCk7XG4gICAgbW9kdWxlMi5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSk7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1vY2tDbGllbnQgPSBNb2NrQ2xpZW50O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Nb2NrUG9vbCA9IE1vY2tQb29sO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Nb2NrQWdlbnQgPSBNb2NrQWdlbnQ7XG4gICAgbW9kdWxlMi5leHBvcnRzLm1vY2tFcnJvcnMgPSBtb2NrRXJyb3JzO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RvdGVudkAxNi4wLjEvbm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qc1xudmFyIHJlcXVpcmVfbWFpbjIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZG90ZW52QDE2LjAuMS9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBmczExID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciBwYXRoNyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBvczMgPSByZXF1aXJlKFwib3NcIik7XG4gICAgdmFyIExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZztcbiAgICBmdW5jdGlvbiBwYXJzZTIoc3JjKSB7XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIGxldCBsaW5lcyA9IHNyYy50b1N0cmluZygpO1xuICAgICAgbGluZXMgPSBsaW5lcy5yZXBsYWNlKC9cXHJcXG4/L21nLCBcIlxcblwiKTtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdO1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXRjaFsyXSB8fCBcIlwiO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgY29uc3QgbWF5YmVRdW90ZSA9IHZhbHVlWzBdO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgXCIkMlwiKTtcbiAgICAgICAgaWYgKG1heWJlUXVvdGUgPT09ICdcIicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHIvZywgXCJcXHJcIik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZTIsIFwicGFyc2VcIik7XG4gICAgZnVuY3Rpb24gX2xvZyhtZXNzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW2RvdGVudl1bREVCVUddICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgX19uYW1lKF9sb2csIFwiX2xvZ1wiKTtcbiAgICBmdW5jdGlvbiBfcmVzb2x2ZUhvbWUoZW52UGF0aCkge1xuICAgICAgcmV0dXJuIGVudlBhdGhbMF0gPT09IFwiflwiID8gcGF0aDcuam9pbihvczMuaG9tZWRpcigpLCBlbnZQYXRoLnNsaWNlKDEpKSA6IGVudlBhdGg7XG4gICAgfVxuICAgIF9fbmFtZShfcmVzb2x2ZUhvbWUsIFwiX3Jlc29sdmVIb21lXCIpO1xuICAgIGZ1bmN0aW9uIGNvbmZpZzIob3B0aW9ucykge1xuICAgICAgbGV0IGRvdGVudlBhdGggPSBwYXRoNy5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIFwiLmVudlwiKTtcbiAgICAgIGxldCBlbmNvZGluZyA9IFwidXRmOFwiO1xuICAgICAgY29uc3QgZGVidWcxMyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMub3ZlcnJpZGUpO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgZG90ZW52UGF0aCA9IF9yZXNvbHZlSG9tZShvcHRpb25zLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nICE9IG51bGwpIHtcbiAgICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmczExLnJlYWRGaWxlU3luYyhkb3RlbnZQYXRoLCB7IGVuY29kaW5nIH0pKTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3MuZW52LCBrZXkpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudltrZXldID0gcGFyc2VkW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudltrZXldID0gcGFyc2VkW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcxMykge1xuICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfbG9nKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBcXGBwcm9jZXNzLmVudlxcYCBhbmQgV0FTIG92ZXJ3cml0dGVuYCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2xvZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gXFxgcHJvY2Vzcy5lbnZcXGAgYW5kIHdhcyBOT1Qgb3ZlcndyaXR0ZW5gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHBhcnNlZCB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZGVidWcxMykge1xuICAgICAgICAgIF9sb2coYEZhaWxlZCB0byBsb2FkICR7ZG90ZW52UGF0aH0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGNvbmZpZzIsIFwiY29uZmlnXCIpO1xuICAgIHZhciBEb3RlbnZNb2R1bGUgPSB7XG4gICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICBwYXJzZTogcGFyc2UyXG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29uZmlnID0gRG90ZW52TW9kdWxlLmNvbmZpZztcbiAgICBtb2R1bGUyLmV4cG9ydHMucGFyc2UgPSBEb3RlbnZNb2R1bGUucGFyc2U7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gRG90ZW52TW9kdWxlO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FyZ0A1LjAuMi9ub2RlX21vZHVsZXMvYXJnL2luZGV4LmpzXG52YXIgcmVxdWlyZV9hcmcgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXJnQDUuMC4yL25vZGVfbW9kdWxlcy9hcmcvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGZsYWdTeW1ib2wgPSBTeW1ib2woXCJhcmcgZmxhZ1wiKTtcbiAgICB2YXIgQXJnRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFyZ0Vycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBcmdFcnJvci5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEFyZ0Vycm9yLCBcIkFyZ0Vycm9yXCIpO1xuICAgIGZ1bmN0aW9uIGFyZzIob3B0cywge1xuICAgICAgYXJndiA9IHByb2Nlc3MuYXJndi5zbGljZSgyKSxcbiAgICAgIHBlcm1pc3NpdmUgPSBmYWxzZSxcbiAgICAgIHN0b3BBdFBvc2l0aW9uYWwgPSBmYWxzZVxuICAgIH0gPSB7fSkge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICBcImFyZ3VtZW50IHNwZWNpZmljYXRpb24gb2JqZWN0IGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgXCJBUkdfQ09ORklHX05PX1NQRUNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0geyBfOiBbXSB9O1xuICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdHMpKSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFyZ0Vycm9yKFxuICAgICAgICAgICAgXCJhcmd1bWVudCBrZXkgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiLFxuICAgICAgICAgICAgXCJBUkdfQ09ORklHX0VNUFRZX0tFWVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5WzBdICE9PSBcIi1cIikge1xuICAgICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICAgIGBhcmd1bWVudCBrZXkgbXVzdCBzdGFydCB3aXRoICctJyBidXQgZm91bmQ6ICcke2tleX0nYCxcbiAgICAgICAgICAgIFwiQVJHX0NPTkZJR19OT05PUFRfS0VZXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFyZ0Vycm9yKFxuICAgICAgICAgICAgYGFyZ3VtZW50IGtleSBtdXN0IGhhdmUgYSBuYW1lOyBzaW5ndWxhciAnLScga2V5cyBhcmUgbm90IGFsbG93ZWQ6ICR7a2V5fWAsXG4gICAgICAgICAgICBcIkFSR19DT05GSUdfTk9OQU1FX0tFWVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGFsaWFzZXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9wdHNba2V5XTtcbiAgICAgICAgbGV0IGlzRmxhZyA9IGZhbHNlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdHlwZVswXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgW2ZuXSA9IHR5cGU7XG4gICAgICAgICAgdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHZhbHVlLCBuYW1lLCBwcmV2ID0gW10pID0+IHtcbiAgICAgICAgICAgIHByZXYucHVzaChmbih2YWx1ZSwgbmFtZSwgcHJldltwcmV2Lmxlbmd0aCAtIDFdKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICB9LCBcInR5cGVcIik7XG4gICAgICAgICAgaXNGbGFnID0gZm4gPT09IEJvb2xlYW4gfHwgZm5bZmxhZ1N5bWJvbF0gPT09IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlzRmxhZyA9IHR5cGUgPT09IEJvb2xlYW4gfHwgdHlwZVtmbGFnU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICBgdHlwZSBtaXNzaW5nIG9yIG5vdCBhIGZ1bmN0aW9uIG9yIHZhbGlkIGFycmF5IHR5cGU6ICR7a2V5fWAsXG4gICAgICAgICAgICBcIkFSR19DT05GSUdfVkFEX1RZUEVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVsxXSAhPT0gXCItXCIgJiYga2V5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICBgc2hvcnQgYXJndW1lbnQga2V5cyAod2l0aCBhIHNpbmdsZSBoeXBoZW4pIG11c3QgaGF2ZSBvbmx5IG9uZSBjaGFyYWN0ZXI6ICR7a2V5fWAsXG4gICAgICAgICAgICBcIkFSR19DT05GSUdfU0hPUlRPUFRfVE9PTE9OR1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyc1trZXldID0gW3R5cGUsIGlzRmxhZ107XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJndi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB3aG9sZUFyZyA9IGFyZ3ZbaV07XG4gICAgICAgIGlmIChzdG9wQXRQb3NpdGlvbmFsICYmIHJlc3VsdC5fLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXN1bHQuXyA9IHJlc3VsdC5fLmNvbmNhdChhcmd2LnNsaWNlKGkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hvbGVBcmcgPT09IFwiLS1cIikge1xuICAgICAgICAgIHJlc3VsdC5fID0gcmVzdWx0Ll8uY29uY2F0KGFyZ3Yuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hvbGVBcmcubGVuZ3RoID4gMSAmJiB3aG9sZUFyZ1swXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICBjb25zdCBzZXBhcmF0ZWRBcmd1bWVudHMgPSB3aG9sZUFyZ1sxXSA9PT0gXCItXCIgfHwgd2hvbGVBcmcubGVuZ3RoID09PSAyID8gW3dob2xlQXJnXSA6IHdob2xlQXJnLnNsaWNlKDEpLnNwbGl0KFwiXCIpLm1hcCgoYSkgPT4gYC0ke2F9YCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZXBhcmF0ZWRBcmd1bWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZzMgPSBzZXBhcmF0ZWRBcmd1bWVudHNbal07XG4gICAgICAgICAgICBjb25zdCBbb3JpZ2luYWxBcmdOYW1lLCBhcmdTdHJdID0gYXJnM1sxXSA9PT0gXCItXCIgPyBhcmczLnNwbGl0KC89KC4qKS8sIDIpIDogW2FyZzMsIHZvaWQgMF07XG4gICAgICAgICAgICBsZXQgYXJnTmFtZSA9IG9yaWdpbmFsQXJnTmFtZTtcbiAgICAgICAgICAgIHdoaWxlIChhcmdOYW1lIGluIGFsaWFzZXMpIHtcbiAgICAgICAgICAgICAgYXJnTmFtZSA9IGFsaWFzZXNbYXJnTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShhcmdOYW1lIGluIGhhbmRsZXJzKSkge1xuICAgICAgICAgICAgICBpZiAocGVybWlzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fLnB1c2goYXJnMyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ0Vycm9yKFxuICAgICAgICAgICAgICAgICAgYHVua25vd24gb3IgdW5leHBlY3RlZCBvcHRpb246ICR7b3JpZ2luYWxBcmdOYW1lfWAsXG4gICAgICAgICAgICAgICAgICBcIkFSR19VTktOT1dOX09QVElPTlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3R5cGUsIGlzRmxhZ10gPSBoYW5kbGVyc1thcmdOYW1lXTtcbiAgICAgICAgICAgIGlmICghaXNGbGFnICYmIGogKyAxIDwgc2VwYXJhdGVkQXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICAgICAgYG9wdGlvbiByZXF1aXJlcyBhcmd1bWVudCAoYnV0IHdhcyBmb2xsb3dlZCBieSBhbm90aGVyIHNob3J0IGFyZ3VtZW50KTogJHtvcmlnaW5hbEFyZ05hbWV9YCxcbiAgICAgICAgICAgICAgICBcIkFSR19NSVNTSU5HX1JFUVVJUkVEX1NIT1JUQVJHXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZsYWcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W2FyZ05hbWVdID0gdHlwZSh0cnVlLCBhcmdOYW1lLCByZXN1bHRbYXJnTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdTdHIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBpZiAoYXJndi5sZW5ndGggPCBpICsgMiB8fCBhcmd2W2kgKyAxXS5sZW5ndGggPiAxICYmIGFyZ3ZbaSArIDFdWzBdID09PSBcIi1cIiAmJiAhKGFyZ3ZbaSArIDFdLm1hdGNoKC9eLT9cXGQqKFxcLig/PVxcZCkpP1xcZCokLykgJiYgKHR5cGUgPT09IE51bWJlciB8fCB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGUgPT09IEJpZ0ludCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWQgPSBvcmlnaW5hbEFyZ05hbWUgPT09IGFyZ05hbWUgPyBcIlwiIDogYCAoYWxpYXMgZm9yICR7YXJnTmFtZX0pYDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgb3B0aW9uIHJlcXVpcmVzIGFyZ3VtZW50OiAke29yaWdpbmFsQXJnTmFtZX0ke2V4dGVuZGVkfWAsXG4gICAgICAgICAgICAgICAgICBcIkFSR19NSVNTSU5HX1JFUVVJUkVEX0xPTkdBUkdcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0W2FyZ05hbWVdID0gdHlwZShhcmd2W2kgKyAxXSwgYXJnTmFtZSwgcmVzdWx0W2FyZ05hbWVdKTtcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0W2FyZ05hbWVdID0gdHlwZShhcmdTdHIsIGFyZ05hbWUsIHJlc3VsdFthcmdOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fLnB1c2god2hvbGVBcmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUoYXJnMiwgXCJhcmdcIik7XG4gICAgYXJnMi5mbGFnID0gKGZuKSA9PiB7XG4gICAgICBmbltmbGFnU3ltYm9sXSA9IHRydWU7XG4gICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBhcmcyLkNPVU5UID0gYXJnMi5mbGFnKCh2LCBuYW1lLCBleGlzdGluZ0NvdW50KSA9PiAoZXhpc3RpbmdDb3VudCB8fCAwKSArIDEpO1xuICAgIGFyZzIuQXJnRXJyb3IgPSBBcmdFcnJvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBhcmcyO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21pbi1pbmRlbnRAMS4wLjEvbm9kZV9tb2R1bGVzL21pbi1pbmRlbnQvaW5kZXguanNcbnZhciByZXF1aXJlX21pbl9pbmRlbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWluLWluZGVudEAxLjAuMS9ub2RlX21vZHVsZXMvbWluLWluZGVudC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAoc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXlsgXFx0XSooPz1cXFMpL2dtKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2gucmVkdWNlKChyLCBhKSA9PiBNYXRoLm1pbihyLCBhLmxlbmd0aCksIEluZmluaXR5KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmlwLWluZGVudEAzLjAuMC9ub2RlX21vZHVsZXMvc3RyaXAtaW5kZW50L2luZGV4LmpzXG52YXIgcmVxdWlyZV9zdHJpcF9pbmRlbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyaXAtaW5kZW50QDMuMC4wL25vZGVfbW9kdWxlcy9zdHJpcC1pbmRlbnQvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG1pbkluZGVudCA9IHJlcXVpcmVfbWluX2luZGVudCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudDQgPSBtaW5JbmRlbnQoc3RyaW5nKTtcbiAgICAgIGlmIChpbmRlbnQ0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF5bIFxcXFx0XXske2luZGVudDR9fWAsIFwiZ21cIik7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGx1cmFsaXplQDguMC4wL25vZGVfbW9kdWxlcy9wbHVyYWxpemUvcGx1cmFsaXplLmpzXG52YXIgcmVxdWlyZV9wbHVyYWxpemUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGx1cmFsaXplQDguMC4wL25vZGVfbW9kdWxlcy9wbHVyYWxpemUvcGx1cmFsaXplLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIChmdW5jdGlvbihyb290LCBwbHVyYWxpemUyKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBwbHVyYWxpemUyKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBmYWxzZSkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdXJhbGl6ZTIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnBsdXJhbGl6ZSA9IHBsdXJhbGl6ZTIoKTtcbiAgICAgIH1cbiAgICB9KShleHBvcnRzLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwbHVyYWxSdWxlcyA9IFtdO1xuICAgICAgdmFyIHNpbmd1bGFyUnVsZXMgPSBbXTtcbiAgICAgIHZhciB1bmNvdW50YWJsZXMgPSB7fTtcbiAgICAgIHZhciBpcnJlZ3VsYXJQbHVyYWxzID0ge307XG4gICAgICB2YXIgaXJyZWd1bGFyU2luZ2xlcyA9IHt9O1xuICAgICAgZnVuY3Rpb24gc2FuaXRpemVSdWxlKHJ1bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIgKyBydWxlICsgXCIkXCIsIFwiaVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzYW5pdGl6ZVJ1bGUsIFwic2FuaXRpemVSdWxlXCIpO1xuICAgICAgZnVuY3Rpb24gcmVzdG9yZUNhc2Uod29yZCwgdG9rZW4pIHtcbiAgICAgICAgaWYgKHdvcmQgPT09IHRva2VuKVxuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgaWYgKHdvcmQgPT09IHdvcmQudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICByZXR1cm4gdG9rZW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHdvcmQgPT09IHdvcmQudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICByZXR1cm4gdG9rZW4udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHdvcmRbMF0gPT09IHdvcmRbMF0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRva2VuLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgX19uYW1lKHJlc3RvcmVDYXNlLCBcInJlc3RvcmVDYXNlXCIpO1xuICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RyLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFwkKFxcZHsxLDJ9KS9nLCBmdW5jdGlvbihtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoaW50ZXJwb2xhdGUsIFwiaW50ZXJwb2xhdGVcIik7XG4gICAgICBmdW5jdGlvbiByZXBsYWNlKHdvcmQsIHJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHdvcmQucmVwbGFjZShydWxlWzBdLCBmdW5jdGlvbihtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGUocnVsZVsxXSwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0b3JlQ2FzZSh3b3JkW2luZGV4IC0gMV0sIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN0b3JlQ2FzZShtYXRjaCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBfX25hbWUocmVwbGFjZSwgXCJyZXBsYWNlXCIpO1xuICAgICAgZnVuY3Rpb24gc2FuaXRpemVXb3JkKHRva2VuLCB3b3JkLCBydWxlcykge1xuICAgICAgICBpZiAoIXRva2VuLmxlbmd0aCB8fCB1bmNvdW50YWJsZXMuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tsZW5dO1xuICAgICAgICAgIGlmIChydWxlWzBdLnRlc3Qod29yZCkpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZSh3b3JkLCBydWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzYW5pdGl6ZVdvcmQsIFwic2FuaXRpemVXb3JkXCIpO1xuICAgICAgZnVuY3Rpb24gcmVwbGFjZVdvcmQocmVwbGFjZU1hcCwga2VlcE1hcCwgcnVsZXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGtlZXBNYXAuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdG9yZUNhc2Uod29yZCwgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVwbGFjZU1hcC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0b3JlQ2FzZSh3b3JkLCByZXBsYWNlTWFwW3Rva2VuXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzYW5pdGl6ZVdvcmQodG9rZW4sIHdvcmQsIHJ1bGVzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShyZXBsYWNlV29yZCwgXCJyZXBsYWNlV29yZFwiKTtcbiAgICAgIGZ1bmN0aW9uIGNoZWNrV29yZChyZXBsYWNlTWFwLCBrZWVwTWFwLCBydWxlcywgYm9vbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoa2VlcE1hcC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAocmVwbGFjZU1hcC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHNhbml0aXplV29yZCh0b2tlbiwgdG9rZW4sIHJ1bGVzKSA9PT0gdG9rZW47XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBfX25hbWUoY2hlY2tXb3JkLCBcImNoZWNrV29yZFwiKTtcbiAgICAgIGZ1bmN0aW9uIHBsdXJhbGl6ZTIod29yZCwgY291bnQyLCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQgPSBjb3VudDIgPT09IDEgPyBwbHVyYWxpemUyLnNpbmd1bGFyKHdvcmQpIDogcGx1cmFsaXplMi5wbHVyYWwod29yZCk7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZlID8gY291bnQyICsgXCIgXCIgOiBcIlwiKSArIHBsdXJhbGl6ZWQ7XG4gICAgICB9XG4gICAgICBfX25hbWUocGx1cmFsaXplMiwgXCJwbHVyYWxpemVcIik7XG4gICAgICBwbHVyYWxpemUyLnBsdXJhbCA9IHJlcGxhY2VXb3JkKFxuICAgICAgICBpcnJlZ3VsYXJTaW5nbGVzLFxuICAgICAgICBpcnJlZ3VsYXJQbHVyYWxzLFxuICAgICAgICBwbHVyYWxSdWxlc1xuICAgICAgKTtcbiAgICAgIHBsdXJhbGl6ZTIuaXNQbHVyYWwgPSBjaGVja1dvcmQoXG4gICAgICAgIGlycmVndWxhclNpbmdsZXMsXG4gICAgICAgIGlycmVndWxhclBsdXJhbHMsXG4gICAgICAgIHBsdXJhbFJ1bGVzXG4gICAgICApO1xuICAgICAgcGx1cmFsaXplMi5zaW5ndWxhciA9IHJlcGxhY2VXb3JkKFxuICAgICAgICBpcnJlZ3VsYXJQbHVyYWxzLFxuICAgICAgICBpcnJlZ3VsYXJTaW5nbGVzLFxuICAgICAgICBzaW5ndWxhclJ1bGVzXG4gICAgICApO1xuICAgICAgcGx1cmFsaXplMi5pc1Npbmd1bGFyID0gY2hlY2tXb3JkKFxuICAgICAgICBpcnJlZ3VsYXJQbHVyYWxzLFxuICAgICAgICBpcnJlZ3VsYXJTaW5nbGVzLFxuICAgICAgICBzaW5ndWxhclJ1bGVzXG4gICAgICApO1xuICAgICAgcGx1cmFsaXplMi5hZGRQbHVyYWxSdWxlID0gZnVuY3Rpb24ocnVsZSwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcGx1cmFsUnVsZXMucHVzaChbc2FuaXRpemVSdWxlKHJ1bGUpLCByZXBsYWNlbWVudF0pO1xuICAgICAgfTtcbiAgICAgIHBsdXJhbGl6ZTIuYWRkU2luZ3VsYXJSdWxlID0gZnVuY3Rpb24ocnVsZSwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgc2luZ3VsYXJSdWxlcy5wdXNoKFtzYW5pdGl6ZVJ1bGUocnVsZSksIHJlcGxhY2VtZW50XSk7XG4gICAgICB9O1xuICAgICAgcGx1cmFsaXplMi5hZGRVbmNvdW50YWJsZVJ1bGUgPSBmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd29yZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHVuY291bnRhYmxlc1t3b3JkLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGx1cmFsaXplMi5hZGRQbHVyYWxSdWxlKHdvcmQsIFwiJDBcIik7XG4gICAgICAgIHBsdXJhbGl6ZTIuYWRkU2luZ3VsYXJSdWxlKHdvcmQsIFwiJDBcIik7XG4gICAgICB9O1xuICAgICAgcGx1cmFsaXplMi5hZGRJcnJlZ3VsYXJSdWxlID0gZnVuY3Rpb24oc2luZ2xlLCBwbHVyYWwpIHtcbiAgICAgICAgcGx1cmFsID0gcGx1cmFsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHNpbmdsZSA9IHNpbmdsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpcnJlZ3VsYXJTaW5nbGVzW3NpbmdsZV0gPSBwbHVyYWw7XG4gICAgICAgIGlycmVndWxhclBsdXJhbHNbcGx1cmFsXSA9IHNpbmdsZTtcbiAgICAgIH07XG4gICAgICBbXG4gICAgICAgIFtcIklcIiwgXCJ3ZVwiXSxcbiAgICAgICAgW1wibWVcIiwgXCJ1c1wiXSxcbiAgICAgICAgW1wiaGVcIiwgXCJ0aGV5XCJdLFxuICAgICAgICBbXCJzaGVcIiwgXCJ0aGV5XCJdLFxuICAgICAgICBbXCJ0aGVtXCIsIFwidGhlbVwiXSxcbiAgICAgICAgW1wibXlzZWxmXCIsIFwib3Vyc2VsdmVzXCJdLFxuICAgICAgICBbXCJ5b3Vyc2VsZlwiLCBcInlvdXJzZWx2ZXNcIl0sXG4gICAgICAgIFtcIml0c2VsZlwiLCBcInRoZW1zZWx2ZXNcIl0sXG4gICAgICAgIFtcImhlcnNlbGZcIiwgXCJ0aGVtc2VsdmVzXCJdLFxuICAgICAgICBbXCJoaW1zZWxmXCIsIFwidGhlbXNlbHZlc1wiXSxcbiAgICAgICAgW1widGhlbXNlbGZcIiwgXCJ0aGVtc2VsdmVzXCJdLFxuICAgICAgICBbXCJpc1wiLCBcImFyZVwiXSxcbiAgICAgICAgW1wid2FzXCIsIFwid2VyZVwiXSxcbiAgICAgICAgW1wiaGFzXCIsIFwiaGF2ZVwiXSxcbiAgICAgICAgW1widGhpc1wiLCBcInRoZXNlXCJdLFxuICAgICAgICBbXCJ0aGF0XCIsIFwidGhvc2VcIl0sXG4gICAgICAgIFtcImVjaG9cIiwgXCJlY2hvZXNcIl0sXG4gICAgICAgIFtcImRpbmdvXCIsIFwiZGluZ29lc1wiXSxcbiAgICAgICAgW1widm9sY2Fub1wiLCBcInZvbGNhbm9lc1wiXSxcbiAgICAgICAgW1widG9ybmFkb1wiLCBcInRvcm5hZG9lc1wiXSxcbiAgICAgICAgW1widG9ycGVkb1wiLCBcInRvcnBlZG9lc1wiXSxcbiAgICAgICAgW1wiZ2VudXNcIiwgXCJnZW5lcmFcIl0sXG4gICAgICAgIFtcInZpc2N1c1wiLCBcInZpc2NlcmFcIl0sXG4gICAgICAgIFtcInN0aWdtYVwiLCBcInN0aWdtYXRhXCJdLFxuICAgICAgICBbXCJzdG9tYVwiLCBcInN0b21hdGFcIl0sXG4gICAgICAgIFtcImRvZ21hXCIsIFwiZG9nbWF0YVwiXSxcbiAgICAgICAgW1wibGVtbWFcIiwgXCJsZW1tYXRhXCJdLFxuICAgICAgICBbXCJzY2hlbWFcIiwgXCJzY2hlbWF0YVwiXSxcbiAgICAgICAgW1wiYW5hdGhlbWFcIiwgXCJhbmF0aGVtYXRhXCJdLFxuICAgICAgICBbXCJveFwiLCBcIm94ZW5cIl0sXG4gICAgICAgIFtcImF4ZVwiLCBcImF4ZXNcIl0sXG4gICAgICAgIFtcImRpZVwiLCBcImRpY2VcIl0sXG4gICAgICAgIFtcInllc1wiLCBcInllc2VzXCJdLFxuICAgICAgICBbXCJmb290XCIsIFwiZmVldFwiXSxcbiAgICAgICAgW1wiZWF2ZVwiLCBcImVhdmVzXCJdLFxuICAgICAgICBbXCJnb29zZVwiLCBcImdlZXNlXCJdLFxuICAgICAgICBbXCJ0b290aFwiLCBcInRlZXRoXCJdLFxuICAgICAgICBbXCJxdWl6XCIsIFwicXVpenplc1wiXSxcbiAgICAgICAgW1wiaHVtYW5cIiwgXCJodW1hbnNcIl0sXG4gICAgICAgIFtcInByb29mXCIsIFwicHJvb2ZzXCJdLFxuICAgICAgICBbXCJjYXJ2ZVwiLCBcImNhcnZlc1wiXSxcbiAgICAgICAgW1widmFsdmVcIiwgXCJ2YWx2ZXNcIl0sXG4gICAgICAgIFtcImxvb2V5XCIsIFwibG9vaWVzXCJdLFxuICAgICAgICBbXCJ0aGllZlwiLCBcInRoaWV2ZXNcIl0sXG4gICAgICAgIFtcImdyb292ZVwiLCBcImdyb292ZXNcIl0sXG4gICAgICAgIFtcInBpY2theGVcIiwgXCJwaWNrYXhlc1wiXSxcbiAgICAgICAgW1wicGFzc2VyYnlcIiwgXCJwYXNzZXJzYnlcIl1cbiAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWxpemUyLmFkZElycmVndWxhclJ1bGUocnVsZVswXSwgcnVsZVsxXSk7XG4gICAgICB9KTtcbiAgICAgIFtcbiAgICAgICAgWy9zPyQvaSwgXCJzXCJdLFxuICAgICAgICBbL1teXFx1MDAwMC1cXHUwMDdGXSQvaSwgXCIkMFwiXSxcbiAgICAgICAgWy8oW15hZWlvdV1lc2UpJC9pLCBcIiQxXCJdLFxuICAgICAgICBbLyhheHx0ZXN0KWlzJC9pLCBcIiQxZXNcIl0sXG4gICAgICAgIFsvKGFsaWFzfFteYW91XXVzfHRbbG1dYXN8Z2FzfHJpcykkL2ksIFwiJDFlc1wiXSxcbiAgICAgICAgWy8oZVttbl11KXM/JC9pLCBcIiQxc1wiXSxcbiAgICAgICAgWy8oW15sXWlhc3xbYWVpb3VdbGFzfFtlanpyXWFzfFtpdV1hbSkkL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKGFsdW1ufHN5bGxhYnx2aXJ8cmFkaXxudWNsZXxmdW5nfGNhY3R8c3RpbXVsfHRlcm1pbnxiYWNpbGx8Zm9jfHV0ZXJ8bG9jfHN0cmF0KSg/OnVzfGkpJC9pLCBcIiQxaVwiXSxcbiAgICAgICAgWy8oYWx1bW58YWxnfHZlcnRlYnIpKD86YXxhZSkkL2ksIFwiJDFhZVwiXSxcbiAgICAgICAgWy8oc2VyYXBofGNoZXJ1YikoPzppbSk/JC9pLCBcIiQxaW1cIl0sXG4gICAgICAgIFsvKGhlcnxhdHxncilvJC9pLCBcIiQxb2VzXCJdLFxuICAgICAgICBbLyhhZ2VuZHxhZGRlbmR8bWlsbGVubml8ZGF0fGV4dHJlbXxiYWN0ZXJpfGRlc2lkZXJhdHxzdHJhdHxjYW5kZWxhYnJ8ZXJyYXR8b3Z8c3ltcG9zaXxjdXJyaWN1bHxhdXRvbWF0fHF1b3IpKD86YXx1bSkkL2ksIFwiJDFhXCJdLFxuICAgICAgICBbLyhhcGhlbGl8aHlwZXJiYXR8cGVyaWhlbGl8YXN5bmRldHxub3VtZW58cGhlbm9tZW58Y3JpdGVyaXxvcmdhbnxwcm9sZWdvbWVufGhlZHJ8YXV0b21hdCkoPzphfG9uKSQvaSwgXCIkMWFcIl0sXG4gICAgICAgIFsvc2lzJC9pLCBcInNlc1wiXSxcbiAgICAgICAgWy8oPzooa25pfHdpfGxpKWZlfChhcnxsfGVhfGVvfG9hfGhvbylmKSQvaSwgXCIkMSQydmVzXCJdLFxuICAgICAgICBbLyhbXmFlaW91eV18cXUpeSQvaSwgXCIkMWllc1wiXSxcbiAgICAgICAgWy8oW15jaF1baWVvXVtsbl0pZXkkL2ksIFwiJDFpZXNcIl0sXG4gICAgICAgIFsvKHh8Y2h8c3N8c2h8enopJC9pLCBcIiQxZXNcIl0sXG4gICAgICAgIFsvKG1hdHJ8Y29kfG11cnxzaWx8dmVydHxpbmR8YXBwZW5kKSg/Oml4fGV4KSQvaSwgXCIkMWljZXNcIl0sXG4gICAgICAgIFsvXFxiKCg/OnRpdCk/bXxsKSg/OmljZXxvdXNlKSQvaSwgXCIkMWljZVwiXSxcbiAgICAgICAgWy8ocGUpKD86cnNvbnxvcGxlKSQvaSwgXCIkMW9wbGVcIl0sXG4gICAgICAgIFsvKGNoaWxkKSg/OnJlbik/JC9pLCBcIiQxcmVuXCJdLFxuICAgICAgICBbL2VhdXgkL2ksIFwiJDBcIl0sXG4gICAgICAgIFsvbVthZV1uJC9pLCBcIm1lblwiXSxcbiAgICAgICAgW1widGhvdVwiLCBcInlvdVwiXVxuICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbGl6ZTIuYWRkUGx1cmFsUnVsZShydWxlWzBdLCBydWxlWzFdKTtcbiAgICAgIH0pO1xuICAgICAgW1xuICAgICAgICBbL3MkL2ksIFwiXCJdLFxuICAgICAgICBbLyhzcykkL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKHdpfGtuaXwoPzphZnRlcnxoYWxmfGhpZ2h8bG93fG1pZHxub258bmlnaHR8W15cXHddfF4pbGkpdmVzJC9pLCBcIiQxZmVcIl0sXG4gICAgICAgIFsvKGFyfCg/OndvfFthZV0pbHxbZW9dW2FvXSl2ZXMkL2ksIFwiJDFmXCJdLFxuICAgICAgICBbL2llcyQvaSwgXCJ5XCJdLFxuICAgICAgICBbL1xcYihbcGxdfHpvbWJ8KD86bmVja3xjcm9zcyk/dHxjb2xsfGZhZXJ8Zm9vZHxnZW58Z29vbnxncm91cHxsYXNzfHRhbGt8Z29hbHxjdXQpaWVzJC9pLCBcIiQxaWVcIl0sXG4gICAgICAgIFsvXFxiKG1vbnxzbWlsKWllcyQvaSwgXCIkMWV5XCJdLFxuICAgICAgICBbL1xcYigoPzp0aXQpP218bClpY2UkL2ksIFwiJDFvdXNlXCJdLFxuICAgICAgICBbLyhzZXJhcGh8Y2hlcnViKWltJC9pLCBcIiQxXCJdLFxuICAgICAgICBbLyh4fGNofHNzfHNofHp6fHR0b3xnb3xjaG98YWxpYXN8W15hb3VddXN8dFtsbV1hc3xnYXN8KD86aGVyfGF0fGdyKW98W2FlaW91XXJpcykoPzplcyk/JC9pLCBcIiQxXCJdLFxuICAgICAgICBbLyhhbmFseXxkaWFnbm98cGFyZW50aGV8cHJvZ25vfHN5bm9wfHRoZXxlbXBoYXxjcml8bmUpKD86c2lzfHNlcykkL2ksIFwiJDFzaXNcIl0sXG4gICAgICAgIFsvKG1vdmllfHR3ZWx2ZXxhYnVzZXxlW21uXXUpcyQvaSwgXCIkMVwiXSxcbiAgICAgICAgWy8odGVzdCkoPzppc3xlcykkL2ksIFwiJDFpc1wiXSxcbiAgICAgICAgWy8oYWx1bW58c3lsbGFifHZpcnxyYWRpfG51Y2xlfGZ1bmd8Y2FjdHxzdGltdWx8dGVybWlufGJhY2lsbHxmb2N8dXRlcnxsb2N8c3RyYXQpKD86dXN8aSkkL2ksIFwiJDF1c1wiXSxcbiAgICAgICAgWy8oYWdlbmR8YWRkZW5kfG1pbGxlbm5pfGRhdHxleHRyZW18YmFjdGVyaXxkZXNpZGVyYXR8c3RyYXR8Y2FuZGVsYWJyfGVycmF0fG92fHN5bXBvc2l8Y3VycmljdWx8cXVvcilhJC9pLCBcIiQxdW1cIl0sXG4gICAgICAgIFsvKGFwaGVsaXxoeXBlcmJhdHxwZXJpaGVsaXxhc3luZGV0fG5vdW1lbnxwaGVub21lbnxjcml0ZXJpfG9yZ2FufHByb2xlZ29tZW58aGVkcnxhdXRvbWF0KWEkL2ksIFwiJDFvblwiXSxcbiAgICAgICAgWy8oYWx1bW58YWxnfHZlcnRlYnIpYWUkL2ksIFwiJDFhXCJdLFxuICAgICAgICBbLyhjb2R8bXVyfHNpbHx2ZXJ0fGluZClpY2VzJC9pLCBcIiQxZXhcIl0sXG4gICAgICAgIFsvKG1hdHJ8YXBwZW5kKWljZXMkL2ksIFwiJDFpeFwiXSxcbiAgICAgICAgWy8ocGUpKHJzb258b3BsZSkkL2ksIFwiJDFyc29uXCJdLFxuICAgICAgICBbLyhjaGlsZClyZW4kL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKGVhdSl4PyQvaSwgXCIkMVwiXSxcbiAgICAgICAgWy9tZW4kL2ksIFwibWFuXCJdXG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsaXplMi5hZGRTaW5ndWxhclJ1bGUocnVsZVswXSwgcnVsZVsxXSk7XG4gICAgICB9KTtcbiAgICAgIFtcbiAgICAgICAgXCJhZHVsdGhvb2RcIixcbiAgICAgICAgXCJhZHZpY2VcIixcbiAgICAgICAgXCJhZ2VuZGFcIixcbiAgICAgICAgXCJhaWRcIixcbiAgICAgICAgXCJhaXJjcmFmdFwiLFxuICAgICAgICBcImFsY29ob2xcIixcbiAgICAgICAgXCJhbW1vXCIsXG4gICAgICAgIFwiYW5hbHl0aWNzXCIsXG4gICAgICAgIFwiYW5pbWVcIixcbiAgICAgICAgXCJhdGhsZXRpY3NcIixcbiAgICAgICAgXCJhdWRpb1wiLFxuICAgICAgICBcImJpc29uXCIsXG4gICAgICAgIFwiYmxvb2RcIixcbiAgICAgICAgXCJicmVhbVwiLFxuICAgICAgICBcImJ1ZmZhbG9cIixcbiAgICAgICAgXCJidXR0ZXJcIixcbiAgICAgICAgXCJjYXJwXCIsXG4gICAgICAgIFwiY2FzaFwiLFxuICAgICAgICBcImNoYXNzaXNcIixcbiAgICAgICAgXCJjaGVzc1wiLFxuICAgICAgICBcImNsb3RoaW5nXCIsXG4gICAgICAgIFwiY29kXCIsXG4gICAgICAgIFwiY29tbWVyY2VcIixcbiAgICAgICAgXCJjb29wZXJhdGlvblwiLFxuICAgICAgICBcImNvcnBzXCIsXG4gICAgICAgIFwiZGVicmlzXCIsXG4gICAgICAgIFwiZGlhYmV0ZXNcIixcbiAgICAgICAgXCJkaWdlc3Rpb25cIixcbiAgICAgICAgXCJlbGtcIixcbiAgICAgICAgXCJlbmVyZ3lcIixcbiAgICAgICAgXCJlcXVpcG1lbnRcIixcbiAgICAgICAgXCJleGNyZXRpb25cIixcbiAgICAgICAgXCJleHBlcnRpc2VcIixcbiAgICAgICAgXCJmaXJtd2FyZVwiLFxuICAgICAgICBcImZsb3VuZGVyXCIsXG4gICAgICAgIFwiZnVuXCIsXG4gICAgICAgIFwiZ2FsbG93c1wiLFxuICAgICAgICBcImdhcmJhZ2VcIixcbiAgICAgICAgXCJncmFmZml0aVwiLFxuICAgICAgICBcImhhcmR3YXJlXCIsXG4gICAgICAgIFwiaGVhZHF1YXJ0ZXJzXCIsXG4gICAgICAgIFwiaGVhbHRoXCIsXG4gICAgICAgIFwiaGVycGVzXCIsXG4gICAgICAgIFwiaGlnaGppbmtzXCIsXG4gICAgICAgIFwiaG9tZXdvcmtcIixcbiAgICAgICAgXCJob3VzZXdvcmtcIixcbiAgICAgICAgXCJpbmZvcm1hdGlvblwiLFxuICAgICAgICBcImplYW5zXCIsXG4gICAgICAgIFwianVzdGljZVwiLFxuICAgICAgICBcImt1ZG9zXCIsXG4gICAgICAgIFwibGFib3VyXCIsXG4gICAgICAgIFwibGl0ZXJhdHVyZVwiLFxuICAgICAgICBcIm1hY2hpbmVyeVwiLFxuICAgICAgICBcIm1hY2tlcmVsXCIsXG4gICAgICAgIFwibWFpbFwiLFxuICAgICAgICBcIm1lZGlhXCIsXG4gICAgICAgIFwibWV3c1wiLFxuICAgICAgICBcIm1vb3NlXCIsXG4gICAgICAgIFwibXVzaWNcIixcbiAgICAgICAgXCJtdWRcIixcbiAgICAgICAgXCJtYW5nYVwiLFxuICAgICAgICBcIm5ld3NcIixcbiAgICAgICAgXCJvbmx5XCIsXG4gICAgICAgIFwicGVyc29ubmVsXCIsXG4gICAgICAgIFwicGlrZVwiLFxuICAgICAgICBcInBsYW5rdG9uXCIsXG4gICAgICAgIFwicGxpZXJzXCIsXG4gICAgICAgIFwicG9saWNlXCIsXG4gICAgICAgIFwicG9sbHV0aW9uXCIsXG4gICAgICAgIFwicHJlbWlzZXNcIixcbiAgICAgICAgXCJyYWluXCIsXG4gICAgICAgIFwicmVzZWFyY2hcIixcbiAgICAgICAgXCJyaWNlXCIsXG4gICAgICAgIFwic2FsbW9uXCIsXG4gICAgICAgIFwic2Npc3NvcnNcIixcbiAgICAgICAgXCJzZXJpZXNcIixcbiAgICAgICAgXCJzZXdhZ2VcIixcbiAgICAgICAgXCJzaGFtYmxlc1wiLFxuICAgICAgICBcInNocmltcFwiLFxuICAgICAgICBcInNvZnR3YXJlXCIsXG4gICAgICAgIFwic3BlY2llc1wiLFxuICAgICAgICBcInN0YWZmXCIsXG4gICAgICAgIFwic3dpbmVcIixcbiAgICAgICAgXCJ0ZW5uaXNcIixcbiAgICAgICAgXCJ0cmFmZmljXCIsXG4gICAgICAgIFwidHJhbnNwb3J0YXRpb25cIixcbiAgICAgICAgXCJ0cm91dFwiLFxuICAgICAgICBcInR1bmFcIixcbiAgICAgICAgXCJ3ZWFsdGhcIixcbiAgICAgICAgXCJ3ZWxmYXJlXCIsXG4gICAgICAgIFwid2hpdGluZ1wiLFxuICAgICAgICBcIndpbGRlYmVlc3RcIixcbiAgICAgICAgXCJ3aWxkbGlmZVwiLFxuICAgICAgICBcInlvdVwiLFxuICAgICAgICAvcG9rW2XDqV1tb24kL2ksXG4gICAgICAgIC9bXmFlaW91XWVzZSQvaSxcbiAgICAgICAgL2RlZXIkL2ksXG4gICAgICAgIC9maXNoJC9pLFxuICAgICAgICAvbWVhc2xlcyQvaSxcbiAgICAgICAgL29baXVdcyQvaSxcbiAgICAgICAgL3BveCQvaSxcbiAgICAgICAgL3NoZWVwJC9pXG4gICAgICBdLmZvckVhY2gocGx1cmFsaXplMi5hZGRVbmNvdW50YWJsZVJ1bGUpO1xuICAgICAgcmV0dXJuIHBsdXJhbGl6ZTI7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtcmVnZXhwQDIuMS4wL25vZGVfbW9kdWxlcy9pcy1yZWdleHAvaW5kZXguanNcbnZhciByZXF1aXJlX2lzX3JlZ2V4cCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1yZWdleHBAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLXJlZ2V4cC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAoaW5wdXQpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtb2JqQDIuMC4wL25vZGVfbW9kdWxlcy9pcy1vYmovaW5kZXguanNcbnZhciByZXF1aXJlX2lzX29iaiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYmpAMi4wLjAvbm9kZV9tb2R1bGVzL2lzLW9iai9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKHR5cGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzQDMuMC4yL25vZGVfbW9kdWxlcy9nZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9scy9saWIvaW5kZXguanNcbnZhciByZXF1aXJlX2xpYiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9nZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9sc0AzLjAuMi9ub2RlX21vZHVsZXMvZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHMvbGliL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmRlZmF1bHQgPSAob2JqZWN0KSA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkuZmlsdGVyKChrZXlTeW1ib2wpID0+IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIGtleVN5bWJvbCkpO1xuICB9XG59KTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgcmVxdWlyZV9wYWNrYWdlMiA9IF9fY29tbW9uSlMoe1xuICBcInBhY2thZ2UuanNvblwiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBuYW1lOiBcIkBwcmlzbWEvY2xpZW50XCIsXG4gICAgICB2ZXJzaW9uOiBcIjQuMy4xXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJQcmlzbWEgQ2xpZW50IGlzIGFuIGF1dG8tZ2VuZXJhdGVkLCB0eXBlLXNhZmUgYW5kIG1vZGVybiBKYXZhU2NyaXB0L1R5cGVTY3JpcHQgT1JNIGZvciBOb2RlLmpzIHRoYXQncyB0YWlsb3JlZCB0byB5b3VyIGRhdGEuIFN1cHBvcnRzIE15U1FMLCBQb3N0Z3JlU1FMLCBNYXJpYURCLCBTUUxpdGUgZGF0YWJhc2VzLlwiLFxuICAgICAga2V5d29yZHM6IFtcbiAgICAgICAgXCJvcm1cIixcbiAgICAgICAgXCJwcmlzbWEyXCIsXG4gICAgICAgIFwicHJpc21hXCIsXG4gICAgICAgIFwiY2xpZW50XCIsXG4gICAgICAgIFwicXVlcnlcIixcbiAgICAgICAgXCJkYXRhYmFzZVwiLFxuICAgICAgICBcInNxbFwiLFxuICAgICAgICBcInBvc3RncmVzXCIsXG4gICAgICAgIFwicG9zdGdyZXNxbFwiLFxuICAgICAgICBcIm15c3FsXCIsXG4gICAgICAgIFwic3FsaXRlXCIsXG4gICAgICAgIFwibWFyaWFkYlwiLFxuICAgICAgICBcIm1zc3FsXCIsXG4gICAgICAgIFwidHlwZXNjcmlwdFwiLFxuICAgICAgICBcInF1ZXJ5LWJ1aWxkZXJcIlxuICAgICAgXSxcbiAgICAgIG1haW46IFwiaW5kZXguanNcIixcbiAgICAgIGJyb3dzZXI6IFwiaW5kZXgtYnJvd3Nlci5qc1wiLFxuICAgICAgdHlwZXM6IFwiaW5kZXguZC50c1wiLFxuICAgICAgbGljZW5zZTogXCJBcGFjaGUtMi4wXCIsXG4gICAgICBlbmdpbmVzOiB7XG4gICAgICAgIG5vZGU6IFwiPj0xNC4xN1wiXG4gICAgICB9LFxuICAgICAgaG9tZXBhZ2U6IFwiaHR0cHM6Ly93d3cucHJpc21hLmlvXCIsXG4gICAgICByZXBvc2l0b3J5OiB7XG4gICAgICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgICAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS5naXRcIixcbiAgICAgICAgZGlyZWN0b3J5OiBcInBhY2thZ2VzL2NsaWVudFwiXG4gICAgICB9LFxuICAgICAgYXV0aG9yOiBcIlRpbSBTdWNoYW5layA8c3VjaGFuZWtAcHJpc21hLmlvPlwiLFxuICAgICAgYnVnczogXCJodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNcIixcbiAgICAgIHNjcmlwdHM6IHtcbiAgICAgICAgZGV2OiBcIkRFVj10cnVlIG5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL2J1aWxkLnRzXCIsXG4gICAgICAgIGJ1aWxkOiBcIm5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL2J1aWxkLnRzXCIsXG4gICAgICAgIHRlc3Q6IFwiamVzdCAtLXZlcmJvc2VcIixcbiAgICAgICAgXCJ0ZXN0OmZ1bmN0aW9uYWxcIjogXCJub2RlIC1yIGVzYnVpbGQtcmVnaXN0ZXIgaGVscGVycy9mdW5jdGlvbmFsLXRlc3QvcnVuLXRlc3RzLnRzXCIsXG4gICAgICAgIFwidGVzdDptZW1vcnlcIjogXCJub2RlIC1yIGVzYnVpbGQtcmVnaXN0ZXIgaGVscGVycy9tZW1vcnktdGVzdHMudHNcIixcbiAgICAgICAgXCJ0ZXN0OmZ1bmN0aW9uYWw6Y29kZVwiOiBcIm5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL2Z1bmN0aW9uYWwtdGVzdC9ydW4tdGVzdHMudHMgLS1uby10eXBlc1wiLFxuICAgICAgICBcInRlc3Q6ZnVuY3Rpb25hbDp0eXBlc1wiOiBcIm5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL2Z1bmN0aW9uYWwtdGVzdC9ydW4tdGVzdHMudHMgLS10eXBlcy1vbmx5XCIsXG4gICAgICAgIFwidGVzdC1ub3R5cGVzXCI6IFwiamVzdCAtLXZlcmJvc2UgLS10ZXN0UGF0aElnbm9yZVBhdHRlcm5zIHNyYy9fX3Rlc3RzX18vdHlwZXMvdHlwZXMudGVzdC50c1wiLFxuICAgICAgICBnZW5lcmF0ZTogXCJub2RlIHNjcmlwdHMvcG9zdGluc3RhbGwuanNcIixcbiAgICAgICAgcG9zdGluc3RhbGw6IFwibm9kZSBzY3JpcHRzL3Bvc3RpbnN0YWxsLmpzXCIsXG4gICAgICAgIHByZXB1Ymxpc2hPbmx5OiBcInBucG0gcnVuIGJ1aWxkXCIsXG4gICAgICAgIFwibmV3LXRlc3RcIjogXCJOT0RFX09QVElPTlM9Jy1yIHRzLW5vZGUvcmVnaXN0ZXInIHlvIC4vaGVscGVycy9nZW5lcmF0b3ItdGVzdC9pbmRleC50c1wiXG4gICAgICB9LFxuICAgICAgZmlsZXM6IFtcbiAgICAgICAgXCJSRUFETUUubWRcIixcbiAgICAgICAgXCJydW50aW1lXCIsXG4gICAgICAgIFwic2NyaXB0c1wiLFxuICAgICAgICBcImdlbmVyYXRvci1idWlsZFwiLFxuICAgICAgICBcImVkZ2UuanNcIixcbiAgICAgICAgXCJlZGdlLmQudHNcIixcbiAgICAgICAgXCJpbmRleC5qc1wiLFxuICAgICAgICBcImluZGV4LmQudHNcIixcbiAgICAgICAgXCJpbmRleC1icm93c2VyLmpzXCJcbiAgICAgIF0sXG4gICAgICBkZXZEZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgXCJAZmFrZXItanMvZmFrZXJcIjogXCI3LjQuMFwiLFxuICAgICAgICBcIkBqZXN0L3Rlc3Qtc2VxdWVuY2VyXCI6IFwiMjguMS4zXCIsXG4gICAgICAgIFwiQG1pY3Jvc29mdC9hcGktZXh0cmFjdG9yXCI6IFwiNy4yOS41XCIsXG4gICAgICAgIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI6IFwiMS4xLjBcIixcbiAgICAgICAgXCJAb3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzXCI6IFwiMS41LjBcIixcbiAgICAgICAgXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIjogXCIwLjMxLjBcIixcbiAgICAgICAgXCJAb3BlbnRlbGVtZXRyeS9yZXNvdXJjZXNcIjogXCIxLjUuMFwiLFxuICAgICAgICBcIkBvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlXCI6IFwiMS41LjBcIixcbiAgICAgICAgXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiOiBcIjEuNS4wXCIsXG4gICAgICAgIFwiQHByaXNtYS9kZWJ1Z1wiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvZW5naW5lLWNvcmVcIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgICAgICAgXCJAcHJpc21hL2VuZ2luZXNcIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgICAgICAgXCJAcHJpc21hL2ZldGNoLWVuZ2luZVwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvZ2VuZXJhdG9yLWhlbHBlclwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvZ2V0LXBsYXRmb3JtXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHByaXNtYS9pbnN0cnVtZW50YXRpb25cIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgICAgICAgXCJAcHJpc21hL2ludGVybmFsc1wiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvbWlncmF0ZVwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBzd2Mtbm9kZS9yZWdpc3RlclwiOiBcIjEuNS4xXCIsXG4gICAgICAgIFwiQHN3Yy9jb3JlXCI6IFwiMS4yLjI0MlwiLFxuICAgICAgICBcIkBzd2MvamVzdFwiOiBcIjAuMi4yMlwiLFxuICAgICAgICBcIkB0aW1zdWNoYW5lay9jb3B5XCI6IFwiMS40LjVcIixcbiAgICAgICAgXCJAdHlwZXMvZGVidWdcIjogXCI0LjEuN1wiLFxuICAgICAgICBcIkB0eXBlcy9qZXN0XCI6IFwiMjguMS43XCIsXG4gICAgICAgIFwiQHR5cGVzL2pzLWxldmVuc2h0ZWluXCI6IFwiMS4xLjFcIixcbiAgICAgICAgXCJAdHlwZXMvbXNzcWxcIjogXCI4LjEuMVwiLFxuICAgICAgICBcIkB0eXBlcy9ub2RlXCI6IFwiMTQuMTguMjZcIixcbiAgICAgICAgXCJAdHlwZXMvcGdcIjogXCI4LjYuNVwiLFxuICAgICAgICBcIkB0eXBlcy95ZW9tYW4tZ2VuZXJhdG9yXCI6IFwiNS4yLjExXCIsXG4gICAgICAgIGFyZzogXCI1LjAuMlwiLFxuICAgICAgICBiZW5jaG1hcms6IFwiMi4xLjRcIixcbiAgICAgICAgY2hhbGs6IFwiNC4xLjJcIixcbiAgICAgICAgY3VpZDogXCIyLjEuOFwiLFxuICAgICAgICBcImRlY2ltYWwuanNcIjogXCIxMC40LjBcIixcbiAgICAgICAgZXNidWlsZDogXCIwLjE1LjVcIixcbiAgICAgICAgZXhlY2E6IFwiNS4xLjFcIixcbiAgICAgICAgXCJleHBlY3QtdHlwZVwiOiBcIjAuMTMuMFwiLFxuICAgICAgICBcImZsYXQtbWFwLXBvbHlmaWxsXCI6IFwiMC4zLjhcIixcbiAgICAgICAgXCJmcy1leHRyYVwiOiBcIjEwLjEuMFwiLFxuICAgICAgICBcImZzLW1vbmtleVwiOiBcIjEuMC4zXCIsXG4gICAgICAgIFwiZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHNcIjogXCIzLjAuMlwiLFxuICAgICAgICBnbG9iYnk6IFwiMTEuMS4wXCIsXG4gICAgICAgIFwiaW5kZW50LXN0cmluZ1wiOiBcIjQuMC4wXCIsXG4gICAgICAgIFwiaXMtb2JqXCI6IFwiMi4wLjBcIixcbiAgICAgICAgXCJpcy1yZWdleHBcIjogXCIyLjEuMFwiLFxuICAgICAgICBqZXN0OiBcIjI4LjEuM1wiLFxuICAgICAgICBcImplc3QtanVuaXRcIjogXCIxNC4wLjBcIixcbiAgICAgICAgXCJqZXN0LXNuYXBzaG90XCI6IFwiMjguMS4zXCIsXG4gICAgICAgIFwianMtbGV2ZW5zaHRlaW5cIjogXCIxLjEuNlwiLFxuICAgICAgICBrbG9uYTogXCIyLjAuNVwiLFxuICAgICAgICBcImx6LXN0cmluZ1wiOiBcIjEuNC40XCIsXG4gICAgICAgIFwibWFrZS1kaXJcIjogXCIzLjEuMFwiLFxuICAgICAgICBtYXJpYWRiOiBcIjMuMC4xXCIsXG4gICAgICAgIG1lbWZzOiBcIjMuNC43XCIsXG4gICAgICAgIG1zc3FsOiBcIjkuMC4xXCIsXG4gICAgICAgIHBnOiBcIjguOC4wXCIsXG4gICAgICAgIFwicGtnLXVwXCI6IFwiMy4xLjBcIixcbiAgICAgICAgcGx1cmFsaXplOiBcIjguMC4wXCIsXG4gICAgICAgIFwicmVwbGFjZS1zdHJpbmdcIjogXCIzLjEuMFwiLFxuICAgICAgICByZXNvbHZlOiBcIjEuMjIuMVwiLFxuICAgICAgICByaW1yYWY6IFwiMy4wLjJcIixcbiAgICAgICAgXCJzaW1wbGUtc3RhdGlzdGljc1wiOiBcIjcuNy42XCIsXG4gICAgICAgIFwic29ydC1rZXlzXCI6IFwiNC4yLjBcIixcbiAgICAgICAgXCJzb3VyY2UtbWFwLXN1cHBvcnRcIjogXCIwLjUuMjFcIixcbiAgICAgICAgXCJzcWwtdGVtcGxhdGUtdGFnXCI6IFwiNS4wLjNcIixcbiAgICAgICAgXCJzdGFja3RyYWNlLXBhcnNlclwiOiBcIjAuMS4xMFwiLFxuICAgICAgICBcInN0cmlwLWFuc2lcIjogXCI2LjAuMVwiLFxuICAgICAgICBcInN0cmlwLWluZGVudFwiOiBcIjMuMC4wXCIsXG4gICAgICAgIFwidHMtamVzdFwiOiBcIjI4LjAuOFwiLFxuICAgICAgICBcInRzLW5vZGVcIjogXCIxMC45LjFcIixcbiAgICAgICAgdHNkOiBcIjAuMjEuMFwiLFxuICAgICAgICB0eXBlc2NyaXB0OiBcIjQuOC4yXCIsXG4gICAgICAgIFwieWVvbWFuLWdlbmVyYXRvclwiOiBcIjUuNy4wXCIsXG4gICAgICAgIHlvOiBcIjQuMy4wXCJcbiAgICAgIH0sXG4gICAgICBwZWVyRGVwZW5kZW5jaWVzOiB7XG4gICAgICAgIHByaXNtYTogXCIqXCJcbiAgICAgIH0sXG4gICAgICBwZWVyRGVwZW5kZW5jaWVzTWV0YToge1xuICAgICAgICBwcmlzbWE6IHtcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgIFwiQHByaXNtYS9lbmdpbmVzLXZlcnNpb25cIjogXCI0LjMuMC0zMi5jODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiXCJcbiAgICAgIH0sXG4gICAgICBzaWRlRWZmZWN0czogZmFsc2VcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL3J1bnRpbWUvaW5kZXgudHNcbnZhciBydW50aW1lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJ1bnRpbWVfZXhwb3J0cywge1xuICBETU1GOiAoKSA9PiBETU1GLFxuICBETU1GQ2xhc3M6ICgpID0+IERNTUZIZWxwZXIsXG4gIERlYnVnOiAoKSA9PiBEZWJ1ZyxcbiAgRGVjaW1hbDogKCkgPT4gZGVjaW1hbF9kZWZhdWx0LFxuICBFbmdpbmU6ICgpID0+IEVuZ2luZSxcbiAgTWV0cmljc0NsaWVudDogKCkgPT4gTWV0cmljc0NsaWVudCxcbiAgTm90Rm91bmRFcnJvcjogKCkgPT4gTm90Rm91bmRFcnJvcjIsXG4gIFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IsXG4gIFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLFxuICBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcixcbiAgU3FsOiAoKSA9PiBTcWwsXG4gIGRlY29tcHJlc3NGcm9tQmFzZTY0OiAoKSA9PiBkZWNvbXByZXNzRnJvbUJhc2U2NDIsXG4gIGVtcHR5OiAoKSA9PiBlbXB0eSxcbiAgZmluZFN5bmM6ICgpID0+IGZpbmRTeW5jLFxuICBnZXRQcmlzbWFDbGllbnQ6ICgpID0+IGdldFByaXNtYUNsaWVudCxcbiAgam9pbjogKCkgPT4gam9pbixcbiAgbWFrZURvY3VtZW50OiAoKSA9PiBtYWtlRG9jdW1lbnQsXG4gIG1ha2VTdHJpY3RFbnVtOiAoKSA9PiBtYWtlU3RyaWN0RW51bSxcbiAgb2JqZWN0RW51bVZhbHVlczogKCkgPT4gb2JqZWN0RW51bVZhbHVlcyxcbiAgcmF3OiAoKSA9PiByYXcsXG4gIHNxbHRhZzogKCkgPT4gc3FsLFxuICB0cmFuc2Zvcm1Eb2N1bWVudDogKCkgPT4gdHJhbnNmb3JtRG9jdW1lbnQsXG4gIHVucGFjazogKCkgPT4gdW5wYWNrLFxuICB3YXJuRW52Q29uZmxpY3RzOiAoKSA9PiB3YXJuRW52Q29uZmxpY3RzXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJ1bnRpbWVfZXhwb3J0cyk7XG52YXIgbHpTdHJpbmcgPSBfX3RvRVNNKHJlcXVpcmVfbHpfc3RyaW5nKCkpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21ldHJpY3MvTWV0cmljc0NsaWVudC50c1xudmFyIE1ldHJpY3NDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVuZ2luZSkge1xuICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgfVxuICBwcm9tZXRoZXVzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5naW5lLm1ldHJpY3MoeyBmb3JtYXQ6IFwicHJvbWV0aGV1c1wiLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIGpzb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9lbmdpbmUubWV0cmljcyh7IGZvcm1hdDogXCJqc29uXCIsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn07XG5fX25hbWUoTWV0cmljc0NsaWVudCwgXCJNZXRyaWNzQ2xpZW50XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9hcHBseU1peGlucy50c1xuZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGNvbnN0cnVjdG9ycykge1xuICB2YXIgX2EzO1xuICBmb3IgKGNvbnN0IGJhc2VDdG9yIG9mIGNvbnN0cnVjdG9ycykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGRlcml2ZWRDdG9yLnByb3RvdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgKF9hMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZUN0b3IucHJvdG90eXBlLCBuYW1lKSkgIT0gbnVsbCA/IF9hMyA6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuX19uYW1lKGFwcGx5TWl4aW5zLCBcImFwcGx5TWl4aW5zXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9jb21tb24udHNcbnZhciBpbXBvcnRfY2hhbGsgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVjaW1hbC5qc0AxMC40LjAvbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanNcbnZhciBFWFBfTElNSVQgPSA5ZTE1O1xudmFyIE1BWF9ESUdJVFMgPSAxZTk7XG52YXIgTlVNRVJBTFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbnZhciBMTjEwID0gXCIyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NjI0ODYzMzQwOTUyNTQ2NTA4MjgwNjc1NjY2NjI4NzM2OTA5ODc4MTY4OTQ4MjkwNzIwODMyNTU1NDY4MDg0Mzc5OTg5NDgyNjIzMzE5ODUyODM5MzUwNTMwODk2NTM3NzczMjYyODg0NjE2MzM2NjIyMjI4NzY5ODIxOTg4Njc0NjU0MzY2NzQ3NDQwNDI0MzI3NDM2NTE1NTA0ODkzNDMxNDkzOTM5MTQ3OTYxOTQwNDQwMDIyMjEwNTEwMTcxNDE3NDgwMDM2ODgwODQwMTI2NDcwODA2ODU1Njc3NDMyMTYyMjgzNTUyMjAxMTQ4MDQ2NjM3MTU2NTkxMjEzNzM0NTA3NDc4NTY5NDc2ODM0NjM2MTY3OTIxMDE4MDY0NDUwNzA2NDgwMDAyNzc1MDI2ODQ5MTY3NDY1NTA1ODY4NTY5MzU2NzM0MjA2NzA1ODExMzY0MjkyMjQ1NTQ0MDU3NTg5MjU3MjQyMDgyNDEzMTQ2OTU2ODkwMTY3NTg5NDAyNTY3NzYzMTEzNTY5MTkyOTIwMzMzNzY1ODcxNDE2NjAyMzAxMDU3MDMwODk2MzQ1NzIwNzU0NDAzNzA4NDc0Njk5NDAxNjgyNjkyODI4MDg0ODExODQyODkzMTQ4NDg1MjQ5NDg2NDQ4NzE5Mjc4MDk2NzYyNzEyNzU3NzUzOTcwMjc2Njg2MDU5NTI0OTY3MTY2NzQxODM0ODU3MDQ0MjI1MDcxOTc5NjUwMDQ3MTQ5NTEwNTA0OTIyMTQ3NzY1Njc2MzY5Mzg2NjI5NzY5Nzk1MjIxMTA3MTgyNjQ1NDk3MzQ3NzI2NjI0MjU3MDk0MjkzMjI1ODI3OTg1MDI1ODU1MDk3ODUyNjUzODMyMDc2MDY3MjYzMTcxNjQzMDk1MDU5OTUwODc4MDc1MjM3MTAzMzMxMDExOTc4NTc1NDczMzE1NDE0MjE4MDg0Mjc1NDM4NjM1OTE3NzgxMTcwNTQzMDk4Mjc0ODIzODUwNDU2NDgwMTkwOTU2MTAyOTkyOTE4MjQzMTgyMzc1MjUzNTc3MDk3NTA1Mzk1NjUxODc2OTc1MTAzNzQ5NzA4ODg2OTIxODAyMDUxODkzMzk1MDcyMzg1MzkyMDUxNDQ2MzQxOTcyNjUyODcyODY5NjUxMTA4NjI1NzE0OTIxOTg4NDk5Nzg3NDg4NzM3NzEzNDU2ODYyMDkxNjcwNThcIjtcbnZhciBQSSA9IFwiMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5XCI7XG52YXIgREVGQVVMVFMgPSB7XG4gIHByZWNpc2lvbjogMjAsXG4gIHJvdW5kaW5nOiA0LFxuICBtb2R1bG86IDEsXG4gIHRvRXhwTmVnOiAtNyxcbiAgdG9FeHBQb3M6IDIxLFxuICBtaW5FOiAtRVhQX0xJTUlULFxuICBtYXhFOiBFWFBfTElNSVQsXG4gIGNyeXB0bzogZmFsc2Vcbn07XG52YXIgaW5leGFjdDtcbnZhciBxdWFkcmFudDtcbnZhciBleHRlcm5hbCA9IHRydWU7XG52YXIgZGVjaW1hbEVycm9yID0gXCJbRGVjaW1hbEVycm9yXSBcIjtcbnZhciBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyBcIkludmFsaWQgYXJndW1lbnQ6IFwiO1xudmFyIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyBcIlByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiO1xudmFyIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgXCJjcnlwdG8gdW5hdmFpbGFibGVcIjtcbnZhciB0YWcgPSBcIltvYmplY3QgRGVjaW1hbF1cIjtcbnZhciBtYXRoZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIG1hdGhwb3cgPSBNYXRoLnBvdztcbnZhciBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzSGV4ID0gL14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTtcbnZhciBCQVNFID0gMWU3O1xudmFyIExPR19CQVNFID0gNztcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBMTjEwX1BSRUNJU0lPTiA9IExOMTAubGVuZ3RoIC0gMTtcbnZhciBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxO1xudmFyIFAgPSB7IHRvU3RyaW5nVGFnOiB0YWcgfTtcblAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIGlmICh4LnMgPCAwKVxuICAgIHgucyA9IDE7XG4gIHJldHVybiBmaW5hbGlzZSh4KTtcbn07XG5QLmNlaWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAyKTtcbn07XG5QLmNsYW1wZWRUbyA9IFAuY2xhbXAgPSBmdW5jdGlvbihtaW4yLCBtYXgyKSB7XG4gIHZhciBrLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIG1pbjIgPSBuZXcgQ3RvcihtaW4yKTtcbiAgbWF4MiA9IG5ldyBDdG9yKG1heDIpO1xuICBpZiAoIW1pbjIucyB8fCAhbWF4Mi5zKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAobWluMi5ndChtYXgyKSlcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBtYXgyKTtcbiAgayA9IHguY21wKG1pbjIpO1xuICByZXR1cm4gayA8IDAgPyBtaW4yIDogeC5jbXAobWF4MikgPiAwID8gbWF4MiA6IG5ldyBDdG9yKHgpO1xufTtcblAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24oeSkge1xuICB2YXIgaSwgaiwgeGRMLCB5ZEwsIHggPSB0aGlzLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLCB4cyA9IHgucywgeXMgPSB5LnM7XG4gIGlmICgheGQgfHwgIXlkKSB7XG4gICAgcmV0dXJuICF4cyB8fCAheXMgPyBOYU4gOiB4cyAhPT0geXMgPyB4cyA6IHhkID09PSB5ZCA/IDAgOiAheGQgXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pXG4gICAgcmV0dXJuIHhkWzBdID8geHMgOiB5ZFswXSA/IC15cyA6IDA7XG4gIGlmICh4cyAhPT0geXMpXG4gICAgcmV0dXJuIHhzO1xuICBpZiAoeC5lICE9PSB5LmUpXG4gICAgcmV0dXJuIHguZSA+IHkuZSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgeGRMID0geGQubGVuZ3RoO1xuICB5ZEwgPSB5ZC5sZW5ndGg7XG4gIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcbiAgICBpZiAoeGRbaV0gIT09IHlkW2ldKVxuICAgICAgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcbn07XG5QLmNvc2luZSA9IFAuY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmQpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICgheC5kWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcigxKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0gY29zaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDMgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgcyA9IHgucyAqIG1hdGhwb3coeC5zICogeCwgMSAvIDMpO1xuICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICBlID0geC5lO1xuICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMylcbiAgICAgIG4gKz0gcyA9PSAxIHx8IHMgPT0gLTIgPyBcIjBcIiA6IFwiMDBcIjtcbiAgICBzID0gbWF0aHBvdyhuLCAxIC8gMyk7XG4gICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMykgLSAoZSAlIDMgPT0gKGUgPCAwID8gLTEgOiAyKSk7XG4gICAgaWYgKHMgPT0gMSAvIDApIHtcbiAgICAgIG4gPSBcIjVlXCIgKyBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XG4gICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoXCJlXCIpICsgMSkgKyBlO1xuICAgIH1cbiAgICByID0gbmV3IEN0b3Iobik7XG4gICAgci5zID0geC5zO1xuICB9IGVsc2Uge1xuICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xuICB9XG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gcjtcbiAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XG4gICAgdDNwbHVzeCA9IHQzLnBsdXMoeCk7XG4gICAgciA9IGRpdmlkZSh0M3BsdXN4LnBsdXMoeCkudGltZXModCksIHQzcGx1c3gucGx1cyh0MyksIHNkICsgMiwgMSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xuICAgICAgaWYgKG4gPT0gXCI5OTk5XCIgfHwgIXJlcCAmJiBuID09IFwiNDk5OVwiKSB7XG4gICAgICAgIGlmICghcmVwKSB7XG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKHgpKSB7XG4gICAgICAgICAgICByID0gdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZCArPSA0O1xuICAgICAgICByZXAgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gXCI1XCIpIHtcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XG4gICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLnRpbWVzKHIpLmVxKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcbn07XG5QLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3LCBkID0gdGhpcy5kLCBuID0gTmFOO1xuICBpZiAoZCkge1xuICAgIHcgPSBkLmxlbmd0aCAtIDE7XG4gICAgbiA9ICh3IC0gbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcbiAgICB3ID0gZFt3XTtcbiAgICBpZiAodylcbiAgICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMClcbiAgICAgICAgbi0tO1xuICAgIGlmIChuIDwgMClcbiAgICAgIG4gPSAwO1xuICB9XG4gIHJldHVybiBuO1xufTtcblAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xufTtcblAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbn07XG5QLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcbn07XG5QLmZsb29yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XG59O1xuUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XG59O1xuUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24oeSkge1xuICB2YXIgayA9IHRoaXMuY21wKHkpO1xuICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XG59O1xuUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrLCBuLCBwciwgcm0sIGxlbiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBvbmUgPSBuZXcgQ3RvcigxKTtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG9uZTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzMikge1xuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XG4gICAgbiA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMTY7XG4gICAgbiA9IFwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiO1xuICB9XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyhuKSwgbmV3IEN0b3IoMSksIHRydWUpO1xuICB2YXIgY29zaDJfeCwgaSA9IGssIGQ4ID0gbmV3IEN0b3IoOCk7XG4gIGZvciAoOyBpLS07ICkge1xuICAgIGNvc2gyX3ggPSB4LnRpbWVzKHgpO1xuICAgIHggPSBvbmUubWludXMoY29zaDJfeC50aW1lcyhkOC5taW51cyhjb3NoMl94LnRpbWVzKGQ4KSkpKTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UoeCwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcbn07XG5QLmh5cGVyYm9saWNTaW5lID0gUC5zaW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrLCBwciwgcm0sIGxlbiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzKSB7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gICAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gICAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XG4gICAgdmFyIHNpbmgyX3gsIGQ1ID0gbmV3IEN0b3IoNSksIGQxNiA9IG5ldyBDdG9yKDE2KSwgZDIwID0gbmV3IEN0b3IoMjApO1xuICAgIGZvciAoOyBrLS07ICkge1xuICAgICAgc2luaDJfeCA9IHgudGltZXMoeCk7XG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbmgyX3gudGltZXMoZDE2LnRpbWVzKHNpbmgyX3gpLnBsdXMoZDIwKSkpKTtcbiAgICB9XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLmh5cGVyYm9saWNUYW5nZW50ID0gUC50YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgucyk7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNztcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xufTtcblAuaW52ZXJzZUNvc2luZSA9IFAuYWNvcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFsZlBpLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIGsgPSB4LmFicygpLmNtcCgxKSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoayAhPT0gLTEpIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IHguaXNOZWcoKSA/IGdldFBpKEN0b3IsIHByLCBybSkgOiBuZXcgQ3RvcigwKSA6IG5ldyBDdG9yKE5hTik7XG4gIH1cbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHguYXNpbigpO1xuICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBoYWxmUGkubWludXMoeCk7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5sdGUoMSkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZXEoMSkgPyAwIDogTmFOKTtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgubG4oKTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljU2luZSA9IFAuYXNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LmxuKCk7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHdwciwgeHNkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoeC5lID49IDApXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIHhzZCA9IHguc2QoKTtcbiAgaWYgKE1hdGgubWF4KHhzZCwgcHIpIDwgMiAqIC14LmUgLSAxKVxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XG4gIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmxuKCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgudGltZXMoMC41KTtcbn07XG5QLmludmVyc2VTaW5lID0gUC5hc2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmUGksIGssIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIGsgPSB4LmFicygpLmNtcCgxKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoayAhPT0gLTEpIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgIGhhbGZQaS5zID0geC5zO1xuICAgICAgcmV0dXJuIGhhbGZQaTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5kaXYobmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC50aW1lcygyKTtcbn07XG5QLmludmVyc2VUYW5nZW50ID0gUC5hdGFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCBqLCBrLCBuLCBweCwgdCwgciwgd3ByLCB4MiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XG4gICAgaWYgKCF4LnMpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAocHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gICAgICByLnMgPSB4LnM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcbiAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XG4gICAgci5zID0geC5zO1xuICAgIHJldHVybiByO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XG4gIGZvciAoaSA9IGs7IGk7IC0taSlcbiAgICB4ID0geC5kaXYoeC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XG4gIG4gPSAxO1xuICB4MiA9IHgudGltZXMoeCk7XG4gIHIgPSBuZXcgQ3Rvcih4KTtcbiAgcHggPSB4O1xuICBmb3IgKDsgaSAhPT0gLTE7ICkge1xuICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgIHQgPSByLm1pbnVzKHB4LmRpdihuICs9IDIpKTtcbiAgICBweCA9IHB4LnRpbWVzKHgyKTtcbiAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcbiAgICBpZiAoci5kW2pdICE9PSB2b2lkIDApXG4gICAgICBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07IClcbiAgICAgICAgO1xuICB9XG4gIGlmIChrKVxuICAgIHIgPSByLnRpbWVzKDIgPDwgayAtIDEpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xufTtcblAuaXNGaW5pdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kO1xufTtcblAuaXNJbnRlZ2VyID0gUC5pc0ludCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQgJiYgbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuZC5sZW5ndGggLSAyO1xufTtcblAuaXNOYU4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnM7XG59O1xuUC5pc05lZ2F0aXZlID0gUC5pc05lZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zIDwgMDtcbn07XG5QLmlzUG9zaXRpdmUgPSBQLmlzUG9zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPiAwO1xufTtcblAuaXNaZXJvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZCAmJiB0aGlzLmRbMF0gPT09IDA7XG59O1xuUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XG59O1xuUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24oeSkge1xuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xufTtcblAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbihiYXNlKSB7XG4gIHZhciBpc0Jhc2UxMCwgZCwgZGVub21pbmF0b3IsIGssIGluZiwgbnVtLCBzZCwgciwgYXJnMiA9IHRoaXMsIEN0b3IgPSBhcmcyLmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmcsIGd1YXJkID0gNTtcbiAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XG4gICAgaXNCYXNlMTAgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcbiAgICBkID0gYmFzZS5kO1xuICAgIGlmIChiYXNlLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGJhc2UuZXEoMSkpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xuICB9XG4gIGQgPSBhcmcyLmQ7XG4gIGlmIChhcmcyLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGFyZzIuZXEoMSkpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoZCAmJiAhZFswXSA/IC0xIC8gMCA6IGFyZzIucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XG4gIH1cbiAgaWYgKGlzQmFzZTEwKSB7XG4gICAgaWYgKGQubGVuZ3RoID4gMSkge1xuICAgICAgaW5mID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOyApXG4gICAgICAgIGsgLz0gMTA7XG4gICAgICBpbmYgPSBrICE9PSAxO1xuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzZCA9IHByICsgZ3VhcmQ7XG4gIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnMiwgc2QpO1xuICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xuICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcbiAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrID0gcHIsIHJtKSkge1xuICAgIGRvIHtcbiAgICAgIHNkICs9IDEwO1xuICAgICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcyLCBzZCk7XG4gICAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xuICAgICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XG4gICAgICBpZiAoIWluZikge1xuICAgICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UoayArIDEsIGsgKyAxNSkgKyAxID09IDFlMTQpIHtcbiAgICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayArPSAxMCwgcm0pKTtcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xufTtcblAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGQsIGUsIGksIGosIGssIGxlbiwgcHIsIHJtLCB4ZCwgeGUsIHhMVHksIHlkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xuICAgIGlmICgheC5zIHx8ICF5LnMpXG4gICAgICB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICBlbHNlIGlmICh4LmQpXG4gICAgICB5LnMgPSAteS5zO1xuICAgIGVsc2VcbiAgICAgIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zICE9PSB5LnMgPyB4IDogTmFOKTtcbiAgICByZXR1cm4geTtcbiAgfVxuICBpZiAoeC5zICE9IHkucykge1xuICAgIHkucyA9IC15LnM7XG4gICAgcmV0dXJuIHgucGx1cyh5KTtcbiAgfVxuICB4ZCA9IHguZDtcbiAgeWQgPSB5LmQ7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcbiAgICBpZiAoeWRbMF0pXG4gICAgICB5LnMgPSAteS5zO1xuICAgIGVsc2UgaWYgKHhkWzBdKVxuICAgICAgeSA9IG5ldyBDdG9yKHgpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG4gIH1cbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcbiAgeGQgPSB4ZC5zbGljZSgpO1xuICBrID0geGUgLSBlO1xuICBpZiAoaykge1xuICAgIHhMVHkgPSBrIDwgMDtcbiAgICBpZiAoeExUeSkge1xuICAgICAgZCA9IHhkO1xuICAgICAgayA9IC1rO1xuICAgICAgbGVuID0geWQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0geWQ7XG4gICAgICBlID0geGU7XG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgfVxuICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xuICAgIGlmIChrID4gaSkge1xuICAgICAgayA9IGk7XG4gICAgICBkLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGQucmV2ZXJzZSgpO1xuICAgIGZvciAoaSA9IGs7IGktLTsgKVxuICAgICAgZC5wdXNoKDApO1xuICAgIGQucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIGkgPSB4ZC5sZW5ndGg7XG4gICAgbGVuID0geWQubGVuZ3RoO1xuICAgIHhMVHkgPSBpIDwgbGVuO1xuICAgIGlmICh4TFR5KVxuICAgICAgbGVuID0gaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xuICAgICAgICB4TFR5ID0geGRbaV0gPCB5ZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGsgPSAwO1xuICB9XG4gIGlmICh4TFR5KSB7XG4gICAgZCA9IHhkO1xuICAgIHhkID0geWQ7XG4gICAgeWQgPSBkO1xuICAgIHkucyA9IC15LnM7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpXG4gICAgeGRbbGVuKytdID0gMDtcbiAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazsgKSB7XG4gICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xuICAgICAgZm9yIChqID0gaTsgaiAmJiB4ZFstLWpdID09PSAwOyApXG4gICAgICAgIHhkW2pdID0gQkFTRSAtIDE7XG4gICAgICAtLXhkW2pdO1xuICAgICAgeGRbaV0gKz0gQkFTRTtcbiAgICB9XG4gICAgeGRbaV0gLT0geWRbaV07XG4gIH1cbiAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDsgKVxuICAgIHhkLnBvcCgpO1xuICBmb3IgKDsgeGRbMF0gPT09IDA7IHhkLnNoaWZ0KCkpXG4gICAgLS1lO1xuICBpZiAoIXhkWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gIHkuZCA9IHhkO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xufTtcblAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBxLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSlcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xuICAgIHEgPSBkaXZpZGUoeCwgeS5hYnMoKSwgMCwgMywgMSk7XG4gICAgcS5zICo9IHkucztcbiAgfSBlbHNlIHtcbiAgICBxID0gZGl2aWRlKHgsIHksIDAsIEN0b3IubW9kdWxvLCAxKTtcbiAgfVxuICBxID0gcS50aW1lcyh5KTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4geC5taW51cyhxKTtcbn07XG5QLm5hdHVyYWxFeHBvbmVudGlhbCA9IFAuZXhwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XG59O1xuUC5uYXR1cmFsTG9nYXJpdGhtID0gUC5sbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmF0dXJhbExvZ2FyaXRobSh0aGlzKTtcbn07XG5QLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICB4LnMgPSAteC5zO1xuICByZXR1cm4gZmluYWxpc2UoeCk7XG59O1xuUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBjYXJyeSwgZCwgZSwgaSwgaywgbGVuLCBwciwgcm0sIHhkLCB5ZCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICBpZiAoIXgucyB8fCAheS5zKVxuICAgICAgeSA9IG5ldyBDdG9yKE5hTik7XG4gICAgZWxzZSBpZiAoIXguZClcbiAgICAgIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zID09PSB5LnMgPyB4IDogTmFOKTtcbiAgICByZXR1cm4geTtcbiAgfVxuICBpZiAoeC5zICE9IHkucykge1xuICAgIHkucyA9IC15LnM7XG4gICAgcmV0dXJuIHgubWludXMoeSk7XG4gIH1cbiAgeGQgPSB4LmQ7XG4gIHlkID0geS5kO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgaWYgKCF5ZFswXSlcbiAgICAgIHkgPSBuZXcgQ3Rvcih4KTtcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgfVxuICBrID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhkID0geGQuc2xpY2UoKTtcbiAgaSA9IGsgLSBlO1xuICBpZiAoaSkge1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgZCA9IHhkO1xuICAgICAgaSA9IC1pO1xuICAgICAgbGVuID0geWQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0geWQ7XG4gICAgICBlID0gaztcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcbiAgICB9XG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcbiAgICBsZW4gPSBrID4gbGVuID8gayArIDEgOiBsZW4gKyAxO1xuICAgIGlmIChpID4gbGVuKSB7XG4gICAgICBpID0gbGVuO1xuICAgICAgZC5sZW5ndGggPSAxO1xuICAgIH1cbiAgICBkLnJldmVyc2UoKTtcbiAgICBmb3IgKDsgaS0tOyApXG4gICAgICBkLnB1c2goMCk7XG4gICAgZC5yZXZlcnNlKCk7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBpID0geWQubGVuZ3RoO1xuICBpZiAobGVuIC0gaSA8IDApIHtcbiAgICBpID0gbGVuO1xuICAgIGQgPSB5ZDtcbiAgICB5ZCA9IHhkO1xuICAgIHhkID0gZDtcbiAgfVxuICBmb3IgKGNhcnJ5ID0gMDsgaTsgKSB7XG4gICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcbiAgICB4ZFtpXSAlPSBCQVNFO1xuICB9XG4gIGlmIChjYXJyeSkge1xuICAgIHhkLnVuc2hpZnQoY2FycnkpO1xuICAgICsrZTtcbiAgfVxuICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7IClcbiAgICB4ZC5wb3AoKTtcbiAgeS5kID0geGQ7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG59O1xuUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24oeikge1xuICB2YXIgaywgeCA9IHRoaXM7XG4gIGlmICh6ICE9PSB2b2lkIDAgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMClcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcbiAgaWYgKHguZCkge1xuICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcbiAgICBpZiAoeiAmJiB4LmUgKyAxID4gaylcbiAgICAgIGsgPSB4LmUgKyAxO1xuICB9IGVsc2Uge1xuICAgIGsgPSBOYU47XG4gIH1cbiAgcmV0dXJuIGs7XG59O1xuUC5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHguZSArIDEsIEN0b3Iucm91bmRpbmcpO1xufTtcblAuc2luZSA9IFAuc2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0gc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LCB4ID0gdGhpcywgZCA9IHguZCwgZSA9IHguZSwgcyA9IHgucywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzICE9PSAxIHx8ICFkIHx8ICFkWzBdKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHMgPSBNYXRoLnNxcnQoK3gpO1xuICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoZCk7XG4gICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKVxuICAgICAgbiArPSBcIjBcIjtcbiAgICBzID0gTWF0aC5zcXJ0KG4pO1xuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgfSBlbHNlIHtcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgfVxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IHI7XG4gICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMTA7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5zaW4oKTtcbiAgeC5zID0gMTtcbiAgeCA9IGRpdmlkZSh4LCBuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCksIHByICsgMTAsIDApO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDQgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBjYXJyeSwgZSwgaSwgaywgciwgckwsIHQsIHhkTCwgeWRMLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHhkID0geC5kLCB5ZCA9ICh5ID0gbmV3IEN0b3IoeSkpLmQ7XG4gIHkucyAqPSB4LnM7XG4gIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGQgPyBOYU4gOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xuICB9XG4gIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGRMID0geGQubGVuZ3RoO1xuICB5ZEwgPSB5ZC5sZW5ndGg7XG4gIGlmICh4ZEwgPCB5ZEwpIHtcbiAgICByID0geGQ7XG4gICAgeGQgPSB5ZDtcbiAgICB5ZCA9IHI7XG4gICAgckwgPSB4ZEw7XG4gICAgeGRMID0geWRMO1xuICAgIHlkTCA9IHJMO1xuICB9XG4gIHIgPSBbXTtcbiAgckwgPSB4ZEwgKyB5ZEw7XG4gIGZvciAoaSA9IHJMOyBpLS07IClcbiAgICByLnB1c2goMCk7XG4gIGZvciAoaSA9IHlkTDsgLS1pID49IDA7ICkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGsgPSB4ZEwgKyBpOyBrID4gaTsgKSB7XG4gICAgICB0ID0gcltrXSArIHlkW2ldICogeGRbayAtIGkgLSAxXSArIGNhcnJ5O1xuICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xuICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XG4gICAgfVxuICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xuICB9XG4gIGZvciAoOyAhclstLXJMXTsgKVxuICAgIHIucG9wKCk7XG4gIGlmIChjYXJyeSlcbiAgICArK2U7XG4gIGVsc2VcbiAgICByLnNoaWZ0KCk7XG4gIHkuZCA9IHI7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xufTtcblAudG9CaW5hcnkgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDIsIHNkLCBybSk7XG59O1xuUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoZHAgPT09IHZvaWQgMClcbiAgICByZXR1cm4geDtcbiAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gIGlmIChybSA9PT0gdm9pZCAwKVxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgZWxzZVxuICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XG59O1xuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gIHZhciBzdHIsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgMSwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUsIGRwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9GaXhlZCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgc3RyLCB5LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeSA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh5LCBmYWxzZSwgZHAgKyB5LmUgKyAxKTtcbiAgfVxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24obWF4RCkge1xuICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgciwgeCA9IHRoaXMsIHhkID0geC5kLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4ZClcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIG4xID0gZDAgPSBuZXcgQ3RvcigxKTtcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xuICBkID0gbmV3IEN0b3IoZDEpO1xuICBlID0gZC5lID0gZ2V0UHJlY2lzaW9uKHhkKSAtIHguZSAtIDE7XG4gIGsgPSBlICUgTE9HX0JBU0U7XG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XG4gIGlmIChtYXhEID09IG51bGwpIHtcbiAgICBtYXhEID0gZSA+IDAgPyBkIDogbjE7XG4gIH0gZWxzZSB7XG4gICAgbiA9IG5ldyBDdG9yKG1heEQpO1xuICAgIGlmICghbi5pc0ludCgpIHx8IG4ubHQobjEpKVxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XG4gICAgbWF4RCA9IG4uZ3QoZCkgPyBlID4gMCA/IGQgOiBuMSA6IG47XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgbiA9IG5ldyBDdG9yKGRpZ2l0c1RvU3RyaW5nKHhkKSk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcbiAgZm9yICg7IDsgKSB7XG4gICAgcSA9IGRpdmlkZShuLCBkLCAwLCAxLCAxKTtcbiAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xuICAgIGlmIChkMi5jbXAobWF4RCkgPT0gMSlcbiAgICAgIGJyZWFrO1xuICAgIGQwID0gZDE7XG4gICAgZDEgPSBkMjtcbiAgICBkMiA9IG4xO1xuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XG4gICAgbjAgPSBkMjtcbiAgICBkMiA9IGQ7XG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xuICAgIG4gPSBkMjtcbiAgfVxuICBkMiA9IGRpdmlkZShtYXhELm1pbnVzKGQwKSwgZDEsIDAsIDEsIDEpO1xuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcbiAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XG4gIG4wLnMgPSBuMS5zID0geC5zO1xuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiByO1xufTtcblAudG9IZXhhZGVjaW1hbCA9IFAudG9IZXggPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDE2LCBzZCwgcm0pO1xufTtcblAudG9OZWFyZXN0ID0gZnVuY3Rpb24oeSwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgaWYgKCF4LmQpXG4gICAgICByZXR1cm4geDtcbiAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkge1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB9XG4gICAgaWYgKCF4LmQpXG4gICAgICByZXR1cm4geS5zID8geCA6IHk7XG4gICAgaWYgKCF5LmQpIHtcbiAgICAgIGlmICh5LnMpXG4gICAgICAgIHkucyA9IHgucztcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfVxuICBpZiAoeS5kWzBdKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB4ID0gZGl2aWRlKHgsIHksIDAsIHJtLCAxKS50aW1lcyh5KTtcbiAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgZmluYWxpc2UoeCk7XG4gIH0gZWxzZSB7XG4gICAgeS5zID0geC5zO1xuICAgIHggPSB5O1xuICB9XG4gIHJldHVybiB4O1xufTtcblAudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICt0aGlzO1xufTtcblAudG9PY3RhbCA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgOCwgc2QsIHJtKTtcbn07XG5QLnRvUG93ZXIgPSBQLnBvdyA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGUsIGssIHByLCByLCBybSwgcywgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCB5biA9ICsoeSA9IG5ldyBDdG9yKHkpKTtcbiAgaWYgKCF4LmQgfHwgIXkuZCB8fCAheC5kWzBdIHx8ICF5LmRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKHguZXEoMSkpXG4gICAgcmV0dXJuIHg7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKHkuZXEoMSkpXG4gICAgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSk7XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICBpZiAoZSA+PSB5LmQubGVuZ3RoIC0gMSAmJiAoayA9IHluIDwgMCA/IC15biA6IHluKSA8PSBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgciA9IGludFBvdyhDdG9yLCB4LCBrLCBwcik7XG4gICAgcmV0dXJuIHkucyA8IDAgPyBuZXcgQ3RvcigxKS5kaXYocikgOiBmaW5hbGlzZShyLCBwciwgcm0pO1xuICB9XG4gIHMgPSB4LnM7XG4gIGlmIChzIDwgMCkge1xuICAgIGlmIChlIDwgeS5kLmxlbmd0aCAtIDEpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApXG4gICAgICBzID0gMTtcbiAgICBpZiAoeC5lID09IDAgJiYgeC5kWzBdID09IDEgJiYgeC5kLmxlbmd0aCA9PSAxKSB7XG4gICAgICB4LnMgPSBzO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG4gIGsgPSBtYXRocG93KCt4LCB5bik7XG4gIGUgPSBrID09IDAgfHwgIWlzRmluaXRlKGspID8gbWF0aGZsb29yKHluICogKE1hdGgubG9nKFwiMC5cIiArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpIDogbmV3IEN0b3IoayArIFwiXCIpLmU7XG4gIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSlcbiAgICByZXR1cm4gbmV3IEN0b3IoZSA+IDAgPyBzIC8gMCA6IDApO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBDdG9yLnJvdW5kaW5nID0geC5zID0gMTtcbiAgayA9IE1hdGgubWluKDEyLCAoZSArIFwiXCIpLmxlbmd0aCk7XG4gIHIgPSBuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIHByICsgaykpLCBwcik7XG4gIGlmIChyLmQpIHtcbiAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcbiAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIHByLCBybSkpIHtcbiAgICAgIGUgPSBwciArIDEwO1xuICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcbiAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XG4gICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByLnMgPSBzO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG59O1xuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICB2YXIgc3RyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCBzZCA8PSB4LmUgfHwgeC5lIDw9IEN0b3IudG9FeHBOZWcsIHNkKTtcbiAgfVxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xufTtcblAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50cnVuY2F0ZWQgPSBQLnRydW5jID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XG59O1xuUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xuICB2YXIgaSwgaywgd3MsIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSwgc3RyID0gXCJcIiwgdyA9IGRbMF07XG4gIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XG4gICAgc3RyICs9IHc7XG4gICAgZm9yIChpID0gMTsgaSA8IGluZGV4T2ZMYXN0V29yZDsgaSsrKSB7XG4gICAgICB3cyA9IGRbaV0gKyBcIlwiO1xuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgICAgaWYgKGspXG4gICAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgc3RyICs9IHdzO1xuICAgIH1cbiAgICB3ID0gZFtpXTtcbiAgICB3cyA9IHcgKyBcIlwiO1xuICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcbiAgICBpZiAoaylcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2UgaWYgKHcgPT09IDApIHtcbiAgICByZXR1cm4gXCIwXCI7XG4gIH1cbiAgZm9yICg7IHcgJSAxMCA9PT0gMDsgKVxuICAgIHcgLz0gMTA7XG4gIHJldHVybiBzdHIgKyB3O1xufVxuX19uYW1lKGRpZ2l0c1RvU3RyaW5nLCBcImRpZ2l0c1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4yLCBtYXgyKSB7XG4gIGlmIChpICE9PSB+fmkgfHwgaSA8IG1pbjIgfHwgaSA+IG1heDIpIHtcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBpKTtcbiAgfVxufVxuX19uYW1lKGNoZWNrSW50MzIsIFwiY2hlY2tJbnQzMlwiKTtcbmZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoZCwgaSwgcm0sIHJlcGVhdGluZykge1xuICB2YXIgZGksIGssIHIsIHJkO1xuICBmb3IgKGsgPSBkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgIC0taTtcbiAgaWYgKC0taSA8IDApIHtcbiAgICBpICs9IExPR19CQVNFO1xuICAgIGRpID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgIGkgJT0gTE9HX0JBU0U7XG4gIH1cbiAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gIHJkID0gZFtkaV0gJSBrIHwgMDtcbiAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XG4gICAgaWYgKGkgPCAzKSB7XG4gICAgICBpZiAoaSA9PSAwKVxuICAgICAgICByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgcmQgPSByZCAvIDEwIHwgMDtcbiAgICAgIHIgPSBybSA8IDQgJiYgcmQgPT0gOTk5OTkgfHwgcm0gPiAzICYmIHJkID09IDQ5OTk5IHx8IHJkID09IDVlNCB8fCByZCA9PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKHJtIDwgNCAmJiByZCArIDEgPT0gayB8fCBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAyKSAtIDEgfHwgKHJkID09IGsgLyAyIHx8IHJkID09IDApICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkgPCA0KSB7XG4gICAgICBpZiAoaSA9PSAwKVxuICAgICAgICByZCA9IHJkIC8gMWUzIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgcmQgPSByZCAvIDEwMCB8IDA7XG4gICAgICBlbHNlIGlmIChpID09IDIpXG4gICAgICAgIHJkID0gcmQgLyAxMCB8IDA7XG4gICAgICByID0gKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkID09IDk5OTkgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgPT0gNDk5OTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDFlMyB8IDApID09IG1hdGhwb3coMTAsIGkgLSAzKSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuX19uYW1lKGNoZWNrUm91bmRpbmdEaWdpdHMsIFwiY2hlY2tSb3VuZGluZ0RpZ2l0c1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlKHN0ciwgYmFzZUluLCBiYXNlT3V0KSB7XG4gIHZhciBqLCBhcnIgPSBbMF0sIGFyckwsIGkgPSAwLCBzdHJMID0gc3RyLmxlbmd0aDtcbiAgZm9yICg7IGkgPCBzdHJMOyApIHtcbiAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IClcbiAgICAgIGFyclthcnJMXSAqPSBiYXNlSW47XG4gICAgYXJyWzBdICs9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcbiAgICAgICAgaWYgKGFycltqICsgMV0gPT09IHZvaWQgMClcbiAgICAgICAgICBhcnJbaiArIDFdID0gMDtcbiAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcbiAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnIucmV2ZXJzZSgpO1xufVxuX19uYW1lKGNvbnZlcnRCYXNlLCBcImNvbnZlcnRCYXNlXCIpO1xuZnVuY3Rpb24gY29zaW5lKEN0b3IsIHgpIHtcbiAgdmFyIGssIGxlbiwgeTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIHg7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzMikge1xuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XG4gICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMTY7XG4gICAgeSA9IFwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uICs9IGs7XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xuICBmb3IgKHZhciBpID0gazsgaS0tOyApIHtcbiAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xuICAgIHggPSBjb3MyeC50aW1lcyhjb3MyeCkubWludXMoY29zMngpLnRpbWVzKDgpLnBsdXMoMSk7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gLT0gaztcbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoY29zaW5lLCBcImNvc2luZVwiKTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gbXVsdGlwbHlJbnRlZ2VyKHgsIGssIGJhc2UpIHtcbiAgICB2YXIgdGVtcCwgY2FycnkgPSAwLCBpID0geC5sZW5ndGg7XG4gICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07ICkge1xuICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XG4gICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xuICAgICAgY2FycnkgPSB0ZW1wIC8gYmFzZSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSlcbiAgICAgIHgudW5zaGlmdChjYXJyeSk7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgX19uYW1lKG11bHRpcGx5SW50ZWdlciwgXCJtdWx0aXBseUludGVnZXJcIik7XG4gIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XG4gICAgdmFyIGksIHI7XG4gICAgaWYgKGFMICE9IGJMKSB7XG4gICAgICByID0gYUwgPiBiTCA/IDEgOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gciA9IDA7IGkgPCBhTDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcbiAgICAgICAgICByID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgX19uYW1lKGNvbXBhcmUsIFwiY29tcGFyZVwiKTtcbiAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGFMLS07ICkge1xuICAgICAgYVthTF0gLT0gaTtcbiAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XG4gICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcbiAgICB9XG4gICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgKVxuICAgICAgYS5zaGlmdCgpO1xuICB9XG4gIF9fbmFtZShzdWJ0cmFjdCwgXCJzdWJ0cmFjdFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHksIHByLCBybSwgZHAsIGJhc2UpIHtcbiAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLCB5TCwgeXosIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzaWduMiA9IHgucyA9PSB5LnMgPyAxIDogLTEsIHhkID0geC5kLCB5ZCA9IHkuZDtcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XG4gICAgICByZXR1cm4gbmV3IEN0b3IoXG4gICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGQgPyB5ZCAmJiB4ZFswXSA9PSB5ZFswXSA6ICF5ZCkgPyBOYU4gOiB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24yICogMCA6IHNpZ24yIC8gMFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIGxvZ0Jhc2UgPSAxO1xuICAgICAgZSA9IHguZSAtIHkuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9IEJBU0U7XG4gICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XG4gICAgICBlID0gbWF0aGZsb29yKHguZSAvIGxvZ0Jhc2UpIC0gbWF0aGZsb29yKHkuZSAvIGxvZ0Jhc2UpO1xuICAgIH1cbiAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICB4TCA9IHhkLmxlbmd0aDtcbiAgICBxID0gbmV3IEN0b3Ioc2lnbjIpO1xuICAgIHFkID0gcS5kID0gW107XG4gICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspXG4gICAgICA7XG4gICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKVxuICAgICAgZS0tO1xuICAgIGlmIChwciA9PSBudWxsKSB7XG4gICAgICBzZCA9IHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgfSBlbHNlIGlmIChkcCkge1xuICAgICAgc2QgPSBwciArICh4LmUgLSB5LmUpICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2QgPSBwcjtcbiAgICB9XG4gICAgaWYgKHNkIDwgMCkge1xuICAgICAgcWQucHVzaCgxKTtcbiAgICAgIG1vcmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZCA9IHNkIC8gbG9nQmFzZSArIDIgfCAwO1xuICAgICAgaSA9IDA7XG4gICAgICBpZiAoeUwgPT0gMSkge1xuICAgICAgICBrID0gMDtcbiAgICAgICAgeWQgPSB5ZFswXTtcbiAgICAgICAgc2QrKztcbiAgICAgICAgZm9yICg7IChpIDwgeEwgfHwgaykgJiYgc2QtLTsgaSsrKSB7XG4gICAgICAgICAgdCA9IGsgKiBiYXNlICsgKHhkW2ldIHx8IDApO1xuICAgICAgICAgIHFkW2ldID0gdCAvIHlkIHwgMDtcbiAgICAgICAgICBrID0gdCAlIHlkIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBtb3JlID0gayB8fCBpIDwgeEw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gYmFzZSAvICh5ZFswXSArIDEpIHwgMDtcbiAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgeWQgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xuICAgICAgICAgIHhkID0gbXVsdGlwbHlJbnRlZ2VyKHhkLCBrLCBiYXNlKTtcbiAgICAgICAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICAgICAgICB4TCA9IHhkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB4aSA9IHlMO1xuICAgICAgICByZW0gPSB4ZC5zbGljZSgwLCB5TCk7XG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyApXG4gICAgICAgICAgcmVtW3JlbUwrK10gPSAwO1xuICAgICAgICB5eiA9IHlkLnNsaWNlKCk7XG4gICAgICAgIHl6LnVuc2hpZnQoMCk7XG4gICAgICAgIHlkMCA9IHlkWzBdO1xuICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpXG4gICAgICAgICAgKyt5ZDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKVxuICAgICAgICAgICAgICByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xuICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChrID49IGJhc2UpXG4gICAgICAgICAgICAgICAgayA9IGJhc2UgLSAxO1xuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gMSkge1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5ZCwgcHJvZEwsIGJhc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoayA9PSAwKVxuICAgICAgICAgICAgICAgIGNtcCA9IGsgPSAxO1xuICAgICAgICAgICAgICBwcm9kID0geWQuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKVxuICAgICAgICAgICAgICBwcm9kLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgICAgICByZW0gPSBbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHFkW2krK10gPSBrO1xuICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcbiAgICAgICAgICAgIHJlbUwgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT09IHZvaWQgMCkgJiYgc2QtLSk7XG4gICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICghcWRbMF0pXG4gICAgICAgIHFkLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChsb2dCYXNlID09IDEpIHtcbiAgICAgIHEuZSA9IGU7XG4gICAgICBpbmV4YWN0ID0gbW9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICBpKys7XG4gICAgICBxLmUgPSBpICsgZSAqIGxvZ0Jhc2UgLSAxO1xuICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIGZpbmFsaXNlKHgsIHNkLCBybSwgaXNUcnVuY2F0ZWQpIHtcbiAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBvdXQ6XG4gICAgaWYgKHNkICE9IG51bGwpIHtcbiAgICAgIHhkID0geC5kO1xuICAgICAgaWYgKCF4ZClcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAgICAgZGlnaXRzKys7XG4gICAgICBpID0gc2QgLSBkaWdpdHM7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICAgICAgaiA9IHNkO1xuICAgICAgICB3ID0geGRbeGRpID0gMF07XG4gICAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgICAgICBrID0geGQubGVuZ3RoO1xuICAgICAgICBpZiAoeGRpID49IGspIHtcbiAgICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoOyBrKysgPD0geGRpOyApXG4gICAgICAgICAgICAgIHhkLnB1c2goMCk7XG4gICAgICAgICAgICB3ID0gcmQgPSAwO1xuICAgICAgICAgICAgZGlnaXRzID0gMTtcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ID0gayA9IHhkW3hkaV07XG4gICAgICAgICAgZm9yIChkaWdpdHMgPSAxOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICAgICAgZGlnaXRzKys7XG4gICAgICAgICAgaSAlPSBMT0dfQkFTRTtcbiAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xuICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNUcnVuY2F0ZWQgPSBpc1RydW5jYXRlZCB8fCBzZCA8IDAgfHwgeGRbeGRpICsgMV0gIT09IHZvaWQgMCB8fCAoaiA8IDAgPyB3IDogdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSk7XG4gICAgICByb3VuZFVwID0gcm0gPCA0ID8gKHJkIHx8IGlzVHJ1bmNhdGVkKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSkgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCBpc1RydW5jYXRlZCB8fCBybSA9PSA2ICYmIChpID4gMCA/IGogPiAwID8gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopIDogMCA6IHhkW3hkaSAtIDFdKSAlIDEwICYgMSB8fCBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XG4gICAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xuICAgICAgICB4ZC5sZW5ndGggPSAwO1xuICAgICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICAgIHNkIC09IHguZSArIDE7XG4gICAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcbiAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ZFswXSA9IHguZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaTtcbiAgICAgICAgayA9IDE7XG4gICAgICAgIHhkaS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGQubGVuZ3RoID0geGRpICsgMTtcbiAgICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gICAgICAgIHhkW3hkaV0gPSBqID4gMCA/ICh3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgJSBtYXRocG93KDEwLCBqKSB8IDApICogayA6IDA7XG4gICAgICB9XG4gICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBpZiAoeGRpID09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMClcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaiA9IHhkWzBdICs9IGs7XG4gICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwKVxuICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICBpZiAoaSAhPSBrKSB7XG4gICAgICAgICAgICAgIHguZSsrO1xuICAgICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSlcbiAgICAgICAgICAgICAgICB4ZFswXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGRbeGRpXSArPSBrO1xuICAgICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB4ZFt4ZGktLV0gPSAwO1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7IClcbiAgICAgICAgeGQucG9wKCk7XG4gICAgfVxuICBpZiAoZXh0ZXJuYWwpIHtcbiAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XG4gICAgICB4LmQgPSBudWxsO1xuICAgICAgeC5lID0gTmFOO1xuICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XG4gICAgICB4LmUgPSAwO1xuICAgICAgeC5kID0gWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cbl9fbmFtZShmaW5hbGlzZSwgXCJmaW5hbGlzZVwiKTtcbmZ1bmN0aW9uIGZpbml0ZVRvU3RyaW5nKHgsIGlzRXhwLCBzZCkge1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbm9uRmluaXRlVG9TdHJpbmcoeCk7XG4gIHZhciBrLCBlID0geC5lLCBzdHIgPSBkaWdpdHNUb1N0cmluZyh4LmQpLCBsZW4gPSBzdHIubGVuZ3RoO1xuICBpZiAoaXNFeHApIHtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XG4gICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSkgKyBnZXRaZXJvU3RyaW5nKGspO1xuICAgIH0gZWxzZSBpZiAobGVuID4gMSkge1xuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICBzdHIgPSBzdHIgKyAoeC5lIDwgMCA/IFwiZVwiIDogXCJlK1wiKSArIHguZTtcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgIHN0ciA9IFwiMC5cIiArIGdldFplcm9TdHJpbmcoLWUgLSAxKSArIHN0cjtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKVxuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSBpZiAoZSA+PSBsZW4pIHtcbiAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhlICsgMSAtIGxlbik7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBlIC0gMSkgPiAwKVxuICAgICAgc3RyID0gc3RyICsgXCIuXCIgKyBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2Uge1xuICAgIGlmICgoayA9IGUgKyAxKSA8IGxlbilcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBrKSArIFwiLlwiICsgc3RyLnNsaWNlKGspO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcbiAgICAgIGlmIChlICsgMSA9PT0gbGVuKVxuICAgICAgICBzdHIgKz0gXCIuXCI7XG4gICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbl9fbmFtZShmaW5pdGVUb1N0cmluZywgXCJmaW5pdGVUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGdldEJhc2UxMEV4cG9uZW50KGRpZ2l0cywgZSkge1xuICB2YXIgdyA9IGRpZ2l0c1swXTtcbiAgZm9yIChlICo9IExPR19CQVNFOyB3ID49IDEwOyB3IC89IDEwKVxuICAgIGUrKztcbiAgcmV0dXJuIGU7XG59XG5fX25hbWUoZ2V0QmFzZTEwRXhwb25lbnQsIFwiZ2V0QmFzZTEwRXhwb25lbnRcIik7XG5mdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xuICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xuICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICBpZiAocHIpXG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihMTjEwKSwgc2QsIDEsIHRydWUpO1xufVxuX19uYW1lKGdldExuMTAsIFwiZ2V0TG4xMFwiKTtcbmZ1bmN0aW9uIGdldFBpKEN0b3IsIHNkLCBybSkge1xuICBpZiAoc2QgPiBQSV9QUkVDSVNJT04pXG4gICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihQSSksIHNkLCBybSwgdHJ1ZSk7XG59XG5fX25hbWUoZ2V0UGksIFwiZ2V0UGlcIik7XG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oZGlnaXRzKSB7XG4gIHZhciB3ID0gZGlnaXRzLmxlbmd0aCAtIDEsIGxlbiA9IHcgKiBMT0dfQkFTRSArIDE7XG4gIHcgPSBkaWdpdHNbd107XG4gIGlmICh3KSB7XG4gICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKVxuICAgICAgbGVuLS07XG4gICAgZm9yICh3ID0gZGlnaXRzWzBdOyB3ID49IDEwOyB3IC89IDEwKVxuICAgICAgbGVuKys7XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbl9fbmFtZShnZXRQcmVjaXNpb24sIFwiZ2V0UHJlY2lzaW9uXCIpO1xuZnVuY3Rpb24gZ2V0WmVyb1N0cmluZyhrKSB7XG4gIHZhciB6cyA9IFwiXCI7XG4gIGZvciAoOyBrLS07IClcbiAgICB6cyArPSBcIjBcIjtcbiAgcmV0dXJuIHpzO1xufVxuX19uYW1lKGdldFplcm9TdHJpbmcsIFwiZ2V0WmVyb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGludFBvdyhDdG9yLCB4LCBuLCBwcikge1xuICB2YXIgaXNUcnVuY2F0ZWQsIHIgPSBuZXcgQ3RvcigxKSwgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFICsgNCk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoOyA7ICkge1xuICAgIGlmIChuICUgMikge1xuICAgICAgciA9IHIudGltZXMoeCk7XG4gICAgICBpZiAodHJ1bmNhdGUoci5kLCBrKSlcbiAgICAgICAgaXNUcnVuY2F0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgbiA9IHIuZC5sZW5ndGggLSAxO1xuICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMClcbiAgICAgICAgKytyLmRbbl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeCA9IHgudGltZXMoeCk7XG4gICAgdHJ1bmNhdGUoeC5kLCBrKTtcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiByO1xufVxuX19uYW1lKGludFBvdywgXCJpbnRQb3dcIik7XG5mdW5jdGlvbiBpc09kZChuKSB7XG4gIHJldHVybiBuLmRbbi5kLmxlbmd0aCAtIDFdICYgMTtcbn1cbl9fbmFtZShpc09kZCwgXCJpc09kZFwiKTtcbmZ1bmN0aW9uIG1heE9yTWluKEN0b3IsIGFyZ3MsIGx0Z3QpIHtcbiAgdmFyIHksIHggPSBuZXcgQ3RvcihhcmdzWzBdKSwgaSA9IDA7XG4gIGZvciAoOyArK2kgPCBhcmdzLmxlbmd0aDsgKSB7XG4gICAgeSA9IG5ldyBDdG9yKGFyZ3NbaV0pO1xuICAgIGlmICgheS5zKSB7XG4gICAgICB4ID0geTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoeFtsdGd0XSh5KSkge1xuICAgICAgeCA9IHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKG1heE9yTWluLCBcIm1heE9yTWluXCIpO1xuZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XG4gIHZhciBkZW5vbWluYXRvciwgZ3VhcmQsIGosIHBvdzIsIHN1bTMsIHQsIHdwciwgcmVwID0gMCwgaSA9IDAsIGsgPSAwLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZCA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMCA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcbiAgfVxuICBpZiAoc2QgPT0gbnVsbCkge1xuICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgd3ByID0gcHI7XG4gIH0gZWxzZSB7XG4gICAgd3ByID0gc2Q7XG4gIH1cbiAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xuICB3aGlsZSAoeC5lID4gLTIpIHtcbiAgICB4ID0geC50aW1lcyh0KTtcbiAgICBrICs9IDU7XG4gIH1cbiAgZ3VhcmQgPSBNYXRoLmxvZyhtYXRocG93KDIsIGspKSAvIE1hdGguTE4xMCAqIDIgKyA1IHwgMDtcbiAgd3ByICs9IGd1YXJkO1xuICBkZW5vbWluYXRvciA9IHBvdzIgPSBzdW0zID0gbmV3IEN0b3IoMSk7XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByO1xuICBmb3IgKDsgOyApIHtcbiAgICBwb3cyID0gZmluYWxpc2UocG93Mi50aW1lcyh4KSwgd3ByLCAxKTtcbiAgICBkZW5vbWluYXRvciA9IGRlbm9taW5hdG9yLnRpbWVzKCsraSk7XG4gICAgdCA9IHN1bTMucGx1cyhkaXZpZGUocG93MiwgZGVub21pbmF0b3IsIHdwciwgMSkpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bTMuZCkuc2xpY2UoMCwgd3ByKSkge1xuICAgICAgaiA9IGs7XG4gICAgICB3aGlsZSAoai0tKVxuICAgICAgICBzdW0zID0gZmluYWxpc2Uoc3VtMy50aW1lcyhzdW0zKSwgd3ByLCAxKTtcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXAgPCAzICYmIGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtMy5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSAxMDtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdzIgPSB0ID0gbmV3IEN0b3IoMSk7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVwKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bTMsIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgICByZXR1cm4gc3VtMztcbiAgICAgIH1cbiAgICB9XG4gICAgc3VtMyA9IHQ7XG4gIH1cbn1cbl9fbmFtZShuYXR1cmFsRXhwb25lbnRpYWwsIFwibmF0dXJhbEV4cG9uZW50aWFsXCIpO1xuZnVuY3Rpb24gbmF0dXJhbExvZ2FyaXRobSh5LCBzZCkge1xuICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtMywgdCwgd3ByLCB4MSwgeDIsIG4gPSAxLCBndWFyZCA9IDEwLCB4ID0geSwgeGQgPSB4LmQsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBybSA9IEN0b3Iucm91bmRpbmcsIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHhkICYmICF4ZFswXSA/IC0xIC8gMCA6IHgucyAhPSAxID8gTmFOIDogeGQgPyAwIDogeCk7XG4gIH1cbiAgaWYgKHNkID09IG51bGwpIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHdwciA9IHByO1xuICB9IGVsc2Uge1xuICAgIHdwciA9IHNkO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICBjID0gZGlnaXRzVG9TdHJpbmcoeGQpO1xuICBjMCA9IGMuY2hhckF0KDApO1xuICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxNWUxNCkge1xuICAgIHdoaWxlIChjMCA8IDcgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMykge1xuICAgICAgeCA9IHgudGltZXMoeSk7XG4gICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICAgIGMwID0gYy5jaGFyQXQoMCk7XG4gICAgICBuKys7XG4gICAgfVxuICAgIGUgPSB4LmU7XG4gICAgaWYgKGMwID4gMSkge1xuICAgICAgeCA9IG5ldyBDdG9yKFwiMC5cIiArIGMpO1xuICAgICAgZSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gbmV3IEN0b3IoYzAgKyBcIi5cIiArIGMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0ID0gZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArIFwiXCIpO1xuICAgIHggPSBuYXR1cmFsTG9nYXJpdGhtKG5ldyBDdG9yKGMwICsgXCIuXCIgKyBjLnNsaWNlKDEpKSwgd3ByIC0gZ3VhcmQpLnBsdXModCk7XG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICByZXR1cm4gc2QgPT0gbnVsbCA/IGZpbmFsaXNlKHgsIHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKSA6IHg7XG4gIH1cbiAgeDEgPSB4O1xuICBzdW0zID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4Lm1pbnVzKDEpLCB4LnBsdXMoMSksIHdwciwgMSk7XG4gIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcbiAgZGVub21pbmF0b3IgPSAzO1xuICBmb3IgKDsgOyApIHtcbiAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xuICAgIHQgPSBzdW0zLnBsdXMoZGl2aWRlKG51bWVyYXRvciwgbmV3IEN0b3IoZGVub21pbmF0b3IpLCB3cHIsIDEpKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCB3cHIpID09PSBkaWdpdHNUb1N0cmluZyhzdW0zLmQpLnNsaWNlKDAsIHdwcikpIHtcbiAgICAgIHN1bTMgPSBzdW0zLnRpbWVzKDIpO1xuICAgICAgaWYgKGUgIT09IDApXG4gICAgICAgIHN1bTMgPSBzdW0zLnBsdXMoZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArIFwiXCIpKTtcbiAgICAgIHN1bTMgPSBkaXZpZGUoc3VtMywgbmV3IEN0b3IobiksIHdwciwgMSk7XG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0zLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICAgICAgICAgIHQgPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgxLm1pbnVzKDEpLCB4MS5wbHVzKDEpLCB3cHIsIDEpO1xuICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bTMsIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgICByZXR1cm4gc3VtMztcbiAgICAgIH1cbiAgICB9XG4gICAgc3VtMyA9IHQ7XG4gICAgZGVub21pbmF0b3IgKz0gMjtcbiAgfVxufVxuX19uYW1lKG5hdHVyYWxMb2dhcml0aG0sIFwibmF0dXJhbExvZ2FyaXRobVwiKTtcbmZ1bmN0aW9uIG5vbkZpbml0ZVRvU3RyaW5nKHgpIHtcbiAgcmV0dXJuIFN0cmluZyh4LnMgKiB4LnMgLyAwKTtcbn1cbl9fbmFtZShub25GaW5pdGVUb1N0cmluZywgXCJub25GaW5pdGVUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIHBhcnNlRGVjaW1hbCh4LCBzdHIpIHtcbiAgdmFyIGUsIGksIGxlbjtcbiAgaWYgKChlID0gc3RyLmluZGV4T2YoXCIuXCIpKSA+IC0xKVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgZSA9IGk7XG4gICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xuICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgZSA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspXG4gICAgO1xuICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpID09PSA0ODsgLS1sZW4pXG4gICAgO1xuICBzdHIgPSBzdHIuc2xpY2UoaSwgbGVuKTtcbiAgaWYgKHN0cikge1xuICAgIGxlbiAtPSBpO1xuICAgIHguZSA9IGUgPSBlIC0gaSAtIDE7XG4gICAgeC5kID0gW107XG4gICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcbiAgICBpZiAoZSA8IDApXG4gICAgICBpICs9IExPR19CQVNFO1xuICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICBpZiAoaSlcbiAgICAgICAgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XG4gICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKVxuICAgICAgICB4LmQucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcbiAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgLT0gbGVuO1xuICAgIH1cbiAgICBmb3IgKDsgaS0tOyApXG4gICAgICBzdHIgKz0gXCIwXCI7XG4gICAgeC5kLnB1c2goK3N0cik7XG4gICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICBpZiAoeC5lID4geC5jb25zdHJ1Y3Rvci5tYXhFKSB7XG4gICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIHguZSA9IE5hTjtcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgeC5jb25zdHJ1Y3Rvci5taW5FKSB7XG4gICAgICAgIHguZSA9IDA7XG4gICAgICAgIHguZCA9IFswXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgeC5lID0gMDtcbiAgICB4LmQgPSBbMF07XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5fX25hbWUocGFyc2VEZWNpbWFsLCBcInBhcnNlRGVjaW1hbFwiKTtcbmZ1bmN0aW9uIHBhcnNlT3RoZXIoeCwgc3RyKSB7XG4gIHZhciBiYXNlLCBDdG9yLCBkaXZpc29yLCBpLCBpc0Zsb2F0LCBsZW4sIHAsIHhkLCB4ZTtcbiAgaWYgKHN0ci5pbmRleE9mKFwiX1wiKSA+IC0xKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgXCIkMVwiKTtcbiAgICBpZiAoaXNEZWNpbWFsLnRlc3Qoc3RyKSlcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgc3RyKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiTmFOXCIpIHtcbiAgICBpZiAoIStzdHIpXG4gICAgICB4LnMgPSBOYU47XG4gICAgeC5lID0gTmFOO1xuICAgIHguZCA9IG51bGw7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgaWYgKGlzSGV4LnRlc3Qoc3RyKSkge1xuICAgIGJhc2UgPSAxNjtcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChpc0JpbmFyeS50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gMjtcbiAgfSBlbHNlIGlmIChpc09jdGFsLnRlc3Qoc3RyKSkge1xuICAgIGJhc2UgPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHN0cik7XG4gIH1cbiAgaSA9IHN0ci5zZWFyY2goL3AvaSk7XG4gIGlmIChpID4gMCkge1xuICAgIHAgPSArc3RyLnNsaWNlKGkgKyAxKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDIsIGkpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgfVxuICBpID0gc3RyLmluZGV4T2YoXCIuXCIpO1xuICBpc0Zsb2F0ID0gaSA+PSAwO1xuICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzRmxvYXQpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBpID0gbGVuIC0gaTtcbiAgICBkaXZpc29yID0gaW50UG93KEN0b3IsIG5ldyBDdG9yKGJhc2UpLCBpLCBpICogMik7XG4gIH1cbiAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIEJBU0UpO1xuICB4ZSA9IHhkLmxlbmd0aCAtIDE7XG4gIGZvciAoaSA9IHhlOyB4ZFtpXSA9PT0gMDsgLS1pKVxuICAgIHhkLnBvcCgpO1xuICBpZiAoaSA8IDApXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xuICB4LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgeGUpO1xuICB4LmQgPSB4ZDtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKGlzRmxvYXQpXG4gICAgeCA9IGRpdmlkZSh4LCBkaXZpc29yLCBsZW4gKiA0KTtcbiAgaWYgKHApXG4gICAgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHg7XG59XG5fX25hbWUocGFyc2VPdGhlciwgXCJwYXJzZU90aGVyXCIpO1xuZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XG4gIHZhciBrLCBsZW4gPSB4LmQubGVuZ3RoO1xuICBpZiAobGVuIDwgMykge1xuICAgIHJldHVybiB4LmlzWmVybygpID8geCA6IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcbiAgfVxuICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xuICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XG4gIHZhciBzaW4yX3gsIGQ1ID0gbmV3IEN0b3IoNSksIGQxNiA9IG5ldyBDdG9yKDE2KSwgZDIwID0gbmV3IEN0b3IoMjApO1xuICBmb3IgKDsgay0tOyApIHtcbiAgICBzaW4yX3ggPSB4LnRpbWVzKHgpO1xuICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luMl94LnRpbWVzKGQxNi50aW1lcyhzaW4yX3gpLm1pbnVzKGQyMCkpKSk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoc2luZSwgXCJzaW5lXCIpO1xuZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xuICB2YXIgaiwgdCwgdSwgeDIsIGkgPSAxLCBwciA9IEN0b3IucHJlY2lzaW9uLCBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICB4MiA9IHgudGltZXMoeCk7XG4gIHUgPSBuZXcgQ3Rvcih5KTtcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xuICAgIHUgPSBpc0h5cGVyYm9saWMgPyB5LnBsdXModCkgOiB5Lm1pbnVzKHQpO1xuICAgIHkgPSBkaXZpZGUodC50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcbiAgICB0ID0gdS5wbHVzKHkpO1xuICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xuICAgICAgZm9yIChqID0gazsgdC5kW2pdID09PSB1LmRbal0gJiYgai0tOyApXG4gICAgICAgIDtcbiAgICAgIGlmIChqID09IC0xKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaiA9IHU7XG4gICAgdSA9IHk7XG4gICAgeSA9IHQ7XG4gICAgdCA9IGo7XG4gICAgaSsrO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgdC5kLmxlbmd0aCA9IGsgKyAxO1xuICByZXR1cm4gdDtcbn1cbl9fbmFtZSh0YXlsb3JTZXJpZXMsIFwidGF5bG9yU2VyaWVzXCIpO1xuZnVuY3Rpb24gdGlueVBvdyhiLCBlKSB7XG4gIHZhciBuID0gYjtcbiAgd2hpbGUgKC0tZSlcbiAgICBuICo9IGI7XG4gIHJldHVybiBuO1xufVxuX19uYW1lKHRpbnlQb3csIFwidGlueVBvd1wiKTtcbmZ1bmN0aW9uIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkge1xuICB2YXIgdCwgaXNOZWcgPSB4LnMgPCAwLCBwaSA9IGdldFBpKEN0b3IsIEN0b3IucHJlY2lzaW9uLCAxKSwgaGFsZlBpID0gcGkudGltZXMoMC41KTtcbiAgeCA9IHguYWJzKCk7XG4gIGlmICh4Lmx0ZShoYWxmUGkpKSB7XG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDQgOiAxO1xuICAgIHJldHVybiB4O1xuICB9XG4gIHQgPSB4LmRpdlRvSW50KHBpKTtcbiAgaWYgKHQuaXNaZXJvKCkpIHtcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gMyA6IDI7XG4gIH0gZWxzZSB7XG4gICAgeCA9IHgubWludXModC50aW1lcyhwaSkpO1xuICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XG4gICAgICBxdWFkcmFudCA9IGlzT2RkKHQpID8gaXNOZWcgPyAyIDogMyA6IGlzTmVnID8gNCA6IDE7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IGlzTmVnID8gMSA6IDQgOiBpc05lZyA/IDMgOiAyO1xuICB9XG4gIHJldHVybiB4Lm1pbnVzKHBpKS5hYnMoKTtcbn1cbl9fbmFtZSh0b0xlc3NUaGFuSGFsZlBpLCBcInRvTGVzc1RoYW5IYWxmUGlcIik7XG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcbiAgdmFyIGJhc2UsIGUsIGksIGssIGxlbiwgcm91bmRVcCwgc3RyLCB4ZCwgeSwgQ3RvciA9IHguY29uc3RydWN0b3IsIGlzRXhwID0gc2QgIT09IHZvaWQgMDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIH0gZWxzZSB7XG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH1cbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcbiAgICBpID0gc3RyLmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpc0V4cCkge1xuICAgICAgYmFzZSA9IDI7XG4gICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xuICAgICAgICBzZCA9IHNkICogNCAtIDM7XG4gICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xuICAgICAgICBzZCA9IHNkICogMyAtIDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBiYXNlT3V0O1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgICB5LmUgPSBzdHIubGVuZ3RoIC0gaTtcbiAgICAgIHkuZCA9IGNvbnZlcnRCYXNlKGZpbml0ZVRvU3RyaW5nKHkpLCAxMCwgYmFzZSk7XG4gICAgICB5LmUgPSB5LmQubGVuZ3RoO1xuICAgIH1cbiAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xuICAgIGUgPSBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgZm9yICg7IHhkWy0tbGVuXSA9PSAwOyApXG4gICAgICB4ZC5wb3AoKTtcbiAgICBpZiAoIXhkWzBdKSB7XG4gICAgICBzdHIgPSBpc0V4cCA/IFwiMHArMFwiIDogXCIwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBlLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbmV3IEN0b3IoeCk7XG4gICAgICAgIHguZCA9IHhkO1xuICAgICAgICB4LmUgPSBlO1xuICAgICAgICB4ID0gZGl2aWRlKHgsIHksIHNkLCBybSwgMCwgYmFzZSk7XG4gICAgICAgIHhkID0geC5kO1xuICAgICAgICBlID0geC5lO1xuICAgICAgICByb3VuZFVwID0gaW5leGFjdDtcbiAgICAgIH1cbiAgICAgIGkgPSB4ZFtzZF07XG4gICAgICBrID0gYmFzZSAvIDI7XG4gICAgICByb3VuZFVwID0gcm91bmRVcCB8fCB4ZFtzZCArIDFdICE9PSB2b2lkIDA7XG4gICAgICByb3VuZFVwID0gcm0gPCA0ID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKSA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHwgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xuICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgZm9yICg7ICsreGRbLS1zZF0gPiBiYXNlIC0gMTsgKSB7XG4gICAgICAgICAgeGRbc2RdID0gMDtcbiAgICAgICAgICBpZiAoIXNkKSB7XG4gICAgICAgICAgICArK2U7XG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pXG4gICAgICAgIDtcbiAgICAgIGZvciAoaSA9IDAsIHN0ciA9IFwiXCI7IGkgPCBsZW47IGkrKylcbiAgICAgICAgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICBpZiAoaXNFeHApIHtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNiB8fCBiYXNlT3V0ID09IDgpIHtcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XG4gICAgICAgICAgICBmb3IgKC0tbGVuOyBsZW4gJSBpOyBsZW4rKylcbiAgICAgICAgICAgICAgc3RyICs9IFwiMFwiO1xuICAgICAgICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIGJhc2VPdXQpO1xuICAgICAgICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIHN0ciA9IFwiMS5cIjsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIgKyAoZSA8IDAgPyBcInBcIiA6IFwicCtcIikgKyBlO1xuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgICAgICBmb3IgKDsgKytlOyApXG4gICAgICAgICAgc3RyID0gXCIwXCIgKyBzdHI7XG4gICAgICAgIHN0ciA9IFwiMC5cIiArIHN0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgrK2UgPiBsZW4pXG4gICAgICAgICAgZm9yIChlIC09IGxlbjsgZS0tOyApXG4gICAgICAgICAgICBzdHIgKz0gXCIwXCI7XG4gICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pXG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgXCIuXCIgKyBzdHIuc2xpY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gXCIweFwiIDogYmFzZU91dCA9PSAyID8gXCIwYlwiIDogYmFzZU91dCA9PSA4ID8gXCIwb1wiIDogXCJcIikgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHgucyA8IDAgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn1cbl9fbmFtZSh0b1N0cmluZ0JpbmFyeSwgXCJ0b1N0cmluZ0JpbmFyeVwiKTtcbmZ1bmN0aW9uIHRydW5jYXRlKGFyciwgbGVuKSB7XG4gIGlmIChhcnIubGVuZ3RoID4gbGVuKSB7XG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuX19uYW1lKHRydW5jYXRlLCBcInRydW5jYXRlXCIpO1xuZnVuY3Rpb24gYWJzKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFicygpO1xufVxuX19uYW1lKGFicywgXCJhYnNcIik7XG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3MoKTtcbn1cbl9fbmFtZShhY29zLCBcImFjb3NcIik7XG5mdW5jdGlvbiBhY29zaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zaCgpO1xufVxuX19uYW1lKGFjb3NoLCBcImFjb3NoXCIpO1xuZnVuY3Rpb24gYWRkKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBsdXMoeSk7XG59XG5fX25hbWUoYWRkLCBcImFkZFwiKTtcbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbigpO1xufVxuX19uYW1lKGFzaW4sIFwiYXNpblwiKTtcbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW5oKCk7XG59XG5fX25hbWUoYXNpbmgsIFwiYXNpbmhcIik7XG5mdW5jdGlvbiBhdGFuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW4oKTtcbn1cbl9fbmFtZShhdGFuLCBcImF0YW5cIik7XG5mdW5jdGlvbiBhdGFuaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hdGFuaCgpO1xufVxuX19uYW1lKGF0YW5oLCBcImF0YW5oXCIpO1xuZnVuY3Rpb24gYXRhbjIoeSwgeCkge1xuICB5ID0gbmV3IHRoaXMoeSk7XG4gIHggPSBuZXcgdGhpcyh4KTtcbiAgdmFyIHIsIHByID0gdGhpcy5wcmVjaXNpb24sIHJtID0gdGhpcy5yb3VuZGluZywgd3ByID0gcHIgKyA0O1xuICBpZiAoIXkucyB8fCAheC5zKSB7XG4gICAgciA9IG5ldyB0aGlzKE5hTik7XG4gIH0gZWxzZSBpZiAoIXkuZCAmJiAheC5kKSB7XG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoeC5zID4gMCA/IDAuMjUgOiAwLjc1KTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoIXguZCB8fCB5LmlzWmVybygpKSB7XG4gICAgciA9IHgucyA8IDAgPyBnZXRQaSh0aGlzLCBwciwgcm0pIDogbmV3IHRoaXMoMCk7XG4gICAgci5zID0geS5zO1xuICB9IGVsc2UgaWYgKCF5LmQgfHwgeC5pc1plcm8oKSkge1xuICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKDAuNSk7XG4gICAgci5zID0geS5zO1xuICB9IGVsc2UgaWYgKHgucyA8IDApIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHdwcjtcbiAgICB0aGlzLnJvdW5kaW5nID0gMTtcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcbiAgICB4ID0gZ2V0UGkodGhpcywgd3ByLCAxKTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByO1xuICAgIHRoaXMucm91bmRpbmcgPSBybTtcbiAgICByID0geS5zIDwgMCA/IHIubWludXMoeCkgOiByLnBsdXMoeCk7XG4gIH0gZWxzZSB7XG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5fX25hbWUoYXRhbjIsIFwiYXRhbjJcIik7XG5mdW5jdGlvbiBjYnJ0KHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcbn1cbl9fbmFtZShjYnJ0LCBcImNicnRcIik7XG5mdW5jdGlvbiBjZWlsKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMik7XG59XG5fX25hbWUoY2VpbCwgXCJjZWlsXCIpO1xuZnVuY3Rpb24gY2xhbXAoeCwgbWluMiwgbWF4Mikge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY2xhbXAobWluMiwgbWF4Mik7XG59XG5fX25hbWUoY2xhbXAsIFwiY2xhbXBcIik7XG5mdW5jdGlvbiBjb25maWcob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpXG4gICAgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gIHZhciBpLCBwLCB2LCB1c2VEZWZhdWx0cyA9IG9iai5kZWZhdWx0cyA9PT0gdHJ1ZSwgcHMgPSBbXG4gICAgXCJwcmVjaXNpb25cIixcbiAgICAxLFxuICAgIE1BWF9ESUdJVFMsXG4gICAgXCJyb3VuZGluZ1wiLFxuICAgIDAsXG4gICAgOCxcbiAgICBcInRvRXhwTmVnXCIsXG4gICAgLUVYUF9MSU1JVCxcbiAgICAwLFxuICAgIFwidG9FeHBQb3NcIixcbiAgICAwLFxuICAgIEVYUF9MSU1JVCxcbiAgICBcIm1heEVcIixcbiAgICAwLFxuICAgIEVYUF9MSU1JVCxcbiAgICBcIm1pbkVcIixcbiAgICAtRVhQX0xJTUlULFxuICAgIDAsXG4gICAgXCJtb2R1bG9cIixcbiAgICAwLFxuICAgIDlcbiAgXTtcbiAgZm9yIChpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgaWYgKHAgPSBwc1tpXSwgdXNlRGVmYXVsdHMpXG4gICAgICB0aGlzW3BdID0gREVGQVVMVFNbcF07XG4gICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKVxuICAgICAgICB0aGlzW3BdID0gdjtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArIFwiOiBcIiArIHYpO1xuICAgIH1cbiAgfVxuICBpZiAocCA9IFwiY3J5cHRvXCIsIHVzZURlZmF1bHRzKVxuICAgIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHYgPT09IHRydWUgfHwgdiA9PT0gZmFsc2UgfHwgdiA9PT0gMCB8fCB2ID09PSAxKSB7XG4gICAgICBpZiAodikge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSBcInVuZGVmaW5lZFwiICYmIGNyeXB0byAmJiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAgICAgdGhpc1twXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3BdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyBcIjogXCIgKyB2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5fX25hbWUoY29uZmlnLCBcImNvbmZpZ1wiKTtcbmZ1bmN0aW9uIGNvcyh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jb3MoKTtcbn1cbl9fbmFtZShjb3MsIFwiY29zXCIpO1xuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jb3NoKCk7XG59XG5fX25hbWUoY29zaCwgXCJjb3NoXCIpO1xuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHZhciBpLCBwLCBwcztcbiAgZnVuY3Rpb24gRGVjaW1hbDIodikge1xuICAgIHZhciBlLCBpMiwgdCwgeCA9IHRoaXM7XG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIERlY2ltYWwyKSlcbiAgICAgIHJldHVybiBuZXcgRGVjaW1hbDIodik7XG4gICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWwyO1xuICAgIGlmIChpc0RlY2ltYWxJbnN0YW5jZSh2KSkge1xuICAgICAgeC5zID0gdi5zO1xuICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgIGlmICghdi5kIHx8IHYuZSA+IERlY2ltYWwyLm1heEUpIHtcbiAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBEZWNpbWFsMi5taW5FKSB7XG4gICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICAgIHguZCA9IHYuZC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LmUgPSB2LmU7XG4gICAgICAgIHguZCA9IHYuZCA/IHYuZC5zbGljZSgpIDogdi5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ID0gdHlwZW9mIHY7XG4gICAgaWYgKHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IC0xIDogMTtcbiAgICAgICAgeC5lID0gMDtcbiAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IC12O1xuICAgICAgICB4LnMgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgucyA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodiA9PT0gfn52ICYmIHYgPCAxZTcpIHtcbiAgICAgICAgZm9yIChlID0gMCwgaTIgPSB2OyBpMiA+PSAxMDsgaTIgLz0gMTApXG4gICAgICAgICAgZSsrO1xuICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgICAgICBpZiAoZSA+IERlY2ltYWwyLm1heEUpIHtcbiAgICAgICAgICAgIHguZSA9IE5hTjtcbiAgICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChlIDwgRGVjaW1hbDIubWluRSkge1xuICAgICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeC5lID0gZTtcbiAgICAgICAgICAgIHguZCA9IFt2XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeC5lID0gZTtcbiAgICAgICAgICB4LmQgPSBbdl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh2ICogMCAhPT0gMCkge1xuICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgeC5zID0gTmFOO1xuICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHYpO1xuICAgIH1cbiAgICBpZiAoKGkyID0gdi5jaGFyQ29kZUF0KDApKSA9PT0gNDUpIHtcbiAgICAgIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgeC5zID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpMiA9PT0gNDMpXG4gICAgICAgIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgeC5zID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcbiAgfVxuICBfX25hbWUoRGVjaW1hbDIsIFwiRGVjaW1hbFwiKTtcbiAgRGVjaW1hbDIucHJvdG90eXBlID0gUDtcbiAgRGVjaW1hbDIuUk9VTkRfVVAgPSAwO1xuICBEZWNpbWFsMi5ST1VORF9ET1dOID0gMTtcbiAgRGVjaW1hbDIuUk9VTkRfQ0VJTCA9IDI7XG4gIERlY2ltYWwyLlJPVU5EX0ZMT09SID0gMztcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9VUCA9IDQ7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xuICBEZWNpbWFsMi5FVUNMSUQgPSA5O1xuICBEZWNpbWFsMi5jb25maWcgPSBEZWNpbWFsMi5zZXQgPSBjb25maWc7XG4gIERlY2ltYWwyLmNsb25lID0gY2xvbmU7XG4gIERlY2ltYWwyLmlzRGVjaW1hbCA9IGlzRGVjaW1hbEluc3RhbmNlO1xuICBEZWNpbWFsMi5hYnMgPSBhYnM7XG4gIERlY2ltYWwyLmFjb3MgPSBhY29zO1xuICBEZWNpbWFsMi5hY29zaCA9IGFjb3NoO1xuICBEZWNpbWFsMi5hZGQgPSBhZGQ7XG4gIERlY2ltYWwyLmFzaW4gPSBhc2luO1xuICBEZWNpbWFsMi5hc2luaCA9IGFzaW5oO1xuICBEZWNpbWFsMi5hdGFuID0gYXRhbjtcbiAgRGVjaW1hbDIuYXRhbmggPSBhdGFuaDtcbiAgRGVjaW1hbDIuYXRhbjIgPSBhdGFuMjtcbiAgRGVjaW1hbDIuY2JydCA9IGNicnQ7XG4gIERlY2ltYWwyLmNlaWwgPSBjZWlsO1xuICBEZWNpbWFsMi5jbGFtcCA9IGNsYW1wO1xuICBEZWNpbWFsMi5jb3MgPSBjb3M7XG4gIERlY2ltYWwyLmNvc2ggPSBjb3NoO1xuICBEZWNpbWFsMi5kaXYgPSBkaXY7XG4gIERlY2ltYWwyLmV4cCA9IGV4cDtcbiAgRGVjaW1hbDIuZmxvb3IgPSBmbG9vcjtcbiAgRGVjaW1hbDIuaHlwb3QgPSBoeXBvdDtcbiAgRGVjaW1hbDIubG4gPSBsbjtcbiAgRGVjaW1hbDIubG9nID0gbG9nO1xuICBEZWNpbWFsMi5sb2cxMCA9IGxvZzEwO1xuICBEZWNpbWFsMi5sb2cyID0gbG9nMjtcbiAgRGVjaW1hbDIubWF4ID0gbWF4O1xuICBEZWNpbWFsMi5taW4gPSBtaW47XG4gIERlY2ltYWwyLm1vZCA9IG1vZDtcbiAgRGVjaW1hbDIubXVsID0gbXVsO1xuICBEZWNpbWFsMi5wb3cgPSBwb3c7XG4gIERlY2ltYWwyLnJhbmRvbSA9IHJhbmRvbTtcbiAgRGVjaW1hbDIucm91bmQgPSByb3VuZDtcbiAgRGVjaW1hbDIuc2lnbiA9IHNpZ247XG4gIERlY2ltYWwyLnNpbiA9IHNpbjtcbiAgRGVjaW1hbDIuc2luaCA9IHNpbmg7XG4gIERlY2ltYWwyLnNxcnQgPSBzcXJ0O1xuICBEZWNpbWFsMi5zdWIgPSBzdWI7XG4gIERlY2ltYWwyLnN1bSA9IHN1bTtcbiAgRGVjaW1hbDIudGFuID0gdGFuO1xuICBEZWNpbWFsMi50YW5oID0gdGFuaDtcbiAgRGVjaW1hbDIudHJ1bmMgPSB0cnVuYztcbiAgaWYgKG9iaiA9PT0gdm9pZCAwKVxuICAgIG9iaiA9IHt9O1xuICBpZiAob2JqKSB7XG4gICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xuICAgICAgcHMgPSBbXCJwcmVjaXNpb25cIiwgXCJyb3VuZGluZ1wiLCBcInRvRXhwTmVnXCIsIFwidG9FeHBQb3NcIiwgXCJtYXhFXCIsIFwibWluRVwiLCBcIm1vZHVsb1wiLCBcImNyeXB0b1wiXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IClcbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKVxuICAgICAgICAgIG9ialtwXSA9IHRoaXNbcF07XG4gICAgfVxuICB9XG4gIERlY2ltYWwyLmNvbmZpZyhvYmopO1xuICByZXR1cm4gRGVjaW1hbDI7XG59XG5fX25hbWUoY2xvbmUsIFwiY2xvbmVcIik7XG5mdW5jdGlvbiBkaXYoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuZGl2KHkpO1xufVxuX19uYW1lKGRpdiwgXCJkaXZcIik7XG5mdW5jdGlvbiBleHAoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuZXhwKCk7XG59XG5fX25hbWUoZXhwLCBcImV4cFwiKTtcbmZ1bmN0aW9uIGZsb29yKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XG59XG5fX25hbWUoZmxvb3IsIFwiZmxvb3JcIik7XG5mdW5jdGlvbiBoeXBvdCgpIHtcbiAgdmFyIGksIG4sIHQgPSBuZXcgdGhpcygwKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICkge1xuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XG4gICAgaWYgKCFuLmQpIHtcbiAgICAgIGlmIChuLnMpIHtcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoMSAvIDApO1xuICAgICAgfVxuICAgICAgdCA9IG47XG4gICAgfSBlbHNlIGlmICh0LmQpIHtcbiAgICAgIHQgPSB0LnBsdXMobi50aW1lcyhuKSk7XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHQuc3FydCgpO1xufVxuX19uYW1lKGh5cG90LCBcImh5cG90XCIpO1xuZnVuY3Rpb24gaXNEZWNpbWFsSW5zdGFuY2Uob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoudG9TdHJpbmdUYWcgPT09IHRhZyB8fCBmYWxzZTtcbn1cbl9fbmFtZShpc0RlY2ltYWxJbnN0YW5jZSwgXCJpc0RlY2ltYWxJbnN0YW5jZVwiKTtcbmZ1bmN0aW9uIGxuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxuKCk7XG59XG5fX25hbWUobG4sIFwibG5cIik7XG5mdW5jdGlvbiBsb2coeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKHkpO1xufVxuX19uYW1lKGxvZywgXCJsb2dcIik7XG5mdW5jdGlvbiBsb2cyKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcbn1cbl9fbmFtZShsb2cyLCBcImxvZzJcIik7XG5mdW5jdGlvbiBsb2cxMCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xufVxuX19uYW1lKGxvZzEwLCBcImxvZzEwXCIpO1xuZnVuY3Rpb24gbWF4KCkge1xuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCBcImx0XCIpO1xufVxuX19uYW1lKG1heCwgXCJtYXhcIik7XG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIFwiZ3RcIik7XG59XG5fX25hbWUobWluLCBcIm1pblwiKTtcbmZ1bmN0aW9uIG1vZCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tb2QoeSk7XG59XG5fX25hbWUobW9kLCBcIm1vZFwiKTtcbmZ1bmN0aW9uIG11bCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tdWwoeSk7XG59XG5fX25hbWUobXVsLCBcIm11bFwiKTtcbmZ1bmN0aW9uIHBvdyh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5wb3coeSk7XG59XG5fX25hbWUocG93LCBcInBvd1wiKTtcbmZ1bmN0aW9uIHJhbmRvbShzZCkge1xuICB2YXIgZCwgZSwgaywgbiwgaSA9IDAsIHIgPSBuZXcgdGhpcygxKSwgcmQgPSBbXTtcbiAgaWYgKHNkID09PSB2b2lkIDApXG4gICAgc2QgPSB0aGlzLnByZWNpc2lvbjtcbiAgZWxzZVxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICBrID0gTWF0aC5jZWlsKHNkIC8gTE9HX0JBU0UpO1xuICBpZiAoIXRoaXMuY3J5cHRvKSB7XG4gICAgZm9yICg7IGkgPCBrOyApXG4gICAgICByZFtpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XG4gIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldO1xuICAgICAgaWYgKG4gPj0gNDI5ZTcpIHtcbiAgICAgICAgZFtpXSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkW2krK10gPSBuICUgMWU3O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldICsgKGRbaSArIDFdIDw8IDgpICsgKGRbaSArIDJdIDw8IDE2KSArICgoZFtpICsgM10gJiAxMjcpIDw8IDI0KTtcbiAgICAgIGlmIChuID49IDIxNGU3KSB7XG4gICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmQucHVzaChuICUgMWU3KTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICBpID0gayAvIDQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICB9XG4gIGsgPSByZFstLWldO1xuICBzZCAlPSBMT0dfQkFTRTtcbiAgaWYgKGsgJiYgc2QpIHtcbiAgICBuID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBzZCk7XG4gICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XG4gIH1cbiAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pXG4gICAgcmQucG9wKCk7XG4gIGlmIChpIDwgMCkge1xuICAgIGUgPSAwO1xuICAgIHJkID0gWzBdO1xuICB9IGVsc2Uge1xuICAgIGUgPSAtMTtcbiAgICBmb3IgKDsgcmRbMF0gPT09IDA7IGUgLT0gTE9HX0JBU0UpXG4gICAgICByZC5zaGlmdCgpO1xuICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMClcbiAgICAgIGsrKztcbiAgICBpZiAoayA8IExPR19CQVNFKVxuICAgICAgZSAtPSBMT0dfQkFTRSAtIGs7XG4gIH1cbiAgci5lID0gZTtcbiAgci5kID0gcmQ7XG4gIHJldHVybiByO1xufVxuX19uYW1lKHJhbmRvbSwgXCJyYW5kb21cIik7XG5mdW5jdGlvbiByb3VuZCh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xufVxuX19uYW1lKHJvdW5kLCBcInJvdW5kXCIpO1xuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHggPSBuZXcgdGhpcyh4KTtcbiAgcmV0dXJuIHguZCA/IHguZFswXSA/IHgucyA6IDAgKiB4LnMgOiB4LnMgfHwgTmFOO1xufVxuX19uYW1lKHNpZ24sIFwic2lnblwiKTtcbmZ1bmN0aW9uIHNpbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcbn1cbl9fbmFtZShzaW4sIFwic2luXCIpO1xuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XG59XG5fX25hbWUoc2luaCwgXCJzaW5oXCIpO1xuZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XG59XG5fX25hbWUoc3FydCwgXCJzcXJ0XCIpO1xuZnVuY3Rpb24gc3ViKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnN1Yih5KTtcbn1cbl9fbmFtZShzdWIsIFwic3ViXCIpO1xuZnVuY3Rpb24gc3VtKCkge1xuICB2YXIgaSA9IDAsIGFyZ3MgPSBhcmd1bWVudHMsIHggPSBuZXcgdGhpcyhhcmdzW2ldKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yICg7IHgucyAmJiArK2kgPCBhcmdzLmxlbmd0aDsgKVxuICAgIHggPSB4LnBsdXMoYXJnc1tpXSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIHRoaXMucHJlY2lzaW9uLCB0aGlzLnJvdW5kaW5nKTtcbn1cbl9fbmFtZShzdW0sIFwic3VtXCIpO1xuZnVuY3Rpb24gdGFuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbigpO1xufVxuX19uYW1lKHRhbiwgXCJ0YW5cIik7XG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbmgoKTtcbn1cbl9fbmFtZSh0YW5oLCBcInRhbmhcIik7XG5mdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xufVxuX19uYW1lKHRydW5jLCBcInRydW5jXCIpO1xuUFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gUC50b1N0cmluZztcblBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiRGVjaW1hbFwiO1xudmFyIERlY2ltYWwgPSBQLmNvbnN0cnVjdG9yID0gY2xvbmUoREVGQVVMVFMpO1xuTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xuUEkgPSBuZXcgRGVjaW1hbChQSSk7XG52YXIgZGVjaW1hbF9kZWZhdWx0ID0gRGVjaW1hbDtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvY29tbW9uLnRzXG52YXIgaW1wb3J0X2luZGVudF9zdHJpbmcgPSBfX3RvRVNNKHJlcXVpcmVfaW5kZW50X3N0cmluZygpKTtcbnZhciBpbXBvcnRfanNfbGV2ZW5zaHRlaW4gPSBfX3RvRVNNKHJlcXVpcmVfanNfbGV2ZW5zaHRlaW4oKSk7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvRmllbGRSZWYudHNcbnZhciBGaWVsZFJlZkltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsTmFtZSwgbmFtZSwgZmllbGRUeXBlLCBpc0xpc3QpIHtcbiAgICB0aGlzLm1vZGVsTmFtZSA9IG1vZGVsTmFtZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZU5hbWUgPSBmaWVsZFR5cGU7XG4gICAgdGhpcy5pc0xpc3QgPSBpc0xpc3Q7XG4gIH1cbiAgX3RvR3JhcGhRTElucHV0VHlwZSgpIHtcbiAgICBjb25zdCBwcmVmaXggPSB0aGlzLmlzTGlzdCA/IGBMaXN0JHt0aGlzLnR5cGVOYW1lfWAgOiB0aGlzLnR5cGVOYW1lO1xuICAgIHJldHVybiBgJHtwcmVmaXh9RmllbGRSZWZJbnB1dDwke3RoaXMubW9kZWxOYW1lfT5gO1xuICB9XG59O1xuX19uYW1lKEZpZWxkUmVmSW1wbCwgXCJGaWVsZFJlZkltcGxcIik7XG5cbi8vIHNyYy9ydW50aW1lL29iamVjdC1lbnVtcy50c1xudmFyIG9iamVjdEVudW1OYW1lcyA9IFtcIkpzb25OdWxsVmFsdWVJbnB1dFwiLCBcIk51bGxhYmxlSnNvbk51bGxWYWx1ZUlucHV0XCIsIFwiSnNvbk51bGxWYWx1ZUZpbHRlclwiXTtcbnZhciBzZWNyZXQgPSBTeW1ib2woKTtcbnZhciByZXByZXNlbnRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBPYmplY3RFbnVtVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZzIpIHtcbiAgICBpZiAoYXJnMiA9PT0gc2VjcmV0KSB7XG4gICAgICByZXByZXNlbnRhdGlvbnMuc2V0KHRoaXMsIGBQcmlzbWEuJHt0aGlzLl9nZXROYW1lKCl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcHJlc2VudGF0aW9ucy5zZXQodGhpcywgYG5ldyBQcmlzbWEuJHt0aGlzLl9nZXROYW1lc3BhY2UoKX0uJHt0aGlzLl9nZXROYW1lKCl9KClgKTtcbiAgICB9XG4gIH1cbiAgX2dldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gcmVwcmVzZW50YXRpb25zLmdldCh0aGlzKTtcbiAgfVxufTtcbl9fbmFtZShPYmplY3RFbnVtVmFsdWUsIFwiT2JqZWN0RW51bVZhbHVlXCIpO1xudmFyIE51bGxUeXBlc0VudW1WYWx1ZSA9IGNsYXNzIGV4dGVuZHMgT2JqZWN0RW51bVZhbHVlIHtcbiAgX2dldE5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gXCJOdWxsVHlwZXNcIjtcbiAgfVxufTtcbl9fbmFtZShOdWxsVHlwZXNFbnVtVmFsdWUsIFwiTnVsbFR5cGVzRW51bVZhbHVlXCIpO1xudmFyIERiTnVsbCA9IGNsYXNzIGV4dGVuZHMgTnVsbFR5cGVzRW51bVZhbHVlIHtcbn07XG5fX25hbWUoRGJOdWxsLCBcIkRiTnVsbFwiKTtcbnZhciBKc29uTnVsbCA9IGNsYXNzIGV4dGVuZHMgTnVsbFR5cGVzRW51bVZhbHVlIHtcbn07XG5fX25hbWUoSnNvbk51bGwsIFwiSnNvbk51bGxcIik7XG52YXIgQW55TnVsbCA9IGNsYXNzIGV4dGVuZHMgTnVsbFR5cGVzRW51bVZhbHVlIHtcbn07XG5fX25hbWUoQW55TnVsbCwgXCJBbnlOdWxsXCIpO1xudmFyIG9iamVjdEVudW1WYWx1ZXMgPSB7XG4gIGNsYXNzZXM6IHtcbiAgICBEYk51bGwsXG4gICAgSnNvbk51bGwsXG4gICAgQW55TnVsbFxuICB9LFxuICBpbnN0YW5jZXM6IHtcbiAgICBEYk51bGw6IG5ldyBEYk51bGwoc2VjcmV0KSxcbiAgICBKc29uTnVsbDogbmV3IEpzb25OdWxsKHNlY3JldCksXG4gICAgQW55TnVsbDogbmV3IEFueU51bGwoc2VjcmV0KVxuICB9XG59O1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9kZWNpbWFsSnNMaWtlLnRzXG5mdW5jdGlvbiBpc0RlY2ltYWxKc0xpa2UodmFsdWUpIHtcbiAgaWYgKERlY2ltYWwuaXNEZWNpbWFsKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLmUgPT09IFwibnVtYmVyXCIgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kKTtcbn1cbl9fbmFtZShpc0RlY2ltYWxKc0xpa2UsIFwiaXNEZWNpbWFsSnNMaWtlXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5RGVjaW1hbEpzTGlrZSh2YWx1ZSkge1xuICBpZiAoRGVjaW1hbC5pc0RlY2ltYWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgY29uc3QgdG1wRGVjaW1hbCA9IG5ldyBEZWNpbWFsKDApO1xuICB0bXBEZWNpbWFsLmQgPSB2YWx1ZS5kO1xuICB0bXBEZWNpbWFsLmUgPSB2YWx1ZS5lO1xuICB0bXBEZWNpbWFsLnMgPSB2YWx1ZS5zO1xuICByZXR1cm4gU3RyaW5nKHRtcERlY2ltYWwpO1xufVxuX19uYW1lKHN0cmluZ2lmeURlY2ltYWxKc0xpa2UsIFwic3RyaW5naWZ5RGVjaW1hbEpzTGlrZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvY29tbW9uLnRzXG52YXIga2V5QnkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjb2xsZWN0aW9uLCBwcm9wKSA9PiB7XG4gIGNvbnN0IGFjYyA9IHt9O1xuICBmb3IgKGNvbnN0IG9iaiBvZiBjb2xsZWN0aW9uKSB7XG4gICAgY29uc3Qga2V5ID0gb2JqW3Byb3BdO1xuICAgIGFjY1trZXldID0gb2JqO1xuICB9XG4gIHJldHVybiBhY2M7XG59LCBcImtleUJ5XCIpO1xudmFyIFNjYWxhclR5cGVUYWJsZSA9IHtcbiAgU3RyaW5nOiB0cnVlLFxuICBJbnQ6IHRydWUsXG4gIEZsb2F0OiB0cnVlLFxuICBCb29sZWFuOiB0cnVlLFxuICBMb25nOiB0cnVlLFxuICBEYXRlVGltZTogdHJ1ZSxcbiAgSUQ6IHRydWUsXG4gIFVVSUQ6IHRydWUsXG4gIEpzb246IHRydWUsXG4gIEJ5dGVzOiB0cnVlLFxuICBEZWNpbWFsOiB0cnVlLFxuICBCaWdJbnQ6IHRydWVcbn07XG52YXIgSlNUeXBlVG9HcmFwaFFMVHlwZSA9IHtcbiAgc3RyaW5nOiBcIlN0cmluZ1wiLFxuICBib29sZWFuOiBcIkJvb2xlYW5cIixcbiAgb2JqZWN0OiBcIkpzb25cIixcbiAgc3ltYm9sOiBcIlN5bWJvbFwiXG59O1xuZnVuY3Rpb24gc3RyaW5naWZ5R3JhcGhRTFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICByZXR1cm4gdHlwZS5uYW1lO1xufVxuX19uYW1lKHN0cmluZ2lmeUdyYXBoUUxUeXBlLCBcInN0cmluZ2lmeUdyYXBoUUxUeXBlXCIpO1xuZnVuY3Rpb24gd3JhcFdpdGhMaXN0KHN0ciwgaXNMaXN0KSB7XG4gIGlmIChpc0xpc3QpIHtcbiAgICByZXR1cm4gYExpc3Q8JHtzdHJ9PmA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbl9fbmFtZSh3cmFwV2l0aExpc3QsIFwid3JhcFdpdGhMaXN0XCIpO1xudmFyIFJGQ18zMzM5X1JFR0VYID0gL14oXFxkezR9LSgwWzEtOV18MVswMTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlUKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkpKFxcLlxcZHsxLH0pPygoW1pdKXwoWyt8LV0oWzAxXVswLTldfDJbMC0zXSk6WzAtNV1bMC05XSkpJC87XG52YXIgVVVJRF9SRUdFWCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2k7XG5mdW5jdGlvbiBnZXRHcmFwaFFMVHlwZSh2YWx1ZSwgaW5wdXRUeXBlKSB7XG4gIGNvbnN0IHBvdGVudGlhbFR5cGUgPSBpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS50eXBlO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBCaWdJbnRdXCIpIHtcbiAgICByZXR1cm4gXCJCaWdJbnRcIjtcbiAgfVxuICBpZiAoZGVjaW1hbF9kZWZhdWx0LmlzRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJEZWNpbWFsXCI7XG4gIH1cbiAgaWYgKHBvdGVudGlhbFR5cGUgPT09IFwiRGVjaW1hbFwiICYmIGlzRGVjaW1hbEpzTGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJEZWNpbWFsXCI7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJCeXRlc1wiO1xuICB9XG4gIGlmIChpc1ZhbGlkRW51bVZhbHVlKHZhbHVlLCBpbnB1dFR5cGUpKSB7XG4gICAgcmV0dXJuIHBvdGVudGlhbFR5cGUubmFtZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3RFbnVtVmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuX2dldE5hbWUoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWVsZFJlZkltcGwpIHtcbiAgICByZXR1cm4gdmFsdWUuX3RvR3JhcGhRTElucHV0VHlwZSgpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGxldCBzY2FsYXJUeXBlcyA9IHZhbHVlLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRHcmFwaFFMVHlwZSh2YWwsIGlucHV0VHlwZSk7XG4gICAgICBpZiAoIWFjYy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBhY2MucHVzaCh0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGlmIChzY2FsYXJUeXBlcy5pbmNsdWRlcyhcIkZsb2F0XCIpICYmIHNjYWxhclR5cGVzLmluY2x1ZGVzKFwiSW50XCIpKSB7XG4gICAgICBzY2FsYXJUeXBlcyA9IFtcIkZsb2F0XCJdO1xuICAgIH1cbiAgICByZXR1cm4gYExpc3Q8JHtzY2FsYXJUeXBlcy5qb2luKFwiIHwgXCIpfT5gO1xuICB9XG4gIGNvbnN0IGpzVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKGpzVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChNYXRoLnRydW5jKHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBcIkludFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJGbG9hdFwiO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcbiAgICByZXR1cm4gXCJEYXRlVGltZVwiO1xuICB9XG4gIGlmIChqc1R5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoVVVJRF9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFwiVVVJRFwiO1xuICAgIH1cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChkYXRlLnRvU3RyaW5nKCkgPT09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgIHJldHVybiBcIlN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoUkZDXzMzMzlfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcIkRhdGVUaW1lXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU1R5cGVUb0dyYXBoUUxUeXBlW2pzVHlwZV07XG59XG5fX25hbWUoZ2V0R3JhcGhRTFR5cGUsIFwiZ2V0R3JhcGhRTFR5cGVcIik7XG5mdW5jdGlvbiBpc1ZhbGlkRW51bVZhbHVlKHZhbHVlLCBpbnB1dFR5cGUpIHtcbiAgdmFyIF9hMztcbiAgY29uc3QgZW51bVR5cGUgPSBpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS50eXBlO1xuICBpZiAoIWlzU2NoZW1hRW51bShlbnVtVHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS5uYW1lc3BhY2UpID09PSBcInByaXNtYVwiICYmIG9iamVjdEVudW1OYW1lcy5pbmNsdWRlcyhlbnVtVHlwZS5uYW1lKSkge1xuICAgIGNvbnN0IG5hbWUgPSAoX2EzID0gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm5hbWU7XG4gICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIG9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzW25hbWVdID09PSB2YWx1ZSAmJiBlbnVtVHlwZS52YWx1ZXMuaW5jbHVkZXMobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBlbnVtVHlwZS52YWx1ZXMuaW5jbHVkZXModmFsdWUpO1xufVxuX19uYW1lKGlzVmFsaWRFbnVtVmFsdWUsIFwiaXNWYWxpZEVudW1WYWx1ZVwiKTtcbmZ1bmN0aW9uIGdldFN1Z2dlc3Rpb24oc3RyLCBwb3NzaWJpbGl0aWVzKSB7XG4gIGNvbnN0IGJlc3RNYXRjaCA9IHBvc3NpYmlsaXRpZXMucmVkdWNlKFxuICAgIChhY2MsIGN1cnIpID0+IHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gKDAsIGltcG9ydF9qc19sZXZlbnNodGVpbi5kZWZhdWx0KShzdHIsIGN1cnIpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgYWNjLmRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgc3RyOiBjdXJyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAge1xuICAgICAgZGlzdGFuY2U6IE1hdGgubWluKE1hdGguZmxvb3Ioc3RyLmxlbmd0aCkgKiAxLjEsIC4uLnBvc3NpYmlsaXRpZXMubWFwKChwKSA9PiBwLmxlbmd0aCAqIDMpKSxcbiAgICAgIHN0cjogbnVsbFxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGJlc3RNYXRjaC5zdHI7XG59XG5fX25hbWUoZ2V0U3VnZ2VzdGlvbiwgXCJnZXRTdWdnZXN0aW9uXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5SW5wdXRUeXBlKGlucHV0LCBncmVlbktleXMgPSBmYWxzZSkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGlmIChpbnB1dC52YWx1ZXMpIHtcbiAgICByZXR1cm4gYGVudW0gJHtpbnB1dC5uYW1lfSB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZy5kZWZhdWx0KShpbnB1dC52YWx1ZXMuam9pbihcIiwgXCIpLCAyKX1cbn1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJvZHkgPSAoMCwgaW1wb3J0X2luZGVudF9zdHJpbmcuZGVmYXVsdCkoXG4gICAgICBpbnB1dC5maWVsZHMubWFwKChhcmcyKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2FyZzIubmFtZX1gO1xuICAgICAgICBjb25zdCBzdHIgPSBgJHtncmVlbktleXMgPyBpbXBvcnRfY2hhbGsuZGVmYXVsdC5ncmVlbihrZXkpIDoga2V5fSR7YXJnMi5pc1JlcXVpcmVkID8gXCJcIiA6IFwiP1wifTogJHtpbXBvcnRfY2hhbGsuZGVmYXVsdC53aGl0ZShcbiAgICAgICAgICBhcmcyLmlucHV0VHlwZXMubWFwKChhcmdUeXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcFdpdGhMaXN0KFxuICAgICAgICAgICAgICBhcmdJc0lucHV0VHlwZShhcmdUeXBlLnR5cGUpID8gYXJnVHlwZS50eXBlLm5hbWUgOiBzdHJpbmdpZnlHcmFwaFFMVHlwZShhcmdUeXBlLnR5cGUpLFxuICAgICAgICAgICAgICBhcmdUeXBlLmlzTGlzdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KS5qb2luKFwiIHwgXCIpXG4gICAgICAgICl9YDtcbiAgICAgICAgaWYgKCFhcmcyLmlzUmVxdWlyZWQpIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0X2NoYWxrLmRlZmF1bHQuZGltKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH0pLmpvaW4oXCJcXG5cIiksXG4gICAgICAyXG4gICAgKTtcbiAgICByZXR1cm4gYCR7aW1wb3J0X2NoYWxrLmRlZmF1bHQuZGltKFwidHlwZVwiKX0gJHtpbXBvcnRfY2hhbGsuZGVmYXVsdC5ib2xkLmRpbShpbnB1dC5uYW1lKX0gJHtpbXBvcnRfY2hhbGsuZGVmYXVsdC5kaW0oXCJ7XCIpfVxuJHtib2R5fVxuJHtpbXBvcnRfY2hhbGsuZGVmYXVsdC5kaW0oXCJ9XCIpfWA7XG4gIH1cbn1cbl9fbmFtZShzdHJpbmdpZnlJbnB1dFR5cGUsIFwic3RyaW5naWZ5SW5wdXRUeXBlXCIpO1xuZnVuY3Rpb24gYXJnSXNJbnB1dFR5cGUoYXJnMikge1xuICBpZiAodHlwZW9mIGFyZzIgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5fX25hbWUoYXJnSXNJbnB1dFR5cGUsIFwiYXJnSXNJbnB1dFR5cGVcIik7XG5mdW5jdGlvbiBnZXRJbnB1dFR5cGVOYW1lKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaW5wdXQgPT09IFwiTnVsbFwiKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gaW5wdXQubmFtZTtcbn1cbl9fbmFtZShnZXRJbnB1dFR5cGVOYW1lLCBcImdldElucHV0VHlwZU5hbWVcIik7XG5mdW5jdGlvbiBnZXRPdXRwdXRUeXBlTmFtZShpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5uYW1lO1xufVxuX19uYW1lKGdldE91dHB1dFR5cGVOYW1lLCBcImdldE91dHB1dFR5cGVOYW1lXCIpO1xuZnVuY3Rpb24gaW5wdXRUeXBlVG9Kc29uKGlucHV0LCBpc1JlcXVpcmVkLCBuYW1lT25seSA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaW5wdXQgPT09IFwiTnVsbFwiKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBpZiAoaW5wdXQudmFsdWVzKSB7XG4gICAgcmV0dXJuIGlucHV0LnZhbHVlcy5qb2luKFwiIHwgXCIpO1xuICB9XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0O1xuICBjb25zdCBzaG93RGVlcFR5cGUgPSBpc1JlcXVpcmVkICYmIGlucHV0VHlwZS5maWVsZHMuZXZlcnkoXG4gICAgKGFyZzIpID0+IHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gYXJnMi5pbnB1dFR5cGVzWzBdLmxvY2F0aW9uID09PSBcImlucHV0T2JqZWN0VHlwZXNcIiB8fCAoKF9hMyA9IGFyZzIuaW5wdXRUeXBlc1sxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5sb2NhdGlvbikgPT09IFwiaW5wdXRPYmplY3RUeXBlc1wiO1xuICAgIH1cbiAgKTtcbiAgaWYgKG5hbWVPbmx5KSB7XG4gICAgcmV0dXJuIGdldElucHV0VHlwZU5hbWUoaW5wdXQpO1xuICB9XG4gIHJldHVybiBpbnB1dFR5cGUuZmllbGRzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgaWYgKCFzaG93RGVlcFR5cGUgJiYgIWN1cnIuaXNSZXF1aXJlZCkge1xuICAgICAgc3RyID0gY3Vyci5pbnB1dFR5cGVzLm1hcCgoYXJnVHlwZSkgPT4gZ2V0SW5wdXRUeXBlTmFtZShhcmdUeXBlLnR5cGUpKS5qb2luKFwiIHwgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdXJyLmlucHV0VHlwZXMubWFwKChhcmdJbnB1dFR5cGUpID0+IGlucHV0VHlwZVRvSnNvbihhcmdJbnB1dFR5cGUudHlwZSwgY3Vyci5pc1JlcXVpcmVkLCB0cnVlKSkuam9pbihcIiB8IFwiKTtcbiAgICB9XG4gICAgYWNjW2N1cnIubmFtZSArIChjdXJyLmlzUmVxdWlyZWQgPyBcIlwiIDogXCI/XCIpXSA9IHN0cjtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5fX25hbWUoaW5wdXRUeXBlVG9Kc29uLCBcImlucHV0VHlwZVRvSnNvblwiKTtcbmZ1bmN0aW9uIHVuaW9uQnkoYXJyMSwgYXJyMiwgaXRlcmF0ZWUpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIxKSB7XG4gICAgbWFwW2l0ZXJhdGVlKGVsZW1lbnQpXSA9IGVsZW1lbnQ7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycjIpIHtcbiAgICBjb25zdCBrZXkgPSBpdGVyYXRlZShlbGVtZW50KTtcbiAgICBpZiAoIW1hcFtrZXldKSB7XG4gICAgICBtYXBba2V5XSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG1hcCk7XG59XG5fX25hbWUodW5pb25CeSwgXCJ1bmlvbkJ5XCIpO1xuZnVuY3Rpb24gbG93ZXJDYXNlKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbn1cbl9fbmFtZShsb3dlckNhc2UsIFwibG93ZXJDYXNlXCIpO1xuZnVuY3Rpb24gaXNHcm91cEJ5T3V0cHV0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmVuZHNXaXRoKFwiR3JvdXBCeU91dHB1dFR5cGVcIik7XG59XG5fX25hbWUoaXNHcm91cEJ5T3V0cHV0TmFtZSwgXCJpc0dyb3VwQnlPdXRwdXROYW1lXCIpO1xuZnVuY3Rpb24gaXNTY2hlbWFFbnVtKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KHR5cGUudmFsdWVzKTtcbn1cbl9fbmFtZShpc1NjaGVtYUVudW0sIFwiaXNTY2hlbWFFbnVtXCIpO1xuXG4vLyBzcmMvcnVudGltZS9kbW1mLnRzXG52YXIgRE1NRkRhdGFtb2RlbEhlbHBlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBkYXRhbW9kZWwgfSkge1xuICAgIHRoaXMuZGF0YW1vZGVsID0gZGF0YW1vZGVsO1xuICAgIHRoaXMuZGF0YW1vZGVsRW51bU1hcCA9IHRoaXMuZ2V0RGF0YW1vZGVsRW51bU1hcCgpO1xuICAgIHRoaXMubW9kZWxNYXAgPSB0aGlzLmdldE1vZGVsTWFwKCk7XG4gICAgdGhpcy50eXBlTWFwID0gdGhpcy5nZXRUeXBlTWFwKCk7XG4gICAgdGhpcy50eXBlQW5kTW9kZWxNYXAgPSB0aGlzLmdldFR5cGVNb2RlbE1hcCgpO1xuICB9XG4gIGdldERhdGFtb2RlbEVudW1NYXAoKSB7XG4gICAgcmV0dXJuIGtleUJ5KHRoaXMuZGF0YW1vZGVsLmVudW1zLCBcIm5hbWVcIik7XG4gIH1cbiAgZ2V0TW9kZWxNYXAoKSB7XG4gICAgcmV0dXJuIHsgLi4ua2V5QnkodGhpcy5kYXRhbW9kZWwubW9kZWxzLCBcIm5hbWVcIikgfTtcbiAgfVxuICBnZXRUeXBlTWFwKCkge1xuICAgIHJldHVybiB7IC4uLmtleUJ5KHRoaXMuZGF0YW1vZGVsLnR5cGVzLCBcIm5hbWVcIikgfTtcbiAgfVxuICBnZXRUeXBlTW9kZWxNYXAoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5nZXRUeXBlTWFwKCksIC4uLnRoaXMuZ2V0TW9kZWxNYXAoKSB9O1xuICB9XG59O1xuX19uYW1lKERNTUZEYXRhbW9kZWxIZWxwZXIsIFwiRE1NRkRhdGFtb2RlbEhlbHBlclwiKTtcbnZhciBETU1GTWFwcGluZ3NIZWxwZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgbWFwcGluZ3MgfSkge1xuICAgIHRoaXMubWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICB0aGlzLm1hcHBpbmdzTWFwID0gdGhpcy5nZXRNYXBwaW5nc01hcCgpO1xuICB9XG4gIGdldE1hcHBpbmdzTWFwKCkge1xuICAgIHJldHVybiBrZXlCeSh0aGlzLm1hcHBpbmdzLm1vZGVsT3BlcmF0aW9ucywgXCJtb2RlbFwiKTtcbiAgfVxufTtcbl9fbmFtZShETU1GTWFwcGluZ3NIZWxwZXIsIFwiRE1NRk1hcHBpbmdzSGVscGVyXCIpO1xudmFyIERNTUZTY2hlbWFIZWxwZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgc2NoZW1hIH0pIHtcbiAgICB0aGlzLm91dHB1dFR5cGVUb01lcmdlZE91dHB1dFR5cGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvdXRwdXRUeXBlKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vdXRwdXRUeXBlLFxuICAgICAgICBmaWVsZHM6IG91dHB1dFR5cGUuZmllbGRzXG4gICAgICB9O1xuICAgIH0sIFwib3V0cHV0VHlwZVRvTWVyZ2VkT3V0cHV0VHlwZVwiKTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmVudW1NYXAgPSB0aGlzLmdldEVudW1NYXAoKTtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9IHRoaXMuZ2V0UXVlcnlUeXBlKCk7XG4gICAgdGhpcy5tdXRhdGlvblR5cGUgPSB0aGlzLmdldE11dGF0aW9uVHlwZSgpO1xuICAgIHRoaXMub3V0cHV0VHlwZXMgPSB0aGlzLmdldE91dHB1dFR5cGVzKCk7XG4gICAgdGhpcy5vdXRwdXRUeXBlTWFwID0gdGhpcy5nZXRNZXJnZWRPdXRwdXRUeXBlTWFwKCk7XG4gICAgdGhpcy5yZXNvbHZlT3V0cHV0VHlwZXMoKTtcbiAgICB0aGlzLmlucHV0T2JqZWN0VHlwZXMgPSB0aGlzLnNjaGVtYS5pbnB1dE9iamVjdFR5cGVzO1xuICAgIHRoaXMuaW5wdXRUeXBlTWFwID0gdGhpcy5nZXRJbnB1dFR5cGVNYXAoKTtcbiAgICB0aGlzLnJlc29sdmVJbnB1dFR5cGVzKCk7XG4gICAgdGhpcy5yZXNvbHZlRmllbGRBcmd1bWVudFR5cGVzKCk7XG4gICAgdGhpcy5xdWVyeVR5cGUgPSB0aGlzLm91dHB1dFR5cGVNYXAuUXVlcnk7XG4gICAgdGhpcy5tdXRhdGlvblR5cGUgPSB0aGlzLm91dHB1dFR5cGVNYXAuTXV0YXRpb247XG4gICAgdGhpcy5yb290RmllbGRNYXAgPSB0aGlzLmdldFJvb3RGaWVsZE1hcCgpO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJETU1GQ2xhc3NcIjtcbiAgfVxuICByZXNvbHZlT3V0cHV0VHlwZXMoKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMub3V0cHV0VHlwZXMubW9kZWwpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5vdXRwdXRUeXBlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgIVNjYWxhclR5cGVUYWJsZVtmaWVsZC5vdXRwdXRUeXBlLnR5cGVdKSB7XG4gICAgICAgICAgZmllbGQub3V0cHV0VHlwZS50eXBlID0gdGhpcy5vdXRwdXRUeXBlTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgdGhpcy5vdXRwdXRUeXBlTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgdGhpcy5lbnVtTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgZmllbGQub3V0cHV0VHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eXBlLmZpZWxkTWFwID0ga2V5QnkodHlwZS5maWVsZHMsIFwibmFtZVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMub3V0cHV0VHlwZXMucHJpc21hKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGQub3V0cHV0VHlwZS50eXBlID09PSBcInN0cmluZ1wiICYmICFTY2FsYXJUeXBlVGFibGVbZmllbGQub3V0cHV0VHlwZS50eXBlXSkge1xuICAgICAgICAgIGZpZWxkLm91dHB1dFR5cGUudHlwZSA9IHRoaXMub3V0cHV0VHlwZU1hcFtmaWVsZC5vdXRwdXRUeXBlLnR5cGVdIHx8IHRoaXMub3V0cHV0VHlwZU1hcFtmaWVsZC5vdXRwdXRUeXBlLnR5cGVdIHx8IHRoaXMuZW51bU1hcFtmaWVsZC5vdXRwdXRUeXBlLnR5cGVdIHx8IGZpZWxkLm91dHB1dFR5cGUudHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZS5maWVsZE1hcCA9IGtleUJ5KHR5cGUuZmllbGRzLCBcIm5hbWVcIik7XG4gICAgfVxuICB9XG4gIHJlc29sdmVJbnB1dFR5cGVzKCkge1xuICAgIGNvbnN0IGlucHV0VHlwZXMgPSB0aGlzLmlucHV0T2JqZWN0VHlwZXMucHJpc21hO1xuICAgIGlmICh0aGlzLmlucHV0T2JqZWN0VHlwZXMubW9kZWwpIHtcbiAgICAgIGlucHV0VHlwZXMucHVzaCguLi50aGlzLmlucHV0T2JqZWN0VHlwZXMubW9kZWwpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgaW5wdXRUeXBlcykge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkSW5wdXRUeXBlIG9mIGZpZWxkLmlucHV0VHlwZXMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZElucHV0VHlwZS50eXBlO1xuICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcInN0cmluZ1wiICYmICFTY2FsYXJUeXBlVGFibGVbZmllbGRUeXBlXSAmJiAodGhpcy5pbnB1dFR5cGVNYXBbZmllbGRUeXBlXSB8fCB0aGlzLmVudW1NYXBbZmllbGRUeXBlXSkpIHtcbiAgICAgICAgICAgIGZpZWxkSW5wdXRUeXBlLnR5cGUgPSB0aGlzLmlucHV0VHlwZU1hcFtmaWVsZFR5cGVdIHx8IHRoaXMuZW51bU1hcFtmaWVsZFR5cGVdIHx8IGZpZWxkVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHR5cGUuZmllbGRNYXAgPSBrZXlCeSh0eXBlLmZpZWxkcywgXCJuYW1lXCIpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRmllbGRBcmd1bWVudFR5cGVzKCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0aGlzLm91dHB1dFR5cGVzLnByaXNtYSkge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZzIgb2YgZmllbGQuYXJncykge1xuICAgICAgICAgIGZvciAoY29uc3QgYXJnSW5wdXRUeXBlIG9mIGFyZzIuaW5wdXRUeXBlcykge1xuICAgICAgICAgICAgY29uc3QgYXJnVHlwZSA9IGFyZ0lucHV0VHlwZS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdUeXBlID09PSBcInN0cmluZ1wiICYmICFTY2FsYXJUeXBlVGFibGVbYXJnVHlwZV0pIHtcbiAgICAgICAgICAgICAgYXJnSW5wdXRUeXBlLnR5cGUgPSB0aGlzLmlucHV0VHlwZU1hcFthcmdUeXBlXSB8fCB0aGlzLmVudW1NYXBbYXJnVHlwZV0gfHwgYXJnVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMub3V0cHV0VHlwZXMubW9kZWwpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhcmcyIG9mIGZpZWxkLmFyZ3MpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFyZ0lucHV0VHlwZSBvZiBhcmcyLmlucHV0VHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ1R5cGUgPSBhcmdJbnB1dFR5cGUudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhU2NhbGFyVHlwZVRhYmxlW2FyZ1R5cGVdKSB7XG4gICAgICAgICAgICAgIGFyZ0lucHV0VHlwZS50eXBlID0gdGhpcy5pbnB1dFR5cGVNYXBbYXJnVHlwZV0gfHwgdGhpcy5lbnVtTWFwW2FyZ1R5cGVdIHx8IGFyZ0lucHV0VHlwZS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRRdWVyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hLm91dHB1dE9iamVjdFR5cGVzLnByaXNtYS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IFwiUXVlcnlcIik7XG4gIH1cbiAgZ2V0TXV0YXRpb25UeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnNjaGVtYS5vdXRwdXRPYmplY3RUeXBlcy5wcmlzbWEuZmluZCgodCkgPT4gdC5uYW1lID09PSBcIk11dGF0aW9uXCIpO1xuICB9XG4gIGdldE91dHB1dFR5cGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlbDogdGhpcy5zY2hlbWEub3V0cHV0T2JqZWN0VHlwZXMubW9kZWwubWFwKHRoaXMub3V0cHV0VHlwZVRvTWVyZ2VkT3V0cHV0VHlwZSksXG4gICAgICBwcmlzbWE6IHRoaXMuc2NoZW1hLm91dHB1dE9iamVjdFR5cGVzLnByaXNtYS5tYXAodGhpcy5vdXRwdXRUeXBlVG9NZXJnZWRPdXRwdXRUeXBlKVxuICAgIH07XG4gIH1cbiAgZ2V0RW51bU1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ua2V5QnkodGhpcy5zY2hlbWEuZW51bVR5cGVzLnByaXNtYSwgXCJuYW1lXCIpLFxuICAgICAgLi4udGhpcy5zY2hlbWEuZW51bVR5cGVzLm1vZGVsID8ga2V5QnkodGhpcy5zY2hlbWEuZW51bVR5cGVzLm1vZGVsLCBcIm5hbWVcIikgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGhhc0VudW1Jbk5hbWVzcGFjZShlbnVtTmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgdmFyIF9hMztcbiAgICByZXR1cm4gKChfYTMgPSB0aGlzLnNjaGVtYS5lbnVtVHlwZXNbbmFtZXNwYWNlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5maW5kKChzY2hlbWFFbnVtKSA9PiBzY2hlbWFFbnVtLm5hbWUgPT09IGVudW1OYW1lKSkgIT09IHZvaWQgMDtcbiAgfVxuICBnZXRNZXJnZWRPdXRwdXRUeXBlTWFwKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5rZXlCeSh0aGlzLm91dHB1dFR5cGVzLm1vZGVsLCBcIm5hbWVcIiksXG4gICAgICAuLi5rZXlCeSh0aGlzLm91dHB1dFR5cGVzLnByaXNtYSwgXCJuYW1lXCIpXG4gICAgfTtcbiAgfVxuICBnZXRJbnB1dFR5cGVNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuc2NoZW1hLmlucHV0T2JqZWN0VHlwZXMubW9kZWwgPyBrZXlCeSh0aGlzLnNjaGVtYS5pbnB1dE9iamVjdFR5cGVzLm1vZGVsLCBcIm5hbWVcIikgOiB2b2lkIDAsXG4gICAgICAuLi5rZXlCeSh0aGlzLnNjaGVtYS5pbnB1dE9iamVjdFR5cGVzLnByaXNtYSwgXCJuYW1lXCIpXG4gICAgfTtcbiAgfVxuICBnZXRSb290RmllbGRNYXAoKSB7XG4gICAgcmV0dXJuIHsgLi4ua2V5QnkodGhpcy5xdWVyeVR5cGUuZmllbGRzLCBcIm5hbWVcIiksIC4uLmtleUJ5KHRoaXMubXV0YXRpb25UeXBlLmZpZWxkcywgXCJuYW1lXCIpIH07XG4gIH1cbn07XG5fX25hbWUoRE1NRlNjaGVtYUhlbHBlciwgXCJETU1GU2NoZW1hSGVscGVyXCIpO1xudmFyIEJhc2VETU1GSGVscGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkbW1mKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcywgbmV3IERNTUZEYXRhbW9kZWxIZWxwZXIoZG1tZiksIG5ldyBETU1GTWFwcGluZ3NIZWxwZXIoZG1tZikpO1xuICB9XG59O1xuX19uYW1lKEJhc2VETU1GSGVscGVyLCBcIkJhc2VETU1GSGVscGVyXCIpO1xuYXBwbHlNaXhpbnMoQmFzZURNTUZIZWxwZXIsIFtETU1GRGF0YW1vZGVsSGVscGVyLCBETU1GTWFwcGluZ3NIZWxwZXJdKTtcbnZhciBETU1GSGVscGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkbW1mKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcywgbmV3IEJhc2VETU1GSGVscGVyKGRtbWYpLCBuZXcgRE1NRlNjaGVtYUhlbHBlcihkbW1mKSk7XG4gIH1cbn07XG5fX25hbWUoRE1NRkhlbHBlciwgXCJETU1GSGVscGVyXCIpO1xuYXBwbHlNaXhpbnMoRE1NRkhlbHBlciwgW0Jhc2VETU1GSGVscGVyLCBETU1GU2NoZW1hSGVscGVyXSk7XG5cbi8vIC4uL2dlbmVyYXRvci1oZWxwZXIvc3JjL2RtbWYudHNcbnZhciBETU1GO1xuKChETU1GMikgPT4ge1xuICBsZXQgTW9kZWxBY3Rpb247XG4gICgoTW9kZWxBY3Rpb24yKSA9PiB7XG4gICAgTW9kZWxBY3Rpb24yW1wiZmluZFVuaXF1ZVwiXSA9IFwiZmluZFVuaXF1ZVwiO1xuICAgIE1vZGVsQWN0aW9uMltcImZpbmRGaXJzdFwiXSA9IFwiZmluZEZpcnN0XCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiZmluZE1hbnlcIl0gPSBcImZpbmRNYW55XCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiY3JlYXRlXCJdID0gXCJjcmVhdGVcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJjcmVhdGVNYW55XCJdID0gXCJjcmVhdGVNYW55XCI7XG4gICAgTW9kZWxBY3Rpb24yW1widXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJ1cGRhdGVNYW55XCJdID0gXCJ1cGRhdGVNYW55XCI7XG4gICAgTW9kZWxBY3Rpb24yW1widXBzZXJ0XCJdID0gXCJ1cHNlcnRcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJkZWxldGVcIl0gPSBcImRlbGV0ZVwiO1xuICAgIE1vZGVsQWN0aW9uMltcImRlbGV0ZU1hbnlcIl0gPSBcImRlbGV0ZU1hbnlcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJncm91cEJ5XCJdID0gXCJncm91cEJ5XCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiY291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiYWdncmVnYXRlXCJdID0gXCJhZ2dyZWdhdGVcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJmaW5kUmF3XCJdID0gXCJmaW5kUmF3XCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiYWdncmVnYXRlUmF3XCJdID0gXCJhZ2dyZWdhdGVSYXdcIjtcbiAgfSkoTW9kZWxBY3Rpb24gPSBETU1GMi5Nb2RlbEFjdGlvbiB8fCAoRE1NRjIuTW9kZWxBY3Rpb24gPSB7fSkpO1xufSkoRE1NRiB8fCAoRE1NRiA9IHt9KSk7XG5cbi8vIC4uL2RlYnVnL3NyYy9pbmRleC50c1xudmFyIGltcG9ydF9kZWJ1ZyA9IF9fdG9FU00ocmVxdWlyZV9zcmMoKSk7XG52YXIgTUFYX0xPR1MgPSAxMDA7XG52YXIgZGVidWdBcmdzSGlzdG9yeSA9IFtdO1xudmFyIF9hLCBfYjtcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgKChfYSA9IHByb2Nlc3Muc3RkZXJyKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud3JpdGUpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgaW1wb3J0X2RlYnVnLmRlZmF1bHQubG9nID0gKF9iID0gY29uc29sZS5kZWJ1ZykgIT0gbnVsbCA/IF9iIDogY29uc29sZS5sb2c7XG59XG5mdW5jdGlvbiBkZWJ1Z0NhbGwobmFtZXNwYWNlKSB7XG4gIGNvbnN0IGRlYnVnTmFtZXNwYWNlID0gKDAsIGltcG9ydF9kZWJ1Zy5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICBjb25zdCBjYWxsID0gT2JqZWN0LmFzc2lnbigoLi4uYXJncykgPT4ge1xuICAgIGRlYnVnTmFtZXNwYWNlLmxvZyA9IGNhbGwubG9nO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZGVidWdBcmdzSGlzdG9yeS5wdXNoKFtuYW1lc3BhY2UsIC4uLmFyZ3NdKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnQXJnc0hpc3RvcnkubGVuZ3RoID4gTUFYX0xPR1MpIHtcbiAgICAgIGRlYnVnQXJnc0hpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlYnVnTmFtZXNwYWNlKFwiXCIsIC4uLmFyZ3MpO1xuICB9LCBkZWJ1Z05hbWVzcGFjZSk7XG4gIHJldHVybiBjYWxsO1xufVxuX19uYW1lKGRlYnVnQ2FsbCwgXCJkZWJ1Z0NhbGxcIik7XG52YXIgRGVidWcgPSBPYmplY3QuYXNzaWduKGRlYnVnQ2FsbCwgaW1wb3J0X2RlYnVnLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0TG9ncyhudW1DaGFycyA9IDc1MDApIHtcbiAgY29uc3Qgb3V0cHV0ID0gZGVidWdBcmdzSGlzdG9yeS5tYXAoXG4gICAgKGMpID0+IGMubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSkuam9pbihcIiBcIilcbiAgKS5qb2luKFwiXFxuXCIpO1xuICBpZiAob3V0cHV0Lmxlbmd0aCA8IG51bUNoYXJzKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0LnNsaWNlKC1udW1DaGFycyk7XG59XG5fX25hbWUoZ2V0TG9ncywgXCJnZXRMb2dzXCIpO1xudmFyIHNyY19kZWZhdWx0ID0gRGVidWc7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9nbG9iYWxUaGlzLmpzXG52YXIgX2dsb2JhbFRoaXMgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMgOiBnbG9iYWw7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjEuMS4wXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vaW50ZXJuYWwvc2VtdmVyLmpzXG52YXIgcmUgPSAvXihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSgtKC4rKSk/JC87XG5mdW5jdGlvbiBfbWFrZUNvbXBhdGliaWxpdHlDaGVjayhvd25WZXJzaW9uKSB7XG4gIHZhciBhY2NlcHRlZFZlcnNpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW293blZlcnNpb25dKTtcbiAgdmFyIHJlamVjdGVkVmVyc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB2YXIgbXlWZXJzaW9uTWF0Y2ggPSBvd25WZXJzaW9uLm1hdGNoKHJlKTtcbiAgaWYgKCFteVZlcnNpb25NYXRjaCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG4gIHZhciBvd25WZXJzaW9uUGFyc2VkID0ge1xuICAgIG1ham9yOiArbXlWZXJzaW9uTWF0Y2hbMV0sXG4gICAgbWlub3I6ICtteVZlcnNpb25NYXRjaFsyXSxcbiAgICBwYXRjaDogK215VmVyc2lvbk1hdGNoWzNdLFxuICAgIHByZXJlbGVhc2U6IG15VmVyc2lvbk1hdGNoWzRdXG4gIH07XG4gIGlmIChvd25WZXJzaW9uUGFyc2VkLnByZXJlbGVhc2UgIT0gbnVsbCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGlzRXhhY3RtYXRjaChnbG9iYWxWZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVmVyc2lvbiA9PT0gb3duVmVyc2lvbjtcbiAgICB9LCBcImlzRXhhY3RtYXRjaFwiKTtcbiAgfVxuICBmdW5jdGlvbiBfcmVqZWN0KHYpIHtcbiAgICByZWplY3RlZFZlcnNpb25zLmFkZCh2KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgX19uYW1lKF9yZWplY3QsIFwiX3JlamVjdFwiKTtcbiAgZnVuY3Rpb24gX2FjY2VwdCh2KSB7XG4gICAgYWNjZXB0ZWRWZXJzaW9ucy5hZGQodik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX19uYW1lKF9hY2NlcHQsIFwiX2FjY2VwdFwiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gaXNDb21wYXRpYmxlMihnbG9iYWxWZXJzaW9uKSB7XG4gICAgaWYgKGFjY2VwdGVkVmVyc2lvbnMuaGFzKGdsb2JhbFZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlamVjdGVkVmVyc2lvbnMuaGFzKGdsb2JhbFZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbG9iYWxWZXJzaW9uTWF0Y2ggPSBnbG9iYWxWZXJzaW9uLm1hdGNoKHJlKTtcbiAgICBpZiAoIWdsb2JhbFZlcnNpb25NYXRjaCkge1xuICAgICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gICAgfVxuICAgIHZhciBnbG9iYWxWZXJzaW9uUGFyc2VkID0ge1xuICAgICAgbWFqb3I6ICtnbG9iYWxWZXJzaW9uTWF0Y2hbMV0sXG4gICAgICBtaW5vcjogK2dsb2JhbFZlcnNpb25NYXRjaFsyXSxcbiAgICAgIHBhdGNoOiArZ2xvYmFsVmVyc2lvbk1hdGNoWzNdLFxuICAgICAgcHJlcmVsZWFzZTogZ2xvYmFsVmVyc2lvbk1hdGNoWzRdXG4gICAgfTtcbiAgICBpZiAoZ2xvYmFsVmVyc2lvblBhcnNlZC5wcmVyZWxlYXNlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBfcmVqZWN0KGdsb2JhbFZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAob3duVmVyc2lvblBhcnNlZC5tYWpvciAhPT0gZ2xvYmFsVmVyc2lvblBhcnNlZC5tYWpvcikge1xuICAgICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChvd25WZXJzaW9uUGFyc2VkLm1ham9yID09PSAwKSB7XG4gICAgICBpZiAob3duVmVyc2lvblBhcnNlZC5taW5vciA9PT0gZ2xvYmFsVmVyc2lvblBhcnNlZC5taW5vciAmJiBvd25WZXJzaW9uUGFyc2VkLnBhdGNoIDw9IGdsb2JhbFZlcnNpb25QYXJzZWQucGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIF9hY2NlcHQoZ2xvYmFsVmVyc2lvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlamVjdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKG93blZlcnNpb25QYXJzZWQubWlub3IgPD0gZ2xvYmFsVmVyc2lvblBhcnNlZC5taW5vcikge1xuICAgICAgcmV0dXJuIF9hY2NlcHQoZ2xvYmFsVmVyc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBfcmVqZWN0KGdsb2JhbFZlcnNpb24pO1xuICB9LCBcImlzQ29tcGF0aWJsZVwiKTtcbn1cbl9fbmFtZShfbWFrZUNvbXBhdGliaWxpdHlDaGVjaywgXCJfbWFrZUNvbXBhdGliaWxpdHlDaGVja1wiKTtcbnZhciBpc0NvbXBhdGlibGUgPSBfbWFrZUNvbXBhdGliaWxpdHlDaGVjayhWRVJTSU9OKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9pbnRlcm5hbC9nbG9iYWwtdXRpbHMuanNcbnZhciBtYWpvciA9IFZFUlNJT04uc3BsaXQoXCIuXCIpWzBdO1xudmFyIEdMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVkgPSBTeW1ib2wuZm9yKFwib3BlbnRlbGVtZXRyeS5qcy5hcGkuXCIgKyBtYWpvcik7XG52YXIgX2dsb2JhbCA9IF9nbG9iYWxUaGlzO1xuZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWwodHlwZSwgaW5zdGFuY2UsIGRpYWczLCBhbGxvd092ZXJyaWRlKSB7XG4gIHZhciBfYTM7XG4gIGlmIChhbGxvd092ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICBhbGxvd092ZXJyaWRlID0gZmFsc2U7XG4gIH1cbiAgdmFyIGFwaSA9IF9nbG9iYWxbR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWV0gPSAoX2EzID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXSkgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiB7XG4gICAgdmVyc2lvbjogVkVSU0lPTlxuICB9O1xuICBpZiAoIWFsbG93T3ZlcnJpZGUgJiYgYXBpW3R5cGVdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkBvcGVudGVsZW1ldHJ5L2FwaTogQXR0ZW1wdGVkIGR1cGxpY2F0ZSByZWdpc3RyYXRpb24gb2YgQVBJOiBcIiArIHR5cGUpO1xuICAgIGRpYWczLmVycm9yKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcGkudmVyc2lvbiAhPT0gVkVSU0lPTikge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJAb3BlbnRlbGVtZXRyeS9hcGk6IEFsbCBBUEkgcmVnaXN0cmF0aW9uIHZlcnNpb25zIG11c3QgbWF0Y2hcIik7XG4gICAgZGlhZzMuZXJyb3IoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBpW3R5cGVdID0gaW5zdGFuY2U7XG4gIGRpYWczLmRlYnVnKFwiQG9wZW50ZWxlbWV0cnkvYXBpOiBSZWdpc3RlcmVkIGEgZ2xvYmFsIGZvciBcIiArIHR5cGUgKyBcIiB2XCIgKyBWRVJTSU9OICsgXCIuXCIpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbl9fbmFtZShyZWdpc3Rlckdsb2JhbCwgXCJyZWdpc3Rlckdsb2JhbFwiKTtcbmZ1bmN0aW9uIGdldEdsb2JhbCh0eXBlKSB7XG4gIHZhciBfYTMsIF9iMjtcbiAgdmFyIGdsb2JhbFZlcnNpb24gPSAoX2EzID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXSkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMudmVyc2lvbjtcbiAgaWYgKCFnbG9iYWxWZXJzaW9uIHx8ICFpc0NvbXBhdGlibGUoZ2xvYmFsVmVyc2lvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIChfYjIgPSBfZ2xvYmFsW0dMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVldKSA9PT0gbnVsbCB8fCBfYjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iMlt0eXBlXTtcbn1cbl9fbmFtZShnZXRHbG9iYWwsIFwiZ2V0R2xvYmFsXCIpO1xuZnVuY3Rpb24gdW5yZWdpc3Rlckdsb2JhbCh0eXBlLCBkaWFnMykge1xuICBkaWFnMy5kZWJ1ZyhcIkBvcGVudGVsZW1ldHJ5L2FwaTogVW5yZWdpc3RlcmluZyBhIGdsb2JhbCBmb3IgXCIgKyB0eXBlICsgXCIgdlwiICsgVkVSU0lPTiArIFwiLlwiKTtcbiAgdmFyIGFwaSA9IF9nbG9iYWxbR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWV07XG4gIGlmIChhcGkpIHtcbiAgICBkZWxldGUgYXBpW3R5cGVdO1xuICB9XG59XG5fX25hbWUodW5yZWdpc3Rlckdsb2JhbCwgXCJ1bnJlZ2lzdGVyR2xvYmFsXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvQ29tcG9uZW50TG9nZ2VyLmpzXG52YXIgRGlhZ0NvbXBvbmVudExvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBEaWFnQ29tcG9uZW50TG9nZ2VyMihwcm9wcykge1xuICAgIHRoaXMuX25hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZSB8fCBcIkRpYWdDb21wb25lbnRMb2dnZXJcIjtcbiAgfVxuICBfX25hbWUoRGlhZ0NvbXBvbmVudExvZ2dlcjIsIFwiRGlhZ0NvbXBvbmVudExvZ2dlclwiKTtcbiAgRGlhZ0NvbXBvbmVudExvZ2dlcjIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbG9nUHJveHkoXCJkZWJ1Z1wiLCB0aGlzLl9uYW1lc3BhY2UsIGFyZ3MpO1xuICB9O1xuICBEaWFnQ29tcG9uZW50TG9nZ2VyMi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBsb2dQcm94eShcImVycm9yXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gIH07XG4gIERpYWdDb21wb25lbnRMb2dnZXIyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbG9nUHJveHkoXCJpbmZvXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gIH07XG4gIERpYWdDb21wb25lbnRMb2dnZXIyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbG9nUHJveHkoXCJ3YXJuXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gIH07XG4gIERpYWdDb21wb25lbnRMb2dnZXIyLnByb3RvdHlwZS52ZXJib3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbG9nUHJveHkoXCJ2ZXJib3NlXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gIH07XG4gIHJldHVybiBEaWFnQ29tcG9uZW50TG9nZ2VyMjtcbn0oKTtcbmZ1bmN0aW9uIGxvZ1Byb3h5KGZ1bmNOYW1lLCBuYW1lc3BhY2UsIGFyZ3MpIHtcbiAgdmFyIGxvZ2dlcjIgPSBnZXRHbG9iYWwoXCJkaWFnXCIpO1xuICBpZiAoIWxvZ2dlcjIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJncy51bnNoaWZ0KG5hbWVzcGFjZSk7XG4gIHJldHVybiBsb2dnZXIyW2Z1bmNOYW1lXS5hcHBseShsb2dnZXIyLCBhcmdzKTtcbn1cbl9fbmFtZShsb2dQcm94eSwgXCJsb2dQcm94eVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9kaWFnL3R5cGVzLmpzXG52YXIgRGlhZ0xvZ0xldmVsO1xuKGZ1bmN0aW9uKERpYWdMb2dMZXZlbDIpIHtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIkVSUk9SXCJdID0gMzBdID0gXCJFUlJPUlwiO1xuICBEaWFnTG9nTGV2ZWwyW0RpYWdMb2dMZXZlbDJbXCJXQVJOXCJdID0gNTBdID0gXCJXQVJOXCI7XG4gIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIklORk9cIl0gPSA2MF0gPSBcIklORk9cIjtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiREVCVUdcIl0gPSA3MF0gPSBcIkRFQlVHXCI7XG4gIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIlZFUkJPU0VcIl0gPSA4MF0gPSBcIlZFUkJPU0VcIjtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiQUxMXCJdID0gOTk5OV0gPSBcIkFMTFwiO1xufSkoRGlhZ0xvZ0xldmVsIHx8IChEaWFnTG9nTGV2ZWwgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvaW50ZXJuYWwvbG9nTGV2ZWxMb2dnZXIuanNcbmZ1bmN0aW9uIGNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcihtYXhMZXZlbCwgbG9nZ2VyMikge1xuICBpZiAobWF4TGV2ZWwgPCBEaWFnTG9nTGV2ZWwuTk9ORSkge1xuICAgIG1heExldmVsID0gRGlhZ0xvZ0xldmVsLk5PTkU7XG4gIH0gZWxzZSBpZiAobWF4TGV2ZWwgPiBEaWFnTG9nTGV2ZWwuQUxMKSB7XG4gICAgbWF4TGV2ZWwgPSBEaWFnTG9nTGV2ZWwuQUxMO1xuICB9XG4gIGxvZ2dlcjIgPSBsb2dnZXIyIHx8IHt9O1xuICBmdW5jdGlvbiBfZmlsdGVyRnVuYyhmdW5jTmFtZSwgdGhlTGV2ZWwpIHtcbiAgICB2YXIgdGhlRnVuYyA9IGxvZ2dlcjJbZnVuY05hbWVdO1xuICAgIGlmICh0eXBlb2YgdGhlRnVuYyA9PT0gXCJmdW5jdGlvblwiICYmIG1heExldmVsID49IHRoZUxldmVsKSB7XG4gICAgICByZXR1cm4gdGhlRnVuYy5iaW5kKGxvZ2dlcjIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgfVxuICBfX25hbWUoX2ZpbHRlckZ1bmMsIFwiX2ZpbHRlckZ1bmNcIik7XG4gIHJldHVybiB7XG4gICAgZXJyb3I6IF9maWx0ZXJGdW5jKFwiZXJyb3JcIiwgRGlhZ0xvZ0xldmVsLkVSUk9SKSxcbiAgICB3YXJuOiBfZmlsdGVyRnVuYyhcIndhcm5cIiwgRGlhZ0xvZ0xldmVsLldBUk4pLFxuICAgIGluZm86IF9maWx0ZXJGdW5jKFwiaW5mb1wiLCBEaWFnTG9nTGV2ZWwuSU5GTyksXG4gICAgZGVidWc6IF9maWx0ZXJGdW5jKFwiZGVidWdcIiwgRGlhZ0xvZ0xldmVsLkRFQlVHKSxcbiAgICB2ZXJib3NlOiBfZmlsdGVyRnVuYyhcInZlcmJvc2VcIiwgRGlhZ0xvZ0xldmVsLlZFUkJPU0UpXG4gIH07XG59XG5fX25hbWUoY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyLCBcImNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlclwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvZGlhZy5qc1xudmFyIEFQSV9OQU1FID0gXCJkaWFnXCI7XG52YXIgRGlhZ0FQSSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBEaWFnQVBJMigpIHtcbiAgICBmdW5jdGlvbiBfbG9nUHJveHkoZnVuY05hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ2dlcjIgPSBnZXRHbG9iYWwoXCJkaWFnXCIpO1xuICAgICAgICBpZiAoIWxvZ2dlcjIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gbG9nZ2VyMltmdW5jTmFtZV0uYXBwbHkobG9nZ2VyMiwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoX2xvZ1Byb3h5LCBcIl9sb2dQcm94eVwiKTtcbiAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgIHNlbGYyLnNldExvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlcjIsIGxvZ0xldmVsKSB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICBpZiAobG9nTGV2ZWwgPT09IHZvaWQgMCkge1xuICAgICAgICBsb2dMZXZlbCA9IERpYWdMb2dMZXZlbC5JTkZPO1xuICAgICAgfVxuICAgICAgaWYgKGxvZ2dlcjIgPT09IHNlbGYyKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGRpYWcgYXMgdGhlIGxvZ2dlciBmb3IgaXRzZWxmLiBQbGVhc2UgdXNlIGEgRGlhZ0xvZ2dlciBpbXBsZW1lbnRhdGlvbiBsaWtlIENvbnNvbGVEaWFnTG9nZ2VyIG9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICBzZWxmMi5lcnJvcigoX2EzID0gZXJyLnN0YWNrKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IGVyci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9sZExvZ2dlciA9IGdldEdsb2JhbChcImRpYWdcIik7XG4gICAgICB2YXIgbmV3TG9nZ2VyID0gY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyKGxvZ0xldmVsLCBsb2dnZXIyKTtcbiAgICAgIGlmIChvbGRMb2dnZXIpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gKF9iMiA9IG5ldyBFcnJvcigpLnN0YWNrKSAhPT0gbnVsbCAmJiBfYjIgIT09IHZvaWQgMCA/IF9iMiA6IFwiPGZhaWxlZCB0byBnZW5lcmF0ZSBzdGFja3RyYWNlPlwiO1xuICAgICAgICBvbGRMb2dnZXIud2FybihcIkN1cnJlbnQgbG9nZ2VyIHdpbGwgYmUgb3ZlcndyaXR0ZW4gZnJvbSBcIiArIHN0YWNrKTtcbiAgICAgICAgbmV3TG9nZ2VyLndhcm4oXCJDdXJyZW50IGxvZ2dlciB3aWxsIG92ZXJ3cml0ZSBvbmUgYWxyZWFkeSByZWdpc3RlcmVkIGZyb20gXCIgKyBzdGFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoXCJkaWFnXCIsIG5ld0xvZ2dlciwgc2VsZjIsIHRydWUpO1xuICAgIH07XG4gICAgc2VsZjIuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdW5yZWdpc3Rlckdsb2JhbChBUElfTkFNRSwgc2VsZjIpO1xuICAgIH07XG4gICAgc2VsZjIuY3JlYXRlQ29tcG9uZW50TG9nZ2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBEaWFnQ29tcG9uZW50TG9nZ2VyKG9wdGlvbnMpO1xuICAgIH07XG4gICAgc2VsZjIudmVyYm9zZSA9IF9sb2dQcm94eShcInZlcmJvc2VcIik7XG4gICAgc2VsZjIuZGVidWcgPSBfbG9nUHJveHkoXCJkZWJ1Z1wiKTtcbiAgICBzZWxmMi5pbmZvID0gX2xvZ1Byb3h5KFwiaW5mb1wiKTtcbiAgICBzZWxmMi53YXJuID0gX2xvZ1Byb3h5KFwid2FyblwiKTtcbiAgICBzZWxmMi5lcnJvciA9IF9sb2dQcm94eShcImVycm9yXCIpO1xuICB9XG4gIF9fbmFtZShEaWFnQVBJMiwgXCJEaWFnQVBJXCIpO1xuICBEaWFnQVBJMi5pbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IERpYWdBUEkyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfTtcbiAgcmV0dXJuIERpYWdBUEkyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvaW50ZXJuYWwvYmFnZ2FnZS1pbXBsLmpzXG52YXIgQmFnZ2FnZUltcGwgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmFnZ2FnZUltcGwyKGVudHJpZXMpIHtcbiAgICB0aGlzLl9lbnRyaWVzID0gZW50cmllcyA/IG5ldyBNYXAoZW50cmllcykgOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIF9fbmFtZShCYWdnYWdlSW1wbDIsIFwiQmFnZ2FnZUltcGxcIik7XG4gIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUuZ2V0RW50cnkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLl9lbnRyaWVzLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlbnRyeSk7XG4gIH07XG4gIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUuZ2V0QWxsRW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2VudHJpZXMuZW50cmllcygpKS5tYXAoZnVuY3Rpb24oX2EzKSB7XG4gICAgICB2YXIgayA9IF9hM1swXSwgdiA9IF9hM1sxXTtcbiAgICAgIHJldHVybiBbaywgdl07XG4gICAgfSk7XG4gIH07XG4gIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUuc2V0RW50cnkgPSBmdW5jdGlvbihrZXksIGVudHJ5KSB7XG4gICAgdmFyIG5ld0JhZ2dhZ2UgPSBuZXcgQmFnZ2FnZUltcGwyKHRoaXMuX2VudHJpZXMpO1xuICAgIG5ld0JhZ2dhZ2UuX2VudHJpZXMuc2V0KGtleSwgZW50cnkpO1xuICAgIHJldHVybiBuZXdCYWdnYWdlO1xuICB9O1xuICBCYWdnYWdlSW1wbDIucHJvdG90eXBlLnJlbW92ZUVudHJ5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIG5ld0JhZ2dhZ2UgPSBuZXcgQmFnZ2FnZUltcGwyKHRoaXMuX2VudHJpZXMpO1xuICAgIG5ld0JhZ2dhZ2UuX2VudHJpZXMuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIG5ld0JhZ2dhZ2U7XG4gIH07XG4gIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUucmVtb3ZlRW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlzMiA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBrZXlzMltfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbmV3QmFnZ2FnZSA9IG5ldyBCYWdnYWdlSW1wbDIodGhpcy5fZW50cmllcyk7XG4gICAgZm9yICh2YXIgX2EzID0gMCwga2V5c18xID0ga2V5czI7IF9hMyA8IGtleXNfMS5sZW5ndGg7IF9hMysrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c18xW19hM107XG4gICAgICBuZXdCYWdnYWdlLl9lbnRyaWVzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QmFnZ2FnZTtcbiAgfTtcbiAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQmFnZ2FnZUltcGwyKCk7XG4gIH07XG4gIHJldHVybiBCYWdnYWdlSW1wbDI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS9pbnRlcm5hbC9zeW1ib2wuanNcbnZhciBiYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbCA9IFN5bWJvbChcIkJhZ2dhZ2VFbnRyeU1ldGFkYXRhXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvdXRpbHMuanNcbnZhciBkaWFnID0gRGlhZ0FQSS5pbnN0YW5jZSgpO1xuZnVuY3Rpb24gY3JlYXRlQmFnZ2FnZShlbnRyaWVzKSB7XG4gIGlmIChlbnRyaWVzID09PSB2b2lkIDApIHtcbiAgICBlbnRyaWVzID0ge307XG4gIH1cbiAgcmV0dXJuIG5ldyBCYWdnYWdlSW1wbChuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGVudHJpZXMpKSk7XG59XG5fX25hbWUoY3JlYXRlQmFnZ2FnZSwgXCJjcmVhdGVCYWdnYWdlXCIpO1xuZnVuY3Rpb24gYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIGRpYWcuZXJyb3IoXCJDYW5ub3QgY3JlYXRlIGJhZ2dhZ2UgbWV0YWRhdGEgZnJvbSB1bmtub3duIHR5cGU6IFwiICsgdHlwZW9mIHN0cik7XG4gICAgc3RyID0gXCJcIjtcbiAgfVxuICByZXR1cm4ge1xuICAgIF9fVFlQRV9fOiBiYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbCxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbn1cbl9fbmFtZShiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcsIFwiYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvY29uc29sZUxvZ2dlci5qc1xudmFyIGNvbnNvbGVNYXAgPSBbXG4gIHsgbjogXCJlcnJvclwiLCBjOiBcImVycm9yXCIgfSxcbiAgeyBuOiBcIndhcm5cIiwgYzogXCJ3YXJuXCIgfSxcbiAgeyBuOiBcImluZm9cIiwgYzogXCJpbmZvXCIgfSxcbiAgeyBuOiBcImRlYnVnXCIsIGM6IFwiZGVidWdcIiB9LFxuICB7IG46IFwidmVyYm9zZVwiLCBjOiBcInRyYWNlXCIgfVxuXTtcbnZhciBEaWFnQ29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBEaWFnQ29uc29sZUxvZ2dlcjIoKSB7XG4gICAgZnVuY3Rpb24gX2NvbnNvbGVGdW5jKGZ1bmNOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgICAgdmFyIHRoZUZ1bmMgPSBjb25zb2xlW2Z1bmNOYW1lXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZUZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhlRnVuYyA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHRoZUZ1bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoZUZ1bmMuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoX2NvbnNvbGVGdW5jLCBcIl9jb25zb2xlRnVuY1wiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnNvbGVNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbY29uc29sZU1hcFtpXS5uXSA9IF9jb25zb2xlRnVuYyhjb25zb2xlTWFwW2ldLmMpO1xuICAgIH1cbiAgfVxuICBfX25hbWUoRGlhZ0NvbnNvbGVMb2dnZXIyLCBcIkRpYWdDb25zb2xlTG9nZ2VyXCIpO1xuICByZXR1cm4gRGlhZ0NvbnNvbGVMb2dnZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3Byb3BhZ2F0aW9uL1RleHRNYXBQcm9wYWdhdG9yLmpzXG52YXIgZGVmYXVsdFRleHRNYXBHZXR0ZXIgPSB7XG4gIGdldDogZnVuY3Rpb24oY2Fycmllciwga2V5KSB7XG4gICAgaWYgKGNhcnJpZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGNhcnJpZXJba2V5XTtcbiAgfSxcbiAga2V5czogZnVuY3Rpb24oY2Fycmllcikge1xuICAgIGlmIChjYXJyaWVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNhcnJpZXIpO1xuICB9XG59O1xudmFyIGRlZmF1bHRUZXh0TWFwU2V0dGVyID0ge1xuICBzZXQ6IGZ1bmN0aW9uKGNhcnJpZXIsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoY2FycmllciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhcnJpZXJba2V5XSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2NvbnRleHQvY29udGV4dC5qc1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dEtleShkZXNjcmlwdGlvbikge1xuICByZXR1cm4gU3ltYm9sLmZvcihkZXNjcmlwdGlvbik7XG59XG5fX25hbWUoY3JlYXRlQ29udGV4dEtleSwgXCJjcmVhdGVDb250ZXh0S2V5XCIpO1xudmFyIEJhc2VDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJhc2VDb250ZXh0MihwYXJlbnRDb250ZXh0KSB7XG4gICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICBzZWxmMi5fY3VycmVudENvbnRleHQgPSBwYXJlbnRDb250ZXh0ID8gbmV3IE1hcChwYXJlbnRDb250ZXh0KSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc2VsZjIuZ2V0VmFsdWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBzZWxmMi5fY3VycmVudENvbnRleHQuZ2V0KGtleSk7XG4gICAgfTtcbiAgICBzZWxmMi5zZXRWYWx1ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBjb250ZXh0MyA9IG5ldyBCYXNlQ29udGV4dDIoc2VsZjIuX2N1cnJlbnRDb250ZXh0KTtcbiAgICAgIGNvbnRleHQzLl9jdXJyZW50Q29udGV4dC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gY29udGV4dDM7XG4gICAgfTtcbiAgICBzZWxmMi5kZWxldGVWYWx1ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNvbnRleHQzID0gbmV3IEJhc2VDb250ZXh0MihzZWxmMi5fY3VycmVudENvbnRleHQpO1xuICAgICAgY29udGV4dDMuX2N1cnJlbnRDb250ZXh0LmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIH07XG4gIH1cbiAgX19uYW1lKEJhc2VDb250ZXh0MiwgXCJCYXNlQ29udGV4dFwiKTtcbiAgcmV0dXJuIEJhc2VDb250ZXh0Mjtcbn0oKTtcbnZhciBST09UX0NPTlRFWFQgPSBuZXcgQmFzZUNvbnRleHQoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9jb250ZXh0L05vb3BDb250ZXh0TWFuYWdlci5qc1xudmFyIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbih0bywgZnJvbSkge1xuICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICB0b1tqXSA9IGZyb21baV07XG4gIHJldHVybiB0bztcbn07XG52YXIgTm9vcENvbnRleHRNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE5vb3BDb250ZXh0TWFuYWdlcjIoKSB7XG4gIH1cbiAgX19uYW1lKE5vb3BDb250ZXh0TWFuYWdlcjIsIFwiTm9vcENvbnRleHRNYW5hZ2VyXCIpO1xuICBOb29wQ29udGV4dE1hbmFnZXIyLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUk9PVF9DT05URVhUO1xuICB9O1xuICBOb29wQ29udGV4dE1hbmFnZXIyLnByb3RvdHlwZS53aXRoID0gZnVuY3Rpb24oX2NvbnRleHQsIGZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmNhbGwuYXBwbHkoZm4sIF9fc3ByZWFkQXJyYXkoW3RoaXNBcmddLCBhcmdzKSk7XG4gIH07XG4gIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihfY29udGV4dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgTm9vcENvbnRleHRNYW5hZ2VyMi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcmV0dXJuIE5vb3BDb250ZXh0TWFuYWdlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL2NvbnRleHQuanNcbnZhciBfX3NwcmVhZEFycmF5MiA9IGZ1bmN0aW9uKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgcmV0dXJuIHRvO1xufTtcbnZhciBBUElfTkFNRTIgPSBcImNvbnRleHRcIjtcbnZhciBOT09QX0NPTlRFWFRfTUFOQUdFUiA9IG5ldyBOb29wQ29udGV4dE1hbmFnZXIoKTtcbnZhciBDb250ZXh0QVBJID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENvbnRleHRBUEkyKCkge1xuICB9XG4gIF9fbmFtZShDb250ZXh0QVBJMiwgXCJDb250ZXh0QVBJXCIpO1xuICBDb250ZXh0QVBJMi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IENvbnRleHRBUEkyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfTtcbiAgQ29udGV4dEFQSTIucHJvdG90eXBlLnNldEdsb2JhbENvbnRleHRNYW5hZ2VyID0gZnVuY3Rpb24oY29udGV4dE1hbmFnZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUyLCBjb250ZXh0TWFuYWdlciwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgfTtcbiAgQ29udGV4dEFQSTIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmFjdGl2ZSgpO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUud2l0aCA9IGZ1bmN0aW9uKGNvbnRleHQzLCBmbiwgdGhpc0FyZykge1xuICAgIHZhciBfYTM7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpKS53aXRoLmFwcGx5KF9hMywgX19zcHJlYWRBcnJheTIoW2NvbnRleHQzLCBmbiwgdGhpc0FyZ10sIGFyZ3MpKTtcbiAgfTtcbiAgQ29udGV4dEFQSTIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihjb250ZXh0MywgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYmluZChjb250ZXh0MywgdGFyZ2V0KTtcbiAgfTtcbiAgQ29udGV4dEFQSTIucHJvdG90eXBlLl9nZXRDb250ZXh0TWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWwoQVBJX05BTUUyKSB8fCBOT09QX0NPTlRFWFRfTUFOQUdFUjtcbiAgfTtcbiAgQ29udGV4dEFQSTIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmRpc2FibGUoKTtcbiAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FMiwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgfTtcbiAgcmV0dXJuIENvbnRleHRBUEkyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3RyYWNlX2ZsYWdzLmpzXG52YXIgVHJhY2VGbGFncztcbihmdW5jdGlvbihUcmFjZUZsYWdzMikge1xuICBUcmFjZUZsYWdzMltUcmFjZUZsYWdzMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBUcmFjZUZsYWdzMltUcmFjZUZsYWdzMltcIlNBTVBMRURcIl0gPSAxXSA9IFwiU0FNUExFRFwiO1xufSkoVHJhY2VGbGFncyB8fCAoVHJhY2VGbGFncyA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW52YWxpZC1zcGFuLWNvbnN0YW50cy5qc1xudmFyIElOVkFMSURfU1BBTklEID0gXCIwMDAwMDAwMDAwMDAwMDAwXCI7XG52YXIgSU5WQUxJRF9UUkFDRUlEID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xudmFyIElOVkFMSURfU1BBTl9DT05URVhUID0ge1xuICB0cmFjZUlkOiBJTlZBTElEX1RSQUNFSUQsXG4gIHNwYW5JZDogSU5WQUxJRF9TUEFOSUQsXG4gIHRyYWNlRmxhZ3M6IFRyYWNlRmxhZ3MuTk9ORVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9Ob25SZWNvcmRpbmdTcGFuLmpzXG52YXIgTm9uUmVjb3JkaW5nU3BhbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBOb25SZWNvcmRpbmdTcGFuMihfc3BhbkNvbnRleHQpIHtcbiAgICBpZiAoX3NwYW5Db250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIF9zcGFuQ29udGV4dCA9IElOVkFMSURfU1BBTl9DT05URVhUO1xuICAgIH1cbiAgICB0aGlzLl9zcGFuQ29udGV4dCA9IF9zcGFuQ29udGV4dDtcbiAgfVxuICBfX25hbWUoTm9uUmVjb3JkaW5nU3BhbjIsIFwiTm9uUmVjb3JkaW5nU3BhblwiKTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnNwYW5Db250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwYW5Db250ZXh0O1xuICB9O1xuICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oX2tleSwgX3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oX2F0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24oX25hbWUsIF9hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbihfc3RhdHVzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS51cGRhdGVOYW1lID0gZnVuY3Rpb24oX25hbWUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKF9lbmRUaW1lKSB7XG4gIH07XG4gIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5pc1JlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnJlY29yZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKF9leGNlcHRpb24sIF90aW1lKSB7XG4gIH07XG4gIHJldHVybiBOb25SZWNvcmRpbmdTcGFuMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9jb250ZXh0LXV0aWxzLmpzXG52YXIgU1BBTl9LRVkgPSBjcmVhdGVDb250ZXh0S2V5KFwiT3BlblRlbGVtZXRyeSBDb250ZXh0IEtleSBTUEFOXCIpO1xuZnVuY3Rpb24gZ2V0U3Bhbihjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuZ2V0VmFsdWUoU1BBTl9LRVkpIHx8IHZvaWQgMDtcbn1cbl9fbmFtZShnZXRTcGFuLCBcImdldFNwYW5cIik7XG5mdW5jdGlvbiBzZXRTcGFuKGNvbnRleHQzLCBzcGFuKSB7XG4gIHJldHVybiBjb250ZXh0My5zZXRWYWx1ZShTUEFOX0tFWSwgc3Bhbik7XG59XG5fX25hbWUoc2V0U3BhbiwgXCJzZXRTcGFuXCIpO1xuZnVuY3Rpb24gZGVsZXRlU3Bhbihjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuZGVsZXRlVmFsdWUoU1BBTl9LRVkpO1xufVxuX19uYW1lKGRlbGV0ZVNwYW4sIFwiZGVsZXRlU3BhblwiKTtcbmZ1bmN0aW9uIHNldFNwYW5Db250ZXh0KGNvbnRleHQzLCBzcGFuQ29udGV4dCkge1xuICByZXR1cm4gc2V0U3Bhbihjb250ZXh0MywgbmV3IE5vblJlY29yZGluZ1NwYW4oc3BhbkNvbnRleHQpKTtcbn1cbl9fbmFtZShzZXRTcGFuQ29udGV4dCwgXCJzZXRTcGFuQ29udGV4dFwiKTtcbmZ1bmN0aW9uIGdldFNwYW5Db250ZXh0KGNvbnRleHQzKSB7XG4gIHZhciBfYTM7XG4gIHJldHVybiAoX2EzID0gZ2V0U3Bhbihjb250ZXh0MykpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzLnNwYW5Db250ZXh0KCk7XG59XG5fX25hbWUoZ2V0U3BhbkNvbnRleHQsIFwiZ2V0U3BhbkNvbnRleHRcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2Uvc3BhbmNvbnRleHQtdXRpbHMuanNcbnZhciBWQUxJRF9UUkFDRUlEX1JFR0VYID0gL14oWzAtOWEtZl17MzJ9KSQvaTtcbnZhciBWQUxJRF9TUEFOSURfUkVHRVggPSAvXlswLTlhLWZdezE2fSQvaTtcbmZ1bmN0aW9uIGlzVmFsaWRUcmFjZUlkKHRyYWNlSWQpIHtcbiAgcmV0dXJuIFZBTElEX1RSQUNFSURfUkVHRVgudGVzdCh0cmFjZUlkKSAmJiB0cmFjZUlkICE9PSBJTlZBTElEX1RSQUNFSUQ7XG59XG5fX25hbWUoaXNWYWxpZFRyYWNlSWQsIFwiaXNWYWxpZFRyYWNlSWRcIik7XG5mdW5jdGlvbiBpc1ZhbGlkU3BhbklkKHNwYW5JZCkge1xuICByZXR1cm4gVkFMSURfU1BBTklEX1JFR0VYLnRlc3Qoc3BhbklkKSAmJiBzcGFuSWQgIT09IElOVkFMSURfU1BBTklEO1xufVxuX19uYW1lKGlzVmFsaWRTcGFuSWQsIFwiaXNWYWxpZFNwYW5JZFwiKTtcbmZ1bmN0aW9uIGlzU3BhbkNvbnRleHRWYWxpZChzcGFuQ29udGV4dCkge1xuICByZXR1cm4gaXNWYWxpZFRyYWNlSWQoc3BhbkNvbnRleHQudHJhY2VJZCkgJiYgaXNWYWxpZFNwYW5JZChzcGFuQ29udGV4dC5zcGFuSWQpO1xufVxuX19uYW1lKGlzU3BhbkNvbnRleHRWYWxpZCwgXCJpc1NwYW5Db250ZXh0VmFsaWRcIik7XG5mdW5jdGlvbiB3cmFwU3BhbkNvbnRleHQoc3BhbkNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKHNwYW5Db250ZXh0KTtcbn1cbl9fbmFtZSh3cmFwU3BhbkNvbnRleHQsIFwid3JhcFNwYW5Db250ZXh0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vb3BUcmFjZXIuanNcbnZhciBjb250ZXh0ID0gQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpO1xudmFyIE5vb3BUcmFjZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTm9vcFRyYWNlcjIoKSB7XG4gIH1cbiAgX19uYW1lKE5vb3BUcmFjZXIyLCBcIk5vb3BUcmFjZXJcIik7XG4gIE5vb3BUcmFjZXIyLnByb3RvdHlwZS5zdGFydFNwYW4gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zLCBjb250ZXh0Mykge1xuICAgIHZhciByb290ID0gQm9vbGVhbihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm9vdCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJldHVybiBuZXcgTm9uUmVjb3JkaW5nU3BhbigpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50RnJvbUNvbnRleHQgPSBjb250ZXh0MyAmJiBnZXRTcGFuQ29udGV4dChjb250ZXh0Myk7XG4gICAgaWYgKGlzU3BhbkNvbnRleHQocGFyZW50RnJvbUNvbnRleHQpICYmIGlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRGcm9tQ29udGV4dCkpIHtcbiAgICAgIHJldHVybiBuZXcgTm9uUmVjb3JkaW5nU3BhbihwYXJlbnRGcm9tQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgTm9uUmVjb3JkaW5nU3BhbigpO1xuICAgIH1cbiAgfTtcbiAgTm9vcFRyYWNlcjIucHJvdG90eXBlLnN0YXJ0QWN0aXZlU3BhbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICB2YXIgb3B0cztcbiAgICB2YXIgY3R4O1xuICAgIHZhciBmbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGZuID0gYXJnMjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIG9wdHMgPSBhcmcyO1xuICAgICAgZm4gPSBhcmczO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0gYXJnMjtcbiAgICAgIGN0eCA9IGFyZzM7XG4gICAgICBmbiA9IGFyZzQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnRDb250ZXh0ID0gY3R4ICE9PSBudWxsICYmIGN0eCAhPT0gdm9pZCAwID8gY3R4IDogY29udGV4dC5hY3RpdmUoKTtcbiAgICB2YXIgc3BhbiA9IHRoaXMuc3RhcnRTcGFuKG5hbWUsIG9wdHMsIHBhcmVudENvbnRleHQpO1xuICAgIHZhciBjb250ZXh0V2l0aFNwYW5TZXQgPSBzZXRTcGFuKHBhcmVudENvbnRleHQsIHNwYW4pO1xuICAgIHJldHVybiBjb250ZXh0LndpdGgoY29udGV4dFdpdGhTcGFuU2V0LCBmbiwgdm9pZCAwLCBzcGFuKTtcbiAgfTtcbiAgcmV0dXJuIE5vb3BUcmFjZXIyO1xufSgpO1xuZnVuY3Rpb24gaXNTcGFuQ29udGV4dChzcGFuQ29udGV4dCkge1xuICByZXR1cm4gdHlwZW9mIHNwYW5Db250ZXh0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzcGFuQ29udGV4dFtcInNwYW5JZFwiXSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc3BhbkNvbnRleHRbXCJ0cmFjZUlkXCJdID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzcGFuQ29udGV4dFtcInRyYWNlRmxhZ3NcIl0gPT09IFwibnVtYmVyXCI7XG59XG5fX25hbWUoaXNTcGFuQ29udGV4dCwgXCJpc1NwYW5Db250ZXh0XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL1Byb3h5VHJhY2VyLmpzXG52YXIgTk9PUF9UUkFDRVIgPSBuZXcgTm9vcFRyYWNlcigpO1xudmFyIFByb3h5VHJhY2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFByb3h5VHJhY2VyMihfcHJvdmlkZXIsIG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9wcm92aWRlciA9IF9wcm92aWRlcjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfX25hbWUoUHJveHlUcmFjZXIyLCBcIlByb3h5VHJhY2VyXCIpO1xuICBQcm94eVRyYWNlcjIucHJvdG90eXBlLnN0YXJ0U3BhbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRyYWNlcigpLnN0YXJ0U3BhbihuYW1lLCBvcHRpb25zLCBjb250ZXh0Myk7XG4gIH07XG4gIFByb3h5VHJhY2VyMi5wcm90b3R5cGUuc3RhcnRBY3RpdmVTcGFuID0gZnVuY3Rpb24oX25hbWUsIF9vcHRpb25zLCBfY29udGV4dCwgX2ZuKSB7XG4gICAgdmFyIHRyYWNlciA9IHRoaXMuX2dldFRyYWNlcigpO1xuICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRyYWNlci5zdGFydEFjdGl2ZVNwYW4sIHRyYWNlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgUHJveHlUcmFjZXIyLnByb3RvdHlwZS5fZ2V0VHJhY2VyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGU7XG4gICAgfVxuICAgIHZhciB0cmFjZXIgPSB0aGlzLl9wcm92aWRlci5nZXREZWxlZ2F0ZVRyYWNlcih0aGlzLm5hbWUsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAoIXRyYWNlcikge1xuICAgICAgcmV0dXJuIE5PT1BfVFJBQ0VSO1xuICAgIH1cbiAgICB0aGlzLl9kZWxlZ2F0ZSA9IHRyYWNlcjtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGU7XG4gIH07XG4gIHJldHVybiBQcm94eVRyYWNlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvTm9vcFRyYWNlclByb3ZpZGVyLmpzXG52YXIgTm9vcFRyYWNlclByb3ZpZGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE5vb3BUcmFjZXJQcm92aWRlcjIoKSB7XG4gIH1cbiAgX19uYW1lKE5vb3BUcmFjZXJQcm92aWRlcjIsIFwiTm9vcFRyYWNlclByb3ZpZGVyXCIpO1xuICBOb29wVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXRUcmFjZXIgPSBmdW5jdGlvbihfbmFtZSwgX3ZlcnNpb24sIF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBOb29wVHJhY2VyKCk7XG4gIH07XG4gIHJldHVybiBOb29wVHJhY2VyUHJvdmlkZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL1Byb3h5VHJhY2VyUHJvdmlkZXIuanNcbnZhciBOT09QX1RSQUNFUl9QUk9WSURFUiA9IG5ldyBOb29wVHJhY2VyUHJvdmlkZXIoKTtcbnZhciBQcm94eVRyYWNlclByb3ZpZGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFByb3h5VHJhY2VyUHJvdmlkZXIyKCkge1xuICB9XG4gIF9fbmFtZShQcm94eVRyYWNlclByb3ZpZGVyMiwgXCJQcm94eVRyYWNlclByb3ZpZGVyXCIpO1xuICBQcm94eVRyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuZ2V0VHJhY2VyID0gZnVuY3Rpb24obmFtZSwgdmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLmdldERlbGVnYXRlVHJhY2VyKG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IG5ldyBQcm94eVRyYWNlcih0aGlzLCBuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgfTtcbiAgUHJveHlUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldERlbGVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9hMztcbiAgICByZXR1cm4gKF9hMyA9IHRoaXMuX2RlbGVnYXRlKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IE5PT1BfVFJBQ0VSX1BST1ZJREVSO1xuICB9O1xuICBQcm94eVRyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuc2V0RGVsZWdhdGUgPSBmdW5jdGlvbihkZWxlZ2F0ZSkge1xuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG4gIH07XG4gIFByb3h5VHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXREZWxlZ2F0ZVRyYWNlciA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiAoX2EzID0gdGhpcy5fZGVsZWdhdGUpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIFByb3h5VHJhY2VyUHJvdmlkZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL1NhbXBsaW5nUmVzdWx0LmpzXG52YXIgU2FtcGxpbmdEZWNpc2lvbjtcbihmdW5jdGlvbihTYW1wbGluZ0RlY2lzaW9uMykge1xuICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIk5PVF9SRUNPUkRcIl0gPSAwXSA9IFwiTk9UX1JFQ09SRFwiO1xuICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIlJFQ09SRFwiXSA9IDFdID0gXCJSRUNPUkRcIjtcbiAgU2FtcGxpbmdEZWNpc2lvbjNbU2FtcGxpbmdEZWNpc2lvbjNbXCJSRUNPUkRfQU5EX1NBTVBMRURcIl0gPSAyXSA9IFwiUkVDT1JEX0FORF9TQU1QTEVEXCI7XG59KShTYW1wbGluZ0RlY2lzaW9uIHx8IChTYW1wbGluZ0RlY2lzaW9uID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9zcGFuX2tpbmQuanNcbnZhciBTcGFuS2luZDtcbihmdW5jdGlvbihTcGFuS2luZDIpIHtcbiAgU3BhbktpbmQyW1NwYW5LaW5kMltcIklOVEVSTkFMXCJdID0gMF0gPSBcIklOVEVSTkFMXCI7XG4gIFNwYW5LaW5kMltTcGFuS2luZDJbXCJTRVJWRVJcIl0gPSAxXSA9IFwiU0VSVkVSXCI7XG4gIFNwYW5LaW5kMltTcGFuS2luZDJbXCJDTElFTlRcIl0gPSAyXSA9IFwiQ0xJRU5UXCI7XG4gIFNwYW5LaW5kMltTcGFuS2luZDJbXCJQUk9EVUNFUlwiXSA9IDNdID0gXCJQUk9EVUNFUlwiO1xuICBTcGFuS2luZDJbU3BhbktpbmQyW1wiQ09OU1VNRVJcIl0gPSA0XSA9IFwiQ09OU1VNRVJcIjtcbn0pKFNwYW5LaW5kIHx8IChTcGFuS2luZCA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2Uvc3RhdHVzLmpzXG52YXIgU3BhblN0YXR1c0NvZGU7XG4oZnVuY3Rpb24oU3BhblN0YXR1c0NvZGUyKSB7XG4gIFNwYW5TdGF0dXNDb2RlMltTcGFuU3RhdHVzQ29kZTJbXCJVTlNFVFwiXSA9IDBdID0gXCJVTlNFVFwiO1xuICBTcGFuU3RhdHVzQ29kZTJbU3BhblN0YXR1c0NvZGUyW1wiT0tcIl0gPSAxXSA9IFwiT0tcIjtcbiAgU3BhblN0YXR1c0NvZGUyW1NwYW5TdGF0dXNDb2RlMltcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG59KShTcGFuU3RhdHVzQ29kZSB8fCAoU3BhblN0YXR1c0NvZGUgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL2ludGVybmFsL3RyYWNlc3RhdGUtdmFsaWRhdG9ycy5qc1xudmFyIFZBTElEX0tFWV9DSEFSX1JBTkdFID0gXCJbXzAtOWEtei0qL11cIjtcbnZhciBWQUxJRF9LRVkgPSBcIlthLXpdXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRSArIFwiezAsMjU1fVwiO1xudmFyIFZBTElEX1ZFTkRPUl9LRVkgPSBcIlthLXowLTldXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRSArIFwiezAsMjQwfUBbYS16XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UgKyBcInswLDEzfVwiO1xudmFyIFZBTElEX0tFWV9SRUdFWCA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBWQUxJRF9LRVkgKyBcInxcIiArIFZBTElEX1ZFTkRPUl9LRVkgKyBcIikkXCIpO1xudmFyIFZBTElEX1ZBTFVFX0JBU0VfUkVHRVggPSAvXlsgLX5dezAsMjU1fVshLX5dJC87XG52YXIgSU5WQUxJRF9WQUxVRV9DT01NQV9FUVVBTF9SRUdFWCA9IC8sfD0vO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBWQUxJRF9LRVlfUkVHRVgudGVzdChrZXkpO1xufVxuX19uYW1lKHZhbGlkYXRlS2V5LCBcInZhbGlkYXRlS2V5XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gVkFMSURfVkFMVUVfQkFTRV9SRUdFWC50ZXN0KHZhbHVlKSAmJiAhSU5WQUxJRF9WQUxVRV9DT01NQV9FUVVBTF9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbl9fbmFtZSh2YWxpZGF0ZVZhbHVlLCBcInZhbGlkYXRlVmFsdWVcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW50ZXJuYWwvdHJhY2VzdGF0ZS1pbXBsLmpzXG52YXIgTUFYX1RSQUNFX1NUQVRFX0lURU1TID0gMzI7XG52YXIgTUFYX1RSQUNFX1NUQVRFX0xFTiA9IDUxMjtcbnZhciBMSVNUX01FTUJFUlNfU0VQQVJBVE9SID0gXCIsXCI7XG52YXIgTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSID0gXCI9XCI7XG52YXIgVHJhY2VTdGF0ZUltcGwgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVHJhY2VTdGF0ZUltcGwyKHJhd1RyYWNlU3RhdGUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAocmF3VHJhY2VTdGF0ZSlcbiAgICAgIHRoaXMuX3BhcnNlKHJhd1RyYWNlU3RhdGUpO1xuICB9XG4gIF9fbmFtZShUcmFjZVN0YXRlSW1wbDIsIFwiVHJhY2VTdGF0ZUltcGxcIik7XG4gIFRyYWNlU3RhdGVJbXBsMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICBpZiAodHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5oYXMoa2V5KSkge1xuICAgICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gIH07XG4gIFRyYWNlU3RhdGVJbXBsMi5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdHJhY2VTdGF0ZSA9IHRoaXMuX2Nsb25lKCk7XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgfTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZS5nZXQoa2V5KTtcbiAgfTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9rZXlzKCkucmVkdWNlKGZ1bmN0aW9uKGFnZywga2V5KSB7XG4gICAgICBhZ2cucHVzaChrZXkgKyBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIgKyBfdGhpcy5nZXQoa2V5KSk7XG4gICAgICByZXR1cm4gYWdnO1xuICAgIH0sIFtdKS5qb2luKExJU1RfTUVNQkVSU19TRVBBUkFUT1IpO1xuICB9O1xuICBUcmFjZVN0YXRlSW1wbDIucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uKHJhd1RyYWNlU3RhdGUpIHtcbiAgICBpZiAocmF3VHJhY2VTdGF0ZS5sZW5ndGggPiBNQVhfVFJBQ0VfU1RBVEVfTEVOKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ludGVybmFsU3RhdGUgPSByYXdUcmFjZVN0YXRlLnNwbGl0KExJU1RfTUVNQkVSU19TRVBBUkFUT1IpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24oYWdnLCBwYXJ0KSB7XG4gICAgICB2YXIgbGlzdE1lbWJlciA9IHBhcnQudHJpbSgpO1xuICAgICAgdmFyIGkgPSBsaXN0TWVtYmVyLmluZGV4T2YoTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICB2YXIga2V5ID0gbGlzdE1lbWJlci5zbGljZSgwLCBpKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbGlzdE1lbWJlci5zbGljZShpICsgMSwgcGFydC5sZW5ndGgpO1xuICAgICAgICBpZiAodmFsaWRhdGVLZXkoa2V5KSAmJiB2YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIGFnZy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhZ2c7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsU3RhdGUuc2l6ZSA+IE1BWF9UUkFDRV9TVEFURV9JVEVNUykge1xuICAgICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmVudHJpZXMoKSkucmV2ZXJzZSgpLnNsaWNlKDAsIE1BWF9UUkFDRV9TVEFURV9JVEVNUykpO1xuICAgIH1cbiAgfTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5fa2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUua2V5cygpKS5yZXZlcnNlKCk7XG4gIH07XG4gIFRyYWNlU3RhdGVJbXBsMi5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYWNlU3RhdGUgPSBuZXcgVHJhY2VTdGF0ZUltcGwyKCk7XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZSA9IG5ldyBNYXAodGhpcy5faW50ZXJuYWxTdGF0ZSk7XG4gICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gIH07XG4gIHJldHVybiBUcmFjZVN0YXRlSW1wbDI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL3RyYWNlLmpzXG52YXIgQVBJX05BTUUzID0gXCJ0cmFjZVwiO1xudmFyIFRyYWNlQVBJID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyYWNlQVBJMigpIHtcbiAgICB0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyID0gbmV3IFByb3h5VHJhY2VyUHJvdmlkZXIoKTtcbiAgICB0aGlzLndyYXBTcGFuQ29udGV4dCA9IHdyYXBTcGFuQ29udGV4dDtcbiAgICB0aGlzLmlzU3BhbkNvbnRleHRWYWxpZCA9IGlzU3BhbkNvbnRleHRWYWxpZDtcbiAgICB0aGlzLmRlbGV0ZVNwYW4gPSBkZWxldGVTcGFuO1xuICAgIHRoaXMuZ2V0U3BhbiA9IGdldFNwYW47XG4gICAgdGhpcy5nZXRTcGFuQ29udGV4dCA9IGdldFNwYW5Db250ZXh0O1xuICAgIHRoaXMuc2V0U3BhbiA9IHNldFNwYW47XG4gICAgdGhpcy5zZXRTcGFuQ29udGV4dCA9IHNldFNwYW5Db250ZXh0O1xuICB9XG4gIF9fbmFtZShUcmFjZUFQSTIsIFwiVHJhY2VBUElcIik7XG4gIFRyYWNlQVBJMi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IFRyYWNlQVBJMigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH07XG4gIFRyYWNlQVBJMi5wcm90b3R5cGUuc2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbihwcm92aWRlcikge1xuICAgIHZhciBzdWNjZXNzID0gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUzLCB0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyLnNldERlbGVnYXRlKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH07XG4gIFRyYWNlQVBJMi5wcm90b3R5cGUuZ2V0VHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0R2xvYmFsKEFQSV9OQU1FMykgfHwgdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcjtcbiAgfTtcbiAgVHJhY2VBUEkyLnByb3RvdHlwZS5nZXRUcmFjZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhY2VyUHJvdmlkZXIoKS5nZXRUcmFjZXIobmFtZSwgdmVyc2lvbik7XG4gIH07XG4gIFRyYWNlQVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHVucmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUzLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICAgIHRoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXIgPSBuZXcgUHJveHlUcmFjZXJQcm92aWRlcigpO1xuICB9O1xuICByZXR1cm4gVHJhY2VBUEkyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3Byb3BhZ2F0aW9uL05vb3BUZXh0TWFwUHJvcGFnYXRvci5qc1xudmFyIE5vb3BUZXh0TWFwUHJvcGFnYXRvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBOb29wVGV4dE1hcFByb3BhZ2F0b3IyKCkge1xuICB9XG4gIF9fbmFtZShOb29wVGV4dE1hcFByb3BhZ2F0b3IyLCBcIk5vb3BUZXh0TWFwUHJvcGFnYXRvclwiKTtcbiAgTm9vcFRleHRNYXBQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oX2NvbnRleHQsIF9jYXJyaWVyKSB7XG4gIH07XG4gIE5vb3BUZXh0TWFwUHJvcGFnYXRvcjIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MywgX2NhcnJpZXIpIHtcbiAgICByZXR1cm4gY29udGV4dDM7XG4gIH07XG4gIE5vb3BUZXh0TWFwUHJvcGFnYXRvcjIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXTtcbiAgfTtcbiAgcmV0dXJuIE5vb3BUZXh0TWFwUHJvcGFnYXRvcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS9jb250ZXh0LWhlbHBlcnMuanNcbnZhciBCQUdHQUdFX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoXCJPcGVuVGVsZW1ldHJ5IEJhZ2dhZ2UgS2V5XCIpO1xuZnVuY3Rpb24gZ2V0QmFnZ2FnZShjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuZ2V0VmFsdWUoQkFHR0FHRV9LRVkpIHx8IHZvaWQgMDtcbn1cbl9fbmFtZShnZXRCYWdnYWdlLCBcImdldEJhZ2dhZ2VcIik7XG5mdW5jdGlvbiBzZXRCYWdnYWdlKGNvbnRleHQzLCBiYWdnYWdlKSB7XG4gIHJldHVybiBjb250ZXh0My5zZXRWYWx1ZShCQUdHQUdFX0tFWSwgYmFnZ2FnZSk7XG59XG5fX25hbWUoc2V0QmFnZ2FnZSwgXCJzZXRCYWdnYWdlXCIpO1xuZnVuY3Rpb24gZGVsZXRlQmFnZ2FnZShjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuZGVsZXRlVmFsdWUoQkFHR0FHRV9LRVkpO1xufVxuX19uYW1lKGRlbGV0ZUJhZ2dhZ2UsIFwiZGVsZXRlQmFnZ2FnZVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvcHJvcGFnYXRpb24uanNcbnZhciBBUElfTkFNRTQgPSBcInByb3BhZ2F0aW9uXCI7XG52YXIgTk9PUF9URVhUX01BUF9QUk9QQUdBVE9SID0gbmV3IE5vb3BUZXh0TWFwUHJvcGFnYXRvcigpO1xudmFyIFByb3BhZ2F0aW9uQVBJID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFByb3BhZ2F0aW9uQVBJMigpIHtcbiAgICB0aGlzLmNyZWF0ZUJhZ2dhZ2UgPSBjcmVhdGVCYWdnYWdlO1xuICAgIHRoaXMuZ2V0QmFnZ2FnZSA9IGdldEJhZ2dhZ2U7XG4gICAgdGhpcy5zZXRCYWdnYWdlID0gc2V0QmFnZ2FnZTtcbiAgICB0aGlzLmRlbGV0ZUJhZ2dhZ2UgPSBkZWxldGVCYWdnYWdlO1xuICB9XG4gIF9fbmFtZShQcm9wYWdhdGlvbkFQSTIsIFwiUHJvcGFnYXRpb25BUElcIik7XG4gIFByb3BhZ2F0aW9uQVBJMi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IFByb3BhZ2F0aW9uQVBJMigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH07XG4gIFByb3BhZ2F0aW9uQVBJMi5wcm90b3R5cGUuc2V0R2xvYmFsUHJvcGFnYXRvciA9IGZ1bmN0aW9uKHByb3BhZ2F0b3IpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUU0LCBwcm9wYWdhdG9yLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICB9O1xuICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQzLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICBpZiAoc2V0dGVyID09PSB2b2lkIDApIHtcbiAgICAgIHNldHRlciA9IGRlZmF1bHRUZXh0TWFwU2V0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmluamVjdChjb250ZXh0MywgY2Fycmllciwgc2V0dGVyKTtcbiAgfTtcbiAgUHJvcGFnYXRpb25BUEkyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIGlmIChnZXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZ2V0dGVyID0gZGVmYXVsdFRleHRNYXBHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRHbG9iYWxQcm9wYWdhdG9yKCkuZXh0cmFjdChjb250ZXh0MywgY2FycmllciwgZ2V0dGVyKTtcbiAgfTtcbiAgUHJvcGFnYXRpb25BUEkyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmZpZWxkcygpO1xuICB9O1xuICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FNCwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgfTtcbiAgUHJvcGFnYXRpb25BUEkyLnByb3RvdHlwZS5fZ2V0R2xvYmFsUHJvcGFnYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWwoQVBJX05BTUU0KSB8fCBOT09QX1RFWFRfTUFQX1BST1BBR0FUT1I7XG4gIH07XG4gIHJldHVybiBQcm9wYWdhdGlvbkFQSTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vaW5kZXguanNcbnZhciBjb250ZXh0MiA9IENvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKTtcbnZhciB0cmFjZSA9IFRyYWNlQVBJLmdldEluc3RhbmNlKCk7XG52YXIgcHJvcGFnYXRpb24gPSBQcm9wYWdhdGlvbkFQSS5nZXRJbnN0YW5jZSgpO1xudmFyIGRpYWcyID0gRGlhZ0FQSS5pbnN0YW5jZSgpO1xuXG4vLyAuLi9lbmdpbmVzL3NyYy9pbmRleC50c1xudmFyIGltcG9ydF9lbmdpbmVzX3ZlcnNpb24gPSBfX3RvRVNNKHJlcXVpcmVfZW5naW5lc192ZXJzaW9uKCkpO1xuXG4vLyAuLi9nZXQtcGxhdGZvcm0vc3JjL2dldE5vZGVBUElOYW1lLnRzXG52YXIgTk9ERV9BUElfUVVFUllfRU5HSU5FX1VSTF9CQVNFID0gXCJsaWJxdWVyeV9lbmdpbmVcIjtcbmZ1bmN0aW9uIGdldE5vZGVBUElOYW1lKHBsYXRmb3JtMywgdHlwZSkge1xuICBjb25zdCBpc1VybCA9IHR5cGUgPT09IFwidXJsXCI7XG4gIGlmIChwbGF0Zm9ybTMuaW5jbHVkZXMoXCJ3aW5kb3dzXCIpKSB7XG4gICAgcmV0dXJuIGlzVXJsID8gYHF1ZXJ5X2VuZ2luZS5kbGwubm9kZWAgOiBgcXVlcnlfZW5naW5lLSR7cGxhdGZvcm0zfS5kbGwubm9kZWA7XG4gIH0gZWxzZSBpZiAocGxhdGZvcm0zLmluY2x1ZGVzKFwiZGFyd2luXCIpKSB7XG4gICAgcmV0dXJuIGlzVXJsID8gYCR7Tk9ERV9BUElfUVVFUllfRU5HSU5FX1VSTF9CQVNFfS5keWxpYi5ub2RlYCA6IGAke05PREVfQVBJX1FVRVJZX0VOR0lORV9VUkxfQkFTRX0tJHtwbGF0Zm9ybTN9LmR5bGliLm5vZGVgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc1VybCA/IGAke05PREVfQVBJX1FVRVJZX0VOR0lORV9VUkxfQkFTRX0uc28ubm9kZWAgOiBgJHtOT0RFX0FQSV9RVUVSWV9FTkdJTkVfVVJMX0JBU0V9LSR7cGxhdGZvcm0zfS5zby5ub2RlYDtcbiAgfVxufVxuX19uYW1lKGdldE5vZGVBUElOYW1lLCBcImdldE5vZGVBUElOYW1lXCIpO1xuXG4vLyAuLi9nZXQtcGxhdGZvcm0vc3JjL2dldFBsYXRmb3JtLnRzXG52YXIgaW1wb3J0X2NoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbnZhciBpbXBvcnRfZnMgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X29zID0gX190b0VTTShyZXF1aXJlKFwib3NcIikpO1xudmFyIGltcG9ydF91dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgcmVhZEZpbGUgPSAoMCwgaW1wb3J0X3V0aWwucHJvbWlzaWZ5KShpbXBvcnRfZnMuZGVmYXVsdC5yZWFkRmlsZSk7XG52YXIgZXhpc3RzID0gKDAsIGltcG9ydF91dGlsLnByb21pc2lmeSkoaW1wb3J0X2ZzLmRlZmF1bHQuZXhpc3RzKTtcbmFzeW5jIGZ1bmN0aW9uIGdldG9zKCkge1xuICBjb25zdCBwbGF0Zm9ybTMgPSBpbXBvcnRfb3MuZGVmYXVsdC5wbGF0Zm9ybSgpO1xuICBjb25zdCBhcmNoMiA9IHByb2Nlc3MuYXJjaDtcbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJmcmVlYnNkXCIpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ3JhY2VmdWxFeGVjKGBmcmVlYnNkLXZlcnNpb25gKTtcbiAgICBpZiAodmVyc2lvbiAmJiB2ZXJzaW9uLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZWdleCA9IC9eKFxcZCspXFwuPy87XG4gICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWModmVyc2lvbik7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwbGF0Zm9ybTogXCJmcmVlYnNkXCIsXG4gICAgICAgICAgZGlzdHJvOiBgZnJlZWJzZCR7bWF0Y2hbMV19YCxcbiAgICAgICAgICBhcmNoOiBhcmNoMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGxhdGZvcm0zICE9PSBcImxpbnV4XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhdGZvcm06IHBsYXRmb3JtMyxcbiAgICAgIGFyY2g6IGFyY2gyXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBsYXRmb3JtOiBcImxpbnV4XCIsXG4gICAgbGlic3NsOiBhd2FpdCBnZXRPcGVuU1NMVmVyc2lvbigpLFxuICAgIGRpc3RybzogYXdhaXQgcmVzb2x2ZURpc3RybygpLFxuICAgIGFyY2g6IGFyY2gyXG4gIH07XG59XG5fX25hbWUoZ2V0b3MsIFwiZ2V0b3NcIik7XG5mdW5jdGlvbiBwYXJzZURpc3RybyhpbnB1dCkge1xuICBjb25zdCBpZFJlZ2V4ID0gL15JRD1cIj8oW15cIlxcbl0qKVwiPyQvaW07XG4gIGNvbnN0IGlkTGlrZVJlZ2V4ID0gL15JRF9MSUtFPVwiPyhbXlwiXFxuXSopXCI/JC9pbTtcbiAgY29uc3QgaWRNYXRjaCA9IGlkUmVnZXguZXhlYyhpbnB1dCk7XG4gIGNvbnN0IGlkID0gaWRNYXRjaCAmJiBpZE1hdGNoWzFdICYmIGlkTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSB8fCBcIlwiO1xuICBjb25zdCBpZExpa2VNYXRjaCA9IGlkTGlrZVJlZ2V4LmV4ZWMoaW5wdXQpO1xuICBjb25zdCBpZExpa2UgPSBpZExpa2VNYXRjaCAmJiBpZExpa2VNYXRjaFsxXSAmJiBpZExpa2VNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gIGlmIChpZCA9PT0gXCJyYXNwYmlhblwiKSB7XG4gICAgcmV0dXJuIFwiYXJtXCI7XG4gIH1cbiAgaWYgKGlkID09PSBcIm5peG9zXCIpIHtcbiAgICByZXR1cm4gXCJuaXhvc1wiO1xuICB9XG4gIGlmIChpZExpa2UuaW5jbHVkZXMoXCJjZW50b3NcIikgfHwgaWRMaWtlLmluY2x1ZGVzKFwiZmVkb3JhXCIpIHx8IGlkTGlrZS5pbmNsdWRlcyhcInJoZWxcIikgfHwgaWQgPT09IFwiZmVkb3JhXCIpIHtcbiAgICByZXR1cm4gXCJyaGVsXCI7XG4gIH1cbiAgaWYgKGlkTGlrZS5pbmNsdWRlcyhcImRlYmlhblwiKSB8fCBpZExpa2UuaW5jbHVkZXMoXCJ1YnVudHVcIikgfHwgaWQgPT09IFwiZGViaWFuXCIpIHtcbiAgICByZXR1cm4gXCJkZWJpYW5cIjtcbiAgfVxuICByZXR1cm47XG59XG5fX25hbWUocGFyc2VEaXN0cm8sIFwicGFyc2VEaXN0cm9cIik7XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGlzdHJvKCkge1xuICBjb25zdCBvc1JlbGVhc2VGaWxlID0gXCIvZXRjL29zLXJlbGVhc2VcIjtcbiAgY29uc3QgYWxwaW5lUmVsZWFzZUZpbGUgPSBcIi9ldGMvYWxwaW5lLXJlbGVhc2VcIjtcbiAgaWYgKGF3YWl0IGV4aXN0cyhhbHBpbmVSZWxlYXNlRmlsZSkpIHtcbiAgICByZXR1cm4gXCJtdXNsXCI7XG4gIH0gZWxzZSBpZiAoYXdhaXQgZXhpc3RzKG9zUmVsZWFzZUZpbGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlRGlzdHJvKGF3YWl0IHJlYWRGaWxlKG9zUmVsZWFzZUZpbGUsIFwidXRmLThcIikpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuX19uYW1lKHJlc29sdmVEaXN0cm8sIFwicmVzb2x2ZURpc3Ryb1wiKTtcbmZ1bmN0aW9uIHBhcnNlT3BlblNTTFZlcnNpb24oaW5wdXQpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXk9wZW5TU0xcXHMoXFxkK1xcLlxcZCspXFwuXFxkKy8uZXhlYyhpbnB1dCk7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaFsxXSArIFwiLnhcIjtcbiAgfVxuICByZXR1cm47XG59XG5fX25hbWUocGFyc2VPcGVuU1NMVmVyc2lvbiwgXCJwYXJzZU9wZW5TU0xWZXJzaW9uXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0T3BlblNTTFZlcnNpb24oKSB7XG4gIGNvbnN0IFt2ZXJzaW9uLCBsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgZ3JhY2VmdWxFeGVjKGBvcGVuc3NsIHZlcnNpb24gLXZgKSxcbiAgICBncmFjZWZ1bEV4ZWMoYFxuICAgICAgbHMgLWwgL2xpYjY0IHwgZ3JlcCBzc2w7XG4gICAgICBscyAtbCAvdXNyL2xpYjY0IHwgZ3JlcCBzc2w7XG4gICAgYClcbiAgXSk7XG4gIGlmICh2ZXJzaW9uKSB7XG4gICAgY29uc3QgdiA9IHBhcnNlT3BlblNTTFZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfVxuICBpZiAobHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IC9saWJzc2xcXC5zb1xcLihcXGQrXFwuXFxkKylcXC5cXGQrLy5leGVjKGxzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaFsxXSArIFwiLnhcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbl9fbmFtZShnZXRPcGVuU1NMVmVyc2lvbiwgXCJnZXRPcGVuU1NMVmVyc2lvblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdyYWNlZnVsRXhlYyhjbWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICgwLCBpbXBvcnRfY2hpbGRfcHJvY2Vzcy5leGVjKShjbWQsIChlcnIsIHN0ZG91dCkgPT4ge1xuICAgICAgICByZXNvbHZlKFN0cmluZyhzdGRvdXQpKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0pO1xufVxuX19uYW1lKGdyYWNlZnVsRXhlYywgXCJncmFjZWZ1bEV4ZWNcIik7XG5hc3luYyBmdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgeyBwbGF0Zm9ybTogcGxhdGZvcm0zLCBsaWJzc2wsIGRpc3RybywgYXJjaDogYXJjaDIgfSA9IGF3YWl0IGdldG9zKCk7XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwiZGFyd2luXCIgJiYgYXJjaDIgPT09IFwiYXJtNjRcIikge1xuICAgIHJldHVybiBcImRhcndpbi1hcm02NFwiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwiZGFyd2luXCIpIHtcbiAgICByZXR1cm4gXCJkYXJ3aW5cIjtcbiAgfVxuICBpZiAocGxhdGZvcm0zID09PSBcIndpbjMyXCIpIHtcbiAgICByZXR1cm4gXCJ3aW5kb3dzXCI7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJmcmVlYnNkXCIpIHtcbiAgICByZXR1cm4gZGlzdHJvO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwib3BlbmJzZFwiKSB7XG4gICAgcmV0dXJuIFwib3BlbmJzZFwiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibmV0YnNkXCIpIHtcbiAgICByZXR1cm4gXCJuZXRic2RcIjtcbiAgfVxuICBpZiAocGxhdGZvcm0zID09PSBcImxpbnV4XCIgJiYgYXJjaDIgPT09IFwiYXJtNjRcIikge1xuICAgIHJldHVybiBgbGludXgtYXJtNjQtb3BlbnNzbC0ke2xpYnNzbH1gO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibGludXhcIiAmJiBhcmNoMiA9PT0gXCJhcm1cIikge1xuICAgIHJldHVybiBgbGludXgtYXJtLW9wZW5zc2wtJHtsaWJzc2x9YDtcbiAgfVxuICBpZiAocGxhdGZvcm0zID09PSBcImxpbnV4XCIgJiYgZGlzdHJvID09PSBcIm5peG9zXCIpIHtcbiAgICByZXR1cm4gXCJsaW51eC1uaXhvc1wiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibGludXhcIiAmJiBkaXN0cm8gPT09IFwibXVzbFwiKSB7XG4gICAgcmV0dXJuIFwibGludXgtbXVzbFwiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibGludXhcIiAmJiBkaXN0cm8gJiYgbGlic3NsKSB7XG4gICAgcmV0dXJuIGRpc3RybyArIFwiLW9wZW5zc2wtXCIgKyBsaWJzc2w7XG4gIH1cbiAgaWYgKGxpYnNzbCkge1xuICAgIHJldHVybiBcImRlYmlhbi1vcGVuc3NsLVwiICsgbGlic3NsO1xuICB9XG4gIGlmIChkaXN0cm8pIHtcbiAgICByZXR1cm4gZGlzdHJvICsgXCItb3BlbnNzbC0xLjEueFwiO1xuICB9XG4gIHJldHVybiBcImRlYmlhbi1vcGVuc3NsLTEuMS54XCI7XG59XG5fX25hbWUoZ2V0UGxhdGZvcm0sIFwiZ2V0UGxhdGZvcm1cIik7XG5cbi8vIC4uL2dldC1wbGF0Zm9ybS9zcmMvaXNOb2RlQVBJU3VwcG9ydGVkLnRzXG52YXIgaW1wb3J0X2ZzMiA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIGlzTm9kZUFQSVN1cHBvcnRlZCgpIHtcbiAgY29uc3QgY3VzdG9tTGlicmFyeVBhdGggPSBwcm9jZXNzLmVudi5QUklTTUFfUVVFUllfRU5HSU5FX0xJQlJBUlk7XG4gIGNvbnN0IGN1c3RvbUxpYnJhcnlFeGlzdHMgPSBjdXN0b21MaWJyYXJ5UGF0aCAmJiBpbXBvcnRfZnMyLmRlZmF1bHQuZXhpc3RzU3luYyhjdXN0b21MaWJyYXJ5UGF0aCk7XG4gIGNvbnN0IG9zMyA9IGF3YWl0IGdldG9zKCk7XG4gIGlmICghY3VzdG9tTGlicmFyeUV4aXN0cyAmJiAob3MzLmFyY2ggPT09IFwieDMyXCIgfHwgb3MzLmFyY2ggPT09IFwiaWEzMlwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgZGVmYXVsdCBxdWVyeSBlbmdpbmUgdHlwZSAoTm9kZS1BUEksIFwibGlicmFyeVwiKSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBmb3IgMzJiaXQgTm9kZS4gUGxlYXNlIHNldCBcXGBlbmdpbmVUeXBlID0gXCJiaW5hcnlcIlxcYCBpbiB0aGUgXCJnZW5lcmF0b3JcIiBibG9jayBvZiB5b3VyIFwic2NoZW1hLnByaXNtYVwiIGZpbGUgKG9yIHVzZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIFwiUFJJU01BX0NMSUVOVF9FTkdJTkVfVFlQRT1iaW5hcnlcIiBhbmQvb3IgXCJQUklTTUFfQ0xJX1FVRVJZX0VOR0lORV9UWVBFPWJpbmFyeVwiLilgXG4gICAgKTtcbiAgfVxufVxuX19uYW1lKGlzTm9kZUFQSVN1cHBvcnRlZCwgXCJpc05vZGVBUElTdXBwb3J0ZWRcIik7XG5cbi8vIC4uL2dldC1wbGF0Zm9ybS9zcmMvcGxhdGZvcm1zLnRzXG52YXIgcGxhdGZvcm1zID0gW1xuICBcImRhcndpblwiLFxuICBcImRhcndpbi1hcm02NFwiLFxuICBcImRlYmlhbi1vcGVuc3NsLTEuMC54XCIsXG4gIFwiZGViaWFuLW9wZW5zc2wtMS4xLnhcIixcbiAgXCJkZWJpYW4tb3BlbnNzbC0zLjAueFwiLFxuICBcInJoZWwtb3BlbnNzbC0xLjAueFwiLFxuICBcInJoZWwtb3BlbnNzbC0xLjEueFwiLFxuICBcInJoZWwtb3BlbnNzbC0zLjAueFwiLFxuICBcImxpbnV4LWFybTY0LW9wZW5zc2wtMS4xLnhcIixcbiAgXCJsaW51eC1hcm02NC1vcGVuc3NsLTEuMC54XCIsXG4gIFwibGludXgtYXJtNjQtb3BlbnNzbC0zLjAueFwiLFxuICBcImxpbnV4LWFybS1vcGVuc3NsLTEuMS54XCIsXG4gIFwibGludXgtYXJtLW9wZW5zc2wtMS4wLnhcIixcbiAgXCJsaW51eC1hcm0tb3BlbnNzbC0zLjAueFwiLFxuICBcImxpbnV4LW11c2xcIixcbiAgXCJsaW51eC1uaXhvc1wiLFxuICBcIndpbmRvd3NcIixcbiAgXCJmcmVlYnNkMTFcIixcbiAgXCJmcmVlYnNkMTJcIixcbiAgXCJmcmVlYnNkMTNcIixcbiAgXCJvcGVuYnNkXCIsXG4gIFwibmV0YnNkXCIsXG4gIFwiYXJtXCJcbl07XG5cbi8vIC4uL2VuZ2luZXMvc3JjL2luZGV4LnRzXG52YXIgaW1wb3J0X3BhdGggPSBfX3RvRVNNKHJlcXVpcmUoXCJwYXRoXCIpKTtcbnZhciBpbXBvcnRfZW5naW5lc192ZXJzaW9uMiA9IF9fdG9FU00ocmVxdWlyZV9lbmdpbmVzX3ZlcnNpb24oKSk7XG52YXIgZGVidWcyID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6ZW5naW5lc1wiKTtcbmZ1bmN0aW9uIGdldEVuZ2luZXNQYXRoKCkge1xuICByZXR1cm4gaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9cIik7XG59XG5fX25hbWUoZ2V0RW5naW5lc1BhdGgsIFwiZ2V0RW5naW5lc1BhdGhcIik7XG52YXIgREVGQVVMVF9DTElfUVVFUllfRU5HSU5FX0JJTkFSWV9UWVBFID0gXCJsaWJxdWVyeS1lbmdpbmVcIiAvKiBsaWJxdWVyeUVuZ2luZSAqLztcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLWRhcndpblwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vaW50cm9zcGVjdGlvbi1lbmdpbmUtZGFyd2luXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LWRhcndpblwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLWRhcndpbi1hcm02NFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vaW50cm9zcGVjdGlvbi1lbmdpbmUtZGFyd2luLWFybTY0XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LWRhcndpbi1hcm02NFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1kZWJpYW4tb3BlbnNzbC0xLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcHJpc21hLWZtdC1kZWJpYW4tb3BlbnNzbC0xLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1kZWJpYW4tb3BlbnNzbC0xLjEueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcHJpc21hLWZtdC1kZWJpYW4tb3BlbnNzbC0xLjEueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLWRlYmlhbi1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1kZWJpYW4tb3BlbnNzbC0zLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcHJpc21hLWZtdC1kZWJpYW4tb3BlbnNzbC0zLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLXJoZWwtb3BlbnNzbC0xLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vaW50cm9zcGVjdGlvbi1lbmdpbmUtcmhlbC1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LXJoZWwtb3BlbnNzbC0xLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLXJoZWwtb3BlbnNzbC0xLjEueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vaW50cm9zcGVjdGlvbi1lbmdpbmUtcmhlbC1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LXJoZWwtb3BlbnNzbC0xLjEueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnktZW5naW5lLXJoZWwtb3BlbnNzbC0zLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vaW50cm9zcGVjdGlvbi1lbmdpbmUtcmhlbC1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LXJoZWwtb3BlbnNzbC0zLjAueFwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWRhcndpbi5keWxpYi5ub2RlXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtZGFyd2luLWFybTY0LmR5bGliLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1kZWJpYW4tb3BlbnNzbC0xLjAueC5zby5ub2RlXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtZGViaWFuLW9wZW5zc2wtMS4xLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWRlYmlhbi1vcGVuc3NsLTMuMC54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1saW51eC1hcm02NC1vcGVuc3NsLTEuMC54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1saW51eC1hcm02NC1vcGVuc3NsLTEuMS54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1saW51eC1hcm02NC1vcGVuc3NsLTMuMC54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1saW51eC1tdXNsLnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1yaGVsLW9wZW5zc2wtMS4wLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLXJoZWwtb3BlbnNzbC0xLjEueC5zby5ub2RlXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtcmhlbC1vcGVuc3NsLTMuMC54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3F1ZXJ5X2VuZ2luZS13aW5kb3dzLmRsbC5ub2RlXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvYmluYXJ5L0JpbmFyeUVuZ2luZS50c1xudmFyIGltcG9ydF9jaGFsazMgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9jaGlsZF9wcm9jZXNzMiA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xudmFyIGltcG9ydF9ldmVudHMgPSBfX3RvRVNNKHJlcXVpcmUoXCJldmVudHNcIikpO1xudmFyIGltcG9ydF9leGVjYSA9IF9fdG9FU00ocmVxdWlyZV9leGVjYSgpKTtcbnZhciBpbXBvcnRfZnM0ID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xudmFyIGltcG9ydF9uZXQgPSBfX3RvRVNNKHJlcXVpcmUoXCJuZXRcIikpO1xudmFyIGltcG9ydF9wX3JldHJ5ID0gX190b0VTTShyZXF1aXJlX3BfcmV0cnkoKSk7XG52YXIgaW1wb3J0X3BhdGgyID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgaW1wb3J0X3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgaW1wb3J0X3V0aWw0ID0gcmVxdWlyZShcInV0aWxcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vRW5naW5lLnRzXG52YXIgRW5naW5lID0gY2xhc3Mge1xufTtcbl9fbmFtZShFbmdpbmUsIFwiRW5naW5lXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy9QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjbGllbnRWZXJzaW9uMiwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjI7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcik7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLCBcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL1ByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgY2xpZW50VmVyc2lvbjIsIG1ldGEpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb24yO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yXCI7XG4gIH1cbn07XG5fX25hbWUoUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL3V0aWxzL2xvZy50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZShsb2c0KSB7XG4gIGlmICh0eXBlb2YgbG9nNCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBsb2c0O1xuICB9IGVsc2UgaWYgKGlzUnVzdEVycm9yKGxvZzQpKSB7XG4gICAgcmV0dXJuIGdldEJhY2t0cmFjZUZyb21SdXN0RXJyb3IobG9nNCk7XG4gIH0gZWxzZSBpZiAoaXNSdXN0TG9nKGxvZzQpKSB7XG4gICAgcmV0dXJuIGdldEJhY2t0cmFjZUZyb21Mb2cobG9nNCk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxvZzQpO1xufVxuX19uYW1lKGdldE1lc3NhZ2UsIFwiZ2V0TWVzc2FnZVwiKTtcbmZ1bmN0aW9uIGdldEJhY2t0cmFjZUZyb21Mb2cobG9nNCkge1xuICB2YXIgX2EzLCBfYjIsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgaWYgKChfYTMgPSBsb2c0LmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tZXNzYWdlKSB7XG4gICAgbGV0IHN0ciA9IChfYjIgPSBsb2c0LmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5tZXNzYWdlO1xuICAgIGlmICgoX2MgPSBsb2c0LmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmZpbGUpIHtcbiAgICAgIHN0ciArPSBgIGluICR7bG9nNC5maWVsZHMuZmlsZX1gO1xuICAgICAgaWYgKChfZCA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2QubGluZSkge1xuICAgICAgICBzdHIgKz0gYDoke2xvZzQuZmllbGRzLmxpbmV9YDtcbiAgICAgIH1cbiAgICAgIGlmICgoX2UgPSBsb2c0LmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNvbHVtbikge1xuICAgICAgICBzdHIgKz0gYDoke2xvZzQuZmllbGRzLmNvbHVtbn1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKF9mID0gbG9nNC5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfZi5yZWFzb24pIHtcbiAgICAgIHN0ciArPSBgXG4keyhfZyA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2cucmVhc29ufWA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIFwiVW5rbm93biBlcnJvclwiO1xufVxuX19uYW1lKGdldEJhY2t0cmFjZUZyb21Mb2csIFwiZ2V0QmFja3RyYWNlRnJvbUxvZ1wiKTtcbmZ1bmN0aW9uIGdldEJhY2t0cmFjZUZyb21SdXN0RXJyb3IoZXJyKSB7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBpZiAoZXJyLmlzX3BhbmljKSB7XG4gICAgc3RyICs9IGBQQU5JQ2A7XG4gIH1cbiAgaWYgKGVyci5iYWNrdHJhY2UpIHtcbiAgICBzdHIgKz0gYCBpbiAke2Vyci5iYWNrdHJhY2V9YDtcbiAgfVxuICBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICBzdHIgKz0gYFxuJHtlcnIubWVzc2FnZX1gO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5fX25hbWUoZ2V0QmFja3RyYWNlRnJvbVJ1c3RFcnJvciwgXCJnZXRCYWNrdHJhY2VGcm9tUnVzdEVycm9yXCIpO1xuZnVuY3Rpb24gaXNSdXN0TG9nKGUpIHtcbiAgcmV0dXJuIGUudGltZXN0YW1wICYmIHR5cGVvZiBlLmxldmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlLnRhcmdldCA9PT0gXCJzdHJpbmdcIjtcbn1cbl9fbmFtZShpc1J1c3RMb2csIFwiaXNSdXN0TG9nXCIpO1xuZnVuY3Rpb24gaXNSdXN0RXJyb3JMb2coZSkge1xuICB2YXIgX2EzLCBfYjI7XG4gIHJldHVybiBpc1J1c3RMb2coZSkgJiYgKGUubGV2ZWwgPT09IFwiZXJyb3JcIiB8fCAoKF9iMiA9IChfYTMgPSBlLmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmluY2x1ZGVzKFwiZmF0YWwgZXJyb3JcIikpKTtcbn1cbl9fbmFtZShpc1J1c3RFcnJvckxvZywgXCJpc1J1c3RFcnJvckxvZ1wiKTtcbmZ1bmN0aW9uIGlzUnVzdEVycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlLmlzX3BhbmljICE9PSBcInVuZGVmaW5lZFwiO1xufVxuX19uYW1lKGlzUnVzdEVycm9yLCBcImlzUnVzdEVycm9yXCIpO1xuZnVuY3Rpb24gY29udmVydExvZyhydXN0TG9nKSB7XG4gIGNvbnN0IGlzUXVlcnkgPSBpc1F1ZXJ5TG9nKHJ1c3RMb2cuZmllbGRzKTtcbiAgY29uc3QgbGV2ZWwgPSBpc1F1ZXJ5ID8gXCJxdWVyeVwiIDogcnVzdExvZy5sZXZlbC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4ge1xuICAgIC4uLnJ1c3RMb2csXG4gICAgbGV2ZWwsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZShydXN0TG9nLnRpbWVzdGFtcClcbiAgfTtcbn1cbl9fbmFtZShjb252ZXJ0TG9nLCBcImNvbnZlcnRMb2dcIik7XG5mdW5jdGlvbiBpc1F1ZXJ5TG9nKGZpZWxkcykge1xuICByZXR1cm4gQm9vbGVhbihmaWVsZHMucXVlcnkpO1xufVxuX19uYW1lKGlzUXVlcnlMb2csIFwiaXNRdWVyeUxvZ1wiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvUHJpc21hQ2xpZW50UnVzdEVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50UnVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50VmVyc2lvbjogY2xpZW50VmVyc2lvbjIsIGxvZzogbG9nNCwgZXJyb3I6IGVycm9yMiB9KSB7XG4gICAgdmFyIF9fc3VwZXIgPSAoLi4uYXJncykgPT4ge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgfTtcbiAgICBpZiAobG9nNCkge1xuICAgICAgY29uc3QgYmFja3RyYWNlID0gZ2V0QmFja3RyYWNlRnJvbUxvZyhsb2c0KTtcbiAgICAgIF9fc3VwZXIoYmFja3RyYWNlICE9IG51bGwgPyBiYWNrdHJhY2UgOiBcIlVua25vd24gZXJyb3JcIik7XG4gICAgfSBlbHNlIGlmIChlcnJvcjIpIHtcbiAgICAgIGNvbnN0IGJhY2t0cmFjZSA9IGdldEJhY2t0cmFjZUZyb21SdXN0RXJyb3IoZXJyb3IyKTtcbiAgICAgIF9fc3VwZXIoYmFja3RyYWNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX19zdXBlcihgVW5rbm93biBlcnJvcmApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uMjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRSdXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50UnVzdEVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy9QcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvci50c1xudmFyIFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNsaWVudFZlcnNpb24yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjI7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXCI7XG4gIH1cbn07XG5fX25hbWUoUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsIFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL1ByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNsaWVudFZlcnNpb24yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjI7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLCBcIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL3V0aWxzL2dldEVycm9yTWVzc2FnZVdpdGhMaW5rLnRzXG52YXIgaW1wb3J0X2NoYWxrMiA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgaW1wb3J0X3N0cmlwX2Fuc2kgPSBfX3RvRVNNKHJlcXVpcmVfc3RyaXBfYW5zaSgpKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi91dGlscy91dGlsLnRzXG52YXIgaW1wb3J0X2ZzMyA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfbmV3X2dpdGh1Yl9pc3N1ZV91cmwgPSBfX3RvRVNNKHJlcXVpcmVfbmV3X2dpdGh1Yl9pc3N1ZV91cmwoKSk7XG52YXIgZGVidWczID0gc3JjX2RlZmF1bHQoXCJwbHVzWFwiKTtcbmZ1bmN0aW9uIHBsdXNYKGZpbGUpIHtcbiAgY29uc3QgcyA9IGltcG9ydF9mczMuZGVmYXVsdC5zdGF0U3luYyhmaWxlKTtcbiAgY29uc3QgbmV3TW9kZSA9IHMubW9kZSB8IDY0IHwgOCB8IDE7XG4gIGlmIChzLm1vZGUgPT09IG5ld01vZGUpIHtcbiAgICBkZWJ1ZzMoYEV4ZWN1dGlvbiBwZXJtaXNzaW9ucyBvZiAke2ZpbGV9IGFyZSBmaW5lYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJhc2U4ID0gbmV3TW9kZS50b1N0cmluZyg4KS5zbGljZSgtMyk7XG4gIGRlYnVnMyhgSGF2ZSB0byBjYWxsIHBsdXNYIG9uICR7ZmlsZX1gKTtcbiAgaW1wb3J0X2ZzMy5kZWZhdWx0LmNobW9kU3luYyhmaWxlLCBiYXNlOCk7XG59XG5fX25hbWUocGx1c1gsIFwicGx1c1hcIik7XG5mdW5jdGlvbiB0cmFuc2Zvcm1QbGF0Zm9ybVRvRW52VmFsdWUocGxhdGZvcm0zKSB7XG4gIHJldHVybiB7IGZyb21FbnZWYXI6IG51bGwsIHZhbHVlOiBwbGF0Zm9ybTMgfTtcbn1cbl9fbmFtZSh0cmFuc2Zvcm1QbGF0Zm9ybVRvRW52VmFsdWUsIFwidHJhbnNmb3JtUGxhdGZvcm1Ub0VudlZhbHVlXCIpO1xuZnVuY3Rpb24gZml4QmluYXJ5VGFyZ2V0cyhiaW5hcnlUYXJnZXRzLCBwbGF0Zm9ybTMpIHtcbiAgYmluYXJ5VGFyZ2V0cyA9IGJpbmFyeVRhcmdldHMgfHwgW107XG4gIGlmICghYmluYXJ5VGFyZ2V0cy5maW5kKChvYmplY3QpID0+IG9iamVjdC52YWx1ZSA9PT0gXCJuYXRpdmVcIikpIHtcbiAgICByZXR1cm4gW3RyYW5zZm9ybVBsYXRmb3JtVG9FbnZWYWx1ZShcIm5hdGl2ZVwiKSwgLi4uYmluYXJ5VGFyZ2V0c107XG4gIH1cbiAgcmV0dXJuIFsuLi5iaW5hcnlUYXJnZXRzLCB0cmFuc2Zvcm1QbGF0Zm9ybVRvRW52VmFsdWUocGxhdGZvcm0zKV07XG59XG5fX25hbWUoZml4QmluYXJ5VGFyZ2V0cywgXCJmaXhCaW5hcnlUYXJnZXRzXCIpO1xuZnVuY3Rpb24gZ2V0R2l0aHViSXNzdWVVcmwoe1xuICB0aXRsZSxcbiAgdXNlciA9IFwicHJpc21hXCIsXG4gIHJlcG8gPSBcInByaXNtYVwiLFxuICB0ZW1wbGF0ZSA9IFwiYnVnX3JlcG9ydC5tZFwiLFxuICBib2R5XG59KSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X25ld19naXRodWJfaXNzdWVfdXJsLmRlZmF1bHQpKHtcbiAgICB1c2VyLFxuICAgIHJlcG8sXG4gICAgdGVtcGxhdGUsXG4gICAgdGl0bGUsXG4gICAgYm9keVxuICB9KTtcbn1cbl9fbmFtZShnZXRHaXRodWJJc3N1ZVVybCwgXCJnZXRHaXRodWJJc3N1ZVVybFwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvdXRpbHMvbWFza1F1ZXJ5LnRzXG5mdW5jdGlvbiBtYXNrUXVlcnkocXVlcnkyKSB7XG4gIGlmICghcXVlcnkyKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5Mi5yZXBsYWNlKC9cIi4qXCIvZywgJ1wiWFwiJykucmVwbGFjZSgvW1xcczpcXFtdKFsrLV0/KFswLTldKlsuXSk/WzAtOV0rKS9nLCAoc3Vic3RyKSA9PiB7XG4gICAgcmV0dXJuIGAke3N1YnN0clswXX01YDtcbiAgfSk7XG59XG5fX25hbWUobWFza1F1ZXJ5LCBcIm1hc2tRdWVyeVwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvdXRpbHMvbm9ybWFsaXplTG9ncy50c1xuZnVuY3Rpb24gbm9ybWFsaXplTG9ncyhsb2dzKSB7XG4gIHJldHVybiBsb2dzLnNwbGl0KFwiXFxuXCIpLm1hcCgobCkgPT4ge1xuICAgIHJldHVybiBsLnJlcGxhY2UoL15cXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZFxcLlxcZCsoWystXVswLTJdXFxkOlswLTVdXFxkfFopXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xcK1xcZCtcXHMqbXMkLywgXCJcIik7XG4gIH0pLmpvaW4oXCJcXG5cIik7XG59XG5fX25hbWUobm9ybWFsaXplTG9ncywgXCJub3JtYWxpemVMb2dzXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy91dGlscy9nZXRFcnJvck1lc3NhZ2VXaXRoTGluay50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsoe1xuICB2ZXJzaW9uLFxuICBwbGF0Zm9ybTogcGxhdGZvcm0zLFxuICB0aXRsZSxcbiAgZGVzY3JpcHRpb24sXG4gIGVuZ2luZVZlcnNpb24sXG4gIGRhdGFiYXNlLFxuICBxdWVyeTogcXVlcnkyXG59KSB7XG4gIHZhciBfYTMsIF9iMjtcbiAgY29uc3QgZ290TG9ncyA9IGdldExvZ3MoNmUzIC0gKChfYTMgPSBxdWVyeTIgPT0gbnVsbCA/IHZvaWQgMCA6IHF1ZXJ5Mi5sZW5ndGgpICE9IG51bGwgPyBfYTMgOiAwKSk7XG4gIGNvbnN0IGxvZ3MgPSBub3JtYWxpemVMb2dzKCgwLCBpbXBvcnRfc3RyaXBfYW5zaS5kZWZhdWx0KShnb3RMb2dzKSk7XG4gIGNvbnN0IG1vcmVJbmZvID0gZGVzY3JpcHRpb24gPyBgIyBEZXNjcmlwdGlvblxuXFxgXFxgXFxgXG4ke2Rlc2NyaXB0aW9ufVxuXFxgXFxgXFxgYCA6IFwiXCI7XG4gIGNvbnN0IGJvZHkgPSAoMCwgaW1wb3J0X3N0cmlwX2Fuc2kuZGVmYXVsdCkoXG4gICAgYEhpIFByaXNtYSBUZWFtISBNeSBQcmlzbWEgQ2xpZW50IGp1c3QgY3Jhc2hlZC4gVGhpcyBpcyB0aGUgcmVwb3J0OlxuIyMgVmVyc2lvbnNcblxufCBOYW1lICAgICAgICAgICAgfCBWZXJzaW9uICAgICAgICAgICAgfFxufC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tfFxufCBOb2RlICAgICAgICAgICAgfCAkeyhfYjIgPSBwcm9jZXNzLnZlcnNpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYjIucGFkRW5kKDE5KX18IFxufCBPUyAgICAgICAgICAgICAgfCAke3BsYXRmb3JtMyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0zLnBhZEVuZCgxOSl9fFxufCBQcmlzbWEgQ2xpZW50ICAgfCAke3ZlcnNpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHZlcnNpb24ucGFkRW5kKDE5KX18XG58IFF1ZXJ5IEVuZ2luZSAgICB8ICR7ZW5naW5lVmVyc2lvbiA9PSBudWxsID8gdm9pZCAwIDogZW5naW5lVmVyc2lvbi5wYWRFbmQoMTkpfXxcbnwgRGF0YWJhc2UgICAgICAgIHwgJHtkYXRhYmFzZSA9PSBudWxsID8gdm9pZCAwIDogZGF0YWJhc2UucGFkRW5kKDE5KX18XG5cbiR7bW9yZUluZm99XG5cbiMjIExvZ3NcblxcYFxcYFxcYFxuJHtsb2dzfVxuXFxgXFxgXFxgXG5cbiMjIENsaWVudCBTbmlwcGV0XG5cXGBcXGBcXGB0c1xuLy8gUExFQVNFIEZJTEwgWU9VUiBDT0RFIFNOSVBQRVQgSEVSRVxuXFxgXFxgXFxgXG5cbiMjIFNjaGVtYVxuXFxgXFxgXFxgcHJpc21hXG4vLyBQTEVBU0UgQUREIFlPVVIgU0NIRU1BIEhFUkUgSUYgUE9TU0lCTEVcblxcYFxcYFxcYFxuXG4jIyBQcmlzbWEgRW5naW5lIFF1ZXJ5XG5cXGBcXGBcXGBcbiR7cXVlcnkyID8gbWFza1F1ZXJ5KHF1ZXJ5MikgOiBcIlwifVxuXFxgXFxgXFxgXG5gXG4gICk7XG4gIGNvbnN0IHVybCA9IGdldEdpdGh1Yklzc3VlVXJsKHsgdGl0bGUsIGJvZHkgfSk7XG4gIHJldHVybiBgJHt0aXRsZX1cblxuVGhpcyBpcyBhIG5vbi1yZWNvdmVyYWJsZSBlcnJvciB3aGljaCBwcm9iYWJseSBoYXBwZW5zIHdoZW4gdGhlIFByaXNtYSBRdWVyeSBFbmdpbmUgaGFzIGEgcGFuaWMuXG5cbiR7aW1wb3J0X2NoYWxrMi5kZWZhdWx0LnVuZGVybGluZSh1cmwpfVxuXG5JZiB5b3Ugd2FudCB0aGUgUHJpc21hIHRlYW0gdG8gbG9vayBpbnRvIGl0LCBwbGVhc2Ugb3BlbiB0aGUgbGluayBhYm92ZSBcXHV7MUY2NEZ9XG5UbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHN1Y2Nlc3MsIHBsZWFzZSBwb3N0IHlvdXIgc2NoZW1hIGFuZCBhIHNuaXBwZXQgb2ZcbmhvdyB5b3UgdXNlZCBQcmlzbWEgQ2xpZW50IGluIHRoZSBpc3N1ZS4gXG5gO1xufVxuX19uYW1lKGdldEVycm9yTWVzc2FnZVdpdGhMaW5rLCBcImdldEVycm9yTWVzc2FnZVdpdGhMaW5rXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy91dGlscy9wcmlzbWFHcmFwaFFMVG9KU0Vycm9yLnRzXG5mdW5jdGlvbiBwcmlzbWFHcmFwaFFMVG9KU0Vycm9yKGVycm9yMiwgY2xpZW50VmVyc2lvbjIpIHtcbiAgaWYgKGVycm9yMi51c2VyX2ZhY2luZ19lcnJvci5lcnJvcl9jb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcihcbiAgICAgIGVycm9yMi51c2VyX2ZhY2luZ19lcnJvci5tZXNzYWdlLFxuICAgICAgZXJyb3IyLnVzZXJfZmFjaW5nX2Vycm9yLmVycm9yX2NvZGUsXG4gICAgICBjbGllbnRWZXJzaW9uMixcbiAgICAgIGVycm9yMi51c2VyX2ZhY2luZ19lcnJvci5tZXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IoZXJyb3IyLmVycm9yLCBjbGllbnRWZXJzaW9uMik7XG59XG5fX25hbWUocHJpc21hR3JhcGhRTFRvSlNFcnJvciwgXCJwcmlzbWFHcmFwaFFMVG9KU0Vycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL3V0aWxzL3ByaW50R2VuZXJhdG9yQ29uZmlnLnRzXG52YXIgaW1wb3J0X2luZGVudF9zdHJpbmcyID0gX190b0VTTShyZXF1aXJlX2luZGVudF9zdHJpbmcoKSk7XG5mdW5jdGlvbiBwcmludEdlbmVyYXRvckNvbmZpZyhjb25maWcyKSB7XG4gIHJldHVybiBTdHJpbmcobmV3IEdlbmVyYXRvckNvbmZpZ0NsYXNzKGNvbmZpZzIpKTtcbn1cbl9fbmFtZShwcmludEdlbmVyYXRvckNvbmZpZywgXCJwcmludEdlbmVyYXRvckNvbmZpZ1wiKTtcbnZhciBHZW5lcmF0b3JDb25maWdDbGFzcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnMikge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnMjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7IGNvbmZpZzogY29uZmlnMiB9ID0gdGhpcztcbiAgICBjb25zdCBwcm92aWRlciA9IGNvbmZpZzIucHJvdmlkZXIuZnJvbUVudlZhciA/IGBlbnYoXCIke2NvbmZpZzIucHJvdmlkZXIuZnJvbUVudlZhcn1cIilgIDogY29uZmlnMi5wcm92aWRlci52YWx1ZTtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgYmluYXJ5VGFyZ2V0czogZ2V0T3JpZ2luYWxCaW5hcnlUYXJnZXRzVmFsdWUoY29uZmlnMi5iaW5hcnlUYXJnZXRzKVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBgZ2VuZXJhdG9yICR7Y29uZmlnMi5uYW1lfSB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzIuZGVmYXVsdCkocHJpbnREYXRhbW9kZWxPYmplY3Qob2JqKSwgMil9XG59YDtcbiAgfVxufTtcbl9fbmFtZShHZW5lcmF0b3JDb25maWdDbGFzcywgXCJHZW5lcmF0b3JDb25maWdDbGFzc1wiKTtcbmZ1bmN0aW9uIGdldE9yaWdpbmFsQmluYXJ5VGFyZ2V0c1ZhbHVlKGJpbmFyeVRhcmdldHMpIHtcbiAgbGV0IHZhbHVlO1xuICBpZiAoYmluYXJ5VGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYmluYXJ5VGFyZ2V0c0Zyb21FbnZWYXIgPSBiaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LmZyb21FbnZWYXIgIT09IG51bGwpO1xuICAgIGlmIChiaW5hcnlUYXJnZXRzRnJvbUVudlZhcikge1xuICAgICAgdmFsdWUgPSBgZW52KFwiJHtiaW5hcnlUYXJnZXRzRnJvbUVudlZhci5mcm9tRW52VmFyfVwiKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYmluYXJ5VGFyZ2V0cy5tYXAoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuX19uYW1lKGdldE9yaWdpbmFsQmluYXJ5VGFyZ2V0c1ZhbHVlLCBcImdldE9yaWdpbmFsQmluYXJ5VGFyZ2V0c1ZhbHVlXCIpO1xuZnVuY3Rpb24gcHJpbnREYXRhbW9kZWxPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG1heExlbmd0aCA9IE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChtYXgyLCBjdXJyKSA9PiBNYXRoLm1heChtYXgyLCBjdXJyLmxlbmd0aCksIDApO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5LnBhZEVuZChtYXhMZW5ndGgpfSA9ICR7bmljZVN0cmluZ2lmeSh2YWx1ZSl9YCkuam9pbihcIlxcblwiKTtcbn1cbl9fbmFtZShwcmludERhdGFtb2RlbE9iamVjdCwgXCJwcmludERhdGFtb2RlbE9iamVjdFwiKTtcbmZ1bmN0aW9uIG5pY2VTdHJpbmdpZnkodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChfLCB2YWx1ZTIpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMikpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt2YWx1ZTIubWFwKChlbGVtZW50KSA9PiBKU09OLnN0cmluZ2lmeShlbGVtZW50KSkuam9pbihcIiwgXCIpfV1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlMik7XG4gICAgfSlcbiAgKTtcbn1cbl9fbmFtZShuaWNlU3RyaW5naWZ5LCBcIm5pY2VTdHJpbmdpZnlcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy90b29scy9ieWxpbmUudHNcbnZhciBpbXBvcnRfc3RyZWFtID0gX190b0VTTShyZXF1aXJlKFwic3RyZWFtXCIpKTtcbnZhciBpbXBvcnRfdXRpbDMgPSBfX3RvRVNNKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbmZ1bmN0aW9uIGJ5bGluZShyZWFkU3RyZWFtLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVTdHJlYW0ocmVhZFN0cmVhbSwgb3B0aW9ucyk7XG59XG5fX25hbWUoYnlsaW5lLCBcImJ5bGluZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbShyZWFkU3RyZWFtLCBvcHRpb25zKSB7XG4gIGlmIChyZWFkU3RyZWFtKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxpbmVTdHJlYW0ocmVhZFN0cmVhbSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyZWFtKG9wdGlvbnMpO1xuICB9XG59XG5fX25hbWUoY3JlYXRlU3RyZWFtLCBcImNyZWF0ZVN0cmVhbVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTdHJlYW0ocmVhZFN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAoIXJlYWRTdHJlYW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCByZWFkU3RyZWFtXCIpO1xuICB9XG4gIGlmICghcmVhZFN0cmVhbS5yZWFkYWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRTdHJlYW0gbXVzdCBiZSByZWFkYWJsZVwiKTtcbiAgfVxuICBjb25zdCBscyA9IG5ldyBMaW5lU3RyZWFtKG9wdGlvbnMpO1xuICByZWFkU3RyZWFtLnBpcGUobHMpO1xuICByZXR1cm4gbHM7XG59XG5fX25hbWUoY3JlYXRlTGluZVN0cmVhbSwgXCJjcmVhdGVMaW5lU3RyZWFtXCIpO1xuZnVuY3Rpb24gTGluZVN0cmVhbShvcHRpb25zKSB7XG4gIGltcG9ydF9zdHJlYW0uZGVmYXVsdC5UcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IHRydWU7XG4gIHRoaXMuX2xpbmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5fa2VlcEVtcHR5TGluZXMgPSBvcHRpb25zLmtlZXBFbXB0eUxpbmVzIHx8IGZhbHNlO1xuICB0aGlzLl9sYXN0Q2h1bmtFbmRlZFdpdGhDUiA9IGZhbHNlO1xuICB0aGlzLm9uKFwicGlwZVwiLCBmdW5jdGlvbihzcmMpIHtcbiAgICBpZiAoIXRoaXMuZW5jb2RpbmcpIHtcbiAgICAgIGlmIChzcmMgaW5zdGFuY2VvZiBpbXBvcnRfc3RyZWFtLmRlZmF1bHQuUmVhZGFibGUpIHtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IHNyYy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuX19uYW1lKExpbmVTdHJlYW0sIFwiTGluZVN0cmVhbVwiKTtcbmltcG9ydF91dGlsMy5kZWZhdWx0LmluaGVyaXRzKExpbmVTdHJlYW0sIGltcG9ydF9zdHJlYW0uZGVmYXVsdC5UcmFuc2Zvcm0pO1xuTGluZVN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IFwidXRmOFwiO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGlmIChlbmNvZGluZyA9PSBcImJ1ZmZlclwiKSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKCk7XG4gICAgICBlbmNvZGluZyA9IFwidXRmOFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fY2h1bmtFbmNvZGluZyA9IGVuY29kaW5nO1xuICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKTtcbiAgaWYgKHRoaXMuX2xhc3RDaHVua0VuZGVkV2l0aENSICYmIGNodW5rWzBdID09IFwiXFxuXCIpIHtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICB9XG4gIGlmICh0aGlzLl9saW5lQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9saW5lQnVmZmVyW3RoaXMuX2xpbmVCdWZmZXIubGVuZ3RoIC0gMV0gKz0gbGluZXNbMF07XG4gICAgbGluZXMuc2hpZnQoKTtcbiAgfVxuICB0aGlzLl9sYXN0Q2h1bmtFbmRlZFdpdGhDUiA9IGNodW5rW2NodW5rLmxlbmd0aCAtIDFdID09IFwiXFxyXCI7XG4gIHRoaXMuX2xpbmVCdWZmZXIgPSB0aGlzLl9saW5lQnVmZmVyLmNvbmNhdChsaW5lcyk7XG4gIHRoaXMuX3B1c2hCdWZmZXIoZW5jb2RpbmcsIDEsIGRvbmUpO1xufTtcbkxpbmVTdHJlYW0ucHJvdG90eXBlLl9wdXNoQnVmZmVyID0gZnVuY3Rpb24oZW5jb2RpbmcsIGtlZXAsIGRvbmUpIHtcbiAgd2hpbGUgKHRoaXMuX2xpbmVCdWZmZXIubGVuZ3RoID4ga2VlcCkge1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLl9saW5lQnVmZmVyLnNoaWZ0KCk7XG4gICAgaWYgKHRoaXMuX2tlZXBFbXB0eUxpbmVzIHx8IGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCF0aGlzLnB1c2godGhpcy5fcmVlbmNvZGUobGluZSwgZW5jb2RpbmcpKSkge1xuICAgICAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmMi5fcHVzaEJ1ZmZlcihlbmNvZGluZywga2VlcCwgZG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRvbmUoKTtcbn07XG5MaW5lU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihkb25lKSB7XG4gIHRoaXMuX3B1c2hCdWZmZXIodGhpcy5fY2h1bmtFbmNvZGluZywgMCwgZG9uZSk7XG59O1xuTGluZVN0cmVhbS5wcm90b3R5cGUuX3JlZW5jb2RlID0gZnVuY3Rpb24obGluZSwgY2h1bmtFbmNvZGluZykge1xuICBpZiAodGhpcy5lbmNvZGluZyAmJiB0aGlzLmVuY29kaW5nICE9IGNodW5rRW5jb2RpbmcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obGluZSwgY2h1bmtFbmNvZGluZykudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG4gIH0gZWxzZSBpZiAodGhpcy5lbmNvZGluZykge1xuICAgIHJldHVybiBsaW5lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShsaW5lLCBjaHVua0VuY29kaW5nKTtcbiAgfVxufTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL3Rvb2xzL29taXQudHNcbmZ1bmN0aW9uIG9taXQob2JqLCBrZXlzMikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoKGtleSkgPT4gIWtleXMyLmluY2x1ZGVzKGtleSkpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn1cbl9fbmFtZShvbWl0LCBcIm9taXRcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc3VwcHJlc3MtdHJhY2luZy5qc1xudmFyIFNVUFBSRVNTX1RSQUNJTkdfS0VZID0gY3JlYXRlQ29udGV4dEtleShcIk9wZW5UZWxlbWV0cnkgU0RLIENvbnRleHQgS2V5IFNVUFBSRVNTX1RSQUNJTkdcIik7XG5mdW5jdGlvbiBzdXBwcmVzc1RyYWNpbmcoY29udGV4dDMpIHtcbiAgcmV0dXJuIGNvbnRleHQzLnNldFZhbHVlKFNVUFBSRVNTX1RSQUNJTkdfS0VZLCB0cnVlKTtcbn1cbl9fbmFtZShzdXBwcmVzc1RyYWNpbmcsIFwic3VwcHJlc3NUcmFjaW5nXCIpO1xuZnVuY3Rpb24gaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuZ2V0VmFsdWUoU1VQUFJFU1NfVFJBQ0lOR19LRVkpID09PSB0cnVlO1xufVxuX19uYW1lKGlzVHJhY2luZ1N1cHByZXNzZWQsIFwiaXNUcmFjaW5nU3VwcHJlc3NlZFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9iYWdnYWdlL2NvbnN0YW50cy5qc1xudmFyIEJBR0dBR0VfS0VZX1BBSVJfU0VQQVJBVE9SID0gXCI9XCI7XG52YXIgQkFHR0FHRV9QUk9QRVJUSUVTX1NFUEFSQVRPUiA9IFwiO1wiO1xudmFyIEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SID0gXCIsXCI7XG52YXIgQkFHR0FHRV9IRUFERVIgPSBcImJhZ2dhZ2VcIjtcbnZhciBCQUdHQUdFX01BWF9OQU1FX1ZBTFVFX1BBSVJTID0gMTgwO1xudmFyIEJBR0dBR0VfTUFYX1BFUl9OQU1FX1ZBTFVFX1BBSVJTID0gNDA5NjtcbnZhciBCQUdHQUdFX01BWF9UT1RBTF9MRU5HVEggPSA4MTkyO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2JhZ2dhZ2UvdXRpbHMuanNcbnZhciBfX3JlYWQgPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIGUgPSB7IGVycm9yOiBlcnJvcjIgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplS2V5UGFpcnMoa2V5UGFpcnMpIHtcbiAgcmV0dXJuIGtleVBhaXJzLnJlZHVjZShmdW5jdGlvbihoVmFsdWUsIGN1cnJlbnQpIHtcbiAgICB2YXIgdmFsdWUgPSBcIlwiICsgaFZhbHVlICsgKGhWYWx1ZSAhPT0gXCJcIiA/IEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SIDogXCJcIikgKyBjdXJyZW50O1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiBCQUdHQUdFX01BWF9UT1RBTF9MRU5HVEggPyBoVmFsdWUgOiB2YWx1ZTtcbiAgfSwgXCJcIik7XG59XG5fX25hbWUoc2VyaWFsaXplS2V5UGFpcnMsIFwic2VyaWFsaXplS2V5UGFpcnNcIik7XG5mdW5jdGlvbiBnZXRLZXlQYWlycyhiYWdnYWdlKSB7XG4gIHJldHVybiBiYWdnYWdlLmdldEFsbEVudHJpZXMoKS5tYXAoZnVuY3Rpb24oX2EzKSB7XG4gICAgdmFyIF9iMiA9IF9fcmVhZChfYTMsIDIpLCBrZXkgPSBfYjJbMF0sIHZhbHVlID0gX2IyWzFdO1xuICAgIHZhciBlbnRyeSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUudmFsdWUpO1xuICAgIGlmICh2YWx1ZS5tZXRhZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICBlbnRyeSArPSBCQUdHQUdFX1BST1BFUlRJRVNfU0VQQVJBVE9SICsgdmFsdWUubWV0YWRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9KTtcbn1cbl9fbmFtZShnZXRLZXlQYWlycywgXCJnZXRLZXlQYWlyc1wiKTtcbmZ1bmN0aW9uIHBhcnNlUGFpcktleVZhbHVlKGVudHJ5KSB7XG4gIHZhciB2YWx1ZVByb3BzID0gZW50cnkuc3BsaXQoQkFHR0FHRV9QUk9QRVJUSUVTX1NFUEFSQVRPUik7XG4gIGlmICh2YWx1ZVByb3BzLmxlbmd0aCA8PSAwKVxuICAgIHJldHVybjtcbiAgdmFyIGtleVBhaXJQYXJ0ID0gdmFsdWVQcm9wcy5zaGlmdCgpO1xuICBpZiAoIWtleVBhaXJQYXJ0KVxuICAgIHJldHVybjtcbiAgdmFyIGtleVBhaXIgPSBrZXlQYWlyUGFydC5zcGxpdChCQUdHQUdFX0tFWV9QQUlSX1NFUEFSQVRPUik7XG4gIGlmIChrZXlQYWlyLmxlbmd0aCAhPT0gMilcbiAgICByZXR1cm47XG4gIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5UGFpclswXS50cmltKCkpO1xuICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5UGFpclsxXS50cmltKCkpO1xuICB2YXIgbWV0YWRhdGE7XG4gIGlmICh2YWx1ZVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICBtZXRhZGF0YSA9IGJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZyh2YWx1ZVByb3BzLmpvaW4oQkFHR0FHRV9QUk9QRVJUSUVTX1NFUEFSQVRPUikpO1xuICB9XG4gIHJldHVybiB7IGtleSwgdmFsdWUsIG1ldGFkYXRhIH07XG59XG5fX25hbWUocGFyc2VQYWlyS2V5VmFsdWUsIFwicGFyc2VQYWlyS2V5VmFsdWVcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vYmFnZ2FnZS9wcm9wYWdhdGlvbi9XM0NCYWdnYWdlUHJvcGFnYXRvci5qc1xudmFyIFczQ0JhZ2dhZ2VQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFczQ0JhZ2dhZ2VQcm9wYWdhdG9yMigpIHtcbiAgfVxuICBfX25hbWUoVzNDQmFnZ2FnZVByb3BhZ2F0b3IyLCBcIlczQ0JhZ2dhZ2VQcm9wYWdhdG9yXCIpO1xuICBXM0NCYWdnYWdlUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQzLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICB2YXIgYmFnZ2FnZSA9IHByb3BhZ2F0aW9uLmdldEJhZ2dhZ2UoY29udGV4dDMpO1xuICAgIGlmICghYmFnZ2FnZSB8fCBpc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQzKSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIga2V5UGFpcnMgPSBnZXRLZXlQYWlycyhiYWdnYWdlKS5maWx0ZXIoZnVuY3Rpb24ocGFpcikge1xuICAgICAgcmV0dXJuIHBhaXIubGVuZ3RoIDw9IEJBR0dBR0VfTUFYX1BFUl9OQU1FX1ZBTFVFX1BBSVJTO1xuICAgIH0pLnNsaWNlKDAsIEJBR0dBR0VfTUFYX05BTUVfVkFMVUVfUEFJUlMpO1xuICAgIHZhciBoZWFkZXJWYWx1ZSA9IHNlcmlhbGl6ZUtleVBhaXJzKGtleVBhaXJzKTtcbiAgICBpZiAoaGVhZGVyVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBCQUdHQUdFX0hFQURFUiwgaGVhZGVyVmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgVzNDQmFnZ2FnZVByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIHZhciBoZWFkZXJWYWx1ZSA9IGdldHRlci5nZXQoY2FycmllciwgQkFHR0FHRV9IRUFERVIpO1xuICAgIHZhciBiYWdnYWdlU3RyaW5nID0gQXJyYXkuaXNBcnJheShoZWFkZXJWYWx1ZSkgPyBoZWFkZXJWYWx1ZS5qb2luKEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SKSA6IGhlYWRlclZhbHVlO1xuICAgIGlmICghYmFnZ2FnZVN0cmluZylcbiAgICAgIHJldHVybiBjb250ZXh0MztcbiAgICB2YXIgYmFnZ2FnZSA9IHt9O1xuICAgIGlmIChiYWdnYWdlU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIH1cbiAgICB2YXIgcGFpcnMgPSBiYWdnYWdlU3RyaW5nLnNwbGl0KEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SKTtcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICB2YXIga2V5UGFpciA9IHBhcnNlUGFpcktleVZhbHVlKGVudHJ5KTtcbiAgICAgIGlmIChrZXlQYWlyKSB7XG4gICAgICAgIHZhciBiYWdnYWdlRW50cnkgPSB7IHZhbHVlOiBrZXlQYWlyLnZhbHVlIH07XG4gICAgICAgIGlmIChrZXlQYWlyLm1ldGFkYXRhKSB7XG4gICAgICAgICAgYmFnZ2FnZUVudHJ5Lm1ldGFkYXRhID0ga2V5UGFpci5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBiYWdnYWdlW2tleVBhaXIua2V5XSA9IGJhZ2dhZ2VFbnRyeTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmVudHJpZXMoYmFnZ2FnZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29udGV4dDM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wYWdhdGlvbi5zZXRCYWdnYWdlKGNvbnRleHQzLCBwcm9wYWdhdGlvbi5jcmVhdGVCYWdnYWdlKGJhZ2dhZ2UpKTtcbiAgfTtcbiAgVzNDQmFnZ2FnZVByb3BhZ2F0b3IyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW0JBR0dBR0VfSEVBREVSXTtcbiAgfTtcbiAgcmV0dXJuIFczQ0JhZ2dhZ2VQcm9wYWdhdG9yMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vYXR0cmlidXRlcy5qc1xudmFyIF9fdmFsdWVzID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZDIgPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIGUgPSB7IGVycm9yOiBlcnJvcjIgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xuZnVuY3Rpb24gc2FuaXRpemVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGVfMSwgX2EzO1xuICB2YXIgb3V0ID0ge307XG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcyAhPT0gXCJvYmplY3RcIiB8fCBhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXMoT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpLCBfYyA9IF9iMi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iMi5uZXh0KCkpIHtcbiAgICAgIHZhciBfZCA9IF9fcmVhZDIoX2MudmFsdWUsIDIpLCBrZXkgPSBfZFswXSwgdmFsID0gX2RbMV07XG4gICAgICBpZiAoIWlzQXR0cmlidXRlS2V5KGtleSkpIHtcbiAgICAgICAgZGlhZzIud2FybihcIkludmFsaWQgYXR0cmlidXRlIGtleTogXCIgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdHRyaWJ1dGVWYWx1ZSh2YWwpKSB7XG4gICAgICAgIGRpYWcyLndhcm4oXCJJbnZhbGlkIGF0dHJpYnV0ZSB2YWx1ZSBzZXQgZm9yIGtleTogXCIgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgb3V0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMyA9IF9iMi5yZXR1cm4pKVxuICAgICAgICBfYTMuY2FsbChfYjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKVxuICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5fX25hbWUoc2FuaXRpemVBdHRyaWJ1dGVzLCBcInNhbml0aXplQXR0cmlidXRlc1wiKTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlS2V5KGtleSkge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBrZXkubGVuZ3RoID4gMDtcbn1cbl9fbmFtZShpc0F0dHJpYnV0ZUtleSwgXCJpc0F0dHJpYnV0ZUtleVwiKTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlVmFsdWUodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gaXNIb21vZ2VuZW91c0F0dHJpYnV0ZVZhbHVlQXJyYXkodmFsKTtcbiAgfVxuICByZXR1cm4gaXNWYWxpZFByaW1pdGl2ZUF0dHJpYnV0ZVZhbHVlKHZhbCk7XG59XG5fX25hbWUoaXNBdHRyaWJ1dGVWYWx1ZSwgXCJpc0F0dHJpYnV0ZVZhbHVlXCIpO1xuZnVuY3Rpb24gaXNIb21vZ2VuZW91c0F0dHJpYnV0ZVZhbHVlQXJyYXkoYXJyKSB7XG4gIHZhciBlXzIsIF9hMztcbiAgdmFyIHR5cGU7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgYXJyXzEgPSBfX3ZhbHVlcyhhcnIpLCBhcnJfMV8xID0gYXJyXzEubmV4dCgpOyAhYXJyXzFfMS5kb25lOyBhcnJfMV8xID0gYXJyXzEubmV4dCgpKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGFycl8xXzEudmFsdWU7XG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFByaW1pdGl2ZUF0dHJpYnV0ZVZhbHVlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGVvZiBlbGVtZW50O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gdHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFycl8xXzEgJiYgIWFycl8xXzEuZG9uZSAmJiAoX2EzID0gYXJyXzEucmV0dXJuKSlcbiAgICAgICAgX2EzLmNhbGwoYXJyXzEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8yKVxuICAgICAgICB0aHJvdyBlXzIuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuX19uYW1lKGlzSG9tb2dlbmVvdXNBdHRyaWJ1dGVWYWx1ZUFycmF5LCBcImlzSG9tb2dlbmVvdXNBdHRyaWJ1dGVWYWx1ZUFycmF5XCIpO1xuZnVuY3Rpb24gaXNWYWxpZFByaW1pdGl2ZUF0dHJpYnV0ZVZhbHVlKHZhbCkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5fX25hbWUoaXNWYWxpZFByaW1pdGl2ZUF0dHJpYnV0ZVZhbHVlLCBcImlzVmFsaWRQcmltaXRpdmVBdHRyaWJ1dGVWYWx1ZVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vbG9nZ2luZy1lcnJvci1oYW5kbGVyLmpzXG5mdW5jdGlvbiBsb2dnaW5nRXJyb3JIYW5kbGVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXgpIHtcbiAgICBkaWFnMi5lcnJvcihzdHJpbmdpZnlFeGNlcHRpb24oZXgpKTtcbiAgfTtcbn1cbl9fbmFtZShsb2dnaW5nRXJyb3JIYW5kbGVyLCBcImxvZ2dpbmdFcnJvckhhbmRsZXJcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlFeGNlcHRpb24oZXgpIHtcbiAgaWYgKHR5cGVvZiBleCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBleDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZmxhdHRlbkV4Y2VwdGlvbihleCkpO1xuICB9XG59XG5fX25hbWUoc3RyaW5naWZ5RXhjZXB0aW9uLCBcInN0cmluZ2lmeUV4Y2VwdGlvblwiKTtcbmZ1bmN0aW9uIGZsYXR0ZW5FeGNlcHRpb24oZXgpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgY3VycmVudCA9IGV4O1xuICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICBpZiAocmVzdWx0W3Byb3BlcnR5TmFtZV0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciB2YWx1ZSA9IGN1cnJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXN1bHRbcHJvcGVydHlOYW1lXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKGZsYXR0ZW5FeGNlcHRpb24sIFwiZmxhdHRlbkV4Y2VwdGlvblwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vZ2xvYmFsLWVycm9yLWhhbmRsZXIuanNcbnZhciBkZWxlZ2F0ZUhhbmRsZXIgPSBsb2dnaW5nRXJyb3JIYW5kbGVyKCk7XG5mdW5jdGlvbiBnbG9iYWxFcnJvckhhbmRsZXIoZXgpIHtcbiAgdHJ5IHtcbiAgICBkZWxlZ2F0ZUhhbmRsZXIoZXgpO1xuICB9IGNhdGNoIChfYTMpIHtcbiAgfVxufVxuX19uYW1lKGdsb2JhbEVycm9ySGFuZGxlciwgXCJnbG9iYWxFcnJvckhhbmRsZXJcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9lbnZpcm9ubWVudC5qc1xudmFyIG9zMiA9IF9fdG9FU00ocmVxdWlyZShcIm9zXCIpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9zYW1wbGluZy5qc1xudmFyIFRyYWNlc1NhbXBsZXJWYWx1ZXM7XG4oZnVuY3Rpb24oVHJhY2VzU2FtcGxlclZhbHVlczIpIHtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJBbHdheXNPZmZcIl0gPSBcImFsd2F5c19vZmZcIjtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJBbHdheXNPblwiXSA9IFwiYWx3YXlzX29uXCI7XG4gIFRyYWNlc1NhbXBsZXJWYWx1ZXMyW1wiUGFyZW50QmFzZWRBbHdheXNPZmZcIl0gPSBcInBhcmVudGJhc2VkX2Fsd2F5c19vZmZcIjtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJQYXJlbnRCYXNlZEFsd2F5c09uXCJdID0gXCJwYXJlbnRiYXNlZF9hbHdheXNfb25cIjtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJQYXJlbnRCYXNlZFRyYWNlSWRSYXRpb1wiXSA9IFwicGFyZW50YmFzZWRfdHJhY2VpZHJhdGlvXCI7XG4gIFRyYWNlc1NhbXBsZXJWYWx1ZXMyW1wiVHJhY2VJZFJhdGlvXCJdID0gXCJ0cmFjZWlkcmF0aW9cIjtcbn0pKFRyYWNlc1NhbXBsZXJWYWx1ZXMgfHwgKFRyYWNlc1NhbXBsZXJWYWx1ZXMgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL2Jyb3dzZXIvZ2xvYmFsVGhpcy5qc1xudmFyIF9nbG9iYWxUaGlzMiA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDoge307XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvZW52aXJvbm1lbnQuanNcbnZhciBERUZBVUxUX0xJU1RfU0VQQVJBVE9SID0gXCIsXCI7XG52YXIgRU5WSVJPTk1FTlRfTlVNQkVSU19LRVlTID0gW1xuICBcIk9URUxfQlNQX0VYUE9SVF9USU1FT1VUXCIsXG4gIFwiT1RFTF9CU1BfTUFYX0VYUE9SVF9CQVRDSF9TSVpFXCIsXG4gIFwiT1RFTF9CU1BfTUFYX1FVRVVFX1NJWkVcIixcbiAgXCJPVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWVwiLFxuICBcIk9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVFwiLFxuICBcIk9URUxfQVRUUklCVVRFX0NPVU5UX0xJTUlUXCIsXG4gIFwiT1RFTF9TUEFOX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVRcIixcbiAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX0NPVU5UX0xJTUlUXCIsXG4gIFwiT1RFTF9TUEFOX0VWRU5UX0NPVU5UX0xJTUlUXCIsXG4gIFwiT1RFTF9TUEFOX0xJTktfQ09VTlRfTElNSVRcIixcbiAgXCJPVEVMX0VYUE9SVEVSX09UTFBfVElNRU9VVFwiLFxuICBcIk9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfVElNRU9VVFwiLFxuICBcIk9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX1RJTUVPVVRcIixcbiAgXCJPVEVMX0VYUE9SVEVSX0pBRUdFUl9BR0VOVF9QT1JUXCJcbl07XG5mdW5jdGlvbiBpc0VudlZhckFOdW1iZXIoa2V5KSB7XG4gIHJldHVybiBFTlZJUk9OTUVOVF9OVU1CRVJTX0tFWVMuaW5kZXhPZihrZXkpID4gLTE7XG59XG5fX25hbWUoaXNFbnZWYXJBTnVtYmVyLCBcImlzRW52VmFyQU51bWJlclwiKTtcbnZhciBFTlZJUk9OTUVOVF9MSVNUU19LRVlTID0gW1xuICBcIk9URUxfTk9fUEFUQ0hfTU9EVUxFU1wiLFxuICBcIk9URUxfUFJPUEFHQVRPUlNcIlxuXTtcbmZ1bmN0aW9uIGlzRW52VmFyQUxpc3Qoa2V5KSB7XG4gIHJldHVybiBFTlZJUk9OTUVOVF9MSVNUU19LRVlTLmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuX19uYW1lKGlzRW52VmFyQUxpc3QsIFwiaXNFbnZWYXJBTGlzdFwiKTtcbnZhciBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQgPSBJbmZpbml0eTtcbnZhciBERUZBVUxUX0FUVFJJQlVURV9DT1VOVF9MSU1JVCA9IDEyODtcbnZhciBERUZBVUxUX0VOVklST05NRU5UID0ge1xuICBDT05UQUlORVJfTkFNRTogXCJcIixcbiAgRUNTX0NPTlRBSU5FUl9NRVRBREFUQV9VUklfVjQ6IFwiXCIsXG4gIEVDU19DT05UQUlORVJfTUVUQURBVEFfVVJJOiBcIlwiLFxuICBIT1NUTkFNRTogXCJcIixcbiAgS1VCRVJORVRFU19TRVJWSUNFX0hPU1Q6IFwiXCIsXG4gIE5BTUVTUEFDRTogXCJcIixcbiAgT1RFTF9CU1BfRVhQT1JUX1RJTUVPVVQ6IDNlNCxcbiAgT1RFTF9CU1BfTUFYX0VYUE9SVF9CQVRDSF9TSVpFOiA1MTIsXG4gIE9URUxfQlNQX01BWF9RVUVVRV9TSVpFOiAyMDQ4LFxuICBPVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWTogNWUzLFxuICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9BR0VOVF9IT1NUOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9BR0VOVF9QT1JUOiA2ODMyLFxuICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9FTkRQT0lOVDogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9KQUVHRVJfUEFTU1dPUkQ6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfSkFFR0VSX1VTRVI6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9FTkRQT0lOVDogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19FTkRQT0lOVDogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfRU5EUE9JTlQ6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9IRUFERVJTOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0hFQURFUlM6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0hFQURFUlM6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9USU1FT1VUOiAxZTQsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfVElNRU9VVDogMWU0LFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19USU1FT1VUOiAxZTQsXG4gIE9URUxfRVhQT1JURVJfWklQS0lOX0VORFBPSU5UOiBcImh0dHA6Ly9sb2NhbGhvc3Q6OTQxMS9hcGkvdjIvc3BhbnNcIixcbiAgT1RFTF9MT0dfTEVWRUw6IERpYWdMb2dMZXZlbC5JTkZPLFxuICBPVEVMX05PX1BBVENIX01PRFVMRVM6IFtdLFxuICBPVEVMX1BST1BBR0FUT1JTOiBbXCJ0cmFjZWNvbnRleHRcIiwgXCJiYWdnYWdlXCJdLFxuICBPVEVMX1JFU09VUkNFX0FUVFJJQlVURVM6IFwiXCIsXG4gIE9URUxfU0VSVklDRV9OQU1FOiBcIlwiLFxuICBPVEVMX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQ6IERFRkFVTFRfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgT1RFTF9BVFRSSUJVVEVfQ09VTlRfTElNSVQ6IERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlULFxuICBPVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlULFxuICBPVEVMX1NQQU5fQVRUUklCVVRFX0NPVU5UX0xJTUlUOiBERUZBVUxUX0FUVFJJQlVURV9DT1VOVF9MSU1JVCxcbiAgT1RFTF9TUEFOX0VWRU5UX0NPVU5UX0xJTUlUOiAxMjgsXG4gIE9URUxfU1BBTl9MSU5LX0NPVU5UX0xJTUlUOiAxMjgsXG4gIE9URUxfVFJBQ0VTX0VYUE9SVEVSOiBcIm5vbmVcIixcbiAgT1RFTF9UUkFDRVNfU0FNUExFUjogVHJhY2VzU2FtcGxlclZhbHVlcy5QYXJlbnRCYXNlZEFsd2F5c09uLFxuICBPVEVMX1RSQUNFU19TQU1QTEVSX0FSRzogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0lOU0VDVVJFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0lOU0VDVVJFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19JTlNFQ1VSRTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0NFUlRJRklDQVRFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0NFUlRJRklDQVRFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19DRVJUSUZJQ0FURTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0NPTVBSRVNTSU9OOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0NPTVBSRVNTSU9OOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19DT01QUkVTU0lPTjogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0NMSUVOVF9LRVk6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ0xJRU5UX0tFWTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfQ0xJRU5UX0tFWTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0NMSUVOVF9DRVJUSUZJQ0FURTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19DTElFTlRfQ0VSVElGSUNBVEU6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0NMSUVOVF9DRVJUSUZJQ0FURTogXCJcIlxufTtcbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKG5hbWUsIGVudmlyb25tZW50LCB2YWx1ZXMsIG1pbjIsIG1heDIpIHtcbiAgaWYgKG1pbjIgPT09IHZvaWQgMCkge1xuICAgIG1pbjIgPSAtSW5maW5pdHk7XG4gIH1cbiAgaWYgKG1heDIgPT09IHZvaWQgMCkge1xuICAgIG1heDIgPSBJbmZpbml0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlc1tuYW1lXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciB2YWx1ZSA9IE51bWJlcih2YWx1ZXNbbmFtZV0pO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUgPCBtaW4yKSB7XG4gICAgICAgIGVudmlyb25tZW50W25hbWVdID0gbWluMjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgyKSB7XG4gICAgICAgIGVudmlyb25tZW50W25hbWVdID0gbWF4MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudmlyb25tZW50W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5fX25hbWUocGFyc2VOdW1iZXIsIFwicGFyc2VOdW1iZXJcIik7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ0xpc3QobmFtZSwgb3V0cHV0LCBpbnB1dCwgc2VwYXJhdG9yKSB7XG4gIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgIHNlcGFyYXRvciA9IERFRkFVTFRfTElTVF9TRVBBUkFUT1I7XG4gIH1cbiAgdmFyIGdpdmVuVmFsdWUgPSBpbnB1dFtuYW1lXTtcbiAgaWYgKHR5cGVvZiBnaXZlblZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3V0cHV0W25hbWVdID0gZ2l2ZW5WYWx1ZS5zcGxpdChzZXBhcmF0b3IpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi50cmltKCk7XG4gICAgfSk7XG4gIH1cbn1cbl9fbmFtZShwYXJzZVN0cmluZ0xpc3QsIFwicGFyc2VTdHJpbmdMaXN0XCIpO1xudmFyIGxvZ0xldmVsTWFwID0ge1xuICBBTEw6IERpYWdMb2dMZXZlbC5BTEwsXG4gIFZFUkJPU0U6IERpYWdMb2dMZXZlbC5WRVJCT1NFLFxuICBERUJVRzogRGlhZ0xvZ0xldmVsLkRFQlVHLFxuICBJTkZPOiBEaWFnTG9nTGV2ZWwuSU5GTyxcbiAgV0FSTjogRGlhZ0xvZ0xldmVsLldBUk4sXG4gIEVSUk9SOiBEaWFnTG9nTGV2ZWwuRVJST1IsXG4gIE5PTkU6IERpYWdMb2dMZXZlbC5OT05FXG59O1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWxGcm9tRW52KGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcykge1xuICB2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciB0aGVMZXZlbCA9IGxvZ0xldmVsTWFwW3ZhbHVlLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICh0aGVMZXZlbCAhPSBudWxsKSB7XG4gICAgICBlbnZpcm9ubWVudFtrZXldID0gdGhlTGV2ZWw7XG4gICAgfVxuICB9XG59XG5fX25hbWUoc2V0TG9nTGV2ZWxGcm9tRW52LCBcInNldExvZ0xldmVsRnJvbUVudlwiKTtcbmZ1bmN0aW9uIHBhcnNlRW52aXJvbm1lbnQodmFsdWVzKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9IHt9O1xuICBmb3IgKHZhciBlbnYyIGluIERFRkFVTFRfRU5WSVJPTk1FTlQpIHtcbiAgICB2YXIga2V5ID0gZW52MjtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIk9URUxfTE9HX0xFVkVMXCI6XG4gICAgICAgIHNldExvZ0xldmVsRnJvbUVudihrZXksIGVudmlyb25tZW50LCB2YWx1ZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc0VudlZhckFOdW1iZXIoa2V5KSkge1xuICAgICAgICAgIHBhcnNlTnVtYmVyKGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbnZWYXJBTGlzdChrZXkpKSB7XG4gICAgICAgICAgcGFyc2VTdHJpbmdMaXN0KGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnZpcm9ubWVudDtcbn1cbl9fbmFtZShwYXJzZUVudmlyb25tZW50LCBcInBhcnNlRW52aXJvbm1lbnRcIik7XG5mdW5jdGlvbiBnZXRFbnZXaXRob3V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHBhcnNlRW52aXJvbm1lbnQocHJvY2Vzcy5lbnYpIDogcGFyc2VFbnZpcm9ubWVudChfZ2xvYmFsVGhpczIpO1xufVxuX19uYW1lKGdldEVudldpdGhvdXREZWZhdWx0cywgXCJnZXRFbnZXaXRob3V0RGVmYXVsdHNcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9lbnZpcm9ubWVudC5qc1xuZnVuY3Rpb24gZ2V0RW52KCkge1xuICB2YXIgcHJvY2Vzc0VudiA9IHBhcnNlRW52aXJvbm1lbnQocHJvY2Vzcy5lbnYpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgSE9TVE5BTUU6IG9zMi5ob3N0bmFtZSgpXG4gIH0sIERFRkFVTFRfRU5WSVJPTk1FTlQsIHByb2Nlc3NFbnYpO1xufVxuX19uYW1lKGdldEVudiwgXCJnZXRFbnZcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9nbG9iYWxUaGlzLmpzXG52YXIgX2dsb2JhbFRoaXMzID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxUaGlzIDogZ2xvYmFsO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvaGV4LXRvLWJhc2U2NC5qc1xudmFyIGJ1ZjggPSBCdWZmZXIuYWxsb2MoOCk7XG52YXIgYnVmMTYgPSBCdWZmZXIuYWxsb2MoMTYpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmFuZG9tSWRHZW5lcmF0b3IuanNcbnZhciBTUEFOX0lEX0JZVEVTID0gODtcbnZhciBUUkFDRV9JRF9CWVRFUyA9IDE2O1xudmFyIFJhbmRvbUlkR2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJhbmRvbUlkR2VuZXJhdG9yMygpIHtcbiAgICB0aGlzLmdlbmVyYXRlVHJhY2VJZCA9IGdldElkR2VuZXJhdG9yKFRSQUNFX0lEX0JZVEVTKTtcbiAgICB0aGlzLmdlbmVyYXRlU3BhbklkID0gZ2V0SWRHZW5lcmF0b3IoU1BBTl9JRF9CWVRFUyk7XG4gIH1cbiAgX19uYW1lKFJhbmRvbUlkR2VuZXJhdG9yMywgXCJSYW5kb21JZEdlbmVyYXRvclwiKTtcbiAgcmV0dXJuIFJhbmRvbUlkR2VuZXJhdG9yMztcbn0oKTtcbnZhciBTSEFSRURfQlVGRkVSID0gQnVmZmVyLmFsbG9jVW5zYWZlKFRSQUNFX0lEX0JZVEVTKTtcbmZ1bmN0aW9uIGdldElkR2VuZXJhdG9yKGJ5dGVzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcyAvIDQ7IGkrKykge1xuICAgICAgU0hBUkVEX0JVRkZFUi53cml0ZVVJbnQzMkJFKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikgPj4+IDAsIGkgKiA0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICBpZiAoU0hBUkVEX0JVRkZFUltpXSA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGJ5dGVzIC0gMSkge1xuICAgICAgICBTSEFSRURfQlVGRkVSW2J5dGVzIC0gMV0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU0hBUkVEX0JVRkZFUi50b1N0cmluZyhcImhleFwiLCAwLCBieXRlcyk7XG4gIH0sIFwiZ2VuZXJhdGVJZFwiKTtcbn1cbl9fbmFtZShnZXRJZEdlbmVyYXRvciwgXCJnZXRJZEdlbmVyYXRvclwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3BlcmZvcm1hbmNlLmpzXG52YXIgaW1wb3J0X3BlcmZfaG9va3MgPSByZXF1aXJlKFwicGVyZl9ob29rc1wiKTtcbnZhciBvdHBlcmZvcm1hbmNlID0gaW1wb3J0X3BlcmZfaG9va3MucGVyZm9ybWFuY2U7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdmVyc2lvbi5qc1xudmFyIFZFUlNJT04yID0gXCIxLjYuMFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2VtYW50aWMtY29udmVudGlvbnNAMS42LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2J1aWxkL2VzbS90cmFjZS9TZW1hbnRpY0F0dHJpYnV0ZXMuanNcbnZhciBTZW1hbnRpY0F0dHJpYnV0ZXMgPSB7XG4gIEFXU19MQU1CREFfSU5WT0tFRF9BUk46IFwiYXdzLmxhbWJkYS5pbnZva2VkX2FyblwiLFxuICBEQl9TWVNURU06IFwiZGIuc3lzdGVtXCIsXG4gIERCX0NPTk5FQ1RJT05fU1RSSU5HOiBcImRiLmNvbm5lY3Rpb25fc3RyaW5nXCIsXG4gIERCX1VTRVI6IFwiZGIudXNlclwiLFxuICBEQl9KREJDX0RSSVZFUl9DTEFTU05BTUU6IFwiZGIuamRiYy5kcml2ZXJfY2xhc3NuYW1lXCIsXG4gIERCX05BTUU6IFwiZGIubmFtZVwiLFxuICBEQl9TVEFURU1FTlQ6IFwiZGIuc3RhdGVtZW50XCIsXG4gIERCX09QRVJBVElPTjogXCJkYi5vcGVyYXRpb25cIixcbiAgREJfTVNTUUxfSU5TVEFOQ0VfTkFNRTogXCJkYi5tc3NxbC5pbnN0YW5jZV9uYW1lXCIsXG4gIERCX0NBU1NBTkRSQV9LRVlTUEFDRTogXCJkYi5jYXNzYW5kcmEua2V5c3BhY2VcIixcbiAgREJfQ0FTU0FORFJBX1BBR0VfU0laRTogXCJkYi5jYXNzYW5kcmEucGFnZV9zaXplXCIsXG4gIERCX0NBU1NBTkRSQV9DT05TSVNURU5DWV9MRVZFTDogXCJkYi5jYXNzYW5kcmEuY29uc2lzdGVuY3lfbGV2ZWxcIixcbiAgREJfQ0FTU0FORFJBX1RBQkxFOiBcImRiLmNhc3NhbmRyYS50YWJsZVwiLFxuICBEQl9DQVNTQU5EUkFfSURFTVBPVEVOQ0U6IFwiZGIuY2Fzc2FuZHJhLmlkZW1wb3RlbmNlXCIsXG4gIERCX0NBU1NBTkRSQV9TUEVDVUxBVElWRV9FWEVDVVRJT05fQ09VTlQ6IFwiZGIuY2Fzc2FuZHJhLnNwZWN1bGF0aXZlX2V4ZWN1dGlvbl9jb3VudFwiLFxuICBEQl9DQVNTQU5EUkFfQ09PUkRJTkFUT1JfSUQ6IFwiZGIuY2Fzc2FuZHJhLmNvb3JkaW5hdG9yLmlkXCIsXG4gIERCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQzogXCJkYi5jYXNzYW5kcmEuY29vcmRpbmF0b3IuZGNcIixcbiAgREJfSEJBU0VfTkFNRVNQQUNFOiBcImRiLmhiYXNlLm5hbWVzcGFjZVwiLFxuICBEQl9SRURJU19EQVRBQkFTRV9JTkRFWDogXCJkYi5yZWRpcy5kYXRhYmFzZV9pbmRleFwiLFxuICBEQl9NT05HT0RCX0NPTExFQ1RJT046IFwiZGIubW9uZ29kYi5jb2xsZWN0aW9uXCIsXG4gIERCX1NRTF9UQUJMRTogXCJkYi5zcWwudGFibGVcIixcbiAgRVhDRVBUSU9OX1RZUEU6IFwiZXhjZXB0aW9uLnR5cGVcIixcbiAgRVhDRVBUSU9OX01FU1NBR0U6IFwiZXhjZXB0aW9uLm1lc3NhZ2VcIixcbiAgRVhDRVBUSU9OX1NUQUNLVFJBQ0U6IFwiZXhjZXB0aW9uLnN0YWNrdHJhY2VcIixcbiAgRVhDRVBUSU9OX0VTQ0FQRUQ6IFwiZXhjZXB0aW9uLmVzY2FwZWRcIixcbiAgRkFBU19UUklHR0VSOiBcImZhYXMudHJpZ2dlclwiLFxuICBGQUFTX0VYRUNVVElPTjogXCJmYWFzLmV4ZWN1dGlvblwiLFxuICBGQUFTX0RPQ1VNRU5UX0NPTExFQ1RJT046IFwiZmFhcy5kb2N1bWVudC5jb2xsZWN0aW9uXCIsXG4gIEZBQVNfRE9DVU1FTlRfT1BFUkFUSU9OOiBcImZhYXMuZG9jdW1lbnQub3BlcmF0aW9uXCIsXG4gIEZBQVNfRE9DVU1FTlRfVElNRTogXCJmYWFzLmRvY3VtZW50LnRpbWVcIixcbiAgRkFBU19ET0NVTUVOVF9OQU1FOiBcImZhYXMuZG9jdW1lbnQubmFtZVwiLFxuICBGQUFTX1RJTUU6IFwiZmFhcy50aW1lXCIsXG4gIEZBQVNfQ1JPTjogXCJmYWFzLmNyb25cIixcbiAgRkFBU19DT0xEU1RBUlQ6IFwiZmFhcy5jb2xkc3RhcnRcIixcbiAgRkFBU19JTlZPS0VEX05BTUU6IFwiZmFhcy5pbnZva2VkX25hbWVcIixcbiAgRkFBU19JTlZPS0VEX1BST1ZJREVSOiBcImZhYXMuaW52b2tlZF9wcm92aWRlclwiLFxuICBGQUFTX0lOVk9LRURfUkVHSU9OOiBcImZhYXMuaW52b2tlZF9yZWdpb25cIixcbiAgTkVUX1RSQU5TUE9SVDogXCJuZXQudHJhbnNwb3J0XCIsXG4gIE5FVF9QRUVSX0lQOiBcIm5ldC5wZWVyLmlwXCIsXG4gIE5FVF9QRUVSX1BPUlQ6IFwibmV0LnBlZXIucG9ydFwiLFxuICBORVRfUEVFUl9OQU1FOiBcIm5ldC5wZWVyLm5hbWVcIixcbiAgTkVUX0hPU1RfSVA6IFwibmV0Lmhvc3QuaXBcIixcbiAgTkVUX0hPU1RfUE9SVDogXCJuZXQuaG9zdC5wb3J0XCIsXG4gIE5FVF9IT1NUX05BTUU6IFwibmV0Lmhvc3QubmFtZVwiLFxuICBORVRfSE9TVF9DT05ORUNUSU9OX1RZUEU6IFwibmV0Lmhvc3QuY29ubmVjdGlvbi50eXBlXCIsXG4gIE5FVF9IT1NUX0NPTk5FQ1RJT05fU1VCVFlQRTogXCJuZXQuaG9zdC5jb25uZWN0aW9uLnN1YnR5cGVcIixcbiAgTkVUX0hPU1RfQ0FSUklFUl9OQU1FOiBcIm5ldC5ob3N0LmNhcnJpZXIubmFtZVwiLFxuICBORVRfSE9TVF9DQVJSSUVSX01DQzogXCJuZXQuaG9zdC5jYXJyaWVyLm1jY1wiLFxuICBORVRfSE9TVF9DQVJSSUVSX01OQzogXCJuZXQuaG9zdC5jYXJyaWVyLm1uY1wiLFxuICBORVRfSE9TVF9DQVJSSUVSX0lDQzogXCJuZXQuaG9zdC5jYXJyaWVyLmljY1wiLFxuICBQRUVSX1NFUlZJQ0U6IFwicGVlci5zZXJ2aWNlXCIsXG4gIEVORFVTRVJfSUQ6IFwiZW5kdXNlci5pZFwiLFxuICBFTkRVU0VSX1JPTEU6IFwiZW5kdXNlci5yb2xlXCIsXG4gIEVORFVTRVJfU0NPUEU6IFwiZW5kdXNlci5zY29wZVwiLFxuICBUSFJFQURfSUQ6IFwidGhyZWFkLmlkXCIsXG4gIFRIUkVBRF9OQU1FOiBcInRocmVhZC5uYW1lXCIsXG4gIENPREVfRlVOQ1RJT046IFwiY29kZS5mdW5jdGlvblwiLFxuICBDT0RFX05BTUVTUEFDRTogXCJjb2RlLm5hbWVzcGFjZVwiLFxuICBDT0RFX0ZJTEVQQVRIOiBcImNvZGUuZmlsZXBhdGhcIixcbiAgQ09ERV9MSU5FTk86IFwiY29kZS5saW5lbm9cIixcbiAgSFRUUF9NRVRIT0Q6IFwiaHR0cC5tZXRob2RcIixcbiAgSFRUUF9VUkw6IFwiaHR0cC51cmxcIixcbiAgSFRUUF9UQVJHRVQ6IFwiaHR0cC50YXJnZXRcIixcbiAgSFRUUF9IT1NUOiBcImh0dHAuaG9zdFwiLFxuICBIVFRQX1NDSEVNRTogXCJodHRwLnNjaGVtZVwiLFxuICBIVFRQX1NUQVRVU19DT0RFOiBcImh0dHAuc3RhdHVzX2NvZGVcIixcbiAgSFRUUF9GTEFWT1I6IFwiaHR0cC5mbGF2b3JcIixcbiAgSFRUUF9VU0VSX0FHRU5UOiBcImh0dHAudXNlcl9hZ2VudFwiLFxuICBIVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEg6IFwiaHR0cC5yZXF1ZXN0X2NvbnRlbnRfbGVuZ3RoXCIsXG4gIEhUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRUQ6IFwiaHR0cC5yZXF1ZXN0X2NvbnRlbnRfbGVuZ3RoX3VuY29tcHJlc3NlZFwiLFxuICBIVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIOiBcImh0dHAucmVzcG9uc2VfY29udGVudF9sZW5ndGhcIixcbiAgSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRUQ6IFwiaHR0cC5yZXNwb25zZV9jb250ZW50X2xlbmd0aF91bmNvbXByZXNzZWRcIixcbiAgSFRUUF9TRVJWRVJfTkFNRTogXCJodHRwLnNlcnZlcl9uYW1lXCIsXG4gIEhUVFBfUk9VVEU6IFwiaHR0cC5yb3V0ZVwiLFxuICBIVFRQX0NMSUVOVF9JUDogXCJodHRwLmNsaWVudF9pcFwiLFxuICBBV1NfRFlOQU1PREJfVEFCTEVfTkFNRVM6IFwiYXdzLmR5bmFtb2RiLnRhYmxlX25hbWVzXCIsXG4gIEFXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWTogXCJhd3MuZHluYW1vZGIuY29uc3VtZWRfY2FwYWNpdHlcIixcbiAgQVdTX0RZTkFNT0RCX0lURU1fQ09MTEVDVElPTl9NRVRSSUNTOiBcImF3cy5keW5hbW9kYi5pdGVtX2NvbGxlY3Rpb25fbWV0cmljc1wiLFxuICBBV1NfRFlOQU1PREJfUFJPVklTSU9ORURfUkVBRF9DQVBBQ0lUWTogXCJhd3MuZHluYW1vZGIucHJvdmlzaW9uZWRfcmVhZF9jYXBhY2l0eVwiLFxuICBBV1NfRFlOQU1PREJfUFJPVklTSU9ORURfV1JJVEVfQ0FQQUNJVFk6IFwiYXdzLmR5bmFtb2RiLnByb3Zpc2lvbmVkX3dyaXRlX2NhcGFjaXR5XCIsXG4gIEFXU19EWU5BTU9EQl9DT05TSVNURU5UX1JFQUQ6IFwiYXdzLmR5bmFtb2RiLmNvbnNpc3RlbnRfcmVhZFwiLFxuICBBV1NfRFlOQU1PREJfUFJPSkVDVElPTjogXCJhd3MuZHluYW1vZGIucHJvamVjdGlvblwiLFxuICBBV1NfRFlOQU1PREJfTElNSVQ6IFwiYXdzLmR5bmFtb2RiLmxpbWl0XCIsXG4gIEFXU19EWU5BTU9EQl9BVFRSSUJVVEVTX1RPX0dFVDogXCJhd3MuZHluYW1vZGIuYXR0cmlidXRlc190b19nZXRcIixcbiAgQVdTX0RZTkFNT0RCX0lOREVYX05BTUU6IFwiYXdzLmR5bmFtb2RiLmluZGV4X25hbWVcIixcbiAgQVdTX0RZTkFNT0RCX1NFTEVDVDogXCJhd3MuZHluYW1vZGIuc2VsZWN0XCIsXG4gIEFXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYRVM6IFwiYXdzLmR5bmFtb2RiLmdsb2JhbF9zZWNvbmRhcnlfaW5kZXhlc1wiLFxuICBBV1NfRFlOQU1PREJfTE9DQUxfU0VDT05EQVJZX0lOREVYRVM6IFwiYXdzLmR5bmFtb2RiLmxvY2FsX3NlY29uZGFyeV9pbmRleGVzXCIsXG4gIEFXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEU6IFwiYXdzLmR5bmFtb2RiLmV4Y2x1c2l2ZV9zdGFydF90YWJsZVwiLFxuICBBV1NfRFlOQU1PREJfVEFCTEVfQ09VTlQ6IFwiYXdzLmR5bmFtb2RiLnRhYmxlX2NvdW50XCIsXG4gIEFXU19EWU5BTU9EQl9TQ0FOX0ZPUldBUkQ6IFwiYXdzLmR5bmFtb2RiLnNjYW5fZm9yd2FyZFwiLFxuICBBV1NfRFlOQU1PREJfU0VHTUVOVDogXCJhd3MuZHluYW1vZGIuc2VnbWVudFwiLFxuICBBV1NfRFlOQU1PREJfVE9UQUxfU0VHTUVOVFM6IFwiYXdzLmR5bmFtb2RiLnRvdGFsX3NlZ21lbnRzXCIsXG4gIEFXU19EWU5BTU9EQl9DT1VOVDogXCJhd3MuZHluYW1vZGIuY291bnRcIixcbiAgQVdTX0RZTkFNT0RCX1NDQU5ORURfQ09VTlQ6IFwiYXdzLmR5bmFtb2RiLnNjYW5uZWRfY291bnRcIixcbiAgQVdTX0RZTkFNT0RCX0FUVFJJQlVURV9ERUZJTklUSU9OUzogXCJhd3MuZHluYW1vZGIuYXR0cmlidXRlX2RlZmluaXRpb25zXCIsXG4gIEFXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYX1VQREFURVM6IFwiYXdzLmR5bmFtb2RiLmdsb2JhbF9zZWNvbmRhcnlfaW5kZXhfdXBkYXRlc1wiLFxuICBNRVNTQUdJTkdfU1lTVEVNOiBcIm1lc3NhZ2luZy5zeXN0ZW1cIixcbiAgTUVTU0FHSU5HX0RFU1RJTkFUSU9OOiBcIm1lc3NhZ2luZy5kZXN0aW5hdGlvblwiLFxuICBNRVNTQUdJTkdfREVTVElOQVRJT05fS0lORDogXCJtZXNzYWdpbmcuZGVzdGluYXRpb25fa2luZFwiLFxuICBNRVNTQUdJTkdfVEVNUF9ERVNUSU5BVElPTjogXCJtZXNzYWdpbmcudGVtcF9kZXN0aW5hdGlvblwiLFxuICBNRVNTQUdJTkdfUFJPVE9DT0w6IFwibWVzc2FnaW5nLnByb3RvY29sXCIsXG4gIE1FU1NBR0lOR19QUk9UT0NPTF9WRVJTSU9OOiBcIm1lc3NhZ2luZy5wcm90b2NvbF92ZXJzaW9uXCIsXG4gIE1FU1NBR0lOR19VUkw6IFwibWVzc2FnaW5nLnVybFwiLFxuICBNRVNTQUdJTkdfTUVTU0FHRV9JRDogXCJtZXNzYWdpbmcubWVzc2FnZV9pZFwiLFxuICBNRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEOiBcIm1lc3NhZ2luZy5jb252ZXJzYXRpb25faWRcIixcbiAgTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9TSVpFX0JZVEVTOiBcIm1lc3NhZ2luZy5tZXNzYWdlX3BheWxvYWRfc2l6ZV9ieXRlc1wiLFxuICBNRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX0NPTVBSRVNTRURfU0laRV9CWVRFUzogXCJtZXNzYWdpbmcubWVzc2FnZV9wYXlsb2FkX2NvbXByZXNzZWRfc2l6ZV9ieXRlc1wiLFxuICBNRVNTQUdJTkdfT1BFUkFUSU9OOiBcIm1lc3NhZ2luZy5vcGVyYXRpb25cIixcbiAgTUVTU0FHSU5HX0NPTlNVTUVSX0lEOiBcIm1lc3NhZ2luZy5jb25zdW1lcl9pZFwiLFxuICBNRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVk6IFwibWVzc2FnaW5nLnJhYmJpdG1xLnJvdXRpbmdfa2V5XCIsXG4gIE1FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWTogXCJtZXNzYWdpbmcua2Fma2EubWVzc2FnZV9rZXlcIixcbiAgTUVTU0FHSU5HX0tBRktBX0NPTlNVTUVSX0dST1VQOiBcIm1lc3NhZ2luZy5rYWZrYS5jb25zdW1lcl9ncm91cFwiLFxuICBNRVNTQUdJTkdfS0FGS0FfQ0xJRU5UX0lEOiBcIm1lc3NhZ2luZy5rYWZrYS5jbGllbnRfaWRcIixcbiAgTUVTU0FHSU5HX0tBRktBX1BBUlRJVElPTjogXCJtZXNzYWdpbmcua2Fma2EucGFydGl0aW9uXCIsXG4gIE1FU1NBR0lOR19LQUZLQV9UT01CU1RPTkU6IFwibWVzc2FnaW5nLmthZmthLnRvbWJzdG9uZVwiLFxuICBSUENfU1lTVEVNOiBcInJwYy5zeXN0ZW1cIixcbiAgUlBDX1NFUlZJQ0U6IFwicnBjLnNlcnZpY2VcIixcbiAgUlBDX01FVEhPRDogXCJycGMubWV0aG9kXCIsXG4gIFJQQ19HUlBDX1NUQVRVU19DT0RFOiBcInJwYy5ncnBjLnN0YXR1c19jb2RlXCIsXG4gIFJQQ19KU09OUlBDX1ZFUlNJT046IFwicnBjLmpzb25ycGMudmVyc2lvblwiLFxuICBSUENfSlNPTlJQQ19SRVFVRVNUX0lEOiBcInJwYy5qc29ucnBjLnJlcXVlc3RfaWRcIixcbiAgUlBDX0pTT05SUENfRVJST1JfQ09ERTogXCJycGMuanNvbnJwYy5lcnJvcl9jb2RlXCIsXG4gIFJQQ19KU09OUlBDX0VSUk9SX01FU1NBR0U6IFwicnBjLmpzb25ycGMuZXJyb3JfbWVzc2FnZVwiLFxuICBNRVNTQUdFX1RZUEU6IFwibWVzc2FnZS50eXBlXCIsXG4gIE1FU1NBR0VfSUQ6IFwibWVzc2FnZS5pZFwiLFxuICBNRVNTQUdFX0NPTVBSRVNTRURfU0laRTogXCJtZXNzYWdlLmNvbXByZXNzZWRfc2l6ZVwiLFxuICBNRVNTQUdFX1VOQ09NUFJFU1NFRF9TSVpFOiBcIm1lc3NhZ2UudW5jb21wcmVzc2VkX3NpemVcIlxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3NlbWFudGljLWNvbnZlbnRpb25zQDEuNi4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9idWlsZC9lc20vcmVzb3VyY2UvU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuanNcbnZhciBTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcyA9IHtcbiAgQ0xPVURfUFJPVklERVI6IFwiY2xvdWQucHJvdmlkZXJcIixcbiAgQ0xPVURfQUNDT1VOVF9JRDogXCJjbG91ZC5hY2NvdW50LmlkXCIsXG4gIENMT1VEX1JFR0lPTjogXCJjbG91ZC5yZWdpb25cIixcbiAgQ0xPVURfQVZBSUxBQklMSVRZX1pPTkU6IFwiY2xvdWQuYXZhaWxhYmlsaXR5X3pvbmVcIixcbiAgQ0xPVURfUExBVEZPUk06IFwiY2xvdWQucGxhdGZvcm1cIixcbiAgQVdTX0VDU19DT05UQUlORVJfQVJOOiBcImF3cy5lY3MuY29udGFpbmVyLmFyblwiLFxuICBBV1NfRUNTX0NMVVNURVJfQVJOOiBcImF3cy5lY3MuY2x1c3Rlci5hcm5cIixcbiAgQVdTX0VDU19MQVVOQ0hUWVBFOiBcImF3cy5lY3MubGF1bmNodHlwZVwiLFxuICBBV1NfRUNTX1RBU0tfQVJOOiBcImF3cy5lY3MudGFzay5hcm5cIixcbiAgQVdTX0VDU19UQVNLX0ZBTUlMWTogXCJhd3MuZWNzLnRhc2suZmFtaWx5XCIsXG4gIEFXU19FQ1NfVEFTS19SRVZJU0lPTjogXCJhd3MuZWNzLnRhc2sucmV2aXNpb25cIixcbiAgQVdTX0VLU19DTFVTVEVSX0FSTjogXCJhd3MuZWtzLmNsdXN0ZXIuYXJuXCIsXG4gIEFXU19MT0dfR1JPVVBfTkFNRVM6IFwiYXdzLmxvZy5ncm91cC5uYW1lc1wiLFxuICBBV1NfTE9HX0dST1VQX0FSTlM6IFwiYXdzLmxvZy5ncm91cC5hcm5zXCIsXG4gIEFXU19MT0dfU1RSRUFNX05BTUVTOiBcImF3cy5sb2cuc3RyZWFtLm5hbWVzXCIsXG4gIEFXU19MT0dfU1RSRUFNX0FSTlM6IFwiYXdzLmxvZy5zdHJlYW0uYXJuc1wiLFxuICBDT05UQUlORVJfTkFNRTogXCJjb250YWluZXIubmFtZVwiLFxuICBDT05UQUlORVJfSUQ6IFwiY29udGFpbmVyLmlkXCIsXG4gIENPTlRBSU5FUl9SVU5USU1FOiBcImNvbnRhaW5lci5ydW50aW1lXCIsXG4gIENPTlRBSU5FUl9JTUFHRV9OQU1FOiBcImNvbnRhaW5lci5pbWFnZS5uYW1lXCIsXG4gIENPTlRBSU5FUl9JTUFHRV9UQUc6IFwiY29udGFpbmVyLmltYWdlLnRhZ1wiLFxuICBERVBMT1lNRU5UX0VOVklST05NRU5UOiBcImRlcGxveW1lbnQuZW52aXJvbm1lbnRcIixcbiAgREVWSUNFX0lEOiBcImRldmljZS5pZFwiLFxuICBERVZJQ0VfTU9ERUxfSURFTlRJRklFUjogXCJkZXZpY2UubW9kZWwuaWRlbnRpZmllclwiLFxuICBERVZJQ0VfTU9ERUxfTkFNRTogXCJkZXZpY2UubW9kZWwubmFtZVwiLFxuICBGQUFTX05BTUU6IFwiZmFhcy5uYW1lXCIsXG4gIEZBQVNfSUQ6IFwiZmFhcy5pZFwiLFxuICBGQUFTX1ZFUlNJT046IFwiZmFhcy52ZXJzaW9uXCIsXG4gIEZBQVNfSU5TVEFOQ0U6IFwiZmFhcy5pbnN0YW5jZVwiLFxuICBGQUFTX01BWF9NRU1PUlk6IFwiZmFhcy5tYXhfbWVtb3J5XCIsXG4gIEhPU1RfSUQ6IFwiaG9zdC5pZFwiLFxuICBIT1NUX05BTUU6IFwiaG9zdC5uYW1lXCIsXG4gIEhPU1RfVFlQRTogXCJob3N0LnR5cGVcIixcbiAgSE9TVF9BUkNIOiBcImhvc3QuYXJjaFwiLFxuICBIT1NUX0lNQUdFX05BTUU6IFwiaG9zdC5pbWFnZS5uYW1lXCIsXG4gIEhPU1RfSU1BR0VfSUQ6IFwiaG9zdC5pbWFnZS5pZFwiLFxuICBIT1NUX0lNQUdFX1ZFUlNJT046IFwiaG9zdC5pbWFnZS52ZXJzaW9uXCIsXG4gIEs4U19DTFVTVEVSX05BTUU6IFwiazhzLmNsdXN0ZXIubmFtZVwiLFxuICBLOFNfTk9ERV9OQU1FOiBcIms4cy5ub2RlLm5hbWVcIixcbiAgSzhTX05PREVfVUlEOiBcIms4cy5ub2RlLnVpZFwiLFxuICBLOFNfTkFNRVNQQUNFX05BTUU6IFwiazhzLm5hbWVzcGFjZS5uYW1lXCIsXG4gIEs4U19QT0RfVUlEOiBcIms4cy5wb2QudWlkXCIsXG4gIEs4U19QT0RfTkFNRTogXCJrOHMucG9kLm5hbWVcIixcbiAgSzhTX0NPTlRBSU5FUl9OQU1FOiBcIms4cy5jb250YWluZXIubmFtZVwiLFxuICBLOFNfUkVQTElDQVNFVF9VSUQ6IFwiazhzLnJlcGxpY2FzZXQudWlkXCIsXG4gIEs4U19SRVBMSUNBU0VUX05BTUU6IFwiazhzLnJlcGxpY2FzZXQubmFtZVwiLFxuICBLOFNfREVQTE9ZTUVOVF9VSUQ6IFwiazhzLmRlcGxveW1lbnQudWlkXCIsXG4gIEs4U19ERVBMT1lNRU5UX05BTUU6IFwiazhzLmRlcGxveW1lbnQubmFtZVwiLFxuICBLOFNfU1RBVEVGVUxTRVRfVUlEOiBcIms4cy5zdGF0ZWZ1bHNldC51aWRcIixcbiAgSzhTX1NUQVRFRlVMU0VUX05BTUU6IFwiazhzLnN0YXRlZnVsc2V0Lm5hbWVcIixcbiAgSzhTX0RBRU1PTlNFVF9VSUQ6IFwiazhzLmRhZW1vbnNldC51aWRcIixcbiAgSzhTX0RBRU1PTlNFVF9OQU1FOiBcIms4cy5kYWVtb25zZXQubmFtZVwiLFxuICBLOFNfSk9CX1VJRDogXCJrOHMuam9iLnVpZFwiLFxuICBLOFNfSk9CX05BTUU6IFwiazhzLmpvYi5uYW1lXCIsXG4gIEs4U19DUk9OSk9CX1VJRDogXCJrOHMuY3JvbmpvYi51aWRcIixcbiAgSzhTX0NST05KT0JfTkFNRTogXCJrOHMuY3JvbmpvYi5uYW1lXCIsXG4gIE9TX1RZUEU6IFwib3MudHlwZVwiLFxuICBPU19ERVNDUklQVElPTjogXCJvcy5kZXNjcmlwdGlvblwiLFxuICBPU19OQU1FOiBcIm9zLm5hbWVcIixcbiAgT1NfVkVSU0lPTjogXCJvcy52ZXJzaW9uXCIsXG4gIFBST0NFU1NfUElEOiBcInByb2Nlc3MucGlkXCIsXG4gIFBST0NFU1NfRVhFQ1VUQUJMRV9OQU1FOiBcInByb2Nlc3MuZXhlY3V0YWJsZS5uYW1lXCIsXG4gIFBST0NFU1NfRVhFQ1VUQUJMRV9QQVRIOiBcInByb2Nlc3MuZXhlY3V0YWJsZS5wYXRoXCIsXG4gIFBST0NFU1NfQ09NTUFORDogXCJwcm9jZXNzLmNvbW1hbmRcIixcbiAgUFJPQ0VTU19DT01NQU5EX0xJTkU6IFwicHJvY2Vzcy5jb21tYW5kX2xpbmVcIixcbiAgUFJPQ0VTU19DT01NQU5EX0FSR1M6IFwicHJvY2Vzcy5jb21tYW5kX2FyZ3NcIixcbiAgUFJPQ0VTU19PV05FUjogXCJwcm9jZXNzLm93bmVyXCIsXG4gIFBST0NFU1NfUlVOVElNRV9OQU1FOiBcInByb2Nlc3MucnVudGltZS5uYW1lXCIsXG4gIFBST0NFU1NfUlVOVElNRV9WRVJTSU9OOiBcInByb2Nlc3MucnVudGltZS52ZXJzaW9uXCIsXG4gIFBST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTjogXCJwcm9jZXNzLnJ1bnRpbWUuZGVzY3JpcHRpb25cIixcbiAgU0VSVklDRV9OQU1FOiBcInNlcnZpY2UubmFtZVwiLFxuICBTRVJWSUNFX05BTUVTUEFDRTogXCJzZXJ2aWNlLm5hbWVzcGFjZVwiLFxuICBTRVJWSUNFX0lOU1RBTkNFX0lEOiBcInNlcnZpY2UuaW5zdGFuY2UuaWRcIixcbiAgU0VSVklDRV9WRVJTSU9OOiBcInNlcnZpY2UudmVyc2lvblwiLFxuICBURUxFTUVUUllfU0RLX05BTUU6IFwidGVsZW1ldHJ5LnNkay5uYW1lXCIsXG4gIFRFTEVNRVRSWV9TREtfTEFOR1VBR0U6IFwidGVsZW1ldHJ5LnNkay5sYW5ndWFnZVwiLFxuICBURUxFTUVUUllfU0RLX1ZFUlNJT046IFwidGVsZW1ldHJ5LnNkay52ZXJzaW9uXCIsXG4gIFRFTEVNRVRSWV9BVVRPX1ZFUlNJT046IFwidGVsZW1ldHJ5LmF1dG8udmVyc2lvblwiLFxuICBXRUJFTkdJTkVfTkFNRTogXCJ3ZWJlbmdpbmUubmFtZVwiLFxuICBXRUJFTkdJTkVfVkVSU0lPTjogXCJ3ZWJlbmdpbmUudmVyc2lvblwiLFxuICBXRUJFTkdJTkVfREVTQ1JJUFRJT046IFwid2ViZW5naW5lLmRlc2NyaXB0aW9uXCJcbn07XG52YXIgVGVsZW1ldHJ5U2RrTGFuZ3VhZ2VWYWx1ZXMgPSB7XG4gIENQUDogXCJjcHBcIixcbiAgRE9UTkVUOiBcImRvdG5ldFwiLFxuICBFUkxBTkc6IFwiZXJsYW5nXCIsXG4gIEdPOiBcImdvXCIsXG4gIEpBVkE6IFwiamF2YVwiLFxuICBOT0RFSlM6IFwibm9kZWpzXCIsXG4gIFBIUDogXCJwaHBcIixcbiAgUFlUSE9OOiBcInB5dGhvblwiLFxuICBSVUJZOiBcInJ1YnlcIixcbiAgV0VCSlM6IFwid2VianNcIlxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3Nkay1pbmZvLmpzXG52YXIgX2EyO1xudmFyIFNES19JTkZPID0gKF9hMiA9IHt9LCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19OQU1FXSA9IFwib3BlbnRlbGVtZXRyeVwiLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX05BTUVdID0gXCJub2RlXCIsIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX0xBTkdVQUdFXSA9IFRlbGVtZXRyeVNka0xhbmd1YWdlVmFsdWVzLk5PREVKUywgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfVkVSU0lPTl0gPSBWRVJTSU9OMiwgX2EyKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3RpbWVyLXV0aWwuanNcbmZ1bmN0aW9uIHVucmVmVGltZXIodGltZXIpIHtcbiAgdGltZXIudW5yZWYoKTtcbn1cbl9fbmFtZSh1bnJlZlRpbWVyLCBcInVucmVmVGltZXJcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vY29tbW9uL3RpbWUuanNcbnZhciBOQU5PU0VDT05EX0RJR0lUUyA9IDk7XG52YXIgU0VDT05EX1RPX05BTk9TRUNPTkRTID0gTWF0aC5wb3coMTAsIE5BTk9TRUNPTkRfRElHSVRTKTtcbmZ1bmN0aW9uIG51bWJlclRvSHJ0aW1lKGVwb2NoTWlsbGlzKSB7XG4gIHZhciBlcG9jaFNlY29uZHMgPSBlcG9jaE1pbGxpcyAvIDFlMztcbiAgdmFyIHNlY29uZHMgPSBNYXRoLnRydW5jKGVwb2NoU2Vjb25kcyk7XG4gIHZhciBuYW5vcyA9IE51bWJlcigoZXBvY2hTZWNvbmRzIC0gc2Vjb25kcykudG9GaXhlZChOQU5PU0VDT05EX0RJR0lUUykpICogU0VDT05EX1RPX05BTk9TRUNPTkRTO1xuICByZXR1cm4gW3NlY29uZHMsIG5hbm9zXTtcbn1cbl9fbmFtZShudW1iZXJUb0hydGltZSwgXCJudW1iZXJUb0hydGltZVwiKTtcbmZ1bmN0aW9uIGdldFRpbWVPcmlnaW4oKSB7XG4gIHZhciB0aW1lT3JpZ2luID0gb3RwZXJmb3JtYW5jZS50aW1lT3JpZ2luO1xuICBpZiAodHlwZW9mIHRpbWVPcmlnaW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgcGVyZiA9IG90cGVyZm9ybWFuY2U7XG4gICAgdGltZU9yaWdpbiA9IHBlcmYudGltaW5nICYmIHBlcmYudGltaW5nLmZldGNoU3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHRpbWVPcmlnaW47XG59XG5fX25hbWUoZ2V0VGltZU9yaWdpbiwgXCJnZXRUaW1lT3JpZ2luXCIpO1xuZnVuY3Rpb24gaHJUaW1lKHBlcmZvcm1hbmNlTm93KSB7XG4gIHZhciB0aW1lT3JpZ2luID0gbnVtYmVyVG9IcnRpbWUoZ2V0VGltZU9yaWdpbigpKTtcbiAgdmFyIG5vdyA9IG51bWJlclRvSHJ0aW1lKHR5cGVvZiBwZXJmb3JtYW5jZU5vdyA9PT0gXCJudW1iZXJcIiA/IHBlcmZvcm1hbmNlTm93IDogb3RwZXJmb3JtYW5jZS5ub3coKSk7XG4gIHZhciBzZWNvbmRzID0gdGltZU9yaWdpblswXSArIG5vd1swXTtcbiAgdmFyIG5hbm9zID0gdGltZU9yaWdpblsxXSArIG5vd1sxXTtcbiAgaWYgKG5hbm9zID4gU0VDT05EX1RPX05BTk9TRUNPTkRTKSB7XG4gICAgbmFub3MgLT0gU0VDT05EX1RPX05BTk9TRUNPTkRTO1xuICAgIHNlY29uZHMgKz0gMTtcbiAgfVxuICByZXR1cm4gW3NlY29uZHMsIG5hbm9zXTtcbn1cbl9fbmFtZShoclRpbWUsIFwiaHJUaW1lXCIpO1xuZnVuY3Rpb24gdGltZUlucHV0VG9IclRpbWUodGltZSkge1xuICBpZiAoaXNUaW1lSW5wdXRIclRpbWUodGltZSkpIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICh0aW1lIDwgZ2V0VGltZU9yaWdpbigpKSB7XG4gICAgICByZXR1cm4gaHJUaW1lKHRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVtYmVyVG9IcnRpbWUodGltZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG51bWJlclRvSHJ0aW1lKHRpbWUuZ2V0VGltZSgpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIik7XG4gIH1cbn1cbl9fbmFtZSh0aW1lSW5wdXRUb0hyVGltZSwgXCJ0aW1lSW5wdXRUb0hyVGltZVwiKTtcbmZ1bmN0aW9uIGhyVGltZUR1cmF0aW9uKHN0YXJ0VGltZSwgZW5kVGltZSkge1xuICB2YXIgc2Vjb25kcyA9IGVuZFRpbWVbMF0gLSBzdGFydFRpbWVbMF07XG4gIHZhciBuYW5vcyA9IGVuZFRpbWVbMV0gLSBzdGFydFRpbWVbMV07XG4gIGlmIChuYW5vcyA8IDApIHtcbiAgICBzZWNvbmRzIC09IDE7XG4gICAgbmFub3MgKz0gU0VDT05EX1RPX05BTk9TRUNPTkRTO1xuICB9XG4gIHJldHVybiBbc2Vjb25kcywgbmFub3NdO1xufVxuX19uYW1lKGhyVGltZUR1cmF0aW9uLCBcImhyVGltZUR1cmF0aW9uXCIpO1xuZnVuY3Rpb24gaHJUaW1lVG9NaWNyb3NlY29uZHModGltZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lWzBdICogMWU2ICsgdGltZVsxXSAvIDFlMyk7XG59XG5fX25hbWUoaHJUaW1lVG9NaWNyb3NlY29uZHMsIFwiaHJUaW1lVG9NaWNyb3NlY29uZHNcIik7XG5mdW5jdGlvbiBpc1RpbWVJbnB1dEhyVGltZSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsdWVbMV0gPT09IFwibnVtYmVyXCI7XG59XG5fX25hbWUoaXNUaW1lSW5wdXRIclRpbWUsIFwiaXNUaW1lSW5wdXRIclRpbWVcIik7XG5mdW5jdGlvbiBpc1RpbWVJbnB1dCh2YWx1ZSkge1xuICByZXR1cm4gaXNUaW1lSW5wdXRIclRpbWUodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59XG5fX25hbWUoaXNUaW1lSW5wdXQsIFwiaXNUaW1lSW5wdXRcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vRXhwb3J0UmVzdWx0LmpzXG52YXIgRXhwb3J0UmVzdWx0Q29kZTtcbihmdW5jdGlvbihFeHBvcnRSZXN1bHRDb2RlMikge1xuICBFeHBvcnRSZXN1bHRDb2RlMltFeHBvcnRSZXN1bHRDb2RlMltcIlNVQ0NFU1NcIl0gPSAwXSA9IFwiU1VDQ0VTU1wiO1xuICBFeHBvcnRSZXN1bHRDb2RlMltFeHBvcnRSZXN1bHRDb2RlMltcIkZBSUxFRFwiXSA9IDFdID0gXCJGQUlMRURcIjtcbn0pKEV4cG9ydFJlc3VsdENvZGUgfHwgKEV4cG9ydFJlc3VsdENvZGUgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3Byb3BhZ2F0aW9uL2NvbXBvc2l0ZS5qc1xudmFyIF9fdmFsdWVzMiA9IGZ1bmN0aW9uKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pXG4gICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBDb21wb3NpdGVQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENvbXBvc2l0ZVByb3BhZ2F0b3IyKGNvbmZpZzIpIHtcbiAgICBpZiAoY29uZmlnMiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25maWcyID0ge307XG4gICAgfVxuICAgIHZhciBfYTM7XG4gICAgdGhpcy5fcHJvcGFnYXRvcnMgPSAoX2EzID0gY29uZmlnMi5wcm9wYWdhdG9ycykgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBbXTtcbiAgICB0aGlzLl9maWVsZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5fcHJvcGFnYXRvcnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgcC5maWVsZHMgPT09IFwiZnVuY3Rpb25cIiA/IHAuZmllbGRzKCkgOiBbXTtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHguY29uY2F0KHkpO1xuICAgIH0sIFtdKSkpO1xuICB9XG4gIF9fbmFtZShDb21wb3NpdGVQcm9wYWdhdG9yMiwgXCJDb21wb3NpdGVQcm9wYWdhdG9yXCIpO1xuICBDb21wb3NpdGVQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIHZhciBlXzEsIF9hMztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXMyKHRoaXMuX3Byb3BhZ2F0b3JzKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBwcm9wYWdhdG9yID0gX2MudmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvcGFnYXRvci5pbmplY3QoY29udGV4dDMsIGNhcnJpZXIsIHNldHRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGRpYWcyLndhcm4oXCJGYWlsZWQgdG8gaW5qZWN0IHdpdGggXCIgKyBwcm9wYWdhdG9yLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi4gRXJyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMyA9IF9iMi5yZXR1cm4pKVxuICAgICAgICAgIF9hMy5jYWxsKF9iMik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENvbXBvc2l0ZVByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wcm9wYWdhdG9ycy5yZWR1Y2UoZnVuY3Rpb24oY3R4LCBwcm9wYWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvcGFnYXRvci5leHRyYWN0KGN0eCwgY2FycmllciwgZ2V0dGVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkaWFnMi53YXJuKFwiRmFpbGVkIHRvIGluamVjdCB3aXRoIFwiICsgcHJvcGFnYXRvci5jb25zdHJ1Y3Rvci5uYW1lICsgXCIuIEVycjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH0sIGNvbnRleHQzKTtcbiAgfTtcbiAgQ29tcG9zaXRlUHJvcGFnYXRvcjIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZHMuc2xpY2UoKTtcbiAgfTtcbiAgcmV0dXJuIENvbXBvc2l0ZVByb3BhZ2F0b3IyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVybmFsL3ZhbGlkYXRvcnMuanNcbnZhciBWQUxJRF9LRVlfQ0hBUl9SQU5HRTIgPSBcIltfMC05YS16LSovXVwiO1xudmFyIFZBTElEX0tFWTIgPSBcIlthLXpdXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRTIgKyBcInswLDI1NX1cIjtcbnZhciBWQUxJRF9WRU5ET1JfS0VZMiA9IFwiW2EtejAtOV1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFMiArIFwiezAsMjQwfUBbYS16XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UyICsgXCJ7MCwxM31cIjtcbnZhciBWQUxJRF9LRVlfUkVHRVgyID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIFZBTElEX0tFWTIgKyBcInxcIiArIFZBTElEX1ZFTkRPUl9LRVkyICsgXCIpJFwiKTtcbnZhciBWQUxJRF9WQUxVRV9CQVNFX1JFR0VYMiA9IC9eWyAtfl17MCwyNTV9WyEtfl0kLztcbnZhciBJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYMiA9IC8sfD0vO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXkyKGtleSkge1xuICByZXR1cm4gVkFMSURfS0VZX1JFR0VYMi50ZXN0KGtleSk7XG59XG5fX25hbWUodmFsaWRhdGVLZXkyLCBcInZhbGlkYXRlS2V5XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZTIodmFsdWUpIHtcbiAgcmV0dXJuIFZBTElEX1ZBTFVFX0JBU0VfUkVHRVgyLnRlc3QodmFsdWUpICYmICFJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYMi50ZXN0KHZhbHVlKTtcbn1cbl9fbmFtZSh2YWxpZGF0ZVZhbHVlMiwgXCJ2YWxpZGF0ZVZhbHVlXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL1RyYWNlU3RhdGUuanNcbnZhciBNQVhfVFJBQ0VfU1RBVEVfSVRFTVMyID0gMzI7XG52YXIgTUFYX1RSQUNFX1NUQVRFX0xFTjIgPSA1MTI7XG52YXIgTElTVF9NRU1CRVJTX1NFUEFSQVRPUjIgPSBcIixcIjtcbnZhciBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIyID0gXCI9XCI7XG52YXIgVHJhY2VTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmFjZVN0YXRlMihyYXdUcmFjZVN0YXRlKSB7XG4gICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHJhd1RyYWNlU3RhdGUpXG4gICAgICB0aGlzLl9wYXJzZShyYXdUcmFjZVN0YXRlKTtcbiAgfVxuICBfX25hbWUoVHJhY2VTdGF0ZTIsIFwiVHJhY2VTdGF0ZVwiKTtcbiAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgdHJhY2VTdGF0ZSA9IHRoaXMuX2Nsb25lKCk7XG4gICAgaWYgKHRyYWNlU3RhdGUuX2ludGVybmFsU3RhdGUuaGFzKGtleSkpIHtcbiAgICAgIHRyYWNlU3RhdGUuX2ludGVybmFsU3RhdGUuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHRyYWNlU3RhdGUuX2ludGVybmFsU3RhdGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB0cmFjZVN0YXRlO1xuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdHJhY2VTdGF0ZSA9IHRoaXMuX2Nsb25lKCk7XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgfTtcbiAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlLmdldChrZXkpO1xuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5fa2V5cygpLnJlZHVjZShmdW5jdGlvbihhZ2csIGtleSkge1xuICAgICAgYWdnLnB1c2goa2V5ICsgTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSMiArIF90aGlzLmdldChrZXkpKTtcbiAgICAgIHJldHVybiBhZ2c7XG4gICAgfSwgW10pLmpvaW4oTElTVF9NRU1CRVJTX1NFUEFSQVRPUjIpO1xuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24ocmF3VHJhY2VTdGF0ZSkge1xuICAgIGlmIChyYXdUcmFjZVN0YXRlLmxlbmd0aCA+IE1BWF9UUkFDRV9TVEFURV9MRU4yKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ludGVybmFsU3RhdGUgPSByYXdUcmFjZVN0YXRlLnNwbGl0KExJU1RfTUVNQkVSU19TRVBBUkFUT1IyKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uKGFnZywgcGFydCkge1xuICAgICAgdmFyIGxpc3RNZW1iZXIgPSBwYXJ0LnRyaW0oKTtcbiAgICAgIHZhciBpID0gbGlzdE1lbWJlci5pbmRleE9mKExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUjIpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIHZhciBrZXkgPSBsaXN0TWVtYmVyLnNsaWNlKDAsIGkpO1xuICAgICAgICB2YXIgdmFsdWUgPSBsaXN0TWVtYmVyLnNsaWNlKGkgKyAxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgIGlmICh2YWxpZGF0ZUtleTIoa2V5KSAmJiB2YWxpZGF0ZVZhbHVlMih2YWx1ZSkpIHtcbiAgICAgICAgICBhZ2cuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWdnO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGlmICh0aGlzLl9pbnRlcm5hbFN0YXRlLnNpemUgPiBNQVhfVFJBQ0VfU1RBVEVfSVRFTVMyKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUuZW50cmllcygpKS5yZXZlcnNlKCkuc2xpY2UoMCwgTUFYX1RSQUNFX1NUQVRFX0lURU1TMikpO1xuICAgIH1cbiAgfTtcbiAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLl9rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5faW50ZXJuYWxTdGF0ZS5rZXlzKCkpLnJldmVyc2UoKTtcbiAgfTtcbiAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFjZVN0YXRlID0gbmV3IFRyYWNlU3RhdGUyKCk7XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZSA9IG5ldyBNYXAodGhpcy5faW50ZXJuYWxTdGF0ZSk7XG4gICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gIH07XG4gIHJldHVybiBUcmFjZVN0YXRlMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9XM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yLmpzXG52YXIgVFJBQ0VfUEFSRU5UX0hFQURFUiA9IFwidHJhY2VwYXJlbnRcIjtcbnZhciBUUkFDRV9TVEFURV9IRUFERVIgPSBcInRyYWNlc3RhdGVcIjtcbnZhciBWRVJTSU9OMyA9IFwiMDBcIjtcbnZhciBWRVJTSU9OX1BBUlQgPSBcIig/IWZmKVtcXFxcZGEtZl17Mn1cIjtcbnZhciBUUkFDRV9JRF9QQVJUID0gXCIoPyFbMF17MzJ9KVtcXFxcZGEtZl17MzJ9XCI7XG52YXIgUEFSRU5UX0lEX1BBUlQgPSBcIig/IVswXXsxNn0pW1xcXFxkYS1mXXsxNn1cIjtcbnZhciBGTEFHU19QQVJUID0gXCJbXFxcXGRhLWZdezJ9XCI7XG52YXIgVFJBQ0VfUEFSRU5UX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5cXFxccz8oXCIgKyBWRVJTSU9OX1BBUlQgKyBcIiktKFwiICsgVFJBQ0VfSURfUEFSVCArIFwiKS0oXCIgKyBQQVJFTlRfSURfUEFSVCArIFwiKS0oXCIgKyBGTEFHU19QQVJUICsgXCIpKC0uKik/XFxcXHM/JFwiKTtcbmZ1bmN0aW9uIHBhcnNlVHJhY2VQYXJlbnQodHJhY2VQYXJlbnQpIHtcbiAgdmFyIG1hdGNoID0gVFJBQ0VfUEFSRU5UX1JFR0VYLmV4ZWModHJhY2VQYXJlbnQpO1xuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAobWF0Y2hbMV0gPT09IFwiMDBcIiAmJiBtYXRjaFs1XSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICB0cmFjZUlkOiBtYXRjaFsyXSxcbiAgICBzcGFuSWQ6IG1hdGNoWzNdLFxuICAgIHRyYWNlRmxhZ3M6IHBhcnNlSW50KG1hdGNoWzRdLCAxNilcbiAgfTtcbn1cbl9fbmFtZShwYXJzZVRyYWNlUGFyZW50LCBcInBhcnNlVHJhY2VQYXJlbnRcIik7XG52YXIgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMigpIHtcbiAgfVxuICBfX25hbWUoVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcjIsIFwiVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvclwiKTtcbiAgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQzLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICB2YXIgc3BhbkNvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChjb250ZXh0Myk7XG4gICAgaWYgKCFzcGFuQ29udGV4dCB8fCBpc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQzKSB8fCAhaXNTcGFuQ29udGV4dFZhbGlkKHNwYW5Db250ZXh0KSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIgdHJhY2VQYXJlbnQgPSBWRVJTSU9OMyArIFwiLVwiICsgc3BhbkNvbnRleHQudHJhY2VJZCArIFwiLVwiICsgc3BhbkNvbnRleHQuc3BhbklkICsgXCItMFwiICsgTnVtYmVyKHNwYW5Db250ZXh0LnRyYWNlRmxhZ3MgfHwgVHJhY2VGbGFncy5OT05FKS50b1N0cmluZygxNik7XG4gICAgc2V0dGVyLnNldChjYXJyaWVyLCBUUkFDRV9QQVJFTlRfSEVBREVSLCB0cmFjZVBhcmVudCk7XG4gICAgaWYgKHNwYW5Db250ZXh0LnRyYWNlU3RhdGUpIHtcbiAgICAgIHNldHRlci5zZXQoY2FycmllciwgVFJBQ0VfU1RBVEVfSEVBREVSLCBzcGFuQ29udGV4dC50cmFjZVN0YXRlLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gIH07XG4gIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIHZhciB0cmFjZVBhcmVudEhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgVFJBQ0VfUEFSRU5UX0hFQURFUik7XG4gICAgaWYgKCF0cmFjZVBhcmVudEhlYWRlcilcbiAgICAgIHJldHVybiBjb250ZXh0MztcbiAgICB2YXIgdHJhY2VQYXJlbnQgPSBBcnJheS5pc0FycmF5KHRyYWNlUGFyZW50SGVhZGVyKSA/IHRyYWNlUGFyZW50SGVhZGVyWzBdIDogdHJhY2VQYXJlbnRIZWFkZXI7XG4gICAgaWYgKHR5cGVvZiB0cmFjZVBhcmVudCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBjb250ZXh0MztcbiAgICB2YXIgc3BhbkNvbnRleHQgPSBwYXJzZVRyYWNlUGFyZW50KHRyYWNlUGFyZW50KTtcbiAgICBpZiAoIXNwYW5Db250ZXh0KVxuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIHNwYW5Db250ZXh0LmlzUmVtb3RlID0gdHJ1ZTtcbiAgICB2YXIgdHJhY2VTdGF0ZUhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgVFJBQ0VfU1RBVEVfSEVBREVSKTtcbiAgICBpZiAodHJhY2VTdGF0ZUhlYWRlcikge1xuICAgICAgdmFyIHN0YXRlID0gQXJyYXkuaXNBcnJheSh0cmFjZVN0YXRlSGVhZGVyKSA/IHRyYWNlU3RhdGVIZWFkZXIuam9pbihcIixcIikgOiB0cmFjZVN0YXRlSGVhZGVyO1xuICAgICAgc3BhbkNvbnRleHQudHJhY2VTdGF0ZSA9IG5ldyBUcmFjZVN0YXRlKHR5cGVvZiBzdGF0ZSA9PT0gXCJzdHJpbmdcIiA/IHN0YXRlIDogdm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlLnNldFNwYW5Db250ZXh0KGNvbnRleHQzLCBzcGFuQ29udGV4dCk7XG4gIH07XG4gIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW1RSQUNFX1BBUkVOVF9IRUFERVIsIFRSQUNFX1NUQVRFX0hFQURFUl07XG4gIH07XG4gIHJldHVybiBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9ycGMtbWV0YWRhdGEuanNcbnZhciBSUENfTUVUQURBVEFfS0VZID0gY3JlYXRlQ29udGV4dEtleShcIk9wZW5UZWxlbWV0cnkgU0RLIENvbnRleHQgS2V5IFJQQ19NRVRBREFUQVwiKTtcbnZhciBSUENUeXBlO1xuKGZ1bmN0aW9uKFJQQ1R5cGUyKSB7XG4gIFJQQ1R5cGUyW1wiSFRUUFwiXSA9IFwiaHR0cFwiO1xufSkoUlBDVHlwZSB8fCAoUlBDVHlwZSA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9BbHdheXNPZmZTYW1wbGVyLmpzXG52YXIgQWx3YXlzT2ZmU2FtcGxlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBbHdheXNPZmZTYW1wbGVyMygpIHtcbiAgfVxuICBfX25hbWUoQWx3YXlzT2ZmU2FtcGxlcjMsIFwiQWx3YXlzT2ZmU2FtcGxlclwiKTtcbiAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEXG4gICAgfTtcbiAgfTtcbiAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiQWx3YXlzT2ZmU2FtcGxlclwiO1xuICB9O1xuICByZXR1cm4gQWx3YXlzT2ZmU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9BbHdheXNPblNhbXBsZXIuanNcbnZhciBBbHdheXNPblNhbXBsZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQWx3YXlzT25TYW1wbGVyMygpIHtcbiAgfVxuICBfX25hbWUoQWx3YXlzT25TYW1wbGVyMywgXCJBbHdheXNPblNhbXBsZXJcIik7XG4gIEFsd2F5c09uU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRURcbiAgICB9O1xuICB9O1xuICBBbHdheXNPblNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIkFsd2F5c09uU2FtcGxlclwiO1xuICB9O1xuICByZXR1cm4gQWx3YXlzT25TYW1wbGVyMztcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zYW1wbGVyL1BhcmVudEJhc2VkU2FtcGxlci5qc1xudmFyIFBhcmVudEJhc2VkU2FtcGxlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBQYXJlbnRCYXNlZFNhbXBsZXIzKGNvbmZpZzIpIHtcbiAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgICB0aGlzLl9yb290ID0gY29uZmlnMi5yb290O1xuICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIlBhcmVudEJhc2VkU2FtcGxlciBtdXN0IGhhdmUgYSByb290IHNhbXBsZXIgY29uZmlndXJlZFwiKSk7XG4gICAgICB0aGlzLl9yb290ID0gbmV3IEFsd2F5c09uU2FtcGxlcigpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkID0gKF9hMyA9IGNvbmZpZzIucmVtb3RlUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBuZXcgQWx3YXlzT25TYW1wbGVyKCk7XG4gICAgdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZCA9IChfYjIgPSBjb25maWcyLnJlbW90ZVBhcmVudE5vdFNhbXBsZWQpICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogbmV3IEFsd2F5c09mZlNhbXBsZXIoKTtcbiAgICB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQgPSAoX2MgPSBjb25maWcyLmxvY2FsUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IEFsd2F5c09uU2FtcGxlcigpO1xuICAgIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZCA9IChfZCA9IGNvbmZpZzIubG9jYWxQYXJlbnROb3RTYW1wbGVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgQWx3YXlzT2ZmU2FtcGxlcigpO1xuICB9XG4gIF9fbmFtZShQYXJlbnRCYXNlZFNhbXBsZXIzLCBcIlBhcmVudEJhc2VkU2FtcGxlclwiKTtcbiAgUGFyZW50QmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpIHtcbiAgICB2YXIgcGFyZW50Q29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQzKTtcbiAgICBpZiAoIXBhcmVudENvbnRleHQgfHwgIWlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRDb250ZXh0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Quc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudENvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgIGlmIChwYXJlbnRDb250ZXh0LnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb250ZXh0LnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICB9O1xuICBQYXJlbnRCYXNlZFNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlBhcmVudEJhc2Vke3Jvb3Q9XCIgKyB0aGlzLl9yb290LnRvU3RyaW5nKCkgKyBcIiwgcmVtb3RlUGFyZW50U2FtcGxlZD1cIiArIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCByZW1vdGVQYXJlbnROb3RTYW1wbGVkPVwiICsgdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZC50b1N0cmluZygpICsgXCIsIGxvY2FsUGFyZW50U2FtcGxlZD1cIiArIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZC50b1N0cmluZygpICsgXCIsIGxvY2FsUGFyZW50Tm90U2FtcGxlZD1cIiArIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZC50b1N0cmluZygpICsgXCJ9XCI7XG4gIH07XG4gIHJldHVybiBQYXJlbnRCYXNlZFNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3NhbXBsZXIvVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyLmpzXG52YXIgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMoX3JhdGlvKSB7XG4gICAgaWYgKF9yYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICBfcmF0aW8gPSAwO1xuICAgIH1cbiAgICB0aGlzLl9yYXRpbyA9IF9yYXRpbztcbiAgICB0aGlzLl9yYXRpbyA9IHRoaXMuX25vcm1hbGl6ZShfcmF0aW8pO1xuICAgIHRoaXMuX3VwcGVyQm91bmQgPSBNYXRoLmZsb29yKHRoaXMuX3JhdGlvICogNDI5NDk2NzI5NSk7XG4gIH1cbiAgX19uYW1lKFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMsIFwiVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyXCIpO1xuICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbihjb250ZXh0MywgdHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogaXNWYWxpZFRyYWNlSWQodHJhY2VJZCkgJiYgdGhpcy5fYWNjdW11bGF0ZSh0cmFjZUlkKSA8IHRoaXMuX3VwcGVyQm91bmQgPyBTYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA6IFNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRFxuICAgIH07XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiVHJhY2VJZFJhdGlvQmFzZWR7XCIgKyB0aGlzLl9yYXRpbyArIFwifVwiO1xuICB9O1xuICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5fbm9ybWFsaXplID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICBpZiAodHlwZW9mIHJhdGlvICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHJhdGlvKSlcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiByYXRpbyA+PSAxID8gMSA6IHJhdGlvIDw9IDAgPyAwIDogcmF0aW87XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLl9hY2N1bXVsYXRlID0gZnVuY3Rpb24odHJhY2VJZCkge1xuICAgIHZhciBhY2N1bXVsYXRpb24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VJZC5sZW5ndGggLyA4OyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBpICogODtcbiAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQodHJhY2VJZC5zbGljZShwb3MsIHBvcyArIDgpLCAxNik7XG4gICAgICBhY2N1bXVsYXRpb24gPSAoYWNjdW11bGF0aW9uIF4gcGFydCkgPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRpb247XG4gIH07XG4gIHJldHVybiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2xvZGFzaC5tZXJnZS5qc1xudmFyIG9iamVjdFRhZyA9IFwiW29iamVjdCBPYmplY3RdXCI7XG52YXIgbnVsbFRhZyA9IFwiW29iamVjdCBOdWxsXVwiO1xudmFyIHVuZGVmaW5lZFRhZyA9IFwiW29iamVjdCBVbmRlZmluZWRdXCI7XG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHZvaWQgMDtcbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZzIpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnMikpO1xuICB9O1xufVxuX19uYW1lKG92ZXJBcmcsIFwib3ZlckFyZ1wiKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9PSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuX19uYW1lKGlzUGxhaW5PYmplY3QsIFwiaXNQbGFpbk9iamVjdFwiKTtcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbn1cbl9fbmFtZShpc09iamVjdExpa2UsIFwiaXNPYmplY3RMaWtlXCIpO1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSA/IGdldFJhd1RhZyh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5fX25hbWUoYmFzZUdldFRhZywgXCJiYXNlR2V0VGFnXCIpO1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSwgdGFnMiA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgdmFyIHVubWFza2VkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdm9pZCAwO1xuICAgIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWcyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKGdldFJhd1RhZywgXCJnZXRSYXdUYWdcIik7XG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5fX25hbWUob2JqZWN0VG9TdHJpbmcsIFwib2JqZWN0VG9TdHJpbmdcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvbWVyZ2UuanNcbnZhciBNQVhfTEVWRUwgPSAyMDtcbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gYXJncy5zaGlmdCgpO1xuICB2YXIgb2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB3aGlsZSAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2VUd29PYmplY3RzKHJlc3VsdCwgYXJncy5zaGlmdCgpLCAwLCBvYmplY3RzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKG1lcmdlLCBcIm1lcmdlXCIpO1xuZnVuY3Rpb24gdGFrZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbl9fbmFtZSh0YWtlVmFsdWUsIFwidGFrZVZhbHVlXCIpO1xuZnVuY3Rpb24gbWVyZ2VUd29PYmplY3RzKG9uZSwgdHdvLCBsZXZlbCwgb2JqZWN0cykge1xuICBpZiAobGV2ZWwgPT09IHZvaWQgMCkge1xuICAgIGxldmVsID0gMDtcbiAgfVxuICB2YXIgcmVzdWx0O1xuICBpZiAobGV2ZWwgPiBNQVhfTEVWRUwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldmVsKys7XG4gIGlmIChpc1ByaW1pdGl2ZShvbmUpIHx8IGlzUHJpbWl0aXZlKHR3bykgfHwgaXNGdW5jdGlvbih0d28pKSB7XG4gICAgcmVzdWx0ID0gdGFrZVZhbHVlKHR3byk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShvbmUpKSB7XG4gICAgcmVzdWx0ID0gb25lLnNsaWNlKCk7XG4gICAgaWYgKGlzQXJyYXkodHdvKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0d28ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRha2VWYWx1ZSh0d29baV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHR3bykpIHtcbiAgICAgIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKHR3byk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGtleXMyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5czJbaV07XG4gICAgICAgIHJlc3VsdFtrZXldID0gdGFrZVZhbHVlKHR3b1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qob25lKSkge1xuICAgIGlmIChpc09iamVjdCh0d28pKSB7XG4gICAgICBpZiAoIXNob3VsZE1lcmdlKG9uZSwgdHdvKSkge1xuICAgICAgICByZXR1cm4gdHdvO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb25lKTtcbiAgICAgIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKHR3byk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGtleXMyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5czJbaV07XG4gICAgICAgIHZhciB0d29WYWx1ZSA9IHR3b1trZXldO1xuICAgICAgICBpZiAoaXNQcmltaXRpdmUodHdvVmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0d29WYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHR3b1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2JqMSA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgIHZhciBvYmoyID0gdHdvVmFsdWU7XG4gICAgICAgICAgaWYgKHdhc09iamVjdFJlZmVyZW5jZWQob25lLCBrZXksIG9iamVjdHMpIHx8IHdhc09iamVjdFJlZmVyZW5jZWQodHdvLCBrZXksIG9iamVjdHMpKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvYmoxKSAmJiBpc09iamVjdChvYmoyKSkge1xuICAgICAgICAgICAgICB2YXIgYXJyMSA9IG9iamVjdHMuZ2V0KG9iajEpIHx8IFtdO1xuICAgICAgICAgICAgICB2YXIgYXJyMiA9IG9iamVjdHMuZ2V0KG9iajIpIHx8IFtdO1xuICAgICAgICAgICAgICBhcnIxLnB1c2goeyBvYmo6IG9uZSwga2V5IH0pO1xuICAgICAgICAgICAgICBhcnIyLnB1c2goeyBvYmo6IHR3bywga2V5IH0pO1xuICAgICAgICAgICAgICBvYmplY3RzLnNldChvYmoxLCBhcnIxKTtcbiAgICAgICAgICAgICAgb2JqZWN0cy5zZXQob2JqMiwgYXJyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlVHdvT2JqZWN0cyhyZXN1bHRba2V5XSwgdHdvVmFsdWUsIGxldmVsLCBvYmplY3RzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gdHdvO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKG1lcmdlVHdvT2JqZWN0cywgXCJtZXJnZVR3b09iamVjdHNcIik7XG5mdW5jdGlvbiB3YXNPYmplY3RSZWZlcmVuY2VkKG9iaiwga2V5LCBvYmplY3RzKSB7XG4gIHZhciBhcnIgPSBvYmplY3RzLmdldChvYmpba2V5XSkgfHwgW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBpbmZvMiA9IGFycltpXTtcbiAgICBpZiAoaW5mbzIua2V5ID09PSBrZXkgJiYgaW5mbzIub2JqID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5fX25hbWUod2FzT2JqZWN0UmVmZXJlbmNlZCwgXCJ3YXNPYmplY3RSZWZlcmVuY2VkXCIpO1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5fX25hbWUoaXNBcnJheSwgXCJpc0FycmF5XCIpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5fX25hbWUoaXNGdW5jdGlvbiwgXCJpc0Z1bmN0aW9uXCIpO1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICFpc1ByaW1pdGl2ZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc0Z1bmN0aW9uKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5fX25hbWUoaXNPYmplY3QsIFwiaXNPYmplY3RcIik7XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdmFsdWUgPT09IG51bGw7XG59XG5fX25hbWUoaXNQcmltaXRpdmUsIFwiaXNQcmltaXRpdmVcIik7XG5mdW5jdGlvbiBzaG91bGRNZXJnZShvbmUsIHR3bykge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob25lKSB8fCAhaXNQbGFpbk9iamVjdCh0d28pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuX19uYW1lKHNob3VsZE1lcmdlLCBcInNob3VsZE1lcmdlXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3Byb21pc2UuanNcbnZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBEZWZlcnJlZDIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG4gIF9fbmFtZShEZWZlcnJlZDIsIFwiRGVmZXJyZWRcIik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZlcnJlZDIucHJvdG90eXBlLCBcInByb21pc2VcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgRGVmZXJyZWQyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICB9O1xuICBEZWZlcnJlZDIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKGVycikge1xuICAgIHRoaXMuX3JlamVjdChlcnIpO1xuICB9O1xuICByZXR1cm4gRGVmZXJyZWQyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2NhbGxiYWNrLmpzXG52YXIgX19yZWFkMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheTMgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgIGlmICghYXIpXG4gICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIEJpbmRPbmNlRnV0dXJlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJpbmRPbmNlRnV0dXJlMihfY2FsbGJhY2ssIF90aGF0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBfY2FsbGJhY2s7XG4gICAgdGhpcy5fdGhhdCA9IF90aGF0O1xuICAgIHRoaXMuX2lzQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgfVxuICBfX25hbWUoQmluZE9uY2VGdXR1cmUyLCBcIkJpbmRPbmNlRnV0dXJlXCIpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZE9uY2VGdXR1cmUyLnByb3RvdHlwZSwgXCJpc0NhbGxlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0NhbGxlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRPbmNlRnV0dXJlMi5wcm90b3R5cGUsIFwicHJvbWlzZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZlcnJlZC5wcm9taXNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBCaW5kT25jZUZ1dHVyZTIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EzO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzQ2FsbGVkKSB7XG4gICAgICB0aGlzLl9pc0NhbGxlZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKF9hMyA9IHRoaXMuX2NhbGxiYWNrKS5jYWxsLmFwcGx5KF9hMywgX19zcHJlYWRBcnJheTMoW3RoaXMuX3RoYXRdLCBfX3JlYWQzKGFyZ3MpLCBmYWxzZSkpKS50aGVuKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVmZXJyZWQucmVzb2x2ZSh2YWwpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2RlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9kZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZmVycmVkLnByb21pc2U7XG4gIH07XG4gIHJldHVybiBCaW5kT25jZUZ1dHVyZTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9lbnVtcy5qc1xudmFyIEV4Y2VwdGlvbkV2ZW50TmFtZSA9IFwiZXhjZXB0aW9uXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9TcGFuLmpzXG52YXIgX192YWx1ZXMzID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZDQgPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIGUgPSB7IGVycm9yOiBlcnJvcjIgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xudmFyIFNwYW4gPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3BhbjMocGFyZW50VHJhY2VyLCBjb250ZXh0Mywgc3Bhbk5hbWUsIHNwYW5Db250ZXh0LCBraW5kLCBwYXJlbnRTcGFuSWQsIGxpbmtzLCBzdGFydFRpbWUpIHtcbiAgICBpZiAobGlua3MgPT09IHZvaWQgMCkge1xuICAgICAgbGlua3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBoclRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5saW5rcyA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5zdGF0dXMgPSB7XG4gICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5VTlNFVFxuICAgIH07XG4gICAgdGhpcy5lbmRUaW1lID0gWzAsIDBdO1xuICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBbLTEsIC0xXTtcbiAgICB0aGlzLm5hbWUgPSBzcGFuTmFtZTtcbiAgICB0aGlzLl9zcGFuQ29udGV4dCA9IHNwYW5Db250ZXh0O1xuICAgIHRoaXMucGFyZW50U3BhbklkID0gcGFyZW50U3BhbklkO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGltZUlucHV0VG9IclRpbWUoc3RhcnRUaW1lKTtcbiAgICB0aGlzLnJlc291cmNlID0gcGFyZW50VHJhY2VyLnJlc291cmNlO1xuICAgIHRoaXMuaW5zdHJ1bWVudGF0aW9uTGlicmFyeSA9IHBhcmVudFRyYWNlci5pbnN0cnVtZW50YXRpb25MaWJyYXJ5O1xuICAgIHRoaXMuX3NwYW5MaW1pdHMgPSBwYXJlbnRUcmFjZXIuZ2V0U3BhbkxpbWl0cygpO1xuICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3IgPSBwYXJlbnRUcmFjZXIuZ2V0QWN0aXZlU3BhblByb2Nlc3NvcigpO1xuICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3Iub25TdGFydCh0aGlzLCBjb250ZXh0Myk7XG4gICAgdGhpcy5fYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdCA9IHRoaXMuX3NwYW5MaW1pdHMuYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdCB8fCAwO1xuICB9XG4gIF9fbmFtZShTcGFuMywgXCJTcGFuXCIpO1xuICBTcGFuMy5wcm90b3R5cGUuc3BhbkNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhbkNvbnRleHQ7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdGhpcy5faXNTcGFuRW5kZWQoKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkaWFnMi53YXJuKFwiSW52YWxpZCBhdHRyaWJ1dGUga2V5OiBcIiArIGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFpc0F0dHJpYnV0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgZGlhZzIud2FybihcIkludmFsaWQgYXR0cmlidXRlIHZhbHVlIHNldCBmb3Iga2V5OiBcIiArIGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykubGVuZ3RoID49IHRoaXMuX3NwYW5MaW1pdHMuYXR0cmlidXRlQ291bnRMaW1pdCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywga2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuYXR0cmlidXRlc1trZXldID0gdGhpcy5fdHJ1bmNhdGVUb1NpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBTcGFuMy5wcm90b3R5cGUuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZV8xLCBfYTM7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iMiA9IF9fdmFsdWVzMyhPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSksIF9jID0gX2IyLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IyLm5leHQoKSkge1xuICAgICAgICB2YXIgX2QgPSBfX3JlYWQ0KF9jLnZhbHVlLCAyKSwgayA9IF9kWzBdLCB2ID0gX2RbMV07XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMyA9IF9iMi5yZXR1cm4pKVxuICAgICAgICAgIF9hMy5jYWxsKF9iMik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXNPclN0YXJ0VGltZSwgc3RhcnRUaW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5fc3BhbkxpbWl0cy5ldmVudENvdW50TGltaXQgPT09IDApIHtcbiAgICAgIGRpYWcyLndhcm4oXCJObyBldmVudHMgYWxsb3dlZC5cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSB0aGlzLl9zcGFuTGltaXRzLmV2ZW50Q291bnRMaW1pdCkge1xuICAgICAgZGlhZzIud2FybihcIkRyb3BwaW5nIGV4dHJhIGV2ZW50cy5cIik7XG4gICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoaXNUaW1lSW5wdXQoYXR0cmlidXRlc09yU3RhcnRUaW1lKSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydFRpbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gYXR0cmlidXRlc09yU3RhcnRUaW1lO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc09yU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0VGltZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc3RhcnRUaW1lID0gaHJUaW1lKCk7XG4gICAgfVxuICAgIHZhciBhdHRyaWJ1dGVzID0gc2FuaXRpemVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNPclN0YXJ0VGltZSk7XG4gICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHRpbWU6IHRpbWVJbnB1dFRvSHJUaW1lKHN0YXJ0VGltZSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgIGlmICh0aGlzLl9pc1NwYW5FbmRlZCgpKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS51cGRhdGVOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0aGlzLl9pc1NwYW5FbmRlZCgpKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGVuZFRpbWUpIHtcbiAgICBpZiAoZW5kVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmRUaW1lID0gaHJUaW1lKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NwYW5FbmRlZCgpKSB7XG4gICAgICBkaWFnMi5lcnJvcihcIllvdSBjYW4gb25seSBjYWxsIGVuZCgpIG9uIGEgc3BhbiBvbmNlLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIHRoaXMuZW5kVGltZSA9IHRpbWVJbnB1dFRvSHJUaW1lKGVuZFRpbWUpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gaHJUaW1lRHVyYXRpb24odGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSk7XG4gICAgaWYgKHRoaXMuX2R1cmF0aW9uWzBdIDwgMCkge1xuICAgICAgZGlhZzIud2FybihcIkluY29uc2lzdGVudCBzdGFydCBhbmQgZW5kIHRpbWUsIHN0YXJ0VGltZSA+IGVuZFRpbWVcIiwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSk7XG4gICAgfVxuICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3Iub25FbmQodGhpcyk7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS5pc1JlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmRlZCA9PT0gZmFsc2U7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS5yZWNvcmRFeGNlcHRpb24gPSBmdW5jdGlvbihleGNlcHRpb24sIHRpbWUpIHtcbiAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lID0gaHJUaW1lKCk7XG4gICAgfVxuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHR5cGVvZiBleGNlcHRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9NRVNTQUdFXSA9IGV4Y2VwdGlvbjtcbiAgICB9IGVsc2UgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKGV4Y2VwdGlvbi5jb2RlKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9UWVBFXSA9IGV4Y2VwdGlvbi5jb2RlLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKGV4Y2VwdGlvbi5uYW1lKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9UWVBFXSA9IGV4Y2VwdGlvbi5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2VwdGlvbi5tZXNzYWdlKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9NRVNTQUdFXSA9IGV4Y2VwdGlvbi5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2VwdGlvbi5zdGFjaykge1xuICAgICAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5FWENFUFRJT05fU1RBQ0tUUkFDRV0gPSBleGNlcHRpb24uc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5FWENFUFRJT05fVFlQRV0gfHwgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX01FU1NBR0VdKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50KEV4Y2VwdGlvbkV2ZW50TmFtZSwgYXR0cmlidXRlcywgdGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpYWcyLndhcm4oXCJGYWlsZWQgdG8gcmVjb3JkIGFuIGV4Y2VwdGlvbiBcIiArIGV4Y2VwdGlvbik7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BhbjMucHJvdG90eXBlLCBcImR1cmF0aW9uXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BhbjMucHJvdG90eXBlLCBcImVuZGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBTcGFuMy5wcm90b3R5cGUuX2lzU3BhbkVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgICBkaWFnMi53YXJuKFwiQ2FuIG5vdCBleGVjdXRlIHRoZSBvcGVyYXRpb24gb24gZW5kZWQgU3BhbiB7dHJhY2VJZDogXCIgKyB0aGlzLl9zcGFuQ29udGV4dC50cmFjZUlkICsgXCIsIHNwYW5JZDogXCIgKyB0aGlzLl9zcGFuQ29udGV4dC5zcGFuSWQgKyBcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbmRlZDtcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLl90cnVuY2F0ZVRvTGltaXRVdGlsID0gZnVuY3Rpb24odmFsdWUsIGxpbWl0KSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDAsIGxpbWl0KTtcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLl90cnVuY2F0ZVRvU2l6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0O1xuICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICBkaWFnMi53YXJuKFwiQXR0cmlidXRlIHZhbHVlIGxpbWl0IG11c3QgYmUgcG9zaXRpdmUsIGdvdCBcIiArIGxpbWl0KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RydW5jYXRlVG9MaW1pdFV0aWwodmFsdWUsIGxpbWl0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IF90aGlzLl90cnVuY2F0ZVRvTGltaXRVdGlsKHZhbCwgbGltaXQpIDogdmFsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgcmV0dXJuIFNwYW4zO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vU2FtcGxlci5qc1xudmFyIFNhbXBsaW5nRGVjaXNpb24yO1xuKGZ1bmN0aW9uKFNhbXBsaW5nRGVjaXNpb24zKSB7XG4gIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiTk9UX1JFQ09SRFwiXSA9IDBdID0gXCJOT1RfUkVDT1JEXCI7XG4gIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiUkVDT1JEXCJdID0gMV0gPSBcIlJFQ09SRFwiO1xuICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIlJFQ09SRF9BTkRfU0FNUExFRFwiXSA9IDJdID0gXCJSRUNPUkRfQU5EX1NBTVBMRURcIjtcbn0pKFNhbXBsaW5nRGVjaXNpb24yIHx8IChTYW1wbGluZ0RlY2lzaW9uMiA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL0Fsd2F5c09mZlNhbXBsZXIuanNcbnZhciBBbHdheXNPZmZTYW1wbGVyMiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBbHdheXNPZmZTYW1wbGVyMygpIHtcbiAgfVxuICBfX25hbWUoQWx3YXlzT2ZmU2FtcGxlcjMsIFwiQWx3YXlzT2ZmU2FtcGxlclwiKTtcbiAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogU2FtcGxpbmdEZWNpc2lvbjIuTk9UX1JFQ09SRFxuICAgIH07XG4gIH07XG4gIEFsd2F5c09mZlNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIkFsd2F5c09mZlNhbXBsZXJcIjtcbiAgfTtcbiAgcmV0dXJuIEFsd2F5c09mZlNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vc2FtcGxlci9BbHdheXNPblNhbXBsZXIuanNcbnZhciBBbHdheXNPblNhbXBsZXIyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFsd2F5c09uU2FtcGxlcjMoKSB7XG4gIH1cbiAgX19uYW1lKEFsd2F5c09uU2FtcGxlcjMsIFwiQWx3YXlzT25TYW1wbGVyXCIpO1xuICBBbHdheXNPblNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjaXNpb246IFNhbXBsaW5nRGVjaXNpb24yLlJFQ09SRF9BTkRfU0FNUExFRFxuICAgIH07XG4gIH07XG4gIEFsd2F5c09uU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiQWx3YXlzT25TYW1wbGVyXCI7XG4gIH07XG4gIHJldHVybiBBbHdheXNPblNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vc2FtcGxlci9QYXJlbnRCYXNlZFNhbXBsZXIuanNcbnZhciBQYXJlbnRCYXNlZFNhbXBsZXIyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFBhcmVudEJhc2VkU2FtcGxlcjMoY29uZmlnMikge1xuICAgIHZhciBfYTMsIF9iMiwgX2MsIF9kO1xuICAgIHRoaXMuX3Jvb3QgPSBjb25maWcyLnJvb3Q7XG4gICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICBnbG9iYWxFcnJvckhhbmRsZXIobmV3IEVycm9yKFwiUGFyZW50QmFzZWRTYW1wbGVyIG11c3QgaGF2ZSBhIHJvb3Qgc2FtcGxlciBjb25maWd1cmVkXCIpKTtcbiAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkID0gKF9hMyA9IGNvbmZpZzIucmVtb3RlUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQgPSAoX2IyID0gY29uZmlnMi5yZW1vdGVQYXJlbnROb3RTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYjIgIT09IHZvaWQgMCA/IF9iMiA6IG5ldyBBbHdheXNPZmZTYW1wbGVyMigpO1xuICAgIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZCA9IChfYyA9IGNvbmZpZzIubG9jYWxQYXJlbnRTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZCA9IChfZCA9IGNvbmZpZzIubG9jYWxQYXJlbnROb3RTYW1wbGVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgQWx3YXlzT2ZmU2FtcGxlcjIoKTtcbiAgfVxuICBfX25hbWUoUGFyZW50QmFzZWRTYW1wbGVyMywgXCJQYXJlbnRCYXNlZFNhbXBsZXJcIik7XG4gIFBhcmVudEJhc2VkU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKSB7XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChjb250ZXh0Myk7XG4gICAgaWYgKCFwYXJlbnRDb250ZXh0IHx8ICFpc1NwYW5Db250ZXh0VmFsaWQocGFyZW50Q29udGV4dCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb250ZXh0LmlzUmVtb3RlKSB7XG4gICAgICBpZiAocGFyZW50Q29udGV4dC50cmFjZUZsYWdzICYgVHJhY2VGbGFncy5TQU1QTEVEKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgIH1cbiAgICBpZiAocGFyZW50Q29udGV4dC50cmFjZUZsYWdzICYgVHJhY2VGbGFncy5TQU1QTEVEKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb2NhbFBhcmVudE5vdFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgfTtcbiAgUGFyZW50QmFzZWRTYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJQYXJlbnRCYXNlZHtyb290PVwiICsgdGhpcy5fcm9vdC50b1N0cmluZygpICsgXCIsIHJlbW90ZVBhcmVudFNhbXBsZWQ9XCIgKyB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgcmVtb3RlUGFyZW50Tm90U2FtcGxlZD1cIiArIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCBsb2NhbFBhcmVudFNhbXBsZWQ9XCIgKyB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCBsb2NhbFBhcmVudE5vdFNhbXBsZWQ9XCIgKyB0aGlzLl9sb2NhbFBhcmVudE5vdFNhbXBsZWQudG9TdHJpbmcoKSArIFwifVwiO1xuICB9O1xuICByZXR1cm4gUGFyZW50QmFzZWRTYW1wbGVyMztcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3NhbXBsZXIvVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyLmpzXG52YXIgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzKF9yYXRpbykge1xuICAgIGlmIChfcmF0aW8gPT09IHZvaWQgMCkge1xuICAgICAgX3JhdGlvID0gMDtcbiAgICB9XG4gICAgdGhpcy5fcmF0aW8gPSBfcmF0aW87XG4gICAgdGhpcy5fcmF0aW8gPSB0aGlzLl9ub3JtYWxpemUoX3JhdGlvKTtcbiAgICB0aGlzLl91cHBlckJvdW5kID0gTWF0aC5mbG9vcih0aGlzLl9yYXRpbyAqIDQyOTQ5NjcyOTUpO1xuICB9XG4gIF9fbmFtZShUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLCBcIlRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlclwiKTtcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oY29udGV4dDMsIHRyYWNlSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjaXNpb246IGlzVmFsaWRUcmFjZUlkKHRyYWNlSWQpICYmIHRoaXMuX2FjY3VtdWxhdGUodHJhY2VJZCkgPCB0aGlzLl91cHBlckJvdW5kID8gU2FtcGxpbmdEZWNpc2lvbjIuUkVDT1JEX0FORF9TQU1QTEVEIDogU2FtcGxpbmdEZWNpc2lvbjIuTk9UX1JFQ09SRFxuICAgIH07XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiVHJhY2VJZFJhdGlvQmFzZWR7XCIgKyB0aGlzLl9yYXRpbyArIFwifVwiO1xuICB9O1xuICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5fbm9ybWFsaXplID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICBpZiAodHlwZW9mIHJhdGlvICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHJhdGlvKSlcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiByYXRpbyA+PSAxID8gMSA6IHJhdGlvIDw9IDAgPyAwIDogcmF0aW87XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLl9hY2N1bXVsYXRlID0gZnVuY3Rpb24odHJhY2VJZCkge1xuICAgIHZhciBhY2N1bXVsYXRpb24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VJZC5sZW5ndGggLyA4OyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBpICogODtcbiAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQodHJhY2VJZC5zbGljZShwb3MsIHBvcyArIDgpLCAxNik7XG4gICAgICBhY2N1bXVsYXRpb24gPSAoYWNjdW11bGF0aW9uIF4gcGFydCkgPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRpb247XG4gIH07XG4gIHJldHVybiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vY29uZmlnLmpzXG52YXIgZW52ID0gZ2V0RW52KCk7XG52YXIgRkFMTEJBQ0tfT1RFTF9UUkFDRVNfU0FNUExFUiA9IFRyYWNlc1NhbXBsZXJWYWx1ZXMuQWx3YXlzT247XG52YXIgREVGQVVMVF9SQVRJTyA9IDE7XG5mdW5jdGlvbiBsb2FkRGVmYXVsdENvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVyOiBidWlsZFNhbXBsZXJGcm9tRW52KGVudiksXG4gICAgZm9yY2VGbHVzaFRpbWVvdXRNaWxsaXM6IDNlNCxcbiAgICBnZW5lcmFsTGltaXRzOiB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0OiBnZXRFbnYoKS5PVEVMX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQsXG4gICAgICBhdHRyaWJ1dGVDb3VudExpbWl0OiBnZXRFbnYoKS5PVEVMX0FUVFJJQlVURV9DT1VOVF9MSU1JVFxuICAgIH0sXG4gICAgc3BhbkxpbWl0czoge1xuICAgICAgYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdDogZ2V0RW52KCkuT1RFTF9TUEFOX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQsXG4gICAgICBhdHRyaWJ1dGVDb3VudExpbWl0OiBnZXRFbnYoKS5PVEVMX1NQQU5fQVRUUklCVVRFX0NPVU5UX0xJTUlULFxuICAgICAgbGlua0NvdW50TGltaXQ6IGdldEVudigpLk9URUxfU1BBTl9MSU5LX0NPVU5UX0xJTUlULFxuICAgICAgZXZlbnRDb3VudExpbWl0OiBnZXRFbnYoKS5PVEVMX1NQQU5fRVZFTlRfQ09VTlRfTElNSVRcbiAgICB9XG4gIH07XG59XG5fX25hbWUobG9hZERlZmF1bHRDb25maWcsIFwibG9hZERlZmF1bHRDb25maWdcIik7XG5mdW5jdGlvbiBidWlsZFNhbXBsZXJGcm9tRW52KGVudmlyb25tZW50KSB7XG4gIGlmIChlbnZpcm9ubWVudCA9PT0gdm9pZCAwKSB7XG4gICAgZW52aXJvbm1lbnQgPSBnZXRFbnYoKTtcbiAgfVxuICBzd2l0Y2ggKGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVIpIHtcbiAgICBjYXNlIFRyYWNlc1NhbXBsZXJWYWx1ZXMuQWx3YXlzT246XG4gICAgICByZXR1cm4gbmV3IEFsd2F5c09uU2FtcGxlcjIoKTtcbiAgICBjYXNlIFRyYWNlc1NhbXBsZXJWYWx1ZXMuQWx3YXlzT2ZmOlxuICAgICAgcmV0dXJuIG5ldyBBbHdheXNPZmZTYW1wbGVyMigpO1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5QYXJlbnRCYXNlZEFsd2F5c09uOlxuICAgICAgcmV0dXJuIG5ldyBQYXJlbnRCYXNlZFNhbXBsZXIyKHtcbiAgICAgICAgcm9vdDogbmV3IEFsd2F5c09uU2FtcGxlcjIoKVxuICAgICAgfSk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkQWx3YXlzT2ZmOlxuICAgICAgcmV0dXJuIG5ldyBQYXJlbnRCYXNlZFNhbXBsZXIyKHtcbiAgICAgICAgcm9vdDogbmV3IEFsd2F5c09mZlNhbXBsZXIyKClcbiAgICAgIH0pO1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5UcmFjZUlkUmF0aW86XG4gICAgICByZXR1cm4gbmV3IFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjIoZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudihlbnZpcm9ubWVudCkpO1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5QYXJlbnRCYXNlZFRyYWNlSWRSYXRpbzpcbiAgICAgIHJldHVybiBuZXcgUGFyZW50QmFzZWRTYW1wbGVyMih7XG4gICAgICAgIHJvb3Q6IG5ldyBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIyKGdldFNhbXBsZXJQcm9iYWJpbGl0eUZyb21FbnYoZW52aXJvbm1lbnQpKVxuICAgICAgfSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRpYWcyLmVycm9yKCdPVEVMX1RSQUNFU19TQU1QTEVSIHZhbHVlIFwiJyArIGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVIgKyBcIiBpbnZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiICsgRkFMTEJBQ0tfT1RFTF9UUkFDRVNfU0FNUExFUiArICdcIi4nKTtcbiAgICAgIHJldHVybiBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICB9XG59XG5fX25hbWUoYnVpbGRTYW1wbGVyRnJvbUVudiwgXCJidWlsZFNhbXBsZXJGcm9tRW52XCIpO1xuZnVuY3Rpb24gZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudihlbnZpcm9ubWVudCkge1xuICBpZiAoZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcgPT09IHZvaWQgMCB8fCBlbnZpcm9ubWVudC5PVEVMX1RSQUNFU19TQU1QTEVSX0FSRyA9PT0gXCJcIikge1xuICAgIGRpYWcyLmVycm9yKFwiT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcgaXMgYmxhbmssIGRlZmF1bHRpbmcgdG8gXCIgKyBERUZBVUxUX1JBVElPICsgXCIuXCIpO1xuICAgIHJldHVybiBERUZBVUxUX1JBVElPO1xuICB9XG4gIHZhciBwcm9iYWJpbGl0eSA9IE51bWJlcihlbnZpcm9ubWVudC5PVEVMX1RSQUNFU19TQU1QTEVSX0FSRyk7XG4gIGlmIChpc05hTihwcm9iYWJpbGl0eSkpIHtcbiAgICBkaWFnMi5lcnJvcihcIk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHPVwiICsgZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcgKyBcIiB3YXMgZ2l2ZW4sIGJ1dCBpdCBpcyBpbnZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiICsgREVGQVVMVF9SQVRJTyArIFwiLlwiKTtcbiAgICByZXR1cm4gREVGQVVMVF9SQVRJTztcbiAgfVxuICBpZiAocHJvYmFiaWxpdHkgPCAwIHx8IHByb2JhYmlsaXR5ID4gMSkge1xuICAgIGRpYWcyLmVycm9yKFwiT1RFTF9UUkFDRVNfU0FNUExFUl9BUkc9XCIgKyBlbnZpcm9ubWVudC5PVEVMX1RSQUNFU19TQU1QTEVSX0FSRyArIFwiIHdhcyBnaXZlbiwgYnV0IGl0IGlzIG91dCBvZiByYW5nZSAoWzAuLjFdKSwgZGVmYXVsdGluZyB0byBcIiArIERFRkFVTFRfUkFUSU8gKyBcIi5cIik7XG4gICAgcmV0dXJuIERFRkFVTFRfUkFUSU87XG4gIH1cbiAgcmV0dXJuIHByb2JhYmlsaXR5O1xufVxuX19uYW1lKGdldFNhbXBsZXJQcm9iYWJpbGl0eUZyb21FbnYsIFwiZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudlwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3V0aWxpdHkuanNcbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKHVzZXJDb25maWcpIHtcbiAgdmFyIHBlckluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgc2FtcGxlcjogYnVpbGRTYW1wbGVyRnJvbUVudigpXG4gIH07XG4gIHZhciBERUZBVUxUX0NPTkZJRyA9IGxvYWREZWZhdWx0Q29uZmlnKCk7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgcGVySW5zdGFuY2VEZWZhdWx0cywgdXNlckNvbmZpZyk7XG4gIHRhcmdldC5nZW5lcmFsTGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9DT05GSUcuZ2VuZXJhbExpbWl0cywgdXNlckNvbmZpZy5nZW5lcmFsTGltaXRzIHx8IHt9KTtcbiAgdGFyZ2V0LnNwYW5MaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRy5zcGFuTGltaXRzLCB1c2VyQ29uZmlnLnNwYW5MaW1pdHMgfHwge30pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuX19uYW1lKG1lcmdlQ29uZmlnLCBcIm1lcmdlQ29uZmlnXCIpO1xuZnVuY3Rpb24gcmVjb25maWd1cmVMaW1pdHModXNlckNvbmZpZykge1xuICB2YXIgX2EzLCBfYjIsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICB2YXIgc3BhbkxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIHVzZXJDb25maWcuc3BhbkxpbWl0cyk7XG4gIHZhciBwYXJzZWRFbnZDb25maWcgPSBnZXRFbnZXaXRob3V0RGVmYXVsdHMoKTtcbiAgc3BhbkxpbWl0cy5hdHRyaWJ1dGVDb3VudExpbWl0ID0gKF9mID0gKF9lID0gKF9kID0gKF9iMiA9IChfYTMgPSB1c2VyQ29uZmlnLnNwYW5MaW1pdHMpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzLmF0dHJpYnV0ZUNvdW50TGltaXQpICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogKF9jID0gdXNlckNvbmZpZy5nZW5lcmFsTGltaXRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYXR0cmlidXRlQ291bnRMaW1pdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyc2VkRW52Q29uZmlnLk9URUxfU1BBTl9BVFRSSUJVVEVfQ09VTlRfTElNSVQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHBhcnNlZEVudkNvbmZpZy5PVEVMX0FUVFJJQlVURV9DT1VOVF9MSU1JVCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogREVGQVVMVF9BVFRSSUJVVEVfQ09VTlRfTElNSVQ7XG4gIHNwYW5MaW1pdHMuYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdCA9IChfbSA9IChfbCA9IChfayA9IChfaCA9IChfZyA9IHVzZXJDb25maWcuc3BhbkxpbWl0cykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmF0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IChfaiA9IHVzZXJDb25maWcuZ2VuZXJhbExpbWl0cykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmF0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcnNlZEVudkNvbmZpZy5PVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogcGFyc2VkRW52Q29uZmlnLk9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogREVGQVVMVF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdXNlckNvbmZpZywgeyBzcGFuTGltaXRzIH0pO1xufVxuX19uYW1lKHJlY29uZmlndXJlTGltaXRzLCBcInJlY29uZmlndXJlTGltaXRzXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0JhdGNoU3BhblByb2Nlc3NvckJhc2UuanNcbnZhciBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyKF9leHBvcnRlciwgY29uZmlnMikge1xuICAgIHRoaXMuX2V4cG9ydGVyID0gX2V4cG9ydGVyO1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB2YXIgZW52MiA9IGdldEVudigpO1xuICAgIHRoaXMuX21heEV4cG9ydEJhdGNoU2l6ZSA9IHR5cGVvZiAoY29uZmlnMiA9PT0gbnVsbCB8fCBjb25maWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcyLm1heEV4cG9ydEJhdGNoU2l6ZSkgPT09IFwibnVtYmVyXCIgPyBjb25maWcyLm1heEV4cG9ydEJhdGNoU2l6ZSA6IGVudjIuT1RFTF9CU1BfTUFYX0VYUE9SVF9CQVRDSF9TSVpFO1xuICAgIHRoaXMuX21heFF1ZXVlU2l6ZSA9IHR5cGVvZiAoY29uZmlnMiA9PT0gbnVsbCB8fCBjb25maWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcyLm1heFF1ZXVlU2l6ZSkgPT09IFwibnVtYmVyXCIgPyBjb25maWcyLm1heFF1ZXVlU2l6ZSA6IGVudjIuT1RFTF9CU1BfTUFYX1FVRVVFX1NJWkU7XG4gICAgdGhpcy5fc2NoZWR1bGVkRGVsYXlNaWxsaXMgPSB0eXBlb2YgKGNvbmZpZzIgPT09IG51bGwgfHwgY29uZmlnMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnMi5zY2hlZHVsZWREZWxheU1pbGxpcykgPT09IFwibnVtYmVyXCIgPyBjb25maWcyLnNjaGVkdWxlZERlbGF5TWlsbGlzIDogZW52Mi5PVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWTtcbiAgICB0aGlzLl9leHBvcnRUaW1lb3V0TWlsbGlzID0gdHlwZW9mIChjb25maWcyID09PSBudWxsIHx8IGNvbmZpZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZzIuZXhwb3J0VGltZW91dE1pbGxpcykgPT09IFwibnVtYmVyXCIgPyBjb25maWcyLmV4cG9ydFRpbWVvdXRNaWxsaXMgOiBlbnYyLk9URUxfQlNQX0VYUE9SVF9USU1FT1VUO1xuICAgIHRoaXMuX3NodXRkb3duT25jZSA9IG5ldyBCaW5kT25jZUZ1dHVyZSh0aGlzLl9zaHV0ZG93biwgdGhpcyk7XG4gIH1cbiAgX19uYW1lKEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLCBcIkJhdGNoU3BhblByb2Nlc3NvckJhc2VcIik7XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NodXRkb3duT25jZS5pc0NhbGxlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NodXRkb3duT25jZS5wcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmx1c2hBbGwoKTtcbiAgfTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbihfc3BhbiwgX3BhcmVudENvbnRleHQpIHtcbiAgfTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3Bhbikge1xuICAgIGlmICh0aGlzLl9zaHV0ZG93bk9uY2UuaXNDYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWRkVG9CdWZmZXIoc3Bhbik7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zaHV0ZG93bk9uY2UuY2FsbCgpO1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX3NodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfdGhpcy5vblNodXRkb3duKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZmx1c2hBbGwoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9leHBvcnRlci5zaHV0ZG93bigpO1xuICAgIH0pO1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX2FkZFRvQnVmZmVyID0gZnVuY3Rpb24oc3Bhbikge1xuICAgIGlmICh0aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aCA+PSB0aGlzLl9tYXhRdWV1ZVNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZmluaXNoZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgIHRoaXMuX21heWJlU3RhcnRUaW1lcigpO1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX2ZsdXNoQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudDIgPSBNYXRoLmNlaWwoX3RoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoIC8gX3RoaXMuX21heEV4cG9ydEJhdGNoU2l6ZSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvdW50MjsgaSA8IGo7IGkrKykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKF90aGlzLl9mbHVzaE9uZUJhdGNoKCkpO1xuICAgICAgfVxuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fZmx1c2hPbmVCYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgIGlmICh0aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dFwiKSk7XG4gICAgICB9LCBfdGhpcy5fZXhwb3J0VGltZW91dE1pbGxpcyk7XG4gICAgICBjb250ZXh0Mi53aXRoKHN1cHByZXNzVHJhY2luZyhjb250ZXh0Mi5hY3RpdmUoKSksIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fZXhwb3J0ZXIuZXhwb3J0KF90aGlzLl9maW5pc2hlZFNwYW5zLnNwbGljZSgwLCBfdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKSwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIGlmIChyZXN1bHQuY29kZSA9PT0gRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgoX2EzID0gcmVzdWx0LmVycm9yKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IG5ldyBFcnJvcihcIkJhdGNoU3BhblByb2Nlc3Nvcjogc3BhbiBleHBvcnQgZmFpbGVkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fbWF5YmVTdGFydFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5fdGltZXIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5fZmx1c2hPbmVCYXRjaCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfdGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3RoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgICAgICBfdGhpcy5fbWF5YmVTdGFydFRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcy5fc2NoZWR1bGVkRGVsYXlNaWxsaXMpO1xuICAgIHVucmVmVGltZXIodGhpcy5fdGltZXIpO1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX2NsZWFyVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdGltZXIgIT09IHZvaWQgMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9leHBvcnQvQmF0Y2hTcGFuUHJvY2Vzc29yLmpzXG52YXIgX19leHRlbmRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBleHRlbmRTdGF0aWNzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYjIpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgIGQyW3BdID0gYjJbcF07XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfSwgXCJleHRlbmRTdGF0aWNzXCIpO1xuICByZXR1cm4gZnVuY3Rpb24oZCwgYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cbiAgICBfX25hbWUoX18sIFwiX19cIik7XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xudmFyIEJhdGNoU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQmF0Y2hTcGFuUHJvY2Vzc29yMiwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQmF0Y2hTcGFuUHJvY2Vzc29yMigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgX19uYW1lKEJhdGNoU3BhblByb2Nlc3NvcjIsIFwiQmF0Y2hTcGFuUHJvY2Vzc29yXCIpO1xuICBCYXRjaFNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vblNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIHJldHVybiBCYXRjaFNwYW5Qcm9jZXNzb3IyO1xufShCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmFuZG9tSWRHZW5lcmF0b3IuanNcbnZhciBTUEFOX0lEX0JZVEVTMiA9IDg7XG52YXIgVFJBQ0VfSURfQllURVMyID0gMTY7XG52YXIgUmFuZG9tSWRHZW5lcmF0b3IyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJhbmRvbUlkR2VuZXJhdG9yMygpIHtcbiAgICB0aGlzLmdlbmVyYXRlVHJhY2VJZCA9IGdldElkR2VuZXJhdG9yMihUUkFDRV9JRF9CWVRFUzIpO1xuICAgIHRoaXMuZ2VuZXJhdGVTcGFuSWQgPSBnZXRJZEdlbmVyYXRvcjIoU1BBTl9JRF9CWVRFUzIpO1xuICB9XG4gIF9fbmFtZShSYW5kb21JZEdlbmVyYXRvcjMsIFwiUmFuZG9tSWRHZW5lcmF0b3JcIik7XG4gIHJldHVybiBSYW5kb21JZEdlbmVyYXRvcjM7XG59KCk7XG52YXIgU0hBUkVEX0JVRkZFUjIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoVFJBQ0VfSURfQllURVMyKTtcbmZ1bmN0aW9uIGdldElkR2VuZXJhdG9yMihieXRlcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMgLyA0OyBpKyspIHtcbiAgICAgIFNIQVJFRF9CVUZGRVIyLndyaXRlVUludDMyQkUoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIDMyKSA+Pj4gMCwgaSAqIDQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgIGlmIChTSEFSRURfQlVGRkVSMltpXSA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGJ5dGVzIC0gMSkge1xuICAgICAgICBTSEFSRURfQlVGRkVSMltieXRlcyAtIDFdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNIQVJFRF9CVUZGRVIyLnRvU3RyaW5nKFwiaGV4XCIsIDAsIGJ5dGVzKTtcbiAgfSwgXCJnZW5lcmF0ZUlkXCIpO1xufVxuX19uYW1lKGdldElkR2VuZXJhdG9yMiwgXCJnZXRJZEdlbmVyYXRvclwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL1RyYWNlci5qc1xudmFyIFRyYWNlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmFjZXIzKGluc3RydW1lbnRhdGlvbkxpYnJhcnksIGNvbmZpZzIsIF90cmFjZXJQcm92aWRlcikge1xuICAgIHRoaXMuX3RyYWNlclByb3ZpZGVyID0gX3RyYWNlclByb3ZpZGVyO1xuICAgIHZhciBsb2NhbENvbmZpZyA9IG1lcmdlQ29uZmlnKGNvbmZpZzIpO1xuICAgIHRoaXMuX3NhbXBsZXIgPSBsb2NhbENvbmZpZy5zYW1wbGVyO1xuICAgIHRoaXMuX2dlbmVyYWxMaW1pdHMgPSBsb2NhbENvbmZpZy5nZW5lcmFsTGltaXRzO1xuICAgIHRoaXMuX3NwYW5MaW1pdHMgPSBsb2NhbENvbmZpZy5zcGFuTGltaXRzO1xuICAgIHRoaXMuX2lkR2VuZXJhdG9yID0gY29uZmlnMi5pZEdlbmVyYXRvciB8fCBuZXcgUmFuZG9tSWRHZW5lcmF0b3IyKCk7XG4gICAgdGhpcy5yZXNvdXJjZSA9IF90cmFjZXJQcm92aWRlci5yZXNvdXJjZTtcbiAgICB0aGlzLmluc3RydW1lbnRhdGlvbkxpYnJhcnkgPSBpbnN0cnVtZW50YXRpb25MaWJyYXJ5O1xuICB9XG4gIF9fbmFtZShUcmFjZXIzLCBcIlRyYWNlclwiKTtcbiAgVHJhY2VyMy5wcm90b3R5cGUuc3RhcnRTcGFuID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgY29udGV4dDMpIHtcbiAgICB2YXIgX2EzLCBfYjI7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dDMgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dDMgPSBjb250ZXh0Mi5hY3RpdmUoKTtcbiAgICB9XG4gICAgaWYgKGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDMpKSB7XG4gICAgICBkaWFnMi5kZWJ1ZyhcIkluc3RydW1lbnRhdGlvbiBzdXBwcmVzc2VkLCByZXR1cm5pbmcgTm9vcCBTcGFuXCIpO1xuICAgICAgcmV0dXJuIHRyYWNlLndyYXBTcGFuQ29udGV4dChJTlZBTElEX1NQQU5fQ09OVEVYVCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJvb3QpIHtcbiAgICAgIGNvbnRleHQzID0gdHJhY2UuZGVsZXRlU3Bhbihjb250ZXh0Myk7XG4gICAgfVxuICAgIHZhciBwYXJlbnRTcGFuQ29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQzKTtcbiAgICB2YXIgc3BhbklkID0gdGhpcy5faWRHZW5lcmF0b3IuZ2VuZXJhdGVTcGFuSWQoKTtcbiAgICB2YXIgdHJhY2VJZDtcbiAgICB2YXIgdHJhY2VTdGF0ZTtcbiAgICB2YXIgcGFyZW50U3BhbklkO1xuICAgIGlmICghcGFyZW50U3BhbkNvbnRleHQgfHwgIXRyYWNlLmlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRTcGFuQ29udGV4dCkpIHtcbiAgICAgIHRyYWNlSWQgPSB0aGlzLl9pZEdlbmVyYXRvci5nZW5lcmF0ZVRyYWNlSWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2VJZCA9IHBhcmVudFNwYW5Db250ZXh0LnRyYWNlSWQ7XG4gICAgICB0cmFjZVN0YXRlID0gcGFyZW50U3BhbkNvbnRleHQudHJhY2VTdGF0ZTtcbiAgICAgIHBhcmVudFNwYW5JZCA9IHBhcmVudFNwYW5Db250ZXh0LnNwYW5JZDtcbiAgICB9XG4gICAgdmFyIHNwYW5LaW5kID0gKF9hMyA9IG9wdGlvbnMua2luZCkgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBTcGFuS2luZC5JTlRFUk5BTDtcbiAgICB2YXIgbGlua3MgPSAoKF9iMiA9IG9wdGlvbnMubGlua3MpICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogW10pLm1hcChmdW5jdGlvbihsaW5rKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiBsaW5rLmNvbnRleHQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNhbml0aXplQXR0cmlidXRlcyhsaW5rLmF0dHJpYnV0ZXMpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc2FuaXRpemVBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgdmFyIHNhbXBsaW5nUmVzdWx0ID0gdGhpcy5fc2FtcGxlci5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIG5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgdmFyIHRyYWNlRmxhZ3MgPSBzYW1wbGluZ1Jlc3VsdC5kZWNpc2lvbiA9PT0gU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRUQgPyBUcmFjZUZsYWdzLlNBTVBMRUQgOiBUcmFjZUZsYWdzLk5PTkU7XG4gICAgdmFyIHNwYW5Db250ZXh0ID0geyB0cmFjZUlkLCBzcGFuSWQsIHRyYWNlRmxhZ3MsIHRyYWNlU3RhdGUgfTtcbiAgICBpZiAoc2FtcGxpbmdSZXN1bHQuZGVjaXNpb24gPT09IFNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCkge1xuICAgICAgZGlhZzIuZGVidWcoXCJSZWNvcmRpbmcgaXMgb2ZmLCBwcm9wYWdhdGluZyBjb250ZXh0IGluIGEgbm9uLXJlY29yZGluZyBzcGFuXCIpO1xuICAgICAgcmV0dXJuIHRyYWNlLndyYXBTcGFuQ29udGV4dChzcGFuQ29udGV4dCk7XG4gICAgfVxuICAgIHZhciBzcGFuID0gbmV3IFNwYW4odGhpcywgY29udGV4dDMsIG5hbWUsIHNwYW5Db250ZXh0LCBzcGFuS2luZCwgcGFyZW50U3BhbklkLCBsaW5rcywgb3B0aW9ucy5zdGFydFRpbWUpO1xuICAgIHZhciBpbml0QXR0cmlidXRlcyA9IHNhbml0aXplQXR0cmlidXRlcyhPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHNhbXBsaW5nUmVzdWx0LmF0dHJpYnV0ZXMpKTtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoaW5pdEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBzcGFuO1xuICB9O1xuICBUcmFjZXIzLnByb3RvdHlwZS5zdGFydEFjdGl2ZVNwYW4gPSBmdW5jdGlvbihuYW1lLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIG9wdHM7XG4gICAgdmFyIGN0eDtcbiAgICB2YXIgZm47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBmbiA9IGFyZzI7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBvcHRzID0gYXJnMjtcbiAgICAgIGZuID0gYXJnMztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cyA9IGFyZzI7XG4gICAgICBjdHggPSBhcmczO1xuICAgICAgZm4gPSBhcmc0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50Q29udGV4dCA9IGN0eCAhPT0gbnVsbCAmJiBjdHggIT09IHZvaWQgMCA/IGN0eCA6IGNvbnRleHQyLmFjdGl2ZSgpO1xuICAgIHZhciBzcGFuID0gdGhpcy5zdGFydFNwYW4obmFtZSwgb3B0cywgcGFyZW50Q29udGV4dCk7XG4gICAgdmFyIGNvbnRleHRXaXRoU3BhblNldCA9IHRyYWNlLnNldFNwYW4ocGFyZW50Q29udGV4dCwgc3Bhbik7XG4gICAgcmV0dXJuIGNvbnRleHQyLndpdGgoY29udGV4dFdpdGhTcGFuU2V0LCBmbiwgdm9pZCAwLCBzcGFuKTtcbiAgfTtcbiAgVHJhY2VyMy5wcm90b3R5cGUuZ2V0R2VuZXJhbExpbWl0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmFsTGltaXRzO1xuICB9O1xuICBUcmFjZXIzLnByb3RvdHlwZS5nZXRTcGFuTGltaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwYW5MaW1pdHM7XG4gIH07XG4gIFRyYWNlcjMucHJvdG90eXBlLmdldEFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2VyUHJvdmlkZXIuZ2V0QWN0aXZlU3BhblByb2Nlc3NvcigpO1xuICB9O1xuICByZXR1cm4gVHJhY2VyMztcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9kZWZhdWx0LXNlcnZpY2UtbmFtZS5qc1xuZnVuY3Rpb24gZGVmYXVsdFNlcnZpY2VOYW1lKCkge1xuICByZXR1cm4gXCJ1bmtub3duX3NlcnZpY2U6XCIgKyBwcm9jZXNzLmFyZ3YwO1xufVxuX19uYW1lKGRlZmF1bHRTZXJ2aWNlTmFtZSwgXCJkZWZhdWx0U2VydmljZU5hbWVcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStyZXNvdXJjZXNAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvSG9zdERldGVjdG9yLmpzXG52YXIgaW1wb3J0X29zMiA9IHJlcXVpcmUoXCJvc1wiKTtcbnZhciBfX2F3YWl0ZXIgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQMywgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUDMgPyB2YWx1ZSA6IG5ldyBQMyhmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfX25hbWUoYWRvcHQsIFwiYWRvcHRcIik7XG4gIHJldHVybiBuZXcgKFAzIHx8IChQMyA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZnVsZmlsbGVkLCBcImZ1bGZpbGxlZFwiKTtcbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWplY3RlZCwgXCJyZWplY3RlZFwiKTtcbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRbMF0gJiAxKVxuICAgICAgdGhyb3cgdFsxXTtcbiAgICByZXR1cm4gdFsxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBfX25hbWUodmVyYiwgXCJ2ZXJiXCIpO1xuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoXylcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgIHkgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgfVxuICAgIGlmIChvcFswXSAmIDUpXG4gICAgICB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG59O1xudmFyIEhvc3REZXRlY3RvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBIb3N0RGV0ZWN0b3IyKCkge1xuICB9XG4gIF9fbmFtZShIb3N0RGV0ZWN0b3IyLCBcIkhvc3REZXRlY3RvclwiKTtcbiAgSG9zdERldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oX2NvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXM7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9iMikge1xuICAgICAgICBhdHRyaWJ1dGVzID0gKF9hMyA9IHt9LCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuSE9TVF9OQU1FXSA9ICgwLCBpbXBvcnRfb3MyLmhvc3RuYW1lKSgpLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuSE9TVF9BUkNIXSA9IHRoaXMuX25vcm1hbGl6ZUFyY2goKDAsIGltcG9ydF9vczIuYXJjaCkoKSksIF9hMyk7XG4gICAgICAgIHJldHVybiBbMiwgbmV3IFJlc291cmNlKGF0dHJpYnV0ZXMpXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBIb3N0RGV0ZWN0b3IyLnByb3RvdHlwZS5fbm9ybWFsaXplQXJjaCA9IGZ1bmN0aW9uKG5vZGVBcmNoU3RyaW5nKSB7XG4gICAgc3dpdGNoIChub2RlQXJjaFN0cmluZykge1xuICAgICAgY2FzZSBcImFybVwiOlxuICAgICAgICByZXR1cm4gXCJhcm0zMlwiO1xuICAgICAgY2FzZSBcInBwY1wiOlxuICAgICAgICByZXR1cm4gXCJwcGMzMlwiO1xuICAgICAgY2FzZSBcIng2NFwiOlxuICAgICAgICByZXR1cm4gXCJhbWQ2NFwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5vZGVBcmNoU3RyaW5nO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEhvc3REZXRlY3RvcjI7XG59KCk7XG52YXIgaG9zdERldGVjdG9yID0gbmV3IEhvc3REZXRlY3RvcigpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL09TRGV0ZWN0b3IuanNcbnZhciBpbXBvcnRfb3MzID0gcmVxdWlyZShcIm9zXCIpO1xudmFyIF9fYXdhaXRlcjIgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQMywgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUDMgPyB2YWx1ZSA6IG5ldyBQMyhmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfX25hbWUoYWRvcHQsIFwiYWRvcHRcIik7XG4gIHJldHVybiBuZXcgKFAzIHx8IChQMyA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZnVsZmlsbGVkLCBcImZ1bGZpbGxlZFwiKTtcbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWplY3RlZCwgXCJyZWplY3RlZFwiKTtcbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IyID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0WzBdICYgMSlcbiAgICAgIHRocm93IHRbMV07XG4gICAgcmV0dXJuIHRbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgX19uYW1lKHZlcmIsIFwidmVyYlwiKTtcbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKF8pXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICB5ID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGYgPSB0ID0gMDtcbiAgICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBfX25hbWUoc3RlcCwgXCJzdGVwXCIpO1xufTtcbnZhciBPU0RldGVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE9TRGV0ZWN0b3IyKCkge1xuICB9XG4gIF9fbmFtZShPU0RldGVjdG9yMiwgXCJPU0RldGVjdG9yXCIpO1xuICBPU0RldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oX2NvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzO1xuICAgICAgdmFyIF9hMztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcjIodGhpcywgZnVuY3Rpb24oX2IyKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSAoX2EzID0ge30sIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5PU19UWVBFXSA9IHRoaXMuX25vcm1hbGl6ZVR5cGUoKDAsIGltcG9ydF9vczMucGxhdGZvcm0pKCkpLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuT1NfVkVSU0lPTl0gPSAoMCwgaW1wb3J0X29zMy5yZWxlYXNlKSgpLCBfYTMpO1xuICAgICAgICByZXR1cm4gWzIsIG5ldyBSZXNvdXJjZShhdHRyaWJ1dGVzKV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgT1NEZXRlY3RvcjIucHJvdG90eXBlLl9ub3JtYWxpemVUeXBlID0gZnVuY3Rpb24obm9kZVBsYXRmb3JtKSB7XG4gICAgc3dpdGNoIChub2RlUGxhdGZvcm0pIHtcbiAgICAgIGNhc2UgXCJzdW5vc1wiOlxuICAgICAgICByZXR1cm4gXCJzb2xhcmlzXCI7XG4gICAgICBjYXNlIFwid2luMzJcIjpcbiAgICAgICAgcmV0dXJuIFwid2luZG93c1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5vZGVQbGF0Zm9ybTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPU0RldGVjdG9yMjtcbn0oKTtcbnZhciBvc0RldGVjdG9yID0gbmV3IE9TRGV0ZWN0b3IoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vUmVzb3VyY2UuanNcbnZhciBSZXNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNvdXJjZTIoYXR0cmlidXRlcykge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cbiAgX19uYW1lKFJlc291cmNlMiwgXCJSZXNvdXJjZVwiKTtcbiAgUmVzb3VyY2UyLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFJlc291cmNlMi5FTVBUWTtcbiAgfTtcbiAgUmVzb3VyY2UyLmRlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiBuZXcgUmVzb3VyY2UyKChfYTMgPSB7fSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlNFUlZJQ0VfTkFNRV0gPSBkZWZhdWx0U2VydmljZU5hbWUoKSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfTEFOR1VBR0VdID0gU0RLX0lORk9bU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19MQU5HVUFHRV0sIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX05BTUVdID0gU0RLX0lORk9bU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19OQU1FXSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfVkVSU0lPTl0gPSBTREtfSU5GT1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX1ZFUlNJT05dLCBfYTMpKTtcbiAgfTtcbiAgUmVzb3VyY2UyLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCFvdGhlciB8fCAhT2JqZWN0LmtleXMob3RoZXIuYXR0cmlidXRlcykubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG1lcmdlZEF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIG90aGVyLmF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBuZXcgUmVzb3VyY2UyKG1lcmdlZEF0dHJpYnV0ZXMpO1xuICB9O1xuICBSZXNvdXJjZTIuRU1QVFkgPSBuZXcgUmVzb3VyY2UyKHt9KTtcbiAgcmV0dXJuIFJlc291cmNlMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL0Jyb3dzZXJEZXRlY3Rvci5qc1xudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQMywgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUDMgPyB2YWx1ZSA6IG5ldyBQMyhmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfX25hbWUoYWRvcHQsIFwiYWRvcHRcIik7XG4gIHJldHVybiBuZXcgKFAzIHx8IChQMyA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZnVsZmlsbGVkLCBcImZ1bGZpbGxlZFwiKTtcbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWplY3RlZCwgXCJyZWplY3RlZFwiKTtcbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IzID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0WzBdICYgMSlcbiAgICAgIHRocm93IHRbMV07XG4gICAgcmV0dXJuIHRbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgX19uYW1lKHZlcmIsIFwidmVyYlwiKTtcbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKF8pXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICB5ID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGYgPSB0ID0gMDtcbiAgICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBfX25hbWUoc3RlcCwgXCJzdGVwXCIpO1xufTtcbnZhciBCcm93c2VyRGV0ZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQnJvd3NlckRldGVjdG9yMigpIHtcbiAgfVxuICBfX25hbWUoQnJvd3NlckRldGVjdG9yMiwgXCJCcm93c2VyRGV0ZWN0b3JcIik7XG4gIEJyb3dzZXJEZXRlY3RvcjIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKGNvbmZpZzIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyMyh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNCcm93c2VyLCBicm93c2VyUmVzb3VyY2U7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yMyh0aGlzLCBmdW5jdGlvbihfYjIpIHtcbiAgICAgICAgaXNCcm93c2VyID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgICByZXR1cm4gWzIsIFJlc291cmNlLmVtcHR5KCldO1xuICAgICAgICB9XG4gICAgICAgIGJyb3dzZXJSZXNvdXJjZSA9IChfYTMgPSB7fSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9OQU1FXSA9IFwiYnJvd3NlclwiLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OXSA9IFwiV2ViIEJyb3dzZXJcIiwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9WRVJTSU9OXSA9IG5hdmlnYXRvci51c2VyQWdlbnQsIF9hMyk7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5fZ2V0UmVzb3VyY2VBdHRyaWJ1dGVzKGJyb3dzZXJSZXNvdXJjZSwgY29uZmlnMildO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIEJyb3dzZXJEZXRlY3RvcjIucHJvdG90eXBlLl9nZXRSZXNvdXJjZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihicm93c2VyUmVzb3VyY2UsIF9jb25maWcpIHtcbiAgICBpZiAoYnJvd3NlclJlc291cmNlW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9WRVJTSU9OXSA9PT0gXCJcIikge1xuICAgICAgZGlhZzIuZGVidWcoXCJCcm93c2VyRGV0ZWN0b3IgZmFpbGVkOiBVbmFibGUgdG8gZmluZCByZXF1aXJlZCBicm93c2VyIHJlc291cmNlcy4gXCIpO1xuICAgICAgcmV0dXJuIFJlc291cmNlLmVtcHR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UoX19hc3NpZ24oe30sIGJyb3dzZXJSZXNvdXJjZSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEJyb3dzZXJEZXRlY3RvcjI7XG59KCk7XG52YXIgYnJvd3NlckRldGVjdG9yID0gbmV3IEJyb3dzZXJEZXRlY3RvcigpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvRW52RGV0ZWN0b3IuanNcbnZhciBfX2F3YWl0ZXI0ID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUDMsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAzID8gdmFsdWUgOiBuZXcgUDMoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgX19uYW1lKGFkb3B0LCBcImFkb3B0XCIpO1xuICByZXR1cm4gbmV3IChQMyB8fCAoUDMgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZ1bGZpbGxlZCwgXCJmdWxmaWxsZWRcIik7XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVqZWN0ZWQsIFwicmVqZWN0ZWRcIik7XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBfX25hbWUoc3RlcCwgXCJzdGVwXCIpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yNCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodFswXSAmIDEpXG4gICAgICB0aHJvdyB0WzFdO1xuICAgIHJldHVybiB0WzFdO1xuICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG4gIF9fbmFtZSh2ZXJiLCBcInZlcmJcIik7XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICBpZiAoZilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIHdoaWxlIChfKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBmID0gdCA9IDA7XG4gICAgICB9XG4gICAgaWYgKG9wWzBdICYgNSlcbiAgICAgIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbn07XG52YXIgX192YWx1ZXM0ID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZDUgPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIGUgPSB7IGVycm9yOiBlcnJvcjIgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xudmFyIEVudkRldGVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEVudkRldGVjdG9yMigpIHtcbiAgICB0aGlzLl9NQVhfTEVOR1RIID0gMjU1O1xuICAgIHRoaXMuX0NPTU1BX1NFUEFSQVRPUiA9IFwiLFwiO1xuICAgIHRoaXMuX0xBQkVMX0tFWV9WQUxVRV9TUExJVFRFUiA9IFwiPVwiO1xuICAgIHRoaXMuX0VSUk9SX01FU1NBR0VfSU5WQUxJRF9DSEFSUyA9IFwic2hvdWxkIGJlIGEgQVNDSUkgc3RyaW5nIHdpdGggYSBsZW5ndGggZ3JlYXRlciB0aGFuIDAgYW5kIG5vdCBleGNlZWQgXCIgKyB0aGlzLl9NQVhfTEVOR1RIICsgXCIgY2hhcmFjdGVycy5cIjtcbiAgICB0aGlzLl9FUlJPUl9NRVNTQUdFX0lOVkFMSURfVkFMVUUgPSBcInNob3VsZCBiZSBhIEFTQ0lJIHN0cmluZyB3aXRoIGEgbGVuZ3RoIG5vdCBleGNlZWQgXCIgKyB0aGlzLl9NQVhfTEVOR1RIICsgXCIgY2hhcmFjdGVycy5cIjtcbiAgfVxuICBfX25hbWUoRW52RGV0ZWN0b3IyLCBcIkVudkRldGVjdG9yXCIpO1xuICBFbnZEZXRlY3RvcjIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKF9jb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyNCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcywgZW52MiwgcmF3QXR0cmlidXRlcywgc2VydmljZU5hbWUsIHBhcnNlZEF0dHJpYnV0ZXM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3I0KHRoaXMsIGZ1bmN0aW9uKF9hMykge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGVudjIgPSBnZXRFbnYoKTtcbiAgICAgICAgcmF3QXR0cmlidXRlcyA9IGVudjIuT1RFTF9SRVNPVVJDRV9BVFRSSUJVVEVTO1xuICAgICAgICBzZXJ2aWNlTmFtZSA9IGVudjIuT1RFTF9TRVJWSUNFX05BTUU7XG4gICAgICAgIGlmIChyYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSB0aGlzLl9wYXJzZVJlc291cmNlQXR0cmlidXRlcyhyYXdBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGlhZzIuZGVidWcoXCJFbnZEZXRlY3RvciBmYWlsZWQ6IFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcnZpY2VOYW1lKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5TRVJWSUNFX05BTUVdID0gc2VydmljZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsyLCBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcyldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIEVudkRldGVjdG9yMi5wcm90b3R5cGUuX3BhcnNlUmVzb3VyY2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocmF3RW52QXR0cmlidXRlcykge1xuICAgIHZhciBlXzEsIF9hMztcbiAgICBpZiAoIXJhd0VudkF0dHJpYnV0ZXMpXG4gICAgICByZXR1cm4ge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgcmF3QXR0cmlidXRlcyA9IHJhd0VudkF0dHJpYnV0ZXMuc3BsaXQodGhpcy5fQ09NTUFfU0VQQVJBVE9SLCAtMSk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIHJhd0F0dHJpYnV0ZXNfMSA9IF9fdmFsdWVzNChyYXdBdHRyaWJ1dGVzKSwgcmF3QXR0cmlidXRlc18xXzEgPSByYXdBdHRyaWJ1dGVzXzEubmV4dCgpOyAhcmF3QXR0cmlidXRlc18xXzEuZG9uZTsgcmF3QXR0cmlidXRlc18xXzEgPSByYXdBdHRyaWJ1dGVzXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciByYXdBdHRyaWJ1dGUgPSByYXdBdHRyaWJ1dGVzXzFfMS52YWx1ZTtcbiAgICAgICAgdmFyIGtleVZhbHVlUGFpciA9IHJhd0F0dHJpYnV0ZS5zcGxpdCh0aGlzLl9MQUJFTF9LRVlfVkFMVUVfU1BMSVRURVIsIC0xKTtcbiAgICAgICAgaWYgKGtleVZhbHVlUGFpci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IyID0gX19yZWFkNShrZXlWYWx1ZVBhaXIsIDIpLCBrZXkgPSBfYjJbMF0sIHZhbHVlID0gX2IyWzFdO1xuICAgICAgICBrZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKS5zcGxpdCgnXlwifFwiJCcpLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZEFuZE5vdEVtcHR5KGtleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUga2V5IFwiICsgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX0NIQVJTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cmlidXRlIHZhbHVlIFwiICsgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJhd0F0dHJpYnV0ZXNfMV8xICYmICFyYXdBdHRyaWJ1dGVzXzFfMS5kb25lICYmIChfYTMgPSByYXdBdHRyaWJ1dGVzXzEucmV0dXJuKSlcbiAgICAgICAgICBfYTMuY2FsbChyYXdBdHRyaWJ1dGVzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9O1xuICBFbnZEZXRlY3RvcjIucHJvdG90eXBlLl9pc1ZhbGlkID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lLmxlbmd0aCA8PSB0aGlzLl9NQVhfTEVOR1RIICYmIHRoaXMuX2lzUHJpbnRhYmxlU3RyaW5nKG5hbWUpO1xuICB9O1xuICBFbnZEZXRlY3RvcjIucHJvdG90eXBlLl9pc1ByaW50YWJsZVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2ggPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGNoIDw9IFwiIFwiIHx8IGNoID49IFwiflwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIEVudkRldGVjdG9yMi5wcm90b3R5cGUuX2lzVmFsaWRBbmROb3RFbXB0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID4gMCAmJiB0aGlzLl9pc1ZhbGlkKHN0cik7XG4gIH07XG4gIHJldHVybiBFbnZEZXRlY3RvcjI7XG59KCk7XG52YXIgZW52RGV0ZWN0b3IgPSBuZXcgRW52RGV0ZWN0b3IoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL1Byb2Nlc3NEZXRlY3Rvci5qc1xudmFyIF9fYXNzaWduMiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbjIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlcjUgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQMywgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUDMgPyB2YWx1ZSA6IG5ldyBQMyhmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfX25hbWUoYWRvcHQsIFwiYWRvcHRcIik7XG4gIHJldHVybiBuZXcgKFAzIHx8IChQMyA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZnVsZmlsbGVkLCBcImZ1bGZpbGxlZFwiKTtcbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWplY3RlZCwgXCJyZWplY3RlZFwiKTtcbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3I1ID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0WzBdICYgMSlcbiAgICAgIHRocm93IHRbMV07XG4gICAgcmV0dXJuIHRbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgX19uYW1lKHZlcmIsIFwidmVyYlwiKTtcbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKF8pXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICB5ID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGYgPSB0ID0gMDtcbiAgICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBfX25hbWUoc3RlcCwgXCJzdGVwXCIpO1xufTtcbnZhciBQcm9jZXNzRGV0ZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUHJvY2Vzc0RldGVjdG9yMigpIHtcbiAgfVxuICBfX25hbWUoUHJvY2Vzc0RldGVjdG9yMiwgXCJQcm9jZXNzRGV0ZWN0b3JcIik7XG4gIFByb2Nlc3NEZXRlY3RvcjIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKGNvbmZpZzIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyNSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvY2Vzc1Jlc291cmNlO1xuICAgICAgdmFyIF9hMztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcjUodGhpcywgZnVuY3Rpb24oX2IyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBbMiwgUmVzb3VyY2UuZW1wdHkoKV07XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc1Jlc291cmNlID0gKF9hMyA9IHt9LCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19QSURdID0gcHJvY2Vzcy5waWQsIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0VYRUNVVEFCTEVfTkFNRV0gPSBwcm9jZXNzLnRpdGxlIHx8IFwiXCIsIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0NPTU1BTkRdID0gcHJvY2Vzcy5hcmd2WzFdIHx8IFwiXCIsIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0NPTU1BTkRfTElORV0gPSBwcm9jZXNzLmFyZ3Yuam9pbihcIiBcIikgfHwgXCJcIiwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9WRVJTSU9OXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9OQU1FXSA9IFwibm9kZWpzXCIsIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX1JVTlRJTUVfREVTQ1JJUFRJT05dID0gXCJOb2RlLmpzXCIsIF9hMyk7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5fZ2V0UmVzb3VyY2VBdHRyaWJ1dGVzKHByb2Nlc3NSZXNvdXJjZSwgY29uZmlnMildO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIFByb2Nlc3NEZXRlY3RvcjIucHJvdG90eXBlLl9nZXRSZXNvdXJjZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwcm9jZXNzUmVzb3VyY2UsIF9jb25maWcpIHtcbiAgICBpZiAocHJvY2Vzc1Jlc291cmNlW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfRVhFQ1VUQUJMRV9OQU1FXSA9PT0gXCJcIiB8fCBwcm9jZXNzUmVzb3VyY2VbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEhdID09PSBcIlwiIHx8IHByb2Nlc3NSZXNvdXJjZVtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0NPTU1BTkRdID09PSBcIlwiIHx8IHByb2Nlc3NSZXNvdXJjZVtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0NPTU1BTkRfTElORV0gPT09IFwiXCIgfHwgcHJvY2Vzc1Jlc291cmNlW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9WRVJTSU9OXSA9PT0gXCJcIikge1xuICAgICAgZGlhZzIuZGVidWcoXCJQcm9jZXNzRGV0ZWN0b3IgZmFpbGVkOiBVbmFibGUgdG8gZmluZCByZXF1aXJlZCBwcm9jZXNzIHJlc291cmNlcy4gXCIpO1xuICAgICAgcmV0dXJuIFJlc291cmNlLmVtcHR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UoX19hc3NpZ24yKHt9LCBwcm9jZXNzUmVzb3VyY2UpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBQcm9jZXNzRGV0ZWN0b3IyO1xufSgpO1xudmFyIHByb2Nlc3NEZXRlY3RvciA9IG5ldyBQcm9jZXNzRGV0ZWN0b3IoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL011bHRpU3BhblByb2Nlc3Nvci5qc1xudmFyIF9fdmFsdWVzNSA9IGZ1bmN0aW9uKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pXG4gICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBNdWx0aVNwYW5Qcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTXVsdGlTcGFuUHJvY2Vzc29yMihfc3BhblByb2Nlc3NvcnMpIHtcbiAgICB0aGlzLl9zcGFuUHJvY2Vzc29ycyA9IF9zcGFuUHJvY2Vzc29ycztcbiAgfVxuICBfX25hbWUoTXVsdGlTcGFuUHJvY2Vzc29yMiwgXCJNdWx0aVNwYW5Qcm9jZXNzb3JcIik7XG4gIE11bHRpU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZV8xLCBfYTM7XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iMiA9IF9fdmFsdWVzNSh0aGlzLl9zcGFuUHJvY2Vzc29ycyksIF9jID0gX2IyLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IyLm5leHQoKSkge1xuICAgICAgICB2YXIgc3BhblByb2Nlc3NvciA9IF9jLnZhbHVlO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHNwYW5Qcm9jZXNzb3IuZm9yY2VGbHVzaCgpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTMgPSBfYjIucmV0dXJuKSlcbiAgICAgICAgICBfYTMuY2FsbChfYjIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IyKSB7XG4gICAgICAgIGdsb2JhbEVycm9ySGFuZGxlcihlcnJvcjIgfHwgbmV3IEVycm9yKFwiTXVsdGlTcGFuUHJvY2Vzc29yOiBmb3JjZUZsdXNoIGZhaWxlZFwiKSk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBNdWx0aVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oc3BhbiwgY29udGV4dDMpIHtcbiAgICB2YXIgZV8yLCBfYTM7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iMiA9IF9fdmFsdWVzNSh0aGlzLl9zcGFuUHJvY2Vzc29ycyksIF9jID0gX2IyLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IyLm5leHQoKSkge1xuICAgICAgICB2YXIgc3BhblByb2Nlc3NvciA9IF9jLnZhbHVlO1xuICAgICAgICBzcGFuUHJvY2Vzc29yLm9uU3RhcnQoc3BhbiwgY29udGV4dDMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMyA9IF9iMi5yZXR1cm4pKVxuICAgICAgICAgIF9hMy5jYWxsKF9iMik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8yKVxuICAgICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE11bHRpU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3Bhbikge1xuICAgIHZhciBlXzMsIF9hMztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXM1KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBzcGFuUHJvY2Vzc29yID0gX2MudmFsdWU7XG4gICAgICAgIHNwYW5Qcm9jZXNzb3Iub25FbmQoc3Bhbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoX2IyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzMpXG4gICAgICAgICAgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTXVsdGlTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZV80LCBfYTM7XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iMiA9IF9fdmFsdWVzNSh0aGlzLl9zcGFuUHJvY2Vzc29ycyksIF9jID0gX2IyLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IyLm5leHQoKSkge1xuICAgICAgICB2YXIgc3BhblByb2Nlc3NvciA9IF9jLnZhbHVlO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHNwYW5Qcm9jZXNzb3Iuc2h1dGRvd24oKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV80XzEpIHtcbiAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoX2IyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzQpXG4gICAgICAgICAgdGhyb3cgZV80LmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIE11bHRpU3BhblByb2Nlc3NvcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvTm9vcFNwYW5Qcm9jZXNzb3IuanNcbnZhciBOb29wU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBOb29wU3BhblByb2Nlc3NvcjIoKSB7XG4gIH1cbiAgX19uYW1lKE5vb3BTcGFuUHJvY2Vzc29yMiwgXCJOb29wU3BhblByb2Nlc3NvclwiKTtcbiAgTm9vcFNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oX3NwYW4sIF9jb250ZXh0KSB7XG4gIH07XG4gIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihfc3Bhbikge1xuICB9O1xuICBOb29wU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBOb29wU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHJldHVybiBOb29wU3BhblByb2Nlc3NvcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9CYXNpY1RyYWNlclByb3ZpZGVyLmpzXG52YXIgRm9yY2VGbHVzaFN0YXRlO1xuKGZ1bmN0aW9uKEZvcmNlRmx1c2hTdGF0ZTIpIHtcbiAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1wicmVzb2x2ZWRcIl0gPSAwXSA9IFwicmVzb2x2ZWRcIjtcbiAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1widGltZW91dFwiXSA9IDFdID0gXCJ0aW1lb3V0XCI7XG4gIEZvcmNlRmx1c2hTdGF0ZTJbRm9yY2VGbHVzaFN0YXRlMltcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XG4gIEZvcmNlRmx1c2hTdGF0ZTJbRm9yY2VGbHVzaFN0YXRlMltcInVucmVzb2x2ZWRcIl0gPSAzXSA9IFwidW5yZXNvbHZlZFwiO1xufSkoRm9yY2VGbHVzaFN0YXRlIHx8IChGb3JjZUZsdXNoU3RhdGUgPSB7fSkpO1xudmFyIEJhc2ljVHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmFzaWNUcmFjZXJQcm92aWRlcjIoY29uZmlnMikge1xuICAgIGlmIChjb25maWcyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbmZpZzIgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9hMztcbiAgICB0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLl90cmFjZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB2YXIgbWVyZ2VkQ29uZmlnID0gbWVyZ2Uoe30sIGxvYWREZWZhdWx0Q29uZmlnKCksIHJlY29uZmlndXJlTGltaXRzKGNvbmZpZzIpKTtcbiAgICB0aGlzLnJlc291cmNlID0gKF9hMyA9IG1lcmdlZENvbmZpZy5yZXNvdXJjZSkgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBSZXNvdXJjZS5lbXB0eSgpO1xuICAgIHRoaXMucmVzb3VyY2UgPSBSZXNvdXJjZS5kZWZhdWx0KCkubWVyZ2UodGhpcy5yZXNvdXJjZSk7XG4gICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkQ29uZmlnLCB7XG4gICAgICByZXNvdXJjZTogdGhpcy5yZXNvdXJjZVxuICAgIH0pO1xuICAgIHZhciBkZWZhdWx0RXhwb3J0ZXIgPSB0aGlzLl9idWlsZEV4cG9ydGVyRnJvbUVudigpO1xuICAgIGlmIChkZWZhdWx0RXhwb3J0ZXIgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIGJhdGNoUHJvY2Vzc29yID0gbmV3IEJhdGNoU3BhblByb2Nlc3NvcihkZWZhdWx0RXhwb3J0ZXIpO1xuICAgICAgdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yID0gYmF0Y2hQcm9jZXNzb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlU3BhblByb2Nlc3NvciA9IG5ldyBOb29wU3BhblByb2Nlc3NvcigpO1xuICAgIH1cbiAgfVxuICBfX25hbWUoQmFzaWNUcmFjZXJQcm92aWRlcjIsIFwiQmFzaWNUcmFjZXJQcm92aWRlclwiKTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldFRyYWNlciA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gbmFtZSArIFwiQFwiICsgKHZlcnNpb24gfHwgXCJcIikgKyBcIjpcIiArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjaGVtYVVybCkgfHwgXCJcIik7XG4gICAgaWYgKCF0aGlzLl90cmFjZXJzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLl90cmFjZXJzLnNldChrZXksIG5ldyBUcmFjZXIoeyBuYW1lLCB2ZXJzaW9uLCBzY2hlbWFVcmw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2hlbWFVcmwgfSwgdGhpcy5fY29uZmlnLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFjZXJzLmdldChrZXkpO1xuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuYWRkU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKHNwYW5Qcm9jZXNzb3IpIHtcbiAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZFNwYW5Qcm9jZXNzb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yLnNodXRkb3duKCkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHJldHVybiBkaWFnMi5lcnJvcihcIkVycm9yIHdoaWxlIHRyeWluZyB0byBzaHV0ZG93biBjdXJyZW50IHNwYW4gcHJvY2Vzc29yXCIsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVnaXN0ZXJlZFNwYW5Qcm9jZXNzb3JzLnB1c2goc3BhblByb2Nlc3Nvcik7XG4gICAgdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yID0gbmV3IE11bHRpU3BhblByb2Nlc3Nvcih0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMpO1xuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuZ2V0QWN0aXZlU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3I7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGNvbmZpZzIpIHtcbiAgICBpZiAoY29uZmlnMiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25maWcyID0ge307XG4gICAgfVxuICAgIHRyYWNlLnNldEdsb2JhbFRyYWNlclByb3ZpZGVyKHRoaXMpO1xuICAgIGlmIChjb25maWcyLnByb3BhZ2F0b3IgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnMi5wcm9wYWdhdG9yID0gdGhpcy5fYnVpbGRQcm9wYWdhdG9yRnJvbUVudigpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnMi5jb250ZXh0TWFuYWdlcikge1xuICAgICAgY29udGV4dDIuc2V0R2xvYmFsQ29udGV4dE1hbmFnZXIoY29uZmlnMi5jb250ZXh0TWFuYWdlcik7XG4gICAgfVxuICAgIGlmIChjb25maWcyLnByb3BhZ2F0b3IpIHtcbiAgICAgIHByb3BhZ2F0aW9uLnNldEdsb2JhbFByb3BhZ2F0b3IoY29uZmlnMi5wcm9wYWdhdG9yKTtcbiAgICB9XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl9jb25maWcuZm9yY2VGbHVzaFRpbWVvdXRNaWxsaXM7XG4gICAgdmFyIHByb21pc2VzID0gdGhpcy5fcmVnaXN0ZXJlZFNwYW5Qcm9jZXNzb3JzLm1hcChmdW5jdGlvbihzcGFuUHJvY2Vzc29yKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB2YXIgc3RhdGU7XG4gICAgICAgIHZhciB0aW1lb3V0SW50ZXJ2YWwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IEVycm9yKFwiU3BhbiBwcm9jZXNzb3IgZGlkIG5vdCBjb21wbGV0ZWQgd2l0aGluIHRpbWVvdXQgcGVyaW9kIG9mIFwiICsgdGltZW91dCArIFwiIG1zXCIpKTtcbiAgICAgICAgICBzdGF0ZSA9IEZvcmNlRmx1c2hTdGF0ZS50aW1lb3V0O1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgc3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEludGVydmFsKTtcbiAgICAgICAgICBpZiAoc3RhdGUgIT09IEZvcmNlRmx1c2hTdGF0ZS50aW1lb3V0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEZvcmNlRmx1c2hTdGF0ZS5yZXNvbHZlZDtcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJbnRlcnZhbCk7XG4gICAgICAgICAgc3RhdGUgPSBGb3JjZUZsdXNoU3RhdGUuZXJyb3I7XG4gICAgICAgICAgcmVzb2x2ZShlcnJvcjIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IEZvcmNlRmx1c2hTdGF0ZS5yZXNvbHZlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlamVjdChlcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoW2Vycm9yMl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3Iuc2h1dGRvd24oKTtcbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9nZXRQcm9wYWdhdG9yID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLmNvbnN0cnVjdG9yLl9yZWdpc3RlcmVkUHJvcGFnYXRvcnMuZ2V0KG5hbWUpKSA9PT0gbnVsbCB8fCBfYTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMygpO1xuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuX2dldFNwYW5FeHBvcnRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiAoX2EzID0gdGhpcy5jb25zdHJ1Y3Rvci5fcmVnaXN0ZXJlZEV4cG9ydGVycy5nZXQobmFtZSkpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzKCk7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5fYnVpbGRQcm9wYWdhdG9yRnJvbUVudiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHVuaXF1ZVByb3BhZ2F0b3JOYW1lcyA9IEFycmF5LmZyb20obmV3IFNldChnZXRFbnYoKS5PVEVMX1BST1BBR0FUT1JTKSk7XG4gICAgdmFyIHByb3BhZ2F0b3JzID0gdW5pcXVlUHJvcGFnYXRvck5hbWVzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcGFnYXRvciA9IF90aGlzLl9nZXRQcm9wYWdhdG9yKG5hbWUpO1xuICAgICAgaWYgKCFwcm9wYWdhdG9yKSB7XG4gICAgICAgIGRpYWcyLndhcm4oJ1Byb3BhZ2F0b3IgXCInICsgbmFtZSArICdcIiByZXF1ZXN0ZWQgdGhyb3VnaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wYWdhdG9yO1xuICAgIH0pO1xuICAgIHZhciB2YWxpZFByb3BhZ2F0b3JzID0gcHJvcGFnYXRvcnMucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgICBpZiAodmFsaWRQcm9wYWdhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHVuaXF1ZVByb3BhZ2F0b3JOYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB2YWxpZFByb3BhZ2F0b3JzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZVByb3BhZ2F0b3Ioe1xuICAgICAgICBwcm9wYWdhdG9yczogdmFsaWRQcm9wYWdhdG9yc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuX2J1aWxkRXhwb3J0ZXJGcm9tRW52ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4cG9ydGVyTmFtZSA9IGdldEVudigpLk9URUxfVFJBQ0VTX0VYUE9SVEVSO1xuICAgIGlmIChleHBvcnRlck5hbWUgPT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBleHBvcnRlciA9IHRoaXMuX2dldFNwYW5FeHBvcnRlcihleHBvcnRlck5hbWUpO1xuICAgIGlmICghZXhwb3J0ZXIpIHtcbiAgICAgIGRpYWcyLmVycm9yKCdFeHBvcnRlciBcIicgKyBleHBvcnRlck5hbWUgKyAnXCIgcmVxdWVzdGVkIHRocm91Z2ggZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRlcjtcbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIuX3JlZ2lzdGVyZWRQcm9wYWdhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXCJ0cmFjZWNvbnRleHRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IoKTtcbiAgICB9XSxcbiAgICBbXCJiYWdnYWdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBXM0NCYWdnYWdlUHJvcGFnYXRvcigpO1xuICAgIH1dXG4gIF0pO1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5fcmVnaXN0ZXJlZEV4cG9ydGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBCYXNpY1RyYWNlclByb3ZpZGVyMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9Db25zb2xlU3BhbkV4cG9ydGVyLmpzXG52YXIgX192YWx1ZXM2ID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIENvbnNvbGVTcGFuRXhwb3J0ZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQ29uc29sZVNwYW5FeHBvcnRlcjIoKSB7XG4gIH1cbiAgX19uYW1lKENvbnNvbGVTcGFuRXhwb3J0ZXIyLCBcIkNvbnNvbGVTcGFuRXhwb3J0ZXJcIik7XG4gIENvbnNvbGVTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5leHBvcnQgPSBmdW5jdGlvbihzcGFucywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZFNwYW5zKHNwYW5zLCByZXN1bHRDYWxsYmFjayk7XG4gIH07XG4gIENvbnNvbGVTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NlbmRTcGFucyhbXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBDb25zb2xlU3BhbkV4cG9ydGVyMi5wcm90b3R5cGUuX2V4cG9ydEluZm8gPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNlSWQ6IHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkLFxuICAgICAgcGFyZW50SWQ6IHNwYW4ucGFyZW50U3BhbklkLFxuICAgICAgbmFtZTogc3Bhbi5uYW1lLFxuICAgICAgaWQ6IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQsXG4gICAgICBraW5kOiBzcGFuLmtpbmQsXG4gICAgICB0aW1lc3RhbXA6IGhyVGltZVRvTWljcm9zZWNvbmRzKHNwYW4uc3RhcnRUaW1lKSxcbiAgICAgIGR1cmF0aW9uOiBoclRpbWVUb01pY3Jvc2Vjb25kcyhzcGFuLmR1cmF0aW9uKSxcbiAgICAgIGF0dHJpYnV0ZXM6IHNwYW4uYXR0cmlidXRlcyxcbiAgICAgIHN0YXR1czogc3Bhbi5zdGF0dXMsXG4gICAgICBldmVudHM6IHNwYW4uZXZlbnRzLFxuICAgICAgbGlua3M6IHNwYW4ubGlua3NcbiAgICB9O1xuICB9O1xuICBDb25zb2xlU3BhbkV4cG9ydGVyMi5wcm90b3R5cGUuX3NlbmRTcGFucyA9IGZ1bmN0aW9uKHNwYW5zLCBkb25lKSB7XG4gICAgdmFyIGVfMSwgX2EzO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBzcGFuc18xID0gX192YWx1ZXM2KHNwYW5zKSwgc3BhbnNfMV8xID0gc3BhbnNfMS5uZXh0KCk7ICFzcGFuc18xXzEuZG9uZTsgc3BhbnNfMV8xID0gc3BhbnNfMS5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc18xXzEudmFsdWU7XG4gICAgICAgIGNvbnNvbGUuZGlyKHRoaXMuX2V4cG9ydEluZm8oc3BhbiksIHsgZGVwdGg6IDMgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzcGFuc18xXzEgJiYgIXNwYW5zXzFfMS5kb25lICYmIChfYTMgPSBzcGFuc18xLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoc3BhbnNfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiBkb25lKHsgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENvbnNvbGVTcGFuRXhwb3J0ZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0luTWVtb3J5U3BhbkV4cG9ydGVyLmpzXG52YXIgX19yZWFkNiA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheTQgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgIGlmICghYXIpXG4gICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIEluTWVtb3J5U3BhbkV4cG9ydGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEluTWVtb3J5U3BhbkV4cG9ydGVyMigpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICB9XG4gIF9fbmFtZShJbk1lbW9yeVNwYW5FeHBvcnRlcjIsIFwiSW5NZW1vcnlTcGFuRXhwb3J0ZXJcIik7XG4gIEluTWVtb3J5U3BhbkV4cG9ydGVyMi5wcm90b3R5cGUuZXhwb3J0ID0gZnVuY3Rpb24oc3BhbnMsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgdmFyIF9hMztcbiAgICBpZiAodGhpcy5fc3RvcHBlZClcbiAgICAgIHJldHVybiByZXN1bHRDYWxsYmFjayh7XG4gICAgICAgIGNvZGU6IEV4cG9ydFJlc3VsdENvZGUuRkFJTEVELFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiRXhwb3J0ZXIgaGFzIGJlZW4gc3RvcHBlZFwiKVxuICAgICAgfSk7XG4gICAgKF9hMyA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMpLnB1c2guYXBwbHkoX2EzLCBfX3NwcmVhZEFycmF5NChbXSwgX19yZWFkNihzcGFucyksIGZhbHNlKSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHRDYWxsYmFjayh7IGNvZGU6IEV4cG9ydFJlc3VsdENvZGUuU1VDQ0VTUyB9KTtcbiAgICB9LCAwKTtcbiAgfTtcbiAgSW5NZW1vcnlTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIEluTWVtb3J5U3BhbkV4cG9ydGVyMi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gIH07XG4gIEluTWVtb3J5U3BhbkV4cG9ydGVyMi5wcm90b3R5cGUuZ2V0RmluaXNoZWRTcGFucyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hlZFNwYW5zO1xuICB9O1xuICByZXR1cm4gSW5NZW1vcnlTcGFuRXhwb3J0ZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L1NpbXBsZVNwYW5Qcm9jZXNzb3IuanNcbnZhciBTaW1wbGVTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVNwYW5Qcm9jZXNzb3IyKF9leHBvcnRlcikge1xuICAgIHRoaXMuX2V4cG9ydGVyID0gX2V4cG9ydGVyO1xuICAgIHRoaXMuX3NodXRkb3duT25jZSA9IG5ldyBCaW5kT25jZUZ1dHVyZSh0aGlzLl9zaHV0ZG93biwgdGhpcyk7XG4gIH1cbiAgX19uYW1lKFNpbXBsZVNwYW5Qcm9jZXNzb3IyLCBcIlNpbXBsZVNwYW5Qcm9jZXNzb3JcIik7XG4gIFNpbXBsZVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBTaW1wbGVTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKF9zcGFuLCBfcGFyZW50Q29udGV4dCkge1xuICB9O1xuICBTaW1wbGVTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5fc2h1dGRvd25PbmNlLmlzQ2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQyLndpdGgoc3VwcHJlc3NUcmFjaW5nKGNvbnRleHQyLmFjdGl2ZSgpKSwgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5fZXhwb3J0ZXIuZXhwb3J0KFtzcGFuXSwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmIChyZXN1bHQuY29kZSAhPT0gRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKChfYTMgPSByZXN1bHQuZXJyb3IpICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogbmV3IEVycm9yKFwiU2ltcGxlU3BhblByb2Nlc3Nvcjogc3BhbiBleHBvcnQgZmFpbGVkIChzdGF0dXMgXCIgKyByZXN1bHQgKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgU2ltcGxlU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NodXRkb3duT25jZS5jYWxsKCk7XG4gIH07XG4gIFNpbXBsZVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5fc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwb3J0ZXIuc2h1dGRvd24oKTtcbiAgfTtcbiAgcmV0dXJuIFNpbXBsZVNwYW5Qcm9jZXNzb3IyO1xufSgpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvdHJhY2luZy9jcmVhdGVTcGFuLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTcGFuKGVuZ2luZVNwYW5FdmVudCkge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgMCkpO1xuICBjb25zdCB0cmFjZXIgPSB0cmFjZS5nZXRUcmFjZXIoXCJwcmlzbWFcIik7XG4gIGVuZ2luZVNwYW5FdmVudC5zcGFucy5mb3JFYWNoKChlbmdpbmVTcGFuKSA9PiB7XG4gICAgdmFyIF9hMztcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHtcbiAgICAgIHRyYWNlSWQ6IGVuZ2luZVNwYW4udHJhY2VfaWQsXG4gICAgICBzcGFuSWQ6IGVuZ2luZVNwYW4uc3Bhbl9pZCxcbiAgICAgIHRyYWNlRmxhZ3M6IFRyYWNlRmxhZ3MuU0FNUExFRFxuICAgIH07XG4gICAgY29uc3QgbGlua3MgPSAoX2EzID0gZW5naW5lU3Bhbi5saW5rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5tYXAoKGxpbmspID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICB0cmFjZUlkOiBsaW5rLnRyYWNlX2lkLFxuICAgICAgICAgIHNwYW5JZDogbGluay5zcGFuX2lkLFxuICAgICAgICAgIHRyYWNlRmxhZ3M6IFRyYWNlRmxhZ3MuU0FNUExFRFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNwYW4gPSBuZXcgU3BhbihcbiAgICAgIHRyYWNlcixcbiAgICAgIFJPT1RfQ09OVEVYVCxcbiAgICAgIGVuZ2luZVNwYW4ubmFtZSxcbiAgICAgIHNwYW5Db250ZXh0LFxuICAgICAgU3BhbktpbmQuSU5URVJOQUwsXG4gICAgICBlbmdpbmVTcGFuLnBhcmVudF9zcGFuX2lkLFxuICAgICAgbGlua3MsXG4gICAgICBlbmdpbmVTcGFuLnN0YXJ0X3RpbWVcbiAgICApO1xuICAgIGlmIChlbmdpbmVTcGFuLmF0dHJpYnV0ZXMpIHtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhlbmdpbmVTcGFuLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBzcGFuLmVuZChlbmdpbmVTcGFuLmVuZF90aW1lKTtcbiAgfSk7XG59XG5fX25hbWUoY3JlYXRlU3BhbiwgXCJjcmVhdGVTcGFuXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvdHJhY2luZy9nZXRUcmFjZVBhcmVudC50c1xuZnVuY3Rpb24gZ2V0VHJhY2VQYXJlbnQoe1xuICBjb250ZXh0OiBjb250ZXh0MyxcbiAgdHJhY2luZ0NvbmZpZ1xufSkge1xuICBjb25zdCBzcGFuID0gdHJhY2UuZ2V0U3BhbkNvbnRleHQoY29udGV4dDMgIT0gbnVsbCA/IGNvbnRleHQzIDogY29udGV4dDIuYWN0aXZlKCkpO1xuICBpZiAoKHRyYWNpbmdDb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNpbmdDb25maWcuZW5hYmxlZCkgJiYgKHNwYW4gPT0gbnVsbCA/IHZvaWQgMCA6IHNwYW4udHJhY2VGbGFncykgPT09IDEpIHtcbiAgICByZXR1cm4gYDAwLSR7c3Bhbi50cmFjZUlkfS0ke3NwYW4uc3BhbklkfS0wMWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAwMC0wMC0wMC0wMGA7XG4gIH1cbn1cbl9fbmFtZShnZXRUcmFjZVBhcmVudCwgXCJnZXRUcmFjZVBhcmVudFwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL3RyYWNpbmcvZ2V0VHJhY2luZ0NvbmZpZy50c1xuZnVuY3Rpb24gZ2V0VHJhY2luZ0NvbmZpZyhwcmV2aWV3RmVhdHVyZXMpIHtcbiAgY29uc3QgaGFzVHJhY2luZ1ByZXZpZXdGZWF0dXJlRmxhZ0VuYWJsZWQgPSBwcmV2aWV3RmVhdHVyZXMuaW5jbHVkZXMoXCJ0cmFjaW5nXCIpO1xuICByZXR1cm4ge1xuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZ2xvYmFsVGhpcy5QUklTTUFfSU5TVFJVTUVOVEFUSU9OICYmIGhhc1RyYWNpbmdQcmV2aWV3RmVhdHVyZUZsYWdFbmFibGVkKTtcbiAgICB9LFxuICAgIGdldCBtaWRkbGV3YXJlKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZ2xvYmFsVGhpcy5QUklTTUFfSU5TVFJVTUVOVEFUSU9OICYmIGdsb2JhbFRoaXMuUFJJU01BX0lOU1RSVU1FTlRBVElPTi5taWRkbGV3YXJlKTtcbiAgICB9XG4gIH07XG59XG5fX25hbWUoZ2V0VHJhY2luZ0NvbmZpZywgXCJnZXRUcmFjaW5nQ29uZmlnXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvdHJhY2luZy9ydW5JbkNoaWxkU3Bhbi50c1xuYXN5bmMgZnVuY3Rpb24gcnVuSW5DaGlsZFNwYW4ob3B0aW9ucywgY2IpIHtcbiAgdmFyIF9hMztcbiAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgcmV0dXJuIGNiKCk7XG4gIGNvbnN0IHRyYWNlciA9IHRyYWNlLmdldFRyYWNlcihcInByaXNtYVwiKTtcbiAgY29uc3QgY29udGV4dDMgPSAoX2EzID0gb3B0aW9ucy5jb250ZXh0KSAhPSBudWxsID8gX2EzIDogY29udGV4dDIuYWN0aXZlKCk7XG4gIGlmIChvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGFuID0gdHJhY2VyLnN0YXJ0U3BhbihgcHJpc21hOmNsaWVudDoke29wdGlvbnMubmFtZX1gLCBvcHRpb25zLCBjb250ZXh0Myk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYihzcGFuLCBjb250ZXh0Myk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNwYW4uZW5kKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKGBwcmlzbWE6Y2xpZW50OiR7b3B0aW9ucy5uYW1lfWAsIG9wdGlvbnMsIGNvbnRleHQzLCBhc3luYyAoc3BhbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2Ioc3BhbiwgY29udGV4dDIuYWN0aXZlKCkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzcGFuLmVuZCgpO1xuICAgIH1cbiAgfSk7XG59XG5fX25hbWUocnVuSW5DaGlsZFNwYW4sIFwicnVuSW5DaGlsZFNwYW5cIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9iaW5hcnkvQ29ubmVjdGlvbi50c1xudmFyIGltcG9ydF9nZXRfc3RyZWFtID0gX190b0VTTShyZXF1aXJlX2dldF9zdHJlYW0oKSk7XG52YXIgdW5kaWNpID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiByZXF1aXJlX3VuZGljaSgpLCBcInVuZGljaVwiKTtcbmZ1bmN0aW9uIGFzc2VydEhhc1Bvb2wocG9vbCkge1xuICBpZiAocG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdGlvbiBoYXMgbm90IGJlZW4gb3BlbmVkXCIpO1xuICB9XG59XG5fX25hbWUoYXNzZXJ0SGFzUG9vbCwgXCJhc3NlcnRIYXNQb29sXCIpO1xudmFyIENvbm5lY3Rpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG4gIHN0YXRpYyBhc3luYyBvbkh0dHBFcnJvcihyZXNwb25zZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IF9yZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlO1xuICAgIGlmIChfcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKF9yZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzcG9uc2U7XG4gIH1cbiAgb3Blbih1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fcG9vbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9wb29sID0gbmV3ICh1bmRpY2koKSkuUG9vbCh1cmwsIHtcbiAgICAgIGNvbm5lY3Rpb25zOiAxZTMsXG4gICAgICBrZWVwQWxpdmVNYXhUaW1lb3V0OiA2ZTUsXG4gICAgICBoZWFkZXJzVGltZW91dDogMCxcbiAgICAgIGJvZHlUaW1lb3V0OiAwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJhdyhtZXRob2QsIGVuZHBvaW50LCBoZWFkZXJzLCBib2R5LCBwYXJzZVJlc3BvbnNlID0gdHJ1ZSkge1xuICAgIGFzc2VydEhhc1Bvb2wodGhpcy5fcG9vbCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9wb29sLnJlcXVlc3Qoe1xuICAgICAgcGF0aDogZW5kcG9pbnQsXG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keVxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHlTdHJpbmcgPSBhd2FpdCAoMCwgaW1wb3J0X2dldF9zdHJlYW0uZGVmYXVsdCkocmVzcG9uc2UuYm9keSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgZGF0YTogcGFyc2VSZXNwb25zZSA/IEpTT04ucGFyc2UoYm9keVN0cmluZykgOiBib2R5U3RyaW5nXG4gICAgfTtcbiAgfVxuICBwb3N0KGVuZHBvaW50LCBib2R5LCBoZWFkZXJzLCBwYXJzZVJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHRoaXMucmF3KFwiUE9TVFwiLCBlbmRwb2ludCwgaGVhZGVycywgYm9keSwgcGFyc2VSZXNwb25zZSk7XG4gIH1cbiAgZ2V0KHBhdGg3LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmF3KFwiR0VUXCIsIHBhdGg3LCBoZWFkZXJzKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgdGhpcy5fcG9vbC5jbG9zZSgoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcG9vbCA9IHZvaWQgMDtcbiAgfVxufTtcbl9fbmFtZShDb25uZWN0aW9uLCBcIkNvbm5lY3Rpb25cIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9iaW5hcnkvQmluYXJ5RW5naW5lLnRzXG52YXIgZGVidWc0ID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6ZW5naW5lXCIpO1xudmFyIGV4aXN0czIgPSAoMCwgaW1wb3J0X3V0aWw0LnByb21pc2lmeSkoaW1wb3J0X2ZzNC5kZWZhdWx0LmV4aXN0cyk7XG52YXIgbG9nZ2VyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoLi4uYXJncykgPT4ge1xufSwgXCJsb2dnZXJcIik7XG52YXIga25vd25QbGF0Zm9ybXMgPSBbLi4ucGxhdGZvcm1zLCBcIm5hdGl2ZVwiXTtcbnZhciBlbmdpbmVzID0gW107XG52YXIgc29ja2V0UGF0aHMgPSBbXTtcbnZhciBNQVhfU1RBUlRTID0gcHJvY2Vzcy5lbnYuUFJJU01BX0NMSUVOVF9OT19SRVRSWSA/IDEgOiAyO1xudmFyIE1BWF9SRVFVRVNUX1JFVFJJRVMgPSBwcm9jZXNzLmVudi5QUklTTUFfQ0xJRU5UX05PX1JFVFJZID8gMSA6IDI7XG52YXIgQmluYXJ5RW5naW5lID0gY2xhc3MgZXh0ZW5kcyBFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY3dkLFxuICAgIGRhdGFtb2RlbFBhdGgsXG4gICAgcHJpc21hUGF0aCxcbiAgICBnZW5lcmF0b3IsXG4gICAgZGF0YXNvdXJjZXMsXG4gICAgc2hvd0NvbG9ycyxcbiAgICBsb2dMZXZlbCxcbiAgICBsb2dRdWVyaWVzLFxuICAgIGVudjogZW52MixcbiAgICBmbGFncyxcbiAgICBjbGllbnRWZXJzaW9uOiBjbGllbnRWZXJzaW9uMixcbiAgICBwcmV2aWV3RmVhdHVyZXMsXG4gICAgZW5naW5lRW5kcG9pbnQsXG4gICAgZW5hYmxlRGVidWdMb2dzLFxuICAgIGFsbG93VHJpZ2dlclBhbmljLFxuICAgIGRpcm5hbWU6IGRpcm5hbWUyLFxuICAgIGFjdGl2ZVByb3ZpZGVyLFxuICAgIHRyYWNpbmdDb25maWdcbiAgfSkge1xuICAgIHZhciBfYTM7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXJ0Q291bnQgPSAwO1xuICAgIHRoaXMucHJldmlld0ZlYXR1cmVzID0gW107XG4gICAgdGhpcy5zdGRlcnJMb2dzID0gXCJcIjtcbiAgICB0aGlzLmhhbmRsZVJlcXVlc3RFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKGVycm9yMiwgZ3JhY2VmdWwgPSBmYWxzZSkgPT4ge1xuICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgZGVidWc0KHsgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0UHJvbWlzZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0UHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGhyb3dBc3luY0Vycm9ySWZFeGlzdHMoKTtcbiAgICAgIGlmICgoX2EzID0gdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuaXNDYW5jZWxlZCkge1xuICAgICAgICB0aGlzLnRocm93QXN5bmNFcnJvcklmRXhpc3RzKCk7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yMi5jb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fCBlcnJvcjIuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIiB8fCBlcnJvcjIuY29kZSA9PT0gXCJVTkRfRVJSX0NMT1NFRFwiIHx8IGVycm9yMi5jb2RlID09PSBcIlVORF9FUlJfU09DS0VUXCIgfHwgZXJyb3IyLmNvZGUgPT09IFwiVU5EX0VSUl9ERVNUUk9ZRURcIiB8fCBlcnJvcjIuY29kZSA9PT0gXCJVTkRfRVJSX0FCT1JURURcIiB8fCBlcnJvcjIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiY2xpZW50IGlzIGRlc3Ryb3llZFwiKSB8fCBlcnJvcjIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwib3RoZXIgc2lkZSBjbG9zZWRcIikgfHwgZXJyb3IyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRoZSBjbGllbnQgaXMgY2xvc2VkXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbEtpbGxTaWduYWxSZWNlaXZlZCAmJiAhKChfYjIgPSB0aGlzLmNoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmNvbm5lY3RlZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihcbiAgICAgICAgICAgIGBUaGUgTm9kZS5qcyBwcm9jZXNzIGFscmVhZHkgcmVjZWl2ZWQgYSAke3RoaXMuZ2xvYmFsS2lsbFNpZ25hbFJlY2VpdmVkfSBzaWduYWwsIHRoZXJlZm9yZSB0aGUgUHJpc21hIHF1ZXJ5IGVuZ2luZSBleGl0ZWRcbmFuZCB5b3VyIHJlcXVlc3QgY2FuJ3QgYmUgcHJvY2Vzc2VkLlxuWW91IHByb2JhYmx5IGhhdmUgc29tZSBvcGVuIGhhbmRsZSB0aGF0IHByZXZlbnRzIHlvdXIgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG5JdCBjb3VsZCBiZSBhbiBvcGVuIGh0dHAgc2VydmVyIG9yIHN0cmVhbSB0aGF0IGRpZG4ndCBjbG9zZSB5ZXQuXG5XZSByZWNvbW1lbmQgdXNpbmcgdGhlIFxcYHd0Zm5vZGVcXGAgcGFja2FnZSB0byBkZWJ1ZyBvcGVuIGhhbmRsZXMuYCxcbiAgICAgICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0FzeW5jRXJyb3JJZkV4aXN0cygpO1xuICAgICAgICBpZiAodGhpcy5zdGFydENvdW50ID4gTUFYX1NUQVJUUykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCA1MCkpO1xuICAgICAgICAgICAgdGhpcy50aHJvd0FzeW5jRXJyb3JJZkV4aXN0cyh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdWVyeSBlbmdpbmUgaXMgdHJ5aW5nIHRvIHJlc3RhcnQsIGJ1dCBjYW4ndC5cblBsZWFzZSBsb29rIGludG8gdGhlIGxvZ3Mgb3IgdHVybiBvbiB0aGUgZW52IHZhciBERUJVRz0qIHRvIGRlYnVnIHRoZSBjb25zdGFudGx5IHJlc3RhcnRpbmcgcXVlcnkgZW5naW5lLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWdyYWNlZnVsKSB7XG4gICAgICAgIHRoaXMudGhyb3dBc3luY0Vycm9ySWZFeGlzdHModHJ1ZSk7XG4gICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBcImhhbmRsZVJlcXVlc3RFcnJvclwiKTtcbiAgICB0aGlzLmRpcm5hbWUgPSBkaXJuYW1lMjtcbiAgICB0aGlzLmVudiA9IGVudjI7XG4gICAgdGhpcy5jd2QgPSB0aGlzLnJlc29sdmVDd2QoY3dkKTtcbiAgICB0aGlzLmVuYWJsZURlYnVnTG9ncyA9IGVuYWJsZURlYnVnTG9ncyAhPSBudWxsID8gZW5hYmxlRGVidWdMb2dzIDogZmFsc2U7XG4gICAgdGhpcy5hbGxvd1RyaWdnZXJQYW5pYyA9IGFsbG93VHJpZ2dlclBhbmljICE9IG51bGwgPyBhbGxvd1RyaWdnZXJQYW5pYyA6IGZhbHNlO1xuICAgIHRoaXMuZGF0YW1vZGVsUGF0aCA9IGRhdGFtb2RlbFBhdGg7XG4gICAgdGhpcy5wcmlzbWFQYXRoID0gKF9hMyA9IHByb2Nlc3MuZW52LlBSSVNNQV9RVUVSWV9FTkdJTkVfQklOQVJZKSAhPSBudWxsID8gX2EzIDogcHJpc21hUGF0aDtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICB0aGlzLmRhdGFzb3VyY2VzID0gZGF0YXNvdXJjZXM7XG4gICAgdGhpcy50cmFjaW5nQ29uZmlnID0gdHJhY2luZ0NvbmZpZztcbiAgICB0aGlzLmxvZ0VtaXR0ZXIgPSBuZXcgaW1wb3J0X2V2ZW50cy5kZWZhdWx0KCk7XG4gICAgdGhpcy5sb2dFbWl0dGVyLm9uKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgIH0pO1xuICAgIHRoaXMuc2hvd0NvbG9ycyA9IHNob3dDb2xvcnMgIT0gbnVsbCA/IHNob3dDb2xvcnMgOiBmYWxzZTtcbiAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgdGhpcy5sb2dRdWVyaWVzID0gbG9nUXVlcmllcyAhPSBudWxsID8gbG9nUXVlcmllcyA6IGZhbHNlO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb24yO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncyAhPSBudWxsID8gZmxhZ3MgOiBbXTtcbiAgICB0aGlzLnByZXZpZXdGZWF0dXJlcyA9IHByZXZpZXdGZWF0dXJlcyAhPSBudWxsID8gcHJldmlld0ZlYXR1cmVzIDogW107XG4gICAgdGhpcy5hY3RpdmVQcm92aWRlciA9IGFjdGl2ZVByb3ZpZGVyO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKCk7XG4gICAgaW5pdEhvb2tzKCk7XG4gICAgY29uc3QgcmVtb3ZlZEZsYWdzID0gW1xuICAgICAgXCJtaWRkbGV3YXJlc1wiLFxuICAgICAgXCJhZ2dyZWdhdGVBcGlcIixcbiAgICAgIFwiZGlzdGluY3RcIixcbiAgICAgIFwiYWdncmVnYXRpb25zXCIsXG4gICAgICBcImluc2Vuc2l0aXZlRmlsdGVyc1wiLFxuICAgICAgXCJhdG9taWNOdW1iZXJPcGVyYXRpb25zXCIsXG4gICAgICBcInRyYW5zYWN0aW9uQXBpXCIsXG4gICAgICBcInRyYW5zYWN0aW9uXCIsXG4gICAgICBcImNvbm5lY3RPckNyZWF0ZVwiLFxuICAgICAgXCJ1bmNoZWNrZWRTY2FsYXJJbnB1dHNcIixcbiAgICAgIFwibmF0aXZlVHlwZXNcIixcbiAgICAgIFwiY3JlYXRlTWFueVwiLFxuICAgICAgXCJncm91cEJ5XCIsXG4gICAgICBcInJlZmVyZW50aWFsQWN0aW9uc1wiLFxuICAgICAgXCJtaWNyb3NvZnRTcWxTZXJ2ZXJcIlxuICAgIF07XG4gICAgY29uc3QgcmVtb3ZlZEZsYWdzVXNlZCA9IHRoaXMucHJldmlld0ZlYXR1cmVzLmZpbHRlcigoZSkgPT4gcmVtb3ZlZEZsYWdzLmluY2x1ZGVzKGUpKTtcbiAgICBpZiAocmVtb3ZlZEZsYWdzVXNlZC5sZW5ndGggPiAwICYmICFwcm9jZXNzLmVudi5QUklTTUFfSElERV9QUkVWSUVXX0ZMQUdfV0FSTklOR1MpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuYmx1ZUJyaWdodChcImluZm9cIil9IFRoZSBwcmV2aWV3IGZsYWdzIFxcYCR7cmVtb3ZlZEZsYWdzVXNlZC5qb2luKFxuICAgICAgICAgIFwiYCwgYFwiXG4gICAgICAgICl9XFxgIHdlcmUgcmVtb3ZlZCwgeW91IGNhbiBub3cgc2FmZWx5IHJlbW92ZSB0aGVtIGZyb20geW91ciBzY2hlbWEucHJpc21hLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucHJldmlld0ZlYXR1cmVzID0gdGhpcy5wcmV2aWV3RmVhdHVyZXMuZmlsdGVyKChlKSA9PiAhcmVtb3ZlZEZsYWdzLmluY2x1ZGVzKGUpKTtcbiAgICB0aGlzLmVuZ2luZUVuZHBvaW50ID0gZW5naW5lRW5kcG9pbnQ7XG4gICAgaWYgKGVuZ2luZUVuZHBvaW50KSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgaW1wb3J0X3VybC5VUkwoZW5naW5lRW5kcG9pbnQpO1xuICAgICAgdGhpcy5wb3J0ID0gTnVtYmVyKHVybC5wb3J0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGxhdGZvcm0pIHtcbiAgICAgIGlmICgha25vd25QbGF0Zm9ybXMuaW5jbHVkZXModGhpcy5wbGF0Zm9ybSkgJiYgIWltcG9ydF9mczQuZGVmYXVsdC5leGlzdHNTeW5jKHRoaXMucGxhdGZvcm0pKSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICAgIGBVbmtub3duICR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnJlZChcIlBSSVNNQV9RVUVSWV9FTkdJTkVfQklOQVJZXCIpfSAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5yZWRCcmlnaHQuYm9sZChcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm1cbiAgICAgICAgICApfS4gUG9zc2libGUgYmluYXJ5VGFyZ2V0czogJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXG4gICAgICAgICAgICBrbm93blBsYXRmb3Jtcy5qb2luKFwiLCBcIilcbiAgICAgICAgICApfSBvciBhIHBhdGggdG8gdGhlIHF1ZXJ5IGVuZ2luZSBiaW5hcnkuXG5Zb3UgbWF5IGhhdmUgdG8gcnVuICR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmdyZWVuQnJpZ2h0KFwicHJpc21hIGdlbmVyYXRlXCIpfSBmb3IgeW91ciBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LmAsXG4gICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgdGhpcy5nZXRQbGF0Zm9ybSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmFibGVEZWJ1Z0xvZ3MpIHtcbiAgICAgIHNyY19kZWZhdWx0LmVuYWJsZShcIipcIik7XG4gICAgfVxuICAgIGVuZ2luZXMucHVzaCh0aGlzKTtcbiAgICB0aGlzLmNoZWNrRm9yVG9vTWFueUVuZ2luZXMoKTtcbiAgfVxuICBzZXRFcnJvcihlcnIpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmIChpc1J1c3RFcnJvcihlcnIpKSB7XG4gICAgICB0aGlzLmxhc3RSdXN0RXJyb3IgPSBlcnI7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBuZXcgUHJpc21hQ2xpZW50UnVzdEVycm9yKHtcbiAgICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb24sXG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmIChlcnIuaXNfcGFuaWMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5pYygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSdXN0RXJyb3JMb2coZXJyKSkge1xuICAgICAgdGhpcy5sYXN0RXJyb3JMb2cgPSBlcnI7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBuZXcgUHJpc21hQ2xpZW50UnVzdEVycm9yKHtcbiAgICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb24sXG4gICAgICAgICAgbG9nOiBlcnJcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpZiAoKChfYTMgPSBlcnIuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1lc3NhZ2UpID09PSBcIlBBTklDXCIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5pYygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgfVxuICB9XG4gIGNoZWNrRm9yVG9vTWFueUVuZ2luZXMoKSB7XG4gICAgaWYgKGVuZ2luZXMubGVuZ3RoID49IDEwKSB7XG4gICAgICBjb25zdCBydW5uaW5nRW5naW5lcyA9IGVuZ2luZXMuZmlsdGVyKChlKSA9PiBlLmNoaWxkKTtcbiAgICAgIGlmIChydW5uaW5nRW5naW5lcy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQueWVsbG93KFwid2FybihwcmlzbWEtY2xpZW50KVwiKX0gVGhlcmUgYXJlIGFscmVhZHkgMTAgaW5zdGFuY2VzIG9mIFByaXNtYSBDbGllbnQgYWN0aXZlbHkgcnVubmluZy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc29sdmVDd2QoY3dkKSB7XG4gICAgaWYgKGN3ZCAmJiBpbXBvcnRfZnM0LmRlZmF1bHQuZXhpc3RzU3luYyhjd2QpICYmIGltcG9ydF9mczQuZGVmYXVsdC5sc3RhdFN5bmMoY3dkKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gY3dkO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5jd2QoKTtcbiAgfVxuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmVmb3JlRXhpdFwiKSB7XG4gICAgICB0aGlzLmJlZm9yZUV4aXRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZW1pdEV4aXQoKSB7XG4gICAgaWYgKHRoaXMuYmVmb3JlRXhpdExpc3RlbmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZUV4aXRMaXN0ZW5lcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXRQbGF0Zm9ybSgpIHtcbiAgICBpZiAodGhpcy5wbGF0Zm9ybVByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXRmb3JtUHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybVByb21pc2UgPSBnZXRQbGF0Zm9ybSgpO1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtUHJvbWlzZTtcbiAgfVxuICBnZXRRdWVyeUVuZ2luZVBhdGgocGxhdGZvcm0zLCBwcmVmaXggPSBfX2Rpcm5hbWUpIHtcbiAgICBsZXQgcXVlcnlFbmdpbmVQYXRoID0gaW1wb3J0X3BhdGgyLmRlZmF1bHQuam9pbihwcmVmaXgsIGBxdWVyeS1lbmdpbmUtJHtwbGF0Zm9ybTN9YCk7XG4gICAgaWYgKHBsYXRmb3JtMyA9PT0gXCJ3aW5kb3dzXCIpIHtcbiAgICAgIHF1ZXJ5RW5naW5lUGF0aCA9IGAke3F1ZXJ5RW5naW5lUGF0aH0uZXhlYDtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5RW5naW5lUGF0aDtcbiAgfVxuICBoYW5kbGVQYW5pYygpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICB0aGlzLnN0b3BQcm9taXNlID0ga2lsbFByb2Nlc3NBbmRXYWl0KHRoaXMuY2hpbGQpO1xuICAgIH1cbiAgICBpZiAoKF9hMyA9IHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbmNlbCkge1xuICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc29sdmVQcmlzbWFQYXRoKCkge1xuICAgIHZhciBfYTMsIF9iMiwgX2M7XG4gICAgY29uc3Qgc2VhcmNoZWRMb2NhdGlvbnMgPSBbXTtcbiAgICBsZXQgZW5naW5lUGF0aDtcbiAgICBpZiAodGhpcy5wcmlzbWFQYXRoKSB7XG4gICAgICByZXR1cm4geyBwcmlzbWFQYXRoOiB0aGlzLnByaXNtYVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgfVxuICAgIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybSgpO1xuICAgIGlmICh0aGlzLnBsYXRmb3JtICYmIHRoaXMucGxhdGZvcm0gIT09IHBsYXRmb3JtKSB7XG4gICAgICB0aGlzLmluY29ycmVjdGx5UGlubmVkQmluYXJ5VGFyZ2V0ID0gdGhpcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm0gfHwgcGxhdGZvcm07XG4gICAgaWYgKF9fZmlsZW5hbWUuaW5jbHVkZXMoXCJCaW5hcnlFbmdpbmVcIikpIHtcbiAgICAgIGVuZ2luZVBhdGggPSB0aGlzLmdldFF1ZXJ5RW5naW5lUGF0aCh0aGlzLnBsYXRmb3JtLCBnZXRFbmdpbmVzUGF0aCgpKTtcbiAgICAgIHJldHVybiB7IHByaXNtYVBhdGg6IGVuZ2luZVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgfVxuICAgIGNvbnN0IHNlYXJjaExvY2F0aW9ucyA9IFtcbiAgICAgIGV2YWwoYHJlcXVpcmUoJ3BhdGgnKS5qb2luKF9fZGlybmFtZSwgJy4uLy4uLy4uLy5wcmlzbWEvY2xpZW50JylgKSxcbiAgICAgIChfYyA9IChfYjIgPSAoX2EzID0gdGhpcy5nZW5lcmF0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnZhbHVlKSAhPSBudWxsID8gX2MgOiBldmFsKFwiX19kaXJuYW1lXCIpLFxuICAgICAgaW1wb3J0X3BhdGgyLmRlZmF1bHQuam9pbihldmFsKFwiX19kaXJuYW1lXCIpLCBcIi4uXCIpLFxuICAgICAgaW1wb3J0X3BhdGgyLmRlZmF1bHQuZGlybmFtZSh0aGlzLmRhdGFtb2RlbFBhdGgpLFxuICAgICAgdGhpcy5jd2QsXG4gICAgICBcIi90bXAvcHJpc21hLWVuZ2luZXNcIlxuICAgIF07XG4gICAgaWYgKHRoaXMuZGlybmFtZSkge1xuICAgICAgc2VhcmNoTG9jYXRpb25zLnB1c2godGhpcy5kaXJuYW1lKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBzZWFyY2hMb2NhdGlvbnMpIHtcbiAgICAgIHNlYXJjaGVkTG9jYXRpb25zLnB1c2gobG9jYXRpb24pO1xuICAgICAgZGVidWc0KGBTZWFyY2ggZm9yIFF1ZXJ5IEVuZ2luZSBpbiAke2xvY2F0aW9ufWApO1xuICAgICAgZW5naW5lUGF0aCA9IHRoaXMuZ2V0UXVlcnlFbmdpbmVQYXRoKHRoaXMucGxhdGZvcm0sIGxvY2F0aW9uKTtcbiAgICAgIGlmIChpbXBvcnRfZnM0LmRlZmF1bHQuZXhpc3RzU3luYyhlbmdpbmVQYXRoKSkge1xuICAgICAgICByZXR1cm4geyBwcmlzbWFQYXRoOiBlbmdpbmVQYXRoLCBzZWFyY2hlZExvY2F0aW9ucyB9O1xuICAgICAgfVxuICAgIH1cbiAgICBlbmdpbmVQYXRoID0gdGhpcy5nZXRRdWVyeUVuZ2luZVBhdGgodGhpcy5wbGF0Zm9ybSk7XG4gICAgcmV0dXJuIHsgcHJpc21hUGF0aDogZW5naW5lUGF0aCAhPSBudWxsID8gZW5naW5lUGF0aCA6IFwiXCIsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gIH1cbiAgYXN5bmMgZ2V0UHJpc21hUGF0aCgpIHtcbiAgICBjb25zdCB7IHByaXNtYVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zOiBzZWFyY2hlZExvY2F0aW9uczIgfSA9IGF3YWl0IHRoaXMucmVzb2x2ZVByaXNtYVBhdGgoKTtcbiAgICBjb25zdCBwbGF0Zm9ybTMgPSBhd2FpdCB0aGlzLmdldFBsYXRmb3JtKCk7XG4gICAgaWYgKCFhd2FpdCBleGlzdHMyKHByaXNtYVBhdGgpKSB7XG4gICAgICBjb25zdCBwaW5uZWRTdHIgPSB0aGlzLmluY29ycmVjdGx5UGlubmVkQmluYXJ5VGFyZ2V0ID8gYFxuWW91IGluY29ycmVjdGx5IHBpbm5lZCBpdCB0byAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5yZWRCcmlnaHQuYm9sZChgJHt0aGlzLmluY29ycmVjdGx5UGlubmVkQmluYXJ5VGFyZ2V0fWApfVxuYCA6IFwiXCI7XG4gICAgICBsZXQgZXJyb3JUZXh0ID0gYFF1ZXJ5IGVuZ2luZSBiaW5hcnkgZm9yIGN1cnJlbnQgcGxhdGZvcm0gXCIke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ib2xkKFxuICAgICAgICBwbGF0Zm9ybTNcbiAgICAgICl9XCIgY291bGQgbm90IGJlIGZvdW5kLiR7cGlubmVkU3RyfVxuVGhpcyBwcm9iYWJseSBoYXBwZW5zLCBiZWNhdXNlIHlvdSBidWlsdCBQcmlzbWEgQ2xpZW50IG9uIGEgZGlmZmVyZW50IHBsYXRmb3JtLlxuKFByaXNtYSBDbGllbnQgbG9va2VkIGluIFwiJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQudW5kZXJsaW5lKHByaXNtYVBhdGgpfVwiKVxuXG5TZWFyY2hlZCBMb2NhdGlvbnM6XG5cbiR7c2VhcmNoZWRMb2NhdGlvbnMyLm1hcCgoZikgPT4ge1xuICAgICAgICBsZXQgbXNnID0gYCAgJHtmfWA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRyA9PT0gXCJub2RlLWVuZ2luZS1zZWFyY2gtbG9jYXRpb25zXCIgJiYgaW1wb3J0X2ZzNC5kZWZhdWx0LmV4aXN0c1N5bmMoZikpIHtcbiAgICAgICAgICBjb25zdCBkaXIgPSBpbXBvcnRfZnM0LmRlZmF1bHQucmVhZGRpclN5bmMoZik7XG4gICAgICAgICAgbXNnICs9IGRpci5tYXAoKGQpID0+IGAgICAgJHtkfWApLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgIH0pLmpvaW4oXCJcXG5cIiArIChwcm9jZXNzLmVudi5ERUJVRyA9PT0gXCJub2RlLWVuZ2luZS1zZWFyY2gtbG9jYXRpb25zXCIgPyBcIlxcblwiIDogXCJcIikpfVxuYDtcbiAgICAgIGlmICh0aGlzLmdlbmVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0b3IuYmluYXJ5VGFyZ2V0cy5maW5kKChvYmplY3QpID0+IG9iamVjdC52YWx1ZSA9PT0gdGhpcy5wbGF0Zm9ybSkgfHwgdGhpcy5nZW5lcmF0b3IuYmluYXJ5VGFyZ2V0cy5maW5kKChvYmplY3QpID0+IG9iamVjdC52YWx1ZSA9PT0gXCJuYXRpdmVcIikpIHtcbiAgICAgICAgICBlcnJvclRleHQgKz0gYFxuWW91IGFscmVhZHkgYWRkZWQgdGhlIHBsYXRmb3JtJHt0aGlzLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJ9ICR7dGhpcy5nZW5lcmF0b3IuYmluYXJ5VGFyZ2V0cy5tYXAoKHQpID0+IGBcIiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmJvbGQodC52YWx1ZSl9XCJgKS5qb2luKFwiLCBcIil9IHRvIHRoZSBcIiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnVuZGVybGluZShcImdlbmVyYXRvclwiKX1cIiBibG9ja1xuaW4gdGhlIFwic2NoZW1hLnByaXNtYVwiIGZpbGUgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcHJpcy5seS9kL2NsaWVudC1nZW5lcmF0b3IsXG5idXQgc29tZXRoaW5nIHdlbnQgd3JvbmcuIFRoYXQncyBzdWJvcHRpbWFsLlxuXG5QbGVhc2UgY3JlYXRlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlcy9uZXdgO1xuICAgICAgICAgIGVycm9yVGV4dCArPSBgYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvclRleHQgKz0gYFxuXG5UbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGFkZCB0aGUgcGxhdGZvcm0gXCIke3RoaXMucGxhdGZvcm19XCIgdG8gdGhlIFwiJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQudW5kZXJsaW5lKFxuICAgICAgICAgICAgXCJiaW5hcnlUYXJnZXRzXCJcbiAgICAgICAgICApfVwiIGF0dHJpYnV0ZSBpbiB0aGUgXCIke2ltcG9ydF9jaGFsazMuZGVmYXVsdC51bmRlcmxpbmUoXCJnZW5lcmF0b3JcIil9XCIgYmxvY2sgaW4gdGhlIFwic2NoZW1hLnByaXNtYVwiIGZpbGU6XG4ke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ncmVlbkJyaWdodCh0aGlzLmdldEZpeGVkR2VuZXJhdG9yKCkpfVxuXG5UaGVuIHJ1biBcIiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmdyZWVuQnJpZ2h0KFwicHJpc21hIGdlbmVyYXRlXCIpfVwiIGZvciB5b3VyIGNoYW5nZXMgdG8gdGFrZSBlZmZlY3QuXG5SZWFkIG1vcmUgYWJvdXQgZGVwbG95aW5nIFByaXNtYSBDbGllbnQ6IGh0dHBzOi8vcHJpcy5seS9kL2NsaWVudC1nZW5lcmF0b3JgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvclRleHQgKz0gYFxuXG5SZWFkIG1vcmUgYWJvdXQgZGVwbG95aW5nIFByaXNtYSBDbGllbnQ6IGh0dHBzOi8vcHJpcy5seS9kL2NsaWVudC1nZW5lcmF0b3JcbmA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihlcnJvclRleHQsIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmluY29ycmVjdGx5UGlubmVkQmluYXJ5VGFyZ2V0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC55ZWxsb3coXCJXYXJuaW5nOlwiKX0gWW91IHBpbm5lZCB0aGUgcGxhdGZvcm0gJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuYm9sZChcbiAgICAgICAgdGhpcy5pbmNvcnJlY3RseVBpbm5lZEJpbmFyeVRhcmdldFxuICAgICAgKX0sIGJ1dCBQcmlzbWEgQ2xpZW50IGRldGVjdHMgJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuYm9sZChhd2FpdCB0aGlzLmdldFBsYXRmb3JtKCkpfS5cblRoaXMgbWVhbnMgeW91IHNob3VsZCB2ZXJ5IGxpa2VseSBwaW4gdGhlIHBsYXRmb3JtICR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmdyZWVuQnJpZ2h0KGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm0oKSl9IGluc3RlYWQuXG4ke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5kaW0oXCJJbiBjYXNlIHdlJ3JlIG1pc3Rha2VuLCBwbGVhc2UgcmVwb3J0IHRoaXMgdG8gdXMgXFx1ezFGNjRGfS5cIil9YCk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSBcIndpbjMyXCIpIHtcbiAgICAgIHBsdXNYKHByaXNtYVBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcHJpc21hUGF0aDtcbiAgfVxuICBnZXRGaXhlZEdlbmVyYXRvcigpIHtcbiAgICBjb25zdCBmaXhlZEdlbmVyYXRvciA9IHtcbiAgICAgIC4uLnRoaXMuZ2VuZXJhdG9yLFxuICAgICAgYmluYXJ5VGFyZ2V0czogZml4QmluYXJ5VGFyZ2V0cyh0aGlzLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLCB0aGlzLnBsYXRmb3JtKVxuICAgIH07XG4gICAgcmV0dXJuIHByaW50R2VuZXJhdG9yQ29uZmlnKGZpeGVkR2VuZXJhdG9yKTtcbiAgfVxuICBwcmludERhdGFzb3VyY2VzKCkge1xuICAgIGlmICh0aGlzLmRhdGFzb3VyY2VzKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhc291cmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBcIltdXCI7XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuc3RvcFByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0Rm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGFydFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5zdGFydENvdW50Kys7XG4gICAgICAgIHRoaXMuc3RhcnRQcm9taXNlID0gdGhpcy5pbnRlcm5hbFN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnN0YXJ0UHJvbWlzZTtcbiAgICAgIGlmICghdGhpcy5jaGlsZCAmJiAhdGhpcy5lbmdpbmVFbmRwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihcbiAgICAgICAgICBgQ2FuJ3QgcGVyZm9ybSByZXF1ZXN0LCBhcyB0aGUgRW5naW5lIGhhcyBhbHJlYWR5IGJlZW4gc3RvcHBlZGAsXG4gICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgXCJzdGFydEZuXCIpO1xuICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgbmFtZTogXCJjb25uZWN0XCIsXG4gICAgICBlbmFibGVkOiB0aGlzLnRyYWNpbmdDb25maWcuZW5hYmxlZCAmJiAhdGhpcy5zdGFydFByb21pc2VcbiAgICB9O1xuICAgIHJldHVybiBydW5JbkNoaWxkU3BhbihzcGFuT3B0aW9ucywgc3RhcnRGbik7XG4gIH1cbiAgZ2V0RW5naW5lRW52VmFycygpIHtcbiAgICB2YXIgX2EzLCBfYjI7XG4gICAgY29uc3QgZW52MiA9IHtcbiAgICAgIFBSSVNNQV9ETUxfUEFUSDogdGhpcy5kYXRhbW9kZWxQYXRoXG4gICAgfTtcbiAgICBpZiAodGhpcy5sb2dRdWVyaWVzIHx8IHRoaXMubG9nTGV2ZWwgPT09IFwiaW5mb1wiKSB7XG4gICAgICBpZiAodGhpcy5sb2dRdWVyaWVzKSB7XG4gICAgICAgIGVudjIuTE9HX1FVRVJJRVMgPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZXMpIHtcbiAgICAgIGVudjIuT1ZFUldSSVRFX0RBVEFTT1VSQ0VTID0gdGhpcy5wcmludERhdGFzb3VyY2VzKCk7XG4gICAgfVxuICAgIGlmICghcHJvY2Vzcy5lbnYuTk9fQ09MT1IgJiYgdGhpcy5zaG93Q29sb3JzKSB7XG4gICAgICBlbnYyLkNMSUNPTE9SX0ZPUkNFID0gXCIxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmVudixcbiAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgLi4uZW52MixcbiAgICAgIFJVU1RfQkFDS1RSQUNFOiAoX2EzID0gcHJvY2Vzcy5lbnYuUlVTVF9CQUNLVFJBQ0UpICE9IG51bGwgPyBfYTMgOiBcIjFcIixcbiAgICAgIFJVU1RfTE9HOiAoX2IyID0gcHJvY2Vzcy5lbnYuUlVTVF9MT0cpICE9IG51bGwgPyBfYjIgOiBcImluZm9cIlxuICAgIH07XG4gIH1cbiAgaW50ZXJuYWxTdGFydCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMywgX2IyLCBfYztcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBwcm9jZXNzLm5leHRUaWNrKHIpKTtcbiAgICAgIGlmICh0aGlzLnN0b3BQcm9taXNlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmdpbmVFbmRwb2ludCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vcGVuKHRoaXMuZW5naW5lRW5kcG9pbnQpO1xuICAgICAgICAgIGF3YWl0ICgwLCBpbXBvcnRfcF9yZXRyeS5kZWZhdWx0KSgoKSA9PiB0aGlzLmNvbm5lY3Rpb24uZ2V0KFwiL3N0YXR1c1wiKSwge1xuICAgICAgICAgICAgcmV0cmllczogMTBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoKF9hMyA9IHRoaXMuY2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29ubmVjdGVkKSB8fCB0aGlzLmNoaWxkICYmICEoKF9iMiA9IHRoaXMuY2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIua2lsbGVkKSkge1xuICAgICAgICAgIGRlYnVnNChgVGhlcmUgaXMgYSBjaGlsZCB0aGF0IHN0aWxsIHJ1bnMgYW5kIHdlIHdhbnQgdG8gc3RhcnQgYWdhaW5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RSdXN0RXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubGFzdEVycm9yTG9nID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxhc3RQYW5pYyA9IHZvaWQgMDtcbiAgICAgICAgbG9nZ2VyKFwic3RhcnRpbiAmIHJlc2V0dGluXCIpO1xuICAgICAgICB0aGlzLmdsb2JhbEtpbGxTaWduYWxSZWNlaXZlZCA9IHZvaWQgMDtcbiAgICAgICAgZGVidWc0KHsgY3dkOiB0aGlzLmN3ZCB9KTtcbiAgICAgICAgY29uc3QgcHJpc21hUGF0aCA9IGF3YWl0IHRoaXMuZ2V0UHJpc21hUGF0aCgpO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsRmxhZyA9IHRoaXMuYWxsb3dUcmlnZ2VyUGFuaWMgPyBbXCItLWRlYnVnXCJdIDogW107XG4gICAgICAgIGNvbnN0IGZsYWdzID0gW1xuICAgICAgICAgIFwiLS1lbmFibGUtcmF3LXF1ZXJpZXNcIixcbiAgICAgICAgICBcIi0tZW5hYmxlLW1ldHJpY3NcIixcbiAgICAgICAgICBcIi0tZW5hYmxlLW9wZW4tdGVsZW1ldHJ5XCIsXG4gICAgICAgICAgLi4udGhpcy5mbGFncyxcbiAgICAgICAgICAuLi5hZGRpdGlvbmFsRmxhZ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLnBvcnQgPSBhd2FpdCB0aGlzLmdldEZyZWVQb3J0KCk7XG4gICAgICAgIGZsYWdzLnB1c2goXCItLXBvcnRcIiwgU3RyaW5nKHRoaXMucG9ydCkpO1xuICAgICAgICBkZWJ1ZzQoeyBmbGFncyB9KTtcbiAgICAgICAgY29uc3QgZW52MiA9IHRoaXMuZ2V0RW5naW5lRW52VmFycygpO1xuICAgICAgICB0aGlzLmNoaWxkID0gKDAsIGltcG9ydF9jaGlsZF9wcm9jZXNzMi5zcGF3bikocHJpc21hUGF0aCwgZmxhZ3MsIHtcbiAgICAgICAgICBlbnY6IGVudjIsXG4gICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgICAgICAgICBzdGRpbzogW1wiaWdub3JlXCIsIFwicGlwZVwiLCBcInBpcGVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIGJ5bGluZSh0aGlzLmNoaWxkLnN0ZGVycikub24oXCJkYXRhXCIsIChtc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gU3RyaW5nKG1zZyk7XG4gICAgICAgICAgZGVidWc0KFwic3RkZXJyXCIsIGRhdGEpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi5pc19wYW5pYyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICBkZWJ1ZzQoanNvbik7XG4gICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoanNvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihqc29uLm1lc3NhZ2UsIHRoaXMuY2xpZW50VmVyc2lvbiwganNvbi5lcnJvcl9jb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaW5jbHVkZXMoXCJQcmludGluZyB0byBzdGRlcnJcIikgJiYgIWRhdGEuaW5jbHVkZXMoXCJMaXN0ZW5pbmcgb24gXCIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RkZXJyTG9ncyArPSBcIlxcblwiICsgZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBieWxpbmUodGhpcy5jaGlsZC5zdGRvdXQpLm9uKFwiZGF0YVwiLCAobXNnKSA9PiB7XG4gICAgICAgICAgdmFyIF9hNCwgX2IzO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBTdHJpbmcobXNnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBkZWJ1ZzQoXCJzdGRvdXRcIiwgZ2V0TWVzc2FnZShqc29uKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmVTdGFydERlZmVycmVkICYmIGpzb24ubGV2ZWwgPT09IFwiSU5GT1wiICYmIGpzb24udGFyZ2V0ID09PSBcInF1ZXJ5X2VuZ2luZTo6c2VydmVyXCIgJiYgKChfYjMgPSAoX2E0ID0ganNvbi5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTQubWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMy5zdGFydHNXaXRoKFwiU3RhcnRlZCBxdWVyeSBlbmdpbmUgaHR0cCBzZXJ2ZXJcIikpKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vcGVuKGBodHRwOi8vMTI3LjAuMC4xOiR7dGhpcy5wb3J0fWApO1xuICAgICAgICAgICAgICB0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24uaXNfcGFuaWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uc3BhbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNpbmdDb25maWcuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgdm9pZCBjcmVhdGVTcGFuKGpzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgbG9nNCA9IGNvbnZlcnRMb2coanNvbik7XG4gICAgICAgICAgICAgIGNvbnN0IGxvZ0lzUnVzdEVycm9yTG9nID0gaXNSdXN0RXJyb3JMb2cobG9nNCk7XG4gICAgICAgICAgICAgIGlmIChsb2dJc1J1c3RFcnJvckxvZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IobG9nNCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQobG9nNC5sZXZlbCwgbG9nNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWc0KGUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hpbGQub24oXCJleGl0XCIsIChjb2RlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hNDtcbiAgICAgICAgICBsb2dnZXIoXCJyZW1vdmluZyBzdGFydFByb21pc2VcIik7XG4gICAgICAgICAgdGhpcy5zdGFydFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lU3RvcERlZmVycmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZVN0b3BEZWZlcnJlZC5yZXNvbHZlKGNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICBpZiAoY29kZSAhPT0gMCAmJiB0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQgJiYgdGhpcy5zdGFydENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgZXJyO1xuICAgICAgICAgICAgbGV0IG1zZyA9IHRoaXMuc3RkZXJyTG9ncztcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RSdXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgbXNnID0gZ2V0TWVzc2FnZSh0aGlzLmxhc3RSdXN0RXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RFcnJvckxvZykge1xuICAgICAgICAgICAgICBtc2cgPSBnZXRNZXNzYWdlKHRoaXMubGFzdEVycm9yTG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVyciA9IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIGBRdWVyeSBlbmdpbmUgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9XG5gICsgbXNnLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoX2E0ID0gdGhpcy5jaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5zaWduYWxDb2RlKSB7XG4gICAgICAgICAgICAgIGVyciA9IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgIGBRdWVyeSBlbmdpbmUgcHJvY2VzcyBraWxsZWQgd2l0aCBzaWduYWwgJHt0aGlzLmNoaWxkLnNpZ25hbENvZGV9IGZvciB1bmtub3duIHJlYXNvbi5cbk1ha2Ugc3VyZSB0aGF0IHRoZSBlbmdpbmUgYmluYXJ5IGF0ICR7cHJpc21hUGF0aH0gaXMgbm90IGNvcnJ1cHQuXG5gICsgbXNnLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyID0gbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IobXNnLCB0aGlzLmNsaWVudFZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmdpbmVTdGFydERlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubGFzdFJ1c3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZSA9PT0gMTI2KSB7XG4gICAgICAgICAgICB0aGlzLnNldEVycm9yKHtcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiZXhpdFwiLFxuICAgICAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGRuJ3Qgc3RhcnQgcXVlcnkgZW5naW5lIGFzIGl0J3Mgbm90IGV4ZWN1dGFibGUgb24gdGhpcyBvcGVyYXRpbmcgc3lzdGVtLlxuWW91IHZlcnkgbGlrZWx5IGhhdmUgdGhlIHdyb25nIFwiYmluYXJ5VGFyZ2V0XCIgZGVmaW5lZCBpbiB0aGUgc2NoZW1hLnByaXNtYSBmaWxlLmBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZC5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLnNldEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgYmFja3RyYWNlOiBcIkNvdWxkIG5vdCBzdGFydCBxdWVyeSBlbmdpbmVcIixcbiAgICAgICAgICAgIGlzX3BhbmljOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZC5vbihcImNsb3NlXCIsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgICB2YXIgX2E0O1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgIGlmIChjb2RlID09PSBudWxsICYmIHNpZ25hbCA9PT0gXCJTSUdBQlJUXCIgJiYgdGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IyID0gbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKFxuICAgICAgICAgICAgICB0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKFwiUGFuaWMgaW4gUXVlcnkgRW5naW5lIHdpdGggU0lHQUJSVCBzaWduYWxcIiksXG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyb3IyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDI1NSAmJiBzaWduYWwgPT09IG51bGwgJiYgKChfYTQgPSB0aGlzLmxhc3RFcnJvckxvZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5maWVsZHMubWVzc2FnZSkgPT09IFwiUEFOSUNcIiAmJiAhdGhpcy5sYXN0UGFuaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yMiA9IG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcihcbiAgICAgICAgICAgICAgdGhpcy5nZXRFcnJvck1lc3NhZ2VXaXRoTGluayhcbiAgICAgICAgICAgICAgICBgJHt0aGlzLmxhc3RFcnJvckxvZy5maWVsZHMubWVzc2FnZX06ICR7dGhpcy5sYXN0RXJyb3JMb2cuZmllbGRzLnJlYXNvbn0gaW4gJHt0aGlzLmxhc3RFcnJvckxvZy5maWVsZHMuZmlsZX06JHt0aGlzLmxhc3RFcnJvckxvZy5maWVsZHMubGluZX06JHt0aGlzLmxhc3RFcnJvckxvZy5maWVsZHMuY29sdW1ufWBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihlcnJvcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RSdXN0RXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGdldE1lc3NhZ2UodGhpcy5sYXN0UnVzdEVycm9yKSwgdGhpcy5jbGllbnRWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yTG9nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihnZXRNZXNzYWdlKHRoaXMubGFzdEVycm9yTG9nKSwgdGhpcy5jbGllbnRWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdDIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZCA9IHsgcmVzb2x2ZTogcmVzb2x2ZTIsIHJlamVjdDogcmVqZWN0MiB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAoX2MgPSB0aGlzLmNoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2Mua2lsbCgpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZ2luZVZlcnNpb24gPSBhd2FpdCB0aGlzLnZlcnNpb24odHJ1ZSk7XG4gICAgICAgICAgICBkZWJ1ZzQoYENsaWVudCBWZXJzaW9uOiAke3RoaXMuY2xpZW50VmVyc2lvbn1gKTtcbiAgICAgICAgICAgIGRlYnVnNChgRW5naW5lIFZlcnNpb246ICR7ZW5naW5lVmVyc2lvbn1gKTtcbiAgICAgICAgICAgIGRlYnVnNChgQWN0aXZlIHByb3ZpZGVyOiAke3RoaXMuYWN0aXZlUHJvdmlkZXJ9YCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWc0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5zdG9wUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc3RvcCgpIHtcbiAgICBjb25zdCBzdG9wRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdG9wUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnN0b3BQcm9taXNlID0gdGhpcy5fc3RvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcFByb21pc2U7XG4gICAgfSwgXCJzdG9wRm5cIik7XG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICBuYW1lOiBcImRpc2Nvbm5lY3RcIixcbiAgICAgIGVuYWJsZWQ6IHRoaXMudHJhY2luZ0NvbmZpZy5lbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcnVuSW5DaGlsZFNwYW4oc3Bhbk9wdGlvbnMsIHN0b3BGbik7XG4gIH1cbiAgYXN5bmMgX3N0b3AoKSB7XG4gICAgdmFyIF9hMztcbiAgICBpZiAodGhpcy5zdGFydFByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnRQcm9taXNlO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcHJvY2Vzcy5uZXh0VGljayhyZXNvbHZlKSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5nZXRDb25maWdQcm9taXNlID0gdm9pZCAwO1xuICAgIGxldCBzdG9wQ2hpbGRQcm9taXNlO1xuICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICBkZWJ1ZzQoYFN0b3BwaW5nIFByaXNtYSBlbmdpbmU0YCk7XG4gICAgICBpZiAodGhpcy5zdGFydFByb21pc2UpIHtcbiAgICAgICAgZGVidWc0KGBXYWl0aW5nIGZvciBzdGFydCBwcm9taXNlYCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhcnRQcm9taXNlO1xuICAgICAgfVxuICAgICAgZGVidWc0KGBEb25lIHdhaXRpbmcgZm9yIHN0YXJ0IHByb21pc2VgKTtcbiAgICAgIHN0b3BDaGlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZW5naW5lU3RvcERlZmVycmVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAoX2EzID0gdGhpcy5jaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5raWxsKCk7XG4gICAgICB0aGlzLmNoaWxkID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc3RvcENoaWxkUHJvbWlzZSkge1xuICAgICAgYXdhaXQgc3RvcENoaWxkUHJvbWlzZTtcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHByb2Nlc3MubmV4dFRpY2socikpO1xuICAgIHRoaXMuc3RhcnRQcm9taXNlID0gdm9pZCAwO1xuICAgIHRoaXMuZW5naW5lU3RvcERlZmVycmVkID0gdm9pZCAwO1xuICB9XG4gIGtpbGwoc2lnbmFsKSB7XG4gICAgdmFyIF9hMztcbiAgICB0aGlzLmdldENvbmZpZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5nbG9iYWxLaWxsU2lnbmFsUmVjZWl2ZWQgPSBzaWduYWw7XG4gICAgKF9hMyA9IHRoaXMuY2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMua2lsbCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICB9XG4gIGdldEZyZWVQb3J0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSBpbXBvcnRfbmV0LmRlZmF1bHQuY3JlYXRlU2VydmVyKChzKSA9PiBzLmVuZChcIlwiKSk7XG4gICAgICBzZXJ2ZXIudW5yZWYoKTtcbiAgICAgIHNlcnZlci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICBzZXJ2ZXIubGlzdGVuKDAsICgpID0+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgIGNvbnN0IHBvcnQgPSB0eXBlb2YgYWRkcmVzcyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGFkZHJlc3Muc3BsaXQoXCI6XCIpLnNsaWNlKC0xKVswXSwgMTApIDogYWRkcmVzcy5wb3J0O1xuICAgICAgICBzZXJ2ZXIuY2xvc2UoKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHBvcnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnUHJvbWlzZSkge1xuICAgICAgdGhpcy5nZXRDb25maWdQcm9taXNlID0gdGhpcy5fZ2V0Q29uZmlnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldENvbmZpZ1Byb21pc2U7XG4gIH1cbiAgYXN5bmMgX2dldENvbmZpZygpIHtcbiAgICBjb25zdCBwcmlzbWFQYXRoID0gYXdhaXQgdGhpcy5nZXRQcmlzbWFQYXRoKCk7XG4gICAgY29uc3QgZW52MiA9IGF3YWl0IHRoaXMuZ2V0RW5naW5lRW52VmFycygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBpbXBvcnRfZXhlY2EuZGVmYXVsdCkocHJpc21hUGF0aCwgW1wiY2xpXCIsIFwiZ2V0LWNvbmZpZ1wiXSwge1xuICAgICAgZW52OiBvbWl0KGVudjIsIFtcIlBPUlRcIl0pLFxuICAgICAgY3dkOiB0aGlzLmN3ZFxuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdC5zdGRvdXQpO1xuICB9XG4gIGFzeW5jIGdldERtbWYoKSB7XG4gICAgaWYgKCF0aGlzLmdldERtbWZQcm9taXNlKSB7XG4gICAgICB0aGlzLmdldERtbWZQcm9taXNlID0gdGhpcy5fZ2V0RG1tZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXREbW1mUHJvbWlzZTtcbiAgfVxuICBhc3luYyBfZ2V0RG1tZigpIHtcbiAgICBjb25zdCBwcmlzbWFQYXRoID0gYXdhaXQgdGhpcy5nZXRQcmlzbWFQYXRoKCk7XG4gICAgY29uc3QgZW52MiA9IGF3YWl0IHRoaXMuZ2V0RW5naW5lRW52VmFycygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBpbXBvcnRfZXhlY2EuZGVmYXVsdCkocHJpc21hUGF0aCwgW1wiLS1lbmFibGUtcmF3LXF1ZXJpZXNcIiwgXCJjbGlcIiwgXCJkbW1mXCJdLCB7XG4gICAgICBlbnY6IG9taXQoZW52MiwgW1wiUE9SVFwiXSksXG4gICAgICBjd2Q6IHRoaXMuY3dkXG4gICAgfSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzdWx0LnN0ZG91dCk7XG4gIH1cbiAgYXN5bmMgdmVyc2lvbihmb3JjZVJ1biA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvblByb21pc2UgJiYgIWZvcmNlUnVuKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJzaW9uUHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IHRoaXMuaW50ZXJuYWxWZXJzaW9uKCk7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgaW50ZXJuYWxWZXJzaW9uKCkge1xuICAgIGNvbnN0IHByaXNtYVBhdGggPSBhd2FpdCB0aGlzLmdldFByaXNtYVBhdGgoKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgaW1wb3J0X2V4ZWNhLmRlZmF1bHQpKHByaXNtYVBhdGgsIFtcIi0tdmVyc2lvblwiXSk7XG4gICAgdGhpcy5sYXN0VmVyc2lvbiA9IHJlc3VsdC5zdGRvdXQ7XG4gICAgcmV0dXJuIHRoaXMubGFzdFZlcnNpb247XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChxdWVyeTIsIGhlYWRlcnMgPSB7fSwgbnVtVHJ5ID0gMSkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZSA9IHRoaXMuY29ubmVjdGlvbi5wb3N0KFwiL1wiLCBzdHJpbmdpZnlRdWVyeShxdWVyeTIpLCBydW50aW1lSGVhZGVyc1RvSHR0cEhlYWRlcnMoaGVhZGVycykpO1xuICAgIHRoaXMubGFzdFF1ZXJ5ID0gcXVlcnkyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGhlYWRlcnM6IGhlYWRlcnMyIH0gPSBhd2FpdCB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZTtcbiAgICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgICBpZiAoZGF0YS5lcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgcHJpc21hR3JhcGhRTFRvSlNFcnJvcihkYXRhLmVycm9yc1swXSwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihKU09OLnN0cmluZ2lmeShkYXRhLmVycm9ycyksIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGFwc2VkID0gcGFyc2VJbnQoaGVhZGVyczJbXCJ4LWVsYXBzZWRcIl0pIC8gMWUzO1xuICAgICAgaWYgKHRoaXMuc3RhcnRDb3VudCA+IDApIHtcbiAgICAgICAgdGhpcy5zdGFydENvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHsgZGF0YSwgZWxhcHNlZCB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcihcInJlcSAtIGVcIiwgZSk7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVJlcXVlc3RFcnJvcihlLCBudW1UcnkgPD0gTUFYX1JFUVVFU1RfUkVUUklFUyk7XG4gICAgICBpZiAobnVtVHJ5IDw9IE1BWF9SRVFVRVNUX1JFVFJJRVMpIHtcbiAgICAgICAgbG9nZ2VyKFwidHJ5aW5nIGEgcmV0cnkgbm93XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHF1ZXJ5MiwgaGVhZGVycywgbnVtVHJ5ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RCYXRjaChxdWVyaWVzLCBoZWFkZXJzID0ge30sIHRyYW5zYWN0aW9uID0gZmFsc2UsIG51bVRyeSA9IDEpIHtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgY29uc3QgcmVxdWVzdDIgPSB7XG4gICAgICBiYXRjaDogcXVlcmllcy5tYXAoKHF1ZXJ5MikgPT4gKHsgcXVlcnk6IHF1ZXJ5MiwgdmFyaWFibGVzOiB7fSB9KSksXG4gICAgICB0cmFuc2FjdGlvblxuICAgIH07XG4gICAgdGhpcy5sYXN0UXVlcnkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Mik7XG4gICAgdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UgPSB0aGlzLmNvbm5lY3Rpb24ucG9zdChcIi9cIiwgdGhpcy5sYXN0UXVlcnksIHJ1bnRpbWVIZWFkZXJzVG9IdHRwSGVhZGVycyhoZWFkZXJzKSk7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlLnRoZW4oKHsgZGF0YSwgaGVhZGVyczogaGVhZGVyczIgfSkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IHBhcnNlSW50KGhlYWRlcnMyW1wieC1lbGFwc2VkXCJdKSAvIDFlMztcbiAgICAgIGNvbnN0IHsgYmF0Y2hSZXN1bHQsIGVycm9ycyB9ID0gZGF0YTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJhdGNoUmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gYmF0Y2hSZXN1bHQubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgcHJpc21hR3JhcGhRTFRvSlNFcnJvcihkYXRhLmVycm9yc1swXSwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdCxcbiAgICAgICAgICAgIGVsYXBzZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHByaXNtYUdyYXBoUUxUb0pTRXJyb3IoZGF0YS5lcnJvcnNbMF0sIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IGlzRXJyb3IyID0gYXdhaXQgdGhpcy5oYW5kbGVSZXF1ZXN0RXJyb3IoZSwgbnVtVHJ5IDwgMyk7XG4gICAgICBpZiAoIWlzRXJyb3IyKSB7XG4gICAgICAgIGlmIChudW1UcnkgPD0gTUFYX1JFUVVFU1RfUkVUUklFUykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RCYXRjaChxdWVyaWVzLCBoZWFkZXJzLCB0cmFuc2FjdGlvbiwgbnVtVHJ5ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGlzRXJyb3IyO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHRyYW5zYWN0aW9uKGFjdGlvbiwgaGVhZGVycywgYXJnMikge1xuICAgIHZhciBfYTMsIF9iMjtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBjb25zdCBqc29uT3B0aW9ucyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbWF4X3dhaXQ6IChfYTMgPSBhcmcyID09IG51bGwgPyB2b2lkIDAgOiBhcmcyLm1heFdhaXQpICE9IG51bGwgPyBfYTMgOiAyZTMsXG4gICAgICAgIHRpbWVvdXQ6IChfYjIgPSBhcmcyID09IG51bGwgPyB2b2lkIDAgOiBhcmcyLnRpbWVvdXQpICE9IG51bGwgPyBfYjIgOiA1ZTMsXG4gICAgICAgIGlzb2xhdGlvbl9sZXZlbDogYXJnMiA9PSBudWxsID8gdm9pZCAwIDogYXJnMi5pc29sYXRpb25MZXZlbFxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBDb25uZWN0aW9uLm9uSHR0cEVycm9yKFxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucG9zdChcIi90cmFuc2FjdGlvbi9zdGFydFwiLCBqc29uT3B0aW9ucywgcnVudGltZUhlYWRlcnNUb0h0dHBIZWFkZXJzKGhlYWRlcnMpKSxcbiAgICAgICAgdHJhbnNhY3Rpb25IdHRwRXJyb3JIYW5kbGVyXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcImNvbW1pdFwiKSB7XG4gICAgICBhd2FpdCBDb25uZWN0aW9uLm9uSHR0cEVycm9yKHRoaXMuY29ubmVjdGlvbi5wb3N0KGAvdHJhbnNhY3Rpb24vJHthcmcyLmlkfS9jb21taXRgKSwgdHJhbnNhY3Rpb25IdHRwRXJyb3JIYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyb2xsYmFja1wiKSB7XG4gICAgICBhd2FpdCBDb25uZWN0aW9uLm9uSHR0cEVycm9yKHRoaXMuY29ubmVjdGlvbi5wb3N0KGAvdHJhbnNhY3Rpb24vJHthcmcyLmlkfS9yb2xsYmFja2ApLCB0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldCBoYXNNYXhSZXN0YXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydENvdW50ID49IE1BWF9TVEFSVFM7XG4gIH1cbiAgdGhyb3dBc3luY0Vycm9ySWZFeGlzdHMoZm9yY2VUaHJvdyA9IGZhbHNlKSB7XG4gICAgdmFyIF9hMywgX2IyO1xuICAgIGxvZ2dlcihcInRocm93QXN5bmNFcnJvcklmRXhpc3RzXCIsIHRoaXMuc3RhcnRDb3VudCwgdGhpcy5oYXNNYXhSZXN0YXJ0cyk7XG4gICAgaWYgKHRoaXMubGFzdFJ1c3RFcnJvcikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKFxuICAgICAgICB0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKGdldE1lc3NhZ2UodGhpcy5sYXN0UnVzdEVycm9yKSksXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmxhc3RSdXN0RXJyb3IuaXNfcGFuaWMpIHtcbiAgICAgICAgdGhpcy5sYXN0UGFuaWMgPSBlcnI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNNYXhSZXN0YXJ0cyB8fCBmb3JjZVRocm93KSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdEVycm9yTG9nICYmIGlzUnVzdEVycm9yTG9nKHRoaXMubGFzdEVycm9yTG9nKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IoXG4gICAgICAgIHRoaXMuZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsoZ2V0TWVzc2FnZSh0aGlzLmxhc3RFcnJvckxvZykpLFxuICAgICAgICB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICk7XG4gICAgICBpZiAoKChfYjIgPSAoX2EzID0gdGhpcy5sYXN0RXJyb3JMb2cpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm1lc3NhZ2UpID09PSBcIlBBTklDXCIpIHtcbiAgICAgICAgdGhpcy5sYXN0UGFuaWMgPSBlcnI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNNYXhSZXN0YXJ0cyB8fCBmb3JjZVRocm93KSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsodGl0bGUpIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsoe1xuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICB0aXRsZSxcbiAgICAgIHZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvbixcbiAgICAgIGVuZ2luZVZlcnNpb246IHRoaXMubGFzdFZlcnNpb24sXG4gICAgICBkYXRhYmFzZTogdGhpcy5sYXN0QWN0aXZlUHJvdmlkZXIsXG4gICAgICBxdWVyeTogdGhpcy5sYXN0UXVlcnlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBtZXRyaWNzKHsgZm9ybWF0OiBmb3JtYXQyLCBnbG9iYWxMYWJlbHMgfSkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICBjb25zdCBwYXJzZVJlc3BvbnNlID0gZm9ybWF0MiA9PT0gXCJqc29uXCI7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucG9zdChcbiAgICAgIGAvbWV0cmljcz9mb3JtYXQ9JHtlbmNvZGVVUklDb21wb25lbnQoZm9ybWF0Mil9YCxcbiAgICAgIEpTT04uc3RyaW5naWZ5KGdsb2JhbExhYmVscyksXG4gICAgICBudWxsLFxuICAgICAgcGFyc2VSZXNwb25zZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbn07XG5fX25hbWUoQmluYXJ5RW5naW5lLCBcIkJpbmFyeUVuZ2luZVwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5KHEpIHtcbiAgcmV0dXJuIGB7XCJ2YXJpYWJsZXNcIjp7fSxcInF1ZXJ5XCI6JHtKU09OLnN0cmluZ2lmeShxKX19YDtcbn1cbl9fbmFtZShzdHJpbmdpZnlRdWVyeSwgXCJzdHJpbmdpZnlRdWVyeVwiKTtcbmZ1bmN0aW9uIGhvb2tQcm9jZXNzKGhhbmRsZXIsIGV4aXQgPSBmYWxzZSkge1xuICBwcm9jZXNzLm9uY2UoaGFuZGxlciwgYXN5bmMgKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZW5naW5lIG9mIGVuZ2luZXMpIHtcbiAgICAgIGF3YWl0IGVuZ2luZS5lbWl0RXhpdCgpO1xuICAgICAgZW5naW5lLmtpbGwoaGFuZGxlcik7XG4gICAgfVxuICAgIGVuZ2luZXMuc3BsaWNlKDAsIGVuZ2luZXMubGVuZ3RoKTtcbiAgICBpZiAoc29ja2V0UGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBzb2NrZXRQYXRoIG9mIHNvY2tldFBhdGhzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW1wb3J0X2ZzNC5kZWZhdWx0LnVubGlua1N5bmMoc29ja2V0UGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhpdCAmJiBwcm9jZXNzLmxpc3RlbmVyQ291bnQoaGFuZGxlcikgPT09IDApIHtcbiAgICAgIHByb2Nlc3MuZXhpdCgpO1xuICAgIH1cbiAgfSk7XG59XG5fX25hbWUoaG9va1Byb2Nlc3MsIFwiaG9va1Byb2Nlc3NcIik7XG52YXIgaG9va3NJbml0aWFsaXplZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdEhvb2tzKCkge1xuICBpZiAoIWhvb2tzSW5pdGlhbGl6ZWQpIHtcbiAgICBob29rUHJvY2VzcyhcImJlZm9yZUV4aXRcIik7XG4gICAgaG9va1Byb2Nlc3MoXCJleGl0XCIpO1xuICAgIGhvb2tQcm9jZXNzKFwiU0lHSU5UXCIsIHRydWUpO1xuICAgIGhvb2tQcm9jZXNzKFwiU0lHVVNSMlwiLCB0cnVlKTtcbiAgICBob29rUHJvY2VzcyhcIlNJR1RFUk1cIiwgdHJ1ZSk7XG4gICAgaG9va3NJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbn1cbl9fbmFtZShpbml0SG9va3MsIFwiaW5pdEhvb2tzXCIpO1xuZnVuY3Rpb24gdHJhbnNhY3Rpb25IdHRwRXJyb3JIYW5kbGVyKHJlc3VsdCkge1xuICB0aHJvdyByZXN1bHQuZGF0YTtcbn1cbl9fbmFtZSh0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXIsIFwidHJhbnNhY3Rpb25IdHRwRXJyb3JIYW5kbGVyXCIpO1xuZnVuY3Rpb24gcnVudGltZUhlYWRlcnNUb0h0dHBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjLCBydW50aW1lSGVhZGVyS2V5KSA9PiB7XG4gICAgbGV0IGh0dHBIZWFkZXJLZXkgPSBydW50aW1lSGVhZGVyS2V5O1xuICAgIGlmIChydW50aW1lSGVhZGVyS2V5ID09PSBcInRyYW5zYWN0aW9uSWRcIikge1xuICAgICAgaHR0cEhlYWRlcktleSA9IFwiWC10cmFuc2FjdGlvbi1pZFwiO1xuICAgIH1cbiAgICBhY2NbaHR0cEhlYWRlcktleV0gPSBoZWFkZXJzW3J1bnRpbWVIZWFkZXJLZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbl9fbmFtZShydW50aW1lSGVhZGVyc1RvSHR0cEhlYWRlcnMsIFwicnVudGltZUhlYWRlcnNUb0h0dHBIZWFkZXJzXCIpO1xuZnVuY3Rpb24ga2lsbFByb2Nlc3NBbmRXYWl0KGNoaWxkUHJvY2Vzcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjaGlsZFByb2Nlc3Mub25jZShcImV4aXRcIiwgcmVzb2x2ZSk7XG4gICAgY2hpbGRQcm9jZXNzLmtpbGwoKTtcbiAgfSk7XG59XG5fX25hbWUoa2lsbFByb2Nlc3NBbmRXYWl0LCBcImtpbGxQcm9jZXNzQW5kV2FpdFwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvRGF0YVByb3h5RW5naW5lLnRzXG52YXIgaW1wb3J0X2V2ZW50czIgPSBfX3RvRVNNKHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy9QcmlzbWFDbGllbnRFcnJvci50c1xudmFyIFByaXNtYUNsaWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGluZm8yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gaW5mbzIuY2xpZW50VmVyc2lvbjtcbiAgICB0aGlzLmNhdXNlID0gaW5mbzIuY2F1c2U7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbn07XG5fX25hbWUoUHJpc21hQ2xpZW50RXJyb3IsIFwiUHJpc21hQ2xpZW50RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9EYXRhUHJveHlFcnJvci50c1xudmFyIERhdGFQcm94eUVycm9yID0gY2xhc3MgZXh0ZW5kcyBQcmlzbWFDbGllbnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGluZm8yKSB7XG4gICAgdmFyIF9hMztcbiAgICBzdXBlcihtZXNzYWdlLCBpbmZvMik7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IChfYTMgPSBpbmZvMi5pc1JldHJ5YWJsZSkgIT0gbnVsbCA/IF9hMyA6IHRydWU7XG4gIH1cbn07XG5fX25hbWUoRGF0YVByb3h5RXJyb3IsIFwiRGF0YVByb3h5RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy91dGlscy9zZXRSZXRyeWFibGUudHNcbmZ1bmN0aW9uIHNldFJldHJ5YWJsZShpbmZvMiwgcmV0cnlhYmxlKSB7XG4gIHJldHVybiB7XG4gICAgLi4uaW5mbzIsXG4gICAgaXNSZXRyeWFibGU6IHJldHJ5YWJsZVxuICB9O1xufVxuX19uYW1lKHNldFJldHJ5YWJsZSwgXCJzZXRSZXRyeWFibGVcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9Gb3JjZWRSZXRyeUVycm9yLnRzXG52YXIgRm9yY2VkUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpbmZvMikge1xuICAgIHN1cGVyKFwiVGhpcyByZXF1ZXN0IG11c3QgYmUgcmV0cmllZFwiLCBzZXRSZXRyeWFibGUoaW5mbzIsIHRydWUpKTtcbiAgICB0aGlzLm5hbWUgPSBcIkZvcmNlZFJldHJ5RXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDAxXCI7XG4gIH1cbn07XG5fX25hbWUoRm9yY2VkUmV0cnlFcnJvciwgXCJGb3JjZWRSZXRyeUVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvSW52YWxpZERhdGFzb3VyY2VFcnJvci50c1xudmFyIEludmFsaWREYXRhc291cmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzZXRSZXRyeWFibGUoaW5mbzIsIGZhbHNlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkRGF0YXNvdXJjZUVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwMlwiO1xuICB9XG59O1xuX19uYW1lKEludmFsaWREYXRhc291cmNlRXJyb3IsIFwiSW52YWxpZERhdGFzb3VyY2VFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL05vdEltcGxlbWVudGVkWWV0RXJyb3IudHNcbnZhciBOb3RJbXBsZW1lbnRlZFlldEVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGluZm8yKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc2V0UmV0cnlhYmxlKGluZm8yLCBmYWxzZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiTm90SW1wbGVtZW50ZWRZZXRFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDRcIjtcbiAgfVxufTtcbl9fbmFtZShOb3RJbXBsZW1lbnRlZFlldEVycm9yLCBcIk5vdEltcGxlbWVudGVkWWV0RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9EYXRhUHJveHlBUElFcnJvci50c1xudmFyIERhdGFQcm94eUFQSUVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGluZm8yKSB7XG4gICAgdmFyIF9hMztcbiAgICBzdXBlcihtZXNzYWdlLCBpbmZvMik7XG4gICAgdGhpcy5yZXNwb25zZSA9IGluZm8yLnJlc3BvbnNlO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IChfYTMgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTNbXCJQcmlzbWEtUmVxdWVzdC1JZFwiXTtcbiAgICBpZiAocmVxdWVzdElkKSB7XG4gICAgICBjb25zdCBtZXNzYWdlU3VmZml4ID0gYChUaGUgcmVxdWVzdCBpZCB3YXM6ICR7cmVxdWVzdElkfSlgO1xuICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlICsgXCIgXCIgKyBtZXNzYWdlU3VmZml4O1xuICAgIH1cbiAgfVxufTtcbl9fbmFtZShEYXRhUHJveHlBUElFcnJvciwgXCJEYXRhUHJveHlBUElFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL1NjaGVtYU1pc3NpbmdFcnJvci50c1xudmFyIFNjaGVtYU1pc3NpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5QVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpbmZvMikge1xuICAgIHN1cGVyKFwiU2NoZW1hIG5lZWRzIHRvIGJlIHVwbG9hZGVkXCIsIHNldFJldHJ5YWJsZShpbmZvMiwgdHJ1ZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiU2NoZW1hTWlzc2luZ0Vycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwNVwiO1xuICB9XG59O1xuX19uYW1lKFNjaGVtYU1pc3NpbmdFcnJvciwgXCJTY2hlbWFNaXNzaW5nRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9CYWRSZXF1ZXN0RXJyb3IudHNcbnZhciBCQURfUkVRVUVTVF9ERUZBVUxUX01FU1NBR0UgPSBcIlRoaXMgcmVxdWVzdCBjb3VsZCBub3QgYmUgdW5kZXJzdG9vZCBieSB0aGUgc2VydmVyXCI7XG52YXIgQmFkUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yLCBtZXNzYWdlLCBjb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCBCQURfUkVRVUVTVF9ERUZBVUxUX01FU1NBR0UsIHNldFJldHJ5YWJsZShpbmZvMiwgZmFsc2UpKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJhZFJlcXVlc3RFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDBcIjtcbiAgICBpZiAoY29kZSlcbiAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn07XG5fX25hbWUoQmFkUmVxdWVzdEVycm9yLCBcIkJhZFJlcXVlc3RFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL0dhdGV3YXlUaW1lb3V0RXJyb3IudHNcbnZhciBHYXRld2F5VGltZW91dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yKSB7XG4gICAgc3VwZXIoXCJSZXF1ZXN0IHRpbWVkIG91dFwiLCBzZXRSZXRyeWFibGUoaW5mbzIsIGZhbHNlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJHYXRld2F5VGltZW91dEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwOVwiO1xuICB9XG59O1xuX19uYW1lKEdhdGV3YXlUaW1lb3V0RXJyb3IsIFwiR2F0ZXdheVRpbWVvdXRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL05vdEZvdW5kRXJyb3IudHNcbnZhciBOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yKSB7XG4gICAgc3VwZXIoXCJSZXF1ZXN0ZWQgcmVzb3VyY2UgZG9lcyBub3QgZXhpc3RcIiwgc2V0UmV0cnlhYmxlKGluZm8yLCBmYWxzZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiTm90Rm91bmRFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDNcIjtcbiAgfVxufTtcbl9fbmFtZShOb3RGb3VuZEVycm9yLCBcIk5vdEZvdW5kRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9TZXJ2ZXJFcnJvci50c1xudmFyIFNFUlZFUl9FUlJPUl9ERUZBVUxUX01FU1NBR0UgPSBcIlVua25vd24gc2VydmVyIGVycm9yXCI7XG52YXIgU2VydmVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5mbzIsIG1lc3NhZ2UsIGxvZ3MpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8IFNFUlZFUl9FUlJPUl9ERUZBVUxUX01FU1NBR0UsIHNldFJldHJ5YWJsZShpbmZvMiwgdHJ1ZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VydmVyRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDA2XCI7XG4gICAgdGhpcy5sb2dzID0gbG9ncztcbiAgfVxufTtcbl9fbmFtZShTZXJ2ZXJFcnJvciwgXCJTZXJ2ZXJFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL1VuYXV0aG9yaXplZEVycm9yLnRzXG52YXIgVW5hdXRob3JpemVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5mbzIpIHtcbiAgICBzdXBlcihcIlVuYXV0aG9yaXplZCwgY2hlY2sgeW91ciBjb25uZWN0aW9uIHN0cmluZ1wiLCBzZXRSZXRyeWFibGUoaW5mbzIsIGZhbHNlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJVbmF1dGhvcml6ZWRFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDdcIjtcbiAgfVxufTtcbl9fbmFtZShVbmF1dGhvcml6ZWRFcnJvciwgXCJVbmF1dGhvcml6ZWRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL1VzYWdlRXhjZWVkZWRFcnJvci50c1xudmFyIFVzYWdlRXhjZWVkZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5QVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpbmZvMikge1xuICAgIHN1cGVyKFwiVXNhZ2UgZXhjZWVkZWQsIHJldHJ5IGFnYWluIGxhdGVyXCIsIHNldFJldHJ5YWJsZShpbmZvMiwgdHJ1ZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiVXNhZ2VFeGNlZWRlZEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwOFwiO1xuICB9XG59O1xuX19uYW1lKFVzYWdlRXhjZWVkZWRFcnJvciwgXCJVc2FnZUV4Y2VlZGVkRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy91dGlscy9yZXNwb25zZVRvRXJyb3IudHNcbmFzeW5jIGZ1bmN0aW9uIHJlc3BvbnNlVG9FcnJvcihyZXNwb25zZSwgY2xpZW50VmVyc2lvbjIpIHtcbiAgdmFyIF9hMywgX2IyLCBfYywgX2QsIF9lO1xuICBpZiAocmVzcG9uc2Uub2spXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgaW5mbzIgPSB7IGNsaWVudFZlcnNpb246IGNsaWVudFZlcnNpb24yLCByZXNwb25zZSB9O1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcbiAgICBsZXQga25vd25FcnJvcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGtub3duRXJyb3IgPSAoX2IyID0gKF9hMyA9IGJvZHkgPT0gbnVsbCA/IHZvaWQgMCA6IGJvZHkuRW5naW5lTm90U3RhcnRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5yZWFzb24pID09IG51bGwgPyB2b2lkIDAgOiBfYjIuS25vd25FbmdpbmVTdGFydHVwRXJyb3I7XG4gICAgfSBjYXRjaCAoXykge1xuICAgIH1cbiAgICBpZiAoa25vd25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFcnJvcihpbmZvMiwga25vd25FcnJvci5tc2csIGtub3duRXJyb3IuZXJyb3JfY29kZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFcnJvcihpbmZvMik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zdCBpc1NjaGVtYU1pc3NpbmcgPSAoKF9jID0gYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS5FbmdpbmVOb3RTdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVhc29uKSA9PT0gXCJTY2hlbWFNaXNzaW5nXCI7XG4gICAgICByZXR1cm4gaXNTY2hlbWFNaXNzaW5nID8gbmV3IFNjaGVtYU1pc3NpbmdFcnJvcihpbmZvMikgOiBuZXcgTm90Rm91bmRFcnJvcihpbmZvMik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoaW5mbzIpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICB0aHJvdyBuZXcgVXNhZ2VFeGNlZWRlZEVycm9yKGluZm8yKTtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDQpIHtcbiAgICB0aHJvdyBuZXcgR2F0ZXdheVRpbWVvdXRFcnJvcihpbmZvMik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHtcbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihpbmZvMik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKChfZCA9IGJvZHkgPT0gbnVsbCA/IHZvaWQgMCA6IGJvZHkuRW5naW5lTm90U3RhcnRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnJlYXNvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihpbmZvMiwgYm9keS5FbmdpbmVOb3RTdGFydGVkLnJlYXNvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKChfZSA9IGJvZHkgPT0gbnVsbCA/IHZvaWQgMCA6IGJvZHkuRW5naW5lTm90U3RhcnRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJlYXNvbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMoYm9keS5FbmdpbmVOb3RTdGFydGVkLnJlYXNvbik7XG4gICAgICBpZiAoa2V5czIubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZWFzb24gPSBib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVhc29uW2tleXMyWzBdXTtcbiAgICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGluZm8yLCBrZXlzMlswXSwgY29udGVudC5sb2dzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGluZm8yKTtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXJyb3IoaW5mbzIpO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5fX25hbWUocmVzcG9uc2VUb0Vycm9yLCBcInJlc3BvbnNlVG9FcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvdXRpbHMvYmFja09mZi50c1xudmFyIEJBQ0tPRkZfSU5URVJWQUwgPSA1MDtcbmZ1bmN0aW9uIGJhY2tPZmYobikge1xuICBjb25zdCBiYXNlRGVsYXkgPSBNYXRoLnBvdygyLCBuKSAqIEJBQ0tPRkZfSU5URVJWQUw7XG4gIGNvbnN0IGppdHRlciA9IE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogYmFzZURlbGF5KSAtIE1hdGguY2VpbChiYXNlRGVsYXkgLyAyKTtcbiAgY29uc3QgdG90YWwgPSBiYXNlRGVsYXkgKyBqaXR0ZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSkgPT4gc2V0VGltZW91dCgoKSA9PiBkb25lKHRvdGFsKSwgdG90YWwpKTtcbn1cbl9fbmFtZShiYWNrT2ZmLCBcImJhY2tPZmZcIik7XG5cbi8vIC4uL2VuZ2luZXMvcGFja2FnZS5qc29uXG52YXIgZGV2RGVwZW5kZW5jaWVzID0ge1xuICBcIkBwcmlzbWEvZGVidWdcIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgXCJAcHJpc21hL2VuZ2luZXMtdmVyc2lvblwiOiBcIjQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIixcbiAgXCJAcHJpc21hL2ZldGNoLWVuZ2luZVwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICBcIkBwcmlzbWEvZ2V0LXBsYXRmb3JtXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gIFwiQHN3Yy9jb3JlXCI6IFwiMS4yLjI0MlwiLFxuICBcIkBzd2MvamVzdFwiOiBcIjAuMi4yMlwiLFxuICBcIkB0eXBlcy9qZXN0XCI6IFwiMjguMS43XCIsXG4gIFwiQHR5cGVzL25vZGVcIjogXCIxNi4xMS41NlwiLFxuICBleGVjYTogXCI1LjEuMVwiLFxuICBqZXN0OiBcIjI4LjEuM1wiLFxuICB0eXBlc2NyaXB0OiBcIjQuOC4yXCJcbn07XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9OZXR3b3JrRXJyb3IudHNcbnZhciBSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICBzdXBlcihgQ2Fubm90IGZldGNoIGRhdGEgZnJvbSBzZXJ2aWNlOlxuJHttZXNzYWdlfWAsIHNldFJldHJ5YWJsZShpbmZvMiwgdHJ1ZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiUmVxdWVzdEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAxMFwiO1xuICB9XG59O1xuX19uYW1lKFJlcXVlc3RFcnJvciwgXCJSZXF1ZXN0RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L3V0aWxzL2dldEpTUnVudGltZU5hbWUudHNcbmZ1bmN0aW9uIGdldEpTUnVudGltZU5hbWUoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfVxuICByZXR1cm4gXCJicm93c2VyXCI7XG59XG5fX25hbWUoZ2V0SlNSdW50aW1lTmFtZSwgXCJnZXRKU1J1bnRpbWVOYW1lXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS91dGlscy9yZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICB2YXIgX2EzO1xuICBjb25zdCBjbGllbnRWZXJzaW9uMiA9IG9wdGlvbnMuY2xpZW50VmVyc2lvbjtcbiAgY29uc3QganNSdW50aW1lTmFtZSA9IGdldEpTUnVudGltZU5hbWUoKTtcbiAgdHJ5IHtcbiAgICBpZiAoanNSdW50aW1lTmFtZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgbm9kZUZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IChfYTMgPSBlLm1lc3NhZ2UpICE9IG51bGwgPyBfYTMgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKG1lc3NhZ2UsIHsgY2xpZW50VmVyc2lvbjogY2xpZW50VmVyc2lvbjIgfSk7XG4gIH1cbn1cbl9fbmFtZShyZXF1ZXN0LCBcInJlcXVlc3RcIik7XG5mdW5jdGlvbiBidWlsZEhlYWRlcnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICB9O1xufVxuX19uYW1lKGJ1aWxkSGVhZGVycywgXCJidWlsZEhlYWRlcnNcIik7XG5mdW5jdGlvbiBidWlsZE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKG9wdGlvbnMpXG4gIH07XG59XG5fX25hbWUoYnVpbGRPcHRpb25zLCBcImJ1aWxkT3B0aW9uc1wiKTtcbmZ1bmN0aW9uIGJ1aWxkUmVzcG9uc2UoaW5jb21pbmdEYXRhLCByZXNwb25zZSkge1xuICByZXR1cm4ge1xuICAgIHRleHQ6ICgpID0+IEJ1ZmZlci5jb25jYXQoaW5jb21pbmdEYXRhKS50b1N0cmluZygpLFxuICAgIGpzb246ICgpID0+IEpTT04ucGFyc2UoQnVmZmVyLmNvbmNhdChpbmNvbWluZ0RhdGEpLnRvU3RyaW5nKCkpLFxuICAgIG9rOiByZXNwb25zZS5zdGF0dXNDb2RlID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDw9IDI5OSxcbiAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVyc1xuICB9O1xufVxuX19uYW1lKGJ1aWxkUmVzcG9uc2UsIFwiYnVpbGRSZXNwb25zZVwiKTtcbmFzeW5jIGZ1bmN0aW9uIG5vZGVGZXRjaCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBodHRwcyA9IGluY2x1ZGUoXCJodHRwc1wiKTtcbiAgY29uc3QgaHR0cHNPcHRpb25zID0gYnVpbGRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBpbmNvbWluZ0RhdGEgPSBbXTtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IG5ldyBVUkwodXJsKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgX2EzO1xuICAgIGNvbnN0IHJlcXVlc3QyID0gaHR0cHMucmVxdWVzdCh1cmwsIGh0dHBzT3B0aW9ucywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGhlYWRlcnM6IHsgbG9jYXRpb24gfSB9ID0gcmVzcG9uc2U7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDEgJiYgc3RhdHVzQ29kZSA8PSAzOTkgJiYgbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnN0YXJ0c1dpdGgoXCJodHRwXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJlc29sdmUobm9kZUZldGNoKGAke29yaWdpbn0ke2xvY2F0aW9ufWAsIG9wdGlvbnMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG5vZGVGZXRjaChsb2NhdGlvbiwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiBpbmNvbWluZ0RhdGEucHVzaChjaHVuaykpO1xuICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4gcmVzb2x2ZShidWlsZFJlc3BvbnNlKGluY29taW5nRGF0YSwgcmVzcG9uc2UpKSk7XG4gICAgICByZXNwb25zZS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgfSk7XG4gICAgcmVxdWVzdDIub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgIHJlcXVlc3QyLmVuZCgoX2EzID0gb3B0aW9ucy5ib2R5KSAhPSBudWxsID8gX2EzIDogXCJcIik7XG4gIH0pO1xufVxuX19uYW1lKG5vZGVGZXRjaCwgXCJub2RlRmV0Y2hcIik7XG52YXIgaW5jbHVkZSA9IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6ICgpID0+IHtcbn07XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L3V0aWxzL2dldENsaWVudFZlcnNpb24udHNcbnZhciBzZW12ZXJSZWdleCA9IC9eWzEtOV1bMC05XSpcXC5bMC05XStcXC5bMC05XSskLztcbnZhciBkZWJ1ZzUgPSBzcmNfZGVmYXVsdChcInByaXNtYTpjbGllbnQ6ZGF0YXByb3h5RW5naW5lXCIpO1xuYXN5bmMgZnVuY3Rpb24gX2dldENsaWVudFZlcnNpb24oY29uZmlnMikge1xuICB2YXIgX2EzLCBfYjIsIF9jO1xuICBjb25zdCBlbmdpbmVWZXJzaW9uID0gZGV2RGVwZW5kZW5jaWVzW1wiQHByaXNtYS9lbmdpbmVzLXZlcnNpb25cIl07XG4gIGNvbnN0IGNsaWVudFZlcnNpb24yID0gKF9hMyA9IGNvbmZpZzIuY2xpZW50VmVyc2lvbikgIT0gbnVsbCA/IF9hMyA6IFwidW5rbm93blwiO1xuICBpZiAocHJvY2Vzcy5lbnYuUFJJU01BX0NMSUVOVF9EQVRBX1BST1hZX0NMSUVOVF9WRVJTSU9OKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfREFUQV9QUk9YWV9DTElFTlRfVkVSU0lPTjtcbiAgfVxuICBjb25zdCBbdmVyc2lvbiwgc3VmZml4XSA9IChfYjIgPSBjbGllbnRWZXJzaW9uMiA9PSBudWxsID8gdm9pZCAwIDogY2xpZW50VmVyc2lvbjIuc3BsaXQoXCItXCIpKSAhPSBudWxsID8gX2IyIDogW107XG4gIGlmIChzdWZmaXggPT09IHZvaWQgMCAmJiBzZW12ZXJSZWdleC50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbiAgaWYgKHN1ZmZpeCAhPT0gdm9pZCAwIHx8IGNsaWVudFZlcnNpb24yID09PSBcIjAuMC4wXCIpIHtcbiAgICBjb25zdCBbdmVyc2lvbjJdID0gKF9jID0gZW5naW5lVmVyc2lvbi5zcGxpdChcIi1cIikpICE9IG51bGwgPyBfYyA6IFtdO1xuICAgIGNvbnN0IFttYWpvcjIsIG1pbm9yLCBwYXRjaF0gPSB2ZXJzaW9uMi5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgcGtnVVJMID0gcHJpc21hUGtnVVJMKGA8PSR7bWFqb3IyfS4ke21pbm9yfS4ke3BhdGNofWApO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QocGtnVVJMLCB7IGNsaWVudFZlcnNpb246IGNsaWVudFZlcnNpb24yIH0pO1xuICAgIGNvbnN0IGJvZHlBc1RleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgIGRlYnVnNShcImxlbmd0aCBvZiBib2R5IGZldGNoZWQgZnJvbSB1bnBrZy5jb21cIiwgYm9keUFzVGV4dC5sZW5ndGgpO1xuICAgIGxldCBib2R5QXNKc29uO1xuICAgIHRyeSB7XG4gICAgICBib2R5QXNKc29uID0gSlNPTi5wYXJzZShib2R5QXNUZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSlNPTi5wYXJzZSBlcnJvcjogYm9keSBmZXRjaGVkIGZyb20gdW5wa2cuY29tOiBcIiwgYm9keUFzVGV4dCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gYm9keUFzSnNvbltcInZlcnNpb25cIl07XG4gIH1cbiAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkWWV0RXJyb3IoXCJPbmx5IGBtYWpvci5taW5vci5wYXRjaGAgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZCBieSBQcmlzbWEgRGF0YSBQcm94eS5cIiwge1xuICAgIGNsaWVudFZlcnNpb246IGNsaWVudFZlcnNpb24yXG4gIH0pO1xufVxuX19uYW1lKF9nZXRDbGllbnRWZXJzaW9uLCBcIl9nZXRDbGllbnRWZXJzaW9uXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50VmVyc2lvbihjb25maWcyKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBfZ2V0Q2xpZW50VmVyc2lvbihjb25maWcyKTtcbiAgZGVidWc1KFwidmVyc2lvblwiLCB2ZXJzaW9uKTtcbiAgcmV0dXJuIHZlcnNpb247XG59XG5fX25hbWUoZ2V0Q2xpZW50VmVyc2lvbiwgXCJnZXRDbGllbnRWZXJzaW9uXCIpO1xuZnVuY3Rpb24gcHJpc21hUGtnVVJMKHZlcnNpb24pIHtcbiAgcmV0dXJuIGVuY29kZVVSSShgaHR0cHM6Ly91bnBrZy5jb20vcHJpc21hQCR7dmVyc2lvbn0vcGFja2FnZS5qc29uYCk7XG59XG5fX25hbWUocHJpc21hUGtnVVJMLCBcInByaXNtYVBrZ1VSTFwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvRGF0YVByb3h5RW5naW5lLnRzXG52YXIgTUFYX1JFVFJJRVMgPSAxMDtcbnZhciBQMiA9IFByb21pc2UucmVzb2x2ZSgpO1xudmFyIGRlYnVnNiA9IHNyY19kZWZhdWx0KFwicHJpc21hOmNsaWVudDpkYXRhcHJveHlFbmdpbmVcIik7XG52YXIgRGF0YVByb3h5RW5naW5lID0gY2xhc3MgZXh0ZW5kcyBFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcyKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZzI7XG4gICAgdGhpcy5lbnYgPSB7IC4uLnRoaXMuY29uZmlnLmVudiwgLi4ucHJvY2Vzcy5lbnYgfTtcbiAgICB0aGlzLmlubGluZVNjaGVtYSA9IChfYTMgPSBjb25maWcyLmlubGluZVNjaGVtYSkgIT0gbnVsbCA/IF9hMyA6IFwiXCI7XG4gICAgdGhpcy5pbmxpbmVEYXRhc291cmNlcyA9IChfYjIgPSBjb25maWcyLmlubGluZURhdGFzb3VyY2VzKSAhPSBudWxsID8gX2IyIDoge307XG4gICAgdGhpcy5pbmxpbmVTY2hlbWFIYXNoID0gKF9jID0gY29uZmlnMi5pbmxpbmVTY2hlbWFIYXNoKSAhPSBudWxsID8gX2MgOiBcIlwiO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IChfZCA9IGNvbmZpZzIuY2xpZW50VmVyc2lvbikgIT0gbnVsbCA/IF9kIDogXCJ1bmtub3duXCI7XG4gICAgdGhpcy5sb2dFbWl0dGVyID0gbmV3IGltcG9ydF9ldmVudHMyLmRlZmF1bHQoKTtcbiAgICB0aGlzLmxvZ0VtaXR0ZXIub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgfSk7XG4gICAgY29uc3QgW2hvc3QsIGFwaUtleV0gPSB0aGlzLmV4dHJhY3RIb3N0QW5kQXBpS2V5KCk7XG4gICAgdGhpcy5yZW1vdGVDbGllbnRWZXJzaW9uID0gUDIudGhlbigoKSA9PiBnZXRDbGllbnRWZXJzaW9uKHRoaXMuY29uZmlnKSk7XG4gICAgdGhpcy5oZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXBpS2V5fWAgfTtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIGRlYnVnNihcImhvc3RcIiwgdGhpcy5ob3N0KTtcbiAgfVxuICB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgfVxuICBhc3luYyBzdG9wKCkge1xuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChldmVudCA9PT0gXCJiZWZvcmVFeGl0XCIpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZFlldEVycm9yKFwiYmVmb3JlRXhpdCBldmVudCBpcyBub3QgeWV0IHN1cHBvcnRlZFwiLCB7XG4gICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cmwocykge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMuaG9zdH0vJHthd2FpdCB0aGlzLnJlbW90ZUNsaWVudFZlcnNpb259LyR7dGhpcy5pbmxpbmVTY2hlbWFIYXNofS8ke3N9YDtcbiAgfVxuICBhc3luYyBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhc291cmNlczogW1xuICAgICAgICB7XG4gICAgICAgICAgYWN0aXZlUHJvdmlkZXI6IHRoaXMuY29uZmlnLmFjdGl2ZVByb3ZpZGVyXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBnZXREbW1mKCkge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZFlldEVycm9yKFwiZ2V0RG1tZiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiLCB7XG4gICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGxvYWRTY2hlbWEoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGF3YWl0IHRoaXMudXJsKFwic2NoZW1hXCIpLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmlubGluZVNjaGVtYSxcbiAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGRlYnVnNihcInNjaGVtYSByZXNwb25zZSBzdGF0dXNcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gYXdhaXQgcmVzcG9uc2VUb0Vycm9yKHJlc3BvbnNlLCB0aGlzLmNsaWVudFZlcnNpb24pO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwid2FyblwiLCB7IG1lc3NhZ2U6IGBFcnJvciB3aGlsZSB1cGxvYWRpbmcgc2NoZW1hOiAke2Vyci5tZXNzYWdlfWAgfSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwiaW5mb1wiLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBTY2hlbWEgKHJlKXVwbG9hZGVkIChoYXNoOiAke3RoaXMuaW5saW5lU2NoZW1hSGFzaH0pYFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlcXVlc3QocXVlcnkyLCBoZWFkZXJzLCBhdHRlbXB0ID0gMCkge1xuICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwicXVlcnlcIiwgeyBxdWVyeTogcXVlcnkyIH0pO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RJbnRlcm5hbCh7IHF1ZXJ5OiBxdWVyeTIsIHZhcmlhYmxlczoge30gfSwgaGVhZGVycywgYXR0ZW1wdCk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdEJhdGNoKHF1ZXJpZXMsIGhlYWRlcnMsIGlzVHJhbnNhY3Rpb24gPSBmYWxzZSwgYXR0ZW1wdCA9IDApIHtcbiAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcInF1ZXJ5XCIsIHtcbiAgICAgIHF1ZXJ5OiBgQmF0Y2gke2lzVHJhbnNhY3Rpb24gPyBcIiBpbiB0cmFuc2FjdGlvblwiIDogXCJcIn0gKCR7cXVlcmllcy5sZW5ndGh9KTpcbiR7cXVlcmllcy5qb2luKFwiXFxuXCIpfWBcbiAgICB9KTtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgYmF0Y2g6IHF1ZXJpZXMubWFwKChxdWVyeTIpID0+ICh7IHF1ZXJ5OiBxdWVyeTIsIHZhcmlhYmxlczoge30gfSkpLFxuICAgICAgdHJhbnNhY3Rpb246IGlzVHJhbnNhY3Rpb25cbiAgICB9O1xuICAgIGNvbnN0IHsgYmF0Y2hSZXN1bHQgfSA9IGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKGJvZHksIGhlYWRlcnMsIGF0dGVtcHQpO1xuICAgIHJldHVybiBiYXRjaFJlc3VsdDtcbiAgfVxuICBhc3luYyByZXF1ZXN0SW50ZXJuYWwoYm9keSwgaGVhZGVycywgYXR0ZW1wdCkge1xuICAgIHZhciBfYTM7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwiaW5mb1wiLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBDYWxsaW5nICR7YXdhaXQgdGhpcy51cmwoXCJncmFwaHFsXCIpfSAobj0ke2F0dGVtcHR9KWBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGF3YWl0IHRoaXMudXJsKFwiZ3JhcGhxbFwiKSwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMsIC4uLnRoaXMuaGVhZGVycyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgZGVidWc2KFwiZ3JhcGhxbCByZXNwb25zZSBzdGF0dXNcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGUgPSBhd2FpdCByZXNwb25zZVRvRXJyb3IocmVzcG9uc2UsIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNjaGVtYU1pc3NpbmdFcnJvcikge1xuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZFNjaGVtYSgpO1xuICAgICAgICB0aHJvdyBuZXcgRm9yY2VkUmV0cnlFcnJvcih7XG4gICAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uLFxuICAgICAgICAgIGNhdXNlOiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGU7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICAgIGlmIChkYXRhLmVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBwcmlzbWFHcmFwaFFMVG9KU0Vycm9yKGRhdGEuZXJyb3JzWzBdLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJlcnJvclwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBFcnJvciB3aGlsZSBxdWVyeWluZzogJHsoX2EzID0gZS5tZXNzYWdlKSAhPSBudWxsID8gX2EzIDogXCIodW5rbm93bilcIn1gXG4gICAgICB9KTtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBEYXRhUHJveHlFcnJvcikpXG4gICAgICAgIHRocm93IGU7XG4gICAgICBpZiAoIWUuaXNSZXRyeWFibGUpXG4gICAgICAgIHRocm93IGU7XG4gICAgICBpZiAoYXR0ZW1wdCA+PSBNQVhfUkVUUklFUykge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZvcmNlZFJldHJ5RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlLmNhdXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwid2FyblwiLCB7IG1lc3NhZ2U6IFwiVGhpcyByZXF1ZXN0IGNhbiBiZSByZXRyaWVkXCIgfSk7XG4gICAgICBjb25zdCBkZWxheSA9IGF3YWl0IGJhY2tPZmYoYXR0ZW1wdCk7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcIndhcm5cIiwgeyBtZXNzYWdlOiBgUmV0cnlpbmcgYWZ0ZXIgJHtkZWxheX1tc2AgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SW50ZXJuYWwoYm9keSwgaGVhZGVycywgYXR0ZW1wdCArIDEpO1xuICAgIH1cbiAgfVxuICB0cmFuc2FjdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRZZXRFcnJvcihcIkludGVyYWN0aXZlIHRyYW5zYWN0aW9ucyBhcmUgbm90IHlldCBzdXBwb3J0ZWRcIiwge1xuICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgfSk7XG4gIH1cbiAgZXh0cmFjdEhvc3RBbmRBcGlLZXkoKSB7XG4gICAgY29uc3QgZGF0YXNvdXJjZXMgPSB0aGlzLm1lcmdlT3ZlcnJpZGRlbkRhdGFzb3VyY2VzKCk7XG4gICAgY29uc3QgbWFpbkRhdGFzb3VyY2VOYW1lID0gT2JqZWN0LmtleXMoZGF0YXNvdXJjZXMpWzBdO1xuICAgIGNvbnN0IG1haW5EYXRhc291cmNlID0gZGF0YXNvdXJjZXNbbWFpbkRhdGFzb3VyY2VOYW1lXTtcbiAgICBjb25zdCBkYXRhUHJveHlVUkwgPSB0aGlzLnJlc29sdmVEYXRhc291cmNlVVJMKG1haW5EYXRhc291cmNlTmFtZSwgbWFpbkRhdGFzb3VyY2UpO1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoZGF0YVByb3h5VVJMKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFzb3VyY2VFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBVUkwgb2YgdGhlIGRhdGFzb3VyY2VcIiwge1xuICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0LCBzZWFyY2hQYXJhbXMgfSA9IHVybDtcbiAgICBpZiAocHJvdG9jb2wgIT09IFwicHJpc21hOlwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFzb3VyY2VFcnJvcihcIkRhdGFzb3VyY2UgVVJMIG11c3QgdXNlIHByaXNtYTovLyBwcm90b2NvbCB3aGVuIC0tZGF0YS1wcm94eSBpcyB1c2VkXCIsIHtcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXBpS2V5ID0gc2VhcmNoUGFyYW1zLmdldChcImFwaV9rZXlcIik7XG4gICAgaWYgKGFwaUtleSA9PT0gbnVsbCB8fCBhcGlLZXkubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhc291cmNlRXJyb3IoXCJObyB2YWxpZCBBUEkga2V5IGZvdW5kIGluIHRoZSBkYXRhc291cmNlIFVSTFwiLCB7XG4gICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaG9zdCwgYXBpS2V5XTtcbiAgfVxuICBtZXJnZU92ZXJyaWRkZW5EYXRhc291cmNlcygpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YXNvdXJjZXMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5saW5lRGF0YXNvdXJjZXM7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsRGF0YXNvdXJjZXMgPSB7IC4uLnRoaXMuaW5saW5lRGF0YXNvdXJjZXMgfTtcbiAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIG9mIHRoaXMuY29uZmlnLmRhdGFzb3VyY2VzKSB7XG4gICAgICBpZiAoIXRoaXMuaW5saW5lRGF0YXNvdXJjZXNbb3ZlcnJpZGUubmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFzb3VyY2U6ICR7b3ZlcnJpZGUubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsRGF0YXNvdXJjZXNbb3ZlcnJpZGUubmFtZV0gPSB7XG4gICAgICAgIHVybDoge1xuICAgICAgICAgIGZyb21FbnZWYXI6IG51bGwsXG4gICAgICAgICAgdmFsdWU6IG92ZXJyaWRlLnVybFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxEYXRhc291cmNlcztcbiAgfVxuICByZXNvbHZlRGF0YXNvdXJjZVVSTChuYW1lLCBkYXRhc291cmNlKSB7XG4gICAgaWYgKGRhdGFzb3VyY2UudXJsLnZhbHVlKSB7XG4gICAgICByZXR1cm4gZGF0YXNvdXJjZS51cmwudmFsdWU7XG4gICAgfVxuICAgIGlmIChkYXRhc291cmNlLnVybC5mcm9tRW52VmFyKSB7XG4gICAgICBjb25zdCBlbnZWYXIgPSBkYXRhc291cmNlLnVybC5mcm9tRW52VmFyO1xuICAgICAgY29uc3QgbG9hZGVkRW52VVJMID0gdGhpcy5lbnZbZW52VmFyXTtcbiAgICAgIGlmIChsb2FkZWRFbnZVUkwgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFzb3VyY2VFcnJvcihcbiAgICAgICAgICBgRGF0YXNvdXJjZSBcIiR7bmFtZX1cIiByZWZlcmVuY2VzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIFwiJHtlbnZWYXJ9XCIgdGhhdCBpcyBub3Qgc2V0YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9hZGVkRW52VVJMO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFzb3VyY2VFcnJvcihcbiAgICAgIGBEYXRhc291cmNlIFwiJHtuYW1lfVwiIHNwZWNpZmljYXRpb24gaXMgaW52YWxpZDogYm90aCB2YWx1ZSBhbmQgZnJvbUVudlZhciBhcmUgbnVsbGAsXG4gICAgICB7XG4gICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgbWV0cmljcyhvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkWWV0RXJyb3IoXCJNZXRyaWMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBEYXRhIFByb3h5XCIsIHtcbiAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgIH0pO1xuICB9XG59O1xuX19uYW1lKERhdGFQcm94eUVuZ2luZSwgXCJEYXRhUHJveHlFbmdpbmVcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9saWJyYXJ5L0xpYnJhcnlFbmdpbmUudHNcbnZhciBpbXBvcnRfY2hhbGs1ID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciBpbXBvcnRfZXZlbnRzMyA9IF9fdG9FU00ocmVxdWlyZShcImV2ZW50c1wiKSk7XG52YXIgaW1wb3J0X2ZzNiA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2xpYnJhcnkvRGVmYXVsdExpYnJhcnlMb2FkZXIudHNcbnZhciBpbXBvcnRfY2hhbGs0ID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciBpbXBvcnRfZnM1ID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xudmFyIGltcG9ydF9wYXRoMyA9IF9fdG9FU00ocmVxdWlyZShcInBhdGhcIikpO1xudmFyIGRlYnVnNyA9IHNyY19kZWZhdWx0KFwicHJpc21hOmNsaWVudDpsaWJyYXJ5RW5naW5lOmxvYWRlclwiKTtcbnZhciBEZWZhdWx0TGlicmFyeUxvYWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnMikge1xuICAgIHRoaXMubGliUXVlcnlFbmdpbmVQYXRoID0gbnVsbDtcbiAgICB0aGlzLnBsYXRmb3JtID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZzI7XG4gIH1cbiAgYXN5bmMgbG9hZExpYnJhcnkoKSB7XG4gICAgaWYgKCF0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCkge1xuICAgICAgdGhpcy5saWJRdWVyeUVuZ2luZVBhdGggPSBhd2FpdCB0aGlzLmdldExpYlF1ZXJ5RW5naW5lUGF0aCgpO1xuICAgIH1cbiAgICBkZWJ1ZzcoYGxvYWRFbmdpbmUgdXNpbmcgJHt0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aH1gKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGV2YWwoXCJyZXF1aXJlXCIpKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaW1wb3J0X2ZzNS5kZWZhdWx0LmV4aXN0c1N5bmModGhpcy5saWJRdWVyeUVuZ2luZVBhdGgpKSB7XG4gICAgICAgIGlmICh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aC5lbmRzV2l0aChcIi5ub2RlXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgICAgICBgVW5hYmxlIHRvIGxvYWQgTm9kZS1BUEkgTGlicmFyeSBmcm9tICR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LmRpbSh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCl9LCBMaWJyYXJ5IG1heSBiZSBjb3JydXB0YCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIE5vZGUtQVBJIExpYnJhcnkgYnV0IHJlY2VpdmVkICR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LmRpbSh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCl9YCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIGxvYWQgTm9kZS1BUEkgTGlicmFyeSBmcm9tICR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LmRpbSh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCl9LCBJdCBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgICAgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXRMaWJRdWVyeUVuZ2luZVBhdGgoKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gICAgY29uc3QgbGliUGF0aCA9IChfYTMgPSBwcm9jZXNzLmVudi5QUklTTUFfUVVFUllfRU5HSU5FX0xJQlJBUlkpICE9IG51bGwgPyBfYTMgOiB0aGlzLmNvbmZpZy5wcmlzbWFQYXRoO1xuICAgIGlmIChsaWJQYXRoICYmIGltcG9ydF9mczUuZGVmYXVsdC5leGlzdHNTeW5jKGxpYlBhdGgpICYmIGxpYlBhdGguZW5kc1dpdGgoXCIubm9kZVwiKSkge1xuICAgICAgcmV0dXJuIGxpYlBhdGg7XG4gICAgfVxuICAgIHRoaXMucGxhdGZvcm0gPSAoX2IyID0gdGhpcy5wbGF0Zm9ybSkgIT0gbnVsbCA/IF9iMiA6IGF3YWl0IGdldFBsYXRmb3JtKCk7XG4gICAgY29uc3QgeyBlbmdpbmVQYXRoOiBlbmdpbmVQYXRoMiwgc2VhcmNoZWRMb2NhdGlvbnM6IHNlYXJjaGVkTG9jYXRpb25zMiB9ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW5naW5lUGF0aCgpO1xuICAgIGlmICghaW1wb3J0X2ZzNS5kZWZhdWx0LmV4aXN0c1N5bmMoZW5naW5lUGF0aDIpKSB7XG4gICAgICBjb25zdCBpbmNvcnJlY3RQaW5uZWRQbGF0Zm9ybUVycm9yU3RyID0gdGhpcy5wbGF0Zm9ybSA/IGBcbllvdSBpbmNvcnJlY3RseSBwaW5uZWQgaXQgdG8gJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQucmVkQnJpZ2h0LmJvbGQoYCR7dGhpcy5wbGF0Zm9ybX1gKX1cbmAgOiBcIlwiO1xuICAgICAgbGV0IGVycm9yVGV4dCA9IGBRdWVyeSBlbmdpbmUgbGlicmFyeSBmb3IgY3VycmVudCBwbGF0Zm9ybSBcIiR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LmJvbGQoXG4gICAgICAgIHRoaXMucGxhdGZvcm1cbiAgICAgICl9XCIgY291bGQgbm90IGJlIGZvdW5kLiR7aW5jb3JyZWN0UGlubmVkUGxhdGZvcm1FcnJvclN0cn1cblRoaXMgcHJvYmFibHkgaGFwcGVucywgYmVjYXVzZSB5b3UgYnVpbHQgUHJpc21hIENsaWVudCBvbiBhIGRpZmZlcmVudCBwbGF0Zm9ybS5cbihQcmlzbWEgQ2xpZW50IGxvb2tlZCBpbiBcIiR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LnVuZGVybGluZShlbmdpbmVQYXRoMil9XCIpXG5cblNlYXJjaGVkIExvY2F0aW9uczpcblxuJHtzZWFyY2hlZExvY2F0aW9uczIubWFwKChmKSA9PiB7XG4gICAgICAgIGxldCBtc2cgPSBgICAke2Z9YDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHID09PSBcIm5vZGUtZW5naW5lLXNlYXJjaC1sb2NhdGlvbnNcIiAmJiBpbXBvcnRfZnM1LmRlZmF1bHQuZXhpc3RzU3luYyhmKSkge1xuICAgICAgICAgIGNvbnN0IGRpciA9IGltcG9ydF9mczUuZGVmYXVsdC5yZWFkZGlyU3luYyhmKTtcbiAgICAgICAgICBtc2cgKz0gZGlyLm1hcCgoZCkgPT4gYCAgICAke2R9YCkuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgfSkuam9pbihcIlxcblwiICsgKHByb2Nlc3MuZW52LkRFQlVHID09PSBcIm5vZGUtZW5naW5lLXNlYXJjaC1sb2NhdGlvbnNcIiA/IFwiXFxuXCIgOiBcIlwiKSl9XG5gO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gKF9jID0gdGhpcy5wbGF0Zm9ybSkgIT0gbnVsbCA/IF9jIDogYXdhaXQgZ2V0UGxhdGZvcm0oKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlID09PSB0aGlzLnBsYXRmb3JtKSB8fCB0aGlzLmNvbmZpZy5nZW5lcmF0b3IuYmluYXJ5VGFyZ2V0cy5maW5kKChvYmplY3QpID0+IG9iamVjdC52YWx1ZSA9PT0gXCJuYXRpdmVcIikpIHtcbiAgICAgICAgICBlcnJvclRleHQgKz0gYFxuWW91IGFscmVhZHkgYWRkZWQgdGhlIHBsYXRmb3JtJHt0aGlzLmNvbmZpZy5nZW5lcmF0b3IuYmluYXJ5VGFyZ2V0cy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSAke3RoaXMuY29uZmlnLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLm1hcCgodCkgPT4gYFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuYm9sZCh0LnZhbHVlKX1cImApLmpvaW4oXCIsIFwiKX0gdG8gdGhlIFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQudW5kZXJsaW5lKFwiZ2VuZXJhdG9yXCIpfVwiIGJsb2NrXG5pbiB0aGUgXCJzY2hlbWEucHJpc21hXCIgZmlsZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvcixcbmJ1dCBzb21ldGhpbmcgd2VudCB3cm9uZy4gVGhhdCdzIHN1Ym9wdGltYWwuXG5cblBsZWFzZSBjcmVhdGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzL25ld2A7XG4gICAgICAgICAgZXJyb3JUZXh0ICs9IGBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yVGV4dCArPSBgXG5cblRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgYWRkIHRoZSBwbGF0Zm9ybSBcIiR7dGhpcy5wbGF0Zm9ybX1cIiB0byB0aGUgXCIke2ltcG9ydF9jaGFsazQuZGVmYXVsdC51bmRlcmxpbmUoXG4gICAgICAgICAgICBcImJpbmFyeVRhcmdldHNcIlxuICAgICAgICAgICl9XCIgYXR0cmlidXRlIGluIHRoZSBcIiR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LnVuZGVybGluZShcImdlbmVyYXRvclwiKX1cIiBibG9jayBpbiB0aGUgXCJzY2hlbWEucHJpc21hXCIgZmlsZTpcbiR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LmdyZWVuQnJpZ2h0KHRoaXMuZ2V0Rml4ZWRHZW5lcmF0b3IoKSl9XG5cblRoZW4gcnVuIFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJwcmlzbWEgZ2VuZXJhdGVcIil9XCIgZm9yIHlvdXIgY2hhbmdlcyB0byB0YWtlIGVmZmVjdC5cblJlYWQgbW9yZSBhYm91dCBkZXBsb3lpbmcgUHJpc21hIENsaWVudDogaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvcmA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yVGV4dCArPSBgXG5cblJlYWQgbW9yZSBhYm91dCBkZXBsb3lpbmcgUHJpc21hIENsaWVudDogaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvclxuYDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGVycm9yVGV4dCwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7XG4gICAgfVxuICAgIHRoaXMucGxhdGZvcm0gPSAoX2QgPSB0aGlzLnBsYXRmb3JtKSAhPSBudWxsID8gX2QgOiBhd2FpdCBnZXRQbGF0Zm9ybSgpO1xuICAgIHJldHVybiBlbmdpbmVQYXRoMjtcbiAgfVxuICBhc3luYyByZXNvbHZlRW5naW5lUGF0aCgpIHtcbiAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgICBjb25zdCBzZWFyY2hlZExvY2F0aW9ucyA9IFtdO1xuICAgIGxldCBlbmdpbmVQYXRoO1xuICAgIGlmICh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCkge1xuICAgICAgcmV0dXJuIHsgZW5naW5lUGF0aDogdGhpcy5saWJRdWVyeUVuZ2luZVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgfVxuICAgIHRoaXMucGxhdGZvcm0gPSAoX2EzID0gdGhpcy5wbGF0Zm9ybSkgIT0gbnVsbCA/IF9hMyA6IGF3YWl0IGdldFBsYXRmb3JtKCk7XG4gICAgaWYgKF9fZmlsZW5hbWUuaW5jbHVkZXMoXCJEZWZhdWx0TGlicmFyeUxvYWRlclwiKSkge1xuICAgICAgZW5naW5lUGF0aCA9IGltcG9ydF9wYXRoMy5kZWZhdWx0LmpvaW4oZ2V0RW5naW5lc1BhdGgoKSwgZ2V0Tm9kZUFQSU5hbWUodGhpcy5wbGF0Zm9ybSwgXCJmc1wiKSk7XG4gICAgICByZXR1cm4geyBlbmdpbmVQYXRoLCBzZWFyY2hlZExvY2F0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCBkaXJuYW1lID0gZXZhbChcIl9fZGlybmFtZVwiKTtcbiAgICBjb25zdCBzZWFyY2hMb2NhdGlvbnMgPSBbXG4gICAgICBpbXBvcnRfcGF0aDMuZGVmYXVsdC5yZXNvbHZlKGRpcm5hbWUsIFwiLi4vLi4vLi4vLnByaXNtYS9jbGllbnRcIiksXG4gICAgICAoX2QgPSAoX2MgPSAoX2IyID0gdGhpcy5jb25maWcuZ2VuZXJhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnZhbHVlKSAhPSBudWxsID8gX2QgOiBkaXJuYW1lLFxuICAgICAgaW1wb3J0X3BhdGgzLmRlZmF1bHQucmVzb2x2ZShkaXJuYW1lLCBcIi4uXCIpLFxuICAgICAgaW1wb3J0X3BhdGgzLmRlZmF1bHQuZGlybmFtZSh0aGlzLmNvbmZpZy5kYXRhbW9kZWxQYXRoKSxcbiAgICAgIHRoaXMuY29uZmlnLmN3ZCxcbiAgICAgIFwiL3RtcC9wcmlzbWEtZW5naW5lc1wiXG4gICAgXTtcbiAgICBpZiAodGhpcy5jb25maWcuZGlybmFtZSkge1xuICAgICAgc2VhcmNoTG9jYXRpb25zLnB1c2godGhpcy5jb25maWcuZGlybmFtZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbG9jYXRpb24gb2Ygc2VhcmNoTG9jYXRpb25zKSB7XG4gICAgICBzZWFyY2hlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIGRlYnVnNyhgU2VhcmNoaW5nIGZvciBRdWVyeSBFbmdpbmUgTGlicmFyeSBpbiAke2xvY2F0aW9ufWApO1xuICAgICAgZW5naW5lUGF0aCA9IGltcG9ydF9wYXRoMy5kZWZhdWx0LmpvaW4obG9jYXRpb24sIGdldE5vZGVBUElOYW1lKHRoaXMucGxhdGZvcm0sIFwiZnNcIikpO1xuICAgICAgaWYgKGltcG9ydF9mczUuZGVmYXVsdC5leGlzdHNTeW5jKGVuZ2luZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiB7IGVuZ2luZVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgICB9XG4gICAgfVxuICAgIGVuZ2luZVBhdGggPSBpbXBvcnRfcGF0aDMuZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgZ2V0Tm9kZUFQSU5hbWUodGhpcy5wbGF0Zm9ybSwgXCJmc1wiKSk7XG4gICAgcmV0dXJuIHsgZW5naW5lUGF0aDogZW5naW5lUGF0aCAhPSBudWxsID8gZW5naW5lUGF0aCA6IFwiXCIsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gIH1cbiAgZ2V0Rml4ZWRHZW5lcmF0b3IoKSB7XG4gICAgY29uc3QgZml4ZWRHZW5lcmF0b3IgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZy5nZW5lcmF0b3IsXG4gICAgICBiaW5hcnlUYXJnZXRzOiBmaXhCaW5hcnlUYXJnZXRzKHRoaXMuY29uZmlnLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLCB0aGlzLnBsYXRmb3JtKVxuICAgIH07XG4gICAgcmV0dXJuIHByaW50R2VuZXJhdG9yQ29uZmlnKGZpeGVkR2VuZXJhdG9yKTtcbiAgfVxufTtcbl9fbmFtZShEZWZhdWx0TGlicmFyeUxvYWRlciwgXCJEZWZhdWx0TGlicmFyeUxvYWRlclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2xpYnJhcnkvRXhpdEhvb2tzLnRzXG52YXIgZGVidWc4ID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50OmxpYnJhcnlFbmdpbmU6ZXhpdEhvb2tzXCIpO1xudmFyIEV4aXRIb29rcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uZXh0T3duZXJJZCA9IDE7XG4gICAgdGhpcy5vd25lclRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLmlkVG9MaXN0ZW5lck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5hcmVIb29rc0luc3RhbGxlZCA9IGZhbHNlO1xuICB9XG4gIGluc3RhbGwoKSB7XG4gICAgaWYgKHRoaXMuYXJlSG9va3NJbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnN0YWxsSG9vayhcImJlZm9yZUV4aXRcIik7XG4gICAgdGhpcy5pbnN0YWxsSG9vayhcImV4aXRcIik7XG4gICAgdGhpcy5pbnN0YWxsSG9vayhcIlNJR0lOVFwiLCB0cnVlKTtcbiAgICB0aGlzLmluc3RhbGxIb29rKFwiU0lHVVNSMlwiLCB0cnVlKTtcbiAgICB0aGlzLmluc3RhbGxIb29rKFwiU0lHVEVSTVwiLCB0cnVlKTtcbiAgICB0aGlzLmFyZUhvb2tzSW5zdGFsbGVkID0gdHJ1ZTtcbiAgfVxuICBzZXRMaXN0ZW5lcihvd25lciwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxldCBpZCA9IHRoaXMub3duZXJUb0lkTWFwLmdldChvd25lcik7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlkID0gdGhpcy5uZXh0T3duZXJJZCsrO1xuICAgICAgICB0aGlzLm93bmVyVG9JZE1hcC5zZXQob3duZXIsIGlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWRUb0xpc3RlbmVyTWFwLnNldChpZCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMub3duZXJUb0lkTWFwLmdldChvd25lcik7XG4gICAgICBpZiAoaWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLm93bmVyVG9JZE1hcC5kZWxldGUob3duZXIpO1xuICAgICAgICB0aGlzLmlkVG9MaXN0ZW5lck1hcC5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRMaXN0ZW5lcihvd25lcikge1xuICAgIGNvbnN0IGlkID0gdGhpcy5vd25lclRvSWRNYXAuZ2V0KG93bmVyKTtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWRUb0xpc3RlbmVyTWFwLmdldChpZCk7XG4gIH1cbiAgaW5zdGFsbEhvb2soZXZlbnQsIHNob3VsZEV4aXQgPSBmYWxzZSkge1xuICAgIHByb2Nlc3Mub25jZShldmVudCwgYXN5bmMgKGNvZGUpID0+IHtcbiAgICAgIGRlYnVnOChgZXhpdCBldmVudCByZWNlaXZlZDogJHtldmVudH1gKTtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5pZFRvTGlzdGVuZXJNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgYXdhaXQgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWRUb0xpc3RlbmVyTWFwLmNsZWFyKCk7XG4gICAgICBpZiAoc2hvdWxkRXhpdCAmJiBwcm9jZXNzLmxpc3RlbmVyQ291bnQoZXZlbnQpID09PSAwKSB7XG4gICAgICAgIHByb2Nlc3MuZXhpdChjb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbl9fbmFtZShFeGl0SG9va3MsIFwiRXhpdEhvb2tzXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvbGlicmFyeS9MaWJyYXJ5RW5naW5lLnRzXG52YXIgZGVidWc5ID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50OmxpYnJhcnlFbmdpbmVcIik7XG5mdW5jdGlvbiBpc1F1ZXJ5RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50W1wiaXRlbV90eXBlXCJdID09PSBcInF1ZXJ5XCIgJiYgXCJxdWVyeVwiIGluIGV2ZW50O1xufVxuX19uYW1lKGlzUXVlcnlFdmVudCwgXCJpc1F1ZXJ5RXZlbnRcIik7XG5mdW5jdGlvbiBpc1BhbmljRXZlbnQoZXZlbnQpIHtcbiAgaWYgKFwibGV2ZWxcIiBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5sZXZlbCA9PT0gXCJlcnJvclwiICYmIGV2ZW50W1wibWVzc2FnZVwiXSA9PT0gXCJQQU5JQ1wiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuX19uYW1lKGlzUGFuaWNFdmVudCwgXCJpc1BhbmljRXZlbnRcIik7XG52YXIga25vd25QbGF0Zm9ybXMyID0gWy4uLnBsYXRmb3JtcywgXCJuYXRpdmVcIl07XG52YXIgZW5naW5lSW5zdGFuY2VDb3VudCA9IDA7XG52YXIgZXhpdEhvb2tzID0gbmV3IEV4aXRIb29rcygpO1xudmFyIExpYnJhcnlFbmdpbmUgPSBjbGFzcyBleHRlbmRzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZzIsIGxvYWRlciA9IG5ldyBEZWZhdWx0TGlicmFyeUxvYWRlcihjb25maWcyKSkge1xuICAgIHZhciBfYTMsIF9iMjtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YW1vZGVsID0gaW1wb3J0X2ZzNi5kZWZhdWx0LnJlYWRGaWxlU3luYyhjb25maWcyLmRhdGFtb2RlbFBhdGgsIFwidXRmLThcIik7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcyO1xuICAgIHRoaXMubGlicmFyeVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZ1F1ZXJpZXMgPSAoX2EzID0gY29uZmlnMi5sb2dRdWVyaWVzKSAhPSBudWxsID8gX2EzIDogZmFsc2U7XG4gICAgdGhpcy5sb2dMZXZlbCA9IChfYjIgPSBjb25maWcyLmxvZ0xldmVsKSAhPSBudWxsID8gX2IyIDogXCJlcnJvclwiO1xuICAgIHRoaXMubGlicmFyeUxvYWRlciA9IGxvYWRlcjtcbiAgICB0aGlzLmxvZ0VtaXR0ZXIgPSBuZXcgaW1wb3J0X2V2ZW50czMuZGVmYXVsdCgpO1xuICAgIHRoaXMubG9nRW1pdHRlci5vbihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgfSk7XG4gICAgdGhpcy5kYXRhc291cmNlT3ZlcnJpZGVzID0gY29uZmlnMi5kYXRhc291cmNlcyA/IHRoaXMuY29udmVydERhdGFzb3VyY2VzKGNvbmZpZzIuZGF0YXNvdXJjZXMpIDoge307XG4gICAgaWYgKGNvbmZpZzIuZW5hYmxlRGVidWdMb2dzKSB7XG4gICAgICB0aGlzLmxvZ0xldmVsID0gXCJkZWJ1Z1wiO1xuICAgIH1cbiAgICB0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZSA9IHRoaXMuaW5zdGFudGlhdGVMaWJyYXJ5KCk7XG4gICAgZXhpdEhvb2tzLmluc3RhbGwoKTtcbiAgICB0aGlzLmNoZWNrRm9yVG9vTWFueUVuZ2luZXMoKTtcbiAgfVxuICBnZXQgYmVmb3JlRXhpdExpc3RlbmVyKCkge1xuICAgIHJldHVybiBleGl0SG9va3MuZ2V0TGlzdGVuZXIodGhpcyk7XG4gIH1cbiAgc2V0IGJlZm9yZUV4aXRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGV4aXRIb29rcy5zZXRMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH1cbiAgY2hlY2tGb3JUb29NYW55RW5naW5lcygpIHtcbiAgICBpZiAoZW5naW5lSW5zdGFuY2VDb3VudCA9PT0gMTApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7aW1wb3J0X2NoYWxrNS5kZWZhdWx0LnllbGxvdyhcIndhcm4ocHJpc21hLWNsaWVudClcIil9IFRoZXJlIGFyZSBhbHJlYWR5IDEwIGluc3RhbmNlcyBvZiBQcmlzbWEgQ2xpZW50IGFjdGl2ZWx5IHJ1bm5pbmcuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdHJhbnNhY3Rpb24oYWN0aW9uLCBoZWFkZXJzLCBhcmcyKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYywgX2QsIF9lO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICBjb25zdCBoZWFkZXJTdHIgPSBKU09OLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChhY3Rpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgY29uc3QganNvbk9wdGlvbnMgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1heF93YWl0OiAoX2EzID0gYXJnMiA9PSBudWxsID8gdm9pZCAwIDogYXJnMi5tYXhXYWl0KSAhPSBudWxsID8gX2EzIDogMmUzLFxuICAgICAgICB0aW1lb3V0OiAoX2IyID0gYXJnMiA9PSBudWxsID8gdm9pZCAwIDogYXJnMi50aW1lb3V0KSAhPSBudWxsID8gX2IyIDogNWUzLFxuICAgICAgICBpc29sYXRpb25fbGV2ZWw6IGFyZzIgPT0gbnVsbCA/IHZvaWQgMCA6IGFyZzIuaXNvbGF0aW9uTGV2ZWxcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgKChfYyA9IHRoaXMuZW5naW5lKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRUcmFuc2FjdGlvbihqc29uT3B0aW9ucywgaGVhZGVyU3RyKSk7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwiY29tbWl0XCIpIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0ICgoX2QgPSB0aGlzLmVuZ2luZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNvbW1pdFRyYW5zYWN0aW9uKGFyZzIuaWQsIGhlYWRlclN0cikpO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJvbGxiYWNrXCIpIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0ICgoX2UgPSB0aGlzLmVuZ2luZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJvbGxiYWNrVHJhbnNhY3Rpb24oYXJnMi5pZCwgaGVhZGVyU3RyKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKHJlc3VsdCk7XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yX2NvZGUpXG4gICAgICB0aHJvdyByZXNwb25zZTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgaW5zdGFudGlhdGVMaWJyYXJ5KCkge1xuICAgIGRlYnVnOShcImludGVybmFsU2V0dXBcIik7XG4gICAgaWYgKHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2U7XG4gICAgfVxuICAgIGF3YWl0IGlzTm9kZUFQSVN1cHBvcnRlZCgpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBhd2FpdCB0aGlzLmdldFBsYXRmb3JtKCk7XG4gICAgYXdhaXQgdGhpcy5sb2FkRW5naW5lKCk7XG4gICAgdGhpcy52ZXJzaW9uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0UGxhdGZvcm0oKSB7XG4gICAgaWYgKHRoaXMucGxhdGZvcm0pXG4gICAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBwbGF0Zm9ybTMgPSBhd2FpdCBnZXRQbGF0Zm9ybSgpO1xuICAgIGlmICgha25vd25QbGF0Zm9ybXMyLmluY2x1ZGVzKHBsYXRmb3JtMykpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICBgVW5rbm93biAke2ltcG9ydF9jaGFsazUuZGVmYXVsdC5yZWQoXCJQUklTTUFfUVVFUllfRU5HSU5FX0xJQlJBUllcIil9ICR7aW1wb3J0X2NoYWxrNS5kZWZhdWx0LnJlZEJyaWdodC5ib2xkKFxuICAgICAgICAgIHBsYXRmb3JtM1xuICAgICAgICApfS4gUG9zc2libGUgYmluYXJ5VGFyZ2V0czogJHtpbXBvcnRfY2hhbGs1LmRlZmF1bHQuZ3JlZW5CcmlnaHQoXG4gICAgICAgICAga25vd25QbGF0Zm9ybXMyLmpvaW4oXCIsIFwiKVxuICAgICAgICApfSBvciBhIHBhdGggdG8gdGhlIHF1ZXJ5IGVuZ2luZSBsaWJyYXJ5LlxuWW91IG1heSBoYXZlIHRvIHJ1biAke2ltcG9ydF9jaGFsazUuZGVmYXVsdC5ncmVlbkJyaWdodChcInByaXNtYSBnZW5lcmF0ZVwiKX0gZm9yIHlvdXIgY2hhbmdlcyB0byB0YWtlIGVmZmVjdC5gLFxuICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGxhdGZvcm0zO1xuICB9XG4gIHBhcnNlRW5naW5lUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihgUmVzcG9uc2UgZnJvbSB0aGUgRW5naW5lIHdhcyBlbXB0eWAsIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnMiA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIGNvbmZpZzI7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihgVW5hYmxlIHRvIEpTT04ucGFyc2UgcmVzcG9uc2UgZnJvbSBlbmdpbmVgLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgICB9XG4gIH1cbiAgY29udmVydERhdGFzb3VyY2VzKGRhdGFzb3VyY2VzKSB7XG4gICAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCB7IG5hbWUsIHVybCB9IG9mIGRhdGFzb3VyY2VzKSB7XG4gICAgICBvYmpbbmFtZV0gPSB1cmw7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgYXN5bmMgbG9hZEVuZ2luZSgpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICghdGhpcy5lbmdpbmUpIHtcbiAgICAgIGlmICghdGhpcy5RdWVyeUVuZ2luZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMubGlicmFyeSA9IGF3YWl0IHRoaXMubGlicmFyeUxvYWRlci5sb2FkTGlicmFyeSgpO1xuICAgICAgICB0aGlzLlF1ZXJ5RW5naW5lQ29uc3RydWN0b3IgPSB0aGlzLmxpYnJhcnkuUXVlcnlFbmdpbmU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB3ZWFrVGhpcyA9IG5ldyBXZWFrUmVmKHRoaXMpO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyB0aGlzLlF1ZXJ5RW5naW5lQ29uc3RydWN0b3IoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YW1vZGVsOiB0aGlzLmRhdGFtb2RlbCxcbiAgICAgICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgICAgICBsb2dRdWVyaWVzOiAoX2EzID0gdGhpcy5jb25maWcubG9nUXVlcmllcykgIT0gbnVsbCA/IF9hMyA6IGZhbHNlLFxuICAgICAgICAgICAgaWdub3JlRW52VmFyRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGFzb3VyY2VPdmVycmlkZXM6IHRoaXMuZGF0YXNvdXJjZU92ZXJyaWRlcyxcbiAgICAgICAgICAgIGxvZ0xldmVsOiB0aGlzLmxvZ0xldmVsLFxuICAgICAgICAgICAgY29uZmlnRGlyOiB0aGlzLmNvbmZpZy5jd2RcbiAgICAgICAgICB9LFxuICAgICAgICAgIChsb2c0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E0O1xuICAgICAgICAgICAgKF9hNCA9IHdlYWtUaGlzLmRlcmVmKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTQubG9nZ2VyKGxvZzQpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgZW5naW5lSW5zdGFuY2VDb3VudCsrO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgY29uc3QgZSA9IF9lO1xuICAgICAgICBjb25zdCBlcnJvcjIgPSB0aGlzLnBhcnNlSW5pdEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihlcnJvcjIubWVzc2FnZSwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbiwgZXJyb3IyLmVycm9yX2NvZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ2dlcihsb2c0KSB7XG4gICAgdmFyIF9hMztcbiAgICBjb25zdCBldmVudCA9IHRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShsb2c0KTtcbiAgICBpZiAoIWV2ZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChcInNwYW5cIiBpbiBldmVudCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnRyYWNpbmdDb25maWcuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2b2lkIGNyZWF0ZVNwYW4oZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5sZXZlbCA9IChfYTMgPSBldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQubGV2ZWwudG9Mb3dlckNhc2UoKSkgIT0gbnVsbCA/IF9hMyA6IFwidW5rbm93blwiO1xuICAgIGlmIChpc1F1ZXJ5RXZlbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcInF1ZXJ5XCIsIHtcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBxdWVyeTogZXZlbnQucXVlcnksXG4gICAgICAgIHBhcmFtczogZXZlbnQucGFyYW1zLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyKGV2ZW50LmR1cmF0aW9uX21zKSxcbiAgICAgICAgdGFyZ2V0OiBldmVudC5tb2R1bGVfcGF0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1BhbmljRXZlbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLmxvZ2dlclJ1c3RQYW5pYyA9IG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcihcbiAgICAgICAgdGhpcy5nZXRFcnJvck1lc3NhZ2VXaXRoTGluayhcbiAgICAgICAgICBgJHtldmVudC5tZXNzYWdlfTogJHtldmVudC5yZWFzb259IGluICR7ZXZlbnQuZmlsZX06JHtldmVudC5saW5lfToke2V2ZW50LmNvbHVtbn1gXG4gICAgICAgICksXG4gICAgICAgIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb25cbiAgICAgICk7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcImVycm9yXCIsIHRoaXMubG9nZ2VyUnVzdFBhbmljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoZXZlbnQubGV2ZWwsIHtcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgICB0YXJnZXQ6IGV2ZW50Lm1vZHVsZV9wYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsodGl0bGUpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiBnZXRFcnJvck1lc3NhZ2VXaXRoTGluayh7XG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHRpdGxlLFxuICAgICAgdmVyc2lvbjogdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbixcbiAgICAgIGVuZ2luZVZlcnNpb246IChfYTMgPSB0aGlzLnZlcnNpb25JbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNvbW1pdCxcbiAgICAgIGRhdGFiYXNlOiB0aGlzLmNvbmZpZy5hY3RpdmVQcm92aWRlcixcbiAgICAgIHF1ZXJ5OiB0aGlzLmxhc3RRdWVyeVxuICAgIH0pO1xuICB9XG4gIHBhcnNlSW5pdEVycm9yKHN0cikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlcnJvcjIgPSBKU09OLnBhcnNlKHN0cik7XG4gICAgICByZXR1cm4gZXJyb3IyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBwYXJzZVJlcXVlc3RFcnJvcihzdHIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXJyb3IyID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgcmV0dXJuIGVycm9yMjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJlZm9yZUV4aXRcIikge1xuICAgICAgdGhpcy5iZWZvcmVFeGl0TGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGF3YWl0IHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlO1xuICAgIGF3YWl0IHRoaXMubGlicmFyeVN0b3BwaW5nUHJvbWlzZTtcbiAgICBpZiAodGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlKSB7XG4gICAgICBkZWJ1ZzkoYGxpYnJhcnkgYWxyZWFkeSBzdGFydGluZywgdGhpcy5saWJyYXJ5U3RhcnRlZDogJHt0aGlzLmxpYnJhcnlTdGFydGVkfWApO1xuICAgICAgcmV0dXJuIHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGlicmFyeVN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGRlYnVnOShcImxpYnJhcnkgc3RhcnRpbmdcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgIHRyYWNlcGFyZW50OiBnZXRUcmFjZVBhcmVudCh7IHRyYWNpbmdDb25maWc6IHRoaXMuY29uZmlnLnRyYWNpbmdDb25maWcgfSlcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgKChfYTMgPSB0aGlzLmVuZ2luZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb25uZWN0KEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpKSk7XG4gICAgICAgIHRoaXMubGlicmFyeVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBkZWJ1ZzkoXCJsaWJyYXJ5IHN0YXJ0ZWRcIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IyID0gdGhpcy5wYXJzZUluaXRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGVycm9yMi5tZXNzYWdlLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uLCBlcnJvcjIuZXJyb3JfY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9LCBcInN0YXJ0Rm5cIik7XG4gICAgY29uc3Qgc3BhbkNvbmZpZyA9IHtcbiAgICAgIG5hbWU6IFwiY29ubmVjdFwiLFxuICAgICAgZW5hYmxlZDogdGhpcy5jb25maWcudHJhY2luZ0NvbmZpZy5lbmFibGVkXG4gICAgfTtcbiAgICB0aGlzLmxpYnJhcnlTdGFydGluZ1Byb21pc2UgPSBydW5JbkNoaWxkU3BhbihzcGFuQ29uZmlnLCBzdGFydEZuKTtcbiAgICByZXR1cm4gdGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlO1xuICB9XG4gIGFzeW5jIHN0b3AoKSB7XG4gICAgYXdhaXQgdGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlO1xuICAgIGlmICh0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2UpIHtcbiAgICAgIGRlYnVnOShcImxpYnJhcnkgaXMgYWxyZWFkeSBzdG9wcGluZ1wiKTtcbiAgICAgIHJldHVybiB0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5saWJyYXJ5U3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdG9wRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTM7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCA1KSk7XG4gICAgICBkZWJ1ZzkoXCJsaWJyYXJ5IHN0b3BwaW5nXCIpO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgdHJhY2VwYXJlbnQ6IGdldFRyYWNlUGFyZW50KHsgdHJhY2luZ0NvbmZpZzogdGhpcy5jb25maWcudHJhY2luZ0NvbmZpZyB9KVxuICAgICAgfTtcbiAgICAgIGF3YWl0ICgoX2EzID0gdGhpcy5lbmdpbmUpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZGlzY29ubmVjdChKU09OLnN0cmluZ2lmeShoZWFkZXJzKSkpO1xuICAgICAgdGhpcy5saWJyYXJ5U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlID0gdm9pZCAwO1xuICAgICAgZGVidWc5KFwibGlicmFyeSBzdG9wcGVkXCIpO1xuICAgIH0sIFwic3RvcEZuXCIpO1xuICAgIGNvbnN0IHNwYW5Db25maWcgPSB7XG4gICAgICBuYW1lOiBcImRpc2Nvbm5lY3RcIixcbiAgICAgIGVuYWJsZWQ6IHRoaXMuY29uZmlnLnRyYWNpbmdDb25maWcuZW5hYmxlZFxuICAgIH07XG4gICAgdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlID0gcnVuSW5DaGlsZFNwYW4oc3BhbkNvbmZpZywgc3RvcEZuKTtcbiAgICByZXR1cm4gdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlO1xuICB9XG4gIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICBhd2FpdCB0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZTtcbiAgICByZXR1cm4gdGhpcy5saWJyYXJ5LmdldENvbmZpZyh7XG4gICAgICBkYXRhbW9kZWw6IHRoaXMuZGF0YW1vZGVsLFxuICAgICAgZGF0YXNvdXJjZU92ZXJyaWRlczogdGhpcy5kYXRhc291cmNlT3ZlcnJpZGVzLFxuICAgICAgaWdub3JlRW52VmFyRXJyb3JzOiB0cnVlLFxuICAgICAgZW52OiBwcm9jZXNzLmVudlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldERtbWYoKSB7XG4gICAgYXdhaXQgdGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2U7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYXdhaXQgdGhpcy5saWJyYXJ5LmRtbWYodGhpcy5kYXRhbW9kZWwpKTtcbiAgfVxuICB2ZXJzaW9uKCkge1xuICAgIHZhciBfYTMsIF9iMiwgX2M7XG4gICAgdGhpcy52ZXJzaW9uSW5mbyA9IChfYTMgPSB0aGlzLmxpYnJhcnkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMudmVyc2lvbigpO1xuICAgIHJldHVybiAoX2MgPSAoX2IyID0gdGhpcy52ZXJzaW9uSW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi52ZXJzaW9uKSAhPSBudWxsID8gX2MgOiBcInVua25vd25cIjtcbiAgfVxuICBkZWJ1Z1BhbmljKG1lc3NhZ2UpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiAoX2EzID0gdGhpcy5saWJyYXJ5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmRlYnVnUGFuaWMobWVzc2FnZSk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChxdWVyeTIsIGhlYWRlcnMgPSB7fSwgbnVtVHJ5ID0gMSkge1xuICAgIHZhciBfYTMsIF9iMjtcbiAgICBkZWJ1ZzkoYHNlbmRpbmcgcmVxdWVzdCwgdGhpcy5saWJyYXJ5U3RhcnRlZDogJHt0aGlzLmxpYnJhcnlTdGFydGVkfWApO1xuICAgIGNvbnN0IHJlcXVlc3QyID0geyBxdWVyeTogcXVlcnkyLCB2YXJpYWJsZXM6IHt9IH07XG4gICAgY29uc3QgaGVhZGVyU3RyID0gSlNPTi5zdHJpbmdpZnkoaGVhZGVycyk7XG4gICAgY29uc3QgcXVlcnlTdHIgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Mik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICAgIHRoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlID0gKF9hMyA9IHRoaXMuZW5naW5lKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnF1ZXJ5KHF1ZXJ5U3RyLCBoZWFkZXJTdHIsIGhlYWRlcnMudHJhbnNhY3Rpb25JZCk7XG4gICAgICB0aGlzLmxhc3RRdWVyeSA9IHF1ZXJ5U3RyO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShhd2FpdCB0aGlzLmV4ZWN1dGluZ1F1ZXJ5UHJvbWlzZSk7XG4gICAgICBpZiAoZGF0YS5lcnJvcnMpIHtcbiAgICAgICAgaWYgKGRhdGEuZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRocm93IHRoaXMuYnVpbGRRdWVyeUVycm9yKGRhdGEuZXJyb3JzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihKU09OLnN0cmluZ2lmeShkYXRhLmVycm9ycyksIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxvZ2dlclJ1c3RQYW5pYykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlclJ1c3RQYW5pYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGEsIGVsYXBzZWQ6IDAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChlLmNvZGUgPT09IFwiR2VuZXJpY0ZhaWx1cmVcIiAmJiAoKF9iMiA9IGUubWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5zdGFydHNXaXRoKFwiUEFOSUM6XCIpKSkge1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IodGhpcy5nZXRFcnJvck1lc3NhZ2VXaXRoTGluayhlLm1lc3NhZ2UpLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yMiA9IHRoaXMucGFyc2VSZXF1ZXN0RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIGlmICh0eXBlb2YgZXJyb3IyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihgJHtlcnJvcjIubWVzc2FnZX1cbiR7ZXJyb3IyLmJhY2t0cmFjZX1gLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdEJhdGNoKHF1ZXJpZXMsIGhlYWRlcnMgPSB7fSwgdHJhbnNhY3Rpb24gPSBmYWxzZSwgbnVtVHJ5ID0gMSkge1xuICAgIGRlYnVnOShcInJlcXVlc3RCYXRjaFwiKTtcbiAgICBjb25zdCByZXF1ZXN0MiA9IHtcbiAgICAgIGJhdGNoOiBxdWVyaWVzLm1hcCgocXVlcnkyKSA9PiAoeyBxdWVyeTogcXVlcnkyLCB2YXJpYWJsZXM6IHt9IH0pKSxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgdGhpcy5sYXN0UXVlcnkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Mik7XG4gICAgdGhpcy5leGVjdXRpbmdRdWVyeVByb21pc2UgPSB0aGlzLmVuZ2luZS5xdWVyeSh0aGlzLmxhc3RRdWVyeSwgSlNPTi5zdHJpbmdpZnkoaGVhZGVycyksIGhlYWRlcnMudHJhbnNhY3Rpb25JZCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRpbmdRdWVyeVByb21pc2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShyZXN1bHQpO1xuICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgaWYgKGRhdGEuZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aHJvdyB0aGlzLmJ1aWxkUXVlcnlFcnJvcihkYXRhLmVycm9yc1swXSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihKU09OLnN0cmluZ2lmeShkYXRhLmVycm9ycyksIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCB7IGJhdGNoUmVzdWx0LCBlcnJvcnMgfSA9IGRhdGE7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmF0Y2hSZXN1bHQpKSB7XG4gICAgICByZXR1cm4gYmF0Y2hSZXN1bHQubWFwKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmIChyZXN1bHQyLmVycm9ycykge1xuICAgICAgICAgIHJldHVybiAoX2EzID0gdGhpcy5sb2dnZXJSdXN0UGFuaWMpICE9IG51bGwgPyBfYTMgOiB0aGlzLmJ1aWxkUXVlcnlFcnJvcihkYXRhLmVycm9yc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiByZXN1bHQyLFxuICAgICAgICAgIGVsYXBzZWQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yc1swXS5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH1cbiAgfVxuICBidWlsZFF1ZXJ5RXJyb3IoZXJyb3IyKSB7XG4gICAgaWYgKGVycm9yMi51c2VyX2ZhY2luZ19lcnJvci5pc19wYW5pYykge1xuICAgICAgcmV0dXJuIG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcihcbiAgICAgICAgdGhpcy5nZXRFcnJvck1lc3NhZ2VXaXRoTGluayhlcnJvcjIudXNlcl9mYWNpbmdfZXJyb3IubWVzc2FnZSksXG4gICAgICAgIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwcmlzbWFHcmFwaFFMVG9KU0Vycm9yKGVycm9yMiwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7XG4gIH1cbiAgYXN5bmMgbWV0cmljcyhvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlU3RyaW5nID0gYXdhaXQgdGhpcy5lbmdpbmUubWV0cmljcyhKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSBcInByb21ldGhldXNcIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKHJlc3BvbnNlU3RyaW5nKTtcbiAgfVxufTtcbl9fbmFtZShMaWJyYXJ5RW5naW5lLCBcIkxpYnJhcnlFbmdpbmVcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvdXRpbHMvdHJ5TG9hZEVudnMudHNcbnZhciBpbXBvcnRfY2hhbGs2ID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciBpbXBvcnRfZG90ZW52ID0gX190b0VTTShyZXF1aXJlX21haW4yKCkpO1xudmFyIGltcG9ydF9mczcgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X3BhdGg0ID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvZG90ZW52RXhwYW5kLnRzXG5mdW5jdGlvbiBkb3RlbnZFeHBhbmQoY29uZmlnMikge1xuICBjb25zdCBlbnZpcm9ubWVudCA9IGNvbmZpZzIuaWdub3JlUHJvY2Vzc0VudiA/IHt9IDogcHJvY2Vzcy5lbnY7XG4gIGNvbnN0IGludGVycG9sYXRlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZW52VmFsdWUpID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gZW52VmFsdWUubWF0Y2goLyguP1xcJHsoPzpbYS16QS1aMC05X10rKT99KS9nKSB8fCBbXTtcbiAgICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoZnVuY3Rpb24obmV3RW52LCBtYXRjaCkge1xuICAgICAgY29uc3QgcGFydHMgPSAvKC4/KVxcJHsoW2EtekEtWjAtOV9dKyk/fS9nLmV4ZWMobWF0Y2gpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbmV3RW52O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlZml4ID0gcGFydHNbMV07XG4gICAgICBsZXQgdmFsdWUsIHJlcGxhY2VQYXJ0O1xuICAgICAgaWYgKHByZWZpeCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgcmVwbGFjZVBhcnQgPSBwYXJ0c1swXTtcbiAgICAgICAgdmFsdWUgPSByZXBsYWNlUGFydC5yZXBsYWNlKFwiXFxcXCRcIiwgXCIkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFydHNbMl07XG4gICAgICAgIHJlcGxhY2VQYXJ0ID0gcGFydHNbMF0uc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICB2YWx1ZSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudmlyb25tZW50LCBrZXkpID8gZW52aXJvbm1lbnRba2V5XSA6IGNvbmZpZzIucGFyc2VkW2tleV0gfHwgXCJcIjtcbiAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RW52LnJlcGxhY2UocmVwbGFjZVBhcnQsIHZhbHVlKTtcbiAgICB9LCBlbnZWYWx1ZSk7XG4gIH0sIFwiaW50ZXJwb2xhdGVcIik7XG4gIGZvciAoY29uc3QgY29uZmlnS2V5IGluIGNvbmZpZzIucGFyc2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlbnZpcm9ubWVudCwgY29uZmlnS2V5KSA/IGVudmlyb25tZW50W2NvbmZpZ0tleV0gOiBjb25maWcyLnBhcnNlZFtjb25maWdLZXldO1xuICAgIGNvbmZpZzIucGFyc2VkW2NvbmZpZ0tleV0gPSBpbnRlcnBvbGF0ZSh2YWx1ZSk7XG4gIH1cbiAgZm9yIChjb25zdCBwcm9jZXNzS2V5IGluIGNvbmZpZzIucGFyc2VkKSB7XG4gICAgZW52aXJvbm1lbnRbcHJvY2Vzc0tleV0gPSBjb25maWcyLnBhcnNlZFtwcm9jZXNzS2V5XTtcbiAgfVxuICByZXR1cm4gY29uZmlnMjtcbn1cbl9fbmFtZShkb3RlbnZFeHBhbmQsIFwiZG90ZW52RXhwYW5kXCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL3V0aWxzL3RyeUxvYWRFbnZzLnRzXG52YXIgZGVidWcxMCA9IHNyY19kZWZhdWx0KFwicHJpc21hOnRyeUxvYWRFbnZcIik7XG5mdW5jdGlvbiB0cnlMb2FkRW52cyh7XG4gIHJvb3RFbnZQYXRoLFxuICBzY2hlbWFFbnZQYXRoXG59LCBvcHRzID0ge1xuICBjb25mbGljdENoZWNrOiBcIm5vbmVcIlxufSkge1xuICB2YXIgX2EzLCBfYjI7XG4gIGNvbnN0IHJvb3RFbnZJbmZvID0gbG9hZEVudihyb290RW52UGF0aCk7XG4gIGlmIChvcHRzLmNvbmZsaWN0Q2hlY2sgIT09IFwibm9uZVwiKSB7XG4gICAgY2hlY2tGb3JDb25mbGljdHMocm9vdEVudkluZm8sIHNjaGVtYUVudlBhdGgsIG9wdHMuY29uZmxpY3RDaGVjayk7XG4gIH1cbiAgbGV0IHNjaGVtYUVudkluZm8gPSBudWxsO1xuICBpZiAoIXBhdGhzRXF1YWwocm9vdEVudkluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RFbnZJbmZvLnBhdGgsIHNjaGVtYUVudlBhdGgpKSB7XG4gICAgc2NoZW1hRW52SW5mbyA9IGxvYWRFbnYoc2NoZW1hRW52UGF0aCk7XG4gIH1cbiAgaWYgKCFyb290RW52SW5mbyAmJiAhc2NoZW1hRW52SW5mbykge1xuICAgIGRlYnVnMTAoXCJObyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgbG9hZGVkXCIpO1xuICB9XG4gIGlmIChzY2hlbWFFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiBzY2hlbWFFbnZJbmZvLmRvdGVudlJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKGltcG9ydF9jaGFsazYuZGVmYXVsdC5yZWRCcmlnaHQuYm9sZChcIlNjaGVtYSBFbnYgRXJyb3I6IFwiKSArIHNjaGVtYUVudkluZm8uZG90ZW52UmVzdWx0LmVycm9yKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlcyA9IFtyb290RW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogcm9vdEVudkluZm8ubWVzc2FnZSwgc2NoZW1hRW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogc2NoZW1hRW52SW5mby5tZXNzYWdlXS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogbWVzc2FnZXMuam9pbihcIlxcblwiKSxcbiAgICBwYXJzZWQ6IHtcbiAgICAgIC4uLihfYTMgPSByb290RW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogcm9vdEVudkluZm8uZG90ZW52UmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnBhcnNlZCxcbiAgICAgIC4uLihfYjIgPSBzY2hlbWFFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiBzY2hlbWFFbnZJbmZvLmRvdGVudlJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5wYXJzZWRcbiAgICB9XG4gIH07XG59XG5fX25hbWUodHJ5TG9hZEVudnMsIFwidHJ5TG9hZEVudnNcIik7XG5mdW5jdGlvbiBjaGVja0ZvckNvbmZsaWN0cyhyb290RW52SW5mbywgZW52UGF0aCwgdHlwZSkge1xuICBjb25zdCBwYXJzZWRSb290RW52ID0gcm9vdEVudkluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RFbnZJbmZvLmRvdGVudlJlc3VsdC5wYXJzZWQ7XG4gIGNvbnN0IGFyZU5vdFRoZVNhbWUgPSAhcGF0aHNFcXVhbChyb290RW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogcm9vdEVudkluZm8ucGF0aCwgZW52UGF0aCk7XG4gIGlmIChwYXJzZWRSb290RW52ICYmIGVudlBhdGggJiYgYXJlTm90VGhlU2FtZSAmJiBpbXBvcnRfZnM3LmRlZmF1bHQuZXhpc3RzU3luYyhlbnZQYXRoKSkge1xuICAgIGNvbnN0IGVudkNvbmZpZyA9IGltcG9ydF9kb3RlbnYuZGVmYXVsdC5wYXJzZShpbXBvcnRfZnM3LmRlZmF1bHQucmVhZEZpbGVTeW5jKGVudlBhdGgpKTtcbiAgICBjb25zdCBjb25mbGljdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZW52Q29uZmlnKSB7XG4gICAgICBpZiAocGFyc2VkUm9vdEVudltrXSA9PT0gZW52Q29uZmlnW2tdKSB7XG4gICAgICAgIGNvbmZsaWN0cy5wdXNoKGspO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUm9vdEVudlBhdGggPSBpbXBvcnRfcGF0aDQuZGVmYXVsdC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCByb290RW52SW5mby5wYXRoKTtcbiAgICAgIGNvbnN0IHJlbGF0aXZlRW52UGF0aCA9IGltcG9ydF9wYXRoNC5kZWZhdWx0LnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIGVudlBhdGgpO1xuICAgICAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFRoZXJlIGlzIGEgY29uZmxpY3QgYmV0d2VlbiBlbnYgdmFyJHtjb25mbGljdHMubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn0gaW4gJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQudW5kZXJsaW5lKFxuICAgICAgICAgIHJlbGF0aXZlUm9vdEVudlBhdGhcbiAgICAgICAgKX0gYW5kICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShyZWxhdGl2ZUVudlBhdGgpfVxuQ29uZmxpY3RpbmcgZW52IHZhcnM6XG4ke2NvbmZsaWN0cy5tYXAoKGNvbmZsaWN0KSA9PiBgICAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC5ib2xkKGNvbmZsaWN0KX1gKS5qb2luKFwiXFxuXCIpfVxuXG5XZSBzdWdnZXN0IHRvIG1vdmUgdGhlIGNvbnRlbnRzIG9mICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShyZWxhdGl2ZUVudlBhdGgpfSB0byAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC51bmRlcmxpbmUoXG4gICAgICAgICAgcmVsYXRpdmVSb290RW52UGF0aFxuICAgICAgICApfSB0byBjb25zb2xpZGF0ZSB5b3VyIGVudiB2YXJzLlxuYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIndhcm5cIikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvbmZsaWN0IGZvciBlbnYgdmFyJHtjb25mbGljdHMubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn0gJHtjb25mbGljdHMubWFwKChjKSA9PiBpbXBvcnRfY2hhbGs2LmRlZmF1bHQuYm9sZChjKSkuam9pbihcIiwgXCIpfSBpbiAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC51bmRlcmxpbmUocmVsYXRpdmVSb290RW52UGF0aCl9IGFuZCAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC51bmRlcmxpbmUocmVsYXRpdmVFbnZQYXRoKX1cbkVudiB2YXJzIGZyb20gJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQudW5kZXJsaW5lKHJlbGF0aXZlRW52UGF0aCl9IG92ZXJ3cml0ZSB0aGUgb25lcyBmcm9tICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShyZWxhdGl2ZVJvb3RFbnZQYXRoKX1cbiAgICAgIGA7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQueWVsbG93KFwid2FybihwcmlzbWEpXCIpfSAke21lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5fX25hbWUoY2hlY2tGb3JDb25mbGljdHMsIFwiY2hlY2tGb3JDb25mbGljdHNcIik7XG5mdW5jdGlvbiBsb2FkRW52KGVudlBhdGgpIHtcbiAgaWYgKGV4aXN0czMoZW52UGF0aCkpIHtcbiAgICBkZWJ1ZzEwKGBFbnZpcm9ubWVudCB2YXJpYWJsZXMgbG9hZGVkIGZyb20gJHtlbnZQYXRofWApO1xuICAgIHJldHVybiB7XG4gICAgICBkb3RlbnZSZXN1bHQ6IGRvdGVudkV4cGFuZChcbiAgICAgICAgaW1wb3J0X2RvdGVudi5kZWZhdWx0LmNvbmZpZyh7XG4gICAgICAgICAgcGF0aDogZW52UGF0aCxcbiAgICAgICAgICBkZWJ1ZzogcHJvY2Vzcy5lbnYuRE9URU5WX0NPTkZJR19ERUJVRyA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBtZXNzYWdlOiBpbXBvcnRfY2hhbGs2LmRlZmF1bHQuZGltKGBFbnZpcm9ubWVudCB2YXJpYWJsZXMgbG9hZGVkIGZyb20gJHtpbXBvcnRfcGF0aDQuZGVmYXVsdC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCBlbnZQYXRoKX1gKSxcbiAgICAgIHBhdGg6IGVudlBhdGhcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGRlYnVnMTAoYEVudmlyb25tZW50IHZhcmlhYmxlcyBub3QgZm91bmQgYXQgJHtlbnZQYXRofWApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuX19uYW1lKGxvYWRFbnYsIFwibG9hZEVudlwiKTtcbmZ1bmN0aW9uIHBhdGhzRXF1YWwocGF0aDEsIHBhdGgyMikge1xuICByZXR1cm4gcGF0aDEgJiYgcGF0aDIyICYmIGltcG9ydF9wYXRoNC5kZWZhdWx0LnJlc29sdmUocGF0aDEpID09PSBpbXBvcnRfcGF0aDQuZGVmYXVsdC5yZXNvbHZlKHBhdGgyMik7XG59XG5fX25hbWUocGF0aHNFcXVhbCwgXCJwYXRoc0VxdWFsXCIpO1xuZnVuY3Rpb24gZXhpc3RzMyhwKSB7XG4gIHJldHVybiBCb29sZWFuKHAgJiYgaW1wb3J0X2ZzNy5kZWZhdWx0LmV4aXN0c1N5bmMocCkpO1xufVxuX19uYW1lKGV4aXN0czMsIFwiZXhpc3RzXCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL2NsaWVudC9nZXRDbGllbnRFbmdpbmVUeXBlLnRzXG52YXIgREVGQVVMVF9DTElFTlRfRU5HSU5FX1RZUEUgPSBcImxpYnJhcnlcIiAvKiBMaWJyYXJ5ICovO1xuZnVuY3Rpb24gZ2V0Q2xpZW50RW5naW5lVHlwZShnZW5lcmF0b3JDb25maWcpIHtcbiAgY29uc3QgZW5naW5lVHlwZUZyb21FbnZWYXIgPSBnZXRFbmdpbmVUeXBlRnJvbUVudlZhcigpO1xuICBpZiAoZW5naW5lVHlwZUZyb21FbnZWYXIpXG4gICAgcmV0dXJuIGVuZ2luZVR5cGVGcm9tRW52VmFyO1xuICBpZiAoKGdlbmVyYXRvckNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogZ2VuZXJhdG9yQ29uZmlnLmNvbmZpZy5lbmdpbmVUeXBlKSA9PT0gXCJsaWJyYXJ5XCIgLyogTGlicmFyeSAqLykge1xuICAgIHJldHVybiBcImxpYnJhcnlcIiAvKiBMaWJyYXJ5ICovO1xuICB9IGVsc2UgaWYgKChnZW5lcmF0b3JDb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGdlbmVyYXRvckNvbmZpZy5jb25maWcuZW5naW5lVHlwZSkgPT09IFwiYmluYXJ5XCIgLyogQmluYXJ5ICovKSB7XG4gICAgcmV0dXJuIFwiYmluYXJ5XCIgLyogQmluYXJ5ICovO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0NMSUVOVF9FTkdJTkVfVFlQRTtcbiAgfVxufVxuX19uYW1lKGdldENsaWVudEVuZ2luZVR5cGUsIFwiZ2V0Q2xpZW50RW5naW5lVHlwZVwiKTtcbmZ1bmN0aW9uIGdldEVuZ2luZVR5cGVGcm9tRW52VmFyKCkge1xuICBjb25zdCBlbmdpbmVUeXBlID0gcHJvY2Vzcy5lbnYuUFJJU01BX0NMSUVOVF9FTkdJTkVfVFlQRTtcbiAgaWYgKGVuZ2luZVR5cGUgPT09IFwibGlicmFyeVwiIC8qIExpYnJhcnkgKi8pIHtcbiAgICByZXR1cm4gXCJsaWJyYXJ5XCIgLyogTGlicmFyeSAqLztcbiAgfSBlbHNlIGlmIChlbmdpbmVUeXBlID09PSBcImJpbmFyeVwiIC8qIEJpbmFyeSAqLykge1xuICAgIHJldHVybiBcImJpbmFyeVwiIC8qIEJpbmFyeSAqLztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5fX25hbWUoZ2V0RW5naW5lVHlwZUZyb21FbnZWYXIsIFwiZ2V0RW5naW5lVHlwZUZyb21FbnZWYXJcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvY2xpL3V0aWxzLnRzXG52YXIgaW1wb3J0X2FyZyA9IF9fdG9FU00ocmVxdWlyZV9hcmcoKSk7XG52YXIgaW1wb3J0X3N0cmlwX2luZGVudCA9IF9fdG9FU00ocmVxdWlyZV9zdHJpcF9pbmRlbnQoKSk7XG5mdW5jdGlvbiBpc0Vycm9yKHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0IGluc3RhbmNlb2YgRXJyb3I7XG59XG5fX25hbWUoaXNFcnJvciwgXCJpc0Vycm9yXCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL2xvZ2dlci50c1xudmFyIGxvZ2dlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsb2dnZXJfZXhwb3J0cywge1xuICBlcnJvcjogKCkgPT4gZXJyb3IsXG4gIGluZm86ICgpID0+IGluZm8sXG4gIGxvZzogKCkgPT4gbG9nMyxcbiAgcXVlcnk6ICgpID0+IHF1ZXJ5LFxuICBzaG91bGQ6ICgpID0+IHNob3VsZCxcbiAgdGFnczogKCkgPT4gdGFncyxcbiAgd2FybjogKCkgPT4gd2FyblxufSk7XG52YXIgaW1wb3J0X2NoYWxrNyA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgdGFncyA9IHtcbiAgZXJyb3I6IGltcG9ydF9jaGFsazcuZGVmYXVsdC5yZWQoXCJwcmlzbWE6ZXJyb3JcIiksXG4gIHdhcm46IGltcG9ydF9jaGFsazcuZGVmYXVsdC55ZWxsb3coXCJwcmlzbWE6d2FyblwiKSxcbiAgaW5mbzogaW1wb3J0X2NoYWxrNy5kZWZhdWx0LmN5YW4oXCJwcmlzbWE6aW5mb1wiKSxcbiAgcXVlcnk6IGltcG9ydF9jaGFsazcuZGVmYXVsdC5ibHVlKFwicHJpc21hOnF1ZXJ5XCIpXG59O1xudmFyIHNob3VsZCA9IHtcbiAgd2FybjogIXByb2Nlc3MuZW52LlBSSVNNQV9ESVNBQkxFX1dBUk5JTkdTXG59O1xuZnVuY3Rpb24gbG9nMyguLi5kYXRhKSB7XG4gIGNvbnNvbGUubG9nKC4uLmRhdGEpO1xufVxuX19uYW1lKGxvZzMsIFwibG9nXCIpO1xuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICBpZiAoc2hvdWxkLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4oYCR7dGFncy53YXJufSAke21lc3NhZ2V9YCwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICB9XG59XG5fX25hbWUod2FybiwgXCJ3YXJuXCIpO1xuZnVuY3Rpb24gaW5mbyhtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICBjb25zb2xlLmluZm8oYCR7dGFncy5pbmZvfSAke21lc3NhZ2V9YCwgLi4ub3B0aW9uYWxQYXJhbXMpO1xufVxuX19uYW1lKGluZm8sIFwiaW5mb1wiKTtcbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7dGFncy5lcnJvcn0gJHttZXNzYWdlfWAsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbn1cbl9fbmFtZShlcnJvciwgXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHF1ZXJ5KG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gIGNvbnNvbGUubG9nKGAke3RhZ3MucXVlcnl9ICR7bWVzc2FnZX1gLCAuLi5vcHRpb25hbFBhcmFtcyk7XG59XG5fX25hbWUocXVlcnksIFwicXVlcnlcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvdXRpbHMvYXNzZXJ0TmV2ZXIudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKGFyZzIsIGVycm9yTWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbn1cbl9fbmFtZShhc3NlcnROZXZlciwgXCJhc3NlcnROZXZlclwiKTtcblxuLy8gLi4vaW50ZXJuYWxzL3NyYy91dGlscy9jYWxsT25jZS50c1xuZnVuY3Rpb24gY2FsbE9uY2UoZm4pIHtcbiAgbGV0IHJlc3VsdDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xufVxuX19uYW1lKGNhbGxPbmNlLCBcImNhbGxPbmNlXCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL3V0aWxzL2tleUJ5LnRzXG52YXIga2V5QnkyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY29sbGVjdGlvbiwgaXRlcmF0ZWUpID0+IHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBhY2NbaXRlcmF0ZWUoY3VycildID0gY3VycjtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59LCBcImtleUJ5XCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL3dhcm5PbmNlLnRzXG52YXIgYWxyZWFkeVdhcm5lZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgd2Fybk9uY2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChrZXksIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFhbHJlYWR5V2FybmVkLmhhcyhrZXkpKSB7XG4gICAgYWxyZWFkeVdhcm5lZC5hZGQoa2V5KTtcbiAgICB3YXJuKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICB9XG59LCBcIndhcm5PbmNlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9nZXRQcmlzbWFDbGllbnQudHNcbnZhciBpbXBvcnRfYXN5bmNfaG9va3MgPSByZXF1aXJlKFwiYXN5bmNfaG9va3NcIik7XG52YXIgaW1wb3J0X2ZzOSA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfcGF0aDUgPSBfX3RvRVNNKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NxbC10ZW1wbGF0ZS10YWdANS4wLjMvbm9kZV9tb2R1bGVzL3NxbC10ZW1wbGF0ZS10YWcvZGlzdC9pbmRleC5qc1xudmFyIFNxbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmF3U3RyaW5ncywgcmF3VmFsdWVzKSB7XG4gICAgaWYgKHJhd1N0cmluZ3MubGVuZ3RoIC0gMSAhPT0gcmF3VmFsdWVzLmxlbmd0aCkge1xuICAgICAgaWYgKHJhd1N0cmluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCAxIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7cmF3U3RyaW5ncy5sZW5ndGh9IHN0cmluZ3MgdG8gaGF2ZSAke3Jhd1N0cmluZ3MubGVuZ3RoIC0gMX0gdmFsdWVzYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlc0xlbmd0aCA9IHJhd1ZhbHVlcy5yZWR1Y2UoKGxlbiwgdmFsdWUpID0+IGxlbiArICh2YWx1ZSBpbnN0YW5jZW9mIFNxbCA/IHZhbHVlLnZhbHVlcy5sZW5ndGggOiAxKSwgMCk7XG4gICAgdGhpcy52YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzTGVuZ3RoKTtcbiAgICB0aGlzLnN0cmluZ3MgPSBuZXcgQXJyYXkodmFsdWVzTGVuZ3RoICsgMSk7XG4gICAgdGhpcy5zdHJpbmdzWzBdID0gcmF3U3RyaW5nc1swXTtcbiAgICBsZXQgaSA9IDAsIHBvcyA9IDA7XG4gICAgd2hpbGUgKGkgPCByYXdWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHJhd1ZhbHVlc1tpKytdO1xuICAgICAgY29uc3QgcmF3U3RyaW5nID0gcmF3U3RyaW5nc1tpXTtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFNxbCkge1xuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSArPSBjaGlsZC5zdHJpbmdzWzBdO1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGQudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudmFsdWVzW3BvcysrXSA9IGNoaWxkLnZhbHVlc1tjaGlsZEluZGV4KytdO1xuICAgICAgICAgIHRoaXMuc3RyaW5nc1twb3NdID0gY2hpbGQuc3RyaW5nc1tjaGlsZEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSArPSByYXdTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlc1twb3MrK10gPSBjaGlsZDtcbiAgICAgICAgdGhpcy5zdHJpbmdzW3Bvc10gPSByYXdTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIGxldCBpID0gMSwgdmFsdWUgPSB0aGlzLnN0cmluZ3NbMF07XG4gICAgd2hpbGUgKGkgPCB0aGlzLnN0cmluZ3MubGVuZ3RoKVxuICAgICAgdmFsdWUgKz0gYCQke2l9JHt0aGlzLnN0cmluZ3NbaSsrXX1gO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXQgc3FsKCkge1xuICAgIGxldCBpID0gMSwgdmFsdWUgPSB0aGlzLnN0cmluZ3NbMF07XG4gICAgd2hpbGUgKGkgPCB0aGlzLnN0cmluZ3MubGVuZ3RoKVxuICAgICAgdmFsdWUgKz0gYD8ke3RoaXMuc3RyaW5nc1tpKytdfWA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgIHNxbDogdGhpcy5zcWwsXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gICAgfTtcbiAgfVxufTtcbl9fbmFtZShTcWwsIFwiU3FsXCIpO1xuZnVuY3Rpb24gam9pbih2YWx1ZXMsIHNlcGFyYXRvciA9IFwiLFwiLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGBqb2luKFtdKWAgdG8gYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbXVsdGlwbGUgZWxlbWVudHMsIGJ1dCBnb3QgYW4gZW1wdHkgYXJyYXlcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBTcWwoW3ByZWZpeCwgLi4uQXJyYXkodmFsdWVzLmxlbmd0aCAtIDEpLmZpbGwoc2VwYXJhdG9yKSwgc3VmZml4XSwgdmFsdWVzKTtcbn1cbl9fbmFtZShqb2luLCBcImpvaW5cIik7XG5mdW5jdGlvbiByYXcodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTcWwoW3ZhbHVlXSwgW10pO1xufVxuX19uYW1lKHJhdywgXCJyYXdcIik7XG52YXIgZW1wdHkgPSByYXcoXCJcIik7XG5mdW5jdGlvbiBzcWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU3FsKHN0cmluZ3MsIHZhbHVlcyk7XG59XG5fX25hbWUoc3FsLCBcInNxbFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvZXh0ZXJuYWxUb0ludGVybmFsRG1tZi50c1xudmFyIGltcG9ydF9wbHVyYWxpemUgPSBfX3RvRVNNKHJlcXVpcmVfcGx1cmFsaXplKCkpO1xuZnVuY3Rpb24gZXh0ZXJuYWxUb0ludGVybmFsRG1tZihkb2N1bWVudDIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kb2N1bWVudDIsXG4gICAgbWFwcGluZ3M6IGdldE1hcHBpbmdzKGRvY3VtZW50Mi5tYXBwaW5ncywgZG9jdW1lbnQyLmRhdGFtb2RlbClcbiAgfTtcbn1cbl9fbmFtZShleHRlcm5hbFRvSW50ZXJuYWxEbW1mLCBcImV4dGVybmFsVG9JbnRlcm5hbERtbWZcIik7XG5mdW5jdGlvbiBnZXRNYXBwaW5ncyhtYXBwaW5ncywgZGF0YW1vZGVsKSB7XG4gIGNvbnN0IG1vZGVsT3BlcmF0aW9ucyA9IG1hcHBpbmdzLm1vZGVsT3BlcmF0aW9ucy5maWx0ZXIoKG1hcHBpbmcpID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IGRhdGFtb2RlbC5tb2RlbHMuZmluZCgobSkgPT4gbS5uYW1lID09PSBtYXBwaW5nLm1vZGVsKTtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcHBpbmcgd2l0aG91dCBtb2RlbCAke21hcHBpbmcubW9kZWx9YCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5maWVsZHMuc29tZSgoZikgPT4gZi5raW5kICE9PSBcIm9iamVjdFwiKTtcbiAgfSkubWFwKChtYXBwaW5nKSA9PiAoe1xuICAgIG1vZGVsOiBtYXBwaW5nLm1vZGVsLFxuICAgIHBsdXJhbDogKDAsIGltcG9ydF9wbHVyYWxpemUuZGVmYXVsdCkobG93ZXJDYXNlKG1hcHBpbmcubW9kZWwpKSxcbiAgICBmaW5kVW5pcXVlOiBtYXBwaW5nLmZpbmRVbmlxdWUgfHwgbWFwcGluZy5maW5kU2luZ2xlLFxuICAgIGZpbmRGaXJzdDogbWFwcGluZy5maW5kRmlyc3QsXG4gICAgZmluZE1hbnk6IG1hcHBpbmcuZmluZE1hbnksXG4gICAgY3JlYXRlOiBtYXBwaW5nLmNyZWF0ZU9uZSB8fCBtYXBwaW5nLmNyZWF0ZVNpbmdsZSB8fCBtYXBwaW5nLmNyZWF0ZSxcbiAgICBjcmVhdGVNYW55OiBtYXBwaW5nLmNyZWF0ZU1hbnksXG4gICAgZGVsZXRlOiBtYXBwaW5nLmRlbGV0ZU9uZSB8fCBtYXBwaW5nLmRlbGV0ZVNpbmdsZSB8fCBtYXBwaW5nLmRlbGV0ZSxcbiAgICB1cGRhdGU6IG1hcHBpbmcudXBkYXRlT25lIHx8IG1hcHBpbmcudXBkYXRlU2luZ2xlIHx8IG1hcHBpbmcudXBkYXRlLFxuICAgIGRlbGV0ZU1hbnk6IG1hcHBpbmcuZGVsZXRlTWFueSxcbiAgICB1cGRhdGVNYW55OiBtYXBwaW5nLnVwZGF0ZU1hbnksXG4gICAgdXBzZXJ0OiBtYXBwaW5nLnVwc2VydE9uZSB8fCBtYXBwaW5nLnVwc2VydFNpbmdsZSB8fCBtYXBwaW5nLnVwc2VydCxcbiAgICBhZ2dyZWdhdGU6IG1hcHBpbmcuYWdncmVnYXRlLFxuICAgIGdyb3VwQnk6IG1hcHBpbmcuZ3JvdXBCeSxcbiAgICBmaW5kUmF3OiBtYXBwaW5nLmZpbmRSYXcsXG4gICAgYWdncmVnYXRlUmF3OiBtYXBwaW5nLmFnZ3JlZ2F0ZVJhd1xuICB9KSk7XG4gIHJldHVybiB7XG4gICAgbW9kZWxPcGVyYXRpb25zLFxuICAgIG90aGVyT3BlcmF0aW9uczogbWFwcGluZ3Mub3RoZXJPcGVyYXRpb25zXG4gIH07XG59XG5fX25hbWUoZ2V0TWFwcGluZ3MsIFwiZ2V0TWFwcGluZ3NcIik7XG5cbi8vIHNyYy9nZW5lcmF0aW9uL2dldERNTUYudHNcbmZ1bmN0aW9uIGdldFByaXNtYUNsaWVudERNTUYoZG1tZikge1xuICByZXR1cm4gZXh0ZXJuYWxUb0ludGVybmFsRG1tZihkbW1mKTtcbn1cbl9fbmFtZShnZXRQcmlzbWFDbGllbnRETU1GLCBcImdldFByaXNtYUNsaWVudERNTUZcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NsaWVudEFjdGlvbnMudHNcbnZhciBjbGllbnRPbmx5QWN0aW9ucyA9IHtcbiAgZmluZFVuaXF1ZU9yVGhyb3c6IHtcbiAgICB3cmFwcGVkQWN0aW9uOiBETU1GLk1vZGVsQWN0aW9uLmZpbmRVbmlxdWVcbiAgfSxcbiAgZmluZEZpcnN0T3JUaHJvdzoge1xuICAgIHdyYXBwZWRBY3Rpb246IERNTUYuTW9kZWxBY3Rpb24uZmluZEZpcnN0XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREbW1mQWN0aW9uTmFtZShuYW1lKSB7XG4gIGlmIChpc0NsaWVudE9ubHlBY3Rpb24obmFtZSkpIHtcbiAgICByZXR1cm4gY2xpZW50T25seUFjdGlvbnNbbmFtZV0ud3JhcHBlZEFjdGlvbjtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbl9fbmFtZShnZXREbW1mQWN0aW9uTmFtZSwgXCJnZXREbW1mQWN0aW9uTmFtZVwiKTtcbmZ1bmN0aW9uIGlzQ2xpZW50T25seUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjbGllbnRPbmx5QWN0aW9ucywgYWN0aW9uKTtcbn1cbl9fbmFtZShpc0NsaWVudE9ubHlBY3Rpb24sIFwiaXNDbGllbnRPbmx5QWN0aW9uXCIpO1xudmFyIGFsbENsaWVudE1vZGVsQWN0aW9ucyA9IE9iamVjdC5rZXlzKERNTUYuTW9kZWxBY3Rpb24pLmNvbmNhdChcbiAgT2JqZWN0LmtleXMoY2xpZW50T25seUFjdGlvbnMpXG4pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhY2t0cmFjZS1wYXJzZXJAMC4xLjEwL25vZGVfbW9kdWxlcy9zdGFja3RyYWNlLXBhcnNlci9kaXN0L3N0YWNrLXRyYWNlLXBhcnNlci5lc20uanNcbnZhciBVTktOT1dOX0ZVTkNUSU9OID0gXCI8dW5rbm93bj5cIjtcbmZ1bmN0aW9uIHBhcnNlKHN0YWNrU3RyaW5nKSB7XG4gIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICByZXR1cm4gbGluZXMucmVkdWNlKGZ1bmN0aW9uKHN0YWNrLCBsaW5lKSB7XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gcGFyc2VDaHJvbWUobGluZSkgfHwgcGFyc2VXaW5qcyhsaW5lKSB8fCBwYXJzZUdlY2tvKGxpbmUpIHx8IHBhcnNlTm9kZShsaW5lKSB8fCBwYXJzZUpTQyhsaW5lKTtcbiAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgIHN0YWNrLnB1c2gocGFyc2VSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG4gIH0sIFtdKTtcbn1cbl9fbmFtZShwYXJzZSwgXCJwYXJzZVwiKTtcbnZhciBjaHJvbWVSZSA9IC9eXFxzKmF0ICguKj8pID9cXCgoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWUtZXh0ZW5zaW9ufG5hdGl2ZXxldmFsfHdlYnBhY2t8PGFub255bW91cz58XFwvfFthLXpdOlxcXFx8XFxcXFxcXFwpLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xudmFyIGNocm9tZUV2YWxSZSA9IC9cXCgoXFxTKikoPzo6KFxcZCspKSg/OjooXFxkKykpXFwpLztcbmZ1bmN0aW9uIHBhcnNlQ2hyb21lKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gY2hyb21lUmUuZXhlYyhsaW5lKTtcbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpc05hdGl2ZSA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoXCJuYXRpdmVcIikgPT09IDA7XG4gIHZhciBpc0V2YWwgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKFwiZXZhbFwiKSA9PT0gMDtcbiAgdmFyIHN1Ym1hdGNoID0gY2hyb21lRXZhbFJlLmV4ZWMocGFydHNbMl0pO1xuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcbiAgICBwYXJ0c1syXSA9IHN1Ym1hdGNoWzFdO1xuICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMl07XG4gICAgcGFydHNbNF0gPSBzdWJtYXRjaFszXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGU6ICFpc05hdGl2ZSA/IHBhcnRzWzJdIDogbnVsbCxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgbGluZU51bWJlcjogcGFydHNbM10gPyArcGFydHNbM10gOiBudWxsLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5fX25hbWUocGFyc2VDaHJvbWUsIFwicGFyc2VDaHJvbWVcIik7XG52YXIgd2luanNSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweHxodHRwcz98d2VicGFja3xibG9iKTouKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuZnVuY3Rpb24gcGFyc2VXaW5qcyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IHdpbmpzUmUuZXhlYyhsaW5lKTtcbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbMl0sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IFtdLFxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1szXSxcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxuICB9O1xufVxuX19uYW1lKHBhcnNlV2luanMsIFwicGFyc2VXaW5qc1wiKTtcbnZhciBnZWNrb1JlID0gL15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKSgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXx3ZWJwYWNrfHJlc291cmNlfFxcW25hdGl2ZSkuKj98W15AXSpidW5kbGUpKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFxzKiQvaTtcbnZhciBnZWNrb0V2YWxSZSA9IC8oXFxTKykgbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbC9pO1xuZnVuY3Rpb24gcGFyc2VHZWNrbyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGdlY2tvUmUuZXhlYyhsaW5lKTtcbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKFwiID4gZXZhbFwiKSA+IC0xO1xuICB2YXIgc3VibWF0Y2ggPSBnZWNrb0V2YWxSZS5leGVjKHBhcnRzWzNdKTtcbiAgaWYgKGlzRXZhbCAmJiBzdWJtYXRjaCAhPSBudWxsKSB7XG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsxXTtcbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzJdO1xuICAgIHBhcnRzWzVdID0gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzNdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KFwiLFwiKSA6IFtdLFxuICAgIGxpbmVOdW1iZXI6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbCxcbiAgICBjb2x1bW46IHBhcnRzWzVdID8gK3BhcnRzWzVdIDogbnVsbFxuICB9O1xufVxuX19uYW1lKHBhcnNlR2Vja28sIFwicGFyc2VHZWNrb1wiKTtcbnZhciBqYXZhU2NyaXB0Q29yZVJlID0gL15cXHMqKD86KFteQF0qKSg/OlxcKCguKj8pXFwpKT9AKT8oXFxTLio/KTooXFxkKykoPzo6KFxcZCspKT9cXHMqJC9pO1xuZnVuY3Rpb24gcGFyc2VKU0MobGluZSkge1xuICB2YXIgcGFydHMgPSBqYXZhU2NyaXB0Q29yZVJlLmV4ZWMobGluZSk7XG4gIGlmICghcGFydHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzNdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBbXSxcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbNF0sXG4gICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IG51bGxcbiAgfTtcbn1cbl9fbmFtZShwYXJzZUpTQywgXCJwYXJzZUpTQ1wiKTtcbnZhciBub2RlUmUgPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/W15cXFxcL10rKD86IFxcW2FzIFxcUytcXF0pPykgKT9cXCg/KC4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XG5mdW5jdGlvbiBwYXJzZU5vZGUobGluZSkge1xuICB2YXIgcGFydHMgPSBub2RlUmUuZXhlYyhsaW5lKTtcbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbMl0sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IFtdLFxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1szXSxcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxuICB9O1xufVxuX19uYW1lKHBhcnNlTm9kZSwgXCJwYXJzZU5vZGVcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL0NhbGxTaXRlLnRzXG52YXIgRGlzYWJsZWRDYWxsU2l0ZSA9IGNsYXNzIHtcbiAgZ2V0TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5fX25hbWUoRGlzYWJsZWRDYWxsU2l0ZSwgXCJEaXNhYmxlZENhbGxTaXRlXCIpO1xudmFyIEVuYWJsZWRDYWxsU2l0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgfVxuICBnZXRMb2NhdGlvbigpIHtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuX2Vycm9yLnN0YWNrO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGFja0ZyYW1lcyA9IHBhcnNlKHN0YWNrKTtcbiAgICBjb25zdCBmcmFtZSA9IHN0YWNrRnJhbWVzLmZpbmQoKHQpID0+IHtcbiAgICAgIHJldHVybiB0LmZpbGUgJiYgdC5maWxlICE9PSBcIjxhbm9ueW1vdXM+XCIgJiYgIXQuZmlsZS5pbmNsdWRlcyhcIkBwcmlzbWFcIikgJiYgIXQuZmlsZS5pbmNsdWRlcyhcImdldFByaXNtYUNsaWVudFwiKSAmJiAhdC5maWxlLnN0YXJ0c1dpdGgoXCJpbnRlcm5hbC9cIikgJiYgIXQubWV0aG9kTmFtZS5pbmNsdWRlcyhcIm5ldyBcIikgJiYgIXQubWV0aG9kTmFtZS5pbmNsdWRlcyhcImdldENhbGxTaXRlXCIpICYmICF0Lm1ldGhvZE5hbWUuaW5jbHVkZXMoXCJQcm94eS5cIikgJiYgdC5tZXRob2ROYW1lLnNwbGl0KFwiLlwiKS5sZW5ndGggPCA0O1xuICAgIH0pO1xuICAgIGlmICghZnJhbWUgfHwgIWZyYW1lLmZpbGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsZU5hbWU6IGZyYW1lLmZpbGUsXG4gICAgICBsaW5lTnVtYmVyOiBmcmFtZS5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiBmcmFtZS5jb2x1bW5cbiAgICB9O1xuICB9XG59O1xuX19uYW1lKEVuYWJsZWRDYWxsU2l0ZSwgXCJFbmFibGVkQ2FsbFNpdGVcIik7XG5mdW5jdGlvbiBnZXRDYWxsU2l0ZShlcnJvckZvcm1hdCkge1xuICBpZiAoZXJyb3JGb3JtYXQgPT09IFwibWluaW1hbFwiKSB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENhbGxTaXRlKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFbmFibGVkQ2FsbFNpdGUoKTtcbn1cbl9fbmFtZShnZXRDYWxsU2l0ZSwgXCJnZXRDYWxsU2l0ZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9yZXF1ZXN0L2NyZWF0ZVByaXNtYVByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVByaXNtYVByb21pc2UoY2FsbGJhY2spIHtcbiAgbGV0IHByb21pc2U7XG4gIGNvbnN0IF9jYWxsYmFjayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHR4SWQsIGxvY2spID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHByb21pc2UgIT0gbnVsbCA/IHByb21pc2UgOiBwcm9taXNlID0gY2FsbGJhY2sodHhJZCwgbG9jayk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IyKTtcbiAgICB9XG4gIH0sIFwiX2NhbGxiYWNrXCIpO1xuICByZXR1cm4ge1xuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHR4SWQpIHtcbiAgICAgIHJldHVybiBfY2FsbGJhY2sodHhJZCwgdm9pZCAwKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCB0eElkKTtcbiAgICB9LFxuICAgIGNhdGNoKG9uUmVqZWN0ZWQsIHR4SWQpIHtcbiAgICAgIHJldHVybiBfY2FsbGJhY2sodHhJZCwgdm9pZCAwKS5jYXRjaChvblJlamVjdGVkLCB0eElkKTtcbiAgICB9LFxuICAgIGZpbmFsbHkob25GaW5hbGx5LCB0eElkKSB7XG4gICAgICByZXR1cm4gX2NhbGxiYWNrKHR4SWQsIHZvaWQgMCkuZmluYWxseShvbkZpbmFsbHksIHR4SWQpO1xuICAgIH0sXG4gICAgcmVxdWVzdFRyYW5zYWN0aW9uKHR4SWQsIGxvY2spIHtcbiAgICAgIGNvbnN0IHByb21pc2UyID0gX2NhbGxiYWNrKHR4SWQsIGxvY2spO1xuICAgICAgaWYgKHByb21pc2UyLnJlcXVlc3RUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTIucmVxdWVzdFRyYW5zYWN0aW9uKHR4SWQsIGxvY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2UyO1xuICAgIH0sXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiUHJpc21hUHJvbWlzZVwiXG4gIH07XG59XG5fX25hbWUoY3JlYXRlUHJpc21hUHJvbWlzZSwgXCJjcmVhdGVQcmlzbWFQcm9taXNlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FnZ3JlZ2F0ZXMvdXRpbHMvYWdncmVnYXRlTWFwLnRzXG52YXIgYWdncmVnYXRlTWFwID0ge1xuICBfYXZnOiB0cnVlLFxuICBfY291bnQ6IHRydWUsXG4gIF9zdW06IHRydWUsXG4gIF9taW46IHRydWUsXG4gIF9tYXg6IHRydWVcbn07XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYWdncmVnYXRlcy9hZ2dyZWdhdGUudHNcbmZ1bmN0aW9uIGRlc3VnYXJVc2VyQXJncyh1c2VyQXJncykge1xuICBjb25zdCBfdXNlckFyZ3MgPSBkZXN1Z2FyQ291bnRJblVzZXJBcmdzKHVzZXJBcmdzKTtcbiAgY29uc3QgdXNlckFyZ3NFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoX3VzZXJBcmdzKTtcbiAgcmV0dXJuIHVzZXJBcmdzRW50cmllcy5yZWR1Y2UoXG4gICAgKGFnZ3JlZ2F0ZUFyZ3MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGFnZ3JlZ2F0ZU1hcFtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYWdncmVnYXRlQXJnc1tcInNlbGVjdFwiXVtrZXldID0geyBzZWxlY3Q6IHZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVBcmdzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZ2dyZWdhdGVBcmdzO1xuICAgIH0sXG4gICAgeyBzZWxlY3Q6IHt9IH1cbiAgKTtcbn1cbl9fbmFtZShkZXN1Z2FyVXNlckFyZ3MsIFwiZGVzdWdhclVzZXJBcmdzXCIpO1xuZnVuY3Rpb24gZGVzdWdhckNvdW50SW5Vc2VyQXJncyh1c2VyQXJncykge1xuICBpZiAodHlwZW9mIHVzZXJBcmdzW1wiX2NvdW50XCJdID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB7IC4uLnVzZXJBcmdzLCBfY291bnQ6IHsgX2FsbDogdXNlckFyZ3NbXCJfY291bnRcIl0gfSB9O1xuICB9XG4gIHJldHVybiB1c2VyQXJncztcbn1cbl9fbmFtZShkZXN1Z2FyQ291bnRJblVzZXJBcmdzLCBcImRlc3VnYXJDb3VudEluVXNlckFyZ3NcIik7XG5mdW5jdGlvbiBjcmVhdGVVbnBhY2tlcih1c2VyQXJncykge1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIHVzZXJBcmdzW1wiX2NvdW50XCJdID09PSBcImJvb2xlYW5cIikge1xuICAgICAgZGF0YVtcIl9jb3VudFwiXSA9IGRhdGFbXCJfY291bnRcIl1bXCJfYWxsXCJdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn1cbl9fbmFtZShjcmVhdGVVbnBhY2tlciwgXCJjcmVhdGVVbnBhY2tlclwiKTtcbmZ1bmN0aW9uIGFnZ3JlZ2F0ZShjbGllbnQsIHVzZXJBcmdzLCBtb2RlbEFjdGlvbikge1xuICBjb25zdCBhZ2dyZWdhdGVBcmdzID0gZGVzdWdhclVzZXJBcmdzKHVzZXJBcmdzICE9IG51bGwgPyB1c2VyQXJncyA6IHt9KTtcbiAgY29uc3QgYWdncmVnYXRlVW5wYWNrZXIgPSBjcmVhdGVVbnBhY2tlcih1c2VyQXJncyAhPSBudWxsID8gdXNlckFyZ3MgOiB7fSk7XG4gIHJldHVybiBtb2RlbEFjdGlvbih7XG4gICAgYWN0aW9uOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIHVucGFja2VyOiBhZ2dyZWdhdGVVbnBhY2tlclxuICB9KShhZ2dyZWdhdGVBcmdzKTtcbn1cbl9fbmFtZShhZ2dyZWdhdGUsIFwiYWdncmVnYXRlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FnZ3JlZ2F0ZXMvY291bnQudHNcbmZ1bmN0aW9uIGNvdW50KGNsaWVudCwgdXNlckFyZ3MsIG1vZGVsQWN0aW9uKSB7XG4gIGNvbnN0IHsgc2VsZWN0LCAuLi5fdXNlckFyZ3MgfSA9IHVzZXJBcmdzICE9IG51bGwgPyB1c2VyQXJncyA6IHt9O1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBhZ2dyZWdhdGUoXG4gICAgICBjbGllbnQsXG4gICAgICB7IC4uLl91c2VyQXJncywgX2NvdW50OiBzZWxlY3QgfSxcbiAgICAgIChwKSA9PiBtb2RlbEFjdGlvbih7IC4uLnAsIGFjdGlvbjogXCJjb3VudFwiLCB1bnBhY2tlcjogKGRhdGEpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgcmV0dXJuIChfYTMgPSBwLnVucGFja2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwocCwgZGF0YSlbXCJfY291bnRcIl07XG4gICAgICB9IH0pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWdncmVnYXRlKFxuICAgICAgY2xpZW50LFxuICAgICAgeyAuLi5fdXNlckFyZ3MsIF9jb3VudDogeyBfYWxsOiB0cnVlIH0gfSxcbiAgICAgIChwKSA9PiBtb2RlbEFjdGlvbih7IC4uLnAsIGFjdGlvbjogXCJjb3VudFwiLCB1bnBhY2tlcjogKGRhdGEpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgcmV0dXJuIChfYTMgPSBwLnVucGFja2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwocCwgZGF0YSlbXCJfY291bnRcIl1bXCJfYWxsXCJdO1xuICAgICAgfSB9KVxuICAgICk7XG4gIH1cbn1cbl9fbmFtZShjb3VudCwgXCJjb3VudFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9hZ2dyZWdhdGVzL2dyb3VwQnkudHNcbmZ1bmN0aW9uIGRlc3VnYXJVc2VyQXJnczIodXNlckFyZ3MpIHtcbiAgY29uc3QgX3VzZXJBcmdzID0gZGVzdWdhclVzZXJBcmdzKHVzZXJBcmdzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodXNlckFyZ3NbXCJieVwiXSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB1c2VyQXJnc1tcImJ5XCJdKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBfdXNlckFyZ3NbXCJzZWxlY3RcIl1ba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBfdXNlckFyZ3M7XG59XG5fX25hbWUoZGVzdWdhclVzZXJBcmdzMiwgXCJkZXN1Z2FyVXNlckFyZ3NcIik7XG5mdW5jdGlvbiBjcmVhdGVVbnBhY2tlcjIodXNlckFyZ3MpIHtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB1c2VyQXJnc1tcIl9jb3VudFwiXSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGRhdGEuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgIHJvd1tcIl9jb3VudFwiXSA9IHJvd1tcIl9jb3VudFwiXVtcIl9hbGxcIl07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG59XG5fX25hbWUoY3JlYXRlVW5wYWNrZXIyLCBcImNyZWF0ZVVucGFja2VyXCIpO1xuZnVuY3Rpb24gZ3JvdXBCeShjbGllbnQsIHVzZXJBcmdzLCBtb2RlbEFjdGlvbikge1xuICBjb25zdCBncm91cEJ5QXJncyA9IGRlc3VnYXJVc2VyQXJnczIodXNlckFyZ3MgIT0gbnVsbCA/IHVzZXJBcmdzIDoge30pO1xuICBjb25zdCBncm91cEJ5VW5wYWNrZXIgPSBjcmVhdGVVbnBhY2tlcjIodXNlckFyZ3MgIT0gbnVsbCA/IHVzZXJBcmdzIDoge30pO1xuICByZXR1cm4gbW9kZWxBY3Rpb24oe1xuICAgIGFjdGlvbjogXCJncm91cEJ5XCIsXG4gICAgdW5wYWNrZXI6IGdyb3VwQnlVbnBhY2tlclxuICB9KShncm91cEJ5QXJncyk7XG59XG5fX25hbWUoZ3JvdXBCeSwgXCJncm91cEJ5XCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FwcGx5QWdncmVnYXRlcy50c1xuZnVuY3Rpb24gYXBwbHlBZ2dyZWdhdGVzKGNsaWVudCwgYWN0aW9uLCBtb2RlbEFjdGlvbikge1xuICBpZiAoYWN0aW9uID09PSBcImFnZ3JlZ2F0ZVwiKVxuICAgIHJldHVybiAodXNlckFyZ3MpID0+IGFnZ3JlZ2F0ZShjbGllbnQsIHVzZXJBcmdzLCBtb2RlbEFjdGlvbik7XG4gIGlmIChhY3Rpb24gPT09IFwiY291bnRcIilcbiAgICByZXR1cm4gKHVzZXJBcmdzKSA9PiBjb3VudChjbGllbnQsIHVzZXJBcmdzLCBtb2RlbEFjdGlvbik7XG4gIGlmIChhY3Rpb24gPT09IFwiZ3JvdXBCeVwiKVxuICAgIHJldHVybiAodXNlckFyZ3MpID0+IGdyb3VwQnkoY2xpZW50LCB1c2VyQXJncywgbW9kZWxBY3Rpb24pO1xuICByZXR1cm4gdm9pZCAwO1xufVxuX19uYW1lKGFwcGx5QWdncmVnYXRlcywgXCJhcHBseUFnZ3JlZ2F0ZXNcIik7XG5cbi8vIHNyYy9ydW50aW1lL3F1ZXJ5LnRzXG52YXIgaW1wb3J0X2NoYWxrMTEgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9pbmRlbnRfc3RyaW5nNCA9IF9fdG9FU00ocmVxdWlyZV9pbmRlbnRfc3RyaW5nKCkpO1xudmFyIGltcG9ydF9zdHJpcF9hbnNpMyA9IF9fdG9FU00ocmVxdWlyZV9zdHJpcF9hbnNpKCkpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9jcmVhdGVFcnJvck1lc3NhZ2VXaXRoQ29udGV4dC50c1xudmFyIGltcG9ydF9jaGFsazkgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9pbmRlbnRfc3RyaW5nMyA9IF9fdG9FU00ocmVxdWlyZV9pbmRlbnRfc3RyaW5nKCkpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9Tb3VyY2VGaWxlU2xpY2UudHNcbnZhciBpbXBvcnRfZnM4ID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xuXG4vLyBzcmMvcnVudGltZS9oaWdobGlnaHQvdGhlbWUudHNcbnZhciBpbXBvcnRfY2hhbGs4ID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciBvcmFuZ2UgPSBpbXBvcnRfY2hhbGs4LmRlZmF1bHQucmdiKDI0NiwgMTQ1LCA5NSk7XG52YXIgZGFya0JyaWdodEJsdWUgPSBpbXBvcnRfY2hhbGs4LmRlZmF1bHQucmdiKDEwNywgMTM5LCAxNDApO1xudmFyIGJsdWUgPSBpbXBvcnRfY2hhbGs4LmRlZmF1bHQuY3lhbjtcbnZhciBicmlnaHRCbHVlID0gaW1wb3J0X2NoYWxrOC5kZWZhdWx0LnJnYigxMjcsIDE1NSwgMTU1KTtcbnZhciBpZGVudGl0eSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0cikgPT4gc3RyLCBcImlkZW50aXR5XCIpO1xudmFyIHRoZW1lID0ge1xuICBrZXl3b3JkOiBibHVlLFxuICBlbnRpdHk6IGJsdWUsXG4gIHZhbHVlOiBicmlnaHRCbHVlLFxuICBwdW5jdHVhdGlvbjogZGFya0JyaWdodEJsdWUsXG4gIGRpcmVjdGl2ZTogYmx1ZSxcbiAgZnVuY3Rpb246IGJsdWUsXG4gIHZhcmlhYmxlOiBicmlnaHRCbHVlLFxuICBzdHJpbmc6IGltcG9ydF9jaGFsazguZGVmYXVsdC5ncmVlbkJyaWdodCxcbiAgYm9vbGVhbjogb3JhbmdlLFxuICBudW1iZXI6IGltcG9ydF9jaGFsazguZGVmYXVsdC5jeWFuLFxuICBjb21tZW50OiBpbXBvcnRfY2hhbGs4LmRlZmF1bHQuZ3JleVxufTtcblxuLy8gc3JjL3J1bnRpbWUvaGlnaGxpZ2h0L3ByaXNtLnRzXG52YXIgX3NlbGYgPSB7fTtcbnZhciB1bmlxdWVJZCA9IDA7XG52YXIgUHJpc20gPSB7XG4gIG1hbnVhbDogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20ubWFudWFsLFxuICBkaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXI6IF9zZWxmLlByaXNtICYmIF9zZWxmLlByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcixcbiAgdXRpbDoge1xuICAgIGVuY29kZTogZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgICBpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgY29uc3QgYW55VG9rZW5zID0gdG9rZW5zO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuKGFueVRva2Vucy50eXBlLCBQcmlzbS51dGlsLmVuY29kZShhbnlUb2tlbnMuY29udGVudCksIGFueVRva2Vucy5hbGlhcyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChQcmlzbS51dGlsLmVuY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIH0sXG4gICAgb2JqSWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKCFvYmpbXCJfX2lkXCJdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFwiX19pZFwiLCB7IHZhbHVlOiArK3VuaXF1ZUlkIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtcIl9faWRcIl07XG4gICAgfSxcbiAgICBjbG9uZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuICAgICAgbGV0IGNsb25lMiwgaWQsIHR5cGUgPSBQcmlzbS51dGlsLnR5cGUobyk7XG4gICAgICB2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgaWQgPSBQcmlzbS51dGlsLm9iaklkKG8pO1xuICAgICAgICAgIGlmICh2aXNpdGVkW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRbaWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9uZTIgPSB7fTtcbiAgICAgICAgICB2aXNpdGVkW2lkXSA9IGNsb25lMjtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGNsb25lMltrZXldID0gZGVlcENsb25lKG9ba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjbG9uZTI7XG4gICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgIGlkID0gUHJpc20udXRpbC5vYmpJZChvKTtcbiAgICAgICAgICBpZiAodmlzaXRlZFtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdGVkW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvbmUyID0gW107XG4gICAgICAgICAgdmlzaXRlZFtpZF0gPSBjbG9uZTI7XG4gICAgICAgICAgby5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICAgIGNsb25lMltpXSA9IGRlZXBDbG9uZSh2LCB2aXNpdGVkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2xvbmUyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH0sIFwiZGVlcENsb25lXCIpXG4gIH0sXG4gIGxhbmd1YWdlczoge1xuICAgIGV4dGVuZDogZnVuY3Rpb24oaWQsIHJlZGVmKSB7XG4gICAgICBjb25zdCBsYW5nID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXNbaWRdKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZGVmKSB7XG4gICAgICAgIGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuICAgICAgcm9vdCA9IHJvb3QgfHwgUHJpc20ubGFuZ3VhZ2VzO1xuICAgICAgY29uc3QgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgZm9yIChjb25zdCB0b2tlbiBpbiBncmFtbWFyKSB7XG4gICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgIGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvbGQgPSByb290W2luc2lkZV07XG4gICAgICByb290W2luc2lkZV0gPSByZXQ7XG4gICAgICBQcmlzbS5sYW5ndWFnZXMuREZTKFByaXNtLmxhbmd1YWdlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG4gICAgICAgICAgdGhpc1trZXldID0gcmV0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBERlM6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG4gICAgICB2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcbiAgICAgIGNvbnN0IG9iaklkID0gUHJpc20udXRpbC5vYmpJZDtcbiAgICAgIGZvciAoY29uc3QgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChvLCBpLCBvW2ldLCB0eXBlIHx8IGkpO1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gb1tpXSwgcHJvcGVydHlUeXBlID0gUHJpc20udXRpbC50eXBlKHByb3BlcnR5KTtcbiAgICAgICAgICBpZiAocHJvcGVydHlUeXBlID09PSBcIk9iamVjdFwiICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG4gICAgICAgICAgICBERlMocHJvcGVydHksIGNhbGxiYWNrLCBudWxsLCB2aXNpdGVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gXCJBcnJheVwiICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG4gICAgICAgICAgICBERlMocHJvcGVydHksIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBcIkRGU1wiKVxuICB9LFxuICBwbHVnaW5zOiB7fSxcbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbih0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IGVudjIgPSB7XG4gICAgICBjb2RlOiB0ZXh0LFxuICAgICAgZ3JhbW1hcixcbiAgICAgIGxhbmd1YWdlXG4gICAgfTtcbiAgICBQcmlzbS5ob29rcy5ydW4oXCJiZWZvcmUtdG9rZW5pemVcIiwgZW52Mik7XG4gICAgZW52Mi50b2tlbnMgPSBQcmlzbS50b2tlbml6ZShlbnYyLmNvZGUsIGVudjIuZ3JhbW1hcik7XG4gICAgUHJpc20uaG9va3MucnVuKFwiYWZ0ZXItdG9rZW5pemVcIiwgZW52Mik7XG4gICAgcmV0dXJuIFRva2VuLnN0cmluZ2lmeShQcmlzbS51dGlsLmVuY29kZShlbnYyLnRva2VucyksIGVudjIubGFuZ3VhZ2UpO1xuICB9LFxuICBtYXRjaEdyYW1tYXI6IGZ1bmN0aW9uKHRleHQsIHN0cmFyciwgZ3JhbW1hciwgaW5kZXgsIHN0YXJ0UG9zLCBvbmVzaG90LCB0YXJnZXQpIHtcbiAgICBmb3IgKGNvbnN0IHRva2VuIGluIGdyYW1tYXIpIHtcbiAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID09IHRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgIHBhdHRlcm5zID0gUHJpc20udXRpbC50eXBlKHBhdHRlcm5zKSA9PT0gXCJBcnJheVwiID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5zW2pdLCBpbnNpZGUgPSBwYXR0ZXJuLmluc2lkZSwgbG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLCBncmVlZHkgPSAhIXBhdHRlcm4uZ3JlZWR5LCBsb29rYmVoaW5kTGVuZ3RoID0gMCwgYWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuICAgICAgICBpZiAoZ3JlZWR5ICYmICFwYXR0ZXJuLnBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgICAgY29uc3QgZmxhZ3MgPSBwYXR0ZXJuLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltdXldKiQvKVswXTtcbiAgICAgICAgICBwYXR0ZXJuLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyBcImdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucGF0dGVybiB8fCBwYXR0ZXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXgsIHBvcyA9IHN0YXJ0UG9zOyBpIDwgc3RyYXJyLmxlbmd0aDsgcG9zICs9IHN0cmFycltpXS5sZW5ndGgsICsraSkge1xuICAgICAgICAgIGxldCBzdHIgPSBzdHJhcnJbaV07XG4gICAgICAgICAgaWYgKHN0cmFyci5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ3JlZWR5ICYmIGkgIT0gc3RyYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcm9tID0gbWF0Y2guaW5kZXggKyAobG9va2JlaGluZCA/IG1hdGNoWzFdLmxlbmd0aCA6IDApLCB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBrID0gaSwgcCA9IHBvcztcbiAgICAgICAgICAgIGZvciAobGV0IGxlbiA9IHN0cmFyci5sZW5ndGg7IGsgPCBsZW4gJiYgKHAgPCB0byB8fCAhc3RyYXJyW2tdLnR5cGUgJiYgIXN0cmFycltrIC0gMV0uZ3JlZWR5KTsgKytrKSB7XG4gICAgICAgICAgICAgIHAgKz0gc3RyYXJyW2tdLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGZyb20gPj0gcCkge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICBwb3MgPSBwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyYXJyW2ldIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxOdW0gPSBrIC0gaTtcbiAgICAgICAgICAgIHN0ciA9IHRleHQuc2xpY2UocG9zLCBwKTtcbiAgICAgICAgICAgIG1hdGNoLmluZGV4IC09IHBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0ciksIGRlbE51bSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChvbmVzaG90KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb29rYmVoaW5kKSB7XG4gICAgICAgICAgICBsb29rYmVoaW5kTGVuZ3RoID0gbWF0Y2hbMV0gPyBtYXRjaFsxXS5sZW5ndGggOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgbG9va2JlaGluZExlbmd0aCwgbWF0Y2ggPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKSwgdG8gPSBmcm9tICsgbWF0Y2gubGVuZ3RoLCBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSksIGFmdGVyID0gc3RyLnNsaWNlKHRvKTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gW2ksIGRlbE51bV07XG4gICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgcG9zICs9IGJlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICBhcmdzLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlID8gUHJpc20udG9rZW5pemUobWF0Y2gsIGluc2lkZSkgOiBtYXRjaCwgYWxpYXMsIG1hdGNoLCBncmVlZHkpO1xuICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhZnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RyYXJyLCBhcmdzKTtcbiAgICAgICAgICBpZiAoZGVsTnVtICE9IDEpXG4gICAgICAgICAgICBQcmlzbS5tYXRjaEdyYW1tYXIodGV4dCwgc3RyYXJyLCBncmFtbWFyLCBpLCBwb3MsIHRydWUsIHRva2VuKTtcbiAgICAgICAgICBpZiAob25lc2hvdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0b2tlbml6ZTogZnVuY3Rpb24odGV4dCwgZ3JhbW1hcikge1xuICAgIGNvbnN0IHN0cmFyciA9IFt0ZXh0XTtcbiAgICBjb25zdCByZXN0ID0gZ3JhbW1hci5yZXN0O1xuICAgIGlmIChyZXN0KSB7XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIGluIHJlc3QpIHtcbiAgICAgICAgZ3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBncmFtbWFyLnJlc3Q7XG4gICAgfVxuICAgIFByaXNtLm1hdGNoR3JhbW1hcih0ZXh0LCBzdHJhcnIsIGdyYW1tYXIsIDAsIDAsIGZhbHNlKTtcbiAgICByZXR1cm4gc3RyYXJyO1xuICB9LFxuICBob29rczoge1xuICAgIGFsbDoge30sXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgY29uc3QgaG9va3MgPSBQcmlzbS5ob29rcy5hbGw7XG4gICAgICBob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uKG5hbWUsIGVudjIpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFByaXNtLmhvb2tzLmFsbFtuYW1lXTtcbiAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjYWxsYmFjazsgY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXTsgKSB7XG4gICAgICAgIGNhbGxiYWNrKGVudjIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgVG9rZW5cbn07XG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gIGNvbW1lbnQ6IFtcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICBdLFxuICBzdHJpbmc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICBcImNsYXNzLW5hbWVcIjoge1xuICAgIHBhdHRlcm46IC8oKD86XFxiKD86Y2xhc3N8aW50ZXJmYWNlfGV4dGVuZHN8aW1wbGVtZW50c3x0cmFpdHxpbnN0YW5jZW9mfG5ldylcXHMrKXwoPzpjYXRjaFxccytcXCgpKVtcXHcuXFxcXF0rL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHB1bmN0dWF0aW9uOiAvWy5cXFxcXS9cbiAgICB9XG4gIH0sXG4gIGtleXdvcmQ6IC9cXGIoPzppZnxlbHNlfHdoaWxlfGRvfGZvcnxyZXR1cm58aW58aW5zdGFuY2VvZnxmdW5jdGlvbnxuZXd8dHJ5fHRocm93fGNhdGNofGZpbmFsbHl8bnVsbHxicmVha3xjb250aW51ZSlcXGIvLFxuICBib29sZWFuOiAvXFxiKD86dHJ1ZXxmYWxzZSlcXGIvLFxuICBmdW5jdGlvbjogL1xcdysoPz1cXCgpLyxcbiAgbnVtYmVyOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkK1xcLj9cXGQqfFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/L2ksXG4gIG9wZXJhdG9yOiAvLS0/fFxcK1xcKz98IT0/PT98PD0/fD49P3w9PT89P3wmJj98XFx8XFx8P3xcXD98XFwqfFxcL3x+fFxcXnwlLyxcbiAgcHVuY3R1YXRpb246IC9be31bXFxdOygpLC46XS9cbn07XG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoXCJjbGlrZVwiLCB7XG4gIFwiY2xhc3MtbmFtZVwiOiBbXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmNsaWtlW1wiY2xhc3MtbmFtZVwiXSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pW18kQS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxcLig/OnByb3RvdHlwZXxjb25zdHJ1Y3RvcikpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XG4gIF0sXG4gIGtleXdvcmQ6IFtcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58fSlcXHMqKSg/OmNhdGNofGZpbmFsbHkpXFxiLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi5dKVxcYig/OmFzfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XG4gIF0sXG4gIG51bWJlcjogL1xcYig/Oig/OjBbeFhdKD86W1xcZEEtRmEtZl0oPzpfW1xcZEEtRmEtZl0pPykrfDBbYkJdKD86WzAxXSg/Ol9bMDFdKT8pK3wwW29PXSg/OlswLTddKD86X1swLTddKT8pKyluP3woPzpcXGQoPzpfXFxkKT8pK258TmFOfEluZmluaXR5KVxcYnwoPzpcXGIoPzpcXGQoPzpfXFxkKT8pK1xcLj8oPzpcXGQoPzpfXFxkKT8pKnxcXEJcXC4oPzpcXGQoPzpfXFxkKT8pKykoPzpbRWVdWystXT8oPzpcXGQoPzpfXFxkKT8pKyk/LyxcbiAgZnVuY3Rpb246IC9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gIG9wZXJhdG9yOiAvLVstPV0/fFxcK1srPV0/fCE9Pz0/fDw8Pz0/fD4+Pz4/PT98PSg/Oj09P3w+KT98JlsmPV0/fFxcfFt8PV0/fFxcKlxcKj89P3xcXC89P3x+fFxcXj0/fCU9P3xcXD98XFwuezN9L1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFtcImNsYXNzLW5hbWVcIl1bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8aW50ZXJmYWNlfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJqYXZhc2NyaXB0XCIsIFwia2V5d29yZFwiLCB7XG4gIHJlZ2V4OiB7XG4gICAgcGF0dGVybjogLygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc10pXFxzKilcXC8oXFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2dpbXl1c117MCw2fSg/PVxccyooJHxbXFxyXFxuLC47fSlcXF1dKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gIFwiZnVuY3Rpb24tdmFyaWFibGVcIjoge1xuICAgIHBhdHRlcm46IC9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKVxccyo9PikpLyxcbiAgICBhbGlhczogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHBhcmFtZXRlcjogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrW18kQS1aYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKCldfFxcKFteKCldKlxcKSkrPyg/PVxccypcXCkpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvW18kYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxccyo9PikvaSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKV18XFwoW14oKV0qXFwpKSs/KD89XFxzKlxcKVxccyo9PikvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/OltfJEEtWmEtelxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSpcXHMqKVxcKFxccyopKD8hXFxzKSg/OlteKCldfFxcKFteKCldKlxcKSkrPyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH1cbiAgXSxcbiAgY29uc3RhbnQ6IC9cXGJbQS1aXSg/OltBLVpfXXxcXGR4PykqXFxiL1xufSk7XG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKFwic2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbn1cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKFwiamF2YXNjcmlwdFwiLCB7XG4gIGtleXdvcmQ6IC9cXGIoPzphYnN0cmFjdHxhc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnN0cnVjdG9yfGNvbnRpbnVlfGRlYnVnZ2VyfGRlY2xhcmV8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGlzfGtleW9mfGxldHxtb2R1bGV8bmFtZXNwYWNlfG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlYWRvbmx5fHJldHVybnxyZXF1aXJlfHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGV8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgYnVpbHRpbjogL1xcYig/OnN0cmluZ3xGdW5jdGlvbnxhbnl8bnVtYmVyfGJvb2xlYW58QXJyYXl8c3ltYm9sfGNvbnNvbGV8UHJvbWlzZXx1bmtub3dufG5ldmVyKVxcYi9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG5mdW5jdGlvbiBUb2tlbih0eXBlLCBjb250ZW50LCBhbGlhcywgbWF0Y2hlZFN0ciwgZ3JlZWR5KSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgdGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCBcIlwiKS5sZW5ndGggfCAwO1xuICB0aGlzLmdyZWVkeSA9ICEhZ3JlZWR5O1xufVxuX19uYW1lKFRva2VuLCBcIlRva2VuXCIpO1xuVG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24obywgbGFuZ3VhZ2UpIHtcbiAgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbztcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgIHJldHVybiBvLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gVG9rZW4uc3RyaW5naWZ5KGVsZW1lbnQsIGxhbmd1YWdlKTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9XG4gIHJldHVybiBnZXRDb2xvckZvclN5bnRheEtpbmQoby50eXBlKShvLmNvbnRlbnQpO1xufTtcbmZ1bmN0aW9uIGdldENvbG9yRm9yU3ludGF4S2luZChzeW50YXhLaW5kKSB7XG4gIHJldHVybiB0aGVtZVtzeW50YXhLaW5kXSB8fCBpZGVudGl0eTtcbn1cbl9fbmFtZShnZXRDb2xvckZvclN5bnRheEtpbmQsIFwiZ2V0Q29sb3JGb3JTeW50YXhLaW5kXCIpO1xuXG4vLyBzcmMvcnVudGltZS9oaWdobGlnaHQvaGlnaGxpZ2h0LnRzXG5mdW5jdGlvbiBoaWdobGlnaHRUUyhzdHIpIHtcbiAgcmV0dXJuIGhpZ2hsaWdodChzdHIsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbn1cbl9fbmFtZShoaWdobGlnaHRUUywgXCJoaWdobGlnaHRUU1wiKTtcbmZ1bmN0aW9uIGhpZ2hsaWdodChzdHIsIGdyYW1tYXIpIHtcbiAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUoc3RyLCBncmFtbWFyKTtcbiAgcmV0dXJuIHRva2Vucy5tYXAoKHQpID0+IFRva2VuLnN0cmluZ2lmeSh0KSkuam9pbihcIlwiKTtcbn1cbl9fbmFtZShoaWdobGlnaHQsIFwiaGlnaGxpZ2h0XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9kZWRlbnQudHNcbnZhciBpbXBvcnRfc3RyaXBfaW5kZW50MiA9IF9fdG9FU00ocmVxdWlyZV9zdHJpcF9pbmRlbnQoKSk7XG5mdW5jdGlvbiBkZWRlbnQyKHN0cikge1xuICByZXR1cm4gKDAsIGltcG9ydF9zdHJpcF9pbmRlbnQyLmRlZmF1bHQpKHN0cik7XG59XG5fX25hbWUoZGVkZW50MiwgXCJkZWRlbnRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL1NvdXJjZUZpbGVTbGljZS50c1xudmFyIFNvdXJjZUZpbGVTbGljZSA9IGNsYXNzIHtcbiAgc3RhdGljIHJlYWQoZmlsZVBhdGgpIHtcbiAgICBsZXQgY29udGVudDtcbiAgICB0cnkge1xuICAgICAgY29udGVudCA9IGltcG9ydF9mczguZGVmYXVsdC5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBTb3VyY2VGaWxlU2xpY2UuZnJvbUNvbnRlbnQoY29udGVudCk7XG4gIH1cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoL1xccj9cXG4vKTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZUZpbGVTbGljZSgxLCBsaW5lcyk7XG4gIH1cbiAgY29uc3RydWN0b3IoZmlyc3RMaW5lLCBsaW5lcykge1xuICAgIHRoaXMuZmlyc3RMaW5lTnVtYmVyID0gZmlyc3RMaW5lO1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgfVxuICBnZXQgbGFzdExpbmVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RMaW5lTnVtYmVyICsgdGhpcy5saW5lcy5sZW5ndGggLSAxO1xuICB9XG4gIG1hcExpbmVBdChsaW5lTnVtYmVyLCBtYXBGbikge1xuICAgIGlmIChsaW5lTnVtYmVyIDwgdGhpcy5maXJzdExpbmVOdW1iZXIgfHwgbGluZU51bWJlciA+IHRoaXMubGluZXMubGVuZ3RoICsgdGhpcy5maXJzdExpbmVOdW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBpZHggPSBsaW5lTnVtYmVyIC0gdGhpcy5maXJzdExpbmVOdW1iZXI7XG4gICAgY29uc3QgbmV3TGluZXMgPSBbLi4udGhpcy5saW5lc107XG4gICAgbmV3TGluZXNbaWR4XSA9IG1hcEZuKG5ld0xpbmVzW2lkeF0pO1xuICAgIHJldHVybiBuZXcgU291cmNlRmlsZVNsaWNlKHRoaXMuZmlyc3RMaW5lTnVtYmVyLCBuZXdMaW5lcyk7XG4gIH1cbiAgbWFwTGluZXMobWFwRm4pIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZUZpbGVTbGljZShcbiAgICAgIHRoaXMuZmlyc3RMaW5lTnVtYmVyLFxuICAgICAgdGhpcy5saW5lcy5tYXAoKGxpbmUsIGkpID0+IG1hcEZuKGxpbmUsIHRoaXMuZmlyc3RMaW5lTnVtYmVyICsgaSkpXG4gICAgKTtcbiAgfVxuICBsaW5lQXQobGluZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLmxpbmVzW2xpbmVOdW1iZXIgLSB0aGlzLmZpcnN0TGluZU51bWJlcl07XG4gIH1cbiAgcHJlcGVuZFN5bWJvbEF0KGF0TGluZSwgc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwTGluZXMoKGxpbmUsIGxpbmVOdW1iZXIpID0+IHtcbiAgICAgIGlmIChsaW5lTnVtYmVyID09PSBhdExpbmUpIHtcbiAgICAgICAgcmV0dXJuIGAke3N0cn0gJHtsaW5lfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCAgJHtsaW5lfWA7XG4gICAgfSk7XG4gIH1cbiAgc2xpY2UoZnJvbUxpbmUsIHRvTGluZSkge1xuICAgIGNvbnN0IHNsaWNlZExpbmVzID0gdGhpcy5saW5lcy5zbGljZShmcm9tTGluZSAtIDEsIHRvTGluZSkuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZUZpbGVTbGljZShmcm9tTGluZSwgZGVkZW50MihzbGljZWRMaW5lcykuc3BsaXQoXCJcXG5cIikpO1xuICB9XG4gIGhpZ2hsaWdodCgpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZCA9IGhpZ2hsaWdodFRTKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VGaWxlU2xpY2UodGhpcy5maXJzdExpbmVOdW1iZXIsIGhpZ2hsaWdodGVkLnNwbGl0KFwiXFxuXCIpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lcy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xuX19uYW1lKFNvdXJjZUZpbGVTbGljZSwgXCJTb3VyY2VGaWxlU2xpY2VcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2NyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0LnRzXG52YXIgY29sb3JzRW5hYmxlZCA9IHtcbiAgcmVkOiAoc3RyKSA9PiBpbXBvcnRfY2hhbGs5LmRlZmF1bHQucmVkKHN0ciksXG4gIGdyYXk6IChzdHIpID0+IGltcG9ydF9jaGFsazkuZGVmYXVsdC5ncmF5KHN0ciksXG4gIGRpbTogKHN0cikgPT4gaW1wb3J0X2NoYWxrOS5kZWZhdWx0LmRpbShzdHIpLFxuICBib2xkOiAoc3RyKSA9PiBpbXBvcnRfY2hhbGs5LmRlZmF1bHQuYm9sZChzdHIpLFxuICB1bmRlcmxpbmU6IChzdHIpID0+IGltcG9ydF9jaGFsazkuZGVmYXVsdC51bmRlcmxpbmUoc3RyKSxcbiAgaGlnaGxpZ2h0U291cmNlOiAoc291cmNlKSA9PiBzb3VyY2UuaGlnaGxpZ2h0KClcbn07XG52YXIgY29sb3JzRGlzYWJsZWQgPSB7XG4gIHJlZDogKHN0cikgPT4gc3RyLFxuICBncmF5OiAoc3RyKSA9PiBzdHIsXG4gIGRpbTogKHN0cikgPT4gc3RyLFxuICBib2xkOiAoc3RyKSA9PiBzdHIsXG4gIHVuZGVybGluZTogKHN0cikgPT4gc3RyLFxuICBoaWdobGlnaHRTb3VyY2U6IChzb3VyY2UpID0+IHNvdXJjZVxufTtcbmZ1bmN0aW9uIGdldFRlbXBsYXRlUGFyYW1ldGVycyh7IGNhbGxzaXRlLCBtZXNzYWdlLCBvcmlnaW5hbE1ldGhvZCwgaXNQYW5pYywgY2FsbEFyZ3VtZW50cyB9LCBjb2xvcnMpIHtcbiAgdmFyIF9hMztcbiAgY29uc3QgdGVtcGxhdGVQYXJhbWV0ZXJzID0ge1xuICAgIGZ1bmN0aW9uTmFtZTogYHByaXNtYS4ke29yaWdpbmFsTWV0aG9kfSgpYCxcbiAgICBtZXNzYWdlLFxuICAgIGlzUGFuaWM6IGlzUGFuaWMgIT0gbnVsbCA/IGlzUGFuaWMgOiBmYWxzZSxcbiAgICBjYWxsQXJndW1lbnRzXG4gIH07XG4gIGlmICghY2FsbHNpdGUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0ZW1wbGF0ZVBhcmFtZXRlcnM7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiB0ZW1wbGF0ZVBhcmFtZXRlcnM7XG4gIH1cbiAgY29uc3QgY2FsbExvY2F0aW9uID0gY2FsbHNpdGUuZ2V0TG9jYXRpb24oKTtcbiAgaWYgKCFjYWxsTG9jYXRpb24gfHwgIWNhbGxMb2NhdGlvbi5saW5lTnVtYmVyIHx8ICFjYWxsTG9jYXRpb24uY29sdW1uTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlUGFyYW1ldGVycztcbiAgfVxuICBjb25zdCBjb250ZXh0Rmlyc3RMaW5lID0gTWF0aC5tYXgoMSwgY2FsbExvY2F0aW9uLmxpbmVOdW1iZXIgLSAzKTtcbiAgbGV0IHNvdXJjZSA9IChfYTMgPSBTb3VyY2VGaWxlU2xpY2UucmVhZChjYWxsTG9jYXRpb24uZmlsZU5hbWUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnNsaWNlKGNvbnRleHRGaXJzdExpbmUsIGNhbGxMb2NhdGlvbi5saW5lTnVtYmVyKTtcbiAgaWYgKHNvdXJjZSkge1xuICAgIGNvbnN0IGludm9jYXRpb25MaW5lID0gc291cmNlLmxpbmVBdChjYWxsTG9jYXRpb24ubGluZU51bWJlcik7XG4gICAgY29uc3QgaW52b2NhdGlvbkxpbmVJbmRlbnQgPSBnZXRJbmRlbnQoaW52b2NhdGlvbkxpbmUpO1xuICAgIGNvbnN0IGludm9jYXRpb25DYWxsQ29kZSA9IGZpbmRQcmlzbWFBY3Rpb25DYWxsKGludm9jYXRpb25MaW5lKTtcbiAgICBpZiAoIWludm9jYXRpb25DYWxsQ29kZSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlUGFyYW1ldGVycztcbiAgICB9XG4gICAgdGVtcGxhdGVQYXJhbWV0ZXJzLmZ1bmN0aW9uTmFtZSA9IGAke2ludm9jYXRpb25DYWxsQ29kZS5jb2RlfSlgO1xuICAgIHRlbXBsYXRlUGFyYW1ldGVycy5sb2NhdGlvbiA9IGNhbGxMb2NhdGlvbjtcbiAgICBpZiAoIWlzUGFuaWMpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5tYXBMaW5lQXQoY2FsbExvY2F0aW9uLmxpbmVOdW1iZXIsIChsaW5lKSA9PiBsaW5lLnNsaWNlKDAsIGludm9jYXRpb25DYWxsQ29kZS5vcGVuaW5nQnJhY2VJbmRleCkpO1xuICAgIH1cbiAgICBzb3VyY2UgPSBjb2xvcnMuaGlnaGxpZ2h0U291cmNlKHNvdXJjZSk7XG4gICAgY29uc3QgbnVtYmVyQ29sdW1uV2lkdGggPSBTdHJpbmcoc291cmNlLmxhc3RMaW5lTnVtYmVyKS5sZW5ndGg7XG4gICAgdGVtcGxhdGVQYXJhbWV0ZXJzLmNvbnRleHRMaW5lcyA9IHNvdXJjZS5tYXBMaW5lcygobGluZSwgbGluZU51bWJlcikgPT4gY29sb3JzLmdyYXkoU3RyaW5nKGxpbmVOdW1iZXIpLnBhZFN0YXJ0KG51bWJlckNvbHVtbldpZHRoKSkgKyBcIiBcIiArIGxpbmUpLm1hcExpbmVzKChsaW5lKSA9PiBjb2xvcnMuZGltKGxpbmUpKS5wcmVwZW5kU3ltYm9sQXQoY2FsbExvY2F0aW9uLmxpbmVOdW1iZXIsIGNvbG9ycy5ib2xkKGNvbG9ycy5yZWQoXCJcXHUyMTkyXCIpKSk7XG4gICAgaWYgKGNhbGxBcmd1bWVudHMpIHtcbiAgICAgIGxldCBpbmRlbnRWYWx1ZSA9IGludm9jYXRpb25MaW5lSW5kZW50ICsgbnVtYmVyQ29sdW1uV2lkdGggKyAxO1xuICAgICAgaW5kZW50VmFsdWUgKz0gMjtcbiAgICAgIHRlbXBsYXRlUGFyYW1ldGVycy5jYWxsQXJndW1lbnRzID0gKDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nMy5kZWZhdWx0KShjYWxsQXJndW1lbnRzLCBpbmRlbnRWYWx1ZSkuc2xpY2UoaW5kZW50VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGVtcGxhdGVQYXJhbWV0ZXJzO1xufVxuX19uYW1lKGdldFRlbXBsYXRlUGFyYW1ldGVycywgXCJnZXRUZW1wbGF0ZVBhcmFtZXRlcnNcIik7XG5mdW5jdGlvbiBmaW5kUHJpc21hQWN0aW9uQ2FsbChzdHIpIHtcbiAgY29uc3QgYWxsQWN0aW9ucyA9IGFsbENsaWVudE1vZGVsQWN0aW9ucy5qb2luKFwifFwiKTtcbiAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3YFxcUysoJHthbGxBY3Rpb25zfSlcXChgKTtcbiAgY29uc3QgbWF0Y2ggPSByZWdleHAuZXhlYyhzdHIpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogbWF0Y2hbMF0sXG4gICAgICBvcGVuaW5nQnJhY2VJbmRleDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuX19uYW1lKGZpbmRQcmlzbWFBY3Rpb25DYWxsLCBcImZpbmRQcmlzbWFBY3Rpb25DYWxsXCIpO1xuZnVuY3Rpb24gZ2V0SW5kZW50KGxpbmUpIHtcbiAgbGV0IHNwYWNlQ291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZS5jaGFyQXQoaSkgIT09IFwiIFwiKSB7XG4gICAgICByZXR1cm4gc3BhY2VDb3VudDtcbiAgICB9XG4gICAgc3BhY2VDb3VudCsrO1xuICB9XG4gIHJldHVybiBzcGFjZUNvdW50O1xufVxuX19uYW1lKGdldEluZGVudCwgXCJnZXRJbmRlbnRcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvck1lc3NhZ2UoeyBmdW5jdGlvbk5hbWUsIGxvY2F0aW9uLCBtZXNzYWdlLCBpc1BhbmljLCBjb250ZXh0TGluZXMsIGNhbGxBcmd1bWVudHMgfSwgY29sb3JzKSB7XG4gIGNvbnN0IGxpbmVzID0gW1wiXCJdO1xuICBjb25zdCBpbnRyb1N1ZmZpeCA9IGxvY2F0aW9uID8gXCIgaW5cIiA6IFwiOlwiO1xuICBpZiAoaXNQYW5pYykge1xuICAgIGxpbmVzLnB1c2goY29sb3JzLnJlZChgT29wcywgYW4gdW5rbm93biBlcnJvciBvY2N1cmVkISBUaGlzIGlzICR7Y29sb3JzLmJvbGQoXCJvbiB1c1wiKX0sIHlvdSBkaWQgbm90aGluZyB3cm9uZy5gKSk7XG4gICAgbGluZXMucHVzaChjb2xvcnMucmVkKGBJdCBvY2N1cmVkIGluIHRoZSAke2NvbG9ycy5ib2xkKGBcXGAke2Z1bmN0aW9uTmFtZX1cXGBgKX0gaW52b2NhdGlvbiR7aW50cm9TdWZmaXh9YCkpO1xuICB9IGVsc2Uge1xuICAgIGxpbmVzLnB1c2goY29sb3JzLnJlZChgSW52YWxpZCAke2NvbG9ycy5ib2xkKGBcXGAke2Z1bmN0aW9uTmFtZX1cXGBgKX0gaW52b2NhdGlvbiR7aW50cm9TdWZmaXh9YCkpO1xuICB9XG4gIGlmIChsb2NhdGlvbikge1xuICAgIGxpbmVzLnB1c2goY29sb3JzLnVuZGVybGluZShzdHJpbmdpZnlMb2NhdGlvbkluRmlsZShsb2NhdGlvbikpKTtcbiAgfVxuICBpZiAoY29udGV4dExpbmVzKSB7XG4gICAgbGluZXMucHVzaChcIlwiKTtcbiAgICBjb25zdCBjb250ZXh0TGluZVBhcnRzID0gW2NvbnRleHRMaW5lcy50b1N0cmluZygpXTtcbiAgICBpZiAoY2FsbEFyZ3VtZW50cykge1xuICAgICAgY29udGV4dExpbmVQYXJ0cy5wdXNoKGNhbGxBcmd1bWVudHMpO1xuICAgICAgY29udGV4dExpbmVQYXJ0cy5wdXNoKGNvbG9ycy5kaW0oXCIpXCIpKTtcbiAgICB9XG4gICAgbGluZXMucHVzaChjb250ZXh0TGluZVBhcnRzLmpvaW4oXCJcIikpO1xuICAgIGlmIChjYWxsQXJndW1lbnRzKSB7XG4gICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgIGlmIChjYWxsQXJndW1lbnRzKSB7XG4gICAgICBsaW5lcy5wdXNoKGNhbGxBcmd1bWVudHMpO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICB9XG4gIGxpbmVzLnB1c2gobWVzc2FnZSk7XG4gIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuX19uYW1lKHN0cmluZ2lmeUVycm9yTWVzc2FnZSwgXCJzdHJpbmdpZnlFcnJvck1lc3NhZ2VcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlMb2NhdGlvbkluRmlsZShsb2NhdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IFtsb2NhdGlvbi5maWxlTmFtZV07XG4gIGlmIChsb2NhdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgcGFydHMucHVzaChTdHJpbmcobG9jYXRpb24ubGluZU51bWJlcikpO1xuICB9XG4gIGlmIChsb2NhdGlvbi5jb2x1bW5OdW1iZXIpIHtcbiAgICBwYXJ0cy5wdXNoKFN0cmluZyhsb2NhdGlvbi5jb2x1bW5OdW1iZXIpKTtcbiAgfVxuICByZXR1cm4gcGFydHMuam9pbihcIjpcIik7XG59XG5fX25hbWUoc3RyaW5naWZ5TG9jYXRpb25JbkZpbGUsIFwic3RyaW5naWZ5TG9jYXRpb25JbkZpbGVcIik7XG5mdW5jdGlvbiBjcmVhdGVFcnJvck1lc3NhZ2VXaXRoQ29udGV4dChhcmdzKSB7XG4gIGNvbnN0IGNvbG9ycyA9IGFyZ3Muc2hvd0NvbG9ycyA/IGNvbG9yc0VuYWJsZWQgOiBjb2xvcnNEaXNhYmxlZDtcbiAgY29uc3QgdGVtcGxhdGVQYXJhbWV0ZXJzID0gZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKGFyZ3MsIGNvbG9ycyk7XG4gIHJldHVybiBzdHJpbmdpZnlFcnJvck1lc3NhZ2UodGVtcGxhdGVQYXJhbWV0ZXJzLCBjb2xvcnMpO1xufVxuX19uYW1lKGNyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0LCBcImNyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9kZWVwLWV4dGVuZC50c1xuZnVuY3Rpb24gaXNTcGVjaWZpY1ZhbHVlKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQnVmZmVyIHx8IHZhbCBpbnN0YW5jZW9mIERhdGUgfHwgdmFsIGluc3RhbmNlb2YgUmVnRXhwID8gdHJ1ZSA6IGZhbHNlO1xufVxuX19uYW1lKGlzU3BlY2lmaWNWYWx1ZSwgXCJpc1NwZWNpZmljVmFsdWVcIik7XG5mdW5jdGlvbiBjbG9uZVNwZWNpZmljVmFsdWUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICBjb25zdCB4ID0gQnVmZmVyLmFsbG9jID8gQnVmZmVyLmFsbG9jKHZhbC5sZW5ndGgpIDogbmV3IEJ1ZmZlcih2YWwubGVuZ3RoKTtcbiAgICB2YWwuY29weSh4KTtcbiAgICByZXR1cm4geDtcbiAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzaXR1YXRpb25cIik7XG4gIH1cbn1cbl9fbmFtZShjbG9uZVNwZWNpZmljVmFsdWUsIFwiY2xvbmVTcGVjaWZpY1ZhbHVlXCIpO1xuZnVuY3Rpb24gZGVlcENsb25lQXJyYXkoYXJyKSB7XG4gIGNvbnN0IGNsb25lMiA9IFtdO1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBjbG9uZTJbaW5kZXhdID0gZGVlcENsb25lQXJyYXkoaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3BlY2lmaWNWYWx1ZShpdGVtKSkge1xuICAgICAgICBjbG9uZTJbaW5kZXhdID0gY2xvbmVTcGVjaWZpY1ZhbHVlKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUyW2luZGV4XSA9IGRlZXBFeHRlbmQoe30sIGl0ZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbG9uZTJbaW5kZXhdID0gaXRlbTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmUyO1xufVxuX19uYW1lKGRlZXBDbG9uZUFycmF5LCBcImRlZXBDbG9uZUFycmF5XCIpO1xuZnVuY3Rpb24gc2FmZUdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHByb3BlcnR5ID09PSBcIl9fcHJvdG9fX1wiID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbn1cbl9fbmFtZShzYWZlR2V0UHJvcGVydHksIFwic2FmZUdldFByb3BlcnR5XCIpO1xudmFyIGRlZXBFeHRlbmQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHRhcmdldCwgLi4uYXJncykge1xuICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgbGV0IHZhbCwgc3JjO1xuICBmb3IgKGNvbnN0IG9iaiBvZiBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgIHNyYyA9IHNhZmVHZXRQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgICB2YWwgPSBzYWZlR2V0UHJvcGVydHkob2JqLCBrZXkpO1xuICAgICAgaWYgKHZhbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IGRlZXBDbG9uZUFycmF5KHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChpc1NwZWNpZmljVmFsdWUodmFsKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lU3BlY2lmaWNWYWx1ZSh2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNyYyAhPT0gXCJvYmplY3RcIiB8fCBzcmMgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gZGVlcEV4dGVuZCh7fSwgdmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IGRlZXBFeHRlbmQoc3JjLCB2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn0sIFwiZGVlcEV4dGVuZFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvZGVlcC1zZXQudHNcbnZhciBrZXlzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoa3MpID0+IEFycmF5LmlzQXJyYXkoa3MpID8ga3MgOiBrcy5zcGxpdChcIi5cIiksIFwia2V5c1wiKTtcbnZhciBkZWVwR2V0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobywga3ApID0+IGtleXMoa3ApLnJlZHVjZSgobzIsIGspID0+IG8yICYmIG8yW2tdLCBvKSwgXCJkZWVwR2V0XCIpO1xudmFyIGRlZXBTZXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvLCBrcCwgdikgPT4ga2V5cyhrcCkucmVkdWNlUmlnaHQoKHYyLCBrLCBpLCBrcykgPT4gT2JqZWN0LmFzc2lnbih7fSwgZGVlcEdldChvLCBrcy5zbGljZSgwLCBpKSksIHsgW2tdOiB2MiB9KSwgdiksIFwiZGVlcFNldFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvZmlsdGVyT2JqZWN0LnRzXG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqLCBjYikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmouaGFzT3duUHJvcGVydHkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29uc3QgbmV3T2JqID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBjYihrZXksIHZhbHVlKSkge1xuICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld09iajtcbn1cbl9fbmFtZShmaWx0ZXJPYmplY3QsIFwiZmlsdGVyT2JqZWN0XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9mbGF0TWFwLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheSk7XG59XG5fX25hbWUoZmxhdHRlbiwgXCJmbGF0dGVuXCIpO1xuZnVuY3Rpb24gZmxhdE1hcChhcnJheSwgY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICByZXR1cm4gZmxhdHRlbihhcnJheS5tYXAoY2FsbGJhY2tGbiwgdGhpc0FyZykpO1xufVxuX19uYW1lKGZsYXRNYXAsIFwiZmxhdE1hcFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvaXNPYmplY3QudHNcbnZhciBub3RSZWFsbHlPYmplY3RzID0ge1xuICBcIltvYmplY3QgRGF0ZV1cIjogdHJ1ZSxcbiAgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6IHRydWUsXG4gIFwiW29iamVjdCBEZWNpbWFsXVwiOiB0cnVlXG59O1xuZnVuY3Rpb24gaXNPYmplY3QyKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhbm90UmVhbGx5T2JqZWN0c1tPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cbl9fbmFtZShpc09iamVjdDIsIFwiaXNPYmplY3RcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL29taXQudHNcbmZ1bmN0aW9uIG9taXQyKG9iamVjdCwgcGF0aDcpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoNykgPyBwYXRoNyA6IFtwYXRoN107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgIXBhdGhzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUob21pdDIsIFwib21pdFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvcHJpbnRKc29uRXJyb3JzLnRzXG52YXIgaW1wb3J0X2NoYWxrMTAgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9zdHJpcF9hbnNpMiA9IF9fdG9FU00ocmVxdWlyZV9zdHJpcF9hbnNpKCkpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9zdHJpbmdpZnlPYmplY3QudHNcbnZhciBpc1JlZ2V4cCA9IHJlcXVpcmVfaXNfcmVnZXhwKCk7XG52YXIgaXNPYmogPSByZXF1aXJlX2lzX29iaigpO1xudmFyIGdldE93bkVudW1Qcm9wU3ltYm9scyA9IHJlcXVpcmVfbGliKCkuZGVmYXVsdDtcbnZhciBzdHJpbmdpZnlPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpbnB1dCwgb3B0aW9ucywgcGFkKSA9PiB7XG4gIGNvbnN0IHNlZW4gPSBbXTtcbiAgcmV0dXJuICgvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdDIoaW5wdXQyLCBvcHRpb25zMiA9IHt9LCBwYWQyID0gXCJcIiwgcGF0aDcgPSBbXSkge1xuICAgIG9wdGlvbnMyLmluZGVudCA9IG9wdGlvbnMyLmluZGVudCB8fCBcIlx0XCI7XG4gICAgbGV0IHRva2VucztcbiAgICBpZiAob3B0aW9uczIuaW5saW5lQ2hhcmFjdGVyTGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5zID0ge1xuICAgICAgICBuZXdMaW5lOiBcIlxcblwiLFxuICAgICAgICBuZXdMaW5lT3JTcGFjZTogXCJcXG5cIixcbiAgICAgICAgcGFkOiBwYWQyLFxuICAgICAgICBpbmRlbnQ6IHBhZDIgKyBvcHRpb25zMi5pbmRlbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VucyA9IHtcbiAgICAgICAgbmV3TGluZTogXCJAQF9fU1RSSU5HSUZZX09CSkVDVF9ORVdfTElORV9fQEBcIixcbiAgICAgICAgbmV3TGluZU9yU3BhY2U6IFwiQEBfX1NUUklOR0lGWV9PQkpFQ1RfTkVXX0xJTkVfT1JfU1BBQ0VfX0BAXCIsXG4gICAgICAgIHBhZDogXCJAQF9fU1RSSU5HSUZZX09CSkVDVF9QQURfX0BAXCIsXG4gICAgICAgIGluZGVudDogXCJAQF9fU1RSSU5HSUZZX09CSkVDVF9JTkRFTlRfX0BAXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4cGFuZFdoaXRlU3BhY2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdHJpbmcpID0+IHtcbiAgICAgIGlmIChvcHRpb25zMi5pbmxpbmVDaGFyYWN0ZXJMaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCBvbmVMaW5lZCA9IHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLm5ld0xpbmUsIFwiZ1wiKSwgXCJcIikucmVwbGFjZShuZXcgUmVnRXhwKHRva2Vucy5uZXdMaW5lT3JTcGFjZSwgXCJnXCIpLCBcIiBcIikucmVwbGFjZShuZXcgUmVnRXhwKHRva2Vucy5wYWQgKyBcInxcIiArIHRva2Vucy5pbmRlbnQsIFwiZ1wiKSwgXCJcIik7XG4gICAgICBpZiAob25lTGluZWQubGVuZ3RoIDw9IG9wdGlvbnMyLmlubGluZUNoYXJhY3RlckxpbWl0KSB7XG4gICAgICAgIHJldHVybiBvbmVMaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRva2Vucy5uZXdMaW5lICsgXCJ8XCIgKyB0b2tlbnMubmV3TGluZU9yU3BhY2UsIFwiZ1wiKSwgXCJcXG5cIikucmVwbGFjZShuZXcgUmVnRXhwKHRva2Vucy5wYWQsIFwiZ1wiKSwgcGFkMikucmVwbGFjZShuZXcgUmVnRXhwKHRva2Vucy5pbmRlbnQsIFwiZ1wiKSwgcGFkMiArIG9wdGlvbnMyLmluZGVudCk7XG4gICAgfSwgXCJleHBhbmRXaGl0ZVNwYWNlXCIpO1xuICAgIGlmIChzZWVuLmluZGV4T2YoaW5wdXQyKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiAnXCJbQ2lyY3VsYXJdXCInO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0MikpIHtcbiAgICAgIHJldHVybiBgQnVmZmVyKCR7QnVmZmVyLmxlbmd0aH0pYDtcbiAgICB9XG4gICAgaWYgKGlucHV0MiA9PT0gbnVsbCB8fCBpbnB1dDIgPT09IHZvaWQgMCB8fCB0eXBlb2YgaW5wdXQyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBpbnB1dDIgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBpbnB1dDIgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgaW5wdXQyID09PSBcInN5bWJvbFwiIHx8IGlucHV0MiBpbnN0YW5jZW9mIE9iamVjdEVudW1WYWx1ZSB8fCBpc1JlZ2V4cChpbnB1dDIpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGlucHV0Mik7XG4gICAgfVxuICAgIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gYG5ldyBEYXRlKCcke2lucHV0Mi50b0lTT1N0cmluZygpfScpYDtcbiAgICB9XG4gICAgaWYgKGlucHV0MiBpbnN0YW5jZW9mIEZpZWxkUmVmSW1wbCkge1xuICAgICAgcmV0dXJuIGBwcmlzbWEuJHtsb3dlckNhc2UoaW5wdXQyLm1vZGVsTmFtZSl9LmZpZWxkcy4ke2lucHV0Mi5uYW1lfWA7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0MikpIHtcbiAgICAgIGlmIChpbnB1dDIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIltdXCI7XG4gICAgICB9XG4gICAgICBzZWVuLnB1c2goaW5wdXQyKTtcbiAgICAgIGNvbnN0IHJldCA9IFwiW1wiICsgdG9rZW5zLm5ld0xpbmUgKyBpbnB1dDIubWFwKChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBlb2wgPSBpbnB1dDIubGVuZ3RoIC0gMSA9PT0gaSA/IHRva2Vucy5uZXdMaW5lIDogXCIsXCIgKyB0b2tlbnMubmV3TGluZU9yU3BhY2U7XG4gICAgICAgIGxldCB2YWx1ZSA9IHN0cmluZ2lmeU9iamVjdDIoZWwsIG9wdGlvbnMyLCBwYWQyICsgb3B0aW9uczIuaW5kZW50LCBbLi4ucGF0aDcsIGldKTtcbiAgICAgICAgaWYgKG9wdGlvbnMyLnRyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zMi50cmFuc2Zvcm1WYWx1ZShpbnB1dDIsIGksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zLmluZGVudCArIHZhbHVlICsgZW9sO1xuICAgICAgfSkuam9pbihcIlwiKSArIHRva2Vucy5wYWQgKyBcIl1cIjtcbiAgICAgIHNlZW4ucG9wKCk7XG4gICAgICByZXR1cm4gZXhwYW5kV2hpdGVTcGFjZShyZXQpO1xuICAgIH1cbiAgICBpZiAoaXNPYmooaW5wdXQyKSkge1xuICAgICAgbGV0IG9iaktleXMgPSBPYmplY3Qua2V5cyhpbnB1dDIpLmNvbmNhdChnZXRPd25FbnVtUHJvcFN5bWJvbHMoaW5wdXQyKSk7XG4gICAgICBpZiAob3B0aW9uczIuZmlsdGVyKSB7XG4gICAgICAgIG9iaktleXMgPSBvYmpLZXlzLmZpbHRlcigoZWwpID0+IG9wdGlvbnMyLmZpbHRlcihpbnB1dDIsIGVsKSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwie31cIjtcbiAgICAgIH1cbiAgICAgIHNlZW4ucHVzaChpbnB1dDIpO1xuICAgICAgY29uc3QgcmV0ID0gXCJ7XCIgKyB0b2tlbnMubmV3TGluZSArIG9iaktleXMubWFwKChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBlb2wgPSBvYmpLZXlzLmxlbmd0aCAtIDEgPT09IGkgPyB0b2tlbnMubmV3TGluZSA6IFwiLFwiICsgdG9rZW5zLm5ld0xpbmVPclNwYWNlO1xuICAgICAgICBjb25zdCBpc1N5bWJvbCA9IHR5cGVvZiBlbCA9PT0gXCJzeW1ib2xcIjtcbiAgICAgICAgY29uc3QgaXNDbGFzc2ljID0gIWlzU3ltYm9sICYmIC9eW2EteiRfXVthLXokXzAtOV0qJC9pLnRlc3QoZWwpO1xuICAgICAgICBjb25zdCBrZXkgPSBpc1N5bWJvbCB8fCBpc0NsYXNzaWMgPyBlbCA6IHN0cmluZ2lmeU9iamVjdDIoZWwsIG9wdGlvbnMyLCB2b2lkIDAsIFsuLi5wYXRoNywgZWxdKTtcbiAgICAgICAgbGV0IHZhbHVlID0gc3RyaW5naWZ5T2JqZWN0MihpbnB1dDJbZWxdLCBvcHRpb25zMiwgcGFkMiArIG9wdGlvbnMyLmluZGVudCwgWy4uLnBhdGg3LCBlbF0pO1xuICAgICAgICBpZiAob3B0aW9uczIudHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMyLnRyYW5zZm9ybVZhbHVlKGlucHV0MiwgZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IHRva2Vucy5pbmRlbnQgKyBTdHJpbmcoa2V5KSArIFwiOiBcIiArIHZhbHVlICsgZW9sO1xuICAgICAgICBpZiAob3B0aW9uczIudHJhbnNmb3JtTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBvcHRpb25zMi50cmFuc2Zvcm1MaW5lKHtcbiAgICAgICAgICAgIG9iajogaW5wdXQyLFxuICAgICAgICAgICAgaW5kZW50OiB0b2tlbnMuaW5kZW50LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc3RyaW5naWZpZWRWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5wdXQyW2VsXSxcbiAgICAgICAgICAgIGVvbCxcbiAgICAgICAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgICAgICAgIHBhdGg6IHBhdGg3LmNvbmNhdChrZXkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9KS5qb2luKFwiXCIpICsgdG9rZW5zLnBhZCArIFwifVwiO1xuICAgICAgc2Vlbi5wb3AoKTtcbiAgICAgIHJldHVybiBleHBhbmRXaGl0ZVNwYWNlKHJldCk7XG4gICAgfVxuICAgIGlucHV0MiA9IFN0cmluZyhpbnB1dDIpLnJlcGxhY2UoL1tcXHJcXG5dL2csICh4KSA9PiB4ID09PSBcIlxcblwiID8gXCJcXFxcblwiIDogXCJcXFxcclwiKTtcbiAgICBpZiAob3B0aW9uczIuc2luZ2xlUXVvdGVzID09PSBmYWxzZSkge1xuICAgICAgaW5wdXQyID0gaW5wdXQyLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbiAgICAgIHJldHVybiBgXCIke2lucHV0Mn1cImA7XG4gICAgfVxuICAgIGlucHV0MiA9IGlucHV0Mi5yZXBsYWNlKC9cXFxcPycvZywgXCJcXFxcJ1wiKTtcbiAgICByZXR1cm4gYCcke2lucHV0Mn0nYDtcbiAgfSwgXCJzdHJpbmdpZnlPYmplY3RcIikpKGlucHV0LCBvcHRpb25zLCBwYWQpO1xufSwgXCJzdHJpbmdpZnlPYmplY3RcIik7XG52YXIgc3RyaW5naWZ5T2JqZWN0X2RlZmF1bHQgPSBzdHJpbmdpZnlPYmplY3Q7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL3ByaW50SnNvbkVycm9ycy50c1xudmFyIERJTV9UT0tFTiA9IFwiQEBfX0RJTV9QT0lOVEVSX19AQFwiO1xuZnVuY3Rpb24gcHJpbnRKc29uV2l0aEVycm9ycyh7IGFzdCwga2V5UGF0aHMsIHZhbHVlUGF0aHMsIG1pc3NpbmdJdGVtcyB9KSB7XG4gIGxldCBvYmogPSBhc3Q7XG4gIGZvciAoY29uc3QgeyBwYXRoOiBwYXRoNywgdHlwZSB9IG9mIG1pc3NpbmdJdGVtcykge1xuICAgIG9iaiA9IGRlZXBTZXQob2JqLCBwYXRoNywgdHlwZSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdF9kZWZhdWx0KG9iaiwge1xuICAgIGluZGVudDogXCIgIFwiLFxuICAgIHRyYW5zZm9ybUxpbmU6ICh7IGluZGVudDogaW5kZW50NCwga2V5LCB2YWx1ZSwgc3RyaW5naWZpZWRWYWx1ZSwgZW9sLCBwYXRoOiBwYXRoNyB9KSA9PiB7XG4gICAgICBjb25zdCBkb3R0ZWRQYXRoID0gcGF0aDcuam9pbihcIi5cIik7XG4gICAgICBjb25zdCBrZXlFcnJvciA9IGtleVBhdGhzLmluY2x1ZGVzKGRvdHRlZFBhdGgpO1xuICAgICAgY29uc3QgdmFsdWVFcnJvciA9IHZhbHVlUGF0aHMuaW5jbHVkZXMoZG90dGVkUGF0aCk7XG4gICAgICBjb25zdCBtaXNzaW5nSXRlbSA9IG1pc3NpbmdJdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLnBhdGggPT09IGRvdHRlZFBhdGgpO1xuICAgICAgbGV0IHZhbHVlU3RyID0gc3RyaW5naWZpZWRWYWx1ZTtcbiAgICAgIGlmIChtaXNzaW5nSXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFsdWVTdHIgPSB2YWx1ZVN0ci5zbGljZSgxLCB2YWx1ZVN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1JlcXVpcmVkU3RyID0gbWlzc2luZ0l0ZW0uaXNSZXF1aXJlZCA/IFwiXCIgOiBcIj9cIjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbWlzc2luZ0l0ZW0uaXNSZXF1aXJlZCA/IFwiK1wiIDogXCI/XCI7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gbWlzc2luZ0l0ZW0uaXNSZXF1aXJlZCA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZ3JlZW5CcmlnaHQgOiBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LmdyZWVuO1xuICAgICAgICBsZXQgb3V0cHV0ID0gY29sb3IocHJlZml4TGluZXMoa2V5ICsgaXNSZXF1aXJlZFN0ciArIFwiOiBcIiArIHZhbHVlU3RyICsgZW9sLCBpbmRlbnQ0LCBwcmVmaXgpKTtcbiAgICAgICAgaWYgKCFtaXNzaW5nSXRlbS5pc1JlcXVpcmVkKSB7XG4gICAgICAgICAgb3V0cHV0ID0gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5kaW0ob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNPbk1pc3NpbmdJdGVtUGF0aCA9IG1pc3NpbmdJdGVtcy5zb21lKChpdGVtKSA9PiBkb3R0ZWRQYXRoLnN0YXJ0c1dpdGgoaXRlbS5wYXRoKSk7XG4gICAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBrZXlba2V5Lmxlbmd0aCAtIDJdID09PSBcIj9cIjtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICBrZXkgPSBrZXkuc2xpY2UoMSwga2V5Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlU3RyID0gdmFsdWVTdHIuc3BsaXQoXCJcXG5cIikubWFwKChsaW5lLCBpbmRleCwgYXJyKSA9PiBpbmRleCA9PT0gYXJyLmxlbmd0aCAtIDEgPyBsaW5lICsgRElNX1RPS0VOIDogbGluZSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPbk1pc3NpbmdJdGVtUGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZVN0ciA9IHZhbHVlU3RyLnNsaWNlKDEsIHZhbHVlU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGlmICghaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgdmFsdWVTdHIgPSBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LmJvbGQodmFsdWVTdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgIXZhbHVlRXJyb3IgJiYgIWlzT25NaXNzaW5nSXRlbVBhdGgpIHtcbiAgICAgICAgICB2YWx1ZVN0ciA9IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZGltKHZhbHVlU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlTdHIgPSBrZXlFcnJvciA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQucmVkQnJpZ2h0KGtleSkgOiBrZXk7XG4gICAgICAgIHZhbHVlU3RyID0gdmFsdWVFcnJvciA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQucmVkQnJpZ2h0KHZhbHVlU3RyKSA6IHZhbHVlU3RyO1xuICAgICAgICBsZXQgb3V0cHV0ID0gaW5kZW50NCArIGtleVN0ciArIFwiOiBcIiArIHZhbHVlU3RyICsgKGlzT25NaXNzaW5nSXRlbVBhdGggPyBlb2wgOiBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LmRpbShlb2wpKTtcbiAgICAgICAgaWYgKGtleUVycm9yIHx8IHZhbHVlRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IG91dHB1dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBTdHJpbmcoa2V5KS5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qga2V5U2NyaWJibGVzID0ga2V5RXJyb3IgPyBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LnJlZEJyaWdodChcIn5cIi5yZXBlYXQoa2V5TGVuZ3RoKSkgOiBcIiBcIi5yZXBlYXQoa2V5TGVuZ3RoKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZUxlbmd0aCA9IHZhbHVlRXJyb3IgPyBnZXRWYWx1ZUxlbmd0aChpbmRlbnQ0LCBrZXksIHZhbHVlLCBzdHJpbmdpZmllZFZhbHVlKSA6IDA7XG4gICAgICAgICAgY29uc3QgaGlkZVZhbHVlU2NyaWJibGVzID0gdmFsdWVFcnJvciAmJiBpc1JlbmRlcmVkQXNPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlU2NyaWJibGVzID0gdmFsdWVFcnJvciA/IFwiICBcIiArIGltcG9ydF9jaGFsazEwLmRlZmF1bHQucmVkQnJpZ2h0KFwiflwiLnJlcGVhdCh2YWx1ZUxlbmd0aCkpIDogXCJcIjtcbiAgICAgICAgICBpZiAoa2V5U2NyaWJibGVzICYmIGtleVNjcmliYmxlcy5sZW5ndGggPiAwICYmICFoaWRlVmFsdWVTY3JpYmJsZXMpIHtcbiAgICAgICAgICAgIGxpbmVzLnNwbGljZSgxLCAwLCBpbmRlbnQ0ICsga2V5U2NyaWJibGVzICsgdmFsdWVTY3JpYmJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5U2NyaWJibGVzICYmIGtleVNjcmliYmxlcy5sZW5ndGggPiAwICYmIGhpZGVWYWx1ZVNjcmliYmxlcykge1xuICAgICAgICAgICAgbGluZXMuc3BsaWNlKGxpbmVzLmxlbmd0aCAtIDEsIDAsIGluZGVudDQuc2xpY2UoMCwgaW5kZW50NC5sZW5ndGggLSAyKSArIHZhbHVlU2NyaWJibGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0ID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5fX25hbWUocHJpbnRKc29uV2l0aEVycm9ycywgXCJwcmludEpzb25XaXRoRXJyb3JzXCIpO1xuZnVuY3Rpb24gZ2V0VmFsdWVMZW5ndGgoaW5kZW50NCwga2V5LCB2YWx1ZSwgc3RyaW5naWZpZWRWYWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gNDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCArIDI7XG4gIH1cbiAgaWYgKGlzUmVuZGVyZWRBc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZ2V0TG9uZ2VzdExpbmUoYCR7a2V5fTogJHsoMCwgaW1wb3J0X3N0cmlwX2Fuc2kyLmRlZmF1bHQpKHN0cmluZ2lmaWVkVmFsdWUpfWApIC0gaW5kZW50NC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLmxlbmd0aDtcbn1cbl9fbmFtZShnZXRWYWx1ZUxlbmd0aCwgXCJnZXRWYWx1ZUxlbmd0aFwiKTtcbmZ1bmN0aW9uIGlzUmVuZGVyZWRBc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmICEodmFsdWUgaW5zdGFuY2VvZiBPYmplY3RFbnVtVmFsdWUpO1xufVxuX19uYW1lKGlzUmVuZGVyZWRBc09iamVjdCwgXCJpc1JlbmRlcmVkQXNPYmplY3RcIik7XG5mdW5jdGlvbiBnZXRMb25nZXN0TGluZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChcIlxcblwiKS5yZWR1Y2UoKG1heDIsIGN1cnIpID0+IGN1cnIubGVuZ3RoID4gbWF4MiA/IGN1cnIubGVuZ3RoIDogbWF4MiwgMCk7XG59XG5fX25hbWUoZ2V0TG9uZ2VzdExpbmUsIFwiZ2V0TG9uZ2VzdExpbmVcIik7XG5mdW5jdGlvbiBwcmVmaXhMaW5lcyhzdHIsIGluZGVudDQsIHByZWZpeCkge1xuICByZXR1cm4gc3RyLnNwbGl0KFwiXFxuXCIpLm1hcChcbiAgICAobGluZSwgaW5kZXgsIGFycikgPT4gaW5kZXggPT09IDAgPyBwcmVmaXggKyBpbmRlbnQ0LnNsaWNlKDEpICsgbGluZSA6IGluZGV4IDwgYXJyLmxlbmd0aCAtIDEgPyBwcmVmaXggKyBsaW5lLnNsaWNlKDEpIDogbGluZVxuICApLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3N0cmlwX2Fuc2kyLmRlZmF1bHQpKGxpbmUpLmluY2x1ZGVzKERJTV9UT0tFTikgPyBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LmRpbShsaW5lLnJlcGxhY2UoRElNX1RPS0VOLCBcIlwiKSkgOiBsaW5lLmluY2x1ZGVzKFwiP1wiKSA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZGltKGxpbmUpIDogbGluZTtcbiAgfSkuam9pbihcIlxcblwiKTtcbn1cbl9fbmFtZShwcmVmaXhMaW5lcywgXCJwcmVmaXhMaW5lc1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvcXVlcnkudHNcbnZhciB0YWIgPSAyO1xudmFyIERvY3VtZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjaGlsZHJlbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucHJpbnRGaWVsZEVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoeyBlcnJvcjogZXJyb3IyIH0sIG1pc3NpbmdJdGVtcywgbWluaW1hbCkgPT4ge1xuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImVtcHR5U2VsZWN0XCIpIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbCA9IG1pbmltYWwgPyBcIlwiIDogYCBBdmFpbGFibGUgb3B0aW9ucyBhcmUgbGlzdGVkIGluICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodC5kaW0oXCJncmVlblwiKX0uYDtcbiAgICAgICAgcmV0dXJuIGBUaGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcImBzZWxlY3RgXCIpfSBzdGF0ZW1lbnQgZm9yIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgZ2V0T3V0cHV0VHlwZU5hbWUoZXJyb3IyLmZpZWxkLm91dHB1dFR5cGUudHlwZSlcbiAgICAgICAgKX0gbXVzdCBub3QgYmUgZW1wdHkuJHthZGRpdGlvbmFsfWA7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiZW1wdHlJbmNsdWRlXCIpIHtcbiAgICAgICAgaWYgKG1pc3NpbmdJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYCR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgICAgZ2V0T3V0cHV0VHlwZU5hbWUoZXJyb3IyLmZpZWxkLm91dHB1dFR5cGUudHlwZSlcbiAgICAgICAgICApfSBkb2VzIG5vdCBoYXZlIGFueSByZWxhdGlvbiBhbmQgdGhlcmVmb3JlIGNhbid0IGhhdmUgYW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcImBpbmNsdWRlYFwiKX0gc3RhdGVtZW50LmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkaXRpb25hbCA9IG1pbmltYWwgPyBcIlwiIDogYCBBdmFpbGFibGUgb3B0aW9ucyBhcmUgbGlzdGVkIGluICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodC5kaW0oXCJncmVlblwiKX0uYDtcbiAgICAgICAgcmV0dXJuIGBUaGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcImBpbmNsdWRlYFwiKX0gc3RhdGVtZW50IGZvciB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgIGdldE91dHB1dFR5cGVOYW1lKGVycm9yMi5maWVsZC5vdXRwdXRUeXBlLnR5cGUpXG4gICAgICAgICl9IG11c3Qgbm90IGJlIGVtcHR5LiR7YWRkaXRpb25hbH1gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcIm5vVHJ1ZVNlbGVjdFwiKSB7XG4gICAgICAgIHJldHVybiBgVGhlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoXCJgc2VsZWN0YFwiKX0gc3RhdGVtZW50IGZvciB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgIGdldE91dHB1dFR5cGVOYW1lKGVycm9yMi5maWVsZC5vdXRwdXRUeXBlLnR5cGUpXG4gICAgICAgICl9IG5lZWRzICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFwiYXQgbGVhc3Qgb25lIHRydXRoeSB2YWx1ZVwiKX0uYDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJpbmNsdWRlQW5kU2VsZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGBQbGVhc2UgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXCJlaXRoZXJcIil9IHVzZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJgaW5jbHVkZWBcIil9IG9yICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcbiAgICAgICAgICBcImBzZWxlY3RgXCJcbiAgICAgICAgKX0sIGJ1dCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KFwibm90IGJvdGhcIil9IGF0IHRoZSBzYW1lIHRpbWUuYDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJpbnZhbGlkRmllbGROYW1lXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gZXJyb3IyLmlzSW5jbHVkZSA/IFwiaW5jbHVkZVwiIDogXCJzZWxlY3RcIjtcbiAgICAgICAgY29uc3Qgd29yZGluZyA9IGVycm9yMi5pc0luY2x1ZGVTY2FsYXIgPyBcIkludmFsaWQgc2NhbGFyXCIgOiBcIlVua25vd25cIjtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbCA9IG1pbmltYWwgPyBcIlwiIDogZXJyb3IyLmlzSW5jbHVkZSAmJiBtaXNzaW5nSXRlbXMubGVuZ3RoID09PSAwID8gYFxuVGhpcyBtb2RlbCBoYXMgbm8gcmVsYXRpb25zLCBzbyB5b3UgY2FuJ3QgdXNlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoXCJpbmNsdWRlXCIpfSB3aXRoIGl0LmAgOiBgIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBsaXN0ZWQgaW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0LmRpbShcImdyZWVuXCIpfS5gO1xuICAgICAgICBsZXQgc3RyID0gYCR7d29yZGluZ30gZmllbGQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChgXFxgJHtlcnJvcjIucHJvdmlkZWROYW1lfVxcYGApfSBmb3IgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgc3RhdGVtZW50XG4gICAgICAgICl9IHN0YXRlbWVudCBvbiBtb2RlbCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZC53aGl0ZShlcnJvcjIubW9kZWxOYW1lKX0uJHthZGRpdGlvbmFsfWA7XG4gICAgICAgIGlmIChlcnJvcjIuZGlkWW91TWVhbikge1xuICAgICAgICAgIHN0ciArPSBgIERpZCB5b3UgbWVhbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoYFxcYCR7ZXJyb3IyLmRpZFlvdU1lYW59XFxgYCl9P2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yMi5pc0luY2x1ZGVTY2FsYXIpIHtcbiAgICAgICAgICBzdHIgKz0gYFxuTm90ZSwgdGhhdCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcImluY2x1ZGVcIil9IHN0YXRlbWVudHMgb25seSBhY2NlcHQgcmVsYXRpb24gZmllbGRzLmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJpbnZhbGlkRmllbGRUeXBlXCIpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gYEludmFsaWQgdmFsdWUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcbiAgICAgICAgICBgJHtzdHJpbmdpZnlPYmplY3RfZGVmYXVsdChlcnJvcjIucHJvdmlkZWRWYWx1ZSl9YFxuICAgICAgICApfSBvZiB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoZ2V0R3JhcGhRTFR5cGUoZXJyb3IyLnByb3ZpZGVkVmFsdWUsIHZvaWQgMCkpfSBmb3IgZmllbGQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgYCR7ZXJyb3IyLmZpZWxkTmFtZX1gXG4gICAgICAgICl9IG9uIG1vZGVsICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkLndoaXRlKGVycm9yMi5tb2RlbE5hbWUpfS4gRXhwZWN0ZWQgZWl0aGVyICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcbiAgICAgICAgICBcInRydWVcIlxuICAgICAgICApfSBvciAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJmYWxzZVwiKX0uYDtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSwgXCJwcmludEZpZWxkRXJyb3JcIik7XG4gICAgdGhpcy5wcmludEFyZ0Vycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoeyBlcnJvcjogZXJyb3IyLCBwYXRoOiBwYXRoNywgaWQgfSwgaGFzTWlzc2luZ0l0ZW1zLCBtaW5pbWFsKSA9PiB7XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiaW52YWxpZE5hbWVcIikge1xuICAgICAgICBsZXQgc3RyID0gYFVua25vd24gYXJnICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoYFxcYCR7ZXJyb3IyLnByb3ZpZGVkTmFtZX1cXGBgKX0gaW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgcGF0aDcuam9pbihcIi5cIilcbiAgICAgICAgKX0gZm9yIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoZXJyb3IyLm91dHB1dFR5cGUgPyBlcnJvcjIub3V0cHV0VHlwZS5uYW1lIDogZ2V0SW5wdXRUeXBlTmFtZShlcnJvcjIub3JpZ2luYWxUeXBlKSl9LmA7XG4gICAgICAgIGlmIChlcnJvcjIuZGlkWW91TWVhbkZpZWxkKSB7XG4gICAgICAgICAgc3RyICs9IGBcblxcdTIxOTIgRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCBpdCB3aXRoIFxcYCR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcInNlbGVjdFwiKX1cXGA/ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oXG4gICAgICAgICAgICBcImUuZy4gXCIgKyBpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KGB7IHNlbGVjdDogeyAke2Vycm9yMi5wcm92aWRlZE5hbWV9OiAke2Vycm9yMi5wcm92aWRlZFZhbHVlfSB9IH1gKVxuICAgICAgICAgICl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvcjIuZGlkWW91TWVhbkFyZykge1xuICAgICAgICAgIHN0ciArPSBgIERpZCB5b3UgbWVhbiBcXGAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoZXJyb3IyLmRpZFlvdU1lYW5BcmcpfVxcYD9gO1xuICAgICAgICAgIGlmICghaGFzTWlzc2luZ0l0ZW1zICYmICFtaW5pbWFsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKFwiQXZhaWxhYmxlIGFyZ3M6XCIpfVxuYCArIHN0cmluZ2lmeUlucHV0VHlwZShlcnJvcjIub3JpZ2luYWxUeXBlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVycm9yMi5vcmlnaW5hbFR5cGUuZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyICs9IGAgVGhlIGZpZWxkICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKGVycm9yMi5vcmlnaW5hbFR5cGUubmFtZSl9IGhhcyBubyBhcmd1bWVudHMuYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFoYXNNaXNzaW5nSXRlbXMgJiYgIW1pbmltYWwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgIEF2YWlsYWJsZSBhcmdzOlxuXG5gICsgc3RyaW5naWZ5SW5wdXRUeXBlKGVycm9yMi5vcmlnaW5hbFR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImludmFsaWRUeXBlXCIpIHtcbiAgICAgICAgbGV0IHZhbHVlU3RyID0gc3RyaW5naWZ5T2JqZWN0X2RlZmF1bHQoZXJyb3IyLnByb3ZpZGVkVmFsdWUsIHsgaW5kZW50OiBcIiAgXCIgfSk7XG4gICAgICAgIGNvbnN0IG11bHRpbGluZVZhbHVlID0gdmFsdWVTdHIuc3BsaXQoXCJcXG5cIikubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKG11bHRpbGluZVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWVTdHIgPSBgXG4ke3ZhbHVlU3RyfVxuYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUubG9jYXRpb24gPT09IFwiZW51bVR5cGVzXCIpIHtcbiAgICAgICAgICByZXR1cm4gYEFyZ3VtZW50ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKGVycm9yMi5hcmdOYW1lKX06IFByb3ZpZGVkIHZhbHVlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQodmFsdWVTdHIpfSR7bXVsdGlsaW5lVmFsdWUgPyBcIlwiIDogXCIgXCJ9b2YgdHlwZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KGdldEdyYXBoUUxUeXBlKGVycm9yMi5wcm92aWRlZFZhbHVlKSl9IG9uICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgICAgYHByaXNtYS4ke3RoaXMuY2hpbGRyZW5bMF0ubmFtZX1gXG4gICAgICAgICAgKX0gaXMgbm90IGEgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFxuICAgICAgICAgICAgd3JhcFdpdGhMaXN0KFxuICAgICAgICAgICAgICBzdHJpbmdpZnlHcmFwaFFMVHlwZShlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS50eXBlKSxcbiAgICAgICAgICAgICAgZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUuaXNMaXN0XG4gICAgICAgICAgICApXG4gICAgICAgICAgKX0uXG5cXHUyMTkyIFBvc3NpYmxlIHZhbHVlczogJHtlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS50eXBlLnZhbHVlcy5tYXAoKHYpID0+IGltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoYCR7c3RyaW5naWZ5R3JhcGhRTFR5cGUoZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUudHlwZSl9LiR7dn1gKSkuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGVTdHIgPSBcIi5cIjtcbiAgICAgICAgaWYgKGlzSW5wdXRBcmdUeXBlKGVycm9yMi5yZXF1aXJlZFR5cGUuYmVzdEZpdHRpbmdUeXBlLnR5cGUpKSB7XG4gICAgICAgICAgdHlwZVN0ciA9IFwiOlxcblwiICsgc3RyaW5naWZ5SW5wdXRUeXBlKGVycm9yMi5yZXF1aXJlZFR5cGUuYmVzdEZpdHRpbmdUeXBlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHBlY3RlZCA9IGAke2Vycm9yMi5yZXF1aXJlZFR5cGUuaW5wdXRUeXBlLm1hcChcbiAgICAgICAgICAodCkgPT4gaW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodCh3cmFwV2l0aExpc3Qoc3RyaW5naWZ5R3JhcGhRTFR5cGUodC50eXBlKSwgZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUuaXNMaXN0KSlcbiAgICAgICAgKS5qb2luKFwiIG9yIFwiKX0ke3R5cGVTdHJ9YDtcbiAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gZXJyb3IyLnJlcXVpcmVkVHlwZS5pbnB1dFR5cGUubGVuZ3RoID09PSAyICYmIGVycm9yMi5yZXF1aXJlZFR5cGUuaW5wdXRUeXBlLmZpbmQoKHQpID0+IGlzSW5wdXRBcmdUeXBlKHQudHlwZSkpIHx8IG51bGw7XG4gICAgICAgIGlmIChpbnB1dFR5cGUpIHtcbiAgICAgICAgICBleHBlY3RlZCArPSBgXG5gICsgc3RyaW5naWZ5SW5wdXRUeXBlKGlucHV0VHlwZS50eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFyZ3VtZW50ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKGVycm9yMi5hcmdOYW1lKX06IEdvdCBpbnZhbGlkIHZhbHVlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQodmFsdWVTdHIpfSR7bXVsdGlsaW5lVmFsdWUgPyBcIlwiIDogXCIgXCJ9b24gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoYHByaXNtYS4ke3RoaXMuY2hpbGRyZW5bMF0ubmFtZX1gKX0uIFByb3ZpZGVkICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoXG4gICAgICAgICAgZ2V0R3JhcGhRTFR5cGUoZXJyb3IyLnByb3ZpZGVkVmFsdWUpXG4gICAgICAgICl9LCBleHBlY3RlZCAke2V4cGVjdGVkfWA7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiaW52YWxpZE51bGxBcmdcIikge1xuICAgICAgICBjb25zdCBmb3JTdHIgPSBwYXRoNy5sZW5ndGggPT09IDEgJiYgcGF0aDdbMF0gPT09IGVycm9yMi5uYW1lID8gXCJcIiA6IGAgZm9yICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKGAke3BhdGg3LmpvaW4oXCIuXCIpfWApfWA7XG4gICAgICAgIGNvbnN0IHVuZGVmaW5lZFRpcCA9IGAgUGxlYXNlIHVzZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZC5ncmVlbkJyaWdodChcInVuZGVmaW5lZFwiKX0gaW5zdGVhZC5gO1xuICAgICAgICByZXR1cm4gYEFyZ3VtZW50ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChlcnJvcjIubmFtZSl9JHtmb3JTdHJ9IG11c3Qgbm90IGJlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFwibnVsbFwiKX0uJHt1bmRlZmluZWRUaXB9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJtaXNzaW5nQXJnXCIpIHtcbiAgICAgICAgY29uc3QgZm9yU3RyID0gcGF0aDcubGVuZ3RoID09PSAxICYmIHBhdGg3WzBdID09PSBlcnJvcjIubWlzc2luZ05hbWUgPyBcIlwiIDogYCBmb3IgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoYCR7cGF0aDcuam9pbihcIi5cIil9YCl9YDtcbiAgICAgICAgcmV0dXJuIGBBcmd1bWVudCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoZXJyb3IyLm1pc3NpbmdOYW1lKX0ke2ZvclN0cn0gaXMgbWlzc2luZy5gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImF0TGVhc3RPbmVcIikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gbWluaW1hbCA/IFwiXCIgOiBgIEF2YWlsYWJsZSBhcmdzIGFyZSBsaXN0ZWQgaW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmRpbS5ncmVlbihcImdyZWVuXCIpfS5gO1xuICAgICAgICByZXR1cm4gYEFyZ3VtZW50ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKHBhdGg3LmpvaW4oXCIuXCIpKX0gb2YgdHlwZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcbiAgICAgICAgICBlcnJvcjIuaW5wdXRUeXBlLm5hbWVcbiAgICAgICAgKX0gbmVlZHMgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFwiYXQgbGVhc3Qgb25lXCIpfSBhcmd1bWVudC4ke2FkZGl0aW9uYWx9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJhdE1vc3RPbmVcIikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gbWluaW1hbCA/IFwiXCIgOiBgIFBsZWFzZSBjaG9vc2Ugb25lLiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKFwiQXZhaWxhYmxlIGFyZ3M6XCIpfSBcbiR7c3RyaW5naWZ5SW5wdXRUeXBlKGVycm9yMi5pbnB1dFR5cGUsIHRydWUpfWA7XG4gICAgICAgIHJldHVybiBgQXJndW1lbnQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQocGF0aDcuam9pbihcIi5cIikpfSBvZiB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgIGVycm9yMi5pbnB1dFR5cGUubmFtZVxuICAgICAgICApfSBuZWVkcyAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJleGFjdGx5IG9uZVwiKX0gYXJndW1lbnQsIGJ1dCB5b3UgcHJvdmlkZWQgJHtlcnJvcjIucHJvdmlkZWRLZXlzLm1hcCgoa2V5KSA9PiBpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChrZXkpKS5qb2luKFwiIGFuZCBcIil9LiR7YWRkaXRpb25hbH1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LCBcInByaW50QXJnRXJyb3JcIik7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkRvY3VtZW50XCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwZX0ge1xuJHsoMCwgaW1wb3J0X2luZGVudF9zdHJpbmc0LmRlZmF1bHQpKHRoaXMuY2hpbGRyZW4ubWFwKFN0cmluZykuam9pbihcIlxcblwiKSwgdGFiKX1cbn1gO1xuICB9XG4gIHZhbGlkYXRlKHNlbGVjdCwgaXNUb3BMZXZlbFF1ZXJ5ID0gZmFsc2UsIG9yaWdpbmFsTWV0aG9kLCBlcnJvckZvcm1hdCwgdmFsaWRhdGlvbkNhbGxzaXRlKSB7XG4gICAgdmFyIF9hMztcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgc2VsZWN0ID0ge307XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWRDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQuaGFzSW52YWxpZENoaWxkIHx8IGNoaWxkLmhhc0ludmFsaWRBcmcpO1xuICAgIGlmIChpbnZhbGlkQ2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0gW107XG4gICAgY29uc3QgYXJnRXJyb3JzID0gW107XG4gICAgY29uc3QgcHJlZml4ID0gc2VsZWN0ICYmIHNlbGVjdC5zZWxlY3QgPyBcInNlbGVjdFwiIDogc2VsZWN0LmluY2x1ZGUgPyBcImluY2x1ZGVcIiA6IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGludmFsaWRDaGlsZHJlbikge1xuICAgICAgY29uc3QgZXJyb3JzID0gY2hpbGQuY29sbGVjdEVycm9ycyhwcmVmaXgpO1xuICAgICAgZmllbGRFcnJvcnMucHVzaChcbiAgICAgICAgLi4uZXJyb3JzLmZpZWxkRXJyb3JzLm1hcCgoZSkgPT4gKHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIHBhdGg6IGlzVG9wTGV2ZWxRdWVyeSA/IGUucGF0aCA6IGUucGF0aC5zbGljZSgxKVxuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgICBhcmdFcnJvcnMucHVzaChcbiAgICAgICAgLi4uZXJyb3JzLmFyZ0Vycm9ycy5tYXAoKGUpID0+ICh7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICBwYXRoOiBpc1RvcExldmVsUXVlcnkgPyBlLnBhdGggOiBlLnBhdGguc2xpY2UoMSlcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0b3BMZXZlbFF1ZXJ5TmFtZSA9IHRoaXMuY2hpbGRyZW5bMF0ubmFtZTtcbiAgICBjb25zdCBxdWVyeU5hbWUgPSBpc1RvcExldmVsUXVlcnkgPyB0aGlzLnR5cGUgOiB0b3BMZXZlbFF1ZXJ5TmFtZTtcbiAgICBjb25zdCBrZXlQYXRocyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlUGF0aHMgPSBbXTtcbiAgICBjb25zdCBtaXNzaW5nSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkRXJyb3Igb2YgZmllbGRFcnJvcnMpIHtcbiAgICAgIGNvbnN0IHBhdGg3ID0gdGhpcy5ub3JtYWxpemVQYXRoKGZpZWxkRXJyb3IucGF0aCwgc2VsZWN0KS5qb2luKFwiLlwiKTtcbiAgICAgIGlmIChmaWVsZEVycm9yLmVycm9yLnR5cGUgPT09IFwiaW52YWxpZEZpZWxkTmFtZVwiKSB7XG4gICAgICAgIGtleVBhdGhzLnB1c2gocGF0aDcpO1xuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZEVycm9yLmVycm9yLm91dHB1dFR5cGU7XG4gICAgICAgIGNvbnN0IHsgaXNJbmNsdWRlIH0gPSBmaWVsZEVycm9yLmVycm9yO1xuICAgICAgICBmaWVsZFR5cGUuZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGlzSW5jbHVkZSA/IGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIiA6IHRydWUpLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3BsaXR0ZWRQYXRoID0gcGF0aDcuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIG1pc3NpbmdJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IGAke3NwbGl0dGVkUGF0aC5zbGljZSgwLCBzcGxpdHRlZFBhdGgubGVuZ3RoIC0gMSkuam9pbihcIi5cIil9LiR7ZmllbGQubmFtZX1gLFxuICAgICAgICAgICAgdHlwZTogXCJ0cnVlXCIsXG4gICAgICAgICAgICBpc1JlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZmllbGRFcnJvci5lcnJvci50eXBlID09PSBcImluY2x1ZGVBbmRTZWxlY3RcIikge1xuICAgICAgICBrZXlQYXRocy5wdXNoKFwic2VsZWN0XCIpO1xuICAgICAgICBrZXlQYXRocy5wdXNoKFwiaW5jbHVkZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlUGF0aHMucHVzaChwYXRoNyk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGRFcnJvci5lcnJvci50eXBlID09PSBcImVtcHR5U2VsZWN0XCIgfHwgZmllbGRFcnJvci5lcnJvci50eXBlID09PSBcIm5vVHJ1ZVNlbGVjdFwiIHx8IGZpZWxkRXJyb3IuZXJyb3IudHlwZSA9PT0gXCJlbXB0eUluY2x1ZGVcIikge1xuICAgICAgICBjb25zdCBzZWxlY3RQYXRoQXJyYXkgPSB0aGlzLm5vcm1hbGl6ZVBhdGgoZmllbGRFcnJvci5wYXRoLCBzZWxlY3QpO1xuICAgICAgICBjb25zdCBzZWxlY3RQYXRoID0gc2VsZWN0UGF0aEFycmF5LnNsaWNlKDAsIHNlbGVjdFBhdGhBcnJheS5sZW5ndGggLSAxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gZmllbGRFcnJvci5lcnJvci5maWVsZC5vdXRwdXRUeXBlLnR5cGU7XG4gICAgICAgIChfYTMgPSBmaWVsZFR5cGUuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmZpbHRlcihcbiAgICAgICAgICAoZmllbGQpID0+IGZpZWxkRXJyb3IuZXJyb3IudHlwZSA9PT0gXCJlbXB0eUluY2x1ZGVcIiA/IGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIiA6IHRydWVcbiAgICAgICAgKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgIG1pc3NpbmdJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IGAke3NlbGVjdFBhdGh9LiR7ZmllbGQubmFtZX1gLFxuICAgICAgICAgICAgdHlwZTogXCJ0cnVlXCIsXG4gICAgICAgICAgICBpc1JlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhcmdFcnJvciBvZiBhcmdFcnJvcnMpIHtcbiAgICAgIGNvbnN0IHBhdGg3ID0gdGhpcy5ub3JtYWxpemVQYXRoKGFyZ0Vycm9yLnBhdGgsIHNlbGVjdCkuam9pbihcIi5cIik7XG4gICAgICBpZiAoYXJnRXJyb3IuZXJyb3IudHlwZSA9PT0gXCJpbnZhbGlkTmFtZVwiKSB7XG4gICAgICAgIGtleVBhdGhzLnB1c2gocGF0aDcpO1xuICAgICAgfSBlbHNlIGlmIChhcmdFcnJvci5lcnJvci50eXBlICE9PSBcIm1pc3NpbmdBcmdcIiAmJiBhcmdFcnJvci5lcnJvci50eXBlICE9PSBcImF0TGVhc3RPbmVcIikge1xuICAgICAgICB2YWx1ZVBhdGhzLnB1c2gocGF0aDcpO1xuICAgICAgfSBlbHNlIGlmIChhcmdFcnJvci5lcnJvci50eXBlID09PSBcIm1pc3NpbmdBcmdcIikge1xuICAgICAgICBjb25zdCB0eXBlID0gYXJnRXJyb3IuZXJyb3IubWlzc2luZ0FyZy5pbnB1dFR5cGVzLmxlbmd0aCA9PT0gMSA/IGFyZ0Vycm9yLmVycm9yLm1pc3NpbmdBcmcuaW5wdXRUeXBlc1swXS50eXBlIDogYXJnRXJyb3IuZXJyb3IubWlzc2luZ0FyZy5pbnB1dFR5cGVzLm1hcCgodCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlucHV0VHlwZU5hbWUgPSBnZXRJbnB1dFR5cGVOYW1lKHQudHlwZSk7XG4gICAgICAgICAgaWYgKGlucHV0VHlwZU5hbWUgPT09IFwiTnVsbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0LmlzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0VHlwZU5hbWUgKyBcIltdXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dFR5cGVOYW1lO1xuICAgICAgICB9KS5qb2luKFwiIHwgXCIpO1xuICAgICAgICBtaXNzaW5nSXRlbXMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcGF0aDcsXG4gICAgICAgICAgdHlwZTogaW5wdXRUeXBlVG9Kc29uKHR5cGUsIHRydWUsIHBhdGg3LnNwbGl0KFwid2hlcmUuXCIpLmxlbmd0aCA9PT0gMiksXG4gICAgICAgICAgaXNSZXF1aXJlZDogYXJnRXJyb3IuZXJyb3IubWlzc2luZ0FyZy5pc1JlcXVpcmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZW5kZXJFcnJvclN0ciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNhbGxzaXRlKSA9PiB7XG4gICAgICBjb25zdCBoYXNSZXF1aXJlZE1pc3NpbmdBcmdzRXJyb3JzID0gYXJnRXJyb3JzLnNvbWUoXG4gICAgICAgIChlKSA9PiBlLmVycm9yLnR5cGUgPT09IFwibWlzc2luZ0FyZ1wiICYmIGUuZXJyb3IubWlzc2luZ0FyZy5pc1JlcXVpcmVkXG4gICAgICApO1xuICAgICAgY29uc3QgaGFzT3B0aW9uYWxNaXNzaW5nQXJnc0Vycm9ycyA9IEJvb2xlYW4oXG4gICAgICAgIGFyZ0Vycm9ycy5maW5kKChlKSA9PiBlLmVycm9yLnR5cGUgPT09IFwibWlzc2luZ0FyZ1wiICYmICFlLmVycm9yLm1pc3NpbmdBcmcuaXNSZXF1aXJlZClcbiAgICAgICk7XG4gICAgICBjb25zdCBoYXNNaXNzaW5nQXJnc0Vycm9ycyA9IGhhc09wdGlvbmFsTWlzc2luZ0FyZ3NFcnJvcnMgfHwgaGFzUmVxdWlyZWRNaXNzaW5nQXJnc0Vycm9ycztcbiAgICAgIGxldCBtaXNzaW5nQXJnc0xlZ2VuZCA9IFwiXCI7XG4gICAgICBpZiAoaGFzUmVxdWlyZWRNaXNzaW5nQXJnc0Vycm9ycykge1xuICAgICAgICBtaXNzaW5nQXJnc0xlZ2VuZCArPSBgXG4ke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKFwiTm90ZTogTGluZXMgd2l0aCBcIil9JHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlc2V0LmdyZWVuQnJpZ2h0KFwiK1wiKX0gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmRpbShcbiAgICAgICAgICBcImFyZSByZXF1aXJlZFwiXG4gICAgICAgICl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPcHRpb25hbE1pc3NpbmdBcmdzRXJyb3JzKSB7XG4gICAgICAgIGlmIChtaXNzaW5nQXJnc0xlZ2VuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBtaXNzaW5nQXJnc0xlZ2VuZCA9IFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1JlcXVpcmVkTWlzc2luZ0FyZ3NFcnJvcnMpIHtcbiAgICAgICAgICBtaXNzaW5nQXJnc0xlZ2VuZCArPSBpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmRpbShgLCBsaW5lcyB3aXRoICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbihcIj9cIil9IGFyZSBvcHRpb25hbGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pc3NpbmdBcmdzTGVnZW5kICs9IGltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKGBOb3RlOiBMaW5lcyB3aXRoICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbihcIj9cIil9IGFyZSBvcHRpb25hbGApO1xuICAgICAgICB9XG4gICAgICAgIG1pc3NpbmdBcmdzTGVnZW5kICs9IGltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKFwiLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGV2YW50QXJnRXJyb3JzID0gYXJnRXJyb3JzLmZpbHRlcigoZSkgPT4gZS5lcnJvci50eXBlICE9PSBcIm1pc3NpbmdBcmdcIiB8fCBlLmVycm9yLm1pc3NpbmdBcmcuaXNSZXF1aXJlZCk7XG4gICAgICBsZXQgZXJyb3JNZXNzYWdlcyA9IHJlbGV2YW50QXJnRXJyb3JzLm1hcCgoZSkgPT4gdGhpcy5wcmludEFyZ0Vycm9yKGUsIGhhc01pc3NpbmdBcmdzRXJyb3JzLCBlcnJvckZvcm1hdCA9PT0gXCJtaW5pbWFsXCIpKS5qb2luKFwiXFxuXCIpO1xuICAgICAgZXJyb3JNZXNzYWdlcyArPSBgXG4ke2ZpZWxkRXJyb3JzLm1hcCgoZSkgPT4gdGhpcy5wcmludEZpZWxkRXJyb3IoZSwgbWlzc2luZ0l0ZW1zLCBlcnJvckZvcm1hdCA9PT0gXCJtaW5pbWFsXCIpKS5qb2luKFwiXFxuXCIpfWA7XG4gICAgICBpZiAoZXJyb3JGb3JtYXQgPT09IFwibWluaW1hbFwiKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW1wb3J0X3N0cmlwX2Fuc2kzLmRlZmF1bHQpKGVycm9yTWVzc2FnZXMpO1xuICAgICAgfVxuICAgICAgbGV0IHByaW50SnNvbkFyZ3MgPSB7XG4gICAgICAgIGFzdDogaXNUb3BMZXZlbFF1ZXJ5ID8geyBbdG9wTGV2ZWxRdWVyeU5hbWVdOiBzZWxlY3QgfSA6IHNlbGVjdCxcbiAgICAgICAga2V5UGF0aHMsXG4gICAgICAgIHZhbHVlUGF0aHMsXG4gICAgICAgIG1pc3NpbmdJdGVtc1xuICAgICAgfTtcbiAgICAgIGlmIChvcmlnaW5hbE1ldGhvZCA9PSBudWxsID8gdm9pZCAwIDogb3JpZ2luYWxNZXRob2QuZW5kc1dpdGgoXCJhZ2dyZWdhdGVcIikpIHtcbiAgICAgICAgcHJpbnRKc29uQXJncyA9IHRyYW5zZm9ybUFnZ3JlZ2F0ZVByaW50SnNvbkFyZ3MocHJpbnRKc29uQXJncyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvclN0ciA9IGNyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgY2FsbHNpdGUsXG4gICAgICAgIG9yaWdpbmFsTWV0aG9kOiBvcmlnaW5hbE1ldGhvZCB8fCBxdWVyeU5hbWUsXG4gICAgICAgIHNob3dDb2xvcnM6IGVycm9yRm9ybWF0ICYmIGVycm9yRm9ybWF0ID09PSBcInByZXR0eVwiLFxuICAgICAgICBjYWxsQXJndW1lbnRzOiBwcmludEpzb25XaXRoRXJyb3JzKHByaW50SnNvbkFyZ3MpLFxuICAgICAgICBtZXNzYWdlOiBgJHtlcnJvck1lc3NhZ2VzfSR7bWlzc2luZ0FyZ3NMZWdlbmR9XG5gXG4gICAgICB9KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT19DT0xPUiB8fCBlcnJvckZvcm1hdCA9PT0gXCJjb2xvcmxlc3NcIikge1xuICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9zdHJpcF9hbnNpMy5kZWZhdWx0KShlcnJvclN0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JTdHI7XG4gICAgfSwgXCJyZW5kZXJFcnJvclN0clwiKTtcbiAgICBjb25zdCBlcnJvcjIgPSBuZXcgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKHJlbmRlckVycm9yU3RyKHZhbGlkYXRpb25DYWxsc2l0ZSkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvcjIsIFwicmVuZGVyXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZW5kZXJFcnJvclN0cixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjI7XG4gIH1cbiAgbm9ybWFsaXplUGF0aChpbnB1dFBhdGgsIHNlbGVjdCkge1xuICAgIGNvbnN0IHBhdGg3ID0gaW5wdXRQYXRoLnNsaWNlKCk7XG4gICAgY29uc3QgbmV3UGF0aCA9IFtdO1xuICAgIGxldCBrZXk7XG4gICAgbGV0IHBvaW50ZXIgPSBzZWxlY3Q7XG4gICAgd2hpbGUgKChrZXkgPSBwYXRoNy5zaGlmdCgpKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRlcikgJiYga2V5ID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICBpZiAoIXBvaW50ZXJba2V5XSkge1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyLmluY2x1ZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXJba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwb2ludGVyICYmIHBvaW50ZXJba2V5XSkge1xuICAgICAgICBwb2ludGVyID0gcG9pbnRlcltrZXldO1xuICAgICAgfVxuICAgICAgbmV3UGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQYXRoO1xuICB9XG59O1xuX19uYW1lKERvY3VtZW50LCBcIkRvY3VtZW50XCIpO1xudmFyIFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCI7XG4gIH1cbn07XG5fX25hbWUoUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLCBcIlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclwiKTtcbnZhciBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSArIGBcblJlYWQgbW9yZSBhdCBodHRwczovL3ByaXMubHkvZC9jbGllbnQtY29uc3RydWN0b3JgKTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvciwgXCJQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvclwiKTtcbnZhciBGaWVsZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBuYW1lLCBhcmdzLCBjaGlsZHJlbiwgZXJyb3I6IGVycm9yMiwgc2NoZW1hRmllbGQgfSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5lcnJvciA9IGVycm9yMjtcbiAgICB0aGlzLnNjaGVtYUZpZWxkID0gc2NoZW1hRmllbGQ7XG4gICAgdGhpcy5oYXNJbnZhbGlkQ2hpbGQgPSBjaGlsZHJlbiA/IGNoaWxkcmVuLnNvbWUoKGNoaWxkKSA9PiBCb29sZWFuKGNoaWxkLmVycm9yIHx8IGNoaWxkLmhhc0ludmFsaWRBcmcgfHwgY2hpbGQuaGFzSW52YWxpZENoaWxkKSkgOiBmYWxzZTtcbiAgICB0aGlzLmhhc0ludmFsaWRBcmcgPSBhcmdzID8gYXJncy5oYXNJbnZhbGlkQXJnIDogZmFsc2U7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZpZWxkXCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHN0ciA9IHRoaXMubmFtZTtcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgcmV0dXJuIHN0ciArIFwiICMgSU5WQUxJRF9GSUVMRFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcmdzICYmIHRoaXMuYXJncy5hcmdzICYmIHRoaXMuYXJncy5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLmFyZ3MuYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RyICs9IGAoJHt0aGlzLmFyZ3MudG9TdHJpbmcoKX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBgKFxuJHsoMCwgaW1wb3J0X2luZGVudF9zdHJpbmc0LmRlZmF1bHQpKHRoaXMuYXJncy50b1N0cmluZygpLCB0YWIpfVxuKWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBzdHIgKz0gYCB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzQuZGVmYXVsdCkodGhpcy5jaGlsZHJlbi5tYXAoU3RyaW5nKS5qb2luKFwiXFxuXCIpLCB0YWIpfVxufWA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgY29sbGVjdEVycm9ycyhwcmVmaXggPSBcInNlbGVjdFwiKSB7XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSBbXTtcbiAgICBjb25zdCBhcmdFcnJvcnMgPSBbXTtcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgZmllbGRFcnJvcnMucHVzaCh7XG4gICAgICAgIHBhdGg6IFt0aGlzLm5hbWVdLFxuICAgICAgICBlcnJvcjogdGhpcy5lcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gY2hpbGQuY29sbGVjdEVycm9ycyhwcmVmaXgpO1xuICAgICAgICBmaWVsZEVycm9ycy5wdXNoKFxuICAgICAgICAgIC4uLmVycm9ycy5maWVsZEVycm9ycy5tYXAoKGUpID0+ICh7XG4gICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgcGF0aDogW3RoaXMubmFtZSwgcHJlZml4LCAuLi5lLnBhdGhdXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICAgIGFyZ0Vycm9ycy5wdXNoKFxuICAgICAgICAgIC4uLmVycm9ycy5hcmdFcnJvcnMubWFwKChlKSA9PiAoe1xuICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgIHBhdGg6IFt0aGlzLm5hbWUsIHByZWZpeCwgLi4uZS5wYXRoXVxuICAgICAgICAgIH0pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICBhcmdFcnJvcnMucHVzaCguLi50aGlzLmFyZ3MuY29sbGVjdEVycm9ycygpLm1hcCgoZSkgPT4gKHsgLi4uZSwgcGF0aDogW3RoaXMubmFtZSwgLi4uZS5wYXRoXSB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmllbGRFcnJvcnMsXG4gICAgICBhcmdFcnJvcnNcbiAgICB9O1xuICB9XG59O1xuX19uYW1lKEZpZWxkLCBcIkZpZWxkXCIpO1xudmFyIEFyZ3MgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSBbXSkge1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5oYXNJbnZhbGlkQXJnID0gYXJncyA/IGFyZ3Muc29tZSgoYXJnMikgPT4gQm9vbGVhbihhcmcyLmhhc0Vycm9yKSkgOiBmYWxzZTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiQXJnc1wiO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuYXJncy5tYXAoKGFyZzIpID0+IGFyZzIudG9TdHJpbmcoKSkuZmlsdGVyKChhKSA9PiBhKS5qb2luKFwiXFxuXCIpfWA7XG4gIH1cbiAgY29sbGVjdEVycm9ycygpIHtcbiAgICBpZiAoIXRoaXMuaGFzSW52YWxpZEFyZykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZmxhdE1hcCh0aGlzLmFyZ3MsIChhcmcyKSA9PiBhcmcyLmNvbGxlY3RFcnJvcnMoKSk7XG4gIH1cbn07XG5fX25hbWUoQXJncywgXCJBcmdzXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBpbnB1dFR5cGUpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpZWxkUmVmSW1wbCkge1xuICAgIHJldHVybiBgeyBfcmVmOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlLm5hbWUpfX1gO1xuICB9XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQmlnSW50XVwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiAoaW5wdXRUeXBlID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dFR5cGUudHlwZSkgPT09IFwic3RyaW5nXCIgJiYgaW5wdXRUeXBlLnR5cGUgPT09IFwiSnNvblwiKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS52YWx1ZXMgJiYgdmFsdWUuX19wcmlzbWFSYXdQYXJhbWF0ZXJzX18pIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS52YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoKGlucHV0VHlwZSA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUeXBlLmlzTGlzdCkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoKG8pID0+IEpTT04uc3RyaW5naWZ5KG8pKSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChkZWNpbWFsX2RlZmF1bHQuaXNEZWNpbWFsKHZhbHVlKSB8fCAoaW5wdXRUeXBlID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dFR5cGUudHlwZSkgPT09IFwiRGVjaW1hbFwiICYmIGlzRGVjaW1hbEpzTGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5RGVjaW1hbEpzTGlrZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKChpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS5sb2NhdGlvbikgPT09IFwiZW51bVR5cGVzXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gYFske3ZhbHVlLmpvaW4oXCIsIFwiKX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMik7XG59XG5fX25hbWUoc3RyaW5naWZ5LCBcInN0cmluZ2lmeVwiKTtcbnZhciBBcmcyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGtleSwgdmFsdWUsIGlzRW51bSA9IGZhbHNlLCBlcnJvcjogZXJyb3IyLCBzY2hlbWFBcmcsIGlucHV0VHlwZSB9KSB7XG4gICAgdGhpcy5pbnB1dFR5cGUgPSBpbnB1dFR5cGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0RW51bVZhbHVlID8gdmFsdWUuX2dldE5hbWUoKSA6IHZhbHVlO1xuICAgIHRoaXMuaXNFbnVtID0gaXNFbnVtO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjI7XG4gICAgdGhpcy5zY2hlbWFBcmcgPSBzY2hlbWFBcmc7XG4gICAgdGhpcy5pc051bGxhYmxlID0gKHNjaGVtYUFyZyA9PSBudWxsID8gdm9pZCAwIDogc2NoZW1hQXJnLmlucHV0VHlwZXMucmVkdWNlKChpc051bGxhYmxlKSA9PiBpc051bGxhYmxlICYmIHNjaGVtYUFyZy5pc051bGxhYmxlLCB0cnVlKSkgfHwgZmFsc2U7XG4gICAgdGhpcy5oYXNFcnJvciA9IEJvb2xlYW4oZXJyb3IyKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBBcmdzID8gdmFsdWUuaGFzSW52YWxpZEFyZyA6IGZhbHNlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5zb21lKCh2KSA9PiB2IGluc3RhbmNlb2YgQXJncyA/IHYuaGFzSW52YWxpZEFyZyA6IGZhbHNlKTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiQXJnXCI7XG4gIH1cbiAgX3RvU3RyaW5nKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFyZ3MpIHtcbiAgICAgIHJldHVybiBgJHtrZXl9OiB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzQuZGVmYXVsdCkodmFsdWUudG9TdHJpbmcoKSwgMil9XG59YDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoKChfYTMgPSB0aGlzLmlucHV0VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy50eXBlKSA9PT0gXCJKc29uXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06ICR7c3RyaW5naWZ5KHZhbHVlLCB0aGlzLmlucHV0VHlwZSl9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU2NhbGFyID0gIXZhbHVlLnNvbWUoKHYpID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKTtcbiAgICAgIHJldHVybiBgJHtrZXl9OiBbJHtpc1NjYWxhciA/IFwiXCIgOiBcIlxcblwifSR7KDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nNC5kZWZhdWx0KShcbiAgICAgICAgdmFsdWUubWFwKChuZXN0ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGlmIChuZXN0ZWRWYWx1ZSBpbnN0YW5jZW9mIEFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBge1xuJHsoMCwgaW1wb3J0X2luZGVudF9zdHJpbmc0LmRlZmF1bHQpKG5lc3RlZFZhbHVlLnRvU3RyaW5nKCksIHRhYil9XG59YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShuZXN0ZWRWYWx1ZSwgdGhpcy5pbnB1dFR5cGUpO1xuICAgICAgICB9KS5qb2luKGAsJHtpc1NjYWxhciA/IFwiIFwiIDogXCJcXG5cIn1gKSxcbiAgICAgICAgaXNTY2FsYXIgPyAwIDogdGFiXG4gICAgICApfSR7aXNTY2FsYXIgPyBcIlwiIDogXCJcXG5cIn1dYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX06ICR7c3RyaW5naWZ5KHZhbHVlLCB0aGlzLmlucHV0VHlwZSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy52YWx1ZSwgdGhpcy5rZXkpO1xuICB9XG4gIGNvbGxlY3RFcnJvcnMoKSB7XG4gICAgdmFyIF9hMztcbiAgICBpZiAoIXRoaXMuaGFzRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIGNvbnN0IGlkID0gdHlwZW9mICgoX2EzID0gdGhpcy5pbnB1dFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTMudHlwZSkgPT09IFwib2JqZWN0XCIgPyBgJHt0aGlzLmlucHV0VHlwZS50eXBlLm5hbWV9JHt0aGlzLmlucHV0VHlwZS5pc0xpc3QgPyBcIltdXCIgOiBcIlwifWAgOiB2b2lkIDA7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICBwYXRoOiBbdGhpcy5rZXldLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgLi4uZmxhdE1hcCh0aGlzLnZhbHVlLCAodmFsLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmICghKHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLmNvbGxlY3RFcnJvcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWwuY29sbGVjdEVycm9ycygpLm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uZSwgcGF0aDogW3RoaXMua2V5LCBpbmRleCwgLi4uZS5wYXRoXSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBBcmdzKSB7XG4gICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbHVlLmNvbGxlY3RFcnJvcnMoKS5tYXAoKGUpID0+ICh7IC4uLmUsIHBhdGg6IFt0aGlzLmtleSwgLi4uZS5wYXRoXSB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG59O1xuX19uYW1lKEFyZzIsIFwiQXJnXCIpO1xuZnVuY3Rpb24gbWFrZURvY3VtZW50KHsgZG1tZiwgcm9vdFR5cGVOYW1lLCByb290RmllbGQsIHNlbGVjdCwgbW9kZWxOYW1lIH0pIHtcbiAgaWYgKCFzZWxlY3QpIHtcbiAgICBzZWxlY3QgPSB7fTtcbiAgfVxuICBjb25zdCByb290VHlwZSA9IHJvb3RUeXBlTmFtZSA9PT0gXCJxdWVyeVwiID8gZG1tZi5xdWVyeVR5cGUgOiBkbW1mLm11dGF0aW9uVHlwZTtcbiAgY29uc3QgZmFrZVJvb3RGaWVsZCA9IHtcbiAgICBhcmdzOiBbXSxcbiAgICBvdXRwdXRUeXBlOiB7XG4gICAgICBpc0xpc3Q6IGZhbHNlLFxuICAgICAgdHlwZTogcm9vdFR5cGUsXG4gICAgICBsb2NhdGlvbjogXCJvdXRwdXRPYmplY3RUeXBlc1wiXG4gICAgfSxcbiAgICBuYW1lOiByb290VHlwZU5hbWVcbiAgfTtcbiAgY29uc3QgY29udGV4dDMgPSB7XG4gICAgbW9kZWxOYW1lXG4gIH07XG4gIGNvbnN0IGNoaWxkcmVuID0gc2VsZWN0aW9uVG9GaWVsZHMoZG1tZiwgeyBbcm9vdEZpZWxkXTogc2VsZWN0IH0sIGZha2VSb290RmllbGQsIFtyb290VHlwZU5hbWVdLCBjb250ZXh0Myk7XG4gIHJldHVybiBuZXcgRG9jdW1lbnQocm9vdFR5cGVOYW1lLCBjaGlsZHJlbik7XG59XG5fX25hbWUobWFrZURvY3VtZW50LCBcIm1ha2VEb2N1bWVudFwiKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50Mikge1xuICByZXR1cm4gZG9jdW1lbnQyO1xufVxuX19uYW1lKHRyYW5zZm9ybURvY3VtZW50LCBcInRyYW5zZm9ybURvY3VtZW50XCIpO1xuZnVuY3Rpb24gc2VsZWN0aW9uVG9GaWVsZHMoZG1tZiwgc2VsZWN0aW9uLCBzY2hlbWFGaWVsZCwgcGF0aDcsIGNvbnRleHQzKSB7XG4gIGNvbnN0IG91dHB1dFR5cGUgPSBzY2hlbWFGaWVsZC5vdXRwdXRUeXBlLnR5cGU7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhzZWxlY3Rpb24pLnJlZHVjZSgoYWNjLCBbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgZmllbGQgPSBvdXRwdXRUeXBlLmZpZWxkTWFwID8gb3V0cHV0VHlwZS5maWVsZE1hcFtuYW1lXSA6IG91dHB1dFR5cGUuZmllbGRzLmZpbmQoKGYpID0+IGYubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgYWNjLnB1c2goXG4gICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZEZpZWxkTmFtZVwiLFxuICAgICAgICAgICAgbW9kZWxOYW1lOiBvdXRwdXRUeXBlLm5hbWUsXG4gICAgICAgICAgICBwcm92aWRlZE5hbWU6IG5hbWUsXG4gICAgICAgICAgICBkaWRZb3VNZWFuOiBnZXRTdWdnZXN0aW9uKFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBvdXRwdXRUeXBlLmZpZWxkcy5tYXAoKGYpID0+IGYubmFtZSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBvdXRwdXRUeXBlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChmaWVsZC5vdXRwdXRUeXBlLmxvY2F0aW9uID09PSBcInNjYWxhclwiICYmIGZpZWxkLmFyZ3MubGVuZ3RoID09PSAwICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGFjYy5wdXNoKFxuICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRGaWVsZFR5cGVcIixcbiAgICAgICAgICAgIG1vZGVsTmFtZTogb3V0cHV0VHlwZS5uYW1lLFxuICAgICAgICAgICAgZmllbGROYW1lOiBuYW1lLFxuICAgICAgICAgICAgcHJvdmlkZWRWYWx1ZTogdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtZWRGaWVsZCA9IHtcbiAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICBmaWVsZHM6IGZpZWxkLmFyZ3MsXG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBtaW5OdW1GaWVsZHM6IG51bGwsXG4gICAgICAgIG1heE51bUZpZWxkczogbnVsbFxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXJnc1dpdGhvdXRJbmNsdWRlQW5kU2VsZWN0ID0gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gb21pdDIodmFsdWUsIFtcImluY2x1ZGVcIiwgXCJzZWxlY3RcIl0pIDogdm9pZCAwO1xuICAgIGNvbnN0IGFyZ3MgPSBhcmdzV2l0aG91dEluY2x1ZGVBbmRTZWxlY3QgPyBvYmplY3RUb0FyZ3MoXG4gICAgICBhcmdzV2l0aG91dEluY2x1ZGVBbmRTZWxlY3QsXG4gICAgICB0cmFuc2Zvcm1lZEZpZWxkLFxuICAgICAgY29udGV4dDMsXG4gICAgICBbXSxcbiAgICAgIHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGZpZWxkLm91dHB1dFR5cGUudHlwZVxuICAgICkgOiB2b2lkIDA7XG4gICAgY29uc3QgaXNSZWxhdGlvbiA9IGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5zZWxlY3QgJiYgdmFsdWUuaW5jbHVkZSkge1xuICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJpbmNsdWRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogbmV3IEFyZ3MoKSxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbmNsdWRlQW5kU2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICBmaWVsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmNsdWRlKSB7XG4gICAgICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXModmFsdWUuaW5jbHVkZSk7XG4gICAgICAgIGlmIChrZXlzMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW5jbHVkZVwiLFxuICAgICAgICAgICAgICAgICAgYXJnczogbmV3IEFyZ3MoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZW1wdHlJbmNsdWRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIikge1xuICAgICAgICAgIGNvbnN0IGZpZWxkT3V0cHV0VHlwZSA9IGZpZWxkLm91dHB1dFR5cGUudHlwZTtcbiAgICAgICAgICBjb25zdCBhbGxvd2VkS2V5cyA9IGZpZWxkT3V0cHV0VHlwZS5maWVsZHMuZmlsdGVyKChmKSA9PiBmLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIikubWFwKChmKSA9PiBmLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IGludmFsaWRLZXlzID0ga2V5czIuZmlsdGVyKChrZXkpID0+ICFhbGxvd2VkS2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICBpZiAoaW52YWxpZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWNjLnB1c2goXG4gICAgICAgICAgICAgIC4uLmludmFsaWRLZXlzLm1hcChcbiAgICAgICAgICAgICAgICAoaW52YWxpZEtleSkgPT4gbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGludmFsaWRLZXksXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGludmFsaWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgYXJnczogbmV3IEFyZ3MoKSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkRmllbGROYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbE5hbWU6IGZpZWxkT3V0cHV0VHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VHlwZTogZmllbGRPdXRwdXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWROYW1lOiBpbnZhbGlkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkWW91TWVhbjogZ2V0U3VnZ2VzdGlvbihpbnZhbGlkS2V5LCBhbGxvd2VkS2V5cykgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlU2NhbGFyOiBmaWVsZE91dHB1dFR5cGUuZmllbGRzLnNvbWUoKGYpID0+IGYubmFtZSA9PT0gaW52YWxpZEtleSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnNlbGVjdCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHZhbHVlLnNlbGVjdCk7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYWNjLnB1c2goXG4gICAgICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgYXJnczogbmV3IEFyZ3MoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZW1wdHlTZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgZmllbGRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnV0aHlWYWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKCh2KSA9PiB2KTtcbiAgICAgICAgaWYgKHRydXRoeVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBuZXcgQXJncygpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJub1RydWVTZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgZmllbGRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2VsZWN0aW9uID0gaXNSZWxhdGlvbiA/IGdldERlZmF1bHRTZWxlY3Rpb24oZG1tZiwgZmllbGQub3V0cHV0VHlwZS50eXBlKSA6IG51bGw7XG4gICAgbGV0IHNlbGVjdCA9IGRlZmF1bHRTZWxlY3Rpb247XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuc2VsZWN0KSB7XG4gICAgICAgIHNlbGVjdCA9IHZhbHVlLnNlbGVjdDtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5jbHVkZSkge1xuICAgICAgICBzZWxlY3QgPSBkZWVwRXh0ZW5kKGRlZmF1bHRTZWxlY3Rpb24sIHZhbHVlLmluY2x1ZGUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5ieSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmJ5KSAmJiBmaWVsZC5vdXRwdXRUeXBlLm5hbWVzcGFjZSA9PT0gXCJwcmlzbWFcIiAmJiBmaWVsZC5vdXRwdXRUeXBlLmxvY2F0aW9uID09PSBcIm91dHB1dE9iamVjdFR5cGVzXCIgJiYgaXNHcm91cEJ5T3V0cHV0TmFtZShmaWVsZC5vdXRwdXRUeXBlLnR5cGUubmFtZSkpIHtcbiAgICAgICAgc2VsZWN0ID0gYnlUb1NlbGVjdCh2YWx1ZS5ieSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gc2VsZWN0ICE9PSBmYWxzZSAmJiBpc1JlbGF0aW9uID8gc2VsZWN0aW9uVG9GaWVsZHMoZG1tZiwgc2VsZWN0LCBmaWVsZCwgWy4uLnBhdGg3LCBuYW1lXSwgY29udGV4dDMpIDogdm9pZCAwO1xuICAgIGFjYy5wdXNoKG5ldyBGaWVsZCh7IG5hbWUsIGFyZ3MsIGNoaWxkcmVuLCBzY2hlbWFGaWVsZDogZmllbGQgfSkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cbl9fbmFtZShzZWxlY3Rpb25Ub0ZpZWxkcywgXCJzZWxlY3Rpb25Ub0ZpZWxkc1wiKTtcbmZ1bmN0aW9uIGJ5VG9TZWxlY3QoYnkpIHtcbiAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgYiBvZiBieSkge1xuICAgIG9ialtiXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbl9fbmFtZShieVRvU2VsZWN0LCBcImJ5VG9TZWxlY3RcIik7XG5mdW5jdGlvbiBnZXREZWZhdWx0U2VsZWN0aW9uKGRtbWYsIG91dHB1dFR5cGUpIHtcbiAgY29uc3QgYWNjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgZiBvZiBvdXRwdXRUeXBlLmZpZWxkcykge1xuICAgIGlmIChkbW1mLnR5cGVNYXBbZi5vdXRwdXRUeXBlLnR5cGUubmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgYWNjW2YubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZi5vdXRwdXRUeXBlLmxvY2F0aW9uID09PSBcInNjYWxhclwiIHx8IGYub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIikge1xuICAgICAgYWNjW2YubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjO1xufVxuX19uYW1lKGdldERlZmF1bHRTZWxlY3Rpb24sIFwiZ2V0RGVmYXVsdFNlbGVjdGlvblwiKTtcbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlQXJnKGtleSwgdmFsdWUsIGFyZzIsIGJlc3RGaXR0aW5nVHlwZSkge1xuICBjb25zdCBhcnJnID0gbmV3IEFyZzIoe1xuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBpc0VudW06IGJlc3RGaXR0aW5nVHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIixcbiAgICBpbnB1dFR5cGU6IGJlc3RGaXR0aW5nVHlwZSxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogXCJpbnZhbGlkVHlwZVwiLFxuICAgICAgcHJvdmlkZWRWYWx1ZTogdmFsdWUsXG4gICAgICBhcmdOYW1lOiBrZXksXG4gICAgICByZXF1aXJlZFR5cGU6IHtcbiAgICAgICAgaW5wdXRUeXBlOiBhcmcyLmlucHV0VHlwZXMsXG4gICAgICAgIGJlc3RGaXR0aW5nVHlwZVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnJnO1xufVxuX19uYW1lKGdldEludmFsaWRUeXBlQXJnLCBcImdldEludmFsaWRUeXBlQXJnXCIpO1xuZnVuY3Rpb24gaGFzQ29ycmVjdFNjYWxhclR5cGUodmFsdWUsIGlucHV0VHlwZSwgY29udGV4dDMpIHtcbiAgY29uc3QgeyBpc0xpc3QgfSA9IGlucHV0VHlwZTtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0RXhwZWN0ZWRUeXBlKGlucHV0VHlwZSwgY29udGV4dDMpO1xuICBjb25zdCBncmFwaFFMVHlwZSA9IGdldEdyYXBoUUxUeXBlKHZhbHVlLCBpbnB1dFR5cGUpO1xuICBpZiAoZ3JhcGhRTFR5cGUgPT09IGV4cGVjdGVkVHlwZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0xpc3QgJiYgZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDw+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkpzb25cIiAmJiBncmFwaFFMVHlwZSAhPT0gXCJTeW1ib2xcIiAmJiAhKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0RW51bVZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRmllbGRSZWZJbXBsKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJJbnRcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiQmlnSW50XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxJbnQ+XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8QmlnSW50PlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8QmlnSW50IHwgSW50PlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PEJpZ0ludD5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEludCB8IEJpZ0ludD5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxCaWdJbnQ+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoKGdyYXBoUUxUeXBlID09PSBcIkludFwiIHx8IGdyYXBoUUxUeXBlID09PSBcIkZsb2F0XCIpICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJEZWNpbWFsXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNWYWxpZERlY2ltYWxMaXN0SW5wdXQoZ3JhcGhRTFR5cGUsIHZhbHVlKSAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxEZWNpbWFsPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkRhdGVUaW1lXCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIlN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8RGF0ZVRpbWU+XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIlVVSURcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxVVUlEPlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PFN0cmluZz5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJTdHJpbmdcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiSURcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PFN0cmluZz5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxJRD5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PFN0cmluZz5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxKc29uPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PFN0cmluZz5cIiAmJiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxTdHJpbmcgfCBVVUlEPlwiIHx8IGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8VVVJRCB8IFN0cmluZz5cIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiSW50XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkZsb2F0XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxJbnQ+XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8RmxvYXQ+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiSW50XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxvbmdcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEludD5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxMb25nPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIlN0cmluZ1wiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJEZWNpbWFsXCIgJiYgaXNEZWNpbWFsU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbl9fbmFtZShoYXNDb3JyZWN0U2NhbGFyVHlwZSwgXCJoYXNDb3JyZWN0U2NhbGFyVHlwZVwiKTtcbmZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShpbnB1dFR5cGUsIGNvbnRleHQzLCBpc0xpc3QgPSBpbnB1dFR5cGUuaXNMaXN0KSB7XG4gIGxldCB0eXBlID0gc3RyaW5naWZ5R3JhcGhRTFR5cGUoaW5wdXRUeXBlLnR5cGUpO1xuICBpZiAoaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImZpZWxkUmVmVHlwZXNcIiAmJiBjb250ZXh0My5tb2RlbE5hbWUpIHtcbiAgICB0eXBlICs9IGA8JHtjb250ZXh0My5tb2RlbE5hbWV9PmA7XG4gIH1cbiAgcmV0dXJuIHdyYXBXaXRoTGlzdCh0eXBlLCBpc0xpc3QpO1xufVxuX19uYW1lKGdldEV4cGVjdGVkVHlwZSwgXCJnZXRFeHBlY3RlZFR5cGVcIik7XG52YXIgY2xlYW5PYmplY3QgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvYmopID0+IGZpbHRlck9iamVjdChvYmosIChrLCB2KSA9PiB2ICE9PSB2b2lkIDApLCBcImNsZWFuT2JqZWN0XCIpO1xuZnVuY3Rpb24gaXNWYWxpZERlY2ltYWxMaXN0SW5wdXQoZ3JhcGhRTFR5cGUsIHZhbHVlKSB7XG4gIHJldHVybiBncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEludD5cIiB8fCBncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEZsb2F0PlwiIHx8IGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiICYmIHZhbHVlLmV2ZXJ5KGlzRGVjaW1hbFN0cmluZyk7XG59XG5fX25hbWUoaXNWYWxpZERlY2ltYWxMaXN0SW5wdXQsIFwiaXNWYWxpZERlY2ltYWxMaXN0SW5wdXRcIik7XG5mdW5jdGlvbiBpc0RlY2ltYWxTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIC9eXFwtPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2kudGVzdCh2YWx1ZSk7XG59XG5fX25hbWUoaXNEZWNpbWFsU3RyaW5nLCBcImlzRGVjaW1hbFN0cmluZ1wiKTtcbmZ1bmN0aW9uIHZhbHVlVG9Bcmcoa2V5LCB2YWx1ZSwgYXJnMiwgY29udGV4dDMpIHtcbiAgbGV0IG1heWJlQXJnID0gbnVsbDtcbiAgY29uc3QgYXJnc1dpdGhFcnJvcnMgPSBbXTtcbiAgZm9yIChjb25zdCBpbnB1dFR5cGUgb2YgYXJnMi5pbnB1dFR5cGVzKSB7XG4gICAgbWF5YmVBcmcgPSB0cnlJbmZlckFyZ3Moa2V5LCB2YWx1ZSwgYXJnMiwgaW5wdXRUeXBlLCBjb250ZXh0Myk7XG4gICAgaWYgKChtYXliZUFyZyA9PSBudWxsID8gdm9pZCAwIDogbWF5YmVBcmcuY29sbGVjdEVycm9ycygpLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtYXliZUFyZztcbiAgICB9XG4gICAgaWYgKG1heWJlQXJnICYmIChtYXliZUFyZyA9PSBudWxsID8gdm9pZCAwIDogbWF5YmVBcmcuY29sbGVjdEVycm9ycygpKSkge1xuICAgICAgY29uc3QgYXJnRXJyb3JzID0gbWF5YmVBcmcgPT0gbnVsbCA/IHZvaWQgMCA6IG1heWJlQXJnLmNvbGxlY3RFcnJvcnMoKTtcbiAgICAgIGlmIChhcmdFcnJvcnMgJiYgYXJnRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJnc1dpdGhFcnJvcnMucHVzaCh7IGFyZzogbWF5YmVBcmcsIGVycm9yczogYXJnRXJyb3JzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoKG1heWJlQXJnID09IG51bGwgPyB2b2lkIDAgOiBtYXliZUFyZy5oYXNFcnJvcikgJiYgYXJnc1dpdGhFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGFyZ3NXaXRoU2NvcmVzID0gYXJnc1dpdGhFcnJvcnMubWFwKCh7IGFyZzogYXJnMywgZXJyb3JzIH0pID0+IHtcbiAgICAgIGNvbnN0IGVycm9yU2NvcmVzID0gZXJyb3JzLm1hcCgoZSkgPT4ge1xuICAgICAgICBsZXQgc2NvcmUgPSAxO1xuICAgICAgICBpZiAoZS5lcnJvci50eXBlID09PSBcImludmFsaWRUeXBlXCIpIHtcbiAgICAgICAgICBzY29yZSA9IDIgKiBNYXRoLmV4cChnZXREZXB0aChlLmVycm9yLnByb3ZpZGVkVmFsdWUpKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coZS5wYXRoLmxlbmd0aCk7XG4gICAgICAgIGlmIChlLmVycm9yLnR5cGUgPT09IFwibWlzc2luZ0FyZ1wiKSB7XG4gICAgICAgICAgaWYgKGFyZzMuaW5wdXRUeXBlICYmIGlzSW5wdXRBcmdUeXBlKGFyZzMuaW5wdXRUeXBlLnR5cGUpICYmIGFyZzMuaW5wdXRUeXBlLnR5cGUubmFtZS5pbmNsdWRlcyhcIlVuY2hlY2tlZFwiKSkge1xuICAgICAgICAgICAgc2NvcmUgKj0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuZXJyb3IudHlwZSA9PT0gXCJpbnZhbGlkTmFtZVwiKSB7XG4gICAgICAgICAgaWYgKGlzSW5wdXRBcmdUeXBlKGUuZXJyb3Iub3JpZ2luYWxUeXBlKSkge1xuICAgICAgICAgICAgaWYgKGUuZXJyb3Iub3JpZ2luYWxUeXBlLm5hbWUuaW5jbHVkZXMoXCJVbmNoZWNrZWRcIikpIHtcbiAgICAgICAgICAgICAgc2NvcmUgKj0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY29yZTogZXJyb3JzLmxlbmd0aCArIHN1bTIoZXJyb3JTY29yZXMpLFxuICAgICAgICBhcmc6IGFyZzMsXG4gICAgICAgIGVycm9yc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBhcmdzV2l0aFNjb3Jlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMSk7XG4gICAgcmV0dXJuIGFyZ3NXaXRoU2NvcmVzWzBdLmFyZztcbiAgfVxuICByZXR1cm4gbWF5YmVBcmc7XG59XG5fX25hbWUodmFsdWVUb0FyZywgXCJ2YWx1ZVRvQXJnXCIpO1xuZnVuY3Rpb24gZ2V0RGVwdGgob2JqZWN0KSB7XG4gIGxldCBsZXZlbCA9IDE7XG4gIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgZGVwdGggPSBnZXREZXB0aChvYmplY3Rba2V5XSkgKyAxO1xuICAgICAgbGV2ZWwgPSBNYXRoLm1heChkZXB0aCwgbGV2ZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV2ZWw7XG59XG5fX25hbWUoZ2V0RGVwdGgsIFwiZ2V0RGVwdGhcIik7XG5mdW5jdGlvbiBzdW0yKG4pIHtcbiAgcmV0dXJuIG4ucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIsIDApO1xufVxuX19uYW1lKHN1bTIsIFwic3VtXCIpO1xuZnVuY3Rpb24gdHJ5SW5mZXJBcmdzKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSwgY29udGV4dDMpIHtcbiAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoIWFyZzIuaXNSZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzRW51bTogaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiLFxuICAgICAgaW5wdXRUeXBlLFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgdHlwZTogXCJtaXNzaW5nQXJnXCIsXG4gICAgICAgIG1pc3NpbmdOYW1lOiBrZXksXG4gICAgICAgIG1pc3NpbmdBcmc6IGFyZzIsXG4gICAgICAgIGF0TGVhc3RPbmU6IGZhbHNlLFxuICAgICAgICBhdE1vc3RPbmU6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgeyBpc051bGxhYmxlLCBpc1JlcXVpcmVkIH0gPSBhcmcyO1xuICBpZiAodmFsdWUgPT09IG51bGwgJiYgIWlzTnVsbGFibGUgJiYgIWlzUmVxdWlyZWQpIHtcbiAgICBjb25zdCBpc0F0TGVhc3RPbmUgPSBpc0lucHV0QXJnVHlwZShpbnB1dFR5cGUudHlwZSkgPyBpbnB1dFR5cGUudHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMgIT09IG51bGwgJiYgaW5wdXRUeXBlLnR5cGUuY29uc3RyYWludHMubWluTnVtRmllbGRzID4gMCA6IGZhbHNlO1xuICAgIGlmICghaXNBdExlYXN0T25lKSB7XG4gICAgICByZXR1cm4gbmV3IEFyZzIoe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc0VudW06IGlucHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIixcbiAgICAgICAgaW5wdXRUeXBlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIHR5cGU6IFwiaW52YWxpZE51bGxBcmdcIixcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgaW52YWxpZFR5cGU6IGFyZzIuaW5wdXRUeXBlcyxcbiAgICAgICAgICBhdExlYXN0T25lOiBmYWxzZSxcbiAgICAgICAgICBhdE1vc3RPbmU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoIWlucHV0VHlwZS5pc0xpc3QpIHtcbiAgICBpZiAoaXNJbnB1dEFyZ1R5cGUoaW5wdXRUeXBlLnR5cGUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlucHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJpbnB1dE9iamVjdFR5cGVzXCIgJiYgIWlzT2JqZWN0Mih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRUeXBlQXJnKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWwgPSBjbGVhbk9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGxldCBlcnJvcjI7XG4gICAgICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXModmFsIHx8IHt9KTtcbiAgICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMyLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bUtleXMgPT09IDAgJiYgdHlwZW9mIGlucHV0VHlwZS50eXBlLmNvbnN0cmFpbnRzLm1pbk51bUZpZWxkcyA9PT0gXCJudW1iZXJcIiAmJiBpbnB1dFR5cGUudHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMgPiAwKSB7XG4gICAgICAgICAgZXJyb3IyID0ge1xuICAgICAgICAgICAgdHlwZTogXCJhdExlYXN0T25lXCIsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBpbnB1dFR5cGU6IGlucHV0VHlwZS50eXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1LZXlzID4gMSAmJiB0eXBlb2YgaW5wdXRUeXBlLnR5cGUuY29uc3RyYWludHMubWF4TnVtRmllbGRzID09PSBcIm51bWJlclwiICYmIGlucHV0VHlwZS50eXBlLmNvbnN0cmFpbnRzLm1heE51bUZpZWxkcyA8IDIpIHtcbiAgICAgICAgICBlcnJvcjIgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImF0TW9zdE9uZVwiLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgaW5wdXRUeXBlOiBpbnB1dFR5cGUudHlwZSxcbiAgICAgICAgICAgIHByb3ZpZGVkS2V5czoga2V5czJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWwgPT09IG51bGwgPyBudWxsIDogb2JqZWN0VG9BcmdzKHZhbCwgaW5wdXRUeXBlLnR5cGUsIGNvbnRleHQzLCBhcmcyLmlucHV0VHlwZXMpLFxuICAgICAgICAgIGlzRW51bTogaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiLFxuICAgICAgICAgIGVycm9yOiBlcnJvcjIsXG4gICAgICAgICAgaW5wdXRUeXBlLFxuICAgICAgICAgIHNjaGVtYUFyZzogYXJnMlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjYWxhclRvQXJnKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSwgY29udGV4dDMpO1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIGlucHV0VHlwZS5pc0xpc3QpIHtcbiAgICBpZiAoa2V5ICE9PSBcInVwZGF0ZU1hbnlcIikge1xuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiIHx8IGlucHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJzY2FsYXJcIikge1xuICAgIHJldHVybiBzY2FsYXJUb0FyZyhrZXksIHZhbHVlLCBhcmcyLCBpbnB1dFR5cGUsIGNvbnRleHQzKTtcbiAgfVxuICBjb25zdCBhcmdJbnB1dFR5cGUgPSBpbnB1dFR5cGUudHlwZTtcbiAgY29uc3QgaGFzQXRMZWFzdE9uZUVycm9yID0gdHlwZW9mICgoX2EzID0gYXJnSW5wdXRUeXBlLmNvbnN0cmFpbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1pbk51bUZpZWxkcykgPT09IFwibnVtYmVyXCIgJiYgKChfYjIgPSBhcmdJbnB1dFR5cGUuY29uc3RyYWludHMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIubWluTnVtRmllbGRzKSA+IDAgPyBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5zb21lKCh2KSA9PiAhdiB8fCBPYmplY3Qua2V5cyhjbGVhbk9iamVjdCh2KSkubGVuZ3RoID09PSAwKSA6IGZhbHNlO1xuICBsZXQgZXJyID0gaGFzQXRMZWFzdE9uZUVycm9yID8ge1xuICAgIGlucHV0VHlwZTogYXJnSW5wdXRUeXBlLFxuICAgIGtleSxcbiAgICB0eXBlOiBcImF0TGVhc3RPbmVcIlxuICB9IDogdm9pZCAwO1xuICBpZiAoIWVycikge1xuICAgIGNvbnN0IGhhc09uZU9mRXJyb3IgPSB0eXBlb2YgKChfYyA9IGFyZ0lucHV0VHlwZS5jb25zdHJhaW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm1heE51bUZpZWxkcykgPT09IFwibnVtYmVyXCIgJiYgKChfZCA9IGFyZ0lucHV0VHlwZS5jb25zdHJhaW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm1heE51bUZpZWxkcykgPCAyID8gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZmluZCgodikgPT4gIXYgfHwgT2JqZWN0LmtleXMoY2xlYW5PYmplY3QodikpLmxlbmd0aCAhPT0gMSkgOiBmYWxzZTtcbiAgICBpZiAoaGFzT25lT2ZFcnJvcikge1xuICAgICAgZXJyID0ge1xuICAgICAgICBpbnB1dFR5cGU6IGFyZ0lucHV0VHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICB0eXBlOiBcImF0TW9zdE9uZVwiLFxuICAgICAgICBwcm92aWRlZEtleXM6IE9iamVjdC5rZXlzKGhhc09uZU9mRXJyb3IpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuZXN0ZWRBcmdJbnB1dFR5cGUgb2YgYXJnMi5pbnB1dFR5cGVzKSB7XG4gICAgICBjb25zdCBhcmdzID0gb2JqZWN0VG9BcmdzKHZhbHVlLCBuZXN0ZWRBcmdJbnB1dFR5cGUudHlwZSwgY29udGV4dDMpO1xuICAgICAgaWYgKGFyZ3MuY29sbGVjdEVycm9ycygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEFyZzIoe1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZTogYXJncyxcbiAgICAgICAgICBpc0VudW06IGZhbHNlLFxuICAgICAgICAgIHNjaGVtYUFyZzogYXJnMixcbiAgICAgICAgICBpbnB1dFR5cGU6IG5lc3RlZEFyZ0lucHV0VHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBBcmcyKHtcbiAgICBrZXksXG4gICAgdmFsdWU6IHZhbHVlLm1hcCgodikgPT4ge1xuICAgICAgaWYgKGlucHV0VHlwZS5pc0xpc3QgJiYgdHlwZW9mIHYgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHYgIT09IFwib2JqZWN0XCIgfHwgIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkVHlwZUFyZyhrZXksIHYsIGFyZzIsIGlucHV0VHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG9BcmdzKHYsIGFyZ0lucHV0VHlwZSwgY29udGV4dDMpO1xuICAgIH0pLFxuICAgIGlzRW51bTogZmFsc2UsXG4gICAgaW5wdXRUeXBlLFxuICAgIHNjaGVtYUFyZzogYXJnMixcbiAgICBlcnJvcjogZXJyXG4gIH0pO1xufVxuX19uYW1lKHRyeUluZmVyQXJncywgXCJ0cnlJbmZlckFyZ3NcIik7XG5mdW5jdGlvbiBpc0lucHV0QXJnVHlwZShhcmdUeXBlKSB7XG4gIGlmICh0eXBlb2YgYXJnVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXJnVHlwZSwgXCJ2YWx1ZXNcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5fX25hbWUoaXNJbnB1dEFyZ1R5cGUsIFwiaXNJbnB1dEFyZ1R5cGVcIik7XG5mdW5jdGlvbiBzY2FsYXJUb0FyZyhrZXksIHZhbHVlLCBhcmcyLCBpbnB1dFR5cGUsIGNvbnRleHQzKSB7XG4gIGlmIChoYXNDb3JyZWN0U2NhbGFyVHlwZSh2YWx1ZSwgaW5wdXRUeXBlLCBjb250ZXh0MykpIHtcbiAgICByZXR1cm4gbmV3IEFyZzIoe1xuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBpc0VudW06IGlucHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIixcbiAgICAgIHNjaGVtYUFyZzogYXJnMixcbiAgICAgIGlucHV0VHlwZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBnZXRJbnZhbGlkVHlwZUFyZyhrZXksIHZhbHVlLCBhcmcyLCBpbnB1dFR5cGUpO1xufVxuX19uYW1lKHNjYWxhclRvQXJnLCBcInNjYWxhclRvQXJnXCIpO1xuZnVuY3Rpb24gb2JqZWN0VG9BcmdzKGluaXRpYWxPYmosIGlucHV0VHlwZSwgY29udGV4dDMsIHBvc3NpYmlsaXRpZXMsIG91dHB1dFR5cGUpIHtcbiAgdmFyIF9hMztcbiAgaWYgKChfYTMgPSBpbnB1dFR5cGUubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5zb3VyY2UpIHtcbiAgICBjb250ZXh0MyA9IHsgbW9kZWxOYW1lOiBpbnB1dFR5cGUubWV0YS5zb3VyY2UgfTtcbiAgfVxuICBjb25zdCBvYmogPSBjbGVhbk9iamVjdChpbml0aWFsT2JqKTtcbiAgY29uc3QgeyBmaWVsZHM6IGFyZ3MsIGZpZWxkTWFwIH0gPSBpbnB1dFR5cGU7XG4gIGNvbnN0IHJlcXVpcmVkQXJncyA9IGFyZ3MubWFwKChhcmcyKSA9PiBbYXJnMi5uYW1lLCB2b2lkIDBdKTtcbiAgY29uc3Qgb2JqRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaiB8fCB7fSk7XG4gIGNvbnN0IGVudHJpZXMgPSB1bmlvbkJ5KG9iakVudHJpZXMsIHJlcXVpcmVkQXJncywgKGEpID0+IGFbMF0pO1xuICBjb25zdCBhcmdzTGlzdCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFthcmdOYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBzY2hlbWFBcmcgPSBmaWVsZE1hcCA/IGZpZWxkTWFwW2FyZ05hbWVdIDogYXJncy5maW5kKChhKSA9PiBhLm5hbWUgPT09IGFyZ05hbWUpO1xuICAgIGlmICghc2NoZW1hQXJnKSB7XG4gICAgICBjb25zdCBkaWRZb3VNZWFuRmllbGQgPSB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiICYmIG91dHB1dFR5cGUgJiYgb3V0cHV0VHlwZS5maWVsZHMuc29tZSgoZikgPT4gZi5uYW1lID09PSBhcmdOYW1lKSA/IGFyZ05hbWUgOiBudWxsO1xuICAgICAgYWNjLnB1c2goXG4gICAgICAgIG5ldyBBcmcyKHtcbiAgICAgICAgICBrZXk6IGFyZ05hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZE5hbWVcIixcbiAgICAgICAgICAgIHByb3ZpZGVkTmFtZTogYXJnTmFtZSxcbiAgICAgICAgICAgIHByb3ZpZGVkVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZGlkWW91TWVhbkZpZWxkLFxuICAgICAgICAgICAgZGlkWW91TWVhbkFyZzogIWRpZFlvdU1lYW5GaWVsZCAmJiBnZXRTdWdnZXN0aW9uKGFyZ05hbWUsIFsuLi5hcmdzLm1hcCgoYSkgPT4gYS5uYW1lKSwgXCJzZWxlY3RcIl0pIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIG9yaWdpbmFsVHlwZTogaW5wdXRUeXBlLFxuICAgICAgICAgICAgcG9zc2liaWxpdGllcyxcbiAgICAgICAgICAgIG91dHB1dFR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgY29uc3QgYXJnMiA9IHZhbHVlVG9BcmcoYXJnTmFtZSwgdmFsdWUsIHNjaGVtYUFyZywgY29udGV4dDMpO1xuICAgIGlmIChhcmcyKSB7XG4gICAgICBhY2MucHVzaChhcmcyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICBpZiAodHlwZW9mIGlucHV0VHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMgPT09IFwibnVtYmVyXCIgJiYgb2JqRW50cmllcy5sZW5ndGggPCBpbnB1dFR5cGUuY29uc3RyYWludHMubWluTnVtRmllbGRzIHx8IGFyZ3NMaXN0LmZpbmQoKGFyZzIpID0+IHtcbiAgICB2YXIgX2E0LCBfYjI7XG4gICAgcmV0dXJuICgoX2E0ID0gYXJnMi5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC50eXBlKSA9PT0gXCJtaXNzaW5nQXJnXCIgfHwgKChfYjIgPSBhcmcyLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnR5cGUpID09PSBcImF0TGVhc3RPbmVcIjtcbiAgfSkpIHtcbiAgICBjb25zdCBvcHRpb25hbE1pc3NpbmdBcmdzID0gaW5wdXRUeXBlLmZpZWxkcy5maWx0ZXIoXG4gICAgICAoZmllbGQpID0+ICFmaWVsZC5pc1JlcXVpcmVkICYmIG9iaiAmJiAodHlwZW9mIG9ialtmaWVsZC5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvYmpbZmllbGQubmFtZV0gPT09IG51bGwpXG4gICAgKTtcbiAgICBhcmdzTGlzdC5wdXNoKFxuICAgICAgLi4ub3B0aW9uYWxNaXNzaW5nQXJncy5tYXAoKGFyZzIpID0+IHtcbiAgICAgICAgY29uc3QgYXJnSW5wdXRUeXBlID0gYXJnMi5pbnB1dFR5cGVzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IEFyZzIoe1xuICAgICAgICAgIGtleTogYXJnMi5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgaXNFbnVtOiBhcmdJbnB1dFR5cGUubG9jYXRpb24gPT09IFwiZW51bVR5cGVzXCIsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWlzc2luZ0FyZ1wiLFxuICAgICAgICAgICAgbWlzc2luZ05hbWU6IGFyZzIubmFtZSxcbiAgICAgICAgICAgIG1pc3NpbmdBcmc6IGFyZzIsXG4gICAgICAgICAgICBhdExlYXN0T25lOiBCb29sZWFuKGlucHV0VHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMpIHx8IGZhbHNlLFxuICAgICAgICAgICAgYXRNb3N0T25lOiBpbnB1dFR5cGUuY29uc3RyYWludHMubWF4TnVtRmllbGRzID09PSAxIHx8IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dFR5cGU6IGFyZ0lucHV0VHlwZVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3IEFyZ3MoYXJnc0xpc3QpO1xufVxuX19uYW1lKG9iamVjdFRvQXJncywgXCJvYmplY3RUb0FyZ3NcIik7XG5mdW5jdGlvbiB1bnBhY2soeyBkb2N1bWVudDogZG9jdW1lbnQyLCBwYXRoOiBwYXRoNywgZGF0YSB9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGRlZXBHZXQoZGF0YSwgcGF0aDcpO1xuICBpZiAocmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQoZG9jdW1lbnQyLCBwYXRoNyk7XG4gIHJldHVybiBtYXBTY2FsYXJzKHsgZmllbGQsIGRhdGE6IHJlc3VsdCB9KTtcbn1cbl9fbmFtZSh1bnBhY2ssIFwidW5wYWNrXCIpO1xuZnVuY3Rpb24gbWFwU2NhbGFycyh7IGZpZWxkLCBkYXRhIH0pIHtcbiAgdmFyIF9hMztcbiAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8ICFmaWVsZC5jaGlsZHJlbiB8fCAhZmllbGQuc2NoZW1hRmllbGQpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCBkZXNlcmlhbGl6ZXJzID0ge1xuICAgIERhdGVUaW1lOiAodmFsdWUpID0+IG5ldyBEYXRlKHZhbHVlKSxcbiAgICBKc29uOiAodmFsdWUpID0+IEpTT04ucGFyc2UodmFsdWUpLFxuICAgIEJ5dGVzOiAodmFsdWUpID0+IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKSxcbiAgICBEZWNpbWFsOiAodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9kZWZhdWx0KHZhbHVlKTtcbiAgICB9LFxuICAgIEJpZ0ludDogKHZhbHVlKSA9PiBCaWdJbnQodmFsdWUpXG4gIH07XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgZmllbGQuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBvdXRwdXRUeXBlID0gKF9hMyA9IGNoaWxkLnNjaGVtYUZpZWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm91dHB1dFR5cGUudHlwZTtcbiAgICBpZiAob3V0cHV0VHlwZSAmJiB0eXBlb2Ygb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZGVzZXJpYWxpemVyID0gZGVzZXJpYWxpemVyc1tvdXRwdXRUeXBlXTtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnlbY2hpbGQubmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiYgZW50cnlbY2hpbGQubmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnlbY2hpbGQubmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZW50cnlbY2hpbGQubmFtZV0gPSBlbnRyeVtjaGlsZC5uYW1lXS5tYXAoZGVzZXJpYWxpemVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRyeVtjaGlsZC5uYW1lXSA9IGRlc2VyaWFsaXplcihlbnRyeVtjaGlsZC5uYW1lXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NoaWxkLm5hbWVdICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGFbY2hpbGQubmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbY2hpbGQubmFtZV0pKSB7XG4gICAgICAgICAgICAgIGRhdGFbY2hpbGQubmFtZV0gPSBkYXRhW2NoaWxkLm5hbWVdLm1hcChkZXNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YVtjaGlsZC5uYW1lXSA9IGRlc2VyaWFsaXplcihkYXRhW2NoaWxkLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkLnNjaGVtYUZpZWxkICYmIGNoaWxkLnNjaGVtYUZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBkYXRhKSB7XG4gICAgICAgICAgbWFwU2NhbGFycyh7IGZpZWxkOiBjaGlsZCwgZGF0YTogZW50cnlbY2hpbGQubmFtZV0gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcFNjYWxhcnMoeyBmaWVsZDogY2hpbGQsIGRhdGE6IGRhdGFbY2hpbGQubmFtZV0gfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuX19uYW1lKG1hcFNjYWxhcnMsIFwibWFwU2NhbGFyc1wiKTtcbmZ1bmN0aW9uIGdldEZpZWxkKGRvY3VtZW50MiwgcGF0aDcpIHtcbiAgY29uc3QgdG9kbyA9IHBhdGg3LnNsaWNlKCk7XG4gIGNvbnN0IGZpcnN0RWxlbWVudCA9IHRvZG8uc2hpZnQoKTtcbiAgbGV0IHBvaW50ZXIgPSBkb2N1bWVudDIuY2hpbGRyZW4uZmluZCgoYykgPT4gYy5uYW1lID09PSBmaXJzdEVsZW1lbnQpO1xuICBpZiAoIXBvaW50ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGZpZWxkICR7Zmlyc3RFbGVtZW50fSBpbiBkb2N1bWVudCAke2RvY3VtZW50Mn1gKTtcbiAgfVxuICB3aGlsZSAodG9kby5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qga2V5ID0gdG9kby5zaGlmdCgpO1xuICAgIGlmICghcG9pbnRlci5jaGlsZHJlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBnZXQgY2hpbGRyZW4gZm9yIGZpZWxkICR7cG9pbnRlcn0gd2l0aCBjaGlsZCAke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBwb2ludGVyLmNoaWxkcmVuLmZpbmQoKGMpID0+IGMubmFtZSA9PT0ga2V5KTtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgY2hpbGQgJHtrZXl9IG9mIGZpZWxkICR7cG9pbnRlcn1gKTtcbiAgICB9XG4gICAgcG9pbnRlciA9IGNoaWxkO1xuICB9XG4gIHJldHVybiBwb2ludGVyO1xufVxuX19uYW1lKGdldEZpZWxkLCBcImdldEZpZWxkXCIpO1xuZnVuY3Rpb24gcmVtb3ZlU2VsZWN0RnJvbVBhdGgocGF0aDcpIHtcbiAgcmV0dXJuIHBhdGg3LnNwbGl0KFwiLlwiKS5maWx0ZXIoKHApID0+IHAgIT09IFwic2VsZWN0XCIpLmpvaW4oXCIuXCIpO1xufVxuX19uYW1lKHJlbW92ZVNlbGVjdEZyb21QYXRoLCBcInJlbW92ZVNlbGVjdEZyb21QYXRoXCIpO1xuZnVuY3Rpb24gcmVtb3ZlU2VsZWN0RnJvbU9iamVjdChvYmopIHtcbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAodHlwZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChrZXkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJLZXkgaW4gb2JqW1wic2VsZWN0XCJdKSB7XG4gICAgICAgICAgY29weVtzdWJLZXldID0gcmVtb3ZlU2VsZWN0RnJvbU9iamVjdChvYmpbXCJzZWxlY3RcIl1bc3ViS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlba2V5XSA9IHJlbW92ZVNlbGVjdEZyb21PYmplY3Qob2JqW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuX19uYW1lKHJlbW92ZVNlbGVjdEZyb21PYmplY3QsIFwicmVtb3ZlU2VsZWN0RnJvbU9iamVjdFwiKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybUFnZ3JlZ2F0ZVByaW50SnNvbkFyZ3Moe1xuICBhc3QsXG4gIGtleVBhdGhzLFxuICBtaXNzaW5nSXRlbXMsXG4gIHZhbHVlUGF0aHNcbn0pIHtcbiAgY29uc3QgbmV3S2V5UGF0aHMgPSBrZXlQYXRocy5tYXAocmVtb3ZlU2VsZWN0RnJvbVBhdGgpO1xuICBjb25zdCBuZXdWYWx1ZVBhdGhzID0gdmFsdWVQYXRocy5tYXAocmVtb3ZlU2VsZWN0RnJvbVBhdGgpO1xuICBjb25zdCBuZXdNaXNzaW5nSXRlbXMgPSBtaXNzaW5nSXRlbXMubWFwKChpdGVtKSA9PiAoe1xuICAgIHBhdGg6IHJlbW92ZVNlbGVjdEZyb21QYXRoKGl0ZW0ucGF0aCksXG4gICAgaXNSZXF1aXJlZDogaXRlbS5pc1JlcXVpcmVkLFxuICAgIHR5cGU6IGl0ZW0udHlwZVxuICB9KSk7XG4gIGNvbnN0IG5ld0FzdCA9IHJlbW92ZVNlbGVjdEZyb21PYmplY3QoYXN0KTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IG5ld0FzdCxcbiAgICBrZXlQYXRoczogbmV3S2V5UGF0aHMsXG4gICAgbWlzc2luZ0l0ZW1zOiBuZXdNaXNzaW5nSXRlbXMsXG4gICAgdmFsdWVQYXRoczogbmV3VmFsdWVQYXRoc1xuICB9O1xufVxuX19uYW1lKHRyYW5zZm9ybUFnZ3JlZ2F0ZVByaW50SnNvbkFyZ3MsIFwidHJhbnNmb3JtQWdncmVnYXRlUHJpbnRKc29uQXJnc1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvcmVqZWN0T25Ob3RGb3VuZC50c1xudmFyIE5vdEZvdW5kRXJyb3IyID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIk5vdEZvdW5kRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShOb3RGb3VuZEVycm9yMiwgXCJOb3RGb3VuZEVycm9yXCIpO1xuZnVuY3Rpb24gZ2V0UmVqZWN0T25Ob3RGb3VuZChhY3Rpb24sIG1vZGVsTmFtZSwgYXJncywgY2xpZW50SW5zdGFuY2UpIHtcbiAgbGV0IHJlamVjdE9uTm90Rm91bmQ7XG4gIGlmIChhcmdzICYmIHR5cGVvZiBhcmdzID09PSBcIm9iamVjdFwiICYmIFwicmVqZWN0T25Ob3RGb3VuZFwiIGluIGFyZ3MgJiYgYXJnc1tcInJlamVjdE9uTm90Rm91bmRcIl0gIT09IHZvaWQgMCkge1xuICAgIHJlamVjdE9uTm90Rm91bmQgPSBhcmdzW1wicmVqZWN0T25Ob3RGb3VuZFwiXTtcbiAgICBkZWxldGUgYXJnc1tcInJlamVjdE9uTm90Rm91bmRcIl07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudEluc3RhbmNlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJlamVjdE9uTm90Rm91bmQgPSBjbGllbnRJbnN0YW5jZTtcbiAgfSBlbHNlIGlmIChjbGllbnRJbnN0YW5jZSAmJiB0eXBlb2YgY2xpZW50SW5zdGFuY2UgPT09IFwib2JqZWN0XCIgJiYgYWN0aW9uIGluIGNsaWVudEluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVqZWN0UGVyT3BlcmF0aW9uID0gY2xpZW50SW5zdGFuY2VbYWN0aW9uXTtcbiAgICBpZiAocmVqZWN0UGVyT3BlcmF0aW9uICYmIHR5cGVvZiByZWplY3RQZXJPcGVyYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChtb2RlbE5hbWUgaW4gcmVqZWN0UGVyT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiByZWplY3RQZXJPcGVyYXRpb25bbW9kZWxOYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJlamVjdE9uTm90Rm91bmQgPSBnZXRSZWplY3RPbk5vdEZvdW5kKGFjdGlvbiwgbW9kZWxOYW1lLCBhcmdzLCByZWplY3RQZXJPcGVyYXRpb24pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjbGllbnRJbnN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVqZWN0T25Ob3RGb3VuZCA9IGNsaWVudEluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdE9uTm90Rm91bmQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmVqZWN0T25Ob3RGb3VuZDtcbn1cbl9fbmFtZShnZXRSZWplY3RPbk5vdEZvdW5kLCBcImdldFJlamVjdE9uTm90Rm91bmRcIik7XG52YXIgUkVHRVggPSAvKGZpbmRVbmlxdWV8ZmluZEZpcnN0KS87XG5mdW5jdGlvbiB0aHJvd0lmTm90Rm91bmQoZGF0YSwgY2xpZW50TWV0aG9kLCB0eXBlTmFtZSwgcmVqZWN0T25Ob3RGb3VuZCkge1xuICBpZiAocmVqZWN0T25Ob3RGb3VuZCAmJiAhZGF0YSAmJiBSRUdFWC5leGVjKGNsaWVudE1ldGhvZCkpIHtcbiAgICBpZiAodHlwZW9mIHJlamVjdE9uTm90Rm91bmQgPT09IFwiYm9vbGVhblwiICYmIHJlamVjdE9uTm90Rm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yMihgTm8gJHt0eXBlTmFtZX0gZm91bmRgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWplY3RPbk5vdEZvdW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IHJlamVjdE9uTm90Rm91bmQobmV3IE5vdEZvdW5kRXJyb3IyKGBObyAke3R5cGVOYW1lfSBmb3VuZGApKTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3IocmVqZWN0T25Ob3RGb3VuZCkpIHtcbiAgICAgIHRocm93IHJlamVjdE9uTm90Rm91bmQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yMihgTm8gJHt0eXBlTmFtZX0gZm91bmRgKTtcbiAgfVxufVxuX19uYW1lKHRocm93SWZOb3RGb3VuZCwgXCJ0aHJvd0lmTm90Rm91bmRcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYXBwbHlDbGllbnRPbmx5V3JhcHBlci50c1xuZnVuY3Rpb24gd3JhcFJlcXVlc3QocHJvcCwgZG1tZk1vZGVsTmFtZSwgcmVxdWVzdENhbGxiYWNrKSB7XG4gIGlmIChwcm9wID09PSBcImZpbmRGaXJzdE9yVGhyb3dcIiB8fCBwcm9wID09PSBcImZpbmRVbmlxdWVPclRocm93XCIpIHtcbiAgICByZXR1cm4gYXBwbHlPclRocm93V3JhcHBlcihkbW1mTW9kZWxOYW1lLCByZXF1ZXN0Q2FsbGJhY2spO1xuICB9XG4gIGFzc2VydE5ldmVyKHByb3AsIFwiVW5rbm93biB3cmFwcGVyIG5hbWVcIik7XG59XG5fX25hbWUod3JhcFJlcXVlc3QsIFwid3JhcFJlcXVlc3RcIik7XG5mdW5jdGlvbiBhcHBseU9yVGhyb3dXcmFwcGVyKGRtbWZNb2RlbE5hbWUsIHJlcXVlc3RDYWxsYmFjaykge1xuICByZXR1cm4gYXN5bmMgKHJlcXVlc3RQYXJhbXMpID0+IHtcbiAgICBpZiAoXCJyZWplY3RPbk5vdEZvdW5kXCIgaW4gcmVxdWVzdFBhcmFtcy5hcmdzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICBvcmlnaW5hbE1ldGhvZDogcmVxdWVzdFBhcmFtcy5jbGllbnRNZXRob2QsXG4gICAgICAgIGNhbGxzaXRlOiByZXF1ZXN0UGFyYW1zLmNhbGxzaXRlLFxuICAgICAgICBtZXNzYWdlOiBcIidyZWplY3RPbk5vdEZvdW5kJyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RDYWxsYmFjayhyZXF1ZXN0UGFyYW1zKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcjIoYE5vICR7ZG1tZk1vZGVsTmFtZX0gZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbl9fbmFtZShhcHBseU9yVGhyb3dXcmFwcGVyLCBcImFwcGx5T3JUaHJvd1dyYXBwZXJcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvdXRpbHMvZGVmYXVsdFByb3h5SGFuZGxlcnMudHNcbnZhciBkZWZhdWx0UHJvcGVydHlEZXNjcmlwdG9yID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59O1xuZnVuY3Rpb24gZGVmYXVsdFByb3h5SGFuZGxlcnMob3duS2V5cykge1xuICBjb25zdCBfb3duS2V5cyA9IG5ldyBTZXQob3duS2V5cyk7XG4gIHJldHVybiB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAoKSA9PiBkZWZhdWx0UHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gX293bktleXMuaGFzKHByb3ApLFxuICAgIHNldDogKHRhcmdldCwgcHJvcCwgdmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBfb3duS2V5cy5hZGQocHJvcCkgJiYgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBvd25LZXlzOiAoKSA9PiBbLi4uX293bktleXNdXG4gIH07XG59XG5fX25hbWUoZGVmYXVsdFByb3h5SGFuZGxlcnMsIFwiZGVmYXVsdFByb3h5SGFuZGxlcnNcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYXBwbHlGaWVsZHNQcm94eS50c1xuZnVuY3Rpb24gYXBwbHlGaWVsZHNQcm94eShtb2RlbCkge1xuICBjb25zdCBzY2FsYXJGaWVsZHNMaXN0ID0gbW9kZWwuZmllbGRzLmZpbHRlcigoZmllbGQpID0+ICFmaWVsZC5yZWxhdGlvbk5hbWUpO1xuICBjb25zdCBzY2FsYXJGaWVsZHMgPSBrZXlCeTIoc2NhbGFyRmllbGRzTGlzdCwgKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wIGluIHRhcmdldCB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG1tZkZpZWxkID0gc2NhbGFyRmllbGRzW3Byb3BdO1xuICAgICAgICBpZiAoZG1tZkZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFJlZkltcGwobW9kZWwubmFtZSwgcHJvcCwgZG1tZkZpZWxkLnR5cGUsIGRtbWZGaWVsZC5pc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgLi4uZGVmYXVsdFByb3h5SGFuZGxlcnMoT2JqZWN0LmtleXMoc2NhbGFyRmllbGRzKSlcbiAgICB9XG4gICk7XG59XG5fX25hbWUoYXBwbHlGaWVsZHNQcm94eSwgXCJhcHBseUZpZWxkc1Byb3h5XCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FwcGx5Rmx1ZW50LnRzXG5mdW5jdGlvbiBnZXROZXh0RGF0YVBhdGgoZmx1ZW50UHJvcE5hbWUsIHByZXZEYXRhUGF0aCkge1xuICBpZiAoZmx1ZW50UHJvcE5hbWUgPT09IHZvaWQgMCB8fCBwcmV2RGF0YVBhdGggPT09IHZvaWQgMClcbiAgICByZXR1cm4gW107XG4gIHJldHVybiBbLi4ucHJldkRhdGFQYXRoLCBcInNlbGVjdFwiLCBmbHVlbnRQcm9wTmFtZV07XG59XG5fX25hbWUoZ2V0TmV4dERhdGFQYXRoLCBcImdldE5leHREYXRhUGF0aFwiKTtcbmZ1bmN0aW9uIGdldE5leHRVc2VyQXJncyhjYWxsQXJncywgcHJldkFyZ3MsIG5leHREYXRhUGF0aCkge1xuICBpZiAocHJldkFyZ3MgPT09IHZvaWQgMClcbiAgICByZXR1cm4gY2FsbEFyZ3MgIT0gbnVsbCA/IGNhbGxBcmdzIDoge307XG4gIHJldHVybiBkZWVwU2V0KHByZXZBcmdzLCBuZXh0RGF0YVBhdGgsIGNhbGxBcmdzIHx8IHRydWUpO1xufVxuX19uYW1lKGdldE5leHRVc2VyQXJncywgXCJnZXROZXh0VXNlckFyZ3NcIik7XG5mdW5jdGlvbiBhcHBseUZsdWVudChjbGllbnQsIGRtbWZNb2RlbE5hbWUsIG1vZGVsQWN0aW9uLCBmbHVlbnRQcm9wTmFtZSwgcHJldkRhdGFQYXRoLCBwcmV2VXNlckFyZ3MpIHtcbiAgY29uc3QgZG1tZk1vZGVsID0gY2xpZW50Ll9iYXNlRG1tZi5tb2RlbE1hcFtkbW1mTW9kZWxOYW1lXTtcbiAgY29uc3QgZG1tZk1vZGVsRmllbGRNYXAgPSBkbW1mTW9kZWwuZmllbGRzLnJlZHVjZShcbiAgICAoYWNjLCBmaWVsZCkgPT4gKHsgLi4uYWNjLCBbZmllbGQubmFtZV06IGZpZWxkIH0pLFxuICAgIHt9XG4gICk7XG4gIHJldHVybiAodXNlckFyZ3MpID0+IHtcbiAgICBjb25zdCBjYWxsc2l0ZSA9IGdldENhbGxTaXRlKGNsaWVudC5fZXJyb3JGb3JtYXQpO1xuICAgIGNvbnN0IG5leHREYXRhUGF0aCA9IGdldE5leHREYXRhUGF0aChmbHVlbnRQcm9wTmFtZSwgcHJldkRhdGFQYXRoKTtcbiAgICBjb25zdCBuZXh0VXNlckFyZ3MgPSBnZXROZXh0VXNlckFyZ3ModXNlckFyZ3MsIHByZXZVc2VyQXJncywgbmV4dERhdGFQYXRoKTtcbiAgICBjb25zdCBwcmlzbWFQcm9taXNlID0gbW9kZWxBY3Rpb24oeyBkYXRhUGF0aDogbmV4dERhdGFQYXRoLCBjYWxsc2l0ZSB9KShuZXh0VXNlckFyZ3MpO1xuICAgIGNvbnN0IG93bktleXMgPSBnZXRPd25LZXlzKGNsaWVudCwgZG1tZk1vZGVsTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShwcmlzbWFQcm9taXNlLCB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICghb3duS2V5cy5pbmNsdWRlcyhwcm9wKSlcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBjb25zdCBkbW1mTW9kZWxOYW1lMiA9IGRtbWZNb2RlbEZpZWxkTWFwW3Byb3BdLnR5cGU7XG4gICAgICAgIGNvbnN0IG1vZGVsQXJncyA9IFtkbW1mTW9kZWxOYW1lMiwgbW9kZWxBY3Rpb24sIHByb3BdO1xuICAgICAgICBjb25zdCBkYXRhQXJncyA9IFtuZXh0RGF0YVBhdGgsIG5leHRVc2VyQXJnc107XG4gICAgICAgIHJldHVybiBhcHBseUZsdWVudChjbGllbnQsIC4uLm1vZGVsQXJncywgLi4uZGF0YUFyZ3MpO1xuICAgICAgfSxcbiAgICAgIC4uLmRlZmF1bHRQcm94eUhhbmRsZXJzKFsuLi5vd25LZXlzLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcmlzbWFQcm9taXNlKV0pXG4gICAgfSk7XG4gIH07XG59XG5fX25hbWUoYXBwbHlGbHVlbnQsIFwiYXBwbHlGbHVlbnRcIik7XG5mdW5jdGlvbiBnZXRPd25LZXlzKGNsaWVudCwgZG1tZk1vZGVsTmFtZSkge1xuICByZXR1cm4gY2xpZW50Ll9iYXNlRG1tZi5tb2RlbE1hcFtkbW1mTW9kZWxOYW1lXS5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQua2luZCA9PT0gXCJvYmplY3RcIikubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSk7XG59XG5fX25hbWUoZ2V0T3duS2V5cywgXCJnZXRPd25LZXlzXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL3V0aWxzL2RtbWZUb0pTTW9kZWxOYW1lLnRzXG5mdW5jdGlvbiBkbW1mVG9KU01vZGVsTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL14uLywgKHN0cikgPT4gc3RyLnRvTG93ZXJDYXNlKCkpO1xufVxuX19uYW1lKGRtbWZUb0pTTW9kZWxOYW1lLCBcImRtbWZUb0pTTW9kZWxOYW1lXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FwcGx5TW9kZWwudHNcbnZhciBmbHVlbnRQcm9wcyA9IFtcImZpbmRVbmlxdWVcIiwgXCJmaW5kRmlyc3RcIiwgXCJjcmVhdGVcIiwgXCJ1cGRhdGVcIiwgXCJ1cHNlcnRcIiwgXCJkZWxldGVcIl07XG52YXIgYWdncmVnYXRlUHJvcHMgPSBbXCJhZ2dyZWdhdGVcIiwgXCJjb3VudFwiLCBcImdyb3VwQnlcIl07XG5mdW5jdGlvbiBhcHBseU1vZGVsKGNsaWVudCwgZG1tZk1vZGVsTmFtZSkge1xuICB2YXIgX2EzO1xuICBjb25zdCBqc01vZGVsTmFtZSA9IGRtbWZUb0pTTW9kZWxOYW1lKGRtbWZNb2RlbE5hbWUpO1xuICBjb25zdCBtb2RlbCA9IGNsaWVudC5fYmFzZURtbWYubW9kZWxNYXBbZG1tZk1vZGVsTmFtZV07XG4gIGNvbnN0IGZpZWxkc1Byb3h5RW5hYmxlZCA9IChfYTMgPSBjbGllbnQuX2VuZ2luZUNvbmZpZy5wcmV2aWV3RmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuaW5jbHVkZXMoXCJmaWVsZFJlZmVyZW5jZVwiKTtcbiAgY29uc3Qgb3duS2V5cyA9IGdldE93bktleXMyKGNsaWVudCwgZG1tZk1vZGVsTmFtZSk7XG4gIGNvbnN0IGJhc2VPYmplY3QgPSB7fTtcbiAgbGV0IGZpZWxkc1Byb3h5O1xuICByZXR1cm4gbmV3IFByb3h5KGJhc2VPYmplY3QsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQgfHwgdHlwZW9mIHByb3AgPT09IFwic3ltYm9sXCIpXG4gICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICBpZiAocHJvcCA9PT0gXCJmaWVsZHNcIiAmJiBmaWVsZHNQcm94eUVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkc1Byb3h5ICE9IG51bGwgPyBmaWVsZHNQcm94eSA6IGZpZWxkc1Byb3h5ID0gYXBwbHlGaWVsZHNQcm94eShtb2RlbCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzVmFsaWRBY3Rpb25OYW1lKGNsaWVudCwgZG1tZk1vZGVsTmFtZSwgcHJvcCkpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBjb25zdCBkbW1mQWN0aW9uTmFtZSA9IGdldERtbWZBY3Rpb25OYW1lKHByb3ApO1xuICAgICAgbGV0IHJlcXVlc3RGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHBhcmFtcykgPT4gY2xpZW50Ll9yZXF1ZXN0KHBhcmFtcyksIFwicmVxdWVzdEZuXCIpO1xuICAgICAgaWYgKGlzQ2xpZW50T25seUFjdGlvbihwcm9wKSkge1xuICAgICAgICByZXF1ZXN0Rm4gPSB3cmFwUmVxdWVzdChwcm9wLCBkbW1mTW9kZWxOYW1lLCByZXF1ZXN0Rm4pO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocGFyYW1PdmVycmlkZXMpID0+ICh1c2VyQXJncykgPT4ge1xuICAgICAgICBjb25zdCBjYWxsU2l0ZSA9IGdldENhbGxTaXRlKGNsaWVudC5fZXJyb3JGb3JtYXQpO1xuICAgICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IGFyZ3M6IHVzZXJBcmdzLCBkYXRhUGF0aDogW10gfTtcbiAgICAgICAgICBjb25zdCBhY3Rpb24yID0geyBhY3Rpb246IGRtbWZBY3Rpb25OYW1lLCBtb2RlbDogZG1tZk1vZGVsTmFtZSB9O1xuICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IHsgY2xpZW50TWV0aG9kOiBgJHtqc01vZGVsTmFtZX0uJHtwcm9wfWAsIGpzTW9kZWxOYW1lIH07XG4gICAgICAgICAgY29uc3QgdHggPSB7IHJ1bkluVHJhbnNhY3Rpb246ICEhdHhJZCwgdHJhbnNhY3Rpb25JZDogdHhJZCwgbG9jayB9O1xuICAgICAgICAgIGNvbnN0IHRyYWNlMiA9IHsgY2FsbHNpdGU6IGNhbGxTaXRlIH07XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0geyAuLi5kYXRhLCAuLi5hY3Rpb24yLCAuLi5tZXRob2QsIC4uLnR4LCAuLi50cmFjZTIgfTtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdEZuKHsgLi4ucGFyYW1zLCAuLi5wYXJhbU92ZXJyaWRlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBcImFjdGlvblwiKTtcbiAgICAgIGlmIChmbHVlbnRQcm9wcy5pbmNsdWRlcyhkbW1mQWN0aW9uTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5Rmx1ZW50KGNsaWVudCwgZG1tZk1vZGVsTmFtZSwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZhbGlkQWdncmVnYXRlTmFtZShwcm9wKSkge1xuICAgICAgICByZXR1cm4gYXBwbHlBZ2dyZWdhdGVzKGNsaWVudCwgcHJvcCwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb24oe30pO1xuICAgIH0sXG4gICAgLi4uZGVmYXVsdFByb3h5SGFuZGxlcnMob3duS2V5cylcbiAgfSk7XG59XG5fX25hbWUoYXBwbHlNb2RlbCwgXCJhcHBseU1vZGVsXCIpO1xuZnVuY3Rpb24gZ2V0T3duS2V5czIoY2xpZW50LCBkbW1mTW9kZWxOYW1lKSB7XG4gIHJldHVybiBbLi4uT2JqZWN0LmtleXMoY2xpZW50Ll9iYXNlRG1tZi5tYXBwaW5nc01hcFtkbW1mTW9kZWxOYW1lXSksIFwiY291bnRcIl0uZmlsdGVyKFxuICAgIChrZXkpID0+ICFbXCJtb2RlbFwiLCBcInBsdXJhbFwiXS5pbmNsdWRlcyhrZXkpXG4gICk7XG59XG5fX25hbWUoZ2V0T3duS2V5czIsIFwiZ2V0T3duS2V5c1wiKTtcbmZ1bmN0aW9uIGlzVmFsaWRBY3Rpb25OYW1lKGNsaWVudCwgZG1tZk1vZGVsTmFtZSwgYWN0aW9uKSB7XG4gIGlmIChpc0NsaWVudE9ubHlBY3Rpb24oYWN0aW9uKSkge1xuICAgIHJldHVybiBpc1ZhbGlkQWN0aW9uTmFtZShjbGllbnQsIGRtbWZNb2RlbE5hbWUsIGNsaWVudE9ubHlBY3Rpb25zW2FjdGlvbl0ud3JhcHBlZEFjdGlvbik7XG4gIH1cbiAgcmV0dXJuIGdldE93bktleXMyKGNsaWVudCwgZG1tZk1vZGVsTmFtZSkuaW5jbHVkZXMoYWN0aW9uKTtcbn1cbl9fbmFtZShpc1ZhbGlkQWN0aW9uTmFtZSwgXCJpc1ZhbGlkQWN0aW9uTmFtZVwiKTtcbmZ1bmN0aW9uIGlzVmFsaWRBZ2dyZWdhdGVOYW1lKGFjdGlvbikge1xuICByZXR1cm4gYWdncmVnYXRlUHJvcHMuaW5jbHVkZXMoYWN0aW9uKTtcbn1cbl9fbmFtZShpc1ZhbGlkQWdncmVnYXRlTmFtZSwgXCJpc1ZhbGlkQWdncmVnYXRlTmFtZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC91dGlscy9qc1RvRE1NRk1vZGVsTmFtZS50c1xuZnVuY3Rpb24ganNUb0RNTUZNb2RlbE5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9eLi8sIChzdHIpID0+IHN0ci50b1VwcGVyQ2FzZSgpKTtcbn1cbl9fbmFtZShqc1RvRE1NRk1vZGVsTmFtZSwgXCJqc1RvRE1NRk1vZGVsTmFtZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9hcHBseU1vZGVscy50c1xuZnVuY3Rpb24gYXBwbHlNb2RlbHMoY2xpZW50KSB7XG4gIGNvbnN0IG1vZGVsQ2FjaGUgPSB7fTtcbiAgY29uc3Qgb3duS2V5cyA9IGdldE93bktleXMzKGNsaWVudCk7XG4gIHJldHVybiBuZXcgUHJveHkoY2xpZW50LCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0IHx8IHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiKVxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgY29uc3QgZG1tZk1vZGVsTmFtZSA9IGpzVG9ETU1GTW9kZWxOYW1lKHByb3ApO1xuICAgICAgaWYgKG1vZGVsQ2FjaGVbZG1tZk1vZGVsTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbW9kZWxDYWNoZVtkbW1mTW9kZWxOYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGllbnQuX2Jhc2VEbW1mLm1vZGVsTWFwW2RtbWZNb2RlbE5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsQ2FjaGVbZG1tZk1vZGVsTmFtZV0gPSBhcHBseU1vZGVsKGNsaWVudCwgZG1tZk1vZGVsTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50Ll9iYXNlRG1tZi5tb2RlbE1hcFtwcm9wXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBtb2RlbENhY2hlW2RtbWZNb2RlbE5hbWVdID0gYXBwbHlNb2RlbChjbGllbnQsIHByb3ApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLi4uZGVmYXVsdFByb3h5SGFuZGxlcnMob3duS2V5cylcbiAgfSk7XG59XG5fX25hbWUoYXBwbHlNb2RlbHMsIFwiYXBwbHlNb2RlbHNcIik7XG5mdW5jdGlvbiBnZXRPd25LZXlzMyhjbGllbnQpIHtcbiAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhjbGllbnQuX2Jhc2VEbW1mLm1vZGVsTWFwKS5tYXAoZG1tZlRvSlNNb2RlbE5hbWUpLCAuLi5PYmplY3Qua2V5cyhjbGllbnQpXTtcbn1cbl9fbmFtZShnZXRPd25LZXlzMywgXCJnZXRPd25LZXlzXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL3RyYW5zYWN0aW9uL3V0aWxzL2NyZWF0ZUxvY2tDb3VudFByb21pc2UudHNcbmZ1bmN0aW9uIGdldExvY2tDb3VudFByb21pc2Uoa25vY2ssIGNiID0gKCkgPT4ge1xufSkge1xuICBsZXQgcmVzb2x2ZTtcbiAgY29uc3QgbG9jayA9IG5ldyBQcm9taXNlKChyZXMpID0+IHJlc29sdmUgPSByZXMpO1xuICByZXR1cm4ge1xuICAgIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgIGlmICgtLWtub2NrID09PSAwKVxuICAgICAgICByZXNvbHZlKGNiKCkpO1xuICAgICAgcmV0dXJuIG9uRnVsZmlsbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZ1bGZpbGxlZChsb2NrKTtcbiAgICB9XG4gIH07XG59XG5fX25hbWUoZ2V0TG9ja0NvdW50UHJvbWlzZSwgXCJnZXRMb2NrQ291bnRQcm9taXNlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9nZXRMb2dMZXZlbC50c1xuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwobG9nNCkge1xuICBpZiAodHlwZW9mIGxvZzQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbG9nNDtcbiAgfVxuICByZXR1cm4gbG9nNC5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHR5cGVvZiBjdXJyID09PSBcInN0cmluZ1wiID8gY3VyciA6IGN1cnIubGV2ZWw7XG4gICAgaWYgKGN1cnJlbnRMZXZlbCA9PT0gXCJxdWVyeVwiKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoIWFjYykge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICB9XG4gICAgaWYgKGN1cnIgPT09IFwiaW5mb1wiIHx8IGFjYyA9PT0gXCJpbmZvXCIpIHtcbiAgICAgIHJldHVybiBcImluZm9cIjtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgfSwgdm9pZCAwKTtcbn1cbl9fbmFtZShnZXRMb2dMZXZlbCwgXCJnZXRMb2dMZXZlbFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvbWVyZ2VCeS50c1xuZnVuY3Rpb24gbWVyZ2VCeShhcnIxLCBhcnIyLCBjYikge1xuICBjb25zdCBncm91cGVkQXJyMSA9IGdyb3VwQnkyKGFycjEsIGNiKTtcbiAgY29uc3QgZ3JvdXBlZEFycjIgPSBncm91cEJ5MihhcnIyLCBjYik7XG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC52YWx1ZXMoZ3JvdXBlZEFycjIpLm1hcCgodmFsdWUpID0+IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgYXJyMktleXMgPSBPYmplY3Qua2V5cyhncm91cGVkQXJyMik7XG4gIE9iamVjdC5lbnRyaWVzKGdyb3VwZWRBcnIxKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoIWFycjJLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKG1lcmdlQnksIFwibWVyZ2VCeVwiKTtcbnZhciBncm91cEJ5MiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGFyciwgY2IpID0+IHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgIGNvbnN0IGtleSA9IGNiKGN1cnIpO1xuICAgIGlmICghYWNjW2tleV0pIHtcbiAgICAgIGFjY1trZXldID0gW107XG4gICAgfVxuICAgIGFjY1trZXldLnB1c2goY3Vycik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSwgXCJncm91cEJ5XCIpO1xuXG4vLyBzcmMvcnVudGltZS9NaWRkbGV3YXJlSGFuZGxlci50c1xudmFyIE1pZGRsZXdhcmVIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9taWRkbGV3YXJlcyA9IFtdO1xuICB9XG4gIHVzZShtaWRkbGV3YXJlKSB7XG4gICAgdGhpcy5fbWlkZGxld2FyZXMucHVzaChtaWRkbGV3YXJlKTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fbWlkZGxld2FyZXNbaWRdO1xuICB9XG4gIGhhcyhpZCkge1xuICAgIHJldHVybiAhIXRoaXMuX21pZGRsZXdhcmVzW2lkXTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pZGRsZXdhcmVzLmxlbmd0aDtcbiAgfVxufTtcbl9fbmFtZShNaWRkbGV3YXJlSGFuZGxlciwgXCJNaWRkbGV3YXJlSGFuZGxlclwiKTtcbnZhciBNaWRkbGV3YXJlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWVyeSA9IG5ldyBNaWRkbGV3YXJlSGFuZGxlcigpO1xuICAgIHRoaXMuZW5naW5lID0gbmV3IE1pZGRsZXdhcmVIYW5kbGVyKCk7XG4gIH1cbn07XG5fX25hbWUoTWlkZGxld2FyZXMsIFwiTWlkZGxld2FyZXNcIik7XG5cbi8vIHNyYy9ydW50aW1lL1JlcXVlc3RIYW5kbGVyLnRzXG52YXIgaW1wb3J0X3N0cmlwX2Fuc2k0ID0gX190b0VTTShyZXF1aXJlX3N0cmlwX2Fuc2koKSk7XG5cbi8vIHNyYy9ydW50aW1lL0RhdGFMb2FkZXIudHNcbnZhciBEYXRhTG9hZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRpY2tBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmJhdGNoZXMgPSB7fTtcbiAgfVxuICByZXF1ZXN0KHJlcXVlc3QyKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMub3B0aW9ucy5iYXRjaEJ5KHJlcXVlc3QyKTtcbiAgICBpZiAoIWhhc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2luZ2xlTG9hZGVyKHJlcXVlc3QyKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJhdGNoZXNbaGFzaF0pIHtcbiAgICAgIHRoaXMuYmF0Y2hlc1toYXNoXSA9IFtdO1xuICAgICAgaWYgKCF0aGlzLnRpY2tBY3RpdmUpIHtcbiAgICAgICAgdGhpcy50aWNrQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEJhdGNoZXMoKTtcbiAgICAgICAgICB0aGlzLnRpY2tBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmJhdGNoZXNbaGFzaF0ucHVzaCh7XG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QyLFxuICAgICAgICByZXNvbHZlLFxuICAgICAgICByZWplY3RcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGRpc3BhdGNoQmF0Y2hlcygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmJhdGNoZXMpIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaGVzW2tleV07XG4gICAgICBkZWxldGUgdGhpcy5iYXRjaGVzW2tleV07XG4gICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaW5nbGVMb2FkZXIoYmF0Y2hbMF0ucmVxdWVzdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBiYXRjaFswXS5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmF0Y2hbMF0ucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBiYXRjaFswXS5yZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmJhdGNoTG9hZGVyKGJhdGNoLm1hcCgoaikgPT4gai5yZXF1ZXN0KSkudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHRzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgYmF0Y2hbaV0ucmVqZWN0KHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiYXRjaFtpXS5yZWplY3QodmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhdGNoW2ldLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJhdGNoW2ldLnJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiRGF0YUxvYWRlclwiO1xuICB9XG59O1xuX19uYW1lKERhdGFMb2FkZXIsIFwiRGF0YUxvYWRlclwiKTtcblxuLy8gc3JjL3J1bnRpbWUvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBkZWJ1ZzExID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50OnJlcXVlc3RfaGFuZGxlclwiKTtcbmZ1bmN0aW9uIGdldFJlcXVlc3RJbmZvKHJlcXVlc3QyKSB7XG4gIHZhciBfYTM7XG4gIGNvbnN0IHR4SWQgPSByZXF1ZXN0Mi50cmFuc2FjdGlvbklkO1xuICBjb25zdCBpblR4ID0gcmVxdWVzdDIucnVuSW5UcmFuc2FjdGlvbjtcbiAgY29uc3QgaGVhZGVycyA9IChfYTMgPSByZXF1ZXN0Mi5oZWFkZXJzKSAhPSBudWxsID8gX2EzIDoge307XG4gIGNvbnN0IHRyYWNlcGFyZW50ID0gZ2V0VHJhY2VQYXJlbnQoeyB0cmFjaW5nQ29uZmlnOiByZXF1ZXN0Mi50cmFjaW5nQ29uZmlnIH0pO1xuICBjb25zdCBfaW5UeCA9IHR5cGVvZiB0eElkID09PSBcIm51bWJlclwiICYmIGluVHggPyB0cnVlIDogdm9pZCAwO1xuICBjb25zdCBfdHhJZCA9IHR5cGVvZiB0eElkID09PSBcInN0cmluZ1wiICYmIGluVHggPyB0eElkIDogdm9pZCAwO1xuICBpZiAoX3R4SWQgIT09IHZvaWQgMClcbiAgICBoZWFkZXJzLnRyYW5zYWN0aW9uSWQgPSBfdHhJZDtcbiAgaWYgKHRyYWNlcGFyZW50ICE9PSB2b2lkIDApXG4gICAgaGVhZGVycy50cmFjZXBhcmVudCA9IHRyYWNlcGFyZW50O1xuICByZXR1cm4geyBpblR4OiBfaW5UeCwgaGVhZGVycyB9O1xufVxuX19uYW1lKGdldFJlcXVlc3RJbmZvLCBcImdldFJlcXVlc3RJbmZvXCIpO1xudmFyIFJlcXVlc3RIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGhvb2tzKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgIHRoaXMuZGF0YWxvYWRlciA9IG5ldyBEYXRhTG9hZGVyKHtcbiAgICAgIGJhdGNoTG9hZGVyOiAocmVxdWVzdHMpID0+IHtcbiAgICAgICAgY29uc3QgaW5mbzIgPSBnZXRSZXF1ZXN0SW5mbyhyZXF1ZXN0c1swXSk7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSByZXF1ZXN0cy5tYXAoKHIpID0+IFN0cmluZyhyLmRvY3VtZW50KSk7XG4gICAgICAgIGNvbnN0IHRyYWNlcGFyZW50ID0gZ2V0VHJhY2VQYXJlbnQoeyBjb250ZXh0OiByZXF1ZXN0c1swXS5vdGVsUGFyZW50Q3R4LCB0cmFjaW5nQ29uZmlnOiBjbGllbnQuX3RyYWNpbmdDb25maWcgfSk7XG4gICAgICAgIGlmICh0cmFjZXBhcmVudClcbiAgICAgICAgICBpbmZvMi5oZWFkZXJzLnRyYWNlcGFyZW50ID0gdHJhY2VwYXJlbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5fZW5naW5lLnJlcXVlc3RCYXRjaChxdWVyaWVzLCBpbmZvMi5oZWFkZXJzLCBpbmZvMi5pblR4KTtcbiAgICAgIH0sXG4gICAgICBzaW5nbGVMb2FkZXI6IChyZXF1ZXN0MikgPT4ge1xuICAgICAgICBjb25zdCBpbmZvMiA9IGdldFJlcXVlc3RJbmZvKHJlcXVlc3QyKTtcbiAgICAgICAgY29uc3QgcXVlcnkyID0gU3RyaW5nKHJlcXVlc3QyLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Ll9lbmdpbmUucmVxdWVzdChxdWVyeTIsIGluZm8yLmhlYWRlcnMpO1xuICAgICAgfSxcbiAgICAgIGJhdGNoQnk6IChyZXF1ZXN0MikgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdDIudHJhbnNhY3Rpb25JZCkge1xuICAgICAgICAgIHJldHVybiBgdHJhbnNhY3Rpb24tJHtyZXF1ZXN0Mi50cmFuc2FjdGlvbklkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhdGNoRmluZFVuaXF1ZUJ5KHJlcXVlc3QyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHtcbiAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgIGRhdGFQYXRoID0gW10sXG4gICAgcm9vdEZpZWxkLFxuICAgIHR5cGVOYW1lLFxuICAgIGlzTGlzdCxcbiAgICBjYWxsc2l0ZSxcbiAgICByZWplY3RPbk5vdEZvdW5kLFxuICAgIGNsaWVudE1ldGhvZCxcbiAgICBydW5JblRyYW5zYWN0aW9uLFxuICAgIGVuZ2luZUhvb2ssXG4gICAgYXJncyxcbiAgICBoZWFkZXJzLFxuICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgdW5wYWNrZXIsXG4gICAgb3RlbFBhcmVudEN0eCxcbiAgICBvdGVsQ2hpbGRDdHhcbiAgfSkge1xuICAgIGlmICh0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuYmVmb3JlUmVxdWVzdCkge1xuICAgICAgY29uc3QgcXVlcnkyID0gU3RyaW5nKGRvY3VtZW50Mik7XG4gICAgICB0aGlzLmhvb2tzLmJlZm9yZVJlcXVlc3Qoe1xuICAgICAgICBxdWVyeTogcXVlcnkyLFxuICAgICAgICBwYXRoOiBkYXRhUGF0aCxcbiAgICAgICAgcm9vdEZpZWxkLFxuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50MixcbiAgICAgICAgaXNMaXN0LFxuICAgICAgICBjbGllbnRNZXRob2QsXG4gICAgICAgIGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEsIGVsYXBzZWQ7XG4gICAgICBpZiAoZW5naW5lSG9vaykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmdpbmVIb29rKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudDIsXG4gICAgICAgICAgICBydW5JblRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICAocGFyYW1zKSA9PiB0aGlzLmRhdGFsb2FkZXIucmVxdWVzdCh7IC4uLnBhcmFtcywgdHJhY2luZ0NvbmZpZzogdGhpcy5jbGllbnQuX3RyYWNpbmdDb25maWcgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICBlbGFwc2VkID0gcmVzdWx0LmVsYXBzZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRhdGFsb2FkZXIucmVxdWVzdCh7XG4gICAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50MixcbiAgICAgICAgICBydW5JblRyYW5zYWN0aW9uLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgdHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICBvdGVsUGFyZW50Q3R4LFxuICAgICAgICAgIG90ZWxDaGlsZEN0eCxcbiAgICAgICAgICB0cmFjaW5nQ29uZmlnOiB0aGlzLmNsaWVudC5fdHJhY2luZ0NvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YSA9IHJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcmVzdWx0LmRhdGE7XG4gICAgICAgIGVsYXBzZWQgPSByZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3VsdC5lbGFwc2VkO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5wYWNrUmVzdWx0ID0gdGhpcy51bnBhY2soZG9jdW1lbnQyLCBkYXRhLCBkYXRhUGF0aCwgcm9vdEZpZWxkLCB1bnBhY2tlcik7XG4gICAgICB0aHJvd0lmTm90Rm91bmQodW5wYWNrUmVzdWx0LCBjbGllbnRNZXRob2QsIHR5cGVOYW1lLCByZWplY3RPbk5vdEZvdW5kKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5QUklTTUFfQ0xJRU5UX0dFVF9USU1FKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHVucGFja1Jlc3VsdCwgZWxhcHNlZCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVucGFja1Jlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdEVycm9yKHsgZXJyb3I6IGVycm9yMiwgY2xpZW50TWV0aG9kLCBjYWxsc2l0ZSB9KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVxdWVzdEVycm9yKHsgZXJyb3I6IGVycm9yMiwgY2xpZW50TWV0aG9kLCBjYWxsc2l0ZSB9KSB7XG4gICAgZGVidWcxMShlcnJvcjIpO1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IyLm1lc3NhZ2U7XG4gICAgaWYgKGNhbGxzaXRlKSB7XG4gICAgICBtZXNzYWdlID0gY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICBjYWxsc2l0ZSxcbiAgICAgICAgb3JpZ2luYWxNZXRob2Q6IGNsaWVudE1ldGhvZCxcbiAgICAgICAgaXNQYW5pYzogZXJyb3IyLmlzUGFuaWMsXG4gICAgICAgIHNob3dDb2xvcnM6IHRoaXMuY2xpZW50Ll9lcnJvckZvcm1hdCA9PT0gXCJwcmV0dHlcIixcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSB0aGlzLnNhbml0aXplTWVzc2FnZShtZXNzYWdlKTtcbiAgICBpZiAoZXJyb3IyLmNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcihtZXNzYWdlLCBlcnJvcjIuY29kZSwgdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24sIGVycm9yMi5tZXRhKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yMi5pc1BhbmljKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IobWVzc2FnZSwgdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24pO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IyIGluc3RhbmNlb2YgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IobWVzc2FnZSwgdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24pO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IyIGluc3RhbmNlb2YgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IobWVzc2FnZSwgdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24pO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IyIGluc3RhbmNlb2YgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcihtZXNzYWdlLCB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbik7XG4gICAgfVxuICAgIGVycm9yMi5jbGllbnRWZXJzaW9uID0gdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb247XG4gICAgdGhyb3cgZXJyb3IyO1xuICB9XG4gIHNhbml0aXplTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50Ll9lcnJvckZvcm1hdCAmJiB0aGlzLmNsaWVudC5fZXJyb3JGb3JtYXQgIT09IFwicHJldHR5XCIpIHtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X3N0cmlwX2Fuc2k0LmRlZmF1bHQpKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICB1bnBhY2soZG9jdW1lbnQyLCBkYXRhLCBwYXRoNywgcm9vdEZpZWxkLCB1bnBhY2tlcikge1xuICAgIGlmIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLmRhdGE7XG4gICAgfVxuICAgIGlmICh1bnBhY2tlcikge1xuICAgICAgZGF0YVtyb290RmllbGRdID0gdW5wYWNrZXIoZGF0YVtyb290RmllbGRdKTtcbiAgICB9XG4gICAgY29uc3QgZ2V0UGF0aCA9IFtdO1xuICAgIGlmIChyb290RmllbGQpIHtcbiAgICAgIGdldFBhdGgucHVzaChyb290RmllbGQpO1xuICAgIH1cbiAgICBnZXRQYXRoLnB1c2goLi4ucGF0aDcuZmlsdGVyKChwKSA9PiBwICE9PSBcInNlbGVjdFwiICYmIHAgIT09IFwiaW5jbHVkZVwiKSk7XG4gICAgcmV0dXJuIHVucGFjayh7IGRvY3VtZW50OiBkb2N1bWVudDIsIGRhdGEsIHBhdGg6IGdldFBhdGggfSk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlJlcXVlc3RIYW5kbGVyXCI7XG4gIH1cbn07XG5fX25hbWUoUmVxdWVzdEhhbmRsZXIsIFwiUmVxdWVzdEhhbmRsZXJcIik7XG5mdW5jdGlvbiBiYXRjaEZpbmRVbmlxdWVCeShyZXF1ZXN0Mikge1xuICB2YXIgX2EzO1xuICBpZiAoIXJlcXVlc3QyLmRvY3VtZW50LmNoaWxkcmVuWzBdLm5hbWUuc3RhcnRzV2l0aChcImZpbmRVbmlxdWVcIikpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGFyZ3MgPSAoX2EzID0gcmVxdWVzdDIuZG9jdW1lbnQuY2hpbGRyZW5bMF0uYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hcmdzLm1hcCgoYSkgPT4ge1xuICAgIGlmIChhLnZhbHVlIGluc3RhbmNlb2YgQXJncykge1xuICAgICAgcmV0dXJuIGAke2Eua2V5fS0ke2EudmFsdWUuYXJncy5tYXAoKGEyKSA9PiBhMi5rZXkpLmpvaW4oXCIsXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiBhLmtleTtcbiAgfSkuam9pbihcIixcIik7XG4gIGNvbnN0IHNlbGVjdGlvblNldCA9IHJlcXVlc3QyLmRvY3VtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuLmpvaW4oXCIsXCIpO1xuICByZXR1cm4gYCR7cmVxdWVzdDIuZG9jdW1lbnQuY2hpbGRyZW5bMF0ubmFtZX18JHthcmdzfXwke3NlbGVjdGlvblNldH1gO1xufVxuX19uYW1lKGJhdGNoRmluZFVuaXF1ZUJ5LCBcImJhdGNoRmluZFVuaXF1ZUJ5XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9jbGllbnRWZXJzaW9uLnRzXG52YXIgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmVfcGFja2FnZTIoKS52ZXJzaW9uO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9kZXNlcmlhbGl6ZVJhd1Jlc3VsdHMudHNcbmZ1bmN0aW9uIGRlc2VyaWFsaXplUmF3UmVzdWx0cyhyb3dzKSB7XG4gIHJldHVybiByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgY29uc3QgbWFwcGVkUm93ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocm93KSkge1xuICAgICAgbWFwcGVkUm93W2tleV0gPSBkZXNlcmlhbGl6ZVZhbHVlKHJvd1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFJvdztcbiAgfSk7XG59XG5fX25hbWUoZGVzZXJpYWxpemVSYXdSZXN1bHRzLCBcImRlc2VyaWFsaXplUmF3UmVzdWx0c1wiKTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUoeyBwcmlzbWFfX3R5cGU6IHR5cGUsIHByaXNtYV9fdmFsdWU6IHZhbHVlIH0pIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIGNhc2UgXCJkZWNpbWFsXCI6XG4gICAgICByZXR1cm4gbmV3IGRlY2ltYWxfZGVmYXVsdCh2YWx1ZSk7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgY2FzZSBcImRhdGVcIjpcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgY2FzZSBcInRpbWVcIjpcbiAgICAgIHJldHVybiBuZXcgRGF0ZShgMTk3MC0wMS0wMVQke3ZhbHVlfVpgKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZGVzZXJpYWxpemVWYWx1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuX19uYW1lKGRlc2VyaWFsaXplVmFsdWUsIFwiZGVzZXJpYWxpemVWYWx1ZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvbXNzcWxQcmVwYXJlZFN0YXRlbWVudC50c1xudmFyIG1zc3FsUHJlcGFyZWRTdGF0ZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh0ZW1wbGF0ZSkgPT4ge1xuICByZXR1cm4gdGVtcGxhdGUucmVkdWNlKChhY2MsIHN0ciwgaWR4KSA9PiBgJHthY2N9QFAke2lkeH0ke3N0cn1gKTtcbn0sIFwibXNzcWxQcmVwYXJlZFN0YXRlbWVudFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvc2VyaWFsaXplUmF3UGFyYW1ldGVycy50c1xuZnVuY3Rpb24gc2VyaWFsaXplUmF3UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnNJbnRlcm5hbChwYXJhbWV0ZXJzLCBcImZhc3RcIik7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzSW50ZXJuYWwocGFyYW1ldGVycywgXCJzbG93XCIpO1xuICB9XG59XG5fX25hbWUoc2VyaWFsaXplUmF3UGFyYW1ldGVycywgXCJzZXJpYWxpemVSYXdQYXJhbWV0ZXJzXCIpO1xuZnVuY3Rpb24gc2VyaWFsaXplUmF3UGFyYW1ldGVyc0ludGVybmFsKHBhcmFtZXRlcnMsIG9iamVjdFNlcmlhbGl6YXRpb24pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IGVuY29kZVBhcmFtZXRlcihwYXJhbWV0ZXIsIG9iamVjdFNlcmlhbGl6YXRpb24pKSk7XG59XG5fX25hbWUoc2VyaWFsaXplUmF3UGFyYW1ldGVyc0ludGVybmFsLCBcInNlcmlhbGl6ZVJhd1BhcmFtZXRlcnNJbnRlcm5hbFwiKTtcbmZ1bmN0aW9uIGVuY29kZVBhcmFtZXRlcihwYXJhbWV0ZXIsIG9iamVjdFNlcmlhbGl6YXRpb24pIHtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpc21hX190eXBlOiBcImJpZ2ludFwiLFxuICAgICAgcHJpc21hX192YWx1ZTogcGFyYW1ldGVyLnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc0RhdGUocGFyYW1ldGVyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlzbWFfX3R5cGU6IFwiZGF0ZVwiLFxuICAgICAgcHJpc21hX192YWx1ZTogcGFyYW1ldGVyLnRvSlNPTigpXG4gICAgfTtcbiAgfVxuICBpZiAoZGVjaW1hbF9kZWZhdWx0LmlzRGVjaW1hbChwYXJhbWV0ZXIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaXNtYV9fdHlwZTogXCJkZWNpbWFsXCIsXG4gICAgICBwcmlzbWFfX3ZhbHVlOiBwYXJhbWV0ZXIudG9KU09OKClcbiAgICB9O1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIocGFyYW1ldGVyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlzbWFfX3R5cGU6IFwiYnl0ZXNcIixcbiAgICAgIHByaXNtYV9fdmFsdWU6IHBhcmFtZXRlci50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKHBhcmFtZXRlcikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpc21hX190eXBlOiBcImJ5dGVzXCIsXG4gICAgICBwcmlzbWFfX3ZhbHVlOiBCdWZmZXIuZnJvbShwYXJhbWV0ZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3RTZXJpYWxpemF0aW9uID09PSBcInNsb3dcIikge1xuICAgIHJldHVybiBwcmVwcm9jZXNzT2JqZWN0KHBhcmFtZXRlcik7XG4gIH1cbiAgcmV0dXJuIHBhcmFtZXRlcjtcbn1cbl9fbmFtZShlbmNvZGVQYXJhbWV0ZXIsIFwiZW5jb2RlUGFyYW1ldGVyXCIpO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuX19uYW1lKGlzRGF0ZSwgXCJpc0RhdGVcIik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyTGlrZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkFycmF5QnVmZmVyXCIgfHwgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJTaGFyZWRBcnJheUJ1ZmZlclwiO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbl9fbmFtZShpc0FycmF5QnVmZmVyTGlrZSwgXCJpc0FycmF5QnVmZmVyTGlrZVwiKTtcbmZ1bmN0aW9uIHByZXByb2Nlc3NPYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChwcmVwcm9jZXNzVmFsdWVJbk9iamVjdCk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICByZXN1bHRba2V5XSA9IHByZXByb2Nlc3NWYWx1ZUluT2JqZWN0KG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKHByZXByb2Nlc3NPYmplY3QsIFwicHJlcHJvY2Vzc09iamVjdFwiKTtcbmZ1bmN0aW9uIHByZXByb2Nlc3NWYWx1ZUluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gcHJlcHJvY2Vzc09iamVjdCh2YWx1ZSk7XG59XG5fX25hbWUocHJlcHJvY2Vzc1ZhbHVlSW5PYmplY3QsIFwicHJlcHJvY2Vzc1ZhbHVlSW5PYmplY3RcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL3ZhbGlkYXRlUHJpc21hQ2xpZW50T3B0aW9ucy50c1xudmFyIGltcG9ydF9qc19sZXZlbnNodGVpbjIgPSBfX3RvRVNNKHJlcXVpcmVfanNfbGV2ZW5zaHRlaW4oKSk7XG52YXIga25vd25Qcm9wZXJ0aWVzID0gW1wiZGF0YXNvdXJjZXNcIiwgXCJlcnJvckZvcm1hdFwiLCBcImxvZ1wiLCBcIl9faW50ZXJuYWxcIiwgXCJyZWplY3RPbk5vdEZvdW5kXCJdO1xudmFyIGVycm9yRm9ybWF0cyA9IFtcInByZXR0eVwiLCBcImNvbG9ybGVzc1wiLCBcIm1pbmltYWxcIl07XG52YXIgbG9nTGV2ZWxzID0gW1wiaW5mb1wiLCBcInF1ZXJ5XCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xudmFyIHZhbGlkYXRvcnMgPSB7XG4gIGRhdGFzb3VyY2VzOiAob3B0aW9ucywgZGF0YXNvdXJjZU5hbWVzKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGZvciBcImRhdGFzb3VyY2VzXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yYFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucykpIHtcbiAgICAgIGlmICghZGF0YXNvdXJjZU5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29uc3QgZGlkWW91TWVhbiA9IGdldERpZFlvdU1lYW4oa2V5LCBkYXRhc291cmNlTmFtZXMpIHx8IGBBdmFpbGFibGUgZGF0YXNvdXJjZXM6ICR7ZGF0YXNvdXJjZU5hbWVzLmpvaW4oXCIsIFwiKX1gO1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgYFVua25vd24gZGF0YXNvdXJjZSAke2tleX0gcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiR7ZGlkWW91TWVhbn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfSBmb3IgZGF0YXNvdXJjZSBcIiR7a2V5fVwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci5cbkl0IHNob3VsZCBoYXZlIHRoaXMgZm9ybTogeyB1cmw6IFwiQ09OTkVDVElPTl9TVFJJTkdcIiB9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXkxLCB2YWx1ZTFdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChrZXkxICE9PSBcInVybFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGZvciBkYXRhc291cmNlIFwiJHtrZXl9XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLlxuSXQgc2hvdWxkIGhhdmUgdGhpcyBmb3JtOiB7IHVybDogXCJDT05ORUNUSU9OX1NUUklOR1wiIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlMSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KHZhbHVlMSl9IGZvciBkYXRhc291cmNlIFwiJHtrZXl9XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLlxuSXQgc2hvdWxkIGhhdmUgdGhpcyBmb3JtOiB7IHVybDogXCJDT05ORUNUSU9OX1NUUklOR1wiIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3JGb3JtYXQ6IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfSBmb3IgXCJlcnJvckZvcm1hdFwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWVycm9yRm9ybWF0cy5pbmNsdWRlcyhvcHRpb25zKSkge1xuICAgICAgY29uc3QgZGlkWW91TWVhbiA9IGdldERpZFlvdU1lYW4ob3B0aW9ucywgZXJyb3JGb3JtYXRzKTtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgZXJyb3JGb3JtYXQgJHtvcHRpb25zfSBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtkaWRZb3VNZWFufWBcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBsb2c6IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfSBmb3IgXCJsb2dcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuYFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMb2dMZXZlbChsZXZlbCkge1xuICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIWxvZ0xldmVscy5pbmNsdWRlcyhsZXZlbCkpIHtcbiAgICAgICAgICBjb25zdCBkaWRZb3VNZWFuID0gZ2V0RGlkWW91TWVhbihsZXZlbCwgbG9nTGV2ZWxzKTtcbiAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBsb2cgbGV2ZWwgXCIke2xldmVsfVwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke2RpZFlvdU1lYW59YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHZhbGlkYXRlTG9nTGV2ZWwsIFwidmFsaWRhdGVMb2dMZXZlbFwiKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICB2YWxpZGF0ZUxvZ0xldmVsKG9wdGlvbik7XG4gICAgICBjb25zdCBsb2dWYWxpZGF0b3JzID0ge1xuICAgICAgICBsZXZlbDogdmFsaWRhdGVMb2dMZXZlbCxcbiAgICAgICAgZW1pdDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZW1pdHMgPSBbXCJzdGRvdXRcIiwgXCJldmVudFwiXTtcbiAgICAgICAgICBpZiAoIWVtaXRzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlkWW91TWVhbiA9IGdldERpZFlvdU1lYW4odmFsdWUsIGVtaXRzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICApfSBmb3IgXCJlbWl0XCIgaW4gbG9nTGV2ZWwgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiR7ZGlkWW91TWVhbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb24gJiYgdHlwZW9mIG9wdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb24pKSB7XG4gICAgICAgICAgaWYgKGxvZ1ZhbGlkYXRvcnNba2V5XSkge1xuICAgICAgICAgICAgbG9nVmFsaWRhdG9yc1trZXldKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSAke2tleX0gZm9yIFwibG9nXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9faW50ZXJuYWw6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga25vd25LZXlzID0gW1wiZGVidWdcIiwgXCJob29rc1wiLCBcImVuZ2luZVwiLCBcIm1lYXN1cmVQZXJmb3JtYW5jZVwiXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSBmb3IgXCJfX2ludGVybmFsXCIgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yYFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgIGlmICgha25vd25LZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29uc3QgZGlkWW91TWVhbiA9IGdldERpZFlvdU1lYW4oa2V5LCBrbm93bktleXMpO1xuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBmb3IgXCJfX2ludGVybmFsXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiR7ZGlkWW91TWVhbn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZWplY3RPbk5vdEZvdW5kOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICBgSW52YWxpZCByZWplY3RPbk5vdEZvdW5kIGV4cGVjdGVkIGEgYm9vbGVhbi9FcnJvci97W21vZGVsTmFtZTogRXJyb3IgfCBib29sZWFuXX0gYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHZhbHVlXG4gICAgICApfWBcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVQcmlzbWFDbGllbnRPcHRpb25zKG9wdGlvbnMsIGRhdGFzb3VyY2VOYW1lcykge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgIGlmICgha25vd25Qcm9wZXJ0aWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnN0IGRpZFlvdU1lYW4gPSBnZXREaWRZb3VNZWFuKGtleSwga25vd25Qcm9wZXJ0aWVzKTtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYFVua25vd24gcHJvcGVydHkgJHtrZXl9IHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke2RpZFlvdU1lYW59YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdG9yc1trZXldKHZhbHVlLCBkYXRhc291cmNlTmFtZXMpO1xuICB9XG59XG5fX25hbWUodmFsaWRhdGVQcmlzbWFDbGllbnRPcHRpb25zLCBcInZhbGlkYXRlUHJpc21hQ2xpZW50T3B0aW9uc1wiKTtcbmZ1bmN0aW9uIGdldERpZFlvdU1lYW4oc3RyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgYWx0ZXJuYXRpdmUgPSBnZXRBbHRlcm5hdGl2ZShzdHIsIG9wdGlvbnMpO1xuICBpZiAoIWFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIGAgRGlkIHlvdSBtZWFuIFwiJHthbHRlcm5hdGl2ZX1cIj9gO1xufVxuX19uYW1lKGdldERpZFlvdU1lYW4sIFwiZ2V0RGlkWW91TWVhblwiKTtcbmZ1bmN0aW9uIGdldEFsdGVybmF0aXZlKHN0ciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBvcHRpb25zV2l0aERpc3RhbmNlcyA9IG9wdGlvbnMubWFwKCh2YWx1ZSkgPT4gKHtcbiAgICB2YWx1ZSxcbiAgICBkaXN0YW5jZTogKDAsIGltcG9ydF9qc19sZXZlbnNodGVpbjIuZGVmYXVsdCkoc3RyLCB2YWx1ZSlcbiAgfSkpO1xuICBvcHRpb25zV2l0aERpc3RhbmNlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEuZGlzdGFuY2UgPCBiLmRpc3RhbmNlID8gLTEgOiAxO1xuICB9KTtcbiAgY29uc3QgYmVzdEFsdGVybmF0aXZlID0gb3B0aW9uc1dpdGhEaXN0YW5jZXNbMF07XG4gIGlmIChiZXN0QWx0ZXJuYXRpdmUuZGlzdGFuY2UgPCAzKSB7XG4gICAgcmV0dXJuIGJlc3RBbHRlcm5hdGl2ZS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbl9fbmFtZShnZXRBbHRlcm5hdGl2ZSwgXCJnZXRBbHRlcm5hdGl2ZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvZ2V0UHJpc21hQ2xpZW50LnRzXG52YXIgZGVidWcxMiA9IHNyY19kZWZhdWx0KFwicHJpc21hOmNsaWVudFwiKTtcbnZhciBBTFRFUl9SRSA9IC9eKFxccyphbHRlclxccykvaTtcbnR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiID8gZ2xvYmFsVGhpcy5OT0RFX0NMSUVOVCA9IHRydWUgOiAwO1xuZnVuY3Rpb24gaXNSZWFkb25seUFycmF5KGFyZzIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnMik7XG59XG5fX25hbWUoaXNSZWFkb25seUFycmF5LCBcImlzUmVhZG9ubHlBcnJheVwiKTtcbmZ1bmN0aW9uIGNoZWNrQWx0ZXIocXVlcnkyLCB2YWx1ZXMsIGludmFsaWRDYWxsKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID4gMCAmJiBBTFRFUl9SRS5leGVjKHF1ZXJ5MikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5pbmcgQUxURVIgdXNpbmcgJHtpbnZhbGlkQ2FsbH0gaXMgbm90IHN1cHBvcnRlZFxuVXNpbmcgdGhlIGV4YW1wbGUgYmVsb3cgeW91IGNhbiBzdGlsbCBleGVjdXRlIHlvdXIgcXVlcnkgd2l0aCBQcmlzbWEsIGJ1dCBwbGVhc2Ugbm90ZSB0aGF0IGl0IGlzIHZ1bG5lcmFibGUgdG8gU1FMIGluamVjdGlvbiBhdHRhY2tzIGFuZCByZXF1aXJlcyB5b3UgdG8gdGFrZSBjYXJlIG9mIGlucHV0IHNhbml0aXphdGlvbi5cblxuRXhhbXBsZTpcbiAgYXdhaXQgcHJpc21hLiRleGVjdXRlUmF3VW5zYWZlKFxcYEFMVEVSIFVTRVIgcHJpc21hIFdJVEggUEFTU1dPUkQgJ1xcJHtwYXNzd29yZH0nXFxgKVxuXG5Nb3JlIEluZm9ybWF0aW9uOiBodHRwczovL3ByaXMubHkvZC9leGVjdXRlLXJhd1xuYCk7XG4gIH1cbn1cbl9fbmFtZShjaGVja0FsdGVyLCBcImNoZWNrQWx0ZXJcIik7XG52YXIgYWN0aW9uT3BlcmF0aW9uTWFwID0ge1xuICBmaW5kVW5pcXVlOiBcInF1ZXJ5XCIsXG4gIGZpbmRGaXJzdDogXCJxdWVyeVwiLFxuICBmaW5kTWFueTogXCJxdWVyeVwiLFxuICBjb3VudDogXCJxdWVyeVwiLFxuICBjcmVhdGU6IFwibXV0YXRpb25cIixcbiAgY3JlYXRlTWFueTogXCJtdXRhdGlvblwiLFxuICB1cGRhdGU6IFwibXV0YXRpb25cIixcbiAgdXBkYXRlTWFueTogXCJtdXRhdGlvblwiLFxuICB1cHNlcnQ6IFwibXV0YXRpb25cIixcbiAgZGVsZXRlOiBcIm11dGF0aW9uXCIsXG4gIGRlbGV0ZU1hbnk6IFwibXV0YXRpb25cIixcbiAgZXhlY3V0ZVJhdzogXCJtdXRhdGlvblwiLFxuICBxdWVyeVJhdzogXCJtdXRhdGlvblwiLFxuICBhZ2dyZWdhdGU6IFwicXVlcnlcIixcbiAgZ3JvdXBCeTogXCJxdWVyeVwiLFxuICBydW5Db21tYW5kUmF3OiBcIm11dGF0aW9uXCIsXG4gIGZpbmRSYXc6IFwicXVlcnlcIixcbiAgYWdncmVnYXRlUmF3OiBcInF1ZXJ5XCJcbn07XG52YXIgVFhfSUQgPSBTeW1ib2wuZm9yKFwicHJpc21hLmNsaWVudC50cmFuc2FjdGlvbi5pZFwiKTtcbmZ1bmN0aW9uIGdldFByaXNtYUNsaWVudChjb25maWcyKSB7XG4gIGNsYXNzIFByaXNtYUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc0FyZykge1xuICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSBuZXcgTWlkZGxld2FyZXMoKTtcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9uSWQgPSAxO1xuICAgICAgdGhpcy5fZ2V0RG1tZiA9IGNhbGxPbmNlKGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkbW1mID0gYXdhaXQgdGhpcy5fZW5naW5lLmdldERtbWYoKTtcbiAgICAgICAgICByZXR1cm4gbmV3IERNTUZIZWxwZXIoZ2V0UHJpc21hQ2xpZW50RE1NRihkbW1mKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgIHRoaXMuX2ZldGNoZXIuaGFuZGxlUmVxdWVzdEVycm9yKHsgLi4ucGFyYW1zLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfYTMsIF9iMiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2k7XG4gICAgICBpZiAob3B0aW9uc0FyZykge1xuICAgICAgICB2YWxpZGF0ZVByaXNtYUNsaWVudE9wdGlvbnMob3B0aW9uc0FyZywgY29uZmlnMi5kYXRhc291cmNlTmFtZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJldmlld0ZlYXR1cmVzID0gKF9iMiA9IChfYTMgPSBjb25maWcyLmdlbmVyYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5wcmV2aWV3RmVhdHVyZXMpICE9IG51bGwgPyBfYjIgOiBbXTtcbiAgICAgIHRoaXMuX3JlamVjdE9uTm90Rm91bmQgPSBvcHRpb25zQXJnID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zQXJnLnJlamVjdE9uTm90Rm91bmQ7XG4gICAgICB0aGlzLl9jbGllbnRWZXJzaW9uID0gKF9jID0gY29uZmlnMi5jbGllbnRWZXJzaW9uKSAhPSBudWxsID8gX2MgOiBjbGllbnRWZXJzaW9uO1xuICAgICAgdGhpcy5fYWN0aXZlUHJvdmlkZXIgPSBjb25maWcyLmFjdGl2ZVByb3ZpZGVyO1xuICAgICAgdGhpcy5fZGF0YVByb3h5ID0gY29uZmlnMi5kYXRhUHJveHk7XG4gICAgICB0aGlzLl90cmFjaW5nQ29uZmlnID0gZ2V0VHJhY2luZ0NvbmZpZyh0aGlzLl9wcmV2aWV3RmVhdHVyZXMpO1xuICAgICAgdGhpcy5fY2xpZW50RW5naW5lVHlwZSA9IGdldENsaWVudEVuZ2luZVR5cGUoY29uZmlnMi5nZW5lcmF0b3IpO1xuICAgICAgY29uc3QgZW52UGF0aHMgPSB7XG4gICAgICAgIHJvb3RFbnZQYXRoOiBjb25maWcyLnJlbGF0aXZlRW52UGF0aHMucm9vdEVudlBhdGggJiYgaW1wb3J0X3BhdGg1LmRlZmF1bHQucmVzb2x2ZShjb25maWcyLmRpcm5hbWUsIGNvbmZpZzIucmVsYXRpdmVFbnZQYXRocy5yb290RW52UGF0aCksXG4gICAgICAgIHNjaGVtYUVudlBhdGg6IGNvbmZpZzIucmVsYXRpdmVFbnZQYXRocy5zY2hlbWFFbnZQYXRoICYmIGltcG9ydF9wYXRoNS5kZWZhdWx0LnJlc29sdmUoY29uZmlnMi5kaXJuYW1lLCBjb25maWcyLnJlbGF0aXZlRW52UGF0aHMuc2NoZW1hRW52UGF0aClcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZWRFbnYgPSB0cnlMb2FkRW52cyhlbnZQYXRocywgeyBjb25mbGljdENoZWNrOiBcIm5vbmVcIiB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zQXJnICE9IG51bGwgPyBvcHRpb25zQXJnIDoge307XG4gICAgICAgIGNvbnN0IGludGVybmFsID0gKF9kID0gb3B0aW9ucy5fX2ludGVybmFsKSAhPSBudWxsID8gX2QgOiB7fTtcbiAgICAgICAgY29uc3QgdXNlRGVidWcgPSBpbnRlcm5hbC5kZWJ1ZyA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZURlYnVnKSB7XG4gICAgICAgICAgc3JjX2RlZmF1bHQuZW5hYmxlKFwicHJpc21hOmNsaWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJuYWwuaG9va3MpIHtcbiAgICAgICAgICB0aGlzLl9ob29rcyA9IGludGVybmFsLmhvb2tzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjd2QgPSBpbXBvcnRfcGF0aDUuZGVmYXVsdC5yZXNvbHZlKGNvbmZpZzIuZGlybmFtZSwgY29uZmlnMi5yZWxhdGl2ZVBhdGgpO1xuICAgICAgICBpZiAoIWltcG9ydF9mczkuZGVmYXVsdC5leGlzdHNTeW5jKGN3ZCkpIHtcbiAgICAgICAgICBjd2QgPSBjb25maWcyLmRpcm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcxMihcImRpcm5hbWVcIiwgY29uZmlnMi5kaXJuYW1lKTtcbiAgICAgICAgZGVidWcxMihcInJlbGF0aXZlUGF0aFwiLCBjb25maWcyLnJlbGF0aXZlUGF0aCk7XG4gICAgICAgIGRlYnVnMTIoXCJjd2RcIiwgY3dkKTtcbiAgICAgICAgY29uc3QgdGhlZGF0YXNvdXJjZXMgPSBvcHRpb25zLmRhdGFzb3VyY2VzIHx8IHt9O1xuICAgICAgICBjb25zdCBpbnB1dERhdGFzb3VyY2VzID0gT2JqZWN0LmVudHJpZXModGhlZGF0YXNvdXJjZXMpLmZpbHRlcigoW18sIHNvdXJjZV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gc291cmNlICYmIHNvdXJjZS51cmw7XG4gICAgICAgIH0pLm1hcCgoW25hbWUsIHsgdXJsIH1dKSA9PiAoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdXJsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgZGF0YXNvdXJjZXMgPSBtZXJnZUJ5KFtdLCBpbnB1dERhdGFzb3VyY2VzLCAoc291cmNlKSA9PiBzb3VyY2UubmFtZSk7XG4gICAgICAgIGNvbnN0IGVuZ2luZUNvbmZpZyA9IGludGVybmFsLmVuZ2luZSB8fCB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JGb3JtYXQpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvckZvcm1hdCA9IG9wdGlvbnMuZXJyb3JGb3JtYXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JGb3JtYXQgPSBcIm1pbmltYWxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT19DT0xPUikge1xuICAgICAgICAgIHRoaXMuX2Vycm9yRm9ybWF0ID0gXCJjb2xvcmxlc3NcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lcnJvckZvcm1hdCA9IFwiY29sb3JsZXNzXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmFzZURtbWYgPSBuZXcgQmFzZURNTUZIZWxwZXIoY29uZmlnMi5kb2N1bWVudCk7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhUHJveHkpIHtcbiAgICAgICAgICBjb25zdCByYXdEbW1mID0gY29uZmlnMi5kb2N1bWVudDtcbiAgICAgICAgICB0aGlzLl9kbW1mID0gbmV3IERNTUZIZWxwZXIocmF3RG1tZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5naW5lQ29uZmlnID0ge1xuICAgICAgICAgIGN3ZCxcbiAgICAgICAgICBkaXJuYW1lOiBjb25maWcyLmRpcm5hbWUsXG4gICAgICAgICAgZW5hYmxlRGVidWdMb2dzOiB1c2VEZWJ1ZyxcbiAgICAgICAgICBhbGxvd1RyaWdnZXJQYW5pYzogZW5naW5lQ29uZmlnLmFsbG93VHJpZ2dlclBhbmljLFxuICAgICAgICAgIGRhdGFtb2RlbFBhdGg6IGltcG9ydF9wYXRoNS5kZWZhdWx0LmpvaW4oY29uZmlnMi5kaXJuYW1lLCAoX2UgPSBjb25maWcyLmZpbGVuYW1lKSAhPSBudWxsID8gX2UgOiBcInNjaGVtYS5wcmlzbWFcIiksXG4gICAgICAgICAgcHJpc21hUGF0aDogKF9mID0gZW5naW5lQ29uZmlnLmJpbmFyeVBhdGgpICE9IG51bGwgPyBfZiA6IHZvaWQgMCxcbiAgICAgICAgICBlbmdpbmVFbmRwb2ludDogZW5naW5lQ29uZmlnLmVuZHBvaW50LFxuICAgICAgICAgIGRhdGFzb3VyY2VzLFxuICAgICAgICAgIGdlbmVyYXRvcjogY29uZmlnMi5nZW5lcmF0b3IsXG4gICAgICAgICAgc2hvd0NvbG9yczogdGhpcy5fZXJyb3JGb3JtYXQgPT09IFwicHJldHR5XCIsXG4gICAgICAgICAgbG9nTGV2ZWw6IG9wdGlvbnMubG9nICYmIGdldExvZ0xldmVsKG9wdGlvbnMubG9nKSxcbiAgICAgICAgICBsb2dRdWVyaWVzOiBvcHRpb25zLmxvZyAmJiBCb29sZWFuKFxuICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9nID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5sb2cgPT09IFwicXVlcnlcIiA6IG9wdGlvbnMubG9nLmZpbmQoKG8pID0+IHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gbyA9PT0gXCJxdWVyeVwiIDogby5sZXZlbCA9PT0gXCJxdWVyeVwiKVxuICAgICAgICAgICksXG4gICAgICAgICAgZW52OiAoX2kgPSAoX2ggPSBsb2FkZWRFbnYgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlZEVudi5wYXJzZWQpICE9IG51bGwgPyBfaCA6IChfZyA9IGNvbmZpZzIuaW5qZWN0YWJsZUVkZ2VFbnYpID09IG51bGwgPyB2b2lkIDAgOiBfZy5wYXJzZWQpICE9IG51bGwgPyBfaSA6IHt9LFxuICAgICAgICAgIGZsYWdzOiBbXSxcbiAgICAgICAgICBjbGllbnRWZXJzaW9uOiBjb25maWcyLmNsaWVudFZlcnNpb24sXG4gICAgICAgICAgcHJldmlld0ZlYXR1cmVzOiB0aGlzLl9wcmV2aWV3RmVhdHVyZXMsXG4gICAgICAgICAgYWN0aXZlUHJvdmlkZXI6IGNvbmZpZzIuYWN0aXZlUHJvdmlkZXIsXG4gICAgICAgICAgaW5saW5lU2NoZW1hOiBjb25maWcyLmlubGluZVNjaGVtYSxcbiAgICAgICAgICBpbmxpbmVEYXRhc291cmNlczogY29uZmlnMi5pbmxpbmVEYXRhc291cmNlcyxcbiAgICAgICAgICBpbmxpbmVTY2hlbWFIYXNoOiBjb25maWcyLmlubGluZVNjaGVtYUhhc2gsXG4gICAgICAgICAgdHJhY2luZ0NvbmZpZzogdGhpcy5fdHJhY2luZ0NvbmZpZ1xuICAgICAgICB9O1xuICAgICAgICBkZWJ1ZzEyKFwiY2xpZW50VmVyc2lvblwiLCBjb25maWcyLmNsaWVudFZlcnNpb24pO1xuICAgICAgICBkZWJ1ZzEyKFwiY2xpZW50RW5naW5lVHlwZVwiLCB0aGlzLl9kYXRhUHJveHkgPyBcImRhdGFwcm94eVwiIDogdGhpcy5fY2xpZW50RW5naW5lVHlwZSk7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhUHJveHkpIHtcbiAgICAgICAgICBjb25zdCBydW50aW1lID0gdHJ1ZSA/IFwiTm9kZS5qc1wiIDogXCJlZGdlXCI7XG4gICAgICAgICAgZGVidWcxMihgdXNpbmcgRGF0YSBQcm94eSB3aXRoICR7cnVudGltZX0gcnVudGltZWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IHRoaXMuZ2V0RW5naW5lKCk7XG4gICAgICAgIHZvaWQgdGhpcy5fZ2V0QWN0aXZlUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5fZmV0Y2hlciA9IG5ldyBSZXF1ZXN0SGFuZGxlcih0aGlzLCB0aGlzLl9ob29rcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgICAgIGZvciAoY29uc3QgbG9nNCBvZiBvcHRpb25zLmxvZykge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSB0eXBlb2YgbG9nNCA9PT0gXCJzdHJpbmdcIiA/IGxvZzQgOiBsb2c0LmVtaXQgPT09IFwic3Rkb3V0XCIgPyBsb2c0LmxldmVsIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICAgICAgICB0aGlzLiRvbihsZXZlbCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hNDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfZXhwb3J0cy5sb2coYCR7KF9hNCA9IGxvZ2dlcl9leHBvcnRzLnRhZ3NbbGV2ZWxdKSAhPSBudWxsID8gX2E0IDogXCJcIn1gLCBldmVudC5tZXNzYWdlIHx8IGV2ZW50LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldHJpY3MgPSBuZXcgTWV0cmljc0NsaWVudCh0aGlzLl9lbmdpbmUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmNsaWVudFZlcnNpb24gPSB0aGlzLl9jbGllbnRWZXJzaW9uO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFwcGx5TW9kZWxzKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRcIjtcbiAgICB9XG4gICAgZ2V0RW5naW5lKCkge1xuICAgICAgaWYgKHRoaXMuX2RhdGFQcm94eSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFQcm94eUVuZ2luZSh0aGlzLl9lbmdpbmVDb25maWcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jbGllbnRFbmdpbmVUeXBlID09PSBcImxpYnJhcnlcIiAvKiBMaWJyYXJ5ICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGlicmFyeUVuZ2luZSh0aGlzLl9lbmdpbmVDb25maWcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jbGllbnRFbmdpbmVUeXBlID09PSBcImJpbmFyeVwiIC8qIEJpbmFyeSAqLykge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUVuZ2luZSh0aGlzLl9lbmdpbmVDb25maWcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcihcIkludmFsaWQgY2xpZW50IGVuZ2luZSB0eXBlLCBwbGVhc2UgdXNlIGBsaWJyYXJ5YCBvciBgYmluYXJ5YFwiKTtcbiAgICB9XG4gICAgJHVzZShhcmcwLCBhcmcxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlcy5xdWVyeS51c2UoYXJnMCk7XG4gICAgICB9IGVsc2UgaWYgKGFyZzAgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMucXVlcnkudXNlKGFyZzEpO1xuICAgICAgfSBlbHNlIGlmIChhcmcwID09PSBcImVuZ2luZVwiKSB7XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmVzLmVuZ2luZS51c2UoYXJnMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWlkZGxld2FyZSAke2FyZzB9YCk7XG4gICAgICB9XG4gICAgfVxuICAgICRvbihldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSBcImJlZm9yZUV4aXRcIikge1xuICAgICAgICB0aGlzLl9lbmdpbmUub24oXCJiZWZvcmVFeGl0XCIsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5vbihldmVudFR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYTMsIF9iMiwgX2MsIF9kO1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IGV2ZW50LmZpZWxkcztcbiAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh7XG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wLFxuICAgICAgICAgICAgICBxdWVyeTogKF9hMyA9IGZpZWxkcyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRzLnF1ZXJ5KSAhPSBudWxsID8gX2EzIDogZXZlbnQucXVlcnksXG4gICAgICAgICAgICAgIHBhcmFtczogKF9iMiA9IGZpZWxkcyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRzLnBhcmFtcykgIT0gbnVsbCA/IF9iMiA6IGV2ZW50LnBhcmFtcyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IChfYyA9IGZpZWxkcyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRzLmR1cmF0aW9uX21zKSAhPSBudWxsID8gX2MgOiBldmVudC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZmllbGRzID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZHMubWVzc2FnZSkgIT0gbnVsbCA/IF9kIDogZXZlbnQubWVzc2FnZSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgICRjb25uZWN0KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZ2luZS5zdGFydCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmNsaWVudFZlcnNpb24gPSB0aGlzLl9jbGllbnRWZXJzaW9uO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcnVuRGlzY29ubmVjdCgpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2VuZ2luZS5zdG9wKCk7XG4gICAgICBkZWxldGUgdGhpcy5fY29ubmVjdGlvblByb21pc2U7XG4gICAgICB0aGlzLl9lbmdpbmUgPSB0aGlzLmdldEVuZ2luZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX2Rpc2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgZGVsZXRlIHRoaXMuX2dldENvbmZpZ1Byb21pc2U7XG4gICAgfVxuICAgIGFzeW5jICRkaXNjb25uZWN0KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5naW5lLnN0b3AoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZS5jbGllbnRWZXJzaW9uID0gdGhpcy5fY2xpZW50VmVyc2lvbjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YVByb3h5KSB7XG4gICAgICAgICAgdGhpcy5fZG1tZiA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0QWN0aXZlUHJvdmlkZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maWdSZXN1bHQgPSBhd2FpdCB0aGlzLl9lbmdpbmUuZ2V0Q29uZmlnKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVByb3ZpZGVyID0gY29uZmlnUmVzdWx0LmRhdGFzb3VyY2VzWzBdLmFjdGl2ZVByb3ZpZGVyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH1cbiAgICAkZXhlY3V0ZVJhd0ludGVybmFsKHR4SWQsIGxvY2ssIHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICBsZXQgcXVlcnlTdHJpbmcgPSBcIlwiO1xuICAgICAgbGV0IHBhcmFtZXRlcnMgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5MjtcbiAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnModmFsdWVzIHx8IFtdKSxcbiAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjaGVja0FsdGVyKHF1ZXJ5U3RyaW5nLCB2YWx1ZXMsIFwicHJpc21hLiRleGVjdXRlUmF3VW5zYWZlKDxTUUw+LCBbLi4udmFsdWVzXSlcIik7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHlBcnJheShxdWVyeTIpKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWN0aXZlUHJvdmlkZXIpIHtcbiAgICAgICAgICBjYXNlIFwic3FsaXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm15c3FsXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5SW5zdGFuY2UgPSBuZXcgU3FsKHF1ZXJ5MiwgdmFsdWVzKTtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlJbnN0YW5jZS5zcWw7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnlJbnN0YW5jZS52YWx1ZXMpLFxuICAgICAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29ja3JvYWNoZGJcIjpcbiAgICAgICAgICBjYXNlIFwicG9zdGdyZXNxbFwiOiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeUluc3RhbmNlID0gbmV3IFNxbChxdWVyeTIsIHZhbHVlcyk7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5SW5zdGFuY2UudGV4dDtcbiAgICAgICAgICAgIGNoZWNrQWx0ZXIocXVlcnlTdHJpbmcsIHF1ZXJ5SW5zdGFuY2UudmFsdWVzLCBcInByaXNtYS4kZXhlY3V0ZVJhd2A8U1FMPmBcIik7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnlJbnN0YW5jZS52YWx1ZXMpLFxuICAgICAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3Fsc2VydmVyXCI6IHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gbXNzcWxQcmVwYXJlZFN0YXRlbWVudChxdWVyeTIpO1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzKHZhbHVlcyksXG4gICAgICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7dGhpcy5fYWN0aXZlUHJvdmlkZXJ9IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJGV4ZWN1dGVSYXdgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWN0aXZlUHJvdmlkZXIpIHtcbiAgICAgICAgICBjYXNlIFwic3FsaXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm15c3FsXCI6XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5Mi5zcWw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29ja3JvYWNoZGJcIjpcbiAgICAgICAgICBjYXNlIFwicG9zdGdyZXNxbFwiOlxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeTIudGV4dDtcbiAgICAgICAgICAgIGNoZWNrQWx0ZXIocXVlcnlTdHJpbmcsIHF1ZXJ5Mi52YWx1ZXMsIFwicHJpc21hLiRleGVjdXRlUmF3KHNxbGA8U1FMPmApXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNxbHNlcnZlclwiOlxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBtc3NxbFByZXBhcmVkU3RhdGVtZW50KHF1ZXJ5Mi5zdHJpbmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke3RoaXMuX2FjdGl2ZVByb3ZpZGVyfSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICRleGVjdXRlUmF3YCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnkyLnZhbHVlcyksXG4gICAgICAgICAgX19wcmlzbWFSYXdQYXJhbWF0ZXJzX186IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLnZhbHVlcykge1xuICAgICAgICBkZWJ1ZzEyKGBwcmlzbWEuJGV4ZWN1dGVSYXcoJHtxdWVyeVN0cmluZ30sICR7cGFyYW1ldGVycy52YWx1ZXN9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcxMihgcHJpc21hLiRleGVjdXRlUmF3KCR7cXVlcnlTdHJpbmd9KWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJncyA9IHsgcXVlcnk6IHF1ZXJ5U3RyaW5nLCBwYXJhbWV0ZXJzIH07XG4gICAgICBkZWJ1ZzEyKGBQcmlzbWEgQ2xpZW50IGNhbGw6YCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNsaWVudE1ldGhvZDogXCIkZXhlY3V0ZVJhd1wiLFxuICAgICAgICBkYXRhUGF0aDogW10sXG4gICAgICAgIGFjdGlvbjogXCJleGVjdXRlUmF3XCIsXG4gICAgICAgIGNhbGxzaXRlOiBnZXRDYWxsU2l0ZSh0aGlzLl9lcnJvckZvcm1hdCksXG4gICAgICAgIHJ1bkluVHJhbnNhY3Rpb246ICEhdHhJZCxcbiAgICAgICAgdHJhbnNhY3Rpb25JZDogdHhJZCxcbiAgICAgICAgbG9ja1xuICAgICAgfSk7XG4gICAgfVxuICAgICRleGVjdXRlUmF3KHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICBpZiAocXVlcnkyLnJhdyAhPT0gdm9pZCAwIHx8IHF1ZXJ5Mi5zcWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRleGVjdXRlUmF3SW50ZXJuYWwodHhJZCwgbG9jaywgcXVlcnkyLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IoYFxcYCRleGVjdXRlUmF3XFxgIGlzIGEgdGFnIGZ1bmN0aW9uLCBwbGVhc2UgdXNlIGl0IGxpa2UgdGhlIGZvbGxvd2luZzpcblxcYFxcYFxcYFxuY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRleGVjdXRlUmF3XFxgVVBEQVRFIFVzZXIgU0VUIGNvb2wgPSBcXCR7dHJ1ZX0gV0hFUkUgZW1haWwgPSBcXCR7J3VzZXJAZW1haWwuY29tJ307XFxgXG5cXGBcXGBcXGBcblxuT3IgcmVhZCBvdXIgZG9jcyBhdCBodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9jb25jZXB0cy9jb21wb25lbnRzL3ByaXNtYS1jbGllbnQvcmF3LWRhdGFiYXNlLWFjY2VzcyNleGVjdXRlcmF3XG5gKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkZXhlY3V0ZVJhd1Vuc2FmZShxdWVyeTIsIC4uLnZhbHVlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVByaXNtYVByb21pc2UoKHR4SWQsIGxvY2spID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGV4ZWN1dGVSYXdJbnRlcm5hbCh0eElkLCBsb2NrLCBxdWVyeTIsIC4uLnZhbHVlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJHJ1bkNvbW1hbmRSYXcoY29tbWFuZCkge1xuICAgICAgaWYgKGNvbmZpZzIuYWN0aXZlUHJvdmlkZXIgIT09IFwibW9uZ29kYlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgYFRoZSAke2NvbmZpZzIuYWN0aXZlUHJvdmlkZXJ9IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJHJ1bkNvbW1hbmRSYXcuIFVzZSB0aGUgbW9uZ29kYiBwcm92aWRlci5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh7XG4gICAgICAgICAgYXJnczogeyBjb21tYW5kIH0sXG4gICAgICAgICAgY2xpZW50TWV0aG9kOiBcIiRydW5Db21tYW5kUmF3XCIsXG4gICAgICAgICAgZGF0YVBhdGg6IFtdLFxuICAgICAgICAgIGFjdGlvbjogXCJydW5Db21tYW5kUmF3XCIsXG4gICAgICAgICAgY2FsbHNpdGU6IGdldENhbGxTaXRlKHRoaXMuX2Vycm9yRm9ybWF0KSxcbiAgICAgICAgICBydW5JblRyYW5zYWN0aW9uOiAhIXR4SWQsXG4gICAgICAgICAgdHJhbnNhY3Rpb25JZDogdHhJZCxcbiAgICAgICAgICBsb2NrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgICRxdWVyeVJhd0ludGVybmFsKHR4SWQsIGxvY2ssIHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICBsZXQgcXVlcnlTdHJpbmcgPSBcIlwiO1xuICAgICAgbGV0IHBhcmFtZXRlcnMgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5MjtcbiAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnModmFsdWVzIHx8IFtdKSxcbiAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5QXJyYXkocXVlcnkyKSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2FjdGl2ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgY2FzZSBcInNxbGl0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJteXNxbFwiOiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeUluc3RhbmNlID0gbmV3IFNxbChxdWVyeTIsIHZhbHVlcyk7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5SW5zdGFuY2Uuc3FsO1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzKHF1ZXJ5SW5zdGFuY2UudmFsdWVzKSxcbiAgICAgICAgICAgICAgX19wcmlzbWFSYXdQYXJhbWF0ZXJzX186IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvY2tyb2FjaGRiXCI6XG4gICAgICAgICAgY2FzZSBcInBvc3RncmVzcWxcIjoge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlJbnN0YW5jZSA9IG5ldyBTcWwocXVlcnkyLCB2YWx1ZXMpO1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeUluc3RhbmNlLnRleHQ7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnlJbnN0YW5jZS52YWx1ZXMpLFxuICAgICAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3Fsc2VydmVyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5SW5zdGFuY2UgPSBuZXcgU3FsKHF1ZXJ5MiwgdmFsdWVzKTtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gbXNzcWxQcmVwYXJlZFN0YXRlbWVudChxdWVyeUluc3RhbmNlLnN0cmluZ3MpO1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgdmFsdWVzOiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzKHF1ZXJ5SW5zdGFuY2UudmFsdWVzKSxcbiAgICAgICAgICAgICAgX19wcmlzbWFSYXdQYXJhbWF0ZXJzX186IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJHt0aGlzLl9hY3RpdmVQcm92aWRlcn0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAkcXVlcnlSYXdgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWN0aXZlUHJvdmlkZXIpIHtcbiAgICAgICAgICBjYXNlIFwic3FsaXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm15c3FsXCI6XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5Mi5zcWw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29ja3JvYWNoZGJcIjpcbiAgICAgICAgICBjYXNlIFwicG9zdGdyZXNxbFwiOlxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeTIudGV4dDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzcWxzZXJ2ZXJcIjpcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gbXNzcWxQcmVwYXJlZFN0YXRlbWVudChxdWVyeTIuc3RyaW5ncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke3RoaXMuX2FjdGl2ZVByb3ZpZGVyfSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICRxdWVyeVJhd2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyhxdWVyeTIudmFsdWVzKSxcbiAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtZXRlcnMudmFsdWVzKSB7XG4gICAgICAgIGRlYnVnMTIoYHByaXNtYS5xdWVyeVJhdygke3F1ZXJ5U3RyaW5nfSwgJHtwYXJhbWV0ZXJzLnZhbHVlc30pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZzEyKGBwcmlzbWEucXVlcnlSYXcoJHtxdWVyeVN0cmluZ30pYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0geyBxdWVyeTogcXVlcnlTdHJpbmcsIHBhcmFtZXRlcnMgfTtcbiAgICAgIGRlYnVnMTIoYFByaXNtYSBDbGllbnQgY2FsbDpgKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgY2xpZW50TWV0aG9kOiBcIiRxdWVyeVJhd1wiLFxuICAgICAgICBkYXRhUGF0aDogW10sXG4gICAgICAgIGFjdGlvbjogXCJxdWVyeVJhd1wiLFxuICAgICAgICBjYWxsc2l0ZTogZ2V0Q2FsbFNpdGUodGhpcy5fZXJyb3JGb3JtYXQpLFxuICAgICAgICBydW5JblRyYW5zYWN0aW9uOiAhIXR4SWQsXG4gICAgICAgIHRyYW5zYWN0aW9uSWQ6IHR4SWQsXG4gICAgICAgIGxvY2tcbiAgICAgIH0pLnRoZW4oZGVzZXJpYWxpemVSYXdSZXN1bHRzKTtcbiAgICB9XG4gICAgJHF1ZXJ5UmF3KHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICBpZiAocXVlcnkyLnJhdyAhPT0gdm9pZCAwIHx8IHF1ZXJ5Mi5zcWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRxdWVyeVJhd0ludGVybmFsKHR4SWQsIGxvY2ssIHF1ZXJ5MiwgLi4udmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKGBcXGAkcXVlcnlSYXdcXGAgaXMgYSB0YWcgZnVuY3Rpb24sIHBsZWFzZSB1c2UgaXQgbGlrZSB0aGUgZm9sbG93aW5nOlxuXFxgXFxgXFxgXG5jb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJHF1ZXJ5UmF3XFxgU0VMRUNUICogRlJPTSBVc2VyIFdIRVJFIGlkID0gXFwkezF9IE9SIGVtYWlsID0gXFwkeyd1c2VyQGVtYWlsLmNvbSd9O1xcYFxuXFxgXFxgXFxgXG5cbk9yIHJlYWQgb3VyIGRvY3MgYXQgaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvY29uY2VwdHMvY29tcG9uZW50cy9wcmlzbWEtY2xpZW50L3Jhdy1kYXRhYmFzZS1hY2Nlc3MjcXVlcnlyYXdcbmApO1xuICAgICAgfSk7XG4gICAgfVxuICAgICRxdWVyeVJhd1Vuc2FmZShxdWVyeTIsIC4uLnZhbHVlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVByaXNtYVByb21pc2UoKHR4SWQsIGxvY2spID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHF1ZXJ5UmF3SW50ZXJuYWwodHhJZCwgbG9jaywgcXVlcnkyLCAuLi52YWx1ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9faW50ZXJuYWxfdHJpZ2dlclBhbmljKGZhdGFsKSB7XG4gICAgICBpZiAoIXRoaXMuX2VuZ2luZUNvbmZpZy5hbGxvd1RyaWdnZXJQYW5pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIG9yZGVyIHRvIHVzZSAuX19pbnRlcm5hbF90cmlnZ2VyUGFuaWMoKSwgcGxlYXNlIGVuYWJsZSBpdCBsaWtlIHNvOlxubmV3IFByaXNtYUNsaWVudCh7XG4gIF9faW50ZXJuYWw6IHtcbiAgICBlbmdpbmU6IHtcbiAgICAgIGFsbG93VHJpZ2dlclBhbmljOiB0cnVlXG4gICAgfVxuICB9XG59KWApO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVycyA9IGZhdGFsID8geyBcIlgtREVCVUctRkFUQUxcIjogXCIxXCIgfSA6IHsgXCJYLURFQlVHLU5PTi1GQVRBTFwiOiBcIjFcIiB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Qoe1xuICAgICAgICBhY3Rpb246IFwicXVlcnlSYXdcIixcbiAgICAgICAgYXJnczoge1xuICAgICAgICAgIHF1ZXJ5OiBcIlNFTEVDVCAxXCIsXG4gICAgICAgICAgcGFyYW1ldGVyczogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGNsaWVudE1ldGhvZDogXCJxdWVyeVJhd1wiLFxuICAgICAgICBkYXRhUGF0aDogW10sXG4gICAgICAgIHJ1bkluVHJhbnNhY3Rpb246IGZhbHNlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBjYWxsc2l0ZTogZ2V0Q2FsbFNpdGUodGhpcy5fZXJyb3JGb3JtYXQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgX3RyYW5zYWN0aW9uV2l0aEFycmF5KHByb21pc2VzKSB7XG4gICAgICBjb25zdCB0eElkID0gdGhpcy5fdHJhbnNhY3Rpb25JZCsrO1xuICAgICAgY29uc3QgbG9jayA9IGdldExvY2tDb3VudFByb21pc2UocHJvbWlzZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gcHJvbWlzZXMubWFwKChyZXF1ZXN0MikgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBpZiAoKHJlcXVlc3QyID09IG51bGwgPyB2b2lkIDAgOiByZXF1ZXN0MltTeW1ib2wudG9TdHJpbmdUYWddKSAhPT0gXCJQcmlzbWFQcm9taXNlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBuZWVkIHRvIGJlIFByaXNtYSBDbGllbnQgcHJvbWlzZXMuIEhpbnQ6IFBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBub3QgYXdhaXRpbmcgdGhlIFByaXNtYSBjbGllbnQgY2FsbHMgeW91IGludGVuZGVkIHRvIHBhc3MgaW4gdGhlICR0cmFuc2FjdGlvbiBmdW5jdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hMyA9IHJlcXVlc3QyLnJlcXVlc3RUcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHJlcXVlc3QyLCB0eElkLCBsb2NrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICB9XG4gICAgYXN5bmMgX3RyYW5zYWN0aW9uV2l0aENhbGxiYWNrKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgIH0pIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IHRyYWNlcGFyZW50OiBnZXRUcmFjZVBhcmVudCh7IHRyYWNpbmdDb25maWc6IHRoaXMuX3RyYWNpbmdDb25maWcgfSkgfTtcbiAgICAgIGNvbnN0IGluZm8yID0gYXdhaXQgdGhpcy5fZW5naW5lLnRyYW5zYWN0aW9uKFwic3RhcnRcIiwgaGVhZGVycywgb3B0aW9ucyk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2sodHJhbnNhY3Rpb25Qcm94eSh0aGlzLCBpbmZvMi5pZCkpO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmdpbmUudHJhbnNhY3Rpb24oXCJjb21taXRcIiwgaGVhZGVycywgaW5mbzIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmdpbmUudHJhbnNhY3Rpb24oXCJyb2xsYmFja1wiLCBoZWFkZXJzLCBpbmZvMikuY2F0Y2goKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgZS5jbGllbnRWZXJzaW9uID0gdGhpcy5fY2xpZW50VmVyc2lvbjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICR0cmFuc2FjdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJmdW5jdGlvblwiICYmIHRoaXMuX2hhc1ByZXZpZXdGbGFnKFwiaW50ZXJhY3RpdmVUcmFuc2FjdGlvbnNcIikpIHtcbiAgICAgICAgY2FsbGJhY2sgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHRoaXMuX3RyYW5zYWN0aW9uV2l0aENhbGxiYWNrKHsgY2FsbGJhY2s6IGlucHV0LCBvcHRpb25zIH0pLCBcImNhbGxiYWNrXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHRoaXMuX3RyYW5zYWN0aW9uV2l0aEFycmF5KGlucHV0KSwgXCJjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICBuYW1lOiBcInRyYW5zYWN0aW9uXCIsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuX3RyYWNpbmdDb25maWcuZW5hYmxlZCxcbiAgICAgICAgYXR0cmlidXRlczogeyBtZXRob2Q6IFwiJHRyYW5zYWN0aW9uXCIgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBydW5JbkNoaWxkU3BhbihzcGFuT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBfcmVxdWVzdChpbnRlcm5hbFBhcmFtcykge1xuICAgICAgaW50ZXJuYWxQYXJhbXMub3RlbFBhcmVudEN0eCA9IGNvbnRleHQyLmFjdGl2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIGFyZ3M6IGludGVybmFsUGFyYW1zLmFyZ3MsXG4gICAgICAgICAgZGF0YVBhdGg6IGludGVybmFsUGFyYW1zLmRhdGFQYXRoLFxuICAgICAgICAgIHJ1bkluVHJhbnNhY3Rpb246IGludGVybmFsUGFyYW1zLnJ1bkluVHJhbnNhY3Rpb24sXG4gICAgICAgICAgYWN0aW9uOiBpbnRlcm5hbFBhcmFtcy5hY3Rpb24sXG4gICAgICAgICAgbW9kZWw6IGludGVybmFsUGFyYW1zLm1vZGVsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICAgIG1pZGRsZXdhcmU6IHtcbiAgICAgICAgICAgIG5hbWU6IFwibWlkZGxld2FyZVwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5fdHJhY2luZ0NvbmZpZy5taWRkbGV3YXJlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogeyBtZXRob2Q6IFwiJHVzZVwiIH0sXG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BlcmF0aW9uXCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0aGlzLl90cmFjaW5nQ29uZmlnLmVuYWJsZWQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIG1ldGhvZDogcGFyYW1zLmFjdGlvbixcbiAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgbmFtZTogYCR7cGFyYW1zLm1vZGVsfS4ke3BhcmFtcy5hY3Rpb259YFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY2hhbmdlZFBhcmFtcykgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRNaWRkbGV3YXJlID0gdGhpcy5fbWlkZGxld2FyZXMucXVlcnkuZ2V0KCsraW5kZXgpO1xuICAgICAgICAgIGlmIChuZXh0TWlkZGxld2FyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bkluQ2hpbGRTcGFuKHNwYW5PcHRpb25zLm1pZGRsZXdhcmUsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0TWlkZGxld2FyZShjaGFuZ2VkUGFyYW1zLCAocCkgPT4gKHNwYW4gPT0gbnVsbCA/IHZvaWQgMCA6IHNwYW4uZW5kKCksIGNvbnN1bWVyKHApKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVSZXF1ZXN0KHsgLi4uaW50ZXJuYWxQYXJhbXMsIC4uLmNoYW5nZWRQYXJhbXMgfSk7XG4gICAgICAgIH0sIFwiY29uc3VtZXJcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5JbkNoaWxkU3BhbihzcGFuT3B0aW9ucy5vcGVyYXRpb24sICgpID0+IHtcbiAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNSZXMgPSBuZXcgaW1wb3J0X2FzeW5jX2hvb2tzLkFzeW5jUmVzb3VyY2UoXCJwcmlzbWEtY2xpZW50LXJlcXVlc3RcIik7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNSZXMucnVuSW5Bc3luY1Njb3BlKCgpID0+IGNvbnN1bWVyKHBhcmFtcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uc3VtZXIocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuY2xpZW50VmVyc2lvbiA9IHRoaXMuX2NsaWVudFZlcnNpb247XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9leGVjdXRlUmVxdWVzdCh7XG4gICAgICBhcmdzLFxuICAgICAgY2xpZW50TWV0aG9kLFxuICAgICAganNNb2RlbE5hbWUsXG4gICAgICBkYXRhUGF0aCxcbiAgICAgIGNhbGxzaXRlLFxuICAgICAgcnVuSW5UcmFuc2FjdGlvbixcbiAgICAgIGFjdGlvbixcbiAgICAgIG1vZGVsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgICBsb2NrLFxuICAgICAgdW5wYWNrZXIsXG4gICAgICBvdGVsUGFyZW50Q3R4XG4gICAgfSkge1xuICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgaWYgKHRoaXMuX2RtbWYgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9kbW1mID0gYXdhaXQgdGhpcy5fZ2V0RG1tZih7IGNsaWVudE1ldGhvZCwgY2FsbHNpdGUgfSk7XG4gICAgICB9XG4gICAgICBsZXQgcm9vdEZpZWxkO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYWN0aW9uT3BlcmF0aW9uTWFwW2FjdGlvbl07XG4gICAgICBpZiAoYWN0aW9uID09PSBcImV4ZWN1dGVSYXdcIiB8fCBhY3Rpb24gPT09IFwicXVlcnlSYXdcIiB8fCBhY3Rpb24gPT09IFwicnVuQ29tbWFuZFJhd1wiKSB7XG4gICAgICAgIHJvb3RGaWVsZCA9IGFjdGlvbjtcbiAgICAgIH1cbiAgICAgIGxldCBtYXBwaW5nO1xuICAgICAgaWYgKG1vZGVsICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWFwcGluZyA9IChfYTMgPSB0aGlzLl9kbW1mKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1hcHBpbmdzTWFwW21vZGVsXTtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbWFwcGluZyBmb3IgbW9kZWwgJHttb2RlbH1gKTtcbiAgICAgICAgfVxuICAgICAgICByb290RmllbGQgPSBtYXBwaW5nW2FjdGlvbiA9PT0gXCJjb3VudFwiID8gXCJhZ2dyZWdhdGVcIiA6IGFjdGlvbl07XG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0aW9uICE9PSBcInF1ZXJ5XCIgJiYgb3BlcmF0aW9uICE9PSBcIm11dGF0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wZXJhdGlvbiAke29wZXJhdGlvbn0gZm9yIGFjdGlvbiAke2FjdGlvbn1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpZWxkID0gKF9iMiA9IHRoaXMuX2RtbWYpID09IG51bGwgPyB2b2lkIDAgOiBfYjIucm9vdEZpZWxkTWFwW3Jvb3RGaWVsZF07XG4gICAgICBpZiAoZmllbGQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIHJvb3RGaWVsZCAke3Jvb3RGaWVsZH0gZm9yIGFjdGlvbiAke2FjdGlvbn0gZm9yIG1vZGVsICR7bW9kZWx9IG9uIHJvb3RUeXBlICR7b3BlcmF0aW9ufWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaXNMaXN0IH0gPSBmaWVsZC5vdXRwdXRUeXBlO1xuICAgICAgY29uc3QgdHlwZU5hbWUgPSBnZXRPdXRwdXRUeXBlTmFtZShmaWVsZC5vdXRwdXRUeXBlLnR5cGUpO1xuICAgICAgY29uc3QgcmVqZWN0T25Ob3RGb3VuZCA9IGdldFJlamVjdE9uTm90Rm91bmQoYWN0aW9uLCB0eXBlTmFtZSwgYXJncywgdGhpcy5fcmVqZWN0T25Ob3RGb3VuZCk7XG4gICAgICB3YXJuQWJvdXRSZWplY3RPbk5vdEZvdW5kKHJlamVjdE9uTm90Rm91bmQsIGpzTW9kZWxOYW1lLCBhY3Rpb24pO1xuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbkZuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50MyA9IG1ha2VEb2N1bWVudCh7XG4gICAgICAgICAgZG1tZjogdGhpcy5fZG1tZixcbiAgICAgICAgICByb290RmllbGQsXG4gICAgICAgICAgcm9vdFR5cGVOYW1lOiBvcGVyYXRpb24sXG4gICAgICAgICAgc2VsZWN0OiBhcmdzLFxuICAgICAgICAgIG1vZGVsTmFtZTogbW9kZWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50My52YWxpZGF0ZShhcmdzLCBmYWxzZSwgY2xpZW50TWV0aG9kLCB0aGlzLl9lcnJvckZvcm1hdCwgY2FsbHNpdGUpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQzKTtcbiAgICAgIH0sIFwic2VyaWFsaXphdGlvbkZuXCIpO1xuICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IFwic2VyaWFsaXplXCIsXG4gICAgICAgIGVuYWJsZWQ6IHRoaXMuX3RyYWNpbmdDb25maWcuZW5hYmxlZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRvY3VtZW50MiA9IGF3YWl0IHJ1bkluQ2hpbGRTcGFuKHNwYW5PcHRpb25zLCBzZXJpYWxpemF0aW9uRm4pO1xuICAgICAgaWYgKHNyY19kZWZhdWx0LmVuYWJsZWQoXCJwcmlzbWE6Y2xpZW50XCIpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5MiA9IFN0cmluZyhkb2N1bWVudDIpO1xuICAgICAgICBkZWJ1ZzEyKGBQcmlzbWEgQ2xpZW50IGNhbGw6YCk7XG4gICAgICAgIGRlYnVnMTIoXG4gICAgICAgICAgYHByaXNtYS4ke2NsaWVudE1ldGhvZH0oJHtwcmludEpzb25XaXRoRXJyb3JzKHtcbiAgICAgICAgICAgIGFzdDogYXJncyxcbiAgICAgICAgICAgIGtleVBhdGhzOiBbXSxcbiAgICAgICAgICAgIHZhbHVlUGF0aHM6IFtdLFxuICAgICAgICAgICAgbWlzc2luZ0l0ZW1zOiBbXVxuICAgICAgICAgIH0pfSlgXG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnMTIoYEdlbmVyYXRlZCByZXF1ZXN0OmApO1xuICAgICAgICBkZWJ1ZzEyKHF1ZXJ5MiArIFwiXFxuXCIpO1xuICAgICAgfVxuICAgICAgYXdhaXQgbG9jaztcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaGVyLnJlcXVlc3Qoe1xuICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgICAgICBjbGllbnRNZXRob2QsXG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICBkYXRhUGF0aCxcbiAgICAgICAgcmVqZWN0T25Ob3RGb3VuZCxcbiAgICAgICAgaXNMaXN0LFxuICAgICAgICByb290RmllbGQsXG4gICAgICAgIGNhbGxzaXRlLFxuICAgICAgICBhcmdzLFxuICAgICAgICBlbmdpbmVIb29rOiB0aGlzLl9taWRkbGV3YXJlcy5lbmdpbmUuZ2V0KDApLFxuICAgICAgICBydW5JblRyYW5zYWN0aW9uLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICB0cmFuc2FjdGlvbklkLFxuICAgICAgICB1bnBhY2tlcixcbiAgICAgICAgb3RlbFBhcmVudEN0eCxcbiAgICAgICAgb3RlbENoaWxkQ3R4OiBjb250ZXh0Mi5hY3RpdmUoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGdldCAkbWV0cmljcygpIHtcbiAgICAgIGlmICghdGhpcy5faGFzUHJldmlld0ZsYWcoXCJtZXRyaWNzXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgXCJgbWV0cmljc2AgcHJldmlldyBmZWF0dXJlIG11c3QgYmUgZW5hYmxlZCBpbiBvcmRlciB0byBhY2Nlc3MgbWV0cmljcyBBUElcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX21ldHJpY3M7XG4gICAgfVxuICAgIF9oYXNQcmV2aWV3RmxhZyhmZWF0dXJlKSB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuICEhKChfYTMgPSB0aGlzLl9lbmdpbmVDb25maWcucHJldmlld0ZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmluY2x1ZGVzKGZlYXR1cmUpKTtcbiAgICB9XG4gIH1cbiAgX19uYW1lKFByaXNtYUNsaWVudCwgXCJQcmlzbWFDbGllbnRcIik7XG4gIHJldHVybiBQcmlzbWFDbGllbnQ7XG59XG5fX25hbWUoZ2V0UHJpc21hQ2xpZW50LCBcImdldFByaXNtYUNsaWVudFwiKTtcbnZhciBmb3JiaWRkZW4gPSBbXCIkY29ubmVjdFwiLCBcIiRkaXNjb25uZWN0XCIsIFwiJG9uXCIsIFwiJHRyYW5zYWN0aW9uXCIsIFwiJHVzZVwiXTtcbmZ1bmN0aW9uIHRyYW5zYWN0aW9uUHJveHkodGhpbmcsIHR4SWQpIHtcbiAgaWYgKHR5cGVvZiB0aGluZyAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gdGhpbmc7XG4gIHJldHVybiBuZXcgUHJveHkodGhpbmcsIHtcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgIGlmIChmb3JiaWRkZW4uaW5jbHVkZXMocHJvcCkpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBpZiAocHJvcCA9PT0gVFhfSUQpXG4gICAgICAgIHJldHVybiB0eElkO1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBpZiAocHJvcCA9PT0gXCJ0aGVuXCIpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdKGFyZ3NbMF0sIGFyZ3NbMV0sIHR4SWQpO1xuICAgICAgICAgIGlmIChwcm9wID09PSBcImNhdGNoXCIpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdKGFyZ3NbMF0sIHR4SWQpO1xuICAgICAgICAgIGlmIChwcm9wID09PSBcImZpbmFsbHlcIilcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF0oYXJnc1swXSwgdHhJZCk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uUHJveHkodGFyZ2V0W3Byb3BdKC4uLmFyZ3MpLCB0eElkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblByb3h5KHRhcmdldFtwcm9wXSwgdHhJZCk7XG4gICAgfVxuICB9KTtcbn1cbl9fbmFtZSh0cmFuc2FjdGlvblByb3h5LCBcInRyYW5zYWN0aW9uUHJveHlcIik7XG52YXIgcmVqZWN0T25Ob3RGb3VuZFJlcGxhY2VtZW50cyA9IHtcbiAgZmluZFVuaXF1ZTogXCJmaW5kVW5pcXVlT3JUaHJvd1wiLFxuICBmaW5kRmlyc3Q6IFwiZmluZEZpcnN0T3JUaHJvd1wiXG59O1xuZnVuY3Rpb24gd2FybkFib3V0UmVqZWN0T25Ob3RGb3VuZChyZWplY3RPbk5vdEZvdW5kLCBtb2RlbCwgYWN0aW9uKSB7XG4gIGlmIChyZWplY3RPbk5vdEZvdW5kKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRBY3Rpb24gPSByZWplY3RPbk5vdEZvdW5kUmVwbGFjZW1lbnRzW2FjdGlvbl07XG4gICAgY29uc3QgcmVwbGFjZW1lbnRDYWxsID0gbW9kZWwgPyBgcHJpc21hLiR7bW9kZWx9LiR7cmVwbGFjZW1lbnRBY3Rpb259YCA6IGBwcmlzbWEuJHtyZXBsYWNlbWVudEFjdGlvbn1gO1xuICAgIGNvbnN0IGtleSA9IGByZWplY3RPbk5vdEZvdW5kLiR7bW9kZWwgIT0gbnVsbCA/IG1vZGVsIDogXCJcIn0uJHthY3Rpb259YDtcbiAgICB3YXJuT25jZShcbiAgICAgIGtleSxcbiAgICAgIGBcXGByZWplY3RPbk5vdEZvdW5kXFxgIG9wdGlvbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUHJpc21hIDUuIFBsZWFzZSB1c2UgXFxgJHtyZXBsYWNlbWVudENhbGx9XFxgIG1ldGhvZCBpbnN0ZWFkYFxuICAgICk7XG4gIH1cbn1cbl9fbmFtZSh3YXJuQWJvdXRSZWplY3RPbk5vdEZvdW5kLCBcIndhcm5BYm91dFJlamVjdE9uTm90Rm91bmRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3N0cmljdEVudW0udHNcbnZhciBhbGxvd0xpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwidG9KU09OXCIsXG4gIFwiYXN5bW1ldHJpY01hdGNoXCIsXG4gIFN5bWJvbC5pdGVyYXRvcixcbiAgU3ltYm9sLnRvU3RyaW5nVGFnLFxuICBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlLFxuICBTeW1ib2wudG9QcmltaXRpdmVcbl0pO1xuZnVuY3Rpb24gbWFrZVN0cmljdEVudW0oZGVmaW5pdGlvbikge1xuICByZXR1cm4gbmV3IFByb3h5KGRlZmluaXRpb24sIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgaWYgKHByb3BlcnR5IGluIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd0xpc3QuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbnVtIHZhbHVlOiAke1N0cmluZyhwcm9wZXJ0eSl9YCk7XG4gICAgfVxuICB9KTtcbn1cbl9fbmFtZShtYWtlU3RyaWN0RW51bSwgXCJtYWtlU3RyaWN0RW51bVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvZmluZC50c1xudmFyIGltcG9ydF9mczEwID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xudmFyIGltcG9ydF9wYXRoNiA9IF9fdG9FU00ocmVxdWlyZShcInBhdGhcIikpO1xudmFyIGltcG9ydF91dGlsNyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIHJlYWRkaXJBc3luYyA9ICgwLCBpbXBvcnRfdXRpbDcucHJvbWlzaWZ5KShpbXBvcnRfZnMxMC5kZWZhdWx0LnJlYWRkaXIpO1xudmFyIHJlYWxwYXRoQXN5bmMgPSAoMCwgaW1wb3J0X3V0aWw3LnByb21pc2lmeSkoaW1wb3J0X2ZzMTAuZGVmYXVsdC5yZWFscGF0aCk7XG52YXIgc3RhdEFzeW5jID0gKDAsIGltcG9ydF91dGlsNy5wcm9taXNpZnkpKGltcG9ydF9mczEwLmRlZmF1bHQuc3RhdCk7XG52YXIgcmVhZGRpclN5bmMgPSBpbXBvcnRfZnMxMC5kZWZhdWx0LnJlYWRkaXJTeW5jO1xudmFyIHJlYWxwYXRoU3luYyA9IGltcG9ydF9mczEwLmRlZmF1bHQucmVhbHBhdGhTeW5jO1xudmFyIHN0YXRTeW5jID0gaW1wb3J0X2ZzMTAuZGVmYXVsdC5zdGF0U3luYztcbmZ1bmN0aW9uIGRpcmVudFRvVHlwZShkaXJlbnQpIHtcbiAgcmV0dXJuIGRpcmVudC5pc0ZpbGUoKSA/IFwiZlwiIDogZGlyZW50LmlzRGlyZWN0b3J5KCkgPyBcImRcIiA6IGRpcmVudC5pc1N5bWJvbGljTGluaygpID8gXCJsXCIgOiB2b2lkIDA7XG59XG5fX25hbWUoZGlyZW50VG9UeXBlLCBcImRpcmVudFRvVHlwZVwiKTtcbmZ1bmN0aW9uIGlzTWF0Y2hlZChzdHJpbmcsIHJlZ2V4cykge1xuICBmb3IgKGNvbnN0IHJlZ2V4IG9mIHJlZ2V4cykge1xuICAgIGlmICh0eXBlb2YgcmVnZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChzdHJpbmcuaW5jbHVkZXMocmVnZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnZXguZXhlYyhzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuX19uYW1lKGlzTWF0Y2hlZCwgXCJpc01hdGNoZWRcIik7XG5mdW5jdGlvbiBmaW5kU3luYyhyb290LCBtYXRjaCwgdHlwZXMgPSBbXCJmXCIsIFwiZFwiLCBcImxcIl0sIGRlZXAgPSBbXSwgbGltaXQgPSBJbmZpbml0eSwgaGFuZGxlciA9ICgpID0+IHRydWUsIGZvdW5kID0gW10sIHNlZW4gPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlYWxSb290ID0gcmVhbHBhdGhTeW5jKHJvb3QpO1xuICAgIGlmIChzZWVuW3JlYWxSb290XSkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAobGltaXQgLSBmb3VuZC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAoZGlyZW50VG9UeXBlKHN0YXRTeW5jKHJlYWxSb290KSkgIT09IFwiZFwiKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gcmVhZGRpclN5bmMocm9vdCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgIHNlZW5bcmVhbFJvb3RdID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IGl0ZW1OYW1lID0gaXRlbS5uYW1lO1xuICAgICAgY29uc3QgaXRlbVR5cGUgPSBkaXJlbnRUb1R5cGUoaXRlbSk7XG4gICAgICBjb25zdCBpdGVtUGF0aCA9IGltcG9ydF9wYXRoNi5kZWZhdWx0LmpvaW4ocm9vdCwgaXRlbS5uYW1lKTtcbiAgICAgIGlmIChpdGVtVHlwZSAmJiB0eXBlcy5pbmNsdWRlcyhpdGVtVHlwZSkpIHtcbiAgICAgICAgaWYgKGlzTWF0Y2hlZChpdGVtUGF0aCwgbWF0Y2gpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBoYW5kbGVyKHJvb3QsIGl0ZW1OYW1lLCBpdGVtVHlwZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZm91bmQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChpdGVtUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVlcC5pbmNsdWRlcyhpdGVtVHlwZSkpIHtcbiAgICAgICAgZmluZFN5bmMoaXRlbVBhdGgsIG1hdGNoLCB0eXBlcywgZGVlcCwgbGltaXQsIGhhbmRsZXIsIGZvdW5kLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5fX25hbWUoZmluZFN5bmMsIFwiZmluZFN5bmNcIik7XG5cbi8vIHNyYy9ydW50aW1lL3dhcm5FbnZDb25mbGljdHMudHNcbmZ1bmN0aW9uIHdhcm5FbnZDb25mbGljdHMoZW52UGF0aHMpIHtcbiAgdHJ5TG9hZEVudnMoZW52UGF0aHMsIHsgY29uZmxpY3RDaGVjazogXCJ3YXJuXCIgfSk7XG59XG5fX25hbWUod2FybkVudkNvbmZsaWN0cywgXCJ3YXJuRW52Q29uZmxpY3RzXCIpO1xuXG4vLyBzcmMvcnVudGltZS9pbmRleC50c1xudmFyIGRlY29tcHJlc3NGcm9tQmFzZTY0MiA9IGx6U3RyaW5nLmRlY29tcHJlc3NGcm9tQmFzZTY0O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIERNTUYsXG4gIERNTUZDbGFzcyxcbiAgRGVidWcsXG4gIERlY2ltYWwsXG4gIEVuZ2luZSxcbiAgTWV0cmljc0NsaWVudCxcbiAgTm90Rm91bmRFcnJvcixcbiAgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcixcbiAgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLFxuICBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IsXG4gIFNxbCxcbiAgZGVjb21wcmVzc0Zyb21CYXNlNjQsXG4gIGVtcHR5LFxuICBmaW5kU3luYyxcbiAgZ2V0UHJpc21hQ2xpZW50LFxuICBqb2luLFxuICBtYWtlRG9jdW1lbnQsXG4gIG1ha2VTdHJpY3RFbnVtLFxuICBvYmplY3RFbnVtVmFsdWVzLFxuICByYXcsXG4gIHNxbHRhZyxcbiAgdHJhbnNmb3JtRG9jdW1lbnQsXG4gIHVucGFjayxcbiAgd2FybkVudkNvbmZsaWN0c1xufSk7XG4vKiFcbiAqICBkZWNpbWFsLmpzIHYxMC40LjBcbiAqICBBbiBhcmJpdHJhcnktcHJlY2lzaW9uIERlY2ltYWwgdHlwZSBmb3IgSmF2YVNjcmlwdC5cbiAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9kZWNpbWFsLmpzXG4gKiAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XG4gKiAgTUlUIExpY2VuY2VcbiAqL1xuLyohXG4gKiBAZGVzY3JpcHRpb24gUmVjdXJzaXZlIG9iamVjdCBleHRlbmRpbmdcbiAqIEBhdXRob3IgVmlhY2hlc2xhdiBMb3RzbWFub3YgPGxvdHNtYW5vdjg5QGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE4IFZpYWNoZXNsYXYgTG90c21hbm92XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2ZcbiAqIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SXG4gKiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVJcbiAqIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG4vKiEgZm9ybWRhdGEtcG9seWZpbGwuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/runtime/index.js\n");

/***/ }),

/***/ "./async-pages/itemcatalogue.js":
/*!**************************************!*\
  !*** ./async-pages/itemcatalogue.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"getStaticProps\": () => (/* binding */ getStaticProps)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/shared/lib/styled-jsx */ \"./node_modules/next/dist/shared/lib/styled-jsx.js\");\n/* harmony import */ var next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"webpack/sharing/consume/default/next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prisma/client */ \"./node_modules/@prisma/client/index.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst ItemCatalogue = (props)=>{\n    console.log(props);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            border: \"10px solid green\"\n        },\n        className: \"jsx-71951eac013e1c14\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"Item Catalogue\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                        lineNumber: 9,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\",\n                        className: \"jsx-71951eac013e1c14\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                        lineNumber: 10,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                lineNumber: 8,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-71951eac013e1c14\" + \" \" + \"hero\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"Item Catalogue\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                        lineNumber: 14,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"This is a federated page owned by localhost:3000 Item Catalogue\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                        lineNumber: 16,\n                        columnNumber: 7\n                    }, undefined),\n                    \"Data from federated getStaticProps\",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: JSON.stringify(props, null, 2)\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                        lineNumber: 20,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n                lineNumber: 13,\n                columnNumber: 5\n            }, undefined),\n            (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"71951eac013e1c14\",\n                children: \".hero.jsx-71951eac013e1c14{width:100%;color:#333}.title.jsx-71951eac013e1c14{margin:0;width:100%;padding-top:80px;line-height:1.15;font-size:20px}.title.jsx-71951eac013e1c14,.description.jsx-71951eac013e1c14{text-align:center}\"\n            }, void 0, false, void 0, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/itemcatalogue/async-pages/itemcatalogue.js\",\n        lineNumber: 7,\n        columnNumber: 3\n    }, undefined);\n};\nconst getStaticProps = async ()=>{\n    const prisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_3__.PrismaClient();\n    const stores = await prisma.store.findMany();\n    return {\n        props: {\n            stores\n        },\n        revalidate: 10\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ItemCatalogue);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3luYy1wYWdlcy9pdGVtY2F0YWxvZ3VlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNkI7QUFDaUI7QUFFOUMsTUFBTUUsYUFBYSxHQUFHQyxDQUFBQSxLQUFLLEdBQUk7SUFDN0JDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDRixLQUFLLENBQUMsQ0FBQztJQUNuQixxQkFDQSw4REFBQ0csS0FBRztRQUFDQyxLQUFLLEVBQUU7WUFBQ0MsTUFBTSxFQUFFLGtCQUFrQjtTQUFDOzs7MEJBQ3RDLDhEQUFDUixrREFBSTs7a0NBQ0gsOERBQUNTLE9BQUs7O2tDQUFDLGdCQUFjOzs7OztpQ0FBUTtrQ0FDN0IsOERBQUNDLE1BQUk7d0JBQUNDLEdBQUcsRUFBQyxNQUFNO3dCQUFDQyxJQUFJLEVBQUMsY0FBYzs7Ozs7O2lDQUFHOzs7Ozs7eUJBQ2xDOzBCQUVQLDhEQUFDTixLQUFHOzBEQUFXLE1BQU07O2tDQUNuQiw4REFBQ08sSUFBRTs7a0NBQUMsZ0JBQWM7Ozs7O2lDQUFLO2tDQUV2Qiw4REFBQ0MsR0FBQzs7a0NBQUMsaUVBQStEOzs7OztpQ0FBSTtvQkFBQSxvQ0FJdEU7a0NBQUEsOERBQUNDLEtBQUc7O2tDQUFFQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ2QsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7Ozs7O2lDQUFPOzs7Ozs7eUJBQ3ZDOzs7Ozs7Ozs7O2lCQWtCRixDQUNQO0NBQUM7QUFHSyxNQUFNZSxjQUFjLEdBQUcsVUFBWTtJQUN4QyxNQUFNQyxNQUFNLEdBQUcsSUFBSWxCLHdEQUFZLEVBQUU7SUFFakMsTUFBTW1CLE1BQU0sR0FBRyxNQUFNRCxNQUFNLENBQUNFLEtBQUssQ0FBQ0MsUUFBUSxFQUFFO0lBRTVDLE9BQU87UUFDTG5CLEtBQUssRUFBRTtZQUFFaUIsTUFBTTtTQUFFO1FBQ2pCRyxVQUFVLEVBQUUsRUFBRTtLQUNmLENBQUM7Q0FDSCxDQUFDO0FBRUYsaUVBQWVyQixhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGVtY2F0YWxvZ3VlLy4vYXN5bmMtcGFnZXMvaXRlbWNhdGFsb2d1ZS5qcz9kZGNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5cbmNvbnN0IEl0ZW1DYXRhbG9ndWUgPSBwcm9wcyA9PiB7XG4gIGNvbnNvbGUubG9nKHByb3BzKTtcbiAgcmV0dXJuIChcbiAgPGRpdiBzdHlsZT17e2JvcmRlcjogJzEwcHggc29saWQgZ3JlZW4nfX0+XG4gICAgPEhlYWQ+XG4gICAgICA8dGl0bGU+SXRlbSBDYXRhbG9ndWU8L3RpdGxlPlxuICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvZmF2aWNvbi5pY29cIiAvPlxuICAgIDwvSGVhZD5cblxuICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVyb1wiPlxuICAgICAgPGgxPkl0ZW0gQ2F0YWxvZ3VlPC9oMT5cbiAgICAgIFxuICAgICAgPHA+VGhpcyBpcyBhIGZlZGVyYXRlZCBwYWdlIG93bmVkIGJ5IGxvY2FsaG9zdDozMDAwIEl0ZW0gQ2F0YWxvZ3VlPC9wPiBcblxuICAgICAgICBEYXRhIGZyb20gZmVkZXJhdGVkIGdldFN0YXRpY1Byb3BzXG5cbiAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KHByb3BzLCBudWxsLCAyKX08L3ByZT5cbiAgICA8L2Rpdj5cbiAgICA8c3R5bGUganN4PntgXG4gICAgICAuaGVybyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBjb2xvcjogIzMzMztcbiAgICAgIH1cbiAgICAgIC50aXRsZSB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHBhZGRpbmctdG9wOiA4MHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgfVxuICAgICAgLnRpdGxlLFxuICAgICAgLmRlc2NyaXB0aW9uIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgfVxuICAgIGB9PC9zdHlsZT5cbiAgPC9kaXY+XG4pfTtcblxuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHMgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHByaXNtYSA9IG5ldyBQcmlzbWFDbGllbnQoKTtcblxuICBjb25zdCBzdG9yZXMgPSBhd2FpdCBwcmlzbWEuc3RvcmUuZmluZE1hbnkoKTtcblxuICByZXR1cm4ge1xuICAgIHByb3BzOiB7IHN0b3JlcyB9LFxuICAgIHJldmFsaWRhdGU6IDEwLFxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSXRlbUNhdGFsb2d1ZTtcbiJdLCJuYW1lcyI6WyJIZWFkIiwiUHJpc21hQ2xpZW50IiwiSXRlbUNhdGFsb2d1ZSIsInByb3BzIiwiY29uc29sZSIsImxvZyIsImRpdiIsInN0eWxlIiwiYm9yZGVyIiwidGl0bGUiLCJsaW5rIiwicmVsIiwiaHJlZiIsImgxIiwicCIsInByZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRTdGF0aWNQcm9wcyIsInByaXNtYSIsInN0b3JlcyIsInN0b3JlIiwiZmluZE1hbnkiLCJyZXZhbGlkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./async-pages/itemcatalogue.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/styled-jsx.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/styled-jsx.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! styled-jsx/style */ \"./node_modules/styled-jsx/style.js\"); //# sourceMappingURL=styled-jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc3R5bGVkLWpzeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxrR0FBNEMsQ0FBQyxDQUU3QyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGVtY2F0YWxvZ3VlLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3N0eWxlZC1qc3guanM/NDg5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnc3R5bGVkLWpzeC9zdHlsZScpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQtanN4LmpzLm1hcCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/styled-jsx.js\n");

/***/ }),

/***/ "./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 583:\n/***/ (function(module) {\n\n\n\nfunction hash(str) {\n  var hash = 5381,\n      i    = str.length;\n\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nmodule.exports = hash;\n\n\n/***/ }),\n\n/***/ 590:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports.computeId = computeId;\nexports.computeSelector = computeSelector;\n\nvar _stringHash = _interopRequireDefault(__nccwpck_require__(583));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar sanitize = function sanitize(rule) {\n  return rule.replace(/\\/style/gi, '\\\\/style');\n};\n\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */\n\nfunction computeId(baseId, props) {\n  if (!props) {\n    return \"jsx-\" + baseId;\n  }\n\n  var propsToString = String(props);\n  var key = baseId + propsToString;\n\n  if (!cache[key]) {\n    cache[key] = \"jsx-\" + (0, _stringHash[\"default\"])(baseId + \"-\" + propsToString);\n  }\n\n  return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */\n\n\nfunction computeSelector(id, css) {\n  var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g; // Sanitize SSR-ed CSS.\n  // Client side code doesn't need to be sanitized since we use\n  // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n\n  if (typeof window === 'undefined') {\n    css = sanitize(css);\n  }\n\n  var idcss = id + css;\n\n  if (!cache[idcss]) {\n    cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n  }\n\n  return cache[idcss];\n}\n\n/***/ }),\n\n/***/ 503:\n/***/ (function(__unused_webpack_module, exports) {\n\n\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/\nvar isProd = typeof process !== 'undefined' && process.env && \"development\" === 'production';\n\nvar isString = function isString(o) {\n  return Object.prototype.toString.call(o) === '[object String]';\n};\n\nvar StyleSheet = /*#__PURE__*/function () {\n  function StyleSheet(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? 'stylesheet' : _ref$name,\n        _ref$optimizeForSpeed = _ref.optimizeForSpeed,\n        optimizeForSpeed = _ref$optimizeForSpeed === void 0 ? isProd : _ref$optimizeForSpeed,\n        _ref$isBrowser = _ref.isBrowser,\n        isBrowser = _ref$isBrowser === void 0 ? typeof window !== 'undefined' : _ref$isBrowser;\n\n    invariant(isString(name), '`name` must be a string');\n    this._name = name;\n    this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n    invariant(typeof optimizeForSpeed === 'boolean', '`optimizeForSpeed` must be a boolean');\n    this._optimizeForSpeed = optimizeForSpeed;\n    this._isBrowser = isBrowser;\n    this._serverSheet = undefined;\n    this._tags = [];\n    this._injected = false;\n    this._rulesCount = 0;\n    var node = this._isBrowser && document.querySelector('meta[property=\"csp-nonce\"]');\n    this._nonce = node ? node.getAttribute('content') : null;\n  }\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n    invariant(typeof bool === 'boolean', '`setOptimizeForSpeed` accepts a boolean');\n    invariant(this._rulesCount === 0, 'optimizeForSpeed cannot be when rules have already been inserted');\n    this.flush();\n    this._optimizeForSpeed = bool;\n    this.inject();\n  };\n\n  _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n    return this._optimizeForSpeed;\n  };\n\n  _proto.inject = function inject() {\n    var _this = this;\n\n    invariant(!this._injected, 'sheet already injected');\n    this._injected = true;\n\n    if (this._isBrowser && this._optimizeForSpeed) {\n      this._tags[0] = this.makeStyleTag(this._name);\n      this._optimizeForSpeed = 'insertRule' in this.getSheet();\n\n      if (!this._optimizeForSpeed) {\n        if (!isProd) {\n          console.warn('StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.');\n        }\n\n        this.flush();\n        this._injected = true;\n      }\n\n      return;\n    }\n\n    this._serverSheet = {\n      cssRules: [],\n      insertRule: function insertRule(rule, index) {\n        if (typeof index === 'number') {\n          _this._serverSheet.cssRules[index] = {\n            cssText: rule\n          };\n        } else {\n          _this._serverSheet.cssRules.push({\n            cssText: rule\n          });\n        }\n\n        return index;\n      },\n      deleteRule: function deleteRule(index) {\n        _this._serverSheet.cssRules[index] = null;\n      }\n    };\n  };\n\n  _proto.getSheetForTag = function getSheetForTag(tag) {\n    if (tag.sheet) {\n      return tag.sheet;\n    } // this weirdness brought to you by firefox\n\n\n    for (var i = 0; i < document.styleSheets.length; i++) {\n      if (document.styleSheets[i].ownerNode === tag) {\n        return document.styleSheets[i];\n      }\n    }\n  };\n\n  _proto.getSheet = function getSheet() {\n    return this.getSheetForTag(this._tags[this._tags.length - 1]);\n  };\n\n  _proto.insertRule = function insertRule(rule, index) {\n    invariant(isString(rule), '`insertRule` accepts only strings');\n\n    if (!this._isBrowser) {\n      if (typeof index !== 'number') {\n        index = this._serverSheet.cssRules.length;\n      }\n\n      this._serverSheet.insertRule(rule, index);\n\n      return this._rulesCount++;\n    }\n\n    if (this._optimizeForSpeed) {\n      var sheet = this.getSheet();\n\n      if (typeof index !== 'number') {\n        index = sheet.cssRules.length;\n      } // this weirdness for perf, and chrome's weird bug\n      // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n\n\n      try {\n        sheet.insertRule(rule, index);\n      } catch (error) {\n        if (!isProd) {\n          console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n        }\n\n        return -1;\n      }\n    } else {\n      var insertionPoint = this._tags[index];\n\n      this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n    }\n\n    return this._rulesCount++;\n  };\n\n  _proto.replaceRule = function replaceRule(index, rule) {\n    if (this._optimizeForSpeed || !this._isBrowser) {\n      var sheet = this._isBrowser ? this.getSheet() : this._serverSheet;\n\n      if (!rule.trim()) {\n        rule = this._deletedRulePlaceholder;\n      }\n\n      if (!sheet.cssRules[index]) {\n        // @TBD Should we throw an error?\n        return index;\n      }\n\n      sheet.deleteRule(index);\n\n      try {\n        sheet.insertRule(rule, index);\n      } catch (error) {\n        if (!isProd) {\n          console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n        } // In order to preserve the indices we insert a deleteRulePlaceholder\n\n\n        sheet.insertRule(this._deletedRulePlaceholder, index);\n      }\n    } else {\n      var tag = this._tags[index];\n      invariant(tag, \"old rule at index `\" + index + \"` not found\");\n      tag.textContent = rule;\n    }\n\n    return index;\n  };\n\n  _proto.deleteRule = function deleteRule(index) {\n    if (!this._isBrowser) {\n      this._serverSheet.deleteRule(index);\n\n      return;\n    }\n\n    if (this._optimizeForSpeed) {\n      this.replaceRule(index, '');\n    } else {\n      var tag = this._tags[index];\n      invariant(tag, \"rule at index `\" + index + \"` not found\");\n      tag.parentNode.removeChild(tag);\n      this._tags[index] = null;\n    }\n  };\n\n  _proto.flush = function flush() {\n    this._injected = false;\n    this._rulesCount = 0;\n\n    if (this._isBrowser) {\n      this._tags.forEach(function (tag) {\n        return tag && tag.parentNode.removeChild(tag);\n      });\n\n      this._tags = [];\n    } else {\n      // simpler on server\n      this._serverSheet.cssRules = [];\n    }\n  };\n\n  _proto.cssRules = function cssRules() {\n    var _this2 = this;\n\n    if (!this._isBrowser) {\n      return this._serverSheet.cssRules;\n    }\n\n    return this._tags.reduce(function (rules, tag) {\n      if (tag) {\n        rules = rules.concat(Array.prototype.map.call(_this2.getSheetForTag(tag).cssRules, function (rule) {\n          return rule.cssText === _this2._deletedRulePlaceholder ? null : rule;\n        }));\n      } else {\n        rules.push(null);\n      }\n\n      return rules;\n    }, []);\n  };\n\n  _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n    if (cssString) {\n      invariant(isString(cssString), 'makeStyleTag accepts only strings as second parameter');\n    }\n\n    var tag = document.createElement('style');\n    if (this._nonce) tag.setAttribute('nonce', this._nonce);\n    tag.type = 'text/css';\n    tag.setAttribute(\"data-\" + name, '');\n\n    if (cssString) {\n      tag.appendChild(document.createTextNode(cssString));\n    }\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n\n    if (relativeToTag) {\n      head.insertBefore(tag, relativeToTag);\n    } else {\n      head.appendChild(tag);\n    }\n\n    return tag;\n  };\n\n  _createClass(StyleSheet, [{\n    key: \"length\",\n    get: function get() {\n      return this._rulesCount;\n    }\n  }]);\n\n  return StyleSheet;\n}();\n\nexports[\"default\"] = StyleSheet;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(\"StyleSheet: \" + message + \".\");\n  }\n}\n\n/***/ }),\n\n/***/ 449:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports[\"default\"] = JSXStyle;\n\nvar _react = _interopRequireDefault(__nccwpck_require__(522));\n\nvar _stylesheetRegistry = __nccwpck_require__(147);\n\nvar _hash = __nccwpck_require__(590);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = _react[\"default\"].useInsertionEffect || _react[\"default\"].useLayoutEffect;\nvar defaultRegistry = typeof window !== 'undefined' ? (0, _stylesheetRegistry.createStyleRegistry)() : undefined;\n\nfunction JSXStyle(props) {\n  var registry = defaultRegistry ? defaultRegistry : (0, _stylesheetRegistry.useStyleRegistry)(); // If `registry` does not exist, we do nothing here.\n\n  if (!registry) {\n    return null;\n  }\n\n  if (typeof window === 'undefined') {\n    registry.add(props);\n    return null;\n  }\n\n  useInsertionEffect(function () {\n    registry.add(props);\n    return function () {\n      registry.remove(props);\n    }; // props.children can be string[], will be striped since id is identical\n  }, [props.id, String(props.dynamic)]);\n  return null;\n}\n\nJSXStyle.dynamic = function (info) {\n  return info.map(function (tagInfo) {\n    var baseId = tagInfo[0];\n    var props = tagInfo[1];\n    return (0, _hash.computeId)(baseId, props);\n  }).join(' ');\n};\n\n/***/ }),\n\n/***/ 147:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports.createStyleRegistry = createStyleRegistry;\nexports.StyleRegistry = StyleRegistry;\nexports.useStyleRegistry = useStyleRegistry;\nexports.StyleSheetContext = exports.StyleSheetRegistry = void 0;\n\nvar _react = _interopRequireWildcard(__nccwpck_require__(522));\n\nvar _stylesheet = _interopRequireDefault(__nccwpck_require__(503));\n\nvar _hash = __nccwpck_require__(590);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction mapRulesToStyle(cssRules, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return cssRules.map(function (args) {\n    var id = args[0];\n    var css = args[1];\n    return _react[\"default\"].createElement('style', {\n      id: \"__\" + id,\n      // Avoid warnings upon render with a key\n      key: \"__\" + id,\n      nonce: options.nonce ? options.nonce : undefined,\n      dangerouslySetInnerHTML: {\n        __html: css\n      }\n    });\n  });\n}\n\nvar StyleSheetRegistry = /*#__PURE__*/function () {\n  function StyleSheetRegistry(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$styleSheet = _ref.styleSheet,\n        styleSheet = _ref$styleSheet === void 0 ? null : _ref$styleSheet,\n        _ref$optimizeForSpeed = _ref.optimizeForSpeed,\n        optimizeForSpeed = _ref$optimizeForSpeed === void 0 ? false : _ref$optimizeForSpeed,\n        _ref$isBrowser = _ref.isBrowser,\n        isBrowser = _ref$isBrowser === void 0 ? typeof window !== 'undefined' : _ref$isBrowser;\n\n    this._sheet = styleSheet || new _stylesheet[\"default\"]({\n      name: 'styled-jsx',\n      optimizeForSpeed: optimizeForSpeed\n    });\n\n    this._sheet.inject();\n\n    if (styleSheet && typeof optimizeForSpeed === 'boolean') {\n      this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n\n      this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n    }\n\n    this._isBrowser = isBrowser;\n    this._fromServer = undefined;\n    this._indices = {};\n    this._instancesCounts = {};\n  }\n\n  var _proto = StyleSheetRegistry.prototype;\n\n  _proto.add = function add(props) {\n    var _this = this;\n\n    if (undefined === this._optimizeForSpeed) {\n      this._optimizeForSpeed = Array.isArray(props.children);\n\n      this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n\n      this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n    }\n\n    if (this._isBrowser && !this._fromServer) {\n      this._fromServer = this.selectFromServer();\n      this._instancesCounts = Object.keys(this._fromServer).reduce(function (acc, tagName) {\n        acc[tagName] = 0;\n        return acc;\n      }, {});\n    }\n\n    var _this$getIdAndRules = this.getIdAndRules(props),\n        styleId = _this$getIdAndRules.styleId,\n        rules = _this$getIdAndRules.rules; // Deduping: just increase the instances count.\n\n\n    if (styleId in this._instancesCounts) {\n      this._instancesCounts[styleId] += 1;\n      return;\n    }\n\n    var indices = rules.map(function (rule) {\n      return _this._sheet.insertRule(rule);\n    }) // Filter out invalid rules\n    .filter(function (index) {\n      return index !== -1;\n    });\n    this._indices[styleId] = indices;\n    this._instancesCounts[styleId] = 1;\n  };\n\n  _proto.remove = function remove(props) {\n    var _this2 = this;\n\n    var _this$getIdAndRules2 = this.getIdAndRules(props),\n        styleId = _this$getIdAndRules2.styleId;\n\n    invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n    this._instancesCounts[styleId] -= 1;\n\n    if (this._instancesCounts[styleId] < 1) {\n      var tagFromServer = this._fromServer && this._fromServer[styleId];\n\n      if (tagFromServer) {\n        tagFromServer.parentNode.removeChild(tagFromServer);\n        delete this._fromServer[styleId];\n      } else {\n        this._indices[styleId].forEach(function (index) {\n          return _this2._sheet.deleteRule(index);\n        });\n\n        delete this._indices[styleId];\n      }\n\n      delete this._instancesCounts[styleId];\n    }\n  };\n\n  _proto.update = function update(props, nextProps) {\n    this.add(nextProps);\n    this.remove(props);\n  };\n\n  _proto.flush = function flush() {\n    this._sheet.flush();\n\n    this._sheet.inject();\n\n    this._fromServer = undefined;\n    this._indices = {};\n    this._instancesCounts = {};\n  };\n\n  _proto.cssRules = function cssRules() {\n    var _this3 = this;\n\n    var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function (styleId) {\n      return [styleId, _this3._fromServer[styleId]];\n    }) : [];\n\n    var cssRules = this._sheet.cssRules();\n\n    return fromServer.concat(Object.keys(this._indices).map(function (styleId) {\n      return [styleId, _this3._indices[styleId].map(function (index) {\n        return cssRules[index].cssText;\n      }).join(_this3._optimizeForSpeed ? '' : '\\n')];\n    }) // filter out empty rules\n    .filter(function (rule) {\n      return Boolean(rule[1]);\n    }));\n  };\n\n  _proto.styles = function styles(options) {\n    return mapRulesToStyle(this.cssRules(), options);\n  };\n\n  _proto.getIdAndRules = function getIdAndRules(props) {\n    var css = props.children,\n        dynamic = props.dynamic,\n        id = props.id;\n\n    if (dynamic) {\n      var styleId = (0, _hash.computeId)(id, dynamic);\n      return {\n        styleId: styleId,\n        rules: Array.isArray(css) ? css.map(function (rule) {\n          return (0, _hash.computeSelector)(styleId, rule);\n        }) : [(0, _hash.computeSelector)(styleId, css)]\n      };\n    }\n\n    return {\n      styleId: (0, _hash.computeId)(id),\n      rules: Array.isArray(css) ? css : [css]\n    };\n  }\n  /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */\n  ;\n\n  _proto.selectFromServer = function selectFromServer() {\n    var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n    return elements.reduce(function (acc, element) {\n      var id = element.id.slice(2);\n      acc[id] = element;\n      return acc;\n    }, {});\n  };\n\n  return StyleSheetRegistry;\n}();\n\nexports.StyleSheetRegistry = StyleSheetRegistry;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n  }\n}\n\nvar StyleSheetContext = (0, _react.createContext)(null);\nexports.StyleSheetContext = StyleSheetContext;\n\nfunction createStyleRegistry() {\n  return new StyleSheetRegistry();\n}\n\nfunction StyleRegistry(_ref2) {\n  var configuredRegistry = _ref2.registry,\n      children = _ref2.children;\n  var rootRegistry = (0, _react.useContext)(StyleSheetContext);\n\n  var _useState = (0, _react.useState)(function () {\n    return rootRegistry || configuredRegistry || createStyleRegistry();\n  }),\n      registry = _useState[0];\n\n  return _react[\"default\"].createElement(StyleSheetContext.Provider, {\n    value: registry\n  }, children);\n}\n\nfunction useStyleRegistry() {\n  return (0, _react.useContext)(StyleSheetContext);\n}\n\n/***/ }),\n\n/***/ 522:\n/***/ (function(module) {\n\nmodule.exports = __webpack_require__(/*! react */ \"react\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat */\n/******/ \t\n/******/ \tif (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + \"/\";\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n!function() {\nvar exports = __webpack_exports__;\n\n\nexports.__esModule = true;\nexports.style = exports.useStyleRegistry = exports.createStyleRegistry = exports.StyleRegistry = void 0;\n\nvar _stylesheetRegistry = __nccwpck_require__(147);\n\nexports.StyleRegistry = _stylesheetRegistry.StyleRegistry;\nexports.createStyleRegistry = _stylesheetRegistry.createStyleRegistry;\nexports.useStyleRegistry = _stylesheetRegistry.useStyleRegistry;\n\nvar _style = _interopRequireDefault(__nccwpck_require__(449));\n\nexports.style = _style[\"default\"];\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n}();\nmodule.exports = __webpack_exports__;\n/******/ })()\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L2luZGV4L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBb0I7O0FBRWxGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QztBQUM5RSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGVtY2F0YWxvZ3VlLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvZGlzdC9pbmRleC9pbmRleC5qcz9iMDA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA1ODM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODEsXG4gICAgICBpICAgID0gc3RyLmxlbmd0aDtcblxuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGNvbnZlcnQgdGhlXG4gICAqIHNpZ25lZCBpbnQgdG8gYW4gdW5zaWduZWQgYnkgZG9pbmcgYW4gdW5zaWduZWQgYml0c2hpZnQuICovXG4gIHJldHVybiBoYXNoID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5MDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXykge1xuXG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcHV0ZUlkID0gY29tcHV0ZUlkO1xuZXhwb3J0cy5jb21wdXRlU2VsZWN0b3IgPSBjb21wdXRlU2VsZWN0b3I7XG5cbnZhciBfc3RyaW5nSGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX19uY2N3cGNrX3JlcXVpcmVfXyg1ODMpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBzYW5pdGl6ZSA9IGZ1bmN0aW9uIHNhbml0aXplKHJ1bGUpIHtcbiAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksICdcXFxcL3N0eWxlJyk7XG59O1xuXG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICB9XG5cbiAgdmFyIHByb3BzVG9TdHJpbmcgPSBTdHJpbmcocHJvcHMpO1xuICB2YXIga2V5ID0gYmFzZUlkICsgcHJvcHNUb1N0cmluZztcblxuICBpZiAoIWNhY2hlW2tleV0pIHtcbiAgICBjYWNoZVtrZXldID0gXCJqc3gtXCIgKyAoMCwgX3N0cmluZ0hhc2hbXCJkZWZhdWx0XCJdKShiYXNlSWQgKyBcIi1cIiArIHByb3BzVG9TdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlU2VsZWN0b3IoaWQsIGNzcykge1xuICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZzsgLy8gU2FuaXRpemUgU1NSLWVkIENTUy5cbiAgLy8gQ2xpZW50IHNpZGUgY29kZSBkb2Vzbid0IG5lZWQgdG8gYmUgc2FuaXRpemVkIHNpbmNlIHdlIHVzZVxuICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICB9XG5cbiAgdmFyIGlkY3NzID0gaWQgKyBjc3M7XG5cbiAgaWYgKCFjYWNoZVtpZGNzc10pIHtcbiAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZVtpZGNzc107XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qL1xudmFyIGlzUHJvZCA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIFN0eWxlU2hlZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgX3JlZiRuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBuYW1lID0gX3JlZiRuYW1lID09PSB2b2lkIDAgPyAnc3R5bGVzaGVldCcgOiBfcmVmJG5hbWUsXG4gICAgICAgIF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYub3B0aW1pemVGb3JTcGVlZCxcbiAgICAgICAgb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9PT0gdm9pZCAwID8gaXNQcm9kIDogX3JlZiRvcHRpbWl6ZUZvclNwZWVkLFxuICAgICAgICBfcmVmJGlzQnJvd3NlciA9IF9yZWYuaXNCcm93c2VyLFxuICAgICAgICBpc0Jyb3dzZXIgPSBfcmVmJGlzQnJvd3NlciA9PT0gdm9pZCAwID8gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgOiBfcmVmJGlzQnJvd3NlcjtcblxuICAgIGludmFyaWFudChpc1N0cmluZyhuYW1lKSwgJ2BuYW1lYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA9IFwiI1wiICsgbmFtZSArIFwiLWRlbGV0ZWQtcnVsZV9fX197fVwiO1xuICAgIGludmFyaWFudCh0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gJ2Jvb2xlYW4nLCAnYG9wdGltaXplRm9yU3BlZWRgIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IG9wdGltaXplRm9yU3BlZWQ7XG4gICAgdGhpcy5faXNCcm93c2VyID0gaXNCcm93c2VyO1xuICAgIHRoaXMuX3NlcnZlclNoZWV0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhZ3MgPSBbXTtcbiAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3J1bGVzQ291bnQgPSAwO1xuICAgIHZhciBub2RlID0gdGhpcy5faXNCcm93c2VyICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICB0aGlzLl9ub25jZSA9IG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0T3B0aW1pemVGb3JTcGVlZCA9IGZ1bmN0aW9uIHNldE9wdGltaXplRm9yU3BlZWQoYm9vbCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgYm9vbCA9PT0gJ2Jvb2xlYW4nLCAnYHNldE9wdGltaXplRm9yU3BlZWRgIGFjY2VwdHMgYSBib29sZWFuJyk7XG4gICAgaW52YXJpYW50KHRoaXMuX3J1bGVzQ291bnQgPT09IDAsICdvcHRpbWl6ZUZvclNwZWVkIGNhbm5vdCBiZSB3aGVuIHJ1bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluc2VydGVkJyk7XG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBib29sO1xuICAgIHRoaXMuaW5qZWN0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzT3B0aW1pemVGb3JTcGVlZCA9IGZ1bmN0aW9uIGlzT3B0aW1pemVGb3JTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW1pemVGb3JTcGVlZDtcbiAgfTtcblxuICBfcHJvdG8uaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpbnZhcmlhbnQoIXRoaXMuX2luamVjdGVkLCAnc2hlZXQgYWxyZWFkeSBpbmplY3RlZCcpO1xuICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9pc0Jyb3dzZXIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9ICdpbnNlcnRSdWxlJyBpbiB0aGlzLmdldFNoZWV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU3R5bGVTaGVldDogb3B0aW1pemVGb3JTcGVlZCBtb2RlIG5vdCBzdXBwb3J0ZWQgZmFsbGluZyBiYWNrIHRvIHN0YW5kYXJkIG1vZGUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NlcnZlclNoZWV0ID0ge1xuICAgICAgY3NzUnVsZXM6IFtdLFxuICAgICAgaW5zZXJ0UnVsZTogZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSB7XG4gICAgICAgICAgICBjc3NUZXh0OiBydWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMucHVzaCh7XG4gICAgICAgICAgICBjc3NUZXh0OiBydWxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUnVsZTogZnVuY3Rpb24gZGVsZXRlUnVsZShpbmRleCkge1xuICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRTaGVldEZvclRhZyA9IGZ1bmN0aW9uIGdldFNoZWV0Rm9yVGFnKHRhZykge1xuICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgfSAvLyB0aGlzIHdlaXJkbmVzcyBicm91Z2h0IHRvIHlvdSBieSBmaXJlZm94XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5vd25lck5vZGUgPT09IHRhZykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRTaGVldCA9IGZ1bmN0aW9uIGdldFNoZWV0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNoZWV0Rm9yVGFnKHRoaXMuX3RhZ3NbdGhpcy5fdGFncy5sZW5ndGggLSAxXSk7XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgaW52YXJpYW50KGlzU3RyaW5nKHJ1bGUpLCAnYGluc2VydFJ1bGVgIGFjY2VwdHMgb25seSBzdHJpbmdzJyk7XG5cbiAgICBpZiAoIXRoaXMuX2lzQnJvd3Nlcikge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlcnZlclNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLmdldFNoZWV0KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgfSAvLyB0aGlzIHdlaXJkbmVzcyBmb3IgcGVyZiwgYW5kIGNocm9tZSdzIHdlaXJkIGJ1Z1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAwMDc5OTIvY2hyb21lLXN1ZGRlbmx5LXN0b3BwZWQtYWNjZXB0aW5nLWluc2VydHJ1bGVcblxuXG4gICAgICB0cnkge1xuICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG5cbiAgICAgIHRoaXMuX3RhZ3MucHVzaCh0aGlzLm1ha2VTdHlsZVRhZyh0aGlzLl9uYW1lLCBydWxlLCBpbnNlcnRpb25Qb2ludCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCB8fCAhdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLl9pc0Jyb3dzZXIgPyB0aGlzLmdldFNoZWV0KCkgOiB0aGlzLl9zZXJ2ZXJTaGVldDtcblxuICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICBydWxlID0gdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgLy8gQFRCRCBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cblxuICAgICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdHlsZVNoZWV0OiBpbGxlZ2FsIHJ1bGU6IFxcblxcblwiICsgcnVsZSArIFwiXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvXCIpO1xuICAgICAgICB9IC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuXG5cbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZSh0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSB0aGlzLl90YWdzW2luZGV4XTtcbiAgICAgIGludmFyaWFudCh0YWcsIFwib2xkIHJ1bGUgYXQgaW5kZXggYFwiICsgaW5kZXggKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgdGFnLnRleHRDb250ZW50ID0gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9pc0Jyb3dzZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlclNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgIHRoaXMucmVwbGFjZVJ1bGUoaW5kZXgsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHRhZywgXCJydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICB0aGlzLl90YWdzW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHRoaXMuX2luamVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG5cbiAgICBpZiAodGhpcy5faXNCcm93c2VyKSB7XG4gICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICByZXR1cm4gdGFnICYmIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuX2lzQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90YWdzLnJlZHVjZShmdW5jdGlvbiAocnVsZXMsIHRhZykge1xuICAgICAgaWYgKHRhZykge1xuICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMyLmdldFNoZWV0Rm9yVGFnKHRhZykuY3NzUnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bGUuY3NzVGV4dCA9PT0gX3RoaXMyLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID8gbnVsbCA6IHJ1bGU7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVzLnB1c2gobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydWxlcztcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICBpbnZhcmlhbnQoaXNTdHJpbmcoY3NzU3RyaW5nKSwgJ21ha2VTdHlsZVRhZyBhY2NlcHRzIG9ubHkgc3RyaW5ncyBhcyBzZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaWYgKHRoaXMuX25vbmNlKSB0YWcuc2V0QXR0cmlidXRlKCdub25jZScsIHRoaXMuX25vbmNlKTtcbiAgICB0YWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgdGFnLnNldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lLCAnJyk7XG5cbiAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICBpZiAocmVsYXRpdmVUb1RhZykge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGFnLCByZWxhdGl2ZVRvVGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIFt7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3R5bGVTaGVldDtcblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlU2hlZXQ6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQ5OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX25jY3dwY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBKU1hTdHlsZTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX19uY2N3cGNrX3JlcXVpcmVfXyg1MjIpKTtcblxudmFyIF9zdHlsZXNoZWV0UmVnaXN0cnkgPSBfX25jY3dwY2tfcmVxdWlyZV9fKDE0Nyk7XG5cbnZhciBfaGFzaCA9IF9fbmNjd3Bja19yZXF1aXJlX18oNTkwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8vIE9wdC1pbnRvIHRoZSBuZXcgYHVzZUluc2VydGlvbkVmZmVjdGAgQVBJIGluIFJlYWN0IDE4LCBmYWxsYmFjayB0byBgdXNlTGF5b3V0RWZmZWN0YC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdHdnL3JlYWN0LTE4L2Rpc2N1c3Npb25zLzExMFxudmFyIHVzZUluc2VydGlvbkVmZmVjdCA9IF9yZWFjdFtcImRlZmF1bHRcIl0udXNlSW5zZXJ0aW9uRWZmZWN0IHx8IF9yZWFjdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKDAsIF9zdHlsZXNoZWV0UmVnaXN0cnkuY3JlYXRlU3R5bGVSZWdpc3RyeSkoKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gSlNYU3R5bGUocHJvcHMpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gZGVmYXVsdFJlZ2lzdHJ5ID8gZGVmYXVsdFJlZ2lzdHJ5IDogKDAsIF9zdHlsZXNoZWV0UmVnaXN0cnkudXNlU3R5bGVSZWdpc3RyeSkoKTsgLy8gSWYgYHJlZ2lzdHJ5YCBkb2VzIG5vdCBleGlzdCwgd2UgZG8gbm90aGluZyBoZXJlLlxuXG4gIGlmICghcmVnaXN0cnkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJlZ2lzdHJ5LmFkZChwcm9wcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB1c2VJbnNlcnRpb25FZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdHJ5LmFkZChwcm9wcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZShwcm9wcyk7XG4gICAgfTsgLy8gcHJvcHMuY2hpbGRyZW4gY2FuIGJlIHN0cmluZ1tdLCB3aWxsIGJlIHN0cmlwZWQgc2luY2UgaWQgaXMgaWRlbnRpY2FsXG4gIH0sIFtwcm9wcy5pZCwgU3RyaW5nKHByb3BzLmR5bmFtaWMpXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5KU1hTdHlsZS5keW5hbWljID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uICh0YWdJbmZvKSB7XG4gICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgdmFyIHByb3BzID0gdGFnSW5mb1sxXTtcbiAgICByZXR1cm4gKDAsIF9oYXNoLmNvbXB1dGVJZCkoYmFzZUlkLCBwcm9wcyk7XG4gIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pIHtcblxuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVN0eWxlUmVnaXN0cnkgPSBjcmVhdGVTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5TdHlsZVJlZ2lzdHJ5ID0gU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLlN0eWxlU2hlZXRDb250ZXh0ID0gZXhwb3J0cy5TdHlsZVNoZWV0UmVnaXN0cnkgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX25jY3dwY2tfcmVxdWlyZV9fKDUyMikpO1xuXG52YXIgX3N0eWxlc2hlZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fbmNjd3Bja19yZXF1aXJlX18oNTAzKSk7XG5cbnZhciBfaGFzaCA9IF9fbmNjd3Bja19yZXF1aXJlX18oNTkwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBtYXBSdWxlc1RvU3R5bGUoY3NzUnVsZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgIHZhciBjc3MgPSBhcmdzWzFdO1xuICAgIHJldHVybiBfcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJywge1xuICAgICAgaWQ6IFwiX19cIiArIGlkLFxuICAgICAgLy8gQXZvaWQgd2FybmluZ3MgdXBvbiByZW5kZXIgd2l0aCBhIGtleVxuICAgICAga2V5OiBcIl9fXCIgKyBpZCxcbiAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHVuZGVmaW5lZCxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogY3NzXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgU3R5bGVTaGVldFJlZ2lzdHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldFJlZ2lzdHJ5KF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgX3JlZiRzdHlsZVNoZWV0ID0gX3JlZi5zdHlsZVNoZWV0LFxuICAgICAgICBzdHlsZVNoZWV0ID0gX3JlZiRzdHlsZVNoZWV0ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRzdHlsZVNoZWV0LFxuICAgICAgICBfcmVmJG9wdGltaXplRm9yU3BlZWQgPSBfcmVmLm9wdGltaXplRm9yU3BlZWQsXG4gICAgICAgIG9wdGltaXplRm9yU3BlZWQgPSBfcmVmJG9wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRvcHRpbWl6ZUZvclNwZWVkLFxuICAgICAgICBfcmVmJGlzQnJvd3NlciA9IF9yZWYuaXNCcm93c2VyLFxuICAgICAgICBpc0Jyb3dzZXIgPSBfcmVmJGlzQnJvd3NlciA9PT0gdm9pZCAwID8gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgOiBfcmVmJGlzQnJvd3NlcjtcblxuICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgX3N0eWxlc2hlZXRbXCJkZWZhdWx0XCJdKHtcbiAgICAgIG5hbWU6ICdzdHlsZWQtanN4JyxcbiAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICB9KTtcblxuICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuXG4gICAgaWYgKHN0eWxlU2hlZXQgJiYgdHlwZW9mIG9wdGltaXplRm9yU3BlZWQgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5fc2hlZXQuc2V0T3B0aW1pemVGb3JTcGVlZChvcHRpbWl6ZUZvclNwZWVkKTtcblxuICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQnJvd3NlciA9IGlzQnJvd3NlcjtcbiAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcbiAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0UmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuXG4gICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQnJvd3NlciAmJiAhdGhpcy5fZnJvbVNlcnZlcikge1xuICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHRoaXMuc2VsZWN0RnJvbVNlcnZlcigpO1xuICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzID0gT2JqZWN0LmtleXModGhpcy5fZnJvbVNlcnZlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRhZ05hbWUpIHtcbiAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkZ2V0SWRBbmRSdWxlcyA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcyksXG4gICAgICAgIHN0eWxlSWQgPSBfdGhpcyRnZXRJZEFuZFJ1bGVzLnN0eWxlSWQsXG4gICAgICAgIHJ1bGVzID0gX3RoaXMkZ2V0SWRBbmRSdWxlcy5ydWxlczsgLy8gRGVkdXBpbmc6IGp1c3QgaW5jcmVhc2UgdGhlIGluc3RhbmNlcyBjb3VudC5cblxuXG4gICAgaWYgKHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzKSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gKz0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcmV0dXJuIF90aGlzLl9zaGVldC5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIH0pIC8vIEZpbHRlciBvdXQgaW52YWxpZCBydWxlc1xuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggIT09IC0xO1xuICAgIH0pO1xuICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA9IDE7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJGdldElkQW5kUnVsZXMyID0gdGhpcy5nZXRJZEFuZFJ1bGVzKHByb3BzKSxcbiAgICAgICAgc3R5bGVJZCA9IF90aGlzJGdldElkQW5kUnVsZXMyLnN0eWxlSWQ7XG5cbiAgICBpbnZhcmlhbnQoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMsIFwic3R5bGVJZDogYFwiICsgc3R5bGVJZCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdIC09IDE7XG5cbiAgICBpZiAodGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdIDwgMSkge1xuICAgICAgdmFyIHRhZ0Zyb21TZXJ2ZXIgPSB0aGlzLl9mcm9tU2VydmVyICYmIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG5cbiAgICAgIGlmICh0YWdGcm9tU2VydmVyKSB7XG4gICAgICAgIHRhZ0Zyb21TZXJ2ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWdGcm9tU2VydmVyKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICB0aGlzLmFkZChuZXh0UHJvcHMpO1xuICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuXG4gICAgdGhpcy5fc2hlZXQuaW5qZWN0KCk7XG5cbiAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcbiAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgfTtcblxuICBfcHJvdG8uY3NzUnVsZXMgPSBmdW5jdGlvbiBjc3NSdWxlcygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBmcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciA/IE9iamVjdC5rZXlzKHRoaXMuX2Zyb21TZXJ2ZXIpLm1hcChmdW5jdGlvbiAoc3R5bGVJZCkge1xuICAgICAgcmV0dXJuIFtzdHlsZUlkLCBfdGhpczMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF1dO1xuICAgIH0pIDogW107XG5cbiAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuXG4gICAgcmV0dXJuIGZyb21TZXJ2ZXIuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuX2luZGljZXMpLm1hcChmdW5jdGlvbiAoc3R5bGVJZCkge1xuICAgICAgcmV0dXJuIFtzdHlsZUlkLCBfdGhpczMuX2luZGljZXNbc3R5bGVJZF0ubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gY3NzUnVsZXNbaW5kZXhdLmNzc1RleHQ7XG4gICAgICB9KS5qb2luKF90aGlzMy5fb3B0aW1pemVGb3JTcGVlZCA/ICcnIDogJ1xcbicpXTtcbiAgICB9KSAvLyBmaWx0ZXIgb3V0IGVtcHR5IHJ1bGVzXG4gICAgLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4ocnVsZVsxXSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90by5zdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXMob3B0aW9ucykge1xuICAgIHJldHVybiBtYXBSdWxlc1RvU3R5bGUodGhpcy5jc3NSdWxlcygpLCBvcHRpb25zKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0SWRBbmRSdWxlcyA9IGZ1bmN0aW9uIGdldElkQW5kUnVsZXMocHJvcHMpIHtcbiAgICB2YXIgY3NzID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGR5bmFtaWMgPSBwcm9wcy5keW5hbWljLFxuICAgICAgICBpZCA9IHByb3BzLmlkO1xuXG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIHZhciBzdHlsZUlkID0gKDAsIF9oYXNoLmNvbXB1dGVJZCkoaWQsIGR5bmFtaWMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF9oYXNoLmNvbXB1dGVTZWxlY3Rvcikoc3R5bGVJZCwgcnVsZSk7XG4gICAgICAgIH0pIDogWygwLCBfaGFzaC5jb21wdXRlU2VsZWN0b3IpKHN0eWxlSWQsIGNzcyldXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdHlsZUlkOiAoMCwgX2hhc2guY29tcHV0ZUlkKShpZCksXG4gICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW2Nzc11cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBzZWxlY3RGcm9tU2VydmVyXG4gICAqXG4gICAqIENvbGxlY3RzIHN0eWxlIHRhZ3MgZnJvbSB0aGUgZG9jdW1lbnQgd2l0aCBpZCBfX2pzeC1YWFhcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2VsZWN0RnJvbVNlcnZlciA9IGZ1bmN0aW9uIHNlbGVjdEZyb21TZXJ2ZXIoKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkXj1cIl9fanN4LVwiXScpKTtcbiAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBpZCA9IGVsZW1lbnQuaWQuc2xpY2UoMik7XG4gICAgICBhY2NbaWRdID0gZWxlbWVudDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0UmVnaXN0cnk7XG59KCk7XG5cbmV4cG9ydHMuU3R5bGVTaGVldFJlZ2lzdHJ5ID0gU3R5bGVTaGVldFJlZ2lzdHJ5O1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3R5bGVTaGVldFJlZ2lzdHJ5OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gIH1cbn1cblxudmFyIFN0eWxlU2hlZXRDb250ZXh0ID0gKDAsIF9yZWFjdC5jcmVhdGVDb250ZXh0KShudWxsKTtcbmV4cG9ydHMuU3R5bGVTaGVldENvbnRleHQgPSBTdHlsZVNoZWV0Q29udGV4dDtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVSZWdpc3RyeSgpIHtcbiAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cblxuZnVuY3Rpb24gU3R5bGVSZWdpc3RyeShfcmVmMikge1xuICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gX3JlZjIucmVnaXN0cnksXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICB2YXIgcm9vdFJlZ2lzdHJ5ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShTdHlsZVNoZWV0Q29udGV4dCk7XG5cbiAgdmFyIF91c2VTdGF0ZSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcm9vdFJlZ2lzdHJ5IHx8IGNvbmZpZ3VyZWRSZWdpc3RyeSB8fCBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCk7XG4gIH0pLFxuICAgICAgcmVnaXN0cnkgPSBfdXNlU3RhdGVbMF07XG5cbiAgcmV0dXJuIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlUmVnaXN0cnkoKSB7XG4gIHJldHVybiAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRpZiAodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18gIT09ICd1bmRlZmluZWQnKSBfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuIWZ1bmN0aW9uKCkge1xudmFyIGV4cG9ydHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnN0eWxlID0gZXhwb3J0cy51c2VTdHlsZVJlZ2lzdHJ5ID0gZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gZXhwb3J0cy5TdHlsZVJlZ2lzdHJ5ID0gdm9pZCAwO1xuXG52YXIgX3N0eWxlc2hlZXRSZWdpc3RyeSA9IF9fbmNjd3Bja19yZXF1aXJlX18oMTQ3KTtcblxuZXhwb3J0cy5TdHlsZVJlZ2lzdHJ5ID0gX3N0eWxlc2hlZXRSZWdpc3RyeS5TdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gX3N0eWxlc2hlZXRSZWdpc3RyeS5jcmVhdGVTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy51c2VTdHlsZVJlZ2lzdHJ5ID0gX3N0eWxlc2hlZXRSZWdpc3RyeS51c2VTdHlsZVJlZ2lzdHJ5O1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX25jY3dwY2tfcmVxdWlyZV9fKDQ0OSkpO1xuXG5leHBvcnRzLnN0eWxlID0gX3N0eWxlW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/dist/index/index.js\n");

/***/ }),

/***/ "./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index */ \"./node_modules/styled-jsx/dist/index/index.js\").style\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrR0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGVtY2F0YWxvZ3VlLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvc3R5bGUuanM/MzcwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9pbmRleCcpLnN0eWxlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/style.js\n");

/***/ })

};
;