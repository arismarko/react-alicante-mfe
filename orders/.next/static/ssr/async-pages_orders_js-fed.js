/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "async-pages_orders_js";
exports.ids = ["async-pages_orders_js"];
exports.modules = {

/***/ "./node_modules/.prisma/client/index.js":
/*!**********************************************!*\
  !*** ./node_modules/.prisma/client/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientRustPanicError,\n  PrismaClientInitializationError,\n  PrismaClientValidationError,\n  NotFoundError,\n  decompressFromBase64,\n  getPrismaClient,\n  sqltag,\n  empty,\n  join,\n  raw,\n  Decimal,\n  Debug,\n  objectEnumValues,\n  makeStrictEnum\n} = __webpack_require__(/*! @prisma/client/runtime/index */ \"./node_modules/@prisma/client/runtime/index.js\")\n\n\nconst Prisma = {}\n\nexports.Prisma = Prisma\n\n/**\n * Prisma Client JS version: 4.3.1\n * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b\n */\nPrisma.prismaVersion = {\n  client: \"4.3.1\",\n  engine: \"c875e43600dfe042452e0b868f7a48b817b9640b\"\n}\n\nPrisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;\nPrisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError\nPrisma.PrismaClientRustPanicError = PrismaClientRustPanicError\nPrisma.PrismaClientInitializationError = PrismaClientInitializationError\nPrisma.PrismaClientValidationError = PrismaClientValidationError\nPrisma.NotFoundError = NotFoundError\nPrisma.Decimal = Decimal\n\n/**\n * Re-export of sql-template-tag\n */\nPrisma.sql = sqltag\nPrisma.empty = empty\nPrisma.join = join\nPrisma.raw = raw\nPrisma.validator = () => (val) => val\n\n/**\n * Shorthand utilities for JSON filtering\n */\nPrisma.DbNull = objectEnumValues.instances.DbNull\nPrisma.JsonNull = objectEnumValues.instances.JsonNull\nPrisma.AnyNull = objectEnumValues.instances.AnyNull\n\nPrisma.NullTypes = {\n  DbNull: objectEnumValues.classes.DbNull,\n  JsonNull: objectEnumValues.classes.JsonNull,\n  AnyNull: objectEnumValues.classes.AnyNull\n}\n\n\n  const path = __webpack_require__(/*! path */ \"path\")\n\nconst { findSync } = __webpack_require__(/*! @prisma/client/runtime */ \"./node_modules/@prisma/client/runtime/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\n// some frameworks or bundlers replace or totally remove __dirname\nconst hasDirname =  true && __dirname !== '/'\n\n// will work in most cases, ie. if the client has not been bundled\nconst regularDirname = hasDirname && fs.existsSync(path.join(__dirname, 'schema.prisma')) && __dirname\n\n// if the client has been bundled, we need to look for the folders\nconst foundDirname = !regularDirname && findSync(process.cwd(), [\n    \"node_modules/.prisma/client\",\n    \".prisma/client\",\n], ['d'], ['d'], 1)[0]\n\nconst dirname = regularDirname || foundDirname || __dirname\n\n/**\n * Enums\n */\n// Based on\n// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nfunction makeEnum(x) { return x; }\n\nexports.Prisma.OrderScalarFieldEnum = makeEnum({\n  id: 'id',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt',\n  products: 'products',\n  buyerId: 'buyerId'\n});\n\nexports.Prisma.QueryMode = makeEnum({\n  default: 'default',\n  insensitive: 'insensitive'\n});\n\nexports.Prisma.SortOrder = makeEnum({\n  asc: 'asc',\n  desc: 'desc'\n});\n\nexports.Prisma.TransactionIsolationLevel = makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n});\n\nexports.Prisma.UserScalarFieldEnum = makeEnum({\n  id: 'id',\n  username: 'username',\n  title: 'title',\n  name: 'name',\n  surname: 'surname'\n});\n\n\nexports.Prisma.ModelName = makeEnum({\n  User: 'User',\n  Order: 'Order'\n});\n\nconst dmmfString = \"{\\\"datamodel\\\":{\\\"enums\\\":[],\\\"models\\\":[{\\\"name\\\":\\\"User\\\",\\\"dbName\\\":\\\"users\\\",\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":true,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"String\\\",\\\"default\\\":{\\\"name\\\":\\\"cuid\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"username\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":true,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"surname\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"orders\\\",\\\"kind\\\":\\\"object\\\",\\\"isList\\\":true,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"Order\\\",\\\"relationName\\\":\\\"OrderToUser\\\",\\\"relationFromFields\\\":[],\\\"relationToFields\\\":[],\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false}],\\\"primaryKey\\\":null,\\\"uniqueFields\\\":[],\\\"uniqueIndexes\\\":[],\\\"isGenerated\\\":false},{\\\"name\\\":\\\"Order\\\",\\\"dbName\\\":null,\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":true,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"String\\\",\\\"default\\\":{\\\"name\\\":\\\"cuid\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":true,\\\"type\\\":\\\"DateTime\\\",\\\"default\\\":{\\\"name\\\":\\\"now\\\",\\\"args\\\":[]},\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"DateTime\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":true},{\\\"name\\\":\\\"products\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":true,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"buyer\\\",\\\"kind\\\":\\\"object\\\",\\\"isList\\\":false,\\\"isRequired\\\":false,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":false,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"OrderToUser\\\",\\\"relationFromFields\\\":[\\\"buyerId\\\"],\\\"relationToFields\\\":[\\\"id\\\"],\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false},{\\\"name\\\":\\\"buyerId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"isList\\\":false,\\\"isRequired\\\":false,\\\"isUnique\\\":false,\\\"isId\\\":false,\\\"isReadOnly\\\":true,\\\"hasDefaultValue\\\":false,\\\"type\\\":\\\"String\\\",\\\"isGenerated\\\":false,\\\"isUpdatedAt\\\":false}],\\\"primaryKey\\\":null,\\\"uniqueFields\\\":[],\\\"uniqueIndexes\\\":[],\\\"isGenerated\\\":false}],\\\"types\\\":[]},\\\"mappings\\\":{\\\"modelOperations\\\":[{\\\"model\\\":\\\"User\\\",\\\"plural\\\":\\\"users\\\",\\\"findUnique\\\":\\\"findUniqueUser\\\",\\\"findFirst\\\":\\\"findFirstUser\\\",\\\"findMany\\\":\\\"findManyUser\\\",\\\"create\\\":\\\"createOneUser\\\",\\\"createMany\\\":\\\"createManyUser\\\",\\\"delete\\\":\\\"deleteOneUser\\\",\\\"update\\\":\\\"updateOneUser\\\",\\\"deleteMany\\\":\\\"deleteManyUser\\\",\\\"updateMany\\\":\\\"updateManyUser\\\",\\\"upsert\\\":\\\"upsertOneUser\\\",\\\"aggregate\\\":\\\"aggregateUser\\\",\\\"groupBy\\\":\\\"groupByUser\\\"},{\\\"model\\\":\\\"Order\\\",\\\"plural\\\":\\\"orders\\\",\\\"findUnique\\\":\\\"findUniqueOrder\\\",\\\"findFirst\\\":\\\"findFirstOrder\\\",\\\"findMany\\\":\\\"findManyOrder\\\",\\\"create\\\":\\\"createOneOrder\\\",\\\"createMany\\\":\\\"createManyOrder\\\",\\\"delete\\\":\\\"deleteOneOrder\\\",\\\"update\\\":\\\"updateOneOrder\\\",\\\"deleteMany\\\":\\\"deleteManyOrder\\\",\\\"updateMany\\\":\\\"updateManyOrder\\\",\\\"upsert\\\":\\\"upsertOneOrder\\\",\\\"aggregate\\\":\\\"aggregateOrder\\\",\\\"groupBy\\\":\\\"groupByOrder\\\"}],\\\"otherOperations\\\":{\\\"read\\\":[],\\\"write\\\":[\\\"executeRaw\\\",\\\"queryRaw\\\"]}}}\"\nconst dmmf = JSON.parse(dmmfString)\nexports.Prisma.dmmf = JSON.parse(dmmfString)\n\n/**\n * Create the Client\n */\nconst config = {\n  \"generator\": {\n    \"name\": \"client\",\n    \"provider\": {\n      \"fromEnvVar\": null,\n      \"value\": \"prisma-client-js\"\n    },\n    \"output\": {\n      \"value\": \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/node_modules/@prisma/client\",\n      \"fromEnvVar\": null\n    },\n    \"config\": {\n      \"engineType\": \"library\"\n    },\n    \"binaryTargets\": [],\n    \"previewFeatures\": []\n  },\n  \"relativeEnvPaths\": {\n    \"rootEnvPath\": \"../../../.env\",\n    \"schemaEnvPath\": \"../../../.env\"\n  },\n  \"relativePath\": \"../../../prisma\",\n  \"clientVersion\": \"4.3.1\",\n  \"engineVersion\": \"c875e43600dfe042452e0b868f7a48b817b9640b\",\n  \"datasourceNames\": [\n    \"db\"\n  ],\n  \"activeProvider\": \"postgresql\",\n  \"dataProxy\": false\n}\nconfig.document = dmmf\nconfig.dirname = dirname\n\n\n\n\nconst { warnEnvConflicts } = __webpack_require__(/*! @prisma/client/runtime/index */ \"./node_modules/@prisma/client/runtime/index.js\")\n\nwarnEnvConflicts({\n    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(dirname, config.relativeEnvPaths.rootEnvPath),\n    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(dirname, config.relativeEnvPaths.schemaEnvPath)\n})\n\nconst PrismaClient = getPrismaClient(config)\nexports.PrismaClient = PrismaClient\nObject.assign(exports, Prisma)\n\npath.join(__dirname, \"libquery_engine-darwin-arm64.dylib.node\");\npath.join(process.cwd(), \"node_modules/.prisma/client/libquery_engine-darwin-arm64.dylib.node\")\npath.join(__dirname, \"schema.prisma\");\npath.join(process.cwd(), \"node_modules/.prisma/client/schema.prisma\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLG9GQUE4Qjs7O0FBRzFDOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxlQUFlLG1CQUFPLENBQUMsa0JBQU07O0FBRTdCLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsOEVBQXdCO0FBQ3JELFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QjtBQUNBLG1CQUFtQixLQUFnQzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7O0FBRUQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOztBQUVELHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCLGVBQWUsMEJBQTBCLG9EQUFvRCx5TEFBeUwsOEJBQThCLDZDQUE2QyxFQUFFLCtOQUErTixFQUFFLDZOQUE2TixFQUFFLDROQUE0TixFQUFFLCtOQUErTixFQUFFLCtTQUErUyxxRkFBcUYsRUFBRSxnREFBZ0QseUxBQXlMLDhCQUE4Qiw2Q0FBNkMsRUFBRSxtTUFBbU0sNkJBQTZCLDZDQUE2QyxFQUFFLGtPQUFrTyxFQUFFLGdPQUFnTyxFQUFFLGdVQUFnVSxFQUFFLCtOQUErTixxRkFBcUYsZUFBZSxlQUFlLHNCQUFzQiw4WkFBOFosRUFBRSw0YUFBNGEsdUJBQXVCLHNEQUFzRDtBQUMzc0k7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxvRkFBOEI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmRlcnMvLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXguanM/M2ViZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3Qge1xuICBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsXG4gIFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IsXG4gIFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgZGVjb21wcmVzc0Zyb21CYXNlNjQsXG4gIGdldFByaXNtYUNsaWVudCxcbiAgc3FsdGFnLFxuICBlbXB0eSxcbiAgam9pbixcbiAgcmF3LFxuICBEZWNpbWFsLFxuICBEZWJ1ZyxcbiAgb2JqZWN0RW51bVZhbHVlcyxcbiAgbWFrZVN0cmljdEVudW1cbn0gPSByZXF1aXJlKCdAcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4JylcblxuXG5jb25zdCBQcmlzbWEgPSB7fVxuXG5leHBvcnRzLlByaXNtYSA9IFByaXNtYVxuXG4vKipcbiAqIFByaXNtYSBDbGllbnQgSlMgdmVyc2lvbjogNC4zLjFcbiAqIFF1ZXJ5IEVuZ2luZSB2ZXJzaW9uOiBjODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiXG4gKi9cblByaXNtYS5wcmlzbWFWZXJzaW9uID0ge1xuICBjbGllbnQ6IFwiNC4zLjFcIixcbiAgZW5naW5lOiBcImM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIlxufVxuXG5QcmlzbWEuUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IgPSBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcjtcblByaXNtYS5QcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclxuUHJpc21hLlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yID0gUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcblByaXNtYS5QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yID0gUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclxuUHJpc21hLlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclxuUHJpc21hLk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yXG5QcmlzbWEuRGVjaW1hbCA9IERlY2ltYWxcblxuLyoqXG4gKiBSZS1leHBvcnQgb2Ygc3FsLXRlbXBsYXRlLXRhZ1xuICovXG5QcmlzbWEuc3FsID0gc3FsdGFnXG5QcmlzbWEuZW1wdHkgPSBlbXB0eVxuUHJpc21hLmpvaW4gPSBqb2luXG5QcmlzbWEucmF3ID0gcmF3XG5QcmlzbWEudmFsaWRhdG9yID0gKCkgPT4gKHZhbCkgPT4gdmFsXG5cbi8qKlxuICogU2hvcnRoYW5kIHV0aWxpdGllcyBmb3IgSlNPTiBmaWx0ZXJpbmdcbiAqL1xuUHJpc21hLkRiTnVsbCA9IG9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzLkRiTnVsbFxuUHJpc21hLkpzb25OdWxsID0gb2JqZWN0RW51bVZhbHVlcy5pbnN0YW5jZXMuSnNvbk51bGxcblByaXNtYS5BbnlOdWxsID0gb2JqZWN0RW51bVZhbHVlcy5pbnN0YW5jZXMuQW55TnVsbFxuXG5QcmlzbWEuTnVsbFR5cGVzID0ge1xuICBEYk51bGw6IG9iamVjdEVudW1WYWx1ZXMuY2xhc3Nlcy5EYk51bGwsXG4gIEpzb25OdWxsOiBvYmplY3RFbnVtVmFsdWVzLmNsYXNzZXMuSnNvbk51bGwsXG4gIEFueU51bGw6IG9iamVjdEVudW1WYWx1ZXMuY2xhc3Nlcy5BbnlOdWxsXG59XG5cblxuICBjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHsgZmluZFN5bmMgfSA9IHJlcXVpcmUoJ0BwcmlzbWEvY2xpZW50L3J1bnRpbWUnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbi8vIHNvbWUgZnJhbWV3b3JrcyBvciBidW5kbGVycyByZXBsYWNlIG9yIHRvdGFsbHkgcmVtb3ZlIF9fZGlybmFtZVxuY29uc3QgaGFzRGlybmFtZSA9IHR5cGVvZiBfX2Rpcm5hbWUgIT09ICd1bmRlZmluZWQnICYmIF9fZGlybmFtZSAhPT0gJy8nXG5cbi8vIHdpbGwgd29yayBpbiBtb3N0IGNhc2VzLCBpZS4gaWYgdGhlIGNsaWVudCBoYXMgbm90IGJlZW4gYnVuZGxlZFxuY29uc3QgcmVndWxhckRpcm5hbWUgPSBoYXNEaXJuYW1lICYmIGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgJ3NjaGVtYS5wcmlzbWEnKSkgJiYgX19kaXJuYW1lXG5cbi8vIGlmIHRoZSBjbGllbnQgaGFzIGJlZW4gYnVuZGxlZCwgd2UgbmVlZCB0byBsb29rIGZvciB0aGUgZm9sZGVyc1xuY29uc3QgZm91bmREaXJuYW1lID0gIXJlZ3VsYXJEaXJuYW1lICYmIGZpbmRTeW5jKHByb2Nlc3MuY3dkKCksIFtcbiAgICBcIm5vZGVfbW9kdWxlcy8ucHJpc21hL2NsaWVudFwiLFxuICAgIFwiLnByaXNtYS9jbGllbnRcIixcbl0sIFsnZCddLCBbJ2QnXSwgMSlbMF1cblxuY29uc3QgZGlybmFtZSA9IHJlZ3VsYXJEaXJuYW1lIHx8IGZvdW5kRGlybmFtZSB8fCBfX2Rpcm5hbWVcblxuLyoqXG4gKiBFbnVtc1xuICovXG4vLyBCYXNlZCBvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTkyI2lzc3VlY29tbWVudC0yNjE3MjAyNzVcbmZ1bmN0aW9uIG1ha2VFbnVtKHgpIHsgcmV0dXJuIHg7IH1cblxuZXhwb3J0cy5QcmlzbWEuT3JkZXJTY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBjcmVhdGVkQXQ6ICdjcmVhdGVkQXQnLFxuICB1cGRhdGVkQXQ6ICd1cGRhdGVkQXQnLFxuICBwcm9kdWN0czogJ3Byb2R1Y3RzJyxcbiAgYnV5ZXJJZDogJ2J1eWVySWQnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuUXVlcnlNb2RlID0gbWFrZUVudW0oe1xuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGluc2Vuc2l0aXZlOiAnaW5zZW5zaXRpdmUnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuU29ydE9yZGVyID0gbWFrZUVudW0oe1xuICBhc2M6ICdhc2MnLFxuICBkZXNjOiAnZGVzYydcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5UcmFuc2FjdGlvbklzb2xhdGlvbkxldmVsID0gbWFrZVN0cmljdEVudW0oe1xuICBSZWFkVW5jb21taXR0ZWQ6ICdSZWFkVW5jb21taXR0ZWQnLFxuICBSZWFkQ29tbWl0dGVkOiAnUmVhZENvbW1pdHRlZCcsXG4gIFJlcGVhdGFibGVSZWFkOiAnUmVwZWF0YWJsZVJlYWQnLFxuICBTZXJpYWxpemFibGU6ICdTZXJpYWxpemFibGUnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuVXNlclNjYWxhckZpZWxkRW51bSA9IG1ha2VFbnVtKHtcbiAgaWQ6ICdpZCcsXG4gIHVzZXJuYW1lOiAndXNlcm5hbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgbmFtZTogJ25hbWUnLFxuICBzdXJuYW1lOiAnc3VybmFtZSdcbn0pO1xuXG5cbmV4cG9ydHMuUHJpc21hLk1vZGVsTmFtZSA9IG1ha2VFbnVtKHtcbiAgVXNlcjogJ1VzZXInLFxuICBPcmRlcjogJ09yZGVyJ1xufSk7XG5cbmNvbnN0IGRtbWZTdHJpbmcgPSBcIntcXFwiZGF0YW1vZGVsXFxcIjp7XFxcImVudW1zXFxcIjpbXSxcXFwibW9kZWxzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiVXNlclxcXCIsXFxcImRiTmFtZVxcXCI6XFxcInVzZXJzXFxcIixcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOltdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInVzZXJuYW1lXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjp0cnVlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwidGl0bGVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwibmFtZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJzdXJuYW1lXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcIm9yZGVyc1xcXCIsXFxcImtpbmRcXFwiOlxcXCJvYmplY3RcXFwiLFxcXCJpc0xpc3RcXFwiOnRydWUsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiT3JkZXJcXFwiLFxcXCJyZWxhdGlvbk5hbWVcXFwiOlxcXCJPcmRlclRvVXNlclxcXCIsXFxcInJlbGF0aW9uRnJvbUZpZWxkc1xcXCI6W10sXFxcInJlbGF0aW9uVG9GaWVsZHNcXFwiOltdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX1dLFxcXCJwcmltYXJ5S2V5XFxcIjpudWxsLFxcXCJ1bmlxdWVGaWVsZHNcXFwiOltdLFxcXCJ1bmlxdWVJbmRleGVzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJPcmRlclxcXCIsXFxcImRiTmFtZVxcXCI6bnVsbCxcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOltdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImNyZWF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJub3dcXFwiLFxcXCJhcmdzXFxcIjpbXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJ1cGRhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOnRydWV9LHtcXFwibmFtZVxcXCI6XFxcInByb2R1Y3RzXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImJ1eWVyXFxcIixcXFwia2luZFxcXCI6XFxcIm9iamVjdFxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOmZhbHNlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlVzZXJcXFwiLFxcXCJyZWxhdGlvbk5hbWVcXFwiOlxcXCJPcmRlclRvVXNlclxcXCIsXFxcInJlbGF0aW9uRnJvbUZpZWxkc1xcXCI6W1xcXCJidXllcklkXFxcIl0sXFxcInJlbGF0aW9uVG9GaWVsZHNcXFwiOltcXFwiaWRcXFwiXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImJ1eWVySWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6ZmFsc2UsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOnRydWUsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX1dLFxcXCJwcmltYXJ5S2V5XFxcIjpudWxsLFxcXCJ1bmlxdWVGaWVsZHNcXFwiOltdLFxcXCJ1bmlxdWVJbmRleGVzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlfV0sXFxcInR5cGVzXFxcIjpbXX0sXFxcIm1hcHBpbmdzXFxcIjp7XFxcIm1vZGVsT3BlcmF0aW9uc1xcXCI6W3tcXFwibW9kZWxcXFwiOlxcXCJVc2VyXFxcIixcXFwicGx1cmFsXFxcIjpcXFwidXNlcnNcXFwiLFxcXCJmaW5kVW5pcXVlXFxcIjpcXFwiZmluZFVuaXF1ZVVzZXJcXFwiLFxcXCJmaW5kRmlyc3RcXFwiOlxcXCJmaW5kRmlyc3RVc2VyXFxcIixcXFwiZmluZE1hbnlcXFwiOlxcXCJmaW5kTWFueVVzZXJcXFwiLFxcXCJjcmVhdGVcXFwiOlxcXCJjcmVhdGVPbmVVc2VyXFxcIixcXFwiY3JlYXRlTWFueVxcXCI6XFxcImNyZWF0ZU1hbnlVc2VyXFxcIixcXFwiZGVsZXRlXFxcIjpcXFwiZGVsZXRlT25lVXNlclxcXCIsXFxcInVwZGF0ZVxcXCI6XFxcInVwZGF0ZU9uZVVzZXJcXFwiLFxcXCJkZWxldGVNYW55XFxcIjpcXFwiZGVsZXRlTWFueVVzZXJcXFwiLFxcXCJ1cGRhdGVNYW55XFxcIjpcXFwidXBkYXRlTWFueVVzZXJcXFwiLFxcXCJ1cHNlcnRcXFwiOlxcXCJ1cHNlcnRPbmVVc2VyXFxcIixcXFwiYWdncmVnYXRlXFxcIjpcXFwiYWdncmVnYXRlVXNlclxcXCIsXFxcImdyb3VwQnlcXFwiOlxcXCJncm91cEJ5VXNlclxcXCJ9LHtcXFwibW9kZWxcXFwiOlxcXCJPcmRlclxcXCIsXFxcInBsdXJhbFxcXCI6XFxcIm9yZGVyc1xcXCIsXFxcImZpbmRVbmlxdWVcXFwiOlxcXCJmaW5kVW5pcXVlT3JkZXJcXFwiLFxcXCJmaW5kRmlyc3RcXFwiOlxcXCJmaW5kRmlyc3RPcmRlclxcXCIsXFxcImZpbmRNYW55XFxcIjpcXFwiZmluZE1hbnlPcmRlclxcXCIsXFxcImNyZWF0ZVxcXCI6XFxcImNyZWF0ZU9uZU9yZGVyXFxcIixcXFwiY3JlYXRlTWFueVxcXCI6XFxcImNyZWF0ZU1hbnlPcmRlclxcXCIsXFxcImRlbGV0ZVxcXCI6XFxcImRlbGV0ZU9uZU9yZGVyXFxcIixcXFwidXBkYXRlXFxcIjpcXFwidXBkYXRlT25lT3JkZXJcXFwiLFxcXCJkZWxldGVNYW55XFxcIjpcXFwiZGVsZXRlTWFueU9yZGVyXFxcIixcXFwidXBkYXRlTWFueVxcXCI6XFxcInVwZGF0ZU1hbnlPcmRlclxcXCIsXFxcInVwc2VydFxcXCI6XFxcInVwc2VydE9uZU9yZGVyXFxcIixcXFwiYWdncmVnYXRlXFxcIjpcXFwiYWdncmVnYXRlT3JkZXJcXFwiLFxcXCJncm91cEJ5XFxcIjpcXFwiZ3JvdXBCeU9yZGVyXFxcIn1dLFxcXCJvdGhlck9wZXJhdGlvbnNcXFwiOntcXFwicmVhZFxcXCI6W10sXFxcIndyaXRlXFxcIjpbXFxcImV4ZWN1dGVSYXdcXFwiLFxcXCJxdWVyeVJhd1xcXCJdfX19XCJcbmNvbnN0IGRtbWYgPSBKU09OLnBhcnNlKGRtbWZTdHJpbmcpXG5leHBvcnRzLlByaXNtYS5kbW1mID0gSlNPTi5wYXJzZShkbW1mU3RyaW5nKVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgQ2xpZW50XG4gKi9cbmNvbnN0IGNvbmZpZyA9IHtcbiAgXCJnZW5lcmF0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcImNsaWVudFwiLFxuICAgIFwicHJvdmlkZXJcIjoge1xuICAgICAgXCJmcm9tRW52VmFyXCI6IG51bGwsXG4gICAgICBcInZhbHVlXCI6IFwicHJpc21hLWNsaWVudC1qc1wiXG4gICAgfSxcbiAgICBcIm91dHB1dFwiOiB7XG4gICAgICBcInZhbHVlXCI6IFwiL1VzZXJzL2FyaXN0b3NtYXJrb2dpYW5uYWtpcy9Qcm9qZWN0cy9jb25mZXJlbmNlL2FsaWNhbnRlLW1pY3JvZnJvbnRlbmRzLWRlbW8yL29yZGVycy9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnRcIixcbiAgICAgIFwiZnJvbUVudlZhclwiOiBudWxsXG4gICAgfSxcbiAgICBcImNvbmZpZ1wiOiB7XG4gICAgICBcImVuZ2luZVR5cGVcIjogXCJsaWJyYXJ5XCJcbiAgICB9LFxuICAgIFwiYmluYXJ5VGFyZ2V0c1wiOiBbXSxcbiAgICBcInByZXZpZXdGZWF0dXJlc1wiOiBbXVxuICB9LFxuICBcInJlbGF0aXZlRW52UGF0aHNcIjoge1xuICAgIFwicm9vdEVudlBhdGhcIjogXCIuLi8uLi8uLi8uZW52XCIsXG4gICAgXCJzY2hlbWFFbnZQYXRoXCI6IFwiLi4vLi4vLi4vLmVudlwiXG4gIH0sXG4gIFwicmVsYXRpdmVQYXRoXCI6IFwiLi4vLi4vLi4vcHJpc21hXCIsXG4gIFwiY2xpZW50VmVyc2lvblwiOiBcIjQuMy4xXCIsXG4gIFwiZW5naW5lVmVyc2lvblwiOiBcImM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIixcbiAgXCJkYXRhc291cmNlTmFtZXNcIjogW1xuICAgIFwiZGJcIlxuICBdLFxuICBcImFjdGl2ZVByb3ZpZGVyXCI6IFwicG9zdGdyZXNxbFwiLFxuICBcImRhdGFQcm94eVwiOiBmYWxzZVxufVxuY29uZmlnLmRvY3VtZW50ID0gZG1tZlxuY29uZmlnLmRpcm5hbWUgPSBkaXJuYW1lXG5cblxuXG5cbmNvbnN0IHsgd2FybkVudkNvbmZsaWN0cyB9ID0gcmVxdWlyZSgnQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleCcpXG5cbndhcm5FbnZDb25mbGljdHMoe1xuICAgIHJvb3RFbnZQYXRoOiBjb25maWcucmVsYXRpdmVFbnZQYXRocy5yb290RW52UGF0aCAmJiBwYXRoLnJlc29sdmUoZGlybmFtZSwgY29uZmlnLnJlbGF0aXZlRW52UGF0aHMucm9vdEVudlBhdGgpLFxuICAgIHNjaGVtYUVudlBhdGg6IGNvbmZpZy5yZWxhdGl2ZUVudlBhdGhzLnNjaGVtYUVudlBhdGggJiYgcGF0aC5yZXNvbHZlKGRpcm5hbWUsIGNvbmZpZy5yZWxhdGl2ZUVudlBhdGhzLnNjaGVtYUVudlBhdGgpXG59KVxuXG5jb25zdCBQcmlzbWFDbGllbnQgPSBnZXRQcmlzbWFDbGllbnQoY29uZmlnKVxuZXhwb3J0cy5QcmlzbWFDbGllbnQgPSBQcmlzbWFDbGllbnRcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgUHJpc21hKVxuXG5wYXRoLmpvaW4oX19kaXJuYW1lLCBcImxpYnF1ZXJ5X2VuZ2luZS1kYXJ3aW4tYXJtNjQuZHlsaWIubm9kZVwiKTtcbnBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBcIm5vZGVfbW9kdWxlcy8ucHJpc21hL2NsaWVudC9saWJxdWVyeV9lbmdpbmUtZGFyd2luLWFybTY0LmR5bGliLm5vZGVcIilcbnBhdGguam9pbihfX2Rpcm5hbWUsIFwic2NoZW1hLnByaXNtYVwiKTtcbnBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBcIm5vZGVfbW9kdWxlcy8ucHJpc21hL2NsaWVudC9zY2hlbWEucHJpc21hXCIpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.prisma/client/index.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@prisma/client/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n  ...__webpack_require__(/*! .prisma/client/index */ \"./node_modules/.prisma/client/index.js\"),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxLQUFLLG1CQUFPLENBQUMsb0VBQXNCO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JkZXJzLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50L2luZGV4LmpzPzMxYjUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC4uLnJlcXVpcmUoJy5wcmlzbWEvY2xpZW50L2luZGV4JyksXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/index.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/runtime/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// ../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js\nvar require_lz_string = __commonJS({\n  \"../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js\"(exports, module2) {\n    var LZString = function() {\n      var f = String.fromCharCode;\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n      var baseReverseDic = {};\n      function getBaseValue(alphabet, character) {\n        if (!baseReverseDic[alphabet]) {\n          baseReverseDic[alphabet] = {};\n          for (var i = 0; i < alphabet.length; i++) {\n            baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n          }\n        }\n        return baseReverseDic[alphabet][character];\n      }\n      __name(getBaseValue, \"getBaseValue\");\n      var LZString2 = {\n        compressToBase64: function(input) {\n          if (input == null)\n            return \"\";\n          var res = LZString2._compress(input, 6, function(a) {\n            return keyStrBase64.charAt(a);\n          });\n          switch (res.length % 4) {\n            default:\n            case 0:\n              return res;\n            case 1:\n              return res + \"===\";\n            case 2:\n              return res + \"==\";\n            case 3:\n              return res + \"=\";\n          }\n        },\n        decompressFromBase64: function(input) {\n          if (input == null)\n            return \"\";\n          if (input == \"\")\n            return null;\n          return LZString2._decompress(input.length, 32, function(index) {\n            return getBaseValue(keyStrBase64, input.charAt(index));\n          });\n        },\n        compressToUTF16: function(input) {\n          if (input == null)\n            return \"\";\n          return LZString2._compress(input, 15, function(a) {\n            return f(a + 32);\n          }) + \" \";\n        },\n        decompressFromUTF16: function(compressed) {\n          if (compressed == null)\n            return \"\";\n          if (compressed == \"\")\n            return null;\n          return LZString2._decompress(compressed.length, 16384, function(index) {\n            return compressed.charCodeAt(index) - 32;\n          });\n        },\n        compressToUint8Array: function(uncompressed) {\n          var compressed = LZString2.compress(uncompressed);\n          var buf = new Uint8Array(compressed.length * 2);\n          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {\n            var current_value = compressed.charCodeAt(i);\n            buf[i * 2] = current_value >>> 8;\n            buf[i * 2 + 1] = current_value % 256;\n          }\n          return buf;\n        },\n        decompressFromUint8Array: function(compressed) {\n          if (compressed === null || compressed === void 0) {\n            return LZString2.decompress(compressed);\n          } else {\n            var buf = new Array(compressed.length / 2);\n            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {\n              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];\n            }\n            var result = [];\n            buf.forEach(function(c) {\n              result.push(f(c));\n            });\n            return LZString2.decompress(result.join(\"\"));\n          }\n        },\n        compressToEncodedURIComponent: function(input) {\n          if (input == null)\n            return \"\";\n          return LZString2._compress(input, 6, function(a) {\n            return keyStrUriSafe.charAt(a);\n          });\n        },\n        decompressFromEncodedURIComponent: function(input) {\n          if (input == null)\n            return \"\";\n          if (input == \"\")\n            return null;\n          input = input.replace(/ /g, \"+\");\n          return LZString2._decompress(input.length, 32, function(index) {\n            return getBaseValue(keyStrUriSafe, input.charAt(index));\n          });\n        },\n        compress: function(uncompressed) {\n          return LZString2._compress(uncompressed, 16, function(a) {\n            return f(a);\n          });\n        },\n        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {\n          if (uncompressed == null)\n            return \"\";\n          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = \"\", context_wc = \"\", context_w = \"\", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;\n          for (ii = 0; ii < uncompressed.length; ii += 1) {\n            context_c = uncompressed.charAt(ii);\n            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {\n              context_dictionary[context_c] = context_dictSize++;\n              context_dictionaryToCreate[context_c] = true;\n            }\n            context_wc = context_w + context_c;\n            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {\n              context_w = context_wc;\n            } else {\n              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n                if (context_w.charCodeAt(0) < 256) {\n                  for (i = 0; i < context_numBits; i++) {\n                    context_data_val = context_data_val << 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                  }\n                  value = context_w.charCodeAt(0);\n                  for (i = 0; i < 8; i++) {\n                    context_data_val = context_data_val << 1 | value & 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = value >> 1;\n                  }\n                } else {\n                  value = 1;\n                  for (i = 0; i < context_numBits; i++) {\n                    context_data_val = context_data_val << 1 | value;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = 0;\n                  }\n                  value = context_w.charCodeAt(0);\n                  for (i = 0; i < 16; i++) {\n                    context_data_val = context_data_val << 1 | value & 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                      context_data_position = 0;\n                      context_data.push(getCharFromInt(context_data_val));\n                      context_data_val = 0;\n                    } else {\n                      context_data_position++;\n                    }\n                    value = value >> 1;\n                  }\n                }\n                context_enlargeIn--;\n                if (context_enlargeIn == 0) {\n                  context_enlargeIn = Math.pow(2, context_numBits);\n                  context_numBits++;\n                }\n                delete context_dictionaryToCreate[context_w];\n              } else {\n                value = context_dictionary[context_w];\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              }\n              context_enlargeIn--;\n              if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n              }\n              context_dictionary[context_wc] = context_dictSize++;\n              context_w = String(context_c);\n            }\n          }\n          if (context_w !== \"\") {\n            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n              if (context_w.charCodeAt(0) < 256) {\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 8; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              } else {\n                value = 1;\n                for (i = 0; i < context_numBits; i++) {\n                  context_data_val = context_data_val << 1 | value;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = 0;\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 16; i++) {\n                  context_data_val = context_data_val << 1 | value & 1;\n                  if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                  } else {\n                    context_data_position++;\n                  }\n                  value = value >> 1;\n                }\n              }\n              context_enlargeIn--;\n              if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n              }\n              delete context_dictionaryToCreate[context_w];\n            } else {\n              value = context_dictionary[context_w];\n              for (i = 0; i < context_numBits; i++) {\n                context_data_val = context_data_val << 1 | value & 1;\n                if (context_data_position == bitsPerChar - 1) {\n                  context_data_position = 0;\n                  context_data.push(getCharFromInt(context_data_val));\n                  context_data_val = 0;\n                } else {\n                  context_data_position++;\n                }\n                value = value >> 1;\n              }\n            }\n            context_enlargeIn--;\n            if (context_enlargeIn == 0) {\n              context_enlargeIn = Math.pow(2, context_numBits);\n              context_numBits++;\n            }\n          }\n          value = 2;\n          for (i = 0; i < context_numBits; i++) {\n            context_data_val = context_data_val << 1 | value & 1;\n            if (context_data_position == bitsPerChar - 1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n          while (true) {\n            context_data_val = context_data_val << 1;\n            if (context_data_position == bitsPerChar - 1) {\n              context_data.push(getCharFromInt(context_data_val));\n              break;\n            } else\n              context_data_position++;\n          }\n          return context_data.join(\"\");\n        },\n        decompress: function(compressed) {\n          if (compressed == null)\n            return \"\";\n          if (compressed == \"\")\n            return null;\n          return LZString2._decompress(compressed.length, 32768, function(index) {\n            return compressed.charCodeAt(index);\n          });\n        },\n        _decompress: function(length, resetValue, getNextValue) {\n          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = \"\", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };\n          for (i = 0; i < 3; i += 1) {\n            dictionary[i] = i;\n          }\n          bits = 0;\n          maxpower = Math.pow(2, 2);\n          power = 1;\n          while (power != maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb > 0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          switch (next = bits) {\n            case 0:\n              bits = 0;\n              maxpower = Math.pow(2, 8);\n              power = 1;\n              while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                  data.position = resetValue;\n                  data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n              }\n              c = f(bits);\n              break;\n            case 1:\n              bits = 0;\n              maxpower = Math.pow(2, 16);\n              power = 1;\n              while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                  data.position = resetValue;\n                  data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n              }\n              c = f(bits);\n              break;\n            case 2:\n              return \"\";\n          }\n          dictionary[3] = c;\n          w = c;\n          result.push(c);\n          while (true) {\n            if (data.index > length) {\n              return \"\";\n            }\n            bits = 0;\n            maxpower = Math.pow(2, numBits);\n            power = 1;\n            while (power != maxpower) {\n              resb = data.val & data.position;\n              data.position >>= 1;\n              if (data.position == 0) {\n                data.position = resetValue;\n                data.val = getNextValue(data.index++);\n              }\n              bits |= (resb > 0 ? 1 : 0) * power;\n              power <<= 1;\n            }\n            switch (c = bits) {\n              case 0:\n                bits = 0;\n                maxpower = Math.pow(2, 8);\n                power = 1;\n                while (power != maxpower) {\n                  resb = data.val & data.position;\n                  data.position >>= 1;\n                  if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                  }\n                  bits |= (resb > 0 ? 1 : 0) * power;\n                  power <<= 1;\n                }\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n              case 1:\n                bits = 0;\n                maxpower = Math.pow(2, 16);\n                power = 1;\n                while (power != maxpower) {\n                  resb = data.val & data.position;\n                  data.position >>= 1;\n                  if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                  }\n                  bits |= (resb > 0 ? 1 : 0) * power;\n                  power <<= 1;\n                }\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n              case 2:\n                return result.join(\"\");\n            }\n            if (enlargeIn == 0) {\n              enlargeIn = Math.pow(2, numBits);\n              numBits++;\n            }\n            if (dictionary[c]) {\n              entry = dictionary[c];\n            } else {\n              if (c === dictSize) {\n                entry = w + w.charAt(0);\n              } else {\n                return null;\n              }\n            }\n            result.push(entry);\n            dictionary[dictSize++] = w + entry.charAt(0);\n            enlargeIn--;\n            w = entry;\n            if (enlargeIn == 0) {\n              enlargeIn = Math.pow(2, numBits);\n              numBits++;\n            }\n          }\n        }\n      };\n      return LZString2;\n    }();\n    if (false) {} else if (typeof module2 !== \"undefined\" && module2 != null) {\n      module2.exports = LZString;\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js\nvar require_color_name = __commonJS({\n  \"../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      \"aliceblue\": [240, 248, 255],\n      \"antiquewhite\": [250, 235, 215],\n      \"aqua\": [0, 255, 255],\n      \"aquamarine\": [127, 255, 212],\n      \"azure\": [240, 255, 255],\n      \"beige\": [245, 245, 220],\n      \"bisque\": [255, 228, 196],\n      \"black\": [0, 0, 0],\n      \"blanchedalmond\": [255, 235, 205],\n      \"blue\": [0, 0, 255],\n      \"blueviolet\": [138, 43, 226],\n      \"brown\": [165, 42, 42],\n      \"burlywood\": [222, 184, 135],\n      \"cadetblue\": [95, 158, 160],\n      \"chartreuse\": [127, 255, 0],\n      \"chocolate\": [210, 105, 30],\n      \"coral\": [255, 127, 80],\n      \"cornflowerblue\": [100, 149, 237],\n      \"cornsilk\": [255, 248, 220],\n      \"crimson\": [220, 20, 60],\n      \"cyan\": [0, 255, 255],\n      \"darkblue\": [0, 0, 139],\n      \"darkcyan\": [0, 139, 139],\n      \"darkgoldenrod\": [184, 134, 11],\n      \"darkgray\": [169, 169, 169],\n      \"darkgreen\": [0, 100, 0],\n      \"darkgrey\": [169, 169, 169],\n      \"darkkhaki\": [189, 183, 107],\n      \"darkmagenta\": [139, 0, 139],\n      \"darkolivegreen\": [85, 107, 47],\n      \"darkorange\": [255, 140, 0],\n      \"darkorchid\": [153, 50, 204],\n      \"darkred\": [139, 0, 0],\n      \"darksalmon\": [233, 150, 122],\n      \"darkseagreen\": [143, 188, 143],\n      \"darkslateblue\": [72, 61, 139],\n      \"darkslategray\": [47, 79, 79],\n      \"darkslategrey\": [47, 79, 79],\n      \"darkturquoise\": [0, 206, 209],\n      \"darkviolet\": [148, 0, 211],\n      \"deeppink\": [255, 20, 147],\n      \"deepskyblue\": [0, 191, 255],\n      \"dimgray\": [105, 105, 105],\n      \"dimgrey\": [105, 105, 105],\n      \"dodgerblue\": [30, 144, 255],\n      \"firebrick\": [178, 34, 34],\n      \"floralwhite\": [255, 250, 240],\n      \"forestgreen\": [34, 139, 34],\n      \"fuchsia\": [255, 0, 255],\n      \"gainsboro\": [220, 220, 220],\n      \"ghostwhite\": [248, 248, 255],\n      \"gold\": [255, 215, 0],\n      \"goldenrod\": [218, 165, 32],\n      \"gray\": [128, 128, 128],\n      \"green\": [0, 128, 0],\n      \"greenyellow\": [173, 255, 47],\n      \"grey\": [128, 128, 128],\n      \"honeydew\": [240, 255, 240],\n      \"hotpink\": [255, 105, 180],\n      \"indianred\": [205, 92, 92],\n      \"indigo\": [75, 0, 130],\n      \"ivory\": [255, 255, 240],\n      \"khaki\": [240, 230, 140],\n      \"lavender\": [230, 230, 250],\n      \"lavenderblush\": [255, 240, 245],\n      \"lawngreen\": [124, 252, 0],\n      \"lemonchiffon\": [255, 250, 205],\n      \"lightblue\": [173, 216, 230],\n      \"lightcoral\": [240, 128, 128],\n      \"lightcyan\": [224, 255, 255],\n      \"lightgoldenrodyellow\": [250, 250, 210],\n      \"lightgray\": [211, 211, 211],\n      \"lightgreen\": [144, 238, 144],\n      \"lightgrey\": [211, 211, 211],\n      \"lightpink\": [255, 182, 193],\n      \"lightsalmon\": [255, 160, 122],\n      \"lightseagreen\": [32, 178, 170],\n      \"lightskyblue\": [135, 206, 250],\n      \"lightslategray\": [119, 136, 153],\n      \"lightslategrey\": [119, 136, 153],\n      \"lightsteelblue\": [176, 196, 222],\n      \"lightyellow\": [255, 255, 224],\n      \"lime\": [0, 255, 0],\n      \"limegreen\": [50, 205, 50],\n      \"linen\": [250, 240, 230],\n      \"magenta\": [255, 0, 255],\n      \"maroon\": [128, 0, 0],\n      \"mediumaquamarine\": [102, 205, 170],\n      \"mediumblue\": [0, 0, 205],\n      \"mediumorchid\": [186, 85, 211],\n      \"mediumpurple\": [147, 112, 219],\n      \"mediumseagreen\": [60, 179, 113],\n      \"mediumslateblue\": [123, 104, 238],\n      \"mediumspringgreen\": [0, 250, 154],\n      \"mediumturquoise\": [72, 209, 204],\n      \"mediumvioletred\": [199, 21, 133],\n      \"midnightblue\": [25, 25, 112],\n      \"mintcream\": [245, 255, 250],\n      \"mistyrose\": [255, 228, 225],\n      \"moccasin\": [255, 228, 181],\n      \"navajowhite\": [255, 222, 173],\n      \"navy\": [0, 0, 128],\n      \"oldlace\": [253, 245, 230],\n      \"olive\": [128, 128, 0],\n      \"olivedrab\": [107, 142, 35],\n      \"orange\": [255, 165, 0],\n      \"orangered\": [255, 69, 0],\n      \"orchid\": [218, 112, 214],\n      \"palegoldenrod\": [238, 232, 170],\n      \"palegreen\": [152, 251, 152],\n      \"paleturquoise\": [175, 238, 238],\n      \"palevioletred\": [219, 112, 147],\n      \"papayawhip\": [255, 239, 213],\n      \"peachpuff\": [255, 218, 185],\n      \"peru\": [205, 133, 63],\n      \"pink\": [255, 192, 203],\n      \"plum\": [221, 160, 221],\n      \"powderblue\": [176, 224, 230],\n      \"purple\": [128, 0, 128],\n      \"rebeccapurple\": [102, 51, 153],\n      \"red\": [255, 0, 0],\n      \"rosybrown\": [188, 143, 143],\n      \"royalblue\": [65, 105, 225],\n      \"saddlebrown\": [139, 69, 19],\n      \"salmon\": [250, 128, 114],\n      \"sandybrown\": [244, 164, 96],\n      \"seagreen\": [46, 139, 87],\n      \"seashell\": [255, 245, 238],\n      \"sienna\": [160, 82, 45],\n      \"silver\": [192, 192, 192],\n      \"skyblue\": [135, 206, 235],\n      \"slateblue\": [106, 90, 205],\n      \"slategray\": [112, 128, 144],\n      \"slategrey\": [112, 128, 144],\n      \"snow\": [255, 250, 250],\n      \"springgreen\": [0, 255, 127],\n      \"steelblue\": [70, 130, 180],\n      \"tan\": [210, 180, 140],\n      \"teal\": [0, 128, 128],\n      \"thistle\": [216, 191, 216],\n      \"tomato\": [255, 99, 71],\n      \"turquoise\": [64, 224, 208],\n      \"violet\": [238, 130, 238],\n      \"wheat\": [245, 222, 179],\n      \"white\": [255, 255, 255],\n      \"whitesmoke\": [245, 245, 245],\n      \"yellow\": [255, 255, 0],\n      \"yellowgreen\": [154, 205, 50]\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js\nvar require_conversions = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js\"(exports, module2) {\n    var cssKeywords = require_color_name();\n    var reverseKeywords = {};\n    for (const key of Object.keys(cssKeywords)) {\n      reverseKeywords[cssKeywords[key]] = key;\n    }\n    var convert = {\n      rgb: { channels: 3, labels: \"rgb\" },\n      hsl: { channels: 3, labels: \"hsl\" },\n      hsv: { channels: 3, labels: \"hsv\" },\n      hwb: { channels: 3, labels: \"hwb\" },\n      cmyk: { channels: 4, labels: \"cmyk\" },\n      xyz: { channels: 3, labels: \"xyz\" },\n      lab: { channels: 3, labels: \"lab\" },\n      lch: { channels: 3, labels: \"lch\" },\n      hex: { channels: 1, labels: [\"hex\"] },\n      keyword: { channels: 1, labels: [\"keyword\"] },\n      ansi16: { channels: 1, labels: [\"ansi16\"] },\n      ansi256: { channels: 1, labels: [\"ansi256\"] },\n      hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n      apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n      gray: { channels: 1, labels: [\"gray\"] }\n    };\n    module2.exports = convert;\n    for (const model of Object.keys(convert)) {\n      if (!(\"channels\" in convert[model])) {\n        throw new Error(\"missing channels property: \" + model);\n      }\n      if (!(\"labels\" in convert[model])) {\n        throw new Error(\"missing channel labels property: \" + model);\n      }\n      if (convert[model].labels.length !== convert[model].channels) {\n        throw new Error(\"channel and label counts mismatch: \" + model);\n      }\n      const { channels, labels } = convert[model];\n      delete convert[model].channels;\n      delete convert[model].labels;\n      Object.defineProperty(convert[model], \"channels\", { value: channels });\n      Object.defineProperty(convert[model], \"labels\", { value: labels });\n    }\n    convert.rgb.hsl = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const min2 = Math.min(r, g, b);\n      const max2 = Math.max(r, g, b);\n      const delta = max2 - min2;\n      let h;\n      let s;\n      if (max2 === min2) {\n        h = 0;\n      } else if (r === max2) {\n        h = (g - b) / delta;\n      } else if (g === max2) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max2) {\n        h = 4 + (r - g) / delta;\n      }\n      h = Math.min(h * 60, 360);\n      if (h < 0) {\n        h += 360;\n      }\n      const l = (min2 + max2) / 2;\n      if (max2 === min2) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max2 + min2);\n      } else {\n        s = delta / (2 - max2 - min2);\n      }\n      return [h, s * 100, l * 100];\n    };\n    convert.rgb.hsv = function(rgb) {\n      let rdif;\n      let gdif;\n      let bdif;\n      let h;\n      let s;\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const v = Math.max(r, g, b);\n      const diff = v - Math.min(r, g, b);\n      const diffc = /* @__PURE__ */ __name(function(c) {\n        return (v - c) / 6 / diff + 1 / 2;\n      }, \"diffc\");\n      if (diff === 0) {\n        h = 0;\n        s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n      return [\n        h * 360,\n        s * 100,\n        v * 100\n      ];\n    };\n    convert.rgb.hwb = function(rgb) {\n      const r = rgb[0];\n      const g = rgb[1];\n      let b = rgb[2];\n      const h = convert.rgb.hsl(rgb)[0];\n      const w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n    convert.rgb.cmyk = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const k = Math.min(1 - r, 1 - g, 1 - b);\n      const c = (1 - r - k) / (1 - k) || 0;\n      const m = (1 - g - k) / (1 - k) || 0;\n      const y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    function comparativeDistance(x, y) {\n      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;\n    }\n    __name(comparativeDistance, \"comparativeDistance\");\n    convert.rgb.keyword = function(rgb) {\n      const reversed = reverseKeywords[rgb];\n      if (reversed) {\n        return reversed;\n      }\n      let currentClosestDistance = Infinity;\n      let currentClosestKeyword;\n      for (const keyword of Object.keys(cssKeywords)) {\n        const value = cssKeywords[keyword];\n        const distance = comparativeDistance(rgb, value);\n        if (distance < currentClosestDistance) {\n          currentClosestDistance = distance;\n          currentClosestKeyword = keyword;\n        }\n      }\n      return currentClosestKeyword;\n    };\n    convert.keyword.rgb = function(keyword) {\n      return cssKeywords[keyword];\n    };\n    convert.rgb.xyz = function(rgb) {\n      let r = rgb[0] / 255;\n      let g = rgb[1] / 255;\n      let b = rgb[2] / 255;\n      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;\n      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;\n      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;\n      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n    convert.rgb.lab = function(rgb) {\n      const xyz = convert.rgb.xyz(rgb);\n      let x = xyz[0];\n      let y = xyz[1];\n      let z = xyz[2];\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n      const l = 116 * y - 16;\n      const a = 500 * (x - y);\n      const b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.hsl.rgb = function(hsl) {\n      const h = hsl[0] / 360;\n      const s = hsl[1] / 100;\n      const l = hsl[2] / 100;\n      let t2;\n      let t3;\n      let val;\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n      const t1 = 2 * l - t2;\n      const rgb = [0, 0, 0];\n      for (let i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n        if (t3 < 0) {\n          t3++;\n        }\n        if (t3 > 1) {\n          t3--;\n        }\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n        rgb[i] = val * 255;\n      }\n      return rgb;\n    };\n    convert.hsl.hsv = function(hsl) {\n      const h = hsl[0];\n      let s = hsl[1] / 100;\n      let l = hsl[2] / 100;\n      let smin = s;\n      const lmin = Math.max(l, 0.01);\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      const v = (l + s) / 2;\n      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n    convert.hsv.rgb = function(hsv) {\n      const h = hsv[0] / 60;\n      const s = hsv[1] / 100;\n      let v = hsv[2] / 100;\n      const hi = Math.floor(h) % 6;\n      const f = h - Math.floor(h);\n      const p = 255 * v * (1 - s);\n      const q = 255 * v * (1 - s * f);\n      const t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n        case 1:\n          return [q, v, p];\n        case 2:\n          return [p, v, t];\n        case 3:\n          return [p, q, v];\n        case 4:\n          return [t, p, v];\n        case 5:\n          return [v, p, q];\n      }\n    };\n    convert.hsv.hsl = function(hsv) {\n      const h = hsv[0];\n      const s = hsv[1] / 100;\n      const v = hsv[2] / 100;\n      const vmin = Math.max(v, 0.01);\n      let sl;\n      let l;\n      l = (2 - s) * v;\n      const lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    };\n    convert.hwb.rgb = function(hwb) {\n      const h = hwb[0] / 360;\n      let wh = hwb[1] / 100;\n      let bl = hwb[2] / 100;\n      const ratio = wh + bl;\n      let f;\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n      const i = Math.floor(6 * h);\n      const v = 1 - bl;\n      f = 6 * h - i;\n      if ((i & 1) !== 0) {\n        f = 1 - f;\n      }\n      const n = wh + f * (v - wh);\n      let r;\n      let g;\n      let b;\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.cmyk.rgb = function(cmyk) {\n      const c = cmyk[0] / 100;\n      const m = cmyk[1] / 100;\n      const y = cmyk[2] / 100;\n      const k = cmyk[3] / 100;\n      const r = 1 - Math.min(1, c * (1 - k) + k);\n      const g = 1 - Math.min(1, m * (1 - k) + k);\n      const b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.rgb = function(xyz) {\n      const x = xyz[0] / 100;\n      const y = xyz[1] / 100;\n      const z = xyz[2] / 100;\n      let r;\n      let g;\n      let b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.204 + z * 1.057;\n      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;\n      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;\n      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.lab = function(xyz) {\n      let x = xyz[0];\n      let y = xyz[1];\n      let z = xyz[2];\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n      const l = 116 * y - 16;\n      const a = 500 * (x - y);\n      const b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.lab.xyz = function(lab) {\n      const l = lab[0];\n      const a = lab[1];\n      const b = lab[2];\n      let x;\n      let y;\n      let z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      const y2 = y ** 3;\n      const x2 = x ** 3;\n      const z2 = z ** 3;\n      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n    convert.lab.lch = function(lab) {\n      const l = lab[0];\n      const a = lab[1];\n      const b = lab[2];\n      let h;\n      const hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n      if (h < 0) {\n        h += 360;\n      }\n      const c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n    convert.lch.lab = function(lch) {\n      const l = lch[0];\n      const c = lch[1];\n      const h = lch[2];\n      const hr = h / 360 * 2 * Math.PI;\n      const a = c * Math.cos(hr);\n      const b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n    convert.rgb.ansi16 = function(args, saturation = null) {\n      const [r, g, b] = args;\n      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;\n      value = Math.round(value / 50);\n      if (value === 0) {\n        return 30;\n      }\n      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n      if (value === 2) {\n        ansi += 60;\n      }\n      return ansi;\n    };\n    convert.hsv.ansi16 = function(args) {\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n    convert.rgb.ansi256 = function(args) {\n      const r = args[0];\n      const g = args[1];\n      const b = args[2];\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n        if (r > 248) {\n          return 231;\n        }\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n    convert.ansi16.rgb = function(args) {\n      let color = args % 10;\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n      const mult = (~~(args > 50) + 1) * 0.5;\n      const r = (color & 1) * mult * 255;\n      const g = (color >> 1 & 1) * mult * 255;\n      const b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n    convert.ansi256.rgb = function(args) {\n      if (args >= 232) {\n        const c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n      args -= 16;\n      let rem;\n      const r = Math.floor(args / 36) / 5 * 255;\n      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      const b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n    convert.rgb.hex = function(args) {\n      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);\n      const string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.hex.rgb = function(args) {\n      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n      if (!match) {\n        return [0, 0, 0];\n      }\n      let colorString = match[0];\n      if (match[0].length === 3) {\n        colorString = colorString.split(\"\").map((char) => {\n          return char + char;\n        }).join(\"\");\n      }\n      const integer = parseInt(colorString, 16);\n      const r = integer >> 16 & 255;\n      const g = integer >> 8 & 255;\n      const b = integer & 255;\n      return [r, g, b];\n    };\n    convert.rgb.hcg = function(rgb) {\n      const r = rgb[0] / 255;\n      const g = rgb[1] / 255;\n      const b = rgb[2] / 255;\n      const max2 = Math.max(Math.max(r, g), b);\n      const min2 = Math.min(Math.min(r, g), b);\n      const chroma = max2 - min2;\n      let grayscale;\n      let hue;\n      if (chroma < 1) {\n        grayscale = min2 / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max2 === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max2 === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma;\n      }\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n    convert.hsl.hcg = function(hsl) {\n      const s = hsl[1] / 100;\n      const l = hsl[2] / 100;\n      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);\n      let f = 0;\n      if (c < 1) {\n        f = (l - 0.5 * c) / (1 - c);\n      }\n      return [hsl[0], c * 100, f * 100];\n    };\n    convert.hsv.hcg = function(hsv) {\n      const s = hsv[1] / 100;\n      const v = hsv[2] / 100;\n      const c = s * v;\n      let f = 0;\n      if (c < 1) {\n        f = (v - c) / (1 - c);\n      }\n      return [hsv[0], c * 100, f * 100];\n    };\n    convert.hcg.rgb = function(hcg) {\n      const h = hcg[0] / 360;\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      if (c === 0) {\n        return [g * 255, g * 255, g * 255];\n      }\n      const pure = [0, 0, 0];\n      const hi = h % 1 * 6;\n      const v = hi % 1;\n      const w = 1 - v;\n      let mg = 0;\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n      mg = (1 - c) * g;\n      return [\n        (c * pure[0] + mg) * 255,\n        (c * pure[1] + mg) * 255,\n        (c * pure[2] + mg) * 255\n      ];\n    };\n    convert.hcg.hsv = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const v = c + g * (1 - c);\n      let f = 0;\n      if (v > 0) {\n        f = c / v;\n      }\n      return [hcg[0], f * 100, v * 100];\n    };\n    convert.hcg.hsl = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const l = g * (1 - c) + 0.5 * c;\n      let s = 0;\n      if (l > 0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1) {\n        s = c / (2 * (1 - l));\n      }\n      return [hcg[0], s * 100, l * 100];\n    };\n    convert.hcg.hwb = function(hcg) {\n      const c = hcg[1] / 100;\n      const g = hcg[2] / 100;\n      const v = c + g * (1 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n    convert.hwb.hcg = function(hwb) {\n      const w = hwb[1] / 100;\n      const b = hwb[2] / 100;\n      const v = 1 - b;\n      const c = v - w;\n      let g = 0;\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n      return [hwb[0], c * 100, g * 100];\n    };\n    convert.apple.rgb = function(apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n    convert.rgb.apple = function(rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n    convert.gray.rgb = function(args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n    convert.gray.hsl = function(args) {\n      return [0, 0, args[0]];\n    };\n    convert.gray.hsv = convert.gray.hsl;\n    convert.gray.hwb = function(gray) {\n      return [0, 100, gray[0]];\n    };\n    convert.gray.cmyk = function(gray) {\n      return [0, 0, 0, gray[0]];\n    };\n    convert.gray.lab = function(gray) {\n      return [gray[0], 0, 0];\n    };\n    convert.gray.hex = function(gray) {\n      const val = Math.round(gray[0] / 100 * 255) & 255;\n      const integer = (val << 16) + (val << 8) + val;\n      const string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.rgb.gray = function(rgb) {\n      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js\nvar require_route = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js\"(exports, module2) {\n    var conversions = require_conversions();\n    function buildGraph() {\n      const graph = {};\n      const models = Object.keys(conversions);\n      for (let len = models.length, i = 0; i < len; i++) {\n        graph[models[i]] = {\n          distance: -1,\n          parent: null\n        };\n      }\n      return graph;\n    }\n    __name(buildGraph, \"buildGraph\");\n    function deriveBFS(fromModel) {\n      const graph = buildGraph();\n      const queue = [fromModel];\n      graph[fromModel].distance = 0;\n      while (queue.length) {\n        const current = queue.pop();\n        const adjacents = Object.keys(conversions[current]);\n        for (let len = adjacents.length, i = 0; i < len; i++) {\n          const adjacent = adjacents[i];\n          const node = graph[adjacent];\n          if (node.distance === -1) {\n            node.distance = graph[current].distance + 1;\n            node.parent = current;\n            queue.unshift(adjacent);\n          }\n        }\n      }\n      return graph;\n    }\n    __name(deriveBFS, \"deriveBFS\");\n    function link(from, to) {\n      return function(args) {\n        return to(from(args));\n      };\n    }\n    __name(link, \"link\");\n    function wrapConversion(toModel, graph) {\n      const path7 = [graph[toModel].parent, toModel];\n      let fn = conversions[graph[toModel].parent][toModel];\n      let cur = graph[toModel].parent;\n      while (graph[cur].parent) {\n        path7.unshift(graph[cur].parent);\n        fn = link(conversions[graph[cur].parent][cur], fn);\n        cur = graph[cur].parent;\n      }\n      fn.conversion = path7;\n      return fn;\n    }\n    __name(wrapConversion, \"wrapConversion\");\n    module2.exports = function(fromModel) {\n      const graph = deriveBFS(fromModel);\n      const conversion = {};\n      const models = Object.keys(graph);\n      for (let len = models.length, i = 0; i < len; i++) {\n        const toModel = models[i];\n        const node = graph[toModel];\n        if (node.parent === null) {\n          continue;\n        }\n        conversion[toModel] = wrapConversion(toModel, graph);\n      }\n      return conversion;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js\nvar require_color_convert = __commonJS({\n  \"../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js\"(exports, module2) {\n    var conversions = require_conversions();\n    var route = require_route();\n    var convert = {};\n    var models = Object.keys(conversions);\n    function wrapRaw(fn) {\n      const wrappedFn = /* @__PURE__ */ __name(function(...args) {\n        const arg0 = args[0];\n        if (arg0 === void 0 || arg0 === null) {\n          return arg0;\n        }\n        if (arg0.length > 1) {\n          args = arg0;\n        }\n        return fn(args);\n      }, \"wrappedFn\");\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    __name(wrapRaw, \"wrapRaw\");\n    function wrapRounded(fn) {\n      const wrappedFn = /* @__PURE__ */ __name(function(...args) {\n        const arg0 = args[0];\n        if (arg0 === void 0 || arg0 === null) {\n          return arg0;\n        }\n        if (arg0.length > 1) {\n          args = arg0;\n        }\n        const result = fn(args);\n        if (typeof result === \"object\") {\n          for (let len = result.length, i = 0; i < len; i++) {\n            result[i] = Math.round(result[i]);\n          }\n        }\n        return result;\n      }, \"wrappedFn\");\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    __name(wrapRounded, \"wrapRounded\");\n    models.forEach((fromModel) => {\n      convert[fromModel] = {};\n      Object.defineProperty(convert[fromModel], \"channels\", { value: conversions[fromModel].channels });\n      Object.defineProperty(convert[fromModel], \"labels\", { value: conversions[fromModel].labels });\n      const routes = route(fromModel);\n      const routeModels = Object.keys(routes);\n      routeModels.forEach((toModel) => {\n        const fn = routes[toModel];\n        convert[fromModel][toModel] = wrapRounded(fn);\n        convert[fromModel][toModel].raw = wrapRaw(fn);\n      });\n    });\n    module2.exports = convert;\n  }\n});\n\n// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js\nvar require_ansi_styles = __commonJS({\n  \"../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js\"(exports, module2) {\n    \"use strict\";\n    var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const code = fn(...args);\n      return `\\x1B[${code + offset}m`;\n    }, \"wrapAnsi16\");\n    var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const code = fn(...args);\n      return `\\x1B[${38 + offset};5;${code}m`;\n    }, \"wrapAnsi256\");\n    var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {\n      const rgb = fn(...args);\n      return `\\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n    }, \"wrapAnsi16m\");\n    var ansi2ansi = /* @__PURE__ */ __name((n) => n, \"ansi2ansi\");\n    var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], \"rgb2rgb\");\n    var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {\n      Object.defineProperty(object, property, {\n        get: () => {\n          const value = get();\n          Object.defineProperty(object, property, {\n            value,\n            enumerable: true,\n            configurable: true\n          });\n          return value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }, \"setLazyProperty\");\n    var colorConvert;\n    var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {\n      if (colorConvert === void 0) {\n        colorConvert = require_color_convert();\n      }\n      const offset = isBackground ? 10 : 0;\n      const styles = {};\n      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n        const name = sourceSpace === \"ansi16\" ? \"ansi\" : sourceSpace;\n        if (sourceSpace === targetSpace) {\n          styles[name] = wrap(identity2, offset);\n        } else if (typeof suite === \"object\") {\n          styles[name] = wrap(suite[targetSpace], offset);\n        }\n      }\n      return styles;\n    }, \"makeDynamicStyles\");\n    function assembleStyles() {\n      const codes = /* @__PURE__ */ new Map();\n      const styles = {\n        modifier: {\n          reset: [0, 0],\n          bold: [1, 22],\n          dim: [2, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          hidden: [8, 28],\n          strikethrough: [9, 29]\n        },\n        color: {\n          black: [30, 39],\n          red: [31, 39],\n          green: [32, 39],\n          yellow: [33, 39],\n          blue: [34, 39],\n          magenta: [35, 39],\n          cyan: [36, 39],\n          white: [37, 39],\n          blackBright: [90, 39],\n          redBright: [91, 39],\n          greenBright: [92, 39],\n          yellowBright: [93, 39],\n          blueBright: [94, 39],\n          magentaBright: [95, 39],\n          cyanBright: [96, 39],\n          whiteBright: [97, 39]\n        },\n        bgColor: {\n          bgBlack: [40, 49],\n          bgRed: [41, 49],\n          bgGreen: [42, 49],\n          bgYellow: [43, 49],\n          bgBlue: [44, 49],\n          bgMagenta: [45, 49],\n          bgCyan: [46, 49],\n          bgWhite: [47, 49],\n          bgBlackBright: [100, 49],\n          bgRedBright: [101, 49],\n          bgGreenBright: [102, 49],\n          bgYellowBright: [103, 49],\n          bgBlueBright: [104, 49],\n          bgMagentaBright: [105, 49],\n          bgCyanBright: [106, 49],\n          bgWhiteBright: [107, 49]\n        }\n      };\n      styles.color.gray = styles.color.blackBright;\n      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n      styles.color.grey = styles.color.blackBright;\n      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n      for (const [groupName, group] of Object.entries(styles)) {\n        for (const [styleName, style] of Object.entries(group)) {\n          styles[styleName] = {\n            open: `\\x1B[${style[0]}m`,\n            close: `\\x1B[${style[1]}m`\n          };\n          group[styleName] = styles[styleName];\n          codes.set(style[0], style[1]);\n        }\n        Object.defineProperty(styles, groupName, {\n          value: group,\n          enumerable: false\n        });\n      }\n      Object.defineProperty(styles, \"codes\", {\n        value: codes,\n        enumerable: false\n      });\n      styles.color.close = \"\\x1B[39m\";\n      styles.bgColor.close = \"\\x1B[49m\";\n      setLazyProperty(styles.color, \"ansi\", () => makeDynamicStyles(wrapAnsi16, \"ansi16\", ansi2ansi, false));\n      setLazyProperty(styles.color, \"ansi256\", () => makeDynamicStyles(wrapAnsi256, \"ansi256\", ansi2ansi, false));\n      setLazyProperty(styles.color, \"ansi16m\", () => makeDynamicStyles(wrapAnsi16m, \"rgb\", rgb2rgb, false));\n      setLazyProperty(styles.bgColor, \"ansi\", () => makeDynamicStyles(wrapAnsi16, \"ansi16\", ansi2ansi, true));\n      setLazyProperty(styles.bgColor, \"ansi256\", () => makeDynamicStyles(wrapAnsi256, \"ansi256\", ansi2ansi, true));\n      setLazyProperty(styles.bgColor, \"ansi16m\", () => makeDynamicStyles(wrapAnsi16m, \"rgb\", rgb2rgb, true));\n      return styles;\n    }\n    __name(assembleStyles, \"assembleStyles\");\n    Object.defineProperty(module2, \"exports\", {\n      enumerable: true,\n      get: assembleStyles\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js\nvar require_has_flag = __commonJS({\n  \"../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (flag, argv = process.argv) => {\n      const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n      const position = argv.indexOf(prefix + flag);\n      const terminatorPosition = argv.indexOf(\"--\");\n      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js\nvar require_supports_color = __commonJS({\n  \"../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js\"(exports, module2) {\n    \"use strict\";\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var tty = __webpack_require__(/*! tty */ \"tty\");\n    var hasFlag = require_has_flag();\n    var { env: env2 } = process;\n    var forceColor;\n    if (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\") || hasFlag(\"color=never\")) {\n      forceColor = 0;\n    } else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {\n      forceColor = 1;\n    }\n    if (\"FORCE_COLOR\" in env2) {\n      if (env2.FORCE_COLOR === \"true\") {\n        forceColor = 1;\n      } else if (env2.FORCE_COLOR === \"false\") {\n        forceColor = 0;\n      } else {\n        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);\n      }\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    __name(translateLevel, \"translateLevel\");\n    function supportsColor(haveStream, streamIsTTY) {\n      if (forceColor === 0) {\n        return 0;\n      }\n      if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {\n        return 3;\n      }\n      if (hasFlag(\"color=256\")) {\n        return 2;\n      }\n      if (haveStream && !streamIsTTY && forceColor === void 0) {\n        return 0;\n      }\n      const min2 = forceColor || 0;\n      if (env2.TERM === \"dumb\") {\n        return min2;\n      }\n      if (process.platform === \"win32\") {\n        const osRelease = os3.release().split(\".\");\n        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if (\"CI\" in env2) {\n        if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\", \"BUILDKITE\"].some((sign2) => sign2 in env2) || env2.CI_NAME === \"codeship\") {\n          return 1;\n        }\n        return min2;\n      }\n      if (\"TEAMCITY_VERSION\" in env2) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env2.COLORTERM === \"truecolor\") {\n        return 3;\n      }\n      if (\"TERM_PROGRAM\" in env2) {\n        const version = parseInt((env2.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n        switch (env2.TERM_PROGRAM) {\n          case \"iTerm.app\":\n            return version >= 3 ? 3 : 2;\n          case \"Apple_Terminal\":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env2.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {\n        return 1;\n      }\n      if (\"COLORTERM\" in env2) {\n        return 1;\n      }\n      return min2;\n    }\n    __name(supportsColor, \"supportsColor\");\n    function getSupportLevel(stream2) {\n      const level = supportsColor(stream2, stream2 && stream2.isTTY);\n      return translateLevel(level);\n    }\n    __name(getSupportLevel, \"getSupportLevel\");\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: translateLevel(supportsColor(true, tty.isatty(1))),\n      stderr: translateLevel(supportsColor(true, tty.isatty(2)))\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js\nvar require_util = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js\"(exports, module2) {\n    \"use strict\";\n    var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {\n      let index = string.indexOf(substring);\n      if (index === -1) {\n        return string;\n      }\n      const substringLength = substring.length;\n      let endIndex = 0;\n      let returnValue = \"\";\n      do {\n        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n        endIndex = index + substringLength;\n        index = string.indexOf(substring, endIndex);\n      } while (index !== -1);\n      returnValue += string.substr(endIndex);\n      return returnValue;\n    }, \"stringReplaceAll\");\n    var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {\n      let endIndex = 0;\n      let returnValue = \"\";\n      do {\n        const gotCR = string[index - 1] === \"\\r\";\n        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? \"\\r\\n\" : \"\\n\") + postfix;\n        endIndex = index + 1;\n        index = string.indexOf(\"\\n\", endIndex);\n      } while (index !== -1);\n      returnValue += string.substr(endIndex);\n      return returnValue;\n    }, \"stringEncaseCRLFWithFirstIndex\");\n    module2.exports = {\n      stringReplaceAll,\n      stringEncaseCRLFWithFirstIndex\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js\nvar require_templates = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js\"(exports, module2) {\n    \"use strict\";\n    var TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n    var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n    var STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n    var ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n    var ESCAPES = /* @__PURE__ */ new Map([\n      [\"n\", \"\\n\"],\n      [\"r\", \"\\r\"],\n      [\"t\", \"\t\"],\n      [\"b\", \"\\b\"],\n      [\"f\", \"\\f\"],\n      [\"v\", \"\\v\"],\n      [\"0\", \"\\0\"],\n      [\"\\\\\", \"\\\\\"],\n      [\"e\", \"\\x1B\"],\n      [\"a\", \"\\x07\"]\n    ]);\n    function unescape(c) {\n      const u = c[0] === \"u\";\n      const bracket = c[1] === \"{\";\n      if (u && !bracket && c.length === 5 || c[0] === \"x\" && c.length === 3) {\n        return String.fromCharCode(parseInt(c.slice(1), 16));\n      }\n      if (u && bracket) {\n        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n      }\n      return ESCAPES.get(c) || c;\n    }\n    __name(unescape, \"unescape\");\n    function parseArguments(name, arguments_) {\n      const results = [];\n      const chunks = arguments_.trim().split(/\\s*,\\s*/g);\n      let matches;\n      for (const chunk of chunks) {\n        const number = Number(chunk);\n        if (!Number.isNaN(number)) {\n          results.push(number);\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n        } else {\n          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n        }\n      }\n      return results;\n    }\n    __name(parseArguments, \"parseArguments\");\n    function parseStyle(style) {\n      STYLE_REGEX.lastIndex = 0;\n      const results = [];\n      let matches;\n      while ((matches = STYLE_REGEX.exec(style)) !== null) {\n        const name = matches[1];\n        if (matches[2]) {\n          const args = parseArguments(name, matches[2]);\n          results.push([name].concat(args));\n        } else {\n          results.push([name]);\n        }\n      }\n      return results;\n    }\n    __name(parseStyle, \"parseStyle\");\n    function buildStyle(chalk12, styles) {\n      const enabled = {};\n      for (const layer of styles) {\n        for (const style of layer.styles) {\n          enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n      }\n      let current = chalk12;\n      for (const [styleName, styles2] of Object.entries(enabled)) {\n        if (!Array.isArray(styles2)) {\n          continue;\n        }\n        if (!(styleName in current)) {\n          throw new Error(`Unknown Chalk style: ${styleName}`);\n        }\n        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];\n      }\n      return current;\n    }\n    __name(buildStyle, \"buildStyle\");\n    module2.exports = (chalk12, temporary) => {\n      const styles = [];\n      const chunks = [];\n      let chunk = [];\n      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n        if (escapeCharacter) {\n          chunk.push(unescape(escapeCharacter));\n        } else if (style) {\n          const string = chunk.join(\"\");\n          chunk = [];\n          chunks.push(styles.length === 0 ? string : buildStyle(chalk12, styles)(string));\n          styles.push({ inverse, styles: parseStyle(style) });\n        } else if (close) {\n          if (styles.length === 0) {\n            throw new Error(\"Found extraneous } in Chalk template literal\");\n          }\n          chunks.push(buildStyle(chalk12, styles)(chunk.join(\"\")));\n          chunk = [];\n          styles.pop();\n        } else {\n          chunk.push(character);\n        }\n      });\n      chunks.push(chunk.join(\"\"));\n      if (styles.length > 0) {\n        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? \"\" : \"s\"} (\\`}\\`)`;\n        throw new Error(errMessage);\n      }\n      return chunks.join(\"\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js\nvar require_source = __commonJS({\n  \"../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js\"(exports, module2) {\n    \"use strict\";\n    var ansiStyles = require_ansi_styles();\n    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();\n    var {\n      stringReplaceAll,\n      stringEncaseCRLFWithFirstIndex\n    } = require_util();\n    var { isArray: isArray2 } = Array;\n    var levelMapping = [\n      \"ansi\",\n      \"ansi\",\n      \"ansi256\",\n      \"ansi16m\"\n    ];\n    var styles = /* @__PURE__ */ Object.create(null);\n    var applyOptions = /* @__PURE__ */ __name((object, options = {}) => {\n      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n        throw new Error(\"The `level` option should be an integer from 0 to 3\");\n      }\n      const colorLevel = stdoutColor ? stdoutColor.level : 0;\n      object.level = options.level === void 0 ? colorLevel : options.level;\n    }, \"applyOptions\");\n    var ChalkClass = class {\n      constructor(options) {\n        return chalkFactory(options);\n      }\n    };\n    __name(ChalkClass, \"ChalkClass\");\n    var chalkFactory = /* @__PURE__ */ __name((options) => {\n      const chalk13 = {};\n      applyOptions(chalk13, options);\n      chalk13.template = (...arguments_) => chalkTag(chalk13.template, ...arguments_);\n      Object.setPrototypeOf(chalk13, Chalk.prototype);\n      Object.setPrototypeOf(chalk13.template, chalk13);\n      chalk13.template.constructor = () => {\n        throw new Error(\"`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.\");\n      };\n      chalk13.template.Instance = ChalkClass;\n      return chalk13.template;\n    }, \"chalkFactory\");\n    function Chalk(options) {\n      return chalkFactory(options);\n    }\n    __name(Chalk, \"Chalk\");\n    for (const [styleName, style] of Object.entries(ansiStyles)) {\n      styles[styleName] = {\n        get() {\n          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n          Object.defineProperty(this, styleName, { value: builder });\n          return builder;\n        }\n      };\n    }\n    styles.visible = {\n      get() {\n        const builder = createBuilder(this, this._styler, true);\n        Object.defineProperty(this, \"visible\", { value: builder });\n        return builder;\n      }\n    };\n    var usedModels = [\"rgb\", \"hex\", \"keyword\", \"hsl\", \"hsv\", \"hwb\", \"ansi\", \"ansi256\"];\n    for (const model of usedModels) {\n      styles[model] = {\n        get() {\n          const { level } = this;\n          return function(...arguments_) {\n            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n            return createBuilder(this, styler, this._isEmpty);\n          };\n        }\n      };\n    }\n    for (const model of usedModels) {\n      const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);\n      styles[bgModel] = {\n        get() {\n          const { level } = this;\n          return function(...arguments_) {\n            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n            return createBuilder(this, styler, this._isEmpty);\n          };\n        }\n      };\n    }\n    var proto = Object.defineProperties(() => {\n    }, {\n      ...styles,\n      level: {\n        enumerable: true,\n        get() {\n          return this._generator.level;\n        },\n        set(level) {\n          this._generator.level = level;\n        }\n      }\n    });\n    var createStyler = /* @__PURE__ */ __name((open, close, parent) => {\n      let openAll;\n      let closeAll;\n      if (parent === void 0) {\n        openAll = open;\n        closeAll = close;\n      } else {\n        openAll = parent.openAll + open;\n        closeAll = close + parent.closeAll;\n      }\n      return {\n        open,\n        close,\n        openAll,\n        closeAll,\n        parent\n      };\n    }, \"createStyler\");\n    var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {\n      const builder = /* @__PURE__ */ __name((...arguments_) => {\n        if (isArray2(arguments_[0]) && isArray2(arguments_[0].raw)) {\n          return applyStyle(builder, chalkTag(builder, ...arguments_));\n        }\n        return applyStyle(builder, arguments_.length === 1 ? \"\" + arguments_[0] : arguments_.join(\" \"));\n      }, \"builder\");\n      Object.setPrototypeOf(builder, proto);\n      builder._generator = self2;\n      builder._styler = _styler;\n      builder._isEmpty = _isEmpty;\n      return builder;\n    }, \"createBuilder\");\n    var applyStyle = /* @__PURE__ */ __name((self2, string) => {\n      if (self2.level <= 0 || !string) {\n        return self2._isEmpty ? \"\" : string;\n      }\n      let styler = self2._styler;\n      if (styler === void 0) {\n        return string;\n      }\n      const { openAll, closeAll } = styler;\n      if (string.indexOf(\"\\x1B\") !== -1) {\n        while (styler !== void 0) {\n          string = stringReplaceAll(string, styler.close, styler.open);\n          styler = styler.parent;\n        }\n      }\n      const lfIndex = string.indexOf(\"\\n\");\n      if (lfIndex !== -1) {\n        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n      }\n      return openAll + string + closeAll;\n    }, \"applyStyle\");\n    var template;\n    var chalkTag = /* @__PURE__ */ __name((chalk13, ...strings) => {\n      const [firstString] = strings;\n      if (!isArray2(firstString) || !isArray2(firstString.raw)) {\n        return strings.join(\" \");\n      }\n      const arguments_ = strings.slice(1);\n      const parts = [firstString.raw[0]];\n      for (let i = 1; i < firstString.length; i++) {\n        parts.push(\n          String(arguments_[i - 1]).replace(/[{}\\\\]/g, \"\\\\$&\"),\n          String(firstString.raw[i])\n        );\n      }\n      if (template === void 0) {\n        template = require_templates();\n      }\n      return template(chalk13, parts.join(\"\"));\n    }, \"chalkTag\");\n    Object.defineProperties(Chalk.prototype, styles);\n    var chalk12 = Chalk();\n    chalk12.supportsColor = stdoutColor;\n    chalk12.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });\n    chalk12.stderr.supportsColor = stderrColor;\n    module2.exports = chalk12;\n  }\n});\n\n// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js\nvar require_indent_string = __commonJS({\n  \"../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (string, count2 = 1, options) => {\n      options = {\n        indent: \" \",\n        includeEmptyLines: false,\n        ...options\n      };\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          `Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n        );\n      }\n      if (typeof count2 !== \"number\") {\n        throw new TypeError(\n          `Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count2}\\``\n        );\n      }\n      if (typeof options.indent !== \"string\") {\n        throw new TypeError(\n          `Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n        );\n      }\n      if (count2 === 0) {\n        return string;\n      }\n      const regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n      return string.replace(regex, options.indent.repeat(count2));\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js\nvar require_js_levenshtein = __commonJS({\n  \"../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function() {\n      function _min(d0, d1, d2, bx, ay) {\n        return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n      }\n      __name(_min, \"_min\");\n      return function(a, b) {\n        if (a === b) {\n          return 0;\n        }\n        if (a.length > b.length) {\n          var tmp = a;\n          a = b;\n          b = tmp;\n        }\n        var la = a.length;\n        var lb = b.length;\n        while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n          la--;\n          lb--;\n        }\n        var offset = 0;\n        while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n          offset++;\n        }\n        la -= offset;\n        lb -= offset;\n        if (la === 0 || lb < 3) {\n          return lb;\n        }\n        var x = 0;\n        var y;\n        var d0;\n        var d1;\n        var d2;\n        var d3;\n        var dd;\n        var dy;\n        var ay;\n        var bx0;\n        var bx1;\n        var bx2;\n        var bx3;\n        var vector = [];\n        for (y = 0; y < la; y++) {\n          vector.push(y + 1);\n          vector.push(a.charCodeAt(offset + y));\n        }\n        var len = vector.length - 1;\n        for (; x < lb - 3; ) {\n          bx0 = b.charCodeAt(offset + (d0 = x));\n          bx1 = b.charCodeAt(offset + (d1 = x + 1));\n          bx2 = b.charCodeAt(offset + (d2 = x + 2));\n          bx3 = b.charCodeAt(offset + (d3 = x + 3));\n          dd = x += 4;\n          for (y = 0; y < len; y += 2) {\n            dy = vector[y];\n            ay = vector[y + 1];\n            d0 = _min(dy, d0, d1, bx0, ay);\n            d1 = _min(d0, d1, d2, bx1, ay);\n            d2 = _min(d1, d2, d3, bx2, ay);\n            dd = _min(d2, d3, dd, bx3, ay);\n            vector[y] = dd;\n            d3 = d2;\n            d2 = d1;\n            d1 = d0;\n            d0 = dy;\n          }\n        }\n        for (; x < lb; ) {\n          bx0 = b.charCodeAt(offset + (d0 = x));\n          dd = ++x;\n          for (y = 0; y < len; y += 2) {\n            dy = vector[y];\n            vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n            d0 = dy;\n          }\n        }\n        return dd;\n      };\n    }();\n  }\n});\n\n// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js\"(exports, module2) {\n    var s = 1e3;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    module2.exports = function(val, options) {\n      options = options || {};\n      var type = typeof val;\n      if (type === \"string\" && val.length > 0) {\n        return parse2(val);\n      } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse2(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type = (match[2] || \"ms\").toLowerCase();\n      switch (type) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    __name(parse2, \"parse\");\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    __name(fmtShort, \"fmtShort\");\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    __name(fmtLong, \"fmtLong\");\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    __name(plural, \"plural\");\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js\"(exports, module2) {\n    function setup(env2) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env2).forEach((key) => {\n        createDebug[key] = env2[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      __name(selectColor, \"selectColor\");\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug13(...args) {\n          if (!debug13.enabled) {\n            return;\n          }\n          const self2 = debug13;\n          const curr = Number(new Date());\n          const ms = curr - (prevTime || curr);\n          self2.diff = ms;\n          self2.prev = prevTime;\n          self2.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format2];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self2, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self2, args);\n          const logFn = self2.log || createDebug.log;\n          logFn.apply(self2, args);\n        }\n        __name(debug13, \"debug\");\n        debug13.namespace = namespace;\n        debug13.useColors = createDebug.useColors();\n        debug13.color = createDebug.selectColor(namespace);\n        debug13.extend = extend;\n        debug13.destroy = createDebug.destroy;\n        Object.defineProperty(debug13, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v) => {\n            enableOverride = v;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug13);\n        }\n        return debug13;\n      }\n      __name(createDebug, \"createDebug\");\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      __name(extend, \"extend\");\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      __name(enable, \"enable\");\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      __name(disable, \"disable\");\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      __name(enabled, \"enabled\");\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      __name(toNamespace, \"toNamespace\");\n      function coerce(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      __name(coerce, \"coerce\");\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      __name(destroy, \"destroy\");\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    __name(setup, \"setup\");\n    module2.exports = setup;\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js\"(exports, module2) {\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    __name(useColors, \"useColors\");\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module2.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c);\n    }\n    __name(formatArgs, \"formatArgs\");\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error2) {\n      }\n    }\n    __name(save, \"save\");\n    function load() {\n      let r;\n      try {\n        r = exports.storage.getItem(\"debug\");\n      } catch (error2) {\n      }\n      if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n      }\n      return r;\n    }\n    __name(load, \"load\");\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error2) {\n      }\n    }\n    __name(localstorage, \"localstorage\");\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.j = function(v) {\n      try {\n        return JSON.stringify(v);\n      } catch (error2) {\n        return \"[UnexpectedJSONParseError]: \" + error2.message;\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js\nvar require_node = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js\"(exports, module2) {\n    var tty = __webpack_require__(/*! tty */ \"tty\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    exports.init = init;\n    exports.log = log4;\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.destroy = util2.deprecate(\n      () => {\n      },\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    );\n    exports.colors = [6, 2, 3, 4, 5, 1];\n    try {\n      const supportsColor = require_supports_color();\n      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n          20,\n          21,\n          26,\n          27,\n          32,\n          33,\n          38,\n          39,\n          40,\n          41,\n          42,\n          43,\n          44,\n          45,\n          56,\n          57,\n          62,\n          63,\n          68,\n          69,\n          74,\n          75,\n          76,\n          77,\n          78,\n          79,\n          80,\n          81,\n          92,\n          93,\n          98,\n          99,\n          112,\n          113,\n          128,\n          129,\n          134,\n          135,\n          148,\n          149,\n          160,\n          161,\n          162,\n          163,\n          164,\n          165,\n          166,\n          167,\n          168,\n          169,\n          170,\n          171,\n          172,\n          173,\n          178,\n          179,\n          184,\n          185,\n          196,\n          197,\n          198,\n          199,\n          200,\n          201,\n          202,\n          203,\n          204,\n          205,\n          206,\n          207,\n          208,\n          209,\n          214,\n          215,\n          220,\n          221\n        ];\n      }\n    } catch (error2) {\n    }\n    exports.inspectOpts = Object.keys(process.env).filter((key) => {\n      return /^debug_/i.test(key);\n    }).reduce((obj, key) => {\n      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {\n        return k.toUpperCase();\n      });\n      let val = process.env[key];\n      if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n      } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n      } else if (val === \"null\") {\n        val = null;\n      } else {\n        val = Number(val);\n      }\n      obj[prop] = val;\n      return obj;\n    }, {});\n    function useColors() {\n      return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n    }\n    __name(useColors, \"useColors\");\n    function formatArgs(args) {\n      const { namespace: name, useColors: useColors2 } = this;\n      if (useColors2) {\n        const c = this.color;\n        const colorCode = \"\\x1B[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\x1B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module2.exports.humanize(this.diff) + \"\\x1B[0m\");\n      } else {\n        args[0] = getDate() + name + \" \" + args[0];\n      }\n    }\n    __name(formatArgs, \"formatArgs\");\n    function getDate() {\n      if (exports.inspectOpts.hideDate) {\n        return \"\";\n      }\n      return new Date().toISOString() + \" \";\n    }\n    __name(getDate, \"getDate\");\n    function log4(...args) {\n      return process.stderr.write(util2.format(...args) + \"\\n\");\n    }\n    __name(log4, \"log\");\n    function save(namespaces) {\n      if (namespaces) {\n        process.env.DEBUG = namespaces;\n      } else {\n        delete process.env.DEBUG;\n      }\n    }\n    __name(save, \"save\");\n    function load() {\n      return process.env.DEBUG;\n    }\n    __name(load, \"load\");\n    function init(debug13) {\n      debug13.inspectOpts = {};\n      const keys2 = Object.keys(exports.inspectOpts);\n      for (let i = 0; i < keys2.length; i++) {\n        debug13.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];\n      }\n    }\n    __name(init, \"init\");\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.o = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts).split(\"\\n\").map((str) => str.trim()).join(\" \");\n    };\n    formatters.O = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js\nvar require_src = __commonJS({\n  \"../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js\"(exports, module2) {\n    if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n      module2.exports = require_browser();\n    } else {\n      module2.exports = require_node();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js\nvar require_windows = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js\"(exports, module2) {\n    module2.exports = isexe;\n    isexe.sync = sync;\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    function checkPathExt(path7, options) {\n      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;\n      if (!pathext) {\n        return true;\n      }\n      pathext = pathext.split(\";\");\n      if (pathext.indexOf(\"\") !== -1) {\n        return true;\n      }\n      for (var i = 0; i < pathext.length; i++) {\n        var p = pathext[i].toLowerCase();\n        if (p && path7.substr(-p.length).toLowerCase() === p) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(checkPathExt, \"checkPathExt\");\n    function checkStat(stat, path7, options) {\n      if (!stat.isSymbolicLink() && !stat.isFile()) {\n        return false;\n      }\n      return checkPathExt(path7, options);\n    }\n    __name(checkStat, \"checkStat\");\n    function isexe(path7, options, cb) {\n      fs11.stat(path7, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, path7, options));\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      return checkStat(fs11.statSync(path7), path7, options);\n    }\n    __name(sync, \"sync\");\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js\nvar require_mode = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js\"(exports, module2) {\n    module2.exports = isexe;\n    isexe.sync = sync;\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    function isexe(path7, options, cb) {\n      fs11.stat(path7, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, options));\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      return checkStat(fs11.statSync(path7), options);\n    }\n    __name(sync, \"sync\");\n    function checkStat(stat, options) {\n      return stat.isFile() && checkMode(stat, options);\n    }\n    __name(checkStat, \"checkStat\");\n    function checkMode(stat, options) {\n      var mod2 = stat.mode;\n      var uid = stat.uid;\n      var gid = stat.gid;\n      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();\n      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();\n      var u = parseInt(\"100\", 8);\n      var g = parseInt(\"010\", 8);\n      var o = parseInt(\"001\", 8);\n      var ug = u | g;\n      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;\n      return ret;\n    }\n    __name(checkMode, \"checkMode\");\n  }\n});\n\n// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js\nvar require_isexe = __commonJS({\n  \"../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js\"(exports, module2) {\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var core;\n    if (process.platform === \"win32\" || global.TESTING_WINDOWS) {\n      core = require_windows();\n    } else {\n      core = require_mode();\n    }\n    module2.exports = isexe;\n    isexe.sync = sync;\n    function isexe(path7, options, cb) {\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n      if (!cb) {\n        if (typeof Promise !== \"function\") {\n          throw new TypeError(\"callback not provided\");\n        }\n        return new Promise(function(resolve, reject) {\n          isexe(path7, options || {}, function(er, is) {\n            if (er) {\n              reject(er);\n            } else {\n              resolve(is);\n            }\n          });\n        });\n      }\n      core(path7, options || {}, function(er, is) {\n        if (er) {\n          if (er.code === \"EACCES\" || options && options.ignoreErrors) {\n            er = null;\n            is = false;\n          }\n        }\n        cb(er, is);\n      });\n    }\n    __name(isexe, \"isexe\");\n    function sync(path7, options) {\n      try {\n        return core.sync(path7, options || {});\n      } catch (er) {\n        if (options && options.ignoreErrors || er.code === \"EACCES\") {\n          return false;\n        } else {\n          throw er;\n        }\n      }\n    }\n    __name(sync, \"sync\");\n  }\n});\n\n// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js\nvar require_which = __commonJS({\n  \"../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js\"(exports, module2) {\n    var isWindows = process.platform === \"win32\" || process.env.OSTYPE === \"cygwin\" || process.env.OSTYPE === \"msys\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var COLON = isWindows ? \";\" : \":\";\n    var isexe = require_isexe();\n    var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: \"ENOENT\" }), \"getNotFoundError\");\n    var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {\n      const colon = opt.colon || COLON;\n      const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [\"\"] : [\n        ...isWindows ? [process.cwd()] : [],\n        ...(opt.path || process.env.PATH || \"\").split(colon)\n      ];\n      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || \".EXE;.CMD;.BAT;.COM\" : \"\";\n      const pathExt = isWindows ? pathExtExe.split(colon) : [\"\"];\n      if (isWindows) {\n        if (cmd.indexOf(\".\") !== -1 && pathExt[0] !== \"\")\n          pathExt.unshift(\"\");\n      }\n      return {\n        pathEnv,\n        pathExt,\n        pathExtExe\n      };\n    }, \"getPathInfo\");\n    var which = /* @__PURE__ */ __name((cmd, opt, cb) => {\n      if (typeof opt === \"function\") {\n        cb = opt;\n        opt = {};\n      }\n      if (!opt)\n        opt = {};\n      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n      const found = [];\n      const step = /* @__PURE__ */ __name((i) => new Promise((resolve, reject) => {\n        if (i === pathEnv.length)\n          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path7.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        resolve(subStep(p, i, 0));\n      }), \"step\");\n      const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve, reject) => {\n        if (ii === pathExt.length)\n          return resolve(step(i + 1));\n        const ext = pathExt[ii];\n        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n          if (!er && is) {\n            if (opt.all)\n              found.push(p + ext);\n            else\n              return resolve(p + ext);\n          }\n          return resolve(subStep(p, i, ii + 1));\n        });\n      }), \"subStep\");\n      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);\n    }, \"which\");\n    var whichSync = /* @__PURE__ */ __name((cmd, opt) => {\n      opt = opt || {};\n      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n      const found = [];\n      for (let i = 0; i < pathEnv.length; i++) {\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path7.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        for (let j = 0; j < pathExt.length; j++) {\n          const cur = p + pathExt[j];\n          try {\n            const is = isexe.sync(cur, { pathExt: pathExtExe });\n            if (is) {\n              if (opt.all)\n                found.push(cur);\n              else\n                return cur;\n            }\n          } catch (ex) {\n          }\n        }\n      }\n      if (opt.all && found.length)\n        return found;\n      if (opt.nothrow)\n        return null;\n      throw getNotFoundError(cmd);\n    }, \"whichSync\");\n    module2.exports = which;\n    which.sync = whichSync;\n  }\n});\n\n// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js\nvar require_path_key = __commonJS({\n  \"../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js\"(exports, module2) {\n    \"use strict\";\n    var pathKey = /* @__PURE__ */ __name((options = {}) => {\n      const environment = options.env || process.env;\n      const platform3 = options.platform || process.platform;\n      if (platform3 !== \"win32\") {\n        return \"PATH\";\n      }\n      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === \"PATH\") || \"Path\";\n    }, \"pathKey\");\n    module2.exports = pathKey;\n    module2.exports.default = pathKey;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js\nvar require_resolveCommand = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var which = require_which();\n    var getPathKey = require_path_key();\n    function resolveCommandAttempt(parsed, withoutPathExt) {\n      const env2 = parsed.options.env || process.env;\n      const cwd = process.cwd();\n      const hasCustomCwd = parsed.options.cwd != null;\n      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;\n      if (shouldSwitchCwd) {\n        try {\n          process.chdir(parsed.options.cwd);\n        } catch (err) {\n        }\n      }\n      let resolved;\n      try {\n        resolved = which.sync(parsed.command, {\n          path: env2[getPathKey({ env: env2 })],\n          pathExt: withoutPathExt ? path7.delimiter : void 0\n        });\n      } catch (e) {\n      } finally {\n        if (shouldSwitchCwd) {\n          process.chdir(cwd);\n        }\n      }\n      if (resolved) {\n        resolved = path7.resolve(hasCustomCwd ? parsed.options.cwd : \"\", resolved);\n      }\n      return resolved;\n    }\n    __name(resolveCommandAttempt, \"resolveCommandAttempt\");\n    function resolveCommand(parsed) {\n      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n    }\n    __name(resolveCommand, \"resolveCommand\");\n    module2.exports = resolveCommand;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js\nvar require_escape = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js\"(exports, module2) {\n    \"use strict\";\n    var metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n    function escapeCommand(arg2) {\n      arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      return arg2;\n    }\n    __name(escapeCommand, \"escapeCommand\");\n    function escapeArgument(arg2, doubleEscapeMetaChars) {\n      arg2 = `${arg2}`;\n      arg2 = arg2.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n      arg2 = arg2.replace(/(\\\\*)$/, \"$1$1\");\n      arg2 = `\"${arg2}\"`;\n      arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      if (doubleEscapeMetaChars) {\n        arg2 = arg2.replace(metaCharsRegExp, \"^$1\");\n      }\n      return arg2;\n    }\n    __name(escapeArgument, \"escapeArgument\");\n    module2.exports.command = escapeCommand;\n    module2.exports.argument = escapeArgument;\n  }\n});\n\n// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js\nvar require_shebang_regex = __commonJS({\n  \"../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = /^#!(.*)/;\n  }\n});\n\n// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js\nvar require_shebang_command = __commonJS({\n  \"../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js\"(exports, module2) {\n    \"use strict\";\n    var shebangRegex = require_shebang_regex();\n    module2.exports = (string = \"\") => {\n      const match = string.match(shebangRegex);\n      if (!match) {\n        return null;\n      }\n      const [path7, argument] = match[0].replace(/#! ?/, \"\").split(\" \");\n      const binary = path7.split(\"/\").pop();\n      if (binary === \"env\") {\n        return argument;\n      }\n      return argument ? `${binary} ${argument}` : binary;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js\nvar require_readShebang = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js\"(exports, module2) {\n    \"use strict\";\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var shebangCommand = require_shebang_command();\n    function readShebang(command) {\n      const size = 150;\n      const buffer = Buffer.alloc(size);\n      let fd;\n      try {\n        fd = fs11.openSync(command, \"r\");\n        fs11.readSync(fd, buffer, 0, size, 0);\n        fs11.closeSync(fd);\n      } catch (e) {\n      }\n      return shebangCommand(buffer.toString());\n    }\n    __name(readShebang, \"readShebang\");\n    module2.exports = readShebang;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js\nvar require_parse = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var resolveCommand = require_resolveCommand();\n    var escape = require_escape();\n    var readShebang = require_readShebang();\n    var isWin = process.platform === \"win32\";\n    var isExecutableRegExp = /\\.(?:com|exe)$/i;\n    var isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n    function detectShebang(parsed) {\n      parsed.file = resolveCommand(parsed);\n      const shebang = parsed.file && readShebang(parsed.file);\n      if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        return resolveCommand(parsed);\n      }\n      return parsed.file;\n    }\n    __name(detectShebang, \"detectShebang\");\n    function parseNonShell(parsed) {\n      if (!isWin) {\n        return parsed;\n      }\n      const commandFile = detectShebang(parsed);\n      const needsShell = !isExecutableRegExp.test(commandFile);\n      if (parsed.options.forceShell || needsShell) {\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n        parsed.command = path7.normalize(parsed.command);\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));\n        const shellCommand = [parsed.command].concat(parsed.args).join(\" \");\n        parsed.args = [\"/d\", \"/s\", \"/c\", `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || \"cmd.exe\";\n        parsed.options.windowsVerbatimArguments = true;\n      }\n      return parsed;\n    }\n    __name(parseNonShell, \"parseNonShell\");\n    function parse2(command, args, options) {\n      if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n      }\n      args = args ? args.slice(0) : [];\n      options = Object.assign({}, options);\n      const parsed = {\n        command,\n        args,\n        options,\n        file: void 0,\n        original: {\n          command,\n          args\n        }\n      };\n      return options.shell ? parsed : parseNonShell(parsed);\n    }\n    __name(parse2, \"parse\");\n    module2.exports = parse2;\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js\nvar require_enoent = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js\"(exports, module2) {\n    \"use strict\";\n    var isWin = process.platform === \"win32\";\n    function notFoundError(original, syscall) {\n      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: \"ENOENT\",\n        errno: \"ENOENT\",\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args\n      });\n    }\n    __name(notFoundError, \"notFoundError\");\n    function hookChildProcess(cp, parsed) {\n      if (!isWin) {\n        return;\n      }\n      const originalEmit = cp.emit;\n      cp.emit = function(name, arg1) {\n        if (name === \"exit\") {\n          const err = verifyENOENT(arg1, parsed, \"spawn\");\n          if (err) {\n            return originalEmit.call(cp, \"error\", err);\n          }\n        }\n        return originalEmit.apply(cp, arguments);\n      };\n    }\n    __name(hookChildProcess, \"hookChildProcess\");\n    function verifyENOENT(status, parsed) {\n      if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, \"spawn\");\n      }\n      return null;\n    }\n    __name(verifyENOENT, \"verifyENOENT\");\n    function verifyENOENTSync(status, parsed) {\n      if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, \"spawnSync\");\n      }\n      return null;\n    }\n    __name(verifyENOENTSync, \"verifyENOENTSync\");\n    module2.exports = {\n      hookChildProcess,\n      verifyENOENT,\n      verifyENOENTSync,\n      notFoundError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js\nvar require_cross_spawn = __commonJS({\n  \"../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js\"(exports, module2) {\n    \"use strict\";\n    var cp = __webpack_require__(/*! child_process */ \"child_process\");\n    var parse2 = require_parse();\n    var enoent = require_enoent();\n    function spawn2(command, args, options) {\n      const parsed = parse2(command, args, options);\n      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n      enoent.hookChildProcess(spawned, parsed);\n      return spawned;\n    }\n    __name(spawn2, \"spawn\");\n    function spawnSync(command, args, options) {\n      const parsed = parse2(command, args, options);\n      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n      return result;\n    }\n    __name(spawnSync, \"spawnSync\");\n    module2.exports = spawn2;\n    module2.exports.spawn = spawn2;\n    module2.exports.sync = spawnSync;\n    module2.exports._parse = parse2;\n    module2.exports._enoent = enoent;\n  }\n});\n\n// ../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/package.json\nvar require_package = __commonJS({\n  \"../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/package.json\"(exports, module2) {\n    module2.exports = {\n      name: \"@prisma/engines-version\",\n      version: \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\",\n      main: \"index.js\",\n      types: \"index.d.ts\",\n      license: \"Apache-2.0\",\n      author: \"Tim Suchanek <suchanek@prisma.io>\",\n      prisma: {\n        enginesVersion: \"c875e43600dfe042452e0b868f7a48b817b9640b\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/prisma/engines-wrapper.git\",\n        directory: \"packages/engines-version\"\n      },\n      devDependencies: {\n        \"@types/node\": \"16.11.56\",\n        typescript: \"4.7.4\"\n      },\n      files: [\n        \"index.js\",\n        \"index.d.ts\"\n      ],\n      scripts: {\n        build: \"tsc -d\"\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/index.js\nvar require_engines_version = __commonJS({\n  \"../../node_modules/.pnpm/@prisma+engines-version@4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b/node_modules/@prisma/engines-version/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.enginesVersion = void 0;\n    exports.enginesVersion = require_package().prisma.enginesVersion;\n  }\n});\n\n// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js\nvar require_strip_final_newline = __commonJS({\n  \"../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (input) => {\n      const LF = typeof input === \"string\" ? \"\\n\" : \"\\n\".charCodeAt();\n      const CR = typeof input === \"string\" ? \"\\r\" : \"\\r\".charCodeAt();\n      if (input[input.length - 1] === LF) {\n        input = input.slice(0, input.length - 1);\n      }\n      if (input[input.length - 1] === CR) {\n        input = input.slice(0, input.length - 1);\n      }\n      return input;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js\nvar require_npm_run_path = __commonJS({\n  \"../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var pathKey = require_path_key();\n    var npmRunPath = /* @__PURE__ */ __name((options) => {\n      options = {\n        cwd: process.cwd(),\n        path: process.env[pathKey()],\n        execPath: process.execPath,\n        ...options\n      };\n      let previous;\n      let cwdPath = path7.resolve(options.cwd);\n      const result = [];\n      while (previous !== cwdPath) {\n        result.push(path7.join(cwdPath, \"node_modules/.bin\"));\n        previous = cwdPath;\n        cwdPath = path7.resolve(cwdPath, \"..\");\n      }\n      const execPathDir = path7.resolve(options.cwd, options.execPath, \"..\");\n      result.push(execPathDir);\n      return result.concat(options.path).join(path7.delimiter);\n    }, \"npmRunPath\");\n    module2.exports = npmRunPath;\n    module2.exports.default = npmRunPath;\n    module2.exports.env = (options) => {\n      options = {\n        env: process.env,\n        ...options\n      };\n      const env2 = { ...options.env };\n      const path8 = pathKey({ env: env2 });\n      options.path = env2[path8];\n      env2[path8] = module2.exports(options);\n      return env2;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js\nvar require_mimic_fn = __commonJS({\n  \"../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js\"(exports, module2) {\n    \"use strict\";\n    var mimicFn = /* @__PURE__ */ __name((to, from) => {\n      for (const prop of Reflect.ownKeys(from)) {\n        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n      }\n      return to;\n    }, \"mimicFn\");\n    module2.exports = mimicFn;\n    module2.exports.default = mimicFn;\n  }\n});\n\n// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js\nvar require_onetime = __commonJS({\n  \"../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js\"(exports, module2) {\n    \"use strict\";\n    var mimicFn = require_mimic_fn();\n    var calledFunctions = /* @__PURE__ */ new WeakMap();\n    var onetime = /* @__PURE__ */ __name((function_, options = {}) => {\n      if (typeof function_ !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n      }\n      let returnValue;\n      let callCount = 0;\n      const functionName = function_.displayName || function_.name || \"<anonymous>\";\n      const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {\n        calledFunctions.set(onetime2, ++callCount);\n        if (callCount === 1) {\n          returnValue = function_.apply(this, arguments_);\n          function_ = null;\n        } else if (options.throw === true) {\n          throw new Error(`Function \\`${functionName}\\` can only be called once`);\n        }\n        return returnValue;\n      }, \"onetime\");\n      mimicFn(onetime2, function_);\n      calledFunctions.set(onetime2, callCount);\n      return onetime2;\n    }, \"onetime\");\n    module2.exports = onetime;\n    module2.exports.default = onetime;\n    module2.exports.callCount = (function_) => {\n      if (!calledFunctions.has(function_)) {\n        throw new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n      }\n      return calledFunctions.get(function_);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js\nvar require_core = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SIGNALS = void 0;\n    var SIGNALS = [\n      {\n        name: \"SIGHUP\",\n        number: 1,\n        action: \"terminate\",\n        description: \"Terminal closed\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGINT\",\n        number: 2,\n        action: \"terminate\",\n        description: \"User interruption with CTRL-C\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGQUIT\",\n        number: 3,\n        action: \"core\",\n        description: \"User interruption with CTRL-\\\\\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGILL\",\n        number: 4,\n        action: \"core\",\n        description: \"Invalid machine instruction\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGTRAP\",\n        number: 5,\n        action: \"core\",\n        description: \"Debugger breakpoint\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGABRT\",\n        number: 6,\n        action: \"core\",\n        description: \"Aborted\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGIOT\",\n        number: 6,\n        action: \"core\",\n        description: \"Aborted\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGBUS\",\n        number: 7,\n        action: \"core\",\n        description: \"Bus error due to misaligned, non-existing address or paging error\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGEMT\",\n        number: 7,\n        action: \"terminate\",\n        description: \"Command should be emulated but is not implemented\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGFPE\",\n        number: 8,\n        action: \"core\",\n        description: \"Floating point arithmetic error\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGKILL\",\n        number: 9,\n        action: \"terminate\",\n        description: \"Forced termination\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGUSR1\",\n        number: 10,\n        action: \"terminate\",\n        description: \"Application-specific signal\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGSEGV\",\n        number: 11,\n        action: \"core\",\n        description: \"Segmentation fault\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGUSR2\",\n        number: 12,\n        action: \"terminate\",\n        description: \"Application-specific signal\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGPIPE\",\n        number: 13,\n        action: \"terminate\",\n        description: \"Broken pipe or socket\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGALRM\",\n        number: 14,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGTERM\",\n        number: 15,\n        action: \"terminate\",\n        description: \"Termination\",\n        standard: \"ansi\"\n      },\n      {\n        name: \"SIGSTKFLT\",\n        number: 16,\n        action: \"terminate\",\n        description: \"Stack is empty or overflowed\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGCHLD\",\n        number: 17,\n        action: \"ignore\",\n        description: \"Child process terminated, paused or unpaused\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGCLD\",\n        number: 17,\n        action: \"ignore\",\n        description: \"Child process terminated, paused or unpaused\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGCONT\",\n        number: 18,\n        action: \"unpause\",\n        description: \"Unpaused\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGSTOP\",\n        number: 19,\n        action: \"pause\",\n        description: \"Paused\",\n        standard: \"posix\",\n        forced: true\n      },\n      {\n        name: \"SIGTSTP\",\n        number: 20,\n        action: \"pause\",\n        description: 'Paused using CTRL-Z or \"suspend\"',\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGTTIN\",\n        number: 21,\n        action: \"pause\",\n        description: \"Background process cannot read terminal input\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGBREAK\",\n        number: 21,\n        action: \"terminate\",\n        description: \"User interruption with CTRL-BREAK\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGTTOU\",\n        number: 22,\n        action: \"pause\",\n        description: \"Background process cannot write to terminal output\",\n        standard: \"posix\"\n      },\n      {\n        name: \"SIGURG\",\n        number: 23,\n        action: \"ignore\",\n        description: \"Socket received out-of-band data\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGXCPU\",\n        number: 24,\n        action: \"core\",\n        description: \"Process timed out\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGXFSZ\",\n        number: 25,\n        action: \"core\",\n        description: \"File too big\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGVTALRM\",\n        number: 26,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGPROF\",\n        number: 27,\n        action: \"terminate\",\n        description: \"Timeout or timer\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGWINCH\",\n        number: 28,\n        action: \"ignore\",\n        description: \"Terminal window size changed\",\n        standard: \"bsd\"\n      },\n      {\n        name: \"SIGIO\",\n        number: 29,\n        action: \"terminate\",\n        description: \"I/O is available\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGPOLL\",\n        number: 29,\n        action: \"terminate\",\n        description: \"Watched event\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGINFO\",\n        number: 29,\n        action: \"ignore\",\n        description: \"Request for process information\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGPWR\",\n        number: 30,\n        action: \"terminate\",\n        description: \"Device running out of power\",\n        standard: \"systemv\"\n      },\n      {\n        name: \"SIGSYS\",\n        number: 31,\n        action: \"core\",\n        description: \"Invalid system call\",\n        standard: \"other\"\n      },\n      {\n        name: \"SIGUNUSED\",\n        number: 31,\n        action: \"terminate\",\n        description: \"Invalid system call\",\n        standard: \"other\"\n      }\n    ];\n    exports.SIGNALS = SIGNALS;\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js\nvar require_realtime = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SIGRTMAX = exports.getRealtimeSignals = void 0;\n    var getRealtimeSignals = /* @__PURE__ */ __name(function() {\n      const length = SIGRTMAX - SIGRTMIN + 1;\n      return Array.from({ length }, getRealtimeSignal);\n    }, \"getRealtimeSignals\");\n    exports.getRealtimeSignals = getRealtimeSignals;\n    var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {\n      return {\n        name: `SIGRT${index + 1}`,\n        number: SIGRTMIN + index,\n        action: \"terminate\",\n        description: \"Application-specific signal (realtime)\",\n        standard: \"posix\"\n      };\n    }, \"getRealtimeSignal\");\n    var SIGRTMIN = 34;\n    var SIGRTMAX = 64;\n    exports.SIGRTMAX = SIGRTMAX;\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js\nvar require_signals = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.getSignals = void 0;\n    var _os = __webpack_require__(/*! os */ \"os\");\n    var _core = require_core();\n    var _realtime = require_realtime();\n    var getSignals = /* @__PURE__ */ __name(function() {\n      const realtimeSignals = (0, _realtime.getRealtimeSignals)();\n      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);\n      return signals;\n    }, \"getSignals\");\n    exports.getSignals = getSignals;\n    var normalizeSignal = /* @__PURE__ */ __name(function({\n      name,\n      number: defaultNumber,\n      description,\n      action,\n      forced = false,\n      standard\n    }) {\n      const {\n        signals: { [name]: constantSignal }\n      } = _os.constants;\n      const supported = constantSignal !== void 0;\n      const number = supported ? constantSignal : defaultNumber;\n      return { name, number, description, supported, action, forced, standard };\n    }, \"normalizeSignal\");\n  }\n});\n\n// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js\nvar require_main = __commonJS({\n  \"../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.signalsByNumber = exports.signalsByName = void 0;\n    var _os = __webpack_require__(/*! os */ \"os\");\n    var _signals = require_signals();\n    var _realtime = require_realtime();\n    var getSignalsByName = /* @__PURE__ */ __name(function() {\n      const signals = (0, _signals.getSignals)();\n      return signals.reduce(getSignalByName, {});\n    }, \"getSignalsByName\");\n    var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {\n      return {\n        ...signalByNameMemo,\n        [name]: { name, number, description, supported, action, forced, standard }\n      };\n    }, \"getSignalByName\");\n    var signalsByName = getSignalsByName();\n    exports.signalsByName = signalsByName;\n    var getSignalsByNumber = /* @__PURE__ */ __name(function() {\n      const signals = (0, _signals.getSignals)();\n      const length = _realtime.SIGRTMAX + 1;\n      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));\n      return Object.assign({}, ...signalsA);\n    }, \"getSignalsByNumber\");\n    var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {\n      const signal = findSignalByNumber(number, signals);\n      if (signal === void 0) {\n        return {};\n      }\n      const { name, description, supported, action, forced, standard } = signal;\n      return {\n        [number]: {\n          name,\n          number,\n          description,\n          supported,\n          action,\n          forced,\n          standard\n        }\n      };\n    }, \"getSignalByNumber\");\n    var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {\n      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);\n      if (signal !== void 0) {\n        return signal;\n      }\n      return signals.find((signalA) => signalA.number === number);\n    }, \"findSignalByNumber\");\n    var signalsByNumber = getSignalsByNumber();\n    exports.signalsByNumber = signalsByNumber;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js\nvar require_error = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js\"(exports, module2) {\n    \"use strict\";\n    var { signalsByName } = require_main();\n    var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {\n      if (timedOut) {\n        return `timed out after ${timeout} milliseconds`;\n      }\n      if (isCanceled) {\n        return \"was canceled\";\n      }\n      if (errorCode !== void 0) {\n        return `failed with ${errorCode}`;\n      }\n      if (signal !== void 0) {\n        return `was killed with ${signal} (${signalDescription})`;\n      }\n      if (exitCode !== void 0) {\n        return `failed with exit code ${exitCode}`;\n      }\n      return \"failed\";\n    }, \"getErrorPrefix\");\n    var makeError = /* @__PURE__ */ __name(({\n      stdout,\n      stderr,\n      all,\n      error: error2,\n      signal,\n      exitCode,\n      command,\n      escapedCommand,\n      timedOut,\n      isCanceled,\n      killed,\n      parsed: { options: { timeout } }\n    }) => {\n      exitCode = exitCode === null ? void 0 : exitCode;\n      signal = signal === null ? void 0 : signal;\n      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;\n      const errorCode = error2 && error2.code;\n      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });\n      const execaMessage = `Command ${prefix}: ${command}`;\n      const isError2 = Object.prototype.toString.call(error2) === \"[object Error]\";\n      const shortMessage = isError2 ? `${execaMessage}\n${error2.message}` : execaMessage;\n      const message = [shortMessage, stderr, stdout].filter(Boolean).join(\"\\n\");\n      if (isError2) {\n        error2.originalMessage = error2.message;\n        error2.message = message;\n      } else {\n        error2 = new Error(message);\n      }\n      error2.shortMessage = shortMessage;\n      error2.command = command;\n      error2.escapedCommand = escapedCommand;\n      error2.exitCode = exitCode;\n      error2.signal = signal;\n      error2.signalDescription = signalDescription;\n      error2.stdout = stdout;\n      error2.stderr = stderr;\n      if (all !== void 0) {\n        error2.all = all;\n      }\n      if (\"bufferedData\" in error2) {\n        delete error2.bufferedData;\n      }\n      error2.failed = true;\n      error2.timedOut = Boolean(timedOut);\n      error2.isCanceled = isCanceled;\n      error2.killed = killed && !timedOut;\n      return error2;\n    }, \"makeError\");\n    module2.exports = makeError;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js\nvar require_stdio = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js\"(exports, module2) {\n    \"use strict\";\n    var aliases = [\"stdin\", \"stdout\", \"stderr\"];\n    var hasAlias = /* @__PURE__ */ __name((options) => aliases.some((alias) => options[alias] !== void 0), \"hasAlias\");\n    var normalizeStdio = /* @__PURE__ */ __name((options) => {\n      if (!options) {\n        return;\n      }\n      const { stdio } = options;\n      if (stdio === void 0) {\n        return aliases.map((alias) => options[alias]);\n      }\n      if (hasAlias(options)) {\n        throw new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map((alias) => `\\`${alias}\\``).join(\", \")}`);\n      }\n      if (typeof stdio === \"string\") {\n        return stdio;\n      }\n      if (!Array.isArray(stdio)) {\n        throw new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n      }\n      const length = Math.max(stdio.length, aliases.length);\n      return Array.from({ length }, (value, index) => stdio[index]);\n    }, \"normalizeStdio\");\n    module2.exports = normalizeStdio;\n    module2.exports.node = (options) => {\n      const stdio = normalizeStdio(options);\n      if (stdio === \"ipc\") {\n        return \"ipc\";\n      }\n      if (stdio === void 0 || typeof stdio === \"string\") {\n        return [stdio, stdio, stdio, \"ipc\"];\n      }\n      if (stdio.includes(\"ipc\")) {\n        return stdio;\n      }\n      return [...stdio, \"ipc\"];\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js\nvar require_signals2 = __commonJS({\n  \"../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js\"(exports, module2) {\n    module2.exports = [\n      \"SIGABRT\",\n      \"SIGALRM\",\n      \"SIGHUP\",\n      \"SIGINT\",\n      \"SIGTERM\"\n    ];\n    if (process.platform !== \"win32\") {\n      module2.exports.push(\n        \"SIGVTALRM\",\n        \"SIGXCPU\",\n        \"SIGXFSZ\",\n        \"SIGUSR2\",\n        \"SIGTRAP\",\n        \"SIGSYS\",\n        \"SIGQUIT\",\n        \"SIGIOT\"\n      );\n    }\n    if (process.platform === \"linux\") {\n      module2.exports.push(\n        \"SIGIO\",\n        \"SIGPOLL\",\n        \"SIGPWR\",\n        \"SIGSTKFLT\",\n        \"SIGUNUSED\"\n      );\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js\nvar require_signal_exit = __commonJS({\n  \"../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js\"(exports, module2) {\n    var process2 = global.process;\n    var processOk = /* @__PURE__ */ __name(function(process3) {\n      return process3 && typeof process3 === \"object\" && typeof process3.removeListener === \"function\" && typeof process3.emit === \"function\" && typeof process3.reallyExit === \"function\" && typeof process3.listeners === \"function\" && typeof process3.kill === \"function\" && typeof process3.pid === \"number\" && typeof process3.on === \"function\";\n    }, \"processOk\");\n    if (!processOk(process2)) {\n      module2.exports = function() {\n        return function() {\n        };\n      };\n    } else {\n      assert = __webpack_require__(/*! assert */ \"assert\");\n      signals = require_signals2();\n      isWin = /^win/i.test(process2.platform);\n      EE = __webpack_require__(/*! events */ \"events\");\n      if (typeof EE !== \"function\") {\n        EE = EE.EventEmitter;\n      }\n      if (process2.__signal_exit_emitter__) {\n        emitter = process2.__signal_exit_emitter__;\n      } else {\n        emitter = process2.__signal_exit_emitter__ = new EE();\n        emitter.count = 0;\n        emitter.emitted = {};\n      }\n      if (!emitter.infinite) {\n        emitter.setMaxListeners(Infinity);\n        emitter.infinite = true;\n      }\n      module2.exports = function(cb, opts) {\n        if (!processOk(global.process)) {\n          return function() {\n          };\n        }\n        assert.equal(typeof cb, \"function\", \"a callback must be provided for exit handler\");\n        if (loaded === false) {\n          load();\n        }\n        var ev = \"exit\";\n        if (opts && opts.alwaysLast) {\n          ev = \"afterexit\";\n        }\n        var remove = /* @__PURE__ */ __name(function() {\n          emitter.removeListener(ev, cb);\n          if (emitter.listeners(\"exit\").length === 0 && emitter.listeners(\"afterexit\").length === 0) {\n            unload();\n          }\n        }, \"remove\");\n        emitter.on(ev, cb);\n        return remove;\n      };\n      unload = /* @__PURE__ */ __name(function unload2() {\n        if (!loaded || !processOk(global.process)) {\n          return;\n        }\n        loaded = false;\n        signals.forEach(function(sig) {\n          try {\n            process2.removeListener(sig, sigListeners[sig]);\n          } catch (er) {\n          }\n        });\n        process2.emit = originalProcessEmit;\n        process2.reallyExit = originalProcessReallyExit;\n        emitter.count -= 1;\n      }, \"unload\");\n      module2.exports.unload = unload;\n      emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {\n        if (emitter.emitted[event]) {\n          return;\n        }\n        emitter.emitted[event] = true;\n        emitter.emit(event, code, signal);\n      }, \"emit\");\n      sigListeners = {};\n      signals.forEach(function(sig) {\n        sigListeners[sig] = /* @__PURE__ */ __name(function listener() {\n          if (!processOk(global.process)) {\n            return;\n          }\n          var listeners = process2.listeners(sig);\n          if (listeners.length === emitter.count) {\n            unload();\n            emit(\"exit\", null, sig);\n            emit(\"afterexit\", null, sig);\n            if (isWin && sig === \"SIGHUP\") {\n              sig = \"SIGINT\";\n            }\n            process2.kill(process2.pid, sig);\n          }\n        }, \"listener\");\n      });\n      module2.exports.signals = function() {\n        return signals;\n      };\n      loaded = false;\n      load = /* @__PURE__ */ __name(function load2() {\n        if (loaded || !processOk(global.process)) {\n          return;\n        }\n        loaded = true;\n        emitter.count += 1;\n        signals = signals.filter(function(sig) {\n          try {\n            process2.on(sig, sigListeners[sig]);\n            return true;\n          } catch (er) {\n            return false;\n          }\n        });\n        process2.emit = processEmit;\n        process2.reallyExit = processReallyExit;\n      }, \"load\");\n      module2.exports.load = load;\n      originalProcessReallyExit = process2.reallyExit;\n      processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {\n        if (!processOk(global.process)) {\n          return;\n        }\n        process2.exitCode = code || 0;\n        emit(\"exit\", process2.exitCode, null);\n        emit(\"afterexit\", process2.exitCode, null);\n        originalProcessReallyExit.call(process2, process2.exitCode);\n      }, \"processReallyExit\");\n      originalProcessEmit = process2.emit;\n      processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg2) {\n        if (ev === \"exit\" && processOk(global.process)) {\n          if (arg2 !== void 0) {\n            process2.exitCode = arg2;\n          }\n          var ret = originalProcessEmit.apply(this, arguments);\n          emit(\"exit\", process2.exitCode, null);\n          emit(\"afterexit\", process2.exitCode, null);\n          return ret;\n        } else {\n          return originalProcessEmit.apply(this, arguments);\n        }\n      }, \"processEmit\");\n    }\n    var assert;\n    var signals;\n    var isWin;\n    var EE;\n    var emitter;\n    var unload;\n    var emit;\n    var sigListeners;\n    var loaded;\n    var load;\n    var originalProcessReallyExit;\n    var processReallyExit;\n    var originalProcessEmit;\n    var processEmit;\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js\nvar require_kill = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js\"(exports, module2) {\n    \"use strict\";\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var onExit = require_signal_exit();\n    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;\n    var spawnedKill = /* @__PURE__ */ __name((kill, signal = \"SIGTERM\", options = {}) => {\n      const killResult = kill(signal);\n      setKillTimeout(kill, signal, options, killResult);\n      return killResult;\n    }, \"spawnedKill\");\n    var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options, killResult) => {\n      if (!shouldForceKill(signal, options, killResult)) {\n        return;\n      }\n      const timeout = getForceKillAfterTimeout(options);\n      const t = setTimeout(() => {\n        kill(\"SIGKILL\");\n      }, timeout);\n      if (t.unref) {\n        t.unref();\n      }\n    }, \"setKillTimeout\");\n    var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {\n      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n    }, \"shouldForceKill\");\n    var isSigterm = /* @__PURE__ */ __name((signal) => {\n      return signal === os3.constants.signals.SIGTERM || typeof signal === \"string\" && signal.toUpperCase() === \"SIGTERM\";\n    }, \"isSigterm\");\n    var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {\n      if (forceKillAfterTimeout === true) {\n        return DEFAULT_FORCE_KILL_TIMEOUT;\n      }\n      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n        throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n      }\n      return forceKillAfterTimeout;\n    }, \"getForceKillAfterTimeout\");\n    var spawnedCancel = /* @__PURE__ */ __name((spawned, context3) => {\n      const killResult = spawned.kill();\n      if (killResult) {\n        context3.isCanceled = true;\n      }\n    }, \"spawnedCancel\");\n    var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject) => {\n      spawned.kill(signal);\n      reject(Object.assign(new Error(\"Timed out\"), { timedOut: true, signal }));\n    }, \"timeoutKill\");\n    var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = \"SIGTERM\" }, spawnedPromise) => {\n      if (timeout === 0 || timeout === void 0) {\n        return spawnedPromise;\n      }\n      let timeoutId;\n      const timeoutPromise = new Promise((resolve, reject) => {\n        timeoutId = setTimeout(() => {\n          timeoutKill(spawned, killSignal, reject);\n        }, timeout);\n      });\n      const safeSpawnedPromise = spawnedPromise.finally(() => {\n        clearTimeout(timeoutId);\n      });\n      return Promise.race([timeoutPromise, safeSpawnedPromise]);\n    }, \"setupTimeout\");\n    var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {\n      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {\n        throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n      }\n    }, \"validateTimeout\");\n    var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {\n      if (!cleanup || detached) {\n        return timedPromise;\n      }\n      const removeExitHandler = onExit(() => {\n        spawned.kill();\n      });\n      return timedPromise.finally(() => {\n        removeExitHandler();\n      });\n    }, \"setExitHandler\");\n    module2.exports = {\n      spawnedKill,\n      spawnedCancel,\n      setupTimeout,\n      validateTimeout,\n      setExitHandler\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js\nvar require_is_stream = __commonJS({\n  \"../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var isStream = /* @__PURE__ */ __name((stream2) => stream2 !== null && typeof stream2 === \"object\" && typeof stream2.pipe === \"function\", \"isStream\");\n    isStream.writable = (stream2) => isStream(stream2) && stream2.writable !== false && typeof stream2._write === \"function\" && typeof stream2._writableState === \"object\";\n    isStream.readable = (stream2) => isStream(stream2) && stream2.readable !== false && typeof stream2._read === \"function\" && typeof stream2._readableState === \"object\";\n    isStream.duplex = (stream2) => isStream.writable(stream2) && isStream.readable(stream2);\n    isStream.transform = (stream2) => isStream.duplex(stream2) && typeof stream2._transform === \"function\";\n    module2.exports = isStream;\n  }\n});\n\n// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js\nvar require_buffer_stream = __commonJS({\n  \"../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js\"(exports, module2) {\n    \"use strict\";\n    var { PassThrough: PassThroughStream } = __webpack_require__(/*! stream */ \"stream\");\n    module2.exports = (options) => {\n      options = { ...options };\n      const { array } = options;\n      let { encoding } = options;\n      const isBuffer = encoding === \"buffer\";\n      let objectMode = false;\n      if (array) {\n        objectMode = !(encoding || isBuffer);\n      } else {\n        encoding = encoding || \"utf8\";\n      }\n      if (isBuffer) {\n        encoding = null;\n      }\n      const stream2 = new PassThroughStream({ objectMode });\n      if (encoding) {\n        stream2.setEncoding(encoding);\n      }\n      let length = 0;\n      const chunks = [];\n      stream2.on(\"data\", (chunk) => {\n        chunks.push(chunk);\n        if (objectMode) {\n          length = chunks.length;\n        } else {\n          length += chunk.length;\n        }\n      });\n      stream2.getBufferedValue = () => {\n        if (array) {\n          return chunks;\n        }\n        return isBuffer ? Buffer.concat(chunks, length) : chunks.join(\"\");\n      };\n      stream2.getBufferedLength = () => length;\n      return stream2;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js\nvar require_get_stream = __commonJS({\n  \"../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var { constants: BufferConstants } = __webpack_require__(/*! buffer */ \"buffer\");\n    var stream2 = __webpack_require__(/*! stream */ \"stream\");\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var bufferStream = require_buffer_stream();\n    var streamPipelinePromisified = promisify4(stream2.pipeline);\n    var MaxBufferError = class extends Error {\n      constructor() {\n        super(\"maxBuffer exceeded\");\n        this.name = \"MaxBufferError\";\n      }\n    };\n    __name(MaxBufferError, \"MaxBufferError\");\n    async function getStream2(inputStream, options) {\n      if (!inputStream) {\n        throw new Error(\"Expected a stream\");\n      }\n      options = {\n        maxBuffer: Infinity,\n        ...options\n      };\n      const { maxBuffer } = options;\n      const stream3 = bufferStream(options);\n      await new Promise((resolve, reject) => {\n        const rejectPromise = /* @__PURE__ */ __name((error2) => {\n          if (error2 && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n            error2.bufferedData = stream3.getBufferedValue();\n          }\n          reject(error2);\n        }, \"rejectPromise\");\n        (async () => {\n          try {\n            await streamPipelinePromisified(inputStream, stream3);\n            resolve();\n          } catch (error2) {\n            rejectPromise(error2);\n          }\n        })();\n        stream3.on(\"data\", () => {\n          if (stream3.getBufferedLength() > maxBuffer) {\n            rejectPromise(new MaxBufferError());\n          }\n        });\n      });\n      return stream3.getBufferedValue();\n    }\n    __name(getStream2, \"getStream\");\n    module2.exports = getStream2;\n    module2.exports.buffer = (stream3, options) => getStream2(stream3, { ...options, encoding: \"buffer\" });\n    module2.exports.array = (stream3, options) => getStream2(stream3, { ...options, array: true });\n    module2.exports.MaxBufferError = MaxBufferError;\n  }\n});\n\n// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js\nvar require_merge_stream = __commonJS({\n  \"../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js\"(exports, module2) {\n    \"use strict\";\n    var { PassThrough } = __webpack_require__(/*! stream */ \"stream\");\n    module2.exports = function() {\n      var sources = [];\n      var output = new PassThrough({ objectMode: true });\n      output.setMaxListeners(0);\n      output.add = add2;\n      output.isEmpty = isEmpty;\n      output.on(\"unpipe\", remove);\n      Array.prototype.slice.call(arguments).forEach(add2);\n      return output;\n      function add2(source) {\n        if (Array.isArray(source)) {\n          source.forEach(add2);\n          return this;\n        }\n        sources.push(source);\n        source.once(\"end\", remove.bind(null, source));\n        source.once(\"error\", output.emit.bind(output, \"error\"));\n        source.pipe(output, { end: false });\n        return this;\n      }\n      __name(add2, \"add\");\n      function isEmpty() {\n        return sources.length == 0;\n      }\n      __name(isEmpty, \"isEmpty\");\n      function remove(source) {\n        sources = sources.filter(function(it) {\n          return it !== source;\n        });\n        if (!sources.length && output.readable) {\n          output.end();\n        }\n      }\n      __name(remove, \"remove\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js\nvar require_stream = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js\"(exports, module2) {\n    \"use strict\";\n    var isStream = require_is_stream();\n    var getStream2 = require_get_stream();\n    var mergeStream = require_merge_stream();\n    var handleInput = /* @__PURE__ */ __name((spawned, input) => {\n      if (input === void 0 || spawned.stdin === void 0) {\n        return;\n      }\n      if (isStream(input)) {\n        input.pipe(spawned.stdin);\n      } else {\n        spawned.stdin.end(input);\n      }\n    }, \"handleInput\");\n    var makeAllStream = /* @__PURE__ */ __name((spawned, { all }) => {\n      if (!all || !spawned.stdout && !spawned.stderr) {\n        return;\n      }\n      const mixed = mergeStream();\n      if (spawned.stdout) {\n        mixed.add(spawned.stdout);\n      }\n      if (spawned.stderr) {\n        mixed.add(spawned.stderr);\n      }\n      return mixed;\n    }, \"makeAllStream\");\n    var getBufferedData = /* @__PURE__ */ __name(async (stream2, streamPromise) => {\n      if (!stream2) {\n        return;\n      }\n      stream2.destroy();\n      try {\n        return await streamPromise;\n      } catch (error2) {\n        return error2.bufferedData;\n      }\n    }, \"getBufferedData\");\n    var getStreamPromise = /* @__PURE__ */ __name((stream2, { encoding, buffer, maxBuffer }) => {\n      if (!stream2 || !buffer) {\n        return;\n      }\n      if (encoding) {\n        return getStream2(stream2, { encoding, maxBuffer });\n      }\n      return getStream2.buffer(stream2, { maxBuffer });\n    }, \"getStreamPromise\");\n    var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {\n      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });\n      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });\n      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });\n      try {\n        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n      } catch (error2) {\n        return Promise.all([\n          { error: error2, signal: error2.signal, timedOut: error2.timedOut },\n          getBufferedData(stdout, stdoutPromise),\n          getBufferedData(stderr, stderrPromise),\n          getBufferedData(all, allPromise)\n        ]);\n      }\n    }, \"getSpawnedResult\");\n    var validateInputSync = /* @__PURE__ */ __name(({ input }) => {\n      if (isStream(input)) {\n        throw new TypeError(\"The `input` option cannot be a stream in sync mode\");\n      }\n    }, \"validateInputSync\");\n    module2.exports = {\n      handleInput,\n      makeAllStream,\n      getSpawnedResult,\n      validateInputSync\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js\nvar require_promise = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js\"(exports, module2) {\n    \"use strict\";\n    var nativePromisePrototype = (async () => {\n    })().constructor.prototype;\n    var descriptors = [\"then\", \"catch\", \"finally\"].map((property) => [\n      property,\n      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)\n    ]);\n    var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {\n      for (const [property, descriptor] of descriptors) {\n        const value = typeof promise === \"function\" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);\n        Reflect.defineProperty(spawned, property, { ...descriptor, value });\n      }\n      return spawned;\n    }, \"mergePromise\");\n    var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {\n      return new Promise((resolve, reject) => {\n        spawned.on(\"exit\", (exitCode, signal) => {\n          resolve({ exitCode, signal });\n        });\n        spawned.on(\"error\", (error2) => {\n          reject(error2);\n        });\n        if (spawned.stdin) {\n          spawned.stdin.on(\"error\", (error2) => {\n            reject(error2);\n          });\n        }\n      });\n    }, \"getSpawnedPromise\");\n    module2.exports = {\n      mergePromise,\n      getSpawnedPromise\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js\nvar require_command = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js\"(exports, module2) {\n    \"use strict\";\n    var normalizeArgs = /* @__PURE__ */ __name((file, args = []) => {\n      if (!Array.isArray(args)) {\n        return [file];\n      }\n      return [file, ...args];\n    }, \"normalizeArgs\");\n    var NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\n    var DOUBLE_QUOTES_REGEXP = /\"/g;\n    var escapeArg = /* @__PURE__ */ __name((arg2) => {\n      if (typeof arg2 !== \"string\" || NO_ESCAPE_REGEXP.test(arg2)) {\n        return arg2;\n      }\n      return `\"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n    }, \"escapeArg\");\n    var joinCommand = /* @__PURE__ */ __name((file, args) => {\n      return normalizeArgs(file, args).join(\" \");\n    }, \"joinCommand\");\n    var getEscapedCommand = /* @__PURE__ */ __name((file, args) => {\n      return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(\" \");\n    }, \"getEscapedCommand\");\n    var SPACES_REGEXP = / +/g;\n    var parseCommand = /* @__PURE__ */ __name((command) => {\n      const tokens = [];\n      for (const token of command.trim().split(SPACES_REGEXP)) {\n        const previousToken = tokens[tokens.length - 1];\n        if (previousToken && previousToken.endsWith(\"\\\\\")) {\n          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n        } else {\n          tokens.push(token);\n        }\n      }\n      return tokens;\n    }, \"parseCommand\");\n    module2.exports = {\n      joinCommand,\n      getEscapedCommand,\n      parseCommand\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js\nvar require_execa = __commonJS({\n  \"../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js\"(exports, module2) {\n    \"use strict\";\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var childProcess = __webpack_require__(/*! child_process */ \"child_process\");\n    var crossSpawn = require_cross_spawn();\n    var stripFinalNewline = require_strip_final_newline();\n    var npmRunPath = require_npm_run_path();\n    var onetime = require_onetime();\n    var makeError = require_error();\n    var normalizeStdio = require_stdio();\n    var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();\n    var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();\n    var { mergePromise, getSpawnedPromise } = require_promise();\n    var { joinCommand, parseCommand, getEscapedCommand } = require_command();\n    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;\n    var getEnv2 = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {\n      const env2 = extendEnv ? { ...process.env, ...envOption } : envOption;\n      if (preferLocal) {\n        return npmRunPath.env({ env: env2, cwd: localDir, execPath });\n      }\n      return env2;\n    }, \"getEnv\");\n    var handleArguments = /* @__PURE__ */ __name((file, args, options = {}) => {\n      const parsed = crossSpawn._parse(file, args, options);\n      file = parsed.command;\n      args = parsed.args;\n      options = parsed.options;\n      options = {\n        maxBuffer: DEFAULT_MAX_BUFFER,\n        buffer: true,\n        stripFinalNewline: true,\n        extendEnv: true,\n        preferLocal: false,\n        localDir: options.cwd || process.cwd(),\n        execPath: process.execPath,\n        encoding: \"utf8\",\n        reject: true,\n        cleanup: true,\n        all: false,\n        windowsHide: true,\n        ...options\n      };\n      options.env = getEnv2(options);\n      options.stdio = normalizeStdio(options);\n      if (process.platform === \"win32\" && path7.basename(file, \".exe\") === \"cmd\") {\n        args.unshift(\"/q\");\n      }\n      return { file, args, options, parsed };\n    }, \"handleArguments\");\n    var handleOutput = /* @__PURE__ */ __name((options, value, error2) => {\n      if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n        return error2 === void 0 ? void 0 : \"\";\n      }\n      if (options.stripFinalNewline) {\n        return stripFinalNewline(value);\n      }\n      return value;\n    }, \"handleOutput\");\n    var execa2 = /* @__PURE__ */ __name((file, args, options) => {\n      const parsed = handleArguments(file, args, options);\n      const command = joinCommand(file, args);\n      const escapedCommand = getEscapedCommand(file, args);\n      validateTimeout(parsed.options);\n      let spawned;\n      try {\n        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n      } catch (error2) {\n        const dummySpawned = new childProcess.ChildProcess();\n        const errorPromise = Promise.reject(makeError({\n          error: error2,\n          stdout: \"\",\n          stderr: \"\",\n          all: \"\",\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        }));\n        return mergePromise(dummySpawned, errorPromise);\n      }\n      const spawnedPromise = getSpawnedPromise(spawned);\n      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n      const processDone = setExitHandler(spawned, parsed.options, timedPromise);\n      const context3 = { isCanceled: false };\n      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n      spawned.cancel = spawnedCancel.bind(null, spawned, context3);\n      const handlePromise = /* @__PURE__ */ __name(async () => {\n        const [{ error: error2, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n        const stdout = handleOutput(parsed.options, stdoutResult);\n        const stderr = handleOutput(parsed.options, stderrResult);\n        const all = handleOutput(parsed.options, allResult);\n        if (error2 || exitCode !== 0 || signal !== null) {\n          const returnedError = makeError({\n            error: error2,\n            exitCode,\n            signal,\n            stdout,\n            stderr,\n            all,\n            command,\n            escapedCommand,\n            parsed,\n            timedOut,\n            isCanceled: context3.isCanceled,\n            killed: spawned.killed\n          });\n          if (!parsed.options.reject) {\n            return returnedError;\n          }\n          throw returnedError;\n        }\n        return {\n          command,\n          escapedCommand,\n          exitCode: 0,\n          stdout,\n          stderr,\n          all,\n          failed: false,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        };\n      }, \"handlePromise\");\n      const handlePromiseOnce = onetime(handlePromise);\n      handleInput(spawned, parsed.options.input);\n      spawned.all = makeAllStream(spawned, parsed.options);\n      return mergePromise(spawned, handlePromiseOnce);\n    }, \"execa\");\n    module2.exports = execa2;\n    module2.exports.sync = (file, args, options) => {\n      const parsed = handleArguments(file, args, options);\n      const command = joinCommand(file, args);\n      const escapedCommand = getEscapedCommand(file, args);\n      validateInputSync(parsed.options);\n      let result;\n      try {\n        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n      } catch (error2) {\n        throw makeError({\n          error: error2,\n          stdout: \"\",\n          stderr: \"\",\n          all: \"\",\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: false,\n          isCanceled: false,\n          killed: false\n        });\n      }\n      const stdout = handleOutput(parsed.options, result.stdout, result.error);\n      const stderr = handleOutput(parsed.options, result.stderr, result.error);\n      if (result.error || result.status !== 0 || result.signal !== null) {\n        const error2 = makeError({\n          stdout,\n          stderr,\n          error: result.error,\n          signal: result.signal,\n          exitCode: result.status,\n          command,\n          escapedCommand,\n          parsed,\n          timedOut: result.error && result.error.code === \"ETIMEDOUT\",\n          isCanceled: false,\n          killed: result.signal !== null\n        });\n        if (!parsed.options.reject) {\n          return error2;\n        }\n        throw error2;\n      }\n      return {\n        command,\n        escapedCommand,\n        exitCode: 0,\n        stdout,\n        stderr,\n        failed: false,\n        timedOut: false,\n        isCanceled: false,\n        killed: false\n      };\n    };\n    module2.exports.command = (command, options) => {\n      const [file, ...args] = parseCommand(command);\n      return execa2(file, args, options);\n    };\n    module2.exports.commandSync = (command, options) => {\n      const [file, ...args] = parseCommand(command);\n      return execa2.sync(file, args, options);\n    };\n    module2.exports.node = (scriptPath, args, options = {}) => {\n      if (args && !Array.isArray(args) && typeof args === \"object\") {\n        options = args;\n        args = [];\n      }\n      const stdio = normalizeStdio.node(options);\n      const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith(\"--inspect\"));\n      const {\n        nodePath = process.execPath,\n        nodeOptions = defaultExecArgv\n      } = options;\n      return execa2(\n        nodePath,\n        [\n          ...nodeOptions,\n          scriptPath,\n          ...Array.isArray(args) ? args : []\n        ],\n        {\n          ...options,\n          stdin: void 0,\n          stdout: void 0,\n          stderr: void 0,\n          stdio,\n          shell: false\n        }\n      );\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js\nvar require_retry_operation = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js\"(exports, module2) {\n    function RetryOperation(timeouts, options) {\n      if (typeof options === \"boolean\") {\n        options = { forever: options };\n      }\n      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n      this._timeouts = timeouts;\n      this._options = options || {};\n      this._maxRetryTime = options && options.maxRetryTime || Infinity;\n      this._fn = null;\n      this._errors = [];\n      this._attempts = 1;\n      this._operationTimeout = null;\n      this._operationTimeoutCb = null;\n      this._timeout = null;\n      this._operationStart = null;\n      this._timer = null;\n      if (this._options.forever) {\n        this._cachedTimeouts = this._timeouts.slice(0);\n      }\n    }\n    __name(RetryOperation, \"RetryOperation\");\n    module2.exports = RetryOperation;\n    RetryOperation.prototype.reset = function() {\n      this._attempts = 1;\n      this._timeouts = this._originalTimeouts.slice(0);\n    };\n    RetryOperation.prototype.stop = function() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n      if (this._timer) {\n        clearTimeout(this._timer);\n      }\n      this._timeouts = [];\n      this._cachedTimeouts = null;\n    };\n    RetryOperation.prototype.retry = function(err) {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n      if (!err) {\n        return false;\n      }\n      var currentTime = new Date().getTime();\n      if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n        this._errors.push(err);\n        this._errors.unshift(new Error(\"RetryOperation timeout occurred\"));\n        return false;\n      }\n      this._errors.push(err);\n      var timeout = this._timeouts.shift();\n      if (timeout === void 0) {\n        if (this._cachedTimeouts) {\n          this._errors.splice(0, this._errors.length - 1);\n          timeout = this._cachedTimeouts.slice(-1);\n        } else {\n          return false;\n        }\n      }\n      var self2 = this;\n      this._timer = setTimeout(function() {\n        self2._attempts++;\n        if (self2._operationTimeoutCb) {\n          self2._timeout = setTimeout(function() {\n            self2._operationTimeoutCb(self2._attempts);\n          }, self2._operationTimeout);\n          if (self2._options.unref) {\n            self2._timeout.unref();\n          }\n        }\n        self2._fn(self2._attempts);\n      }, timeout);\n      if (this._options.unref) {\n        this._timer.unref();\n      }\n      return true;\n    };\n    RetryOperation.prototype.attempt = function(fn, timeoutOps) {\n      this._fn = fn;\n      if (timeoutOps) {\n        if (timeoutOps.timeout) {\n          this._operationTimeout = timeoutOps.timeout;\n        }\n        if (timeoutOps.cb) {\n          this._operationTimeoutCb = timeoutOps.cb;\n        }\n      }\n      var self2 = this;\n      if (this._operationTimeoutCb) {\n        this._timeout = setTimeout(function() {\n          self2._operationTimeoutCb();\n        }, self2._operationTimeout);\n      }\n      this._operationStart = new Date().getTime();\n      this._fn(this._attempts);\n    };\n    RetryOperation.prototype.try = function(fn) {\n      console.log(\"Using RetryOperation.try() is deprecated\");\n      this.attempt(fn);\n    };\n    RetryOperation.prototype.start = function(fn) {\n      console.log(\"Using RetryOperation.start() is deprecated\");\n      this.attempt(fn);\n    };\n    RetryOperation.prototype.start = RetryOperation.prototype.try;\n    RetryOperation.prototype.errors = function() {\n      return this._errors;\n    };\n    RetryOperation.prototype.attempts = function() {\n      return this._attempts;\n    };\n    RetryOperation.prototype.mainError = function() {\n      if (this._errors.length === 0) {\n        return null;\n      }\n      var counts = {};\n      var mainError = null;\n      var mainErrorCount = 0;\n      for (var i = 0; i < this._errors.length; i++) {\n        var error2 = this._errors[i];\n        var message = error2.message;\n        var count2 = (counts[message] || 0) + 1;\n        counts[message] = count2;\n        if (count2 >= mainErrorCount) {\n          mainError = error2;\n          mainErrorCount = count2;\n        }\n      }\n      return mainError;\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js\nvar require_retry = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js\"(exports) {\n    var RetryOperation = require_retry_operation();\n    exports.operation = function(options) {\n      var timeouts = exports.timeouts(options);\n      return new RetryOperation(timeouts, {\n        forever: options && (options.forever || options.retries === Infinity),\n        unref: options && options.unref,\n        maxRetryTime: options && options.maxRetryTime\n      });\n    };\n    exports.timeouts = function(options) {\n      if (options instanceof Array) {\n        return [].concat(options);\n      }\n      var opts = {\n        retries: 10,\n        factor: 2,\n        minTimeout: 1 * 1e3,\n        maxTimeout: Infinity,\n        randomize: false\n      };\n      for (var key in options) {\n        opts[key] = options[key];\n      }\n      if (opts.minTimeout > opts.maxTimeout) {\n        throw new Error(\"minTimeout is greater than maxTimeout\");\n      }\n      var timeouts = [];\n      for (var i = 0; i < opts.retries; i++) {\n        timeouts.push(this.createTimeout(i, opts));\n      }\n      if (options && options.forever && !timeouts.length) {\n        timeouts.push(this.createTimeout(i, opts));\n      }\n      timeouts.sort(function(a, b) {\n        return a - b;\n      });\n      return timeouts;\n    };\n    exports.createTimeout = function(attempt, opts) {\n      var random2 = opts.randomize ? Math.random() + 1 : 1;\n      var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n      timeout = Math.min(timeout, opts.maxTimeout);\n      return timeout;\n    };\n    exports.wrap = function(obj, options, methods) {\n      if (options instanceof Array) {\n        methods = options;\n        options = null;\n      }\n      if (!methods) {\n        methods = [];\n        for (var key in obj) {\n          if (typeof obj[key] === \"function\") {\n            methods.push(key);\n          }\n        }\n      }\n      for (var i = 0; i < methods.length; i++) {\n        var method = methods[i];\n        var original = obj[method];\n        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {\n          var op = exports.operation(options);\n          var args = Array.prototype.slice.call(arguments, 1);\n          var callback = args.pop();\n          args.push(function(err) {\n            if (op.retry(err)) {\n              return;\n            }\n            if (err) {\n              arguments[0] = op.mainError();\n            }\n            callback.apply(this, arguments);\n          });\n          op.attempt(function() {\n            original2.apply(obj, args);\n          });\n        }, \"retryWrapper\")).bind(obj, original);\n        obj[method].options = options;\n      }\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js\nvar require_retry2 = __commonJS({\n  \"../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js\"(exports, module2) {\n    module2.exports = require_retry();\n  }\n});\n\n// ../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js\nvar require_p_retry = __commonJS({\n  \"../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js\"(exports, module2) {\n    \"use strict\";\n    var retry = require_retry2();\n    var networkErrorMsgs = [\n      \"Failed to fetch\",\n      \"NetworkError when attempting to fetch resource.\",\n      \"The Internet connection appears to be offline.\",\n      \"Network request failed\"\n    ];\n    var AbortError = class extends Error {\n      constructor(message) {\n        super();\n        if (message instanceof Error) {\n          this.originalError = message;\n          ({ message } = message);\n        } else {\n          this.originalError = new Error(message);\n          this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n      }\n    };\n    __name(AbortError, \"AbortError\");\n    var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options) => {\n      const retriesLeft = options.retries - (attemptNumber - 1);\n      error2.attemptNumber = attemptNumber;\n      error2.retriesLeft = retriesLeft;\n      return error2;\n    }, \"decorateErrorWithCounts\");\n    var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), \"isNetworkError\");\n    var pRetry2 = /* @__PURE__ */ __name((input, options) => new Promise((resolve, reject) => {\n      options = {\n        onFailedAttempt: () => {\n        },\n        retries: 10,\n        ...options\n      };\n      const operation = retry.operation(options);\n      operation.attempt(async (attemptNumber) => {\n        try {\n          resolve(await input(attemptNumber));\n        } catch (error2) {\n          if (!(error2 instanceof Error)) {\n            reject(new TypeError(`Non-error was thrown: \"${error2}\". You should only throw errors.`));\n            return;\n          }\n          if (error2 instanceof AbortError) {\n            operation.stop();\n            reject(error2.originalError);\n          } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {\n            operation.stop();\n            reject(error2);\n          } else {\n            decorateErrorWithCounts(error2, attemptNumber, options);\n            try {\n              await options.onFailedAttempt(error2);\n            } catch (error3) {\n              reject(error3);\n              return;\n            }\n            if (!operation.retry(error2)) {\n              reject(operation.mainError());\n            }\n          }\n        }\n      });\n    }), \"pRetry\");\n    module2.exports = pRetry2;\n    module2.exports.default = pRetry2;\n    module2.exports.AbortError = AbortError;\n  }\n});\n\n// ../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js\nvar require_ansi_regex = __commonJS({\n  \"../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = ({ onlyFirst = false } = {}) => {\n      const pattern = [\n        \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n        \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"\n      ].join(\"|\");\n      return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js\nvar require_strip_ansi = __commonJS({\n  \"../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js\"(exports, module2) {\n    \"use strict\";\n    var ansiRegex = require_ansi_regex();\n    module2.exports = (string) => typeof string === \"string\" ? string.replace(ansiRegex(), \"\") : string;\n  }\n});\n\n// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js\nvar require_new_github_issue_url = __commonJS({\n  \"../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (options = {}) => {\n      let repoUrl;\n      if (options.repoUrl) {\n        repoUrl = options.repoUrl;\n      } else if (options.user && options.repo) {\n        repoUrl = `https://github.com/${options.user}/${options.repo}`;\n      } else {\n        throw new Error(\"You need to specify either the `repoUrl` option or both the `user` and `repo` options\");\n      }\n      const url = new URL(`${repoUrl}/issues/new`);\n      const types = [\n        \"body\",\n        \"title\",\n        \"labels\",\n        \"template\",\n        \"milestone\",\n        \"assignee\",\n        \"projects\"\n      ];\n      for (const type of types) {\n        let value = options[type];\n        if (value === void 0) {\n          continue;\n        }\n        if (type === \"labels\" || type === \"projects\") {\n          if (!Array.isArray(value)) {\n            throw new TypeError(`The \\`${type}\\` option should be an array`);\n          }\n          value = value.join(\",\");\n        }\n        url.searchParams.set(type, value);\n      }\n      return url.toString();\n    };\n    module2.exports.default = module2.exports;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/symbols.js\nvar require_symbols = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/symbols.js\"(exports, module2) {\n    module2.exports = {\n      kClose: Symbol(\"close\"),\n      kDestroy: Symbol(\"destroy\"),\n      kDispatch: Symbol(\"dispatch\"),\n      kUrl: Symbol(\"url\"),\n      kWriting: Symbol(\"writing\"),\n      kResuming: Symbol(\"resuming\"),\n      kQueue: Symbol(\"queue\"),\n      kConnect: Symbol(\"connect\"),\n      kConnecting: Symbol(\"connecting\"),\n      kHeadersList: Symbol(\"headers list\"),\n      kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n      kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n      kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n      kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n      kKeepAlive: Symbol(\"keep alive\"),\n      kHeadersTimeout: Symbol(\"headers timeout\"),\n      kBodyTimeout: Symbol(\"body timeout\"),\n      kServerName: Symbol(\"server name\"),\n      kHost: Symbol(\"host\"),\n      kNoRef: Symbol(\"no ref\"),\n      kBodyUsed: Symbol(\"used\"),\n      kRunning: Symbol(\"running\"),\n      kBlocking: Symbol(\"blocking\"),\n      kPending: Symbol(\"pending\"),\n      kSize: Symbol(\"size\"),\n      kBusy: Symbol(\"busy\"),\n      kQueued: Symbol(\"queued\"),\n      kFree: Symbol(\"free\"),\n      kConnected: Symbol(\"connected\"),\n      kClosed: Symbol(\"closed\"),\n      kNeedDrain: Symbol(\"need drain\"),\n      kReset: Symbol(\"reset\"),\n      kDestroyed: Symbol(\"destroyed\"),\n      kMaxHeadersSize: Symbol(\"max headers size\"),\n      kRunningIdx: Symbol(\"running index\"),\n      kPendingIdx: Symbol(\"pending index\"),\n      kError: Symbol(\"error\"),\n      kClients: Symbol(\"clients\"),\n      kClient: Symbol(\"client\"),\n      kParser: Symbol(\"parser\"),\n      kOnDestroyed: Symbol(\"destroy callbacks\"),\n      kPipelining: Symbol(\"pipelinig\"),\n      kSocket: Symbol(\"socket\"),\n      kHostHeader: Symbol(\"host header\"),\n      kConnector: Symbol(\"connector\"),\n      kStrictContentLength: Symbol(\"strict content length\"),\n      kMaxRedirections: Symbol(\"maxRedirections\"),\n      kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n      kProxy: Symbol(\"proxy agent options\"),\n      kCounter: Symbol(\"socket request counter\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/errors.js\nvar require_errors = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/errors.js\"(exports, module2) {\n    \"use strict\";\n    var UndiciError = class extends Error {\n      constructor(message) {\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n      }\n    };\n    __name(UndiciError, \"UndiciError\");\n    var ConnectTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n      }\n    };\n    __name(ConnectTimeoutError, \"ConnectTimeoutError\");\n    var HeadersTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n      }\n    };\n    __name(HeadersTimeoutError, \"HeadersTimeoutError\");\n    var HeadersOverflowError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n      }\n    };\n    __name(HeadersOverflowError, \"HeadersOverflowError\");\n    var BodyTimeoutError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n      }\n    };\n    __name(BodyTimeoutError, \"BodyTimeoutError\");\n    var ResponseStatusCodeError = class extends UndiciError {\n      constructor(message, statusCode, headers, body) {\n        super(message);\n        Error.captureStackTrace(this, ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n      }\n    };\n    __name(ResponseStatusCodeError, \"ResponseStatusCodeError\");\n    var InvalidArgumentError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n      }\n    };\n    __name(InvalidArgumentError, \"InvalidArgumentError\");\n    var InvalidReturnValueError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n      }\n    };\n    __name(InvalidReturnValueError, \"InvalidReturnValueError\");\n    var RequestAbortedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n      }\n    };\n    __name(RequestAbortedError, \"RequestAbortedError\");\n    var InformationalError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n      }\n    };\n    __name(InformationalError, \"InformationalError\");\n    var RequestContentLengthMismatchError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(RequestContentLengthMismatchError, \"RequestContentLengthMismatchError\");\n    var ResponseContentLengthMismatchError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(ResponseContentLengthMismatchError, \"ResponseContentLengthMismatchError\");\n    var ClientDestroyedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n      }\n    };\n    __name(ClientDestroyedError, \"ClientDestroyedError\");\n    var ClientClosedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n      }\n    };\n    __name(ClientClosedError, \"ClientClosedError\");\n    var SocketError = class extends UndiciError {\n      constructor(message, socket) {\n        super(message);\n        Error.captureStackTrace(this, SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n      }\n    };\n    __name(SocketError, \"SocketError\");\n    var NotSupportedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n      }\n    };\n    __name(NotSupportedError, \"NotSupportedError\");\n    var BalancedPoolMissingUpstreamError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n      }\n    };\n    __name(BalancedPoolMissingUpstreamError, \"BalancedPoolMissingUpstreamError\");\n    var HTTPParserError = class extends Error {\n      constructor(message, code, data) {\n        super(message);\n        Error.captureStackTrace(this, HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : void 0;\n        this.data = data ? data.toString() : void 0;\n      }\n    };\n    __name(HTTPParserError, \"HTTPParserError\");\n    module2.exports = {\n      HTTPParserError,\n      UndiciError,\n      HeadersTimeoutError,\n      HeadersOverflowError,\n      BodyTimeoutError,\n      RequestContentLengthMismatchError,\n      ConnectTimeoutError,\n      ResponseStatusCodeError,\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError,\n      ClientDestroyedError,\n      ClientClosedError,\n      InformationalError,\n      SocketError,\n      NotSupportedError,\n      ResponseContentLengthMismatchError,\n      BalancedPoolMissingUpstreamError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/util.js\nvar require_util2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/util.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { kDestroyed, kBodyUsed } = require_symbols();\n    var { IncomingMessage } = __webpack_require__(/*! http */ \"http\");\n    var stream2 = __webpack_require__(/*! stream */ \"stream\");\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var { InvalidArgumentError } = require_errors();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var nodeUtil = __webpack_require__(/*! util */ \"util\");\n    function nop() {\n    }\n    __name(nop, \"nop\");\n    function isStream(obj) {\n      return obj && typeof obj.pipe === \"function\";\n    }\n    __name(isStream, \"isStream\");\n    function isBlobLike(object) {\n      return Blob && object instanceof Blob || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n    __name(isBlobLike, \"isBlobLike\");\n    function isObject3(val) {\n      return val !== null && typeof val === \"object\";\n    }\n    __name(isObject3, \"isObject\");\n    function encode(val) {\n      return encodeURIComponent(val);\n    }\n    __name(encode, \"encode\");\n    function buildURL(url, queryParams) {\n      if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n      }\n      if (!isObject3(queryParams)) {\n        throw new Error(\"Query params must be an object\");\n      }\n      const parts = [];\n      for (let [key, val] of Object.entries(queryParams)) {\n        if (val === null || typeof val === \"undefined\") {\n          continue;\n        }\n        if (!Array.isArray(val)) {\n          val = [val];\n        }\n        for (const v of val) {\n          if (isObject3(v)) {\n            throw new Error(\"Passing object as a query param is not supported, please serialize to string up-front\");\n          }\n          parts.push(encode(key) + \"=\" + encode(v));\n        }\n      }\n      const serializedParams = parts.join(\"&\");\n      if (serializedParams) {\n        url += \"?\" + serializedParams;\n      }\n      return url;\n    }\n    __name(buildURL, \"buildURL\");\n    function parseURL(url) {\n      if (typeof url === \"string\") {\n        url = new URL(url);\n      }\n      if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"invalid url\");\n      }\n      if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n        throw new InvalidArgumentError(\"invalid port\");\n      }\n      if (url.path != null && typeof url.path !== \"string\") {\n        throw new InvalidArgumentError(\"invalid path\");\n      }\n      if (url.pathname != null && typeof url.pathname !== \"string\") {\n        throw new InvalidArgumentError(\"invalid pathname\");\n      }\n      if (url.hostname != null && typeof url.hostname !== \"string\") {\n        throw new InvalidArgumentError(\"invalid hostname\");\n      }\n      if (url.origin != null && typeof url.origin !== \"string\") {\n        throw new InvalidArgumentError(\"invalid origin\");\n      }\n      if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"invalid protocol\");\n      }\n      if (!(url instanceof URL)) {\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;\n        let path7 = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin.endsWith(\"/\")) {\n          origin = origin.substring(0, origin.length - 1);\n        }\n        if (path7 && !path7.startsWith(\"/\")) {\n          path7 = `/${path7}`;\n        }\n        url = new URL(origin + path7);\n      }\n      return url;\n    }\n    __name(parseURL, \"parseURL\");\n    function parseOrigin(url) {\n      url = parseURL(url);\n      if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n      }\n      return url;\n    }\n    __name(parseOrigin, \"parseOrigin\");\n    function getHostname(host) {\n      if (host[0] === \"[\") {\n        const idx2 = host.indexOf(\"]\");\n        assert(idx2 !== -1);\n        return host.substr(1, idx2 - 1);\n      }\n      const idx = host.indexOf(\":\");\n      if (idx === -1)\n        return host;\n      return host.substr(0, idx);\n    }\n    __name(getHostname, \"getHostname\");\n    function getServerName(host) {\n      if (!host) {\n        return null;\n      }\n      assert.strictEqual(typeof host, \"string\");\n      const servername = getHostname(host);\n      if (net2.isIP(servername)) {\n        return \"\";\n      }\n      return servername;\n    }\n    __name(getServerName, \"getServerName\");\n    function deepClone2(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n    __name(deepClone2, \"deepClone\");\n    function isAsyncIterable(obj) {\n      return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n    }\n    __name(isAsyncIterable, \"isAsyncIterable\");\n    function isIterable(obj) {\n      return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n    }\n    __name(isIterable, \"isIterable\");\n    function bodyLength(body) {\n      if (body == null) {\n        return 0;\n      } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n      } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n      } else if (isBuffer(body)) {\n        return body.byteLength;\n      }\n      return null;\n    }\n    __name(bodyLength, \"bodyLength\");\n    function isDestroyed(stream3) {\n      return !stream3 || !!(stream3.destroyed || stream3[kDestroyed]);\n    }\n    __name(isDestroyed, \"isDestroyed\");\n    function isReadableAborted(stream3) {\n      const state = stream3 && stream3._readableState;\n      return isDestroyed(stream3) && state && !state.endEmitted;\n    }\n    __name(isReadableAborted, \"isReadableAborted\");\n    function destroy(stream3, err) {\n      if (!isStream(stream3) || isDestroyed(stream3)) {\n        return;\n      }\n      if (typeof stream3.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream3).constructor === IncomingMessage) {\n          stream3.socket = null;\n        }\n        stream3.destroy(err);\n      } else if (err) {\n        process.nextTick((stream4, err2) => {\n          stream4.emit(\"error\", err2);\n        }, stream3, err);\n      }\n      if (stream3.destroyed !== true) {\n        stream3[kDestroyed] = true;\n      }\n    }\n    __name(destroy, \"destroy\");\n    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\n    function parseKeepAliveTimeout(val) {\n      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n      return m ? parseInt(m[1], 10) * 1e3 : null;\n    }\n    __name(parseKeepAliveTimeout, \"parseKeepAliveTimeout\");\n    function parseHeaders(headers, obj = {}) {\n      for (let i = 0; i < headers.length; i += 2) {\n        const key = headers[i].toString().toLowerCase();\n        let val = obj[key];\n        if (!val) {\n          if (Array.isArray(headers[i + 1])) {\n            obj[key] = headers[i + 1];\n          } else {\n            obj[key] = headers[i + 1].toString();\n          }\n        } else {\n          if (!Array.isArray(val)) {\n            val = [val];\n            obj[key] = val;\n          }\n          val.push(headers[i + 1].toString());\n        }\n      }\n      return obj;\n    }\n    __name(parseHeaders, \"parseHeaders\");\n    function parseRawHeaders(headers) {\n      return headers.map((header) => header.toString());\n    }\n    __name(parseRawHeaders, \"parseRawHeaders\");\n    function isBuffer(buffer) {\n      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n    }\n    __name(isBuffer, \"isBuffer\");\n    function validateHandler(handler, method, upgrade) {\n      if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n      }\n      if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n      }\n      if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n      }\n      if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== void 0) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n      }\n      if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n      } else {\n        if (typeof handler.onHeaders !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n      }\n    }\n    __name(validateHandler, \"validateHandler\");\n    function isDisturbed(body) {\n      return !!(body && (stream2.isDisturbed ? stream2.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));\n    }\n    __name(isDisturbed, \"isDisturbed\");\n    function isErrored(body) {\n      return !!(body && (stream2.isErrored ? stream2.isErrored(body) : /state: 'errored'/.test(\n        nodeUtil.inspect(body)\n      )));\n    }\n    __name(isErrored, \"isErrored\");\n    function isReadable(body) {\n      return !!(body && (stream2.isReadable ? stream2.isReadable(body) : /state: 'readable'/.test(\n        nodeUtil.inspect(body)\n      )));\n    }\n    __name(isReadable, \"isReadable\");\n    function getSocketInfo(socket) {\n      return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n      };\n    }\n    __name(getSocketInfo, \"getSocketInfo\");\n    var ReadableStream;\n    function ReadableStreamFrom(iterable) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      if (ReadableStream.from) {\n        return ReadableStream.from(iterable);\n      }\n      let iterator;\n      return new ReadableStream(\n        {\n          async start() {\n            iterator = iterable[Symbol.asyncIterator]();\n          },\n          async pull(controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n              queueMicrotask(() => {\n                controller.close();\n              });\n            } else {\n              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n              controller.enqueue(new Uint8Array(buf));\n            }\n            return controller.desiredSize > 0;\n          },\n          async cancel(reason) {\n            await iterator.return();\n          }\n        },\n        0\n      );\n    }\n    __name(ReadableStreamFrom, \"ReadableStreamFrom\");\n    function isFormDataLike(chunk) {\n      return chunk && chunk.constructor && chunk.constructor.name === \"FormData\";\n    }\n    __name(isFormDataLike, \"isFormDataLike\");\n    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);\n    kEnumerableProperty.enumerable = true;\n    module2.exports = {\n      kEnumerableProperty,\n      nop,\n      isDisturbed,\n      isErrored,\n      isReadable,\n      toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),\n      isReadableAborted,\n      isBlobLike,\n      parseOrigin,\n      parseURL,\n      getServerName,\n      isStream,\n      isIterable,\n      isAsyncIterable,\n      isDestroyed,\n      parseRawHeaders,\n      parseHeaders,\n      parseKeepAliveTimeout,\n      destroy,\n      bodyLength,\n      deepClone: deepClone2,\n      ReadableStreamFrom,\n      isBuffer,\n      validateHandler,\n      getSocketInfo,\n      isFormDataLike,\n      buildURL\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/constants.js\nvar require_constants = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/constants.js\"(exports, module2) {\n    \"use strict\";\n    var corsSafeListedMethods = [\"GET\", \"HEAD\", \"POST\"];\n    var nullBodyStatus = [101, 204, 205, 304];\n    var redirectStatus = [301, 302, 303, 307, 308];\n    var referrerPolicy = [\n      \"\",\n      \"no-referrer\",\n      \"no-referrer-when-downgrade\",\n      \"same-origin\",\n      \"origin\",\n      \"strict-origin\",\n      \"origin-when-cross-origin\",\n      \"strict-origin-when-cross-origin\",\n      \"unsafe-url\"\n    ];\n    var requestRedirect = [\"follow\", \"manual\", \"error\"];\n    var safeMethods = [\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"];\n    var requestMode = [\"navigate\", \"same-origin\", \"no-cors\", \"cors\"];\n    var requestCredentials = [\"omit\", \"same-origin\", \"include\"];\n    var requestCache = [\n      \"default\",\n      \"no-store\",\n      \"reload\",\n      \"no-cache\",\n      \"force-cache\",\n      \"only-if-cached\"\n    ];\n    var requestBodyHeader = [\n      \"content-encoding\",\n      \"content-language\",\n      \"content-location\",\n      \"content-type\"\n    ];\n    var forbiddenMethods = [\"CONNECT\", \"TRACE\", \"TRACK\"];\n    var subresource = [\n      \"audio\",\n      \"audioworklet\",\n      \"font\",\n      \"image\",\n      \"manifest\",\n      \"paintworklet\",\n      \"script\",\n      \"style\",\n      \"track\",\n      \"video\",\n      \"xslt\",\n      \"\"\n    ];\n    var _a3;\n    var DOMException = (_a3 = globalThis.DOMException) != null ? _a3 : (() => {\n      try {\n        atob(\"~\");\n      } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n      }\n    })();\n    module2.exports = {\n      DOMException,\n      subresource,\n      forbiddenMethods,\n      requestBodyHeader,\n      referrerPolicy,\n      requestRedirect,\n      requestMode,\n      requestCredentials,\n      requestCache,\n      redirectStatus,\n      corsSafeListedMethods,\n      nullBodyStatus,\n      safeMethods\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/symbols.js\nvar require_symbols2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/symbols.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      kUrl: Symbol(\"url\"),\n      kHeaders: Symbol(\"headers\"),\n      kSignal: Symbol(\"signal\"),\n      kState: Symbol(\"state\"),\n      kGuard: Symbol(\"guard\"),\n      kRealm: Symbol(\"realm\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/webidl.js\nvar require_webidl = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/webidl.js\"(exports, module2) {\n    \"use strict\";\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var { hasOwn, toUSVString } = require_util3();\n    var webidl = {};\n    webidl.converters = {};\n    webidl.util = {};\n    webidl.errors = {};\n    webidl.errors.exception = function(message) {\n      throw new TypeError(`${message.header}: ${message.message}`);\n    };\n    webidl.errors.conversionFailed = function(context3) {\n      const plural = context3.types.length === 1 ? \"\" : \" one of\";\n      const message = `${context3.argument} could not be converted to${plural}: ${context3.types.join(\", \")}.`;\n      return webidl.errors.exception({\n        header: context3.prefix,\n        message\n      });\n    };\n    webidl.errors.invalidArgument = function(context3) {\n      return webidl.errors.exception({\n        header: context3.prefix,\n        message: `\"${context3.value}\" is an invalid ${context3.type}.`\n      });\n    };\n    webidl.util.Type = function(V) {\n      switch (typeof V) {\n        case \"undefined\":\n          return \"Undefined\";\n        case \"boolean\":\n          return \"Boolean\";\n        case \"string\":\n          return \"String\";\n        case \"symbol\":\n          return \"Symbol\";\n        case \"number\":\n          return \"Number\";\n        case \"bigint\":\n          return \"BigInt\";\n        case \"function\":\n        case \"object\": {\n          if (V === null) {\n            return \"Null\";\n          }\n          return \"Object\";\n        }\n      }\n    };\n    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n      let upperBound;\n      let lowerBound;\n      if (bitLength === 64) {\n        upperBound = Math.pow(2, 53) - 1;\n        if (signedness === \"unsigned\") {\n          lowerBound = 0;\n        } else {\n          lowerBound = Math.pow(-2, 53) + 1;\n        }\n      } else if (signedness === \"unsigned\") {\n        lowerBound = 0;\n        upperBound = Math.pow(2, bitLength) - 1;\n      } else {\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n      }\n      let x = Number(V);\n      if (Object.is(-0, x)) {\n        x = 0;\n      }\n      if (opts.enforceRange === true) {\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n          webidl.errors.exception({\n            header: \"Integer conversion\",\n            message: `Could not convert ${V} to an integer.`\n          });\n        }\n        x = webidl.util.IntegerPart(x);\n        if (x < lowerBound || x > upperBound) {\n          webidl.errors.exception({\n            header: \"Integer conversion\",\n            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n          });\n        }\n        return x;\n      }\n      if (!Number.isNaN(x) && opts.clamp === true) {\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        if (Math.floor(x) % 2 === 0) {\n          x = Math.floor(x);\n        } else {\n          x = Math.ceil(x);\n        }\n        return x;\n      }\n      if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n      }\n      x = webidl.util.IntegerPart(x);\n      x = x % Math.pow(2, bitLength);\n      if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n      }\n      return x;\n    };\n    webidl.util.IntegerPart = function(n) {\n      const r = Math.floor(Math.abs(n));\n      if (n < 0) {\n        return -1 * r;\n      }\n      return r;\n    };\n    webidl.sequenceConverter = function(converter) {\n      return (V) => {\n        var _a3;\n        if (webidl.util.Type(V) !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Sequence\",\n            message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n          });\n        }\n        const method = (_a3 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a3.call(V);\n        const seq = [];\n        if (method === void 0 || typeof method.next !== \"function\") {\n          webidl.errors.exception({\n            header: \"Sequence\",\n            message: \"Object is not an iterator.\"\n          });\n        }\n        while (true) {\n          const { done, value } = method.next();\n          if (done) {\n            break;\n          }\n          seq.push(converter(value));\n        }\n        return seq;\n      };\n    };\n    webidl.recordConverter = function(keyConverter, valueConverter) {\n      return (V) => {\n        const record = {};\n        const type = webidl.util.Type(V);\n        if (type === \"Undefined\" || type === \"Null\") {\n          return record;\n        }\n        if (type !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Record\",\n            message: `Expected ${V} to be an Object type.`\n          });\n        }\n        for (let [key, value] of Object.entries(V)) {\n          key = keyConverter(key);\n          value = valueConverter(value);\n          record[key] = value;\n        }\n        return record;\n      };\n    };\n    webidl.interfaceConverter = function(i) {\n      return (V, opts = {}) => {\n        if (opts.strict !== false && !(V instanceof i)) {\n          webidl.errors.exception({\n            header: i.name,\n            message: `Expected ${V} to be an instance of ${i.name}.`\n          });\n        }\n        return V;\n      };\n    };\n    webidl.dictionaryConverter = function(converters) {\n      return (dictionary) => {\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type !== \"Null\" && type !== \"Undefined\" && type !== \"Object\") {\n          webidl.errors.exception({\n            header: \"Dictionary\",\n            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n          });\n        }\n        for (const options of converters) {\n          const { key, defaultValue, required, converter } = options;\n          if (required === true) {\n            if (!hasOwn(dictionary, key)) {\n              webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `Missing required key \"${key}\".`\n              });\n            }\n          }\n          let value = dictionary[key];\n          const hasDefault = hasOwn(options, \"defaultValue\");\n          if (hasDefault && value !== null) {\n            value = value != null ? value : defaultValue;\n          }\n          if (required || hasDefault || value !== void 0) {\n            value = converter(value);\n            if (options.allowedValues && !options.allowedValues.includes(value)) {\n              webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n              });\n            }\n            dict[key] = value;\n          }\n        }\n        return dict;\n      };\n    };\n    webidl.nullableConverter = function(converter) {\n      return (V) => {\n        if (V === null) {\n          return V;\n        }\n        return converter(V);\n      };\n    };\n    webidl.converters.DOMString = function(V, opts = {}) {\n      if (V === null && opts.legacyNullToEmptyString) {\n        return \"\";\n      }\n      if (typeof V === \"symbol\") {\n        throw new TypeError(\"Could not convert argument of type symbol to string.\");\n      }\n      return String(V);\n    };\n    webidl.converters.ByteString = function(V) {\n      const x = webidl.converters.DOMString(V);\n      for (let index = 0; index < x.length; index++) {\n        const charCode = x.charCodeAt(index);\n        if (charCode > 255) {\n          throw new TypeError(\n            `Cannot convert argument to a ByteString because the character atindex ${index} has a value of ${charCode} which is greater than 255.`\n          );\n        }\n      }\n      return x;\n    };\n    webidl.converters.USVString = toUSVString;\n    webidl.converters.boolean = function(V) {\n      const x = Boolean(V);\n      return x;\n    };\n    webidl.converters.any = function(V) {\n      return V;\n    };\n    webidl.converters[\"long long\"] = function(V, opts) {\n      const x = webidl.util.ConvertToInt(V, 64, \"signed\", opts);\n      return x;\n    };\n    webidl.converters[\"unsigned short\"] = function(V) {\n      const x = webidl.util.ConvertToInt(V, 16, \"unsigned\");\n      return x;\n    };\n    webidl.converters.ArrayBuffer = function(V, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        webidl.errors.conversionFailed({\n          prefix: `${V}`,\n          argument: `${V}`,\n          types: [\"ArrayBuffer\"]\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.TypedArray = function(V, T, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        webidl.errors.conversionFailed({\n          prefix: `${T.name}`,\n          argument: `${V}`,\n          types: [T.name]\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.DataView = function(V, opts = {}) {\n      if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        webidl.errors.exception({\n          header: \"DataView\",\n          message: \"Object is not a DataView.\"\n        });\n      }\n      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        webidl.errors.exception({\n          header: \"ArrayBuffer\",\n          message: \"SharedArrayBuffer is not allowed.\"\n        });\n      }\n      return V;\n    };\n    webidl.converters.BufferSource = function(V, opts = {}) {\n      if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, opts);\n      }\n      if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor);\n      }\n      if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, opts);\n      }\n      throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n    };\n    webidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(\n      webidl.converters.ByteString\n    );\n    webidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(\n      webidl.converters[\"sequence<ByteString>\"]\n    );\n    webidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(\n      webidl.converters.ByteString,\n      webidl.converters.ByteString\n    );\n    module2.exports = {\n      webidl\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/file.js\nvar require_file = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/file.js\"(exports, module2) {\n    \"use strict\";\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var { kState } = require_symbols2();\n    var { isBlobLike } = require_util3();\n    var { webidl } = require_webidl();\n    var File = class extends Blob {\n      constructor(fileBits, fileName, options = {}) {\n        if (arguments.length < 2) {\n          throw new TypeError(\"2 arguments required\");\n        }\n        fileBits = webidl.converters[\"sequence<BlobPart>\"](fileBits);\n        fileName = webidl.converters.USVString(fileName);\n        options = webidl.converters.FilePropertyBag(options);\n        const n = fileName;\n        const d = options.lastModified;\n        super(processBlobParts(fileBits, options), { type: options.type });\n        this[kState] = {\n          name: n,\n          lastModified: d\n        };\n      }\n      get name() {\n        if (!(this instanceof File)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].name;\n      }\n      get lastModified() {\n        if (!(this instanceof File)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].lastModified;\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n    };\n    __name(File, \"File\");\n    var FileLike = class {\n      constructor(blobLike, fileName, options = {}) {\n        var _a3;\n        const n = fileName;\n        const t = options.type;\n        const d = (_a3 = options.lastModified) != null ? _a3 : Date.now();\n        this[kState] = {\n          blobLike,\n          name: n,\n          type: t,\n          lastModified: d\n        };\n      }\n      stream(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.stream(...args);\n      }\n      arrayBuffer(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.arrayBuffer(...args);\n      }\n      slice(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.slice(...args);\n      }\n      text(...args) {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.text(...args);\n      }\n      get size() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.size;\n      }\n      get type() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].blobLike.type;\n      }\n      get name() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].name;\n      }\n      get lastModified() {\n        if (!(this instanceof FileLike)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].lastModified;\n      }\n      get [Symbol.toStringTag]() {\n        return \"File\";\n      }\n    };\n    __name(FileLike, \"FileLike\");\n    webidl.converters.Blob = webidl.interfaceConverter(Blob);\n    webidl.converters.BlobPart = function(V, opts) {\n      if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n          return webidl.converters.Blob(V, { strict: false });\n        }\n        return webidl.converters.BufferSource(V, opts);\n      } else {\n        return webidl.converters.USVString(V, opts);\n      }\n    };\n    webidl.converters[\"sequence<BlobPart>\"] = webidl.sequenceConverter(\n      webidl.converters.BlobPart\n    );\n    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n      {\n        key: \"lastModified\",\n        converter: webidl.converters[\"long long\"],\n        get defaultValue() {\n          return Date.now();\n        }\n      },\n      {\n        key: \"type\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n      },\n      {\n        key: \"endings\",\n        converter: (value) => {\n          value = webidl.converters.DOMString(value);\n          value = value.toLowerCase();\n          if (value !== \"native\") {\n            value = \"transparent\";\n          }\n          return value;\n        },\n        defaultValue: \"transparent\"\n      }\n    ]);\n    function processBlobParts(parts, options) {\n      const bytes = [];\n      for (const element of parts) {\n        if (typeof element === \"string\") {\n          let s = element;\n          if (options.endings === \"native\") {\n            s = convertLineEndingsNative(s);\n          }\n          bytes.push(new TextEncoder().encode(s));\n        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {\n          if (!element.buffer) {\n            bytes.push(new Uint8Array(element));\n          } else {\n            bytes.push(\n              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)\n            );\n          }\n        } else if (isBlobLike(element)) {\n          bytes.push(element);\n        }\n      }\n      return bytes;\n    }\n    __name(processBlobParts, \"processBlobParts\");\n    function convertLineEndingsNative(s) {\n      let nativeLineEnding = \"\\n\";\n      if (process.platform === \"win32\") {\n        nativeLineEnding = \"\\r\\n\";\n      }\n      return s.replace(/\\r?\\n/g, nativeLineEnding);\n    }\n    __name(convertLineEndingsNative, \"convertLineEndingsNative\");\n    module2.exports = { File, FileLike };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/util.js\nvar require_util3 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/util.js\"(exports, module2) {\n    \"use strict\";\n    var { redirectStatus } = require_constants();\n    var { performance: performance3 } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\");\n    var File;\n    var crypto2;\n    try {\n      crypto2 = __webpack_require__(/*! crypto */ \"crypto\");\n    } catch (e) {\n    }\n    var badPorts = [\n      \"1\",\n      \"7\",\n      \"9\",\n      \"11\",\n      \"13\",\n      \"15\",\n      \"17\",\n      \"19\",\n      \"20\",\n      \"21\",\n      \"22\",\n      \"23\",\n      \"25\",\n      \"37\",\n      \"42\",\n      \"43\",\n      \"53\",\n      \"69\",\n      \"77\",\n      \"79\",\n      \"87\",\n      \"95\",\n      \"101\",\n      \"102\",\n      \"103\",\n      \"104\",\n      \"109\",\n      \"110\",\n      \"111\",\n      \"113\",\n      \"115\",\n      \"117\",\n      \"119\",\n      \"123\",\n      \"135\",\n      \"137\",\n      \"139\",\n      \"143\",\n      \"161\",\n      \"179\",\n      \"389\",\n      \"427\",\n      \"465\",\n      \"512\",\n      \"513\",\n      \"514\",\n      \"515\",\n      \"526\",\n      \"530\",\n      \"531\",\n      \"532\",\n      \"540\",\n      \"548\",\n      \"554\",\n      \"556\",\n      \"563\",\n      \"587\",\n      \"601\",\n      \"636\",\n      \"989\",\n      \"990\",\n      \"993\",\n      \"995\",\n      \"1719\",\n      \"1720\",\n      \"1723\",\n      \"2049\",\n      \"3659\",\n      \"4045\",\n      \"5060\",\n      \"5061\",\n      \"6000\",\n      \"6566\",\n      \"6665\",\n      \"6666\",\n      \"6667\",\n      \"6668\",\n      \"6669\",\n      \"6697\",\n      \"10080\"\n    ];\n    function responseURL(response) {\n      const urlList = response.urlList;\n      const length = urlList.length;\n      return length === 0 ? null : urlList[length - 1].toString();\n    }\n    __name(responseURL, \"responseURL\");\n    function responseLocationURL(response, requestFragment) {\n      if (!redirectStatus.includes(response.status)) {\n        return null;\n      }\n      let location = response.headersList.get(\"location\");\n      location = location ? new URL(location, responseURL(response)) : null;\n      if (location && !location.hash) {\n        location.hash = requestFragment;\n      }\n      return location;\n    }\n    __name(responseLocationURL, \"responseLocationURL\");\n    function requestCurrentURL(request2) {\n      return request2.urlList[request2.urlList.length - 1];\n    }\n    __name(requestCurrentURL, \"requestCurrentURL\");\n    function requestBadPort(request2) {\n      const url = requestCurrentURL(request2);\n      if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n        return \"blocked\";\n      }\n      return \"allowed\";\n    }\n    __name(requestBadPort, \"requestBadPort\");\n    function isFileLike(object) {\n      if (!File) {\n        File = require_file().File;\n      }\n      return object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n    __name(isFileLike, \"isFileLike\");\n    function isErrorLike(object) {\n      var _a3, _b2;\n      return object instanceof Error || (((_a3 = object == null ? void 0 : object.constructor) == null ? void 0 : _a3.name) === \"Error\" || ((_b2 = object == null ? void 0 : object.constructor) == null ? void 0 : _b2.name) === \"DOMException\");\n    }\n    __name(isErrorLike, \"isErrorLike\");\n    function isValidReasonPhrase(statusText) {\n      for (let i = 0; i < statusText.length; ++i) {\n        const c = statusText.charCodeAt(i);\n        if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidReasonPhrase, \"isValidReasonPhrase\");\n    function isTokenChar(c) {\n      return !(c >= 127 || c <= 32 || c === \"(\" || c === \")\" || c === \"<\" || c === \">\" || c === \"@\" || c === \",\" || c === \";\" || c === \":\" || c === \"\\\\\" || c === '\"' || c === \"/\" || c === \"[\" || c === \"]\" || c === \"?\" || c === \"=\" || c === \"{\" || c === \"}\");\n    }\n    __name(isTokenChar, \"isTokenChar\");\n    function isValidHTTPToken(characters) {\n      if (!characters || typeof characters !== \"string\") {\n        return false;\n      }\n      for (let i = 0; i < characters.length; ++i) {\n        const c = characters.charCodeAt(i);\n        if (c > 127 || !isTokenChar(c)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidHTTPToken, \"isValidHTTPToken\");\n    function isValidHeaderName(potentialValue) {\n      if (potentialValue.length === 0) {\n        return false;\n      }\n      for (const char of potentialValue) {\n        if (!isValidHTTPToken(char)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidHeaderName, \"isValidHeaderName\");\n    function isValidHeaderValue(potentialValue) {\n      if (potentialValue.startsWith(\"\t\") || potentialValue.startsWith(\" \") || potentialValue.endsWith(\"\t\") || potentialValue.endsWith(\" \")) {\n        return false;\n      }\n      if (potentialValue.includes(\"\\0\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\n\")) {\n        return false;\n      }\n      return true;\n    }\n    __name(isValidHeaderValue, \"isValidHeaderValue\");\n    function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {\n      const policy = \"\";\n      if (policy !== \"\") {\n        request2.referrerPolicy = policy;\n      }\n    }\n    __name(setRequestReferrerPolicyOnRedirect, \"setRequestReferrerPolicyOnRedirect\");\n    function crossOriginResourcePolicyCheck() {\n      return \"allowed\";\n    }\n    __name(crossOriginResourcePolicyCheck, \"crossOriginResourcePolicyCheck\");\n    function corsCheck() {\n      return \"success\";\n    }\n    __name(corsCheck, \"corsCheck\");\n    function TAOCheck() {\n      return \"success\";\n    }\n    __name(TAOCheck, \"TAOCheck\");\n    function appendFetchMetadata(httpRequest) {\n      let header = null;\n      header = httpRequest.mode;\n      httpRequest.headersList.set(\"sec-fetch-mode\", header);\n    }\n    __name(appendFetchMetadata, \"appendFetchMetadata\");\n    function appendRequestOriginHeader(request2) {\n      let serializedOrigin = request2.origin;\n      if (request2.responseTainting === \"cors\" || request2.mode === \"websocket\") {\n        if (serializedOrigin) {\n          request2.headersList.append(\"Origin\", serializedOrigin);\n        }\n      } else if (request2.method !== \"GET\" && request2.method !== \"HEAD\") {\n        switch (request2.referrerPolicy) {\n          case \"no-referrer\":\n            serializedOrigin = null;\n            break;\n          case \"no-referrer-when-downgrade\":\n          case \"strict-origin\":\n          case \"strict-origin-when-cross-origin\":\n            if (/^https:/.test(request2.origin) && !/^https:/.test(requestCurrentURL(request2))) {\n              serializedOrigin = null;\n            }\n            break;\n          case \"same-origin\":\n            if (!sameOrigin(request2, requestCurrentURL(request2))) {\n              serializedOrigin = null;\n            }\n            break;\n          default:\n        }\n        if (serializedOrigin) {\n          request2.headersList.append(\"Origin\", serializedOrigin);\n        }\n      }\n    }\n    __name(appendRequestOriginHeader, \"appendRequestOriginHeader\");\n    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n      return performance3.now();\n    }\n    __name(coarsenedSharedCurrentTime, \"coarsenedSharedCurrentTime\");\n    function createOpaqueTimingInfo(timingInfo) {\n      var _a3, _b2;\n      return {\n        startTime: (_a3 = timingInfo.startTime) != null ? _a3 : 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: (_b2 = timingInfo.startTime) != null ? _b2 : 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n      };\n    }\n    __name(createOpaqueTimingInfo, \"createOpaqueTimingInfo\");\n    function makePolicyContainer() {\n      return {};\n    }\n    __name(makePolicyContainer, \"makePolicyContainer\");\n    function clonePolicyContainer() {\n      return {};\n    }\n    __name(clonePolicyContainer, \"clonePolicyContainer\");\n    function determineRequestsReferrer(request2) {\n      return \"no-referrer\";\n    }\n    __name(determineRequestsReferrer, \"determineRequestsReferrer\");\n    function bytesMatch(bytes, metadataList) {\n      if (crypto2 === void 0) {\n        return true;\n      }\n      const parsedMetadata = parseMetadata(metadataList);\n      if (parsedMetadata === \"no metadata\") {\n        return true;\n      }\n      if (parsedMetadata.length === 0) {\n        return true;\n      }\n      const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n      for (const item of metadata) {\n        const algorithm = item.algo;\n        const expectedValue = item.hash;\n        const actualValue = crypto2.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue === expectedValue) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(bytesMatch, \"bytesMatch\");\n    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i;\n    function parseMetadata(metadata) {\n      const result = [];\n      let empty2 = true;\n      const supportedHashes = crypto2.getHashes();\n      for (const token of metadata.split(\" \")) {\n        empty2 = false;\n        const parsedToken = parseHashWithOptions.exec(token);\n        if (parsedToken === null || parsedToken.groups === void 0) {\n          continue;\n        }\n        const algorithm = parsedToken.groups.algo;\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n          result.push(parsedToken.groups);\n        }\n      }\n      if (empty2 === true) {\n        return \"no metadata\";\n      }\n      return result;\n    }\n    __name(parseMetadata, \"parseMetadata\");\n    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {\n    }\n    __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, \"tryUpgradeRequestToAPotentiallyTrustworthyURL\");\n    function sameOrigin(A, B) {\n      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n      }\n      return false;\n    }\n    __name(sameOrigin, \"sameOrigin\");\n    function createDeferredPromise() {\n      let res;\n      let rej;\n      const promise = new Promise((resolve, reject) => {\n        res = resolve;\n        rej = reject;\n      });\n      return { promise, resolve: res, reject: rej };\n    }\n    __name(createDeferredPromise, \"createDeferredPromise\");\n    function isAborted(fetchParams) {\n      return fetchParams.controller.state === \"aborted\";\n    }\n    __name(isAborted, \"isAborted\");\n    function isCancelled(fetchParams) {\n      return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n    }\n    __name(isCancelled, \"isCancelled\");\n    function normalizeMethod(method) {\n      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n    }\n    __name(normalizeMethod, \"normalizeMethod\");\n    function serializeJavascriptValueToJSONString(value) {\n      const result = JSON.stringify(value);\n      if (result === void 0) {\n        throw new TypeError(\"Value is not JSON serializable\");\n      }\n      assert(typeof result === \"string\");\n      return result;\n    }\n    __name(serializeJavascriptValueToJSONString, \"serializeJavascriptValueToJSONString\");\n    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n    function makeIterator(iterator, name) {\n      const i = {\n        next() {\n          if (Object.getPrototypeOf(this) !== i) {\n            throw new TypeError(\n              `'next' called on an object that does not implement interface ${name} Iterator.`\n            );\n          }\n          return iterator.next();\n        },\n        [Symbol.toStringTag]: `${name} Iterator`\n      };\n      Object.setPrototypeOf(i, esIteratorPrototype);\n      return Object.setPrototypeOf({}, i);\n    }\n    __name(makeIterator, \"makeIterator\");\n    async function fullyReadBody(body, processBody, processBodyError) {\n      try {\n        const chunks = [];\n        let length = 0;\n        const reader = body.stream.getReader();\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done === true) {\n            break;\n          }\n          assert(isUint8Array(value));\n          chunks.push(value);\n          length += value.byteLength;\n        }\n        const fulfilledSteps = /* @__PURE__ */ __name((bytes) => queueMicrotask(() => {\n          processBody(bytes);\n        }), \"fulfilledSteps\");\n        fulfilledSteps(Buffer.concat(chunks, length));\n      } catch (err) {\n        queueMicrotask(() => processBodyError(err));\n      }\n    }\n    __name(fullyReadBody, \"fullyReadBody\");\n    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\n    module2.exports = {\n      isAborted,\n      isCancelled,\n      createDeferredPromise,\n      ReadableStreamFrom,\n      toUSVString,\n      tryUpgradeRequestToAPotentiallyTrustworthyURL,\n      coarsenedSharedCurrentTime,\n      determineRequestsReferrer,\n      makePolicyContainer,\n      clonePolicyContainer,\n      appendFetchMetadata,\n      appendRequestOriginHeader,\n      TAOCheck,\n      corsCheck,\n      crossOriginResourcePolicyCheck,\n      createOpaqueTimingInfo,\n      setRequestReferrerPolicyOnRedirect,\n      isValidHTTPToken,\n      requestBadPort,\n      requestCurrentURL,\n      responseURL,\n      responseLocationURL,\n      isBlobLike,\n      isFileLike,\n      isValidReasonPhrase,\n      sameOrigin,\n      normalizeMethod,\n      serializeJavascriptValueToJSONString,\n      makeIterator,\n      isValidHeaderName,\n      isValidHeaderValue,\n      hasOwn,\n      isErrorLike,\n      fullyReadBody,\n      bytesMatch\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/formdata.js\nvar require_formdata = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/formdata.js\"(exports, module2) {\n    \"use strict\";\n    var { isBlobLike, isFileLike, toUSVString, makeIterator } = require_util3();\n    var { kState } = require_symbols2();\n    var { File, FileLike } = require_file();\n    var { webidl } = require_webidl();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var _FormData = class {\n      constructor(form) {\n        if (arguments.length > 0 && form != null) {\n          webidl.errors.conversionFailed({\n            prefix: \"FormData constructor\",\n            argument: \"Argument 1\",\n            types: [\"null\"]\n          });\n        }\n        this[kState] = [];\n      }\n      append(name, value, filename = void 0) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        if (arguments.length === 3 && !isBlobLike(value)) {\n          throw new TypeError(\n            \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n          );\n        }\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;\n        const entry = makeEntry(name, value, filename);\n        this[kState].push(entry);\n      }\n      delete(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        const next = [];\n        for (const entry of this[kState]) {\n          if (entry.name !== name) {\n            next.push(entry);\n          }\n        }\n        this[kState] = next;\n      }\n      get(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        const idx = this[kState].findIndex((entry) => entry.name === name);\n        if (idx === -1) {\n          return null;\n        }\n        return this[kState][idx].value;\n      }\n      getAll(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);\n      }\n      has(name) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.USVString(name);\n        return this[kState].findIndex((entry) => entry.name === name) !== -1;\n      }\n      set(name, value, filename = void 0) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        if (arguments.length === 3 && !isBlobLike(value)) {\n          throw new TypeError(\n            \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n          );\n        }\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? toUSVString(filename) : void 0;\n        const entry = makeEntry(name, value, filename);\n        const idx = this[kState].findIndex((entry2) => entry2.name === name);\n        if (idx !== -1) {\n          this[kState] = [\n            ...this[kState].slice(0, idx),\n            entry,\n            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)\n          ];\n        } else {\n          this[kState].push(entry);\n        }\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      entries() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"entries\"),\n          \"FormData\"\n        );\n      }\n      keys() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"keys\"),\n          \"FormData\"\n        );\n      }\n      values() {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(\n          makeIterable(this[kState], \"values\"),\n          \"FormData\"\n        );\n      }\n      forEach(callbackFn, thisArg = globalThis) {\n        if (!(this instanceof _FormData)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        if (typeof callbackFn !== \"function\") {\n          throw new TypeError(\n            \"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\"\n          );\n        }\n        for (const [key, value] of this) {\n          callbackFn.apply(thisArg, [value, key, this]);\n        }\n      }\n    };\n    var FormData = _FormData;\n    __name(FormData, \"FormData\");\n    __publicField(FormData, \"name\", \"FormData\");\n    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;\n    function makeEntry(name, value, filename) {\n      name = Buffer.from(name).toString(\"utf8\");\n      if (typeof value === \"string\") {\n        value = Buffer.from(value).toString(\"utf8\");\n      } else {\n        if (!isFileLike(value)) {\n          value = value instanceof Blob ? new File([value], \"blob\", { type: value.type }) : new FileLike(value, \"blob\", { type: value.type });\n        }\n        if (filename !== void 0) {\n          value = value instanceof File ? new File([value], filename, { type: value.type }) : new FileLike(value, filename, { type: value.type });\n        }\n      }\n      return { name, value };\n    }\n    __name(makeEntry, \"makeEntry\");\n    function* makeIterable(entries, type) {\n      for (const { name, value } of entries) {\n        if (type === \"entries\") {\n          yield [name, value];\n        } else if (type === \"values\") {\n          yield value;\n        } else {\n          yield name;\n        }\n      }\n    }\n    __name(makeIterable, \"makeIterable\");\n    module2.exports = { FormData };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/body.js\nvar require_body = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/body.js\"(exports, module2) {\n    \"use strict\";\n    var util2 = require_util2();\n    var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util3();\n    var { FormData } = require_formdata();\n    var { kState } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    var { kBodyUsed } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { NotSupportedError } = require_errors();\n    var { isErrored } = require_util2();\n    var { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\");\n    var ReadableStream;\n    async function* blobGen(blob) {\n      yield* blob.stream();\n    }\n    __name(blobGen, \"blobGen\");\n    function extractBody(object, keepalive = false) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      let stream2 = null;\n      let action = null;\n      let source = null;\n      let length = null;\n      let contentType = null;\n      if (object == null) {\n      } else if (object instanceof URLSearchParams) {\n        source = object.toString();\n        contentType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      } else if (isArrayBuffer(object)) {\n        source = new Uint8Array(object.slice());\n      } else if (ArrayBuffer.isView(object)) {\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n      } else if (util2.isFormDataLike(object)) {\n        const boundary = \"----formdata-undici-\" + Math.random();\n        const prefix = `--${boundary}\\r\nContent-Disposition: form-data`;\n        const escape = /* @__PURE__ */ __name((str) => str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), \"escape\");\n        const normalizeLinefeeds = /* @__PURE__ */ __name((value) => value.replace(/\\r?\\n|\\r/g, \"\\r\\n\"), \"normalizeLinefeeds\");\n        action = /* @__PURE__ */ __name(async function* (object2) {\n          const enc = new TextEncoder();\n          for (const [name, value] of object2) {\n            if (typeof value === \"string\") {\n              yield enc.encode(\n                prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"\\r\n\\r\n${normalizeLinefeeds(value)}\\r\n`\n              );\n            } else {\n              yield enc.encode(\n                prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + `\\r\nContent-Type: ${value.type || \"application/octet-stream\"}\\r\n\\r\n`\n              );\n              yield* blobGen(value);\n              yield enc.encode(\"\\r\\n\");\n            }\n          }\n          yield enc.encode(`--${boundary}--`);\n        }, \"action\");\n        source = object;\n        contentType = \"multipart/form-data; boundary=\" + boundary;\n      } else if (isBlobLike(object)) {\n        action = blobGen;\n        source = object;\n        length = object.size;\n        if (object.type) {\n          contentType = object.type;\n        }\n      } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        if (keepalive) {\n          throw new TypeError(\"keepalive\");\n        }\n        if (util2.isDisturbed(object) || object.locked) {\n          throw new TypeError(\n            \"Response body object should not be disturbed or locked\"\n          );\n        }\n        stream2 = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n      } else {\n        source = toUSVString(object);\n        contentType = \"text/plain;charset=UTF-8\";\n      }\n      if (typeof source === \"string\" || util2.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n      }\n      if (action != null) {\n        let iterator;\n        stream2 = new ReadableStream({\n          async start() {\n            iterator = action(object)[Symbol.asyncIterator]();\n          },\n          async pull(controller) {\n            const { value, done } = await iterator.next();\n            if (done) {\n              queueMicrotask(() => {\n                controller.close();\n              });\n            } else {\n              if (!isErrored(stream2)) {\n                controller.enqueue(new Uint8Array(value));\n              }\n            }\n            return controller.desiredSize > 0;\n          },\n          async cancel(reason) {\n            await iterator.return();\n          }\n        });\n      } else if (!stream2) {\n        stream2 = new ReadableStream({\n          async pull(controller) {\n            controller.enqueue(\n              typeof source === \"string\" ? new TextEncoder().encode(source) : source\n            );\n            queueMicrotask(() => {\n              controller.close();\n            });\n          }\n        });\n      }\n      const body = { stream: stream2, source, length };\n      return [body, contentType];\n    }\n    __name(extractBody, \"extractBody\");\n    function safelyExtractBody(object, keepalive = false) {\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      if (object instanceof ReadableStream) {\n        assert(!util2.isDisturbed(object), \"disturbed\");\n        assert(!object.locked, \"locked\");\n      }\n      return extractBody(object, keepalive);\n    }\n    __name(safelyExtractBody, \"safelyExtractBody\");\n    function cloneBody(body) {\n      const [out1, out2] = body.stream.tee();\n      body.stream = out1;\n      return {\n        stream: out2,\n        length: body.length,\n        source: body.source\n      };\n    }\n    __name(cloneBody, \"cloneBody\");\n    async function* consumeBody(body) {\n      if (body) {\n        if (isUint8Array(body)) {\n          yield body;\n        } else {\n          const stream2 = body.stream;\n          if (util2.isDisturbed(stream2)) {\n            throw new TypeError(\"disturbed\");\n          }\n          if (stream2.locked) {\n            throw new TypeError(\"locked\");\n          }\n          stream2[kBodyUsed] = true;\n          yield* stream2;\n        }\n      }\n    }\n    __name(consumeBody, \"consumeBody\");\n    function bodyMixinMethods(instance) {\n      const methods = {\n        async blob() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const chunks = [];\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            chunks.push(new Blob([chunk]));\n          }\n          return new Blob(chunks, { type: this.headers.get(\"Content-Type\") || \"\" });\n        },\n        async arrayBuffer() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const contentLength = this.headers.get(\"content-length\");\n          const encoded = this.headers.has(\"content-encoding\");\n          if (!encoded && contentLength) {\n            const buffer2 = new Uint8Array(contentLength);\n            let offset2 = 0;\n            for await (const chunk of consumeBody(this[kState].body)) {\n              if (!isUint8Array(chunk)) {\n                throw new TypeError(\"Expected Uint8Array chunk\");\n              }\n              buffer2.set(chunk, offset2);\n              offset2 += chunk.length;\n            }\n            return buffer2.buffer;\n          }\n          const chunks = [];\n          let size = 0;\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            chunks.push(chunk);\n            size += chunk.byteLength;\n          }\n          const buffer = new Uint8Array(size);\n          let offset = 0;\n          for (const chunk of chunks) {\n            buffer.set(chunk, offset);\n            offset += chunk.byteLength;\n          }\n          return buffer.buffer;\n        },\n        async text() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          let result = \"\";\n          const textDecoder = new TextDecoder();\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError(\"Expected Uint8Array chunk\");\n            }\n            result += textDecoder.decode(chunk, { stream: true });\n          }\n          result += textDecoder.decode();\n          return result;\n        },\n        async json() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return JSON.parse(await this.text());\n        },\n        async formData() {\n          if (!(this instanceof instance)) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          const contentType = this.headers.get(\"Content-Type\");\n          if (/multipart\\/form-data/.test(contentType)) {\n            throw new NotSupportedError(\"multipart/form-data not supported\");\n          } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n            let entries;\n            try {\n              let text = \"\";\n              const textDecoder = new TextDecoder(\"utf-8\", { ignoreBOM: true });\n              for await (const chunk of consumeBody(this[kState].body)) {\n                if (!isUint8Array(chunk)) {\n                  throw new TypeError(\"Expected Uint8Array chunk\");\n                }\n                text += textDecoder.decode(chunk, { stream: true });\n              }\n              text += textDecoder.decode();\n              entries = new URLSearchParams(text);\n            } catch (err) {\n              throw Object.assign(new TypeError(), { cause: err });\n            }\n            const formData = new FormData();\n            for (const [name, value] of entries) {\n              formData.append(name, value);\n            }\n            return formData;\n          } else {\n            webidl.errors.exception({\n              header: `${instance.name}.formData`,\n              value: \"Could not parse content as FormData.\"\n            });\n          }\n        }\n      };\n      return methods;\n    }\n    __name(bodyMixinMethods, \"bodyMixinMethods\");\n    var properties = {\n      body: {\n        enumerable: true,\n        get() {\n          if (!this || !this[kState]) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return this[kState].body ? this[kState].body.stream : null;\n        }\n      },\n      bodyUsed: {\n        enumerable: true,\n        get() {\n          if (!this || !this[kState]) {\n            throw new TypeError(\"Illegal invocation\");\n          }\n          return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);\n        }\n      }\n    };\n    function mixinBody(prototype) {\n      Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n      Object.defineProperties(prototype.prototype, properties);\n    }\n    __name(mixinBody, \"mixinBody\");\n    module2.exports = {\n      extractBody,\n      safelyExtractBody,\n      cloneBody,\n      mixinBody\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/request.js\nvar require_request = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/request.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      InvalidArgumentError,\n      NotSupportedError\n    } = require_errors();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var util2 = require_util2();\n    var tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n    var headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n    var invalidPathRegex = /[^\\u0021-\\u00ff]/;\n    var kHandler = Symbol(\"handler\");\n    var channels = {};\n    var extractBody;\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    try {\n      const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n      channels.create = diagnosticsChannel.channel(\"undici:request:create\");\n      channels.bodySent = diagnosticsChannel.channel(\"undici:request:bodySent\");\n      channels.headers = diagnosticsChannel.channel(\"undici:request:headers\");\n      channels.trailers = diagnosticsChannel.channel(\"undici:request:trailers\");\n      channels.error = diagnosticsChannel.channel(\"undici:request:error\");\n    } catch (e) {\n      channels.create = { hasSubscribers: false };\n      channels.bodySent = { hasSubscribers: false };\n      channels.headers = { hasSubscribers: false };\n      channels.trailers = { hasSubscribers: false };\n      channels.error = { hasSubscribers: false };\n    }\n    var Request = class {\n      constructor(origin, {\n        path: path7,\n        method,\n        body,\n        headers,\n        query: query2,\n        idempotent,\n        blocking,\n        upgrade,\n        headersTimeout,\n        bodyTimeout,\n        throwOnError\n      }, handler) {\n        if (typeof path7 !== \"string\") {\n          throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path7[0] !== \"/\" && !(path7.startsWith(\"http://\") || path7.startsWith(\"https://\")) && method !== \"CONNECT\") {\n          throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.exec(path7) !== null) {\n          throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n          throw new InvalidArgumentError(\"method must be a string\");\n        } else if (tokenRegExp.exec(method) === null) {\n          throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n          throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        if (body == null) {\n          this.body = null;\n        } else if (util2.isStream(body)) {\n          this.body = body;\n        } else if (util2.isBuffer(body)) {\n          this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n          this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n          this.body = body.length ? Buffer.from(body) : null;\n        } else if (util2.isFormDataLike(body) || util2.isIterable(body) || util2.isBlobLike(body)) {\n          this.body = body;\n        } else {\n          throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query2 ? util2.buildURL(path7, query2) : path7;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = \"\";\n        if (Array.isArray(headers)) {\n          if (headers.length % 2 !== 0) {\n            throw new InvalidArgumentError(\"headers array must be even\");\n          }\n          for (let i = 0; i < headers.length; i += 2) {\n            processHeader(this, headers[i], headers[i + 1]);\n          }\n        } else if (headers && typeof headers === \"object\") {\n          const keys2 = Object.keys(headers);\n          for (let i = 0; i < keys2.length; i++) {\n            const key = keys2[i];\n            processHeader(this, key, headers[key]);\n          }\n        } else if (headers != null) {\n          throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        if (util2.isFormDataLike(this.body)) {\n          if (nodeMajor < 16 || nodeMajor === 16 && nodeMinor < 8) {\n            throw new InvalidArgumentError(\"Form-Data bodies are only supported in node v16.8 and newer.\");\n          }\n          if (!extractBody) {\n            extractBody = require_body().extractBody;\n          }\n          const [bodyStream, contentType] = extractBody(body);\n          if (this.contentType == null) {\n            this.contentType = contentType;\n            this.headers += `content-type: ${contentType}\\r\n`;\n          }\n          this.body = bodyStream.stream;\n        } else if (util2.isBlobLike(body) && this.contentType == null && body.type) {\n          this.contentType = body.type;\n          this.headers += `content-type: ${body.type}\\r\n`;\n        }\n        util2.validateHandler(handler, method, upgrade);\n        this.servername = util2.getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n          channels.create.publish({ request: this });\n        }\n      }\n      onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n          try {\n            this[kHandler].onBodySent(chunk);\n          } catch (err) {\n            this.onError(err);\n          }\n        }\n      }\n      onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n          channels.bodySent.publish({ request: this });\n        }\n      }\n      onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onConnect(abort);\n      }\n      onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });\n        }\n        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n      }\n      onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onData(chunk);\n      }\n      onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n      }\n      onComplete(trailers) {\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n          channels.trailers.publish({ request: this, trailers });\n        }\n        return this[kHandler].onComplete(trailers);\n      }\n      onError(error2) {\n        if (channels.error.hasSubscribers) {\n          channels.error.publish({ request: this, error: error2 });\n        }\n        if (this.aborted) {\n          return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error2);\n      }\n      addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n      }\n    };\n    __name(Request, \"Request\");\n    function processHeader(request2, key, val) {\n      if (val && typeof val === \"object\") {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n      } else if (val === void 0) {\n        return;\n      }\n      if (request2.host === null && key.length === 4 && key.toLowerCase() === \"host\") {\n        request2.host = val;\n      } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === \"content-length\") {\n        request2.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request2.contentLength)) {\n          throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n      } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === \"content-type\" && headerCharRegex.exec(val) === null) {\n        request2.contentType = val;\n        request2.headers += `${key}: ${val}\\r\n`;\n      } else if (key.length === 17 && key.toLowerCase() === \"transfer-encoding\") {\n        throw new InvalidArgumentError(\"invalid transfer-encoding header\");\n      } else if (key.length === 10 && key.toLowerCase() === \"connection\") {\n        throw new InvalidArgumentError(\"invalid connection header\");\n      } else if (key.length === 10 && key.toLowerCase() === \"keep-alive\") {\n        throw new InvalidArgumentError(\"invalid keep-alive header\");\n      } else if (key.length === 7 && key.toLowerCase() === \"upgrade\") {\n        throw new InvalidArgumentError(\"invalid upgrade header\");\n      } else if (key.length === 6 && key.toLowerCase() === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n      } else if (tokenRegExp.exec(key) === null) {\n        throw new InvalidArgumentError(\"invalid header key\");\n      } else if (headerCharRegex.exec(val) !== null) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n      } else {\n        request2.headers += `${key}: ${val}\\r\n`;\n      }\n    }\n    __name(processHeader, \"processHeader\");\n    module2.exports = Request;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher.js\nvar require_dispatcher = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher.js\"(exports, module2) {\n    \"use strict\";\n    var EventEmitter4 = __webpack_require__(/*! events */ \"events\");\n    var Dispatcher = class extends EventEmitter4 {\n      dispatch() {\n        throw new Error(\"not implemented\");\n      }\n      close() {\n        throw new Error(\"not implemented\");\n      }\n      destroy() {\n        throw new Error(\"not implemented\");\n      }\n    };\n    __name(Dispatcher, \"Dispatcher\");\n    module2.exports = Dispatcher;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher-base.js\nvar require_dispatcher_base = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/dispatcher-base.js\"(exports, module2) {\n    \"use strict\";\n    var Dispatcher = require_dispatcher();\n    var {\n      ClientDestroyedError,\n      ClientClosedError,\n      InvalidArgumentError\n    } = require_errors();\n    var { kDestroy, kClose, kDispatch } = require_symbols();\n    var kDestroyed = Symbol(\"destroyed\");\n    var kClosed = Symbol(\"closed\");\n    var kOnDestroyed = Symbol(\"onDestroyed\");\n    var kOnClosed = Symbol(\"onClosed\");\n    var DispatcherBase = class extends Dispatcher {\n      constructor() {\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = [];\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n      }\n      get destroyed() {\n        return this[kDestroyed];\n      }\n      get closed() {\n        return this[kClosed];\n      }\n      close(callback) {\n        if (callback === void 0) {\n          return new Promise((resolve, reject) => {\n            this.close((err, data) => {\n              return err ? reject(err) : resolve(data);\n            });\n          });\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n          queueMicrotask(() => callback(new ClientDestroyedError(), null));\n          return;\n        }\n        if (this[kClosed]) {\n          if (this[kOnClosed]) {\n            this[kOnClosed].push(callback);\n          } else {\n            queueMicrotask(() => callback(null, null));\n          }\n          return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = /* @__PURE__ */ __name(() => {\n          const callbacks = this[kOnClosed];\n          this[kOnClosed] = null;\n          for (let i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, null);\n          }\n        }, \"onClosed\");\n        this[kClose]().then(() => this.destroy()).then(() => {\n          queueMicrotask(onClosed);\n        });\n      }\n      destroy(err, callback) {\n        if (typeof err === \"function\") {\n          callback = err;\n          err = null;\n        }\n        if (callback === void 0) {\n          return new Promise((resolve, reject) => {\n            this.destroy(err, (err2, data) => {\n              return err2 ? reject(err2) : resolve(data);\n            });\n          });\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n          if (this[kOnDestroyed]) {\n            this[kOnDestroyed].push(callback);\n          } else {\n            queueMicrotask(() => callback(null, null));\n          }\n          return;\n        }\n        if (!err) {\n          err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = /* @__PURE__ */ __name(() => {\n          const callbacks = this[kOnDestroyed];\n          this[kOnDestroyed] = null;\n          for (let i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, null);\n          }\n        }, \"onDestroyed\");\n        this[kDestroy](err).then(() => {\n          queueMicrotask(onDestroyed);\n        });\n      }\n      dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n          throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n          if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object.\");\n          }\n          if (this[kDestroyed]) {\n            throw new ClientDestroyedError();\n          }\n          if (this[kClosed]) {\n            throw new ClientClosedError();\n          }\n          return this[kDispatch](opts, handler);\n        } catch (err) {\n          if (typeof handler.onError !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onError method\");\n          }\n          handler.onError(err);\n          return false;\n        }\n      }\n    };\n    __name(DispatcherBase, \"DispatcherBase\");\n    module2.exports = DispatcherBase;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/handler/redirect.js\nvar require_redirect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/handler/redirect.js\"(exports, module2) {\n    \"use strict\";\n    var util2 = require_util2();\n    var { kBodyUsed } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { InvalidArgumentError } = require_errors();\n    var EE = __webpack_require__(/*! events */ \"events\");\n    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];\n    var kBody = Symbol(\"body\");\n    var BodyAsyncIterable = class {\n      constructor(body) {\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n      }\n      async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n      }\n    };\n    __name(BodyAsyncIterable, \"BodyAsyncIterable\");\n    var RedirectHandler = class {\n      constructor(dispatcher, maxRedirections, opts, handler) {\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util2.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatcher = dispatcher;\n        this.location = null;\n        this.abort = null;\n        this.opts = { ...opts, maxRedirections: 0 };\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        if (util2.isStream(this.opts.body)) {\n          if (util2.bodyLength(this.opts.body) === 0) {\n            this.opts.body.on(\"data\", function() {\n              assert(false);\n            });\n          }\n          if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n            this.opts.body[kBodyUsed] = false;\n            EE.prototype.on.call(this.opts.body, \"data\", function() {\n              this[kBodyUsed] = true;\n            });\n          }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n          this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {\n          this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n      }\n      onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, { history: this.history });\n      }\n      onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n      }\n      onError(error2) {\n        this.handler.onError(error2);\n      }\n      onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.origin) {\n          this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n          return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path7 = search ? `${pathname}${search}` : pathname;\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path7;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n          this.opts.method = \"GET\";\n          this.opts.body = null;\n        }\n      }\n      onData(chunk) {\n        if (this.location) {\n        } else {\n          return this.handler.onData(chunk);\n        }\n      }\n      onComplete(trailers) {\n        if (this.location) {\n          this.location = null;\n          this.abort = null;\n          this.dispatcher.dispatch(this.opts, this);\n        } else {\n          this.handler.onComplete(trailers);\n        }\n      }\n      onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n          this.handler.onBodySent(chunk);\n        }\n      }\n    };\n    __name(RedirectHandler, \"RedirectHandler\");\n    function parseLocation(statusCode, headers) {\n      if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        if (headers[i].toString().toLowerCase() === \"location\") {\n          return headers[i + 1];\n        }\n      }\n    }\n    __name(parseLocation, \"parseLocation\");\n    function shouldRemoveHeader(header, removeContent, unknownOrigin) {\n      return header.length === 4 && header.toString().toLowerCase() === \"host\" || removeContent && header.toString().toLowerCase().indexOf(\"content-\") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === \"authorization\" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === \"cookie\";\n    }\n    __name(shouldRemoveHeader, \"shouldRemoveHeader\");\n    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n      const ret = [];\n      if (Array.isArray(headers)) {\n        for (let i = 0; i < headers.length; i += 2) {\n          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n            ret.push(headers[i], headers[i + 1]);\n          }\n        }\n      } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)) {\n          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n            ret.push(key, headers[key]);\n          }\n        }\n      } else {\n        assert(headers == null, \"headers must be an object or an array\");\n      }\n      return ret;\n    }\n    __name(cleanRequestHeaders, \"cleanRequestHeaders\");\n    module2.exports = RedirectHandler;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/connect.js\nvar require_connect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/core/connect.js\"(exports, module2) {\n    \"use strict\";\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var util2 = require_util2();\n    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();\n    var tls;\n    function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {\n      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n      }\n      const options = { path: socketPath, ...opts };\n      const sessionCache = /* @__PURE__ */ new Map();\n      timeout = timeout == null ? 1e4 : timeout;\n      maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n      return /* @__PURE__ */ __name(function connect({ hostname: hostname3, host, protocol, port, servername, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n          if (!tls) {\n            tls = __webpack_require__(/*! tls */ \"tls\");\n          }\n          servername = servername || options.servername || util2.getServerName(host) || null;\n          const sessionKey = servername || hostname3;\n          const session = sessionCache.get(sessionKey) || null;\n          assert(sessionKey);\n          socket = tls.connect({\n            highWaterMark: 16384,\n            ...options,\n            servername,\n            session,\n            socket: httpSocket,\n            port: port || 443,\n            host: hostname3\n          });\n          socket.on(\"session\", function(session2) {\n            if (maxCachedSessions === 0) {\n              return;\n            }\n            if (sessionCache.size >= maxCachedSessions) {\n              const { value: oldestKey } = sessionCache.keys().next();\n              sessionCache.delete(oldestKey);\n            }\n            sessionCache.set(sessionKey, session2);\n          }).on(\"error\", function(err) {\n            if (sessionKey && err.code !== \"UND_ERR_INFO\") {\n              sessionCache.delete(sessionKey);\n            }\n          });\n        } else {\n          assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n          socket = net2.connect({\n            highWaterMark: 64 * 1024,\n            ...options,\n            port: port || 80,\n            host: hostname3\n          });\n        }\n        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n          cancelTimeout();\n          if (callback) {\n            const cb = callback;\n            callback = null;\n            cb(null, this);\n          }\n        }).on(\"error\", function(err) {\n          cancelTimeout();\n          if (callback) {\n            const cb = callback;\n            callback = null;\n            cb(err);\n          }\n        });\n        return socket;\n      }, \"connect\");\n    }\n    __name(buildConnector, \"buildConnector\");\n    function setupTimeout(onConnectTimeout2, timeout) {\n      if (!timeout) {\n        return () => {\n        };\n      }\n      let s1 = null;\n      let s2 = null;\n      const timeoutId = setTimeout(() => {\n        s1 = setImmediate(() => {\n          if (process.platform === \"win32\") {\n            s2 = setImmediate(() => onConnectTimeout2());\n          } else {\n            onConnectTimeout2();\n          }\n        });\n      }, timeout);\n      return () => {\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n      };\n    }\n    __name(setupTimeout, \"setupTimeout\");\n    function onConnectTimeout(socket) {\n      util2.destroy(socket, new ConnectTimeoutError());\n    }\n    __name(onConnectTimeout, \"onConnectTimeout\");\n    module2.exports = buildConnector;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/utils.js\nvar require_utils = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/utils.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.enumToMap = void 0;\n    function enumToMap(obj) {\n      const res = {};\n      Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === \"number\") {\n          res[key] = value;\n        }\n      });\n      return res;\n    }\n    __name(enumToMap, \"enumToMap\");\n    exports.enumToMap = enumToMap;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/constants.js\nvar require_constants2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/constants.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\n    var utils_1 = require_utils();\n    var ERROR;\n    (function(ERROR2) {\n      ERROR2[ERROR2[\"OK\"] = 0] = \"OK\";\n      ERROR2[ERROR2[\"INTERNAL\"] = 1] = \"INTERNAL\";\n      ERROR2[ERROR2[\"STRICT\"] = 2] = \"STRICT\";\n      ERROR2[ERROR2[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n      ERROR2[ERROR2[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n      ERROR2[ERROR2[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n      ERROR2[ERROR2[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n      ERROR2[ERROR2[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n      ERROR2[ERROR2[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n      ERROR2[ERROR2[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n      ERROR2[ERROR2[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n      ERROR2[ERROR2[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n      ERROR2[ERROR2[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n      ERROR2[ERROR2[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n      ERROR2[ERROR2[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n      ERROR2[ERROR2[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n      ERROR2[ERROR2[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n      ERROR2[ERROR2[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n      ERROR2[ERROR2[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n      ERROR2[ERROR2[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n      ERROR2[ERROR2[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n      ERROR2[ERROR2[\"PAUSED\"] = 21] = \"PAUSED\";\n      ERROR2[ERROR2[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n      ERROR2[ERROR2[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n      ERROR2[ERROR2[\"USER\"] = 24] = \"USER\";\n    })(ERROR = exports.ERROR || (exports.ERROR = {}));\n    var TYPE;\n    (function(TYPE2) {\n      TYPE2[TYPE2[\"BOTH\"] = 0] = \"BOTH\";\n      TYPE2[TYPE2[\"REQUEST\"] = 1] = \"REQUEST\";\n      TYPE2[TYPE2[\"RESPONSE\"] = 2] = \"RESPONSE\";\n    })(TYPE = exports.TYPE || (exports.TYPE = {}));\n    var FLAGS;\n    (function(FLAGS2) {\n      FLAGS2[FLAGS2[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n      FLAGS2[FLAGS2[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n      FLAGS2[FLAGS2[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n      FLAGS2[FLAGS2[\"CHUNKED\"] = 8] = \"CHUNKED\";\n      FLAGS2[FLAGS2[\"UPGRADE\"] = 16] = \"UPGRADE\";\n      FLAGS2[FLAGS2[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n      FLAGS2[FLAGS2[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n      FLAGS2[FLAGS2[\"TRAILING\"] = 128] = \"TRAILING\";\n      FLAGS2[FLAGS2[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n    })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\n    var LENIENT_FLAGS;\n    (function(LENIENT_FLAGS2) {\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"HEADERS\"] = 1] = \"HEADERS\";\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n      LENIENT_FLAGS2[LENIENT_FLAGS2[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n    })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\n    var METHODS;\n    (function(METHODS2) {\n      METHODS2[METHODS2[\"DELETE\"] = 0] = \"DELETE\";\n      METHODS2[METHODS2[\"GET\"] = 1] = \"GET\";\n      METHODS2[METHODS2[\"HEAD\"] = 2] = \"HEAD\";\n      METHODS2[METHODS2[\"POST\"] = 3] = \"POST\";\n      METHODS2[METHODS2[\"PUT\"] = 4] = \"PUT\";\n      METHODS2[METHODS2[\"CONNECT\"] = 5] = \"CONNECT\";\n      METHODS2[METHODS2[\"OPTIONS\"] = 6] = \"OPTIONS\";\n      METHODS2[METHODS2[\"TRACE\"] = 7] = \"TRACE\";\n      METHODS2[METHODS2[\"COPY\"] = 8] = \"COPY\";\n      METHODS2[METHODS2[\"LOCK\"] = 9] = \"LOCK\";\n      METHODS2[METHODS2[\"MKCOL\"] = 10] = \"MKCOL\";\n      METHODS2[METHODS2[\"MOVE\"] = 11] = \"MOVE\";\n      METHODS2[METHODS2[\"PROPFIND\"] = 12] = \"PROPFIND\";\n      METHODS2[METHODS2[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n      METHODS2[METHODS2[\"SEARCH\"] = 14] = \"SEARCH\";\n      METHODS2[METHODS2[\"UNLOCK\"] = 15] = \"UNLOCK\";\n      METHODS2[METHODS2[\"BIND\"] = 16] = \"BIND\";\n      METHODS2[METHODS2[\"REBIND\"] = 17] = \"REBIND\";\n      METHODS2[METHODS2[\"UNBIND\"] = 18] = \"UNBIND\";\n      METHODS2[METHODS2[\"ACL\"] = 19] = \"ACL\";\n      METHODS2[METHODS2[\"REPORT\"] = 20] = \"REPORT\";\n      METHODS2[METHODS2[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n      METHODS2[METHODS2[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n      METHODS2[METHODS2[\"MERGE\"] = 23] = \"MERGE\";\n      METHODS2[METHODS2[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n      METHODS2[METHODS2[\"NOTIFY\"] = 25] = \"NOTIFY\";\n      METHODS2[METHODS2[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n      METHODS2[METHODS2[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n      METHODS2[METHODS2[\"PATCH\"] = 28] = \"PATCH\";\n      METHODS2[METHODS2[\"PURGE\"] = 29] = \"PURGE\";\n      METHODS2[METHODS2[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n      METHODS2[METHODS2[\"LINK\"] = 31] = \"LINK\";\n      METHODS2[METHODS2[\"UNLINK\"] = 32] = \"UNLINK\";\n      METHODS2[METHODS2[\"SOURCE\"] = 33] = \"SOURCE\";\n      METHODS2[METHODS2[\"PRI\"] = 34] = \"PRI\";\n      METHODS2[METHODS2[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n      METHODS2[METHODS2[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n      METHODS2[METHODS2[\"SETUP\"] = 37] = \"SETUP\";\n      METHODS2[METHODS2[\"PLAY\"] = 38] = \"PLAY\";\n      METHODS2[METHODS2[\"PAUSE\"] = 39] = \"PAUSE\";\n      METHODS2[METHODS2[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n      METHODS2[METHODS2[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n      METHODS2[METHODS2[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n      METHODS2[METHODS2[\"REDIRECT\"] = 43] = \"REDIRECT\";\n      METHODS2[METHODS2[\"RECORD\"] = 44] = \"RECORD\";\n      METHODS2[METHODS2[\"FLUSH\"] = 45] = \"FLUSH\";\n    })(METHODS = exports.METHODS || (exports.METHODS = {}));\n    exports.METHODS_HTTP = [\n      METHODS.DELETE,\n      METHODS.GET,\n      METHODS.HEAD,\n      METHODS.POST,\n      METHODS.PUT,\n      METHODS.CONNECT,\n      METHODS.OPTIONS,\n      METHODS.TRACE,\n      METHODS.COPY,\n      METHODS.LOCK,\n      METHODS.MKCOL,\n      METHODS.MOVE,\n      METHODS.PROPFIND,\n      METHODS.PROPPATCH,\n      METHODS.SEARCH,\n      METHODS.UNLOCK,\n      METHODS.BIND,\n      METHODS.REBIND,\n      METHODS.UNBIND,\n      METHODS.ACL,\n      METHODS.REPORT,\n      METHODS.MKACTIVITY,\n      METHODS.CHECKOUT,\n      METHODS.MERGE,\n      METHODS[\"M-SEARCH\"],\n      METHODS.NOTIFY,\n      METHODS.SUBSCRIBE,\n      METHODS.UNSUBSCRIBE,\n      METHODS.PATCH,\n      METHODS.PURGE,\n      METHODS.MKCALENDAR,\n      METHODS.LINK,\n      METHODS.UNLINK,\n      METHODS.PRI,\n      METHODS.SOURCE\n    ];\n    exports.METHODS_ICE = [\n      METHODS.SOURCE\n    ];\n    exports.METHODS_RTSP = [\n      METHODS.OPTIONS,\n      METHODS.DESCRIBE,\n      METHODS.ANNOUNCE,\n      METHODS.SETUP,\n      METHODS.PLAY,\n      METHODS.PAUSE,\n      METHODS.TEARDOWN,\n      METHODS.GET_PARAMETER,\n      METHODS.SET_PARAMETER,\n      METHODS.REDIRECT,\n      METHODS.RECORD,\n      METHODS.FLUSH,\n      METHODS.GET,\n      METHODS.POST\n    ];\n    exports.METHOD_MAP = utils_1.enumToMap(METHODS);\n    exports.H_METHOD_MAP = {};\n    Object.keys(exports.METHOD_MAP).forEach((key) => {\n      if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n      }\n    });\n    var FINISH;\n    (function(FINISH2) {\n      FINISH2[FINISH2[\"SAFE\"] = 0] = \"SAFE\";\n      FINISH2[FINISH2[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n      FINISH2[FINISH2[\"UNSAFE\"] = 2] = \"UNSAFE\";\n    })(FINISH = exports.FINISH || (exports.FINISH = {}));\n    exports.ALPHA = [];\n    for (let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++) {\n      exports.ALPHA.push(String.fromCharCode(i));\n      exports.ALPHA.push(String.fromCharCode(i + 32));\n    }\n    exports.NUM_MAP = {\n      0: 0,\n      1: 1,\n      2: 2,\n      3: 3,\n      4: 4,\n      5: 5,\n      6: 6,\n      7: 7,\n      8: 8,\n      9: 9\n    };\n    exports.HEX_MAP = {\n      0: 0,\n      1: 1,\n      2: 2,\n      3: 3,\n      4: 4,\n      5: 5,\n      6: 6,\n      7: 7,\n      8: 8,\n      9: 9,\n      A: 10,\n      B: 11,\n      C: 12,\n      D: 13,\n      E: 14,\n      F: 15,\n      a: 10,\n      b: 11,\n      c: 12,\n      d: 13,\n      e: 14,\n      f: 15\n    };\n    exports.NUM = [\n      \"0\",\n      \"1\",\n      \"2\",\n      \"3\",\n      \"4\",\n      \"5\",\n      \"6\",\n      \"7\",\n      \"8\",\n      \"9\"\n    ];\n    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\n    exports.MARK = [\"-\", \"_\", \".\", \"!\", \"~\", \"*\", \"'\", \"(\", \")\"];\n    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\"%\", \";\", \":\", \"&\", \"=\", \"+\", \"$\", \",\"]);\n    exports.STRICT_URL_CHAR = [\n      \"!\",\n      '\"',\n      \"$\",\n      \"%\",\n      \"&\",\n      \"'\",\n      \"(\",\n      \")\",\n      \"*\",\n      \"+\",\n      \",\",\n      \"-\",\n      \".\",\n      \"/\",\n      \":\",\n      \";\",\n      \"<\",\n      \"=\",\n      \">\",\n      \"@\",\n      \"[\",\n      \"\\\\\",\n      \"]\",\n      \"^\",\n      \"_\",\n      \"`\",\n      \"{\",\n      \"|\",\n      \"}\",\n      \"~\"\n    ].concat(exports.ALPHANUM);\n    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\"\t\", \"\\f\"]);\n    for (let i = 128; i <= 255; i++) {\n      exports.URL_CHAR.push(i);\n    }\n    exports.HEX = exports.NUM.concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]);\n    exports.STRICT_TOKEN = [\n      \"!\",\n      \"#\",\n      \"$\",\n      \"%\",\n      \"&\",\n      \"'\",\n      \"*\",\n      \"+\",\n      \"-\",\n      \".\",\n      \"^\",\n      \"_\",\n      \"`\",\n      \"|\",\n      \"~\"\n    ].concat(exports.ALPHANUM);\n    exports.TOKEN = exports.STRICT_TOKEN.concat([\" \"]);\n    exports.HEADER_CHARS = [\"\t\"];\n    for (let i = 32; i <= 255; i++) {\n      if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n      }\n    }\n    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\n    exports.MAJOR = exports.NUM_MAP;\n    exports.MINOR = exports.MAJOR;\n    var HEADER_STATE;\n    (function(HEADER_STATE2) {\n      HEADER_STATE2[HEADER_STATE2[\"GENERAL\"] = 0] = \"GENERAL\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION\"] = 1] = \"CONNECTION\";\n      HEADER_STATE2[HEADER_STATE2[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n      HEADER_STATE2[HEADER_STATE2[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n      HEADER_STATE2[HEADER_STATE2[\"UPGRADE\"] = 4] = \"UPGRADE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n      HEADER_STATE2[HEADER_STATE2[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n      HEADER_STATE2[HEADER_STATE2[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\n    exports.SPECIAL_HEADERS = {\n      \"connection\": HEADER_STATE.CONNECTION,\n      \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n      \"proxy-connection\": HEADER_STATE.CONNECTION,\n      \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n      \"upgrade\": HEADER_STATE.UPGRADE\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp.wasm.js\nvar require_llhttp_wasm = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp.wasm.js\"(exports, module2) {\n    module2.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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f2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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HgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcN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ImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiAC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IiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABB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QR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVO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AAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\";\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js\nvar require_llhttp_simd_wasm = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js\"(exports, module2) {\n    module2.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYKuKgCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAs+AQF7IAD9DAAAAAAAAAAAAAAAAAAAAAAiAf0LAgAgAEEwakIANwIAIABBIGogAf0LAgAgAEEQaiAB/QsCAAtnAQF/QQAhAQJAIAAoAgwNAAJAAkACQAJAIAAtAC8OAwEAAwILIAAoAjQiAUUNACABKAIcIgFFDQAgACABEYCAgIAAACIBDQMLQQAPCxC/gICAAAALIABB/5GAgAA2AhBBDiEBCyABCx4AAkAgACgCDA0AIABBhJSAgAA2AhAgAEEVNgIMCwsWAAJAIAAoAgxBFUcNACAAQQA2AgwLCxYAAkAgACgCDEEWRw0AIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCyIAAkAgAEEaSQ0AEL+AgIAAAAsgAEECdEHIm4CAAGooAgALIgACQCAAQS5JDQAQv4CAgAAACyAAQQJ0QbCcgIAAaigCAAsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCACIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIEIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBnI6AgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAigiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCCCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQdKKgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAgwiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHdk4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCMCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIQIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBw5CAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCFCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIcIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAhgiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSiICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCICIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIkIgRFDQAgACAEEYCAgIAAACEDCyADC0UBAX8CQAJAIAAvATBBFHFBFEcNAEEBIQMgAC0AKEEBRg0BIAAvATJB5QBGIQMMAQsgAC0AKUEFRiEDCyAAIAM6AC5BAAvyAQEDf0EBIQMCQCAALwEwIgRBCHENACAAKQMgQgBSIQMLAkACQCAALQAuRQ0AQQEhBSAALQApQQVGDQFBASEFIARBwABxRSADcUEBRw0BC0EAIQUgBEHAAHENAEECIQUgBEEIcQ0AAkAgBEGABHFFDQACQCAALQAoQQFHDQAgAC0ALUEKcQ0AQQUPC0EEDwsCQCAEQSBxDQACQCAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELSAEBeyAAQRBq/QwAAAAAAAAAAAAAAAAAAAAAIgH9CwMAIAAgAf0LAwAgAEEwakIANwMAIABBIGogAf0LAwAgAEG8ATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACELiAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvTzgEDHH8DfgV/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8gASEQIAEhESABIRIgASETIAEhFCABIRUgASEWIAEhFyABIRggASEZIAEhGiABIRsgASEcIAEhHQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiHkF/ag68AbcBAbYBAgMEBQYHCAkKCwwNDg8QwAG/ARESE7UBFBUWFxgZGr0BvAEbHB0eHyAhtAGzASIjsgGxASQlJicoKSorLC0uLzAxMjM0NTY3ODk6uAE7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwEAuQELQQAhHgyvAQtBDyEeDK4BC0EOIR4MrQELQRAhHgysAQtBESEeDKsBC0EUIR4MqgELQRUhHgypAQtBFiEeDKgBC0EXIR4MpwELQRghHgymAQtBCCEeDKUBC0EZIR4MpAELQRohHgyjAQtBEyEeDKIBC0ESIR4MoQELQRshHgygAQtBHCEeDJ8BC0EdIR4MngELQR4hHgydAQtBqgEhHgycAQtBqwEhHgybAQtBICEeDJoBC0EhIR4MmQELQSIhHgyYAQtBIyEeDJcBC0EkIR4MlgELQa0BIR4MlQELQSUhHgyUAQtBKSEeDJMBC0ENIR4MkgELQSYhHgyRAQtBJyEeDJABC0EoIR4MjwELQS4hHgyOAQtBKiEeDI0BC0GuASEeDIwBC0EMIR4MiwELQS8hHgyKAQtBKyEeDIkBC0ELIR4MiAELQSwhHgyHAQtBLSEeDIYBC0EKIR4MhQELQTEhHgyEAQtBMCEeDIMBC0EJIR4MggELQR8hHgyBAQtBMiEeDIABC0EzIR4MfwtBNCEeDH4LQTUhHgx9C0E2IR4MfAtBNyEeDHsLQTghHgx6C0E5IR4MeQtBOiEeDHgLQawBIR4MdwtBOyEeDHYLQTwhHgx1C0E9IR4MdAtBPiEeDHMLQT8hHgxyC0HAACEeDHELQcEAIR4McAtBwgAhHgxvC0HDACEeDG4LQcQAIR4MbQtBByEeDGwLQcUAIR4MawtBBiEeDGoLQcYAIR4MaQtBBSEeDGgLQccAIR4MZwtBBCEeDGYLQcgAIR4MZQtByQAhHgxkC0HKACEeDGMLQcsAIR4MYgtBAyEeDGELQcwAIR4MYAtBzQAhHgxfC0HOACEeDF4LQdAAIR4MXQtBzwAhHgxcC0HRACEeDFsLQdIAIR4MWgtBAiEeDFkLQdMAIR4MWAtB1AAhHgxXC0HVACEeDFYLQdYAIR4MVQtB1wAhHgxUC0HYACEeDFMLQdkAIR4MUgtB2gAhHgxRC0HbACEeDFALQdwAIR4MTwtB3QAhHgxOC0HeACEeDE0LQd8AIR4MTAtB4AAhHgxLC0HhACEeDEoLQeIAIR4MSQtB4wAhHgxIC0HkACEeDEcLQeUAIR4MRgtB5gAhHgxFC0HnACEeDEQLQegAIR4MQwtB6QAhHgxCC0HqACEeDEELQesAIR4MQAtB7AAhHgw/C0HtACEeDD4LQe4AIR4MPQtB7wAhHgw8C0HwACEeDDsLQfEAIR4MOgtB8gAhHgw5C0HzACEeDDgLQfQAIR4MNwtB9QAhHgw2C0H2ACEeDDULQfcAIR4MNAtB+AAhHgwzC0H5ACEeDDILQfoAIR4MMQtB+wAhHgwwC0H8ACEeDC8LQf0AIR4MLgtB/gAhHgwtC0H/ACEeDCwLQYABIR4MKwtBgQEhHgwqC0GCASEeDCkLQYMBIR4MKAtBhAEhHgwnC0GFASEeDCYLQYYBIR4MJQtBhwEhHgwkC0GIASEeDCMLQYkBIR4MIgtBigEhHgwhC0GLASEeDCALQYwBIR4MHwtBjQEhHgweC0GOASEeDB0LQY8BIR4MHAtBkAEhHgwbC0GRASEeDBoLQZIBIR4MGQtBkwEhHgwYC0GUASEeDBcLQZUBIR4MFgtBlgEhHgwVC0GXASEeDBQLQZgBIR4MEwtBmQEhHgwSC0GdASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJq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LwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACAB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HiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJA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AkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQ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BQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv\";\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/client.js\nvar require_client = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/client.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var net2 = __webpack_require__(/*! net */ \"net\");\n    var util2 = require_util2();\n    var Request = require_request();\n    var DispatcherBase = require_dispatcher_base();\n    var RedirectHandler = require_redirect();\n    var {\n      RequestContentLengthMismatchError,\n      ResponseContentLengthMismatchError,\n      InvalidArgumentError,\n      RequestAbortedError,\n      HeadersTimeoutError,\n      HeadersOverflowError,\n      SocketError,\n      InformationalError,\n      BodyTimeoutError,\n      HTTPParserError\n    } = require_errors();\n    var buildConnector = require_connect();\n    var {\n      kUrl,\n      kReset,\n      kServerName,\n      kClient,\n      kBusy,\n      kParser,\n      kConnect,\n      kBlocking,\n      kResuming,\n      kRunning,\n      kPending,\n      kSize,\n      kWriting,\n      kQueue,\n      kConnected,\n      kConnecting,\n      kNeedDrain,\n      kNoRef,\n      kKeepAliveDefaultTimeout,\n      kHostHeader,\n      kPendingIdx,\n      kRunningIdx,\n      kError,\n      kPipelining,\n      kSocket,\n      kKeepAliveTimeoutValue,\n      kMaxHeadersSize,\n      kKeepAliveMaxTimeout,\n      kKeepAliveTimeoutThreshold,\n      kHeadersTimeout,\n      kBodyTimeout,\n      kStrictContentLength,\n      kConnector,\n      kMaxRedirections,\n      kMaxRequests,\n      kCounter,\n      kClose,\n      kDestroy,\n      kDispatch\n    } = require_symbols();\n    var kClosedResolve = Symbol(\"kClosedResolve\");\n    var channels = {};\n    try {\n      const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n      channels.sendHeaders = diagnosticsChannel.channel(\"undici:client:sendHeaders\");\n      channels.beforeConnect = diagnosticsChannel.channel(\"undici:client:beforeConnect\");\n      channels.connectError = diagnosticsChannel.channel(\"undici:client:connectError\");\n      channels.connected = diagnosticsChannel.channel(\"undici:client:connected\");\n    } catch (e) {\n      channels.sendHeaders = { hasSubscribers: false };\n      channels.beforeConnect = { hasSubscribers: false };\n      channels.connectError = { hasSubscribers: false };\n      channels.connected = { hasSubscribers: false };\n    }\n    var Client = class extends DispatcherBase {\n      constructor(url, {\n        maxHeaderSize,\n        headersTimeout,\n        socketTimeout,\n        requestTimeout,\n        connectTimeout,\n        bodyTimeout,\n        idleTimeout,\n        keepAlive,\n        keepAliveTimeout,\n        maxKeepAliveTimeout,\n        keepAliveMaxTimeout,\n        keepAliveTimeoutThreshold,\n        socketPath,\n        pipelining,\n        tls,\n        strictContentLength,\n        maxCachedSessions,\n        maxRedirections,\n        connect: connect2,\n        maxRequestsPerClient\n      } = {}) {\n        super();\n        if (keepAlive !== void 0) {\n          throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== void 0) {\n          throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n          throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n          throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n          throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n          throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n          throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n          throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n          throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n          throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect2 != null && typeof connect2 !== \"function\" && typeof connect2 !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n          throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (typeof connect2 !== \"function\") {\n          connect2 = buildConnector({\n            ...tls,\n            maxCachedSessions,\n            socketPath,\n            timeout: connectTimeout,\n            ...connect2\n          });\n        }\n        this[kUrl] = util2.parseOrigin(url);\n        this[kConnector] = connect2;\n        this[kSocket] = null;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || 16384;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kResuming] = 0;\n        this[kNeedDrain] = 0;\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n      }\n      get pipelining() {\n        return this[kPipelining];\n      }\n      set pipelining(value) {\n        this[kPipelining] = value;\n        resume(this, true);\n      }\n      get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n      }\n      get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n      }\n      get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n      }\n      get [kConnected]() {\n        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n      }\n      get [kBusy]() {\n        const socket = this[kSocket];\n        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n      }\n      [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n      }\n      [kDispatch](opts, handler) {\n        const { maxRedirections = this[kMaxRedirections] } = opts;\n        if (maxRedirections) {\n          handler = new RedirectHandler(this, maxRedirections, opts, handler);\n        }\n        const origin = opts.origin || this[kUrl].origin;\n        const request2 = new Request(origin, opts, handler);\n        this[kQueue].push(request2);\n        if (this[kResuming]) {\n        } else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {\n          this[kResuming] = 1;\n          process.nextTick(resume, this);\n        } else {\n          resume(this, true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n          this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n      }\n      async [kClose]() {\n        return new Promise((resolve) => {\n          if (!this[kSize]) {\n            this.destroy(resolve);\n          } else {\n            this[kClosedResolve] = resolve;\n          }\n        });\n      }\n      async [kDestroy](err) {\n        return new Promise((resolve) => {\n          const requests = this[kQueue].splice(this[kPendingIdx]);\n          for (let i = 0; i < requests.length; i++) {\n            const request2 = requests[i];\n            errorRequest(this, request2, err);\n          }\n          const callback = /* @__PURE__ */ __name(() => {\n            if (this[kClosedResolve]) {\n              this[kClosedResolve]();\n              this[kClosedResolve] = null;\n            }\n            resolve();\n          }, \"callback\");\n          if (!this[kSocket]) {\n            queueMicrotask(callback);\n          } else {\n            util2.destroy(this[kSocket].on(\"close\", callback), err);\n          }\n          resume(this);\n        });\n      }\n    };\n    __name(Client, \"Client\");\n    var constants = require_constants2();\n    var EMPTY_BUF = Buffer.alloc(0);\n    async function lazyllhttp() {\n      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;\n      let mod2;\n      try {\n        mod2 = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), \"base64\"));\n      } catch (e) {\n        mod2 = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), \"base64\"));\n      }\n      return await WebAssembly.instantiate(mod2, {\n        env: {\n          wasm_on_url: (p, at, len) => {\n            return 0;\n          },\n          wasm_on_status: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_message_begin: (p) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onMessageBegin() || 0;\n          },\n          wasm_on_header_field: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_header_value: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n          },\n          wasm_on_body: (p, at, len) => {\n            assert.strictEqual(currentParser.ptr, p);\n            const start = at - currentBufferPtr;\n            const end = start + len;\n            return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n          },\n          wasm_on_message_complete: (p) => {\n            assert.strictEqual(currentParser.ptr, p);\n            return currentParser.onMessageComplete() || 0;\n          }\n        }\n      });\n    }\n    __name(lazyllhttp, \"lazyllhttp\");\n    var llhttpInstance = null;\n    var llhttpPromise = lazyllhttp().catch(() => {\n    });\n    var currentParser = null;\n    var currentBufferRef = null;\n    var currentBufferSize = 0;\n    var currentBufferPtr = null;\n    var TIMEOUT_HEADERS = 1;\n    var TIMEOUT_BODY = 2;\n    var TIMEOUT_IDLE = 3;\n    var Parser = class {\n      constructor(client, socket, { exports: exports2 }) {\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports2;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n      }\n      setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n          clearTimeout(this.timeout);\n          if (value) {\n            this.timeout = setTimeout(onParserTimeout, value, this);\n            if (this.timeout.unref) {\n              this.timeout.unref();\n            }\n          } else {\n            this.timeout = null;\n          }\n          this.timeoutValue = value;\n        } else if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n      }\n      resume() {\n        if (this.socket.destroyed || !this.paused) {\n          return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF);\n        this.readMore();\n      }\n      readMore() {\n        while (!this.paused && this.ptr) {\n          const chunk = this.socket.read();\n          if (chunk === null) {\n            break;\n          }\n          this.execute(chunk);\n        }\n      }\n      execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n          if (currentBufferPtr) {\n            llhttp.free(currentBufferPtr);\n          }\n          currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n          currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        try {\n          let ret;\n          try {\n            currentBufferRef = data;\n            currentParser = this;\n            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n          } catch (err) {\n            throw err;\n          } finally {\n            currentParser = null;\n            currentBufferRef = null;\n          }\n          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n          if (ret === constants.ERROR.PAUSED_UPGRADE) {\n            this.onUpgrade(data.slice(offset));\n          } else if (ret === constants.ERROR.PAUSED) {\n            this.paused = true;\n            socket.unshift(data.slice(offset));\n          } else if (ret !== constants.ERROR.OK) {\n            const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n            let message = \"\";\n            if (ptr) {\n              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n              message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n            }\n            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n          }\n        } catch (err) {\n          util2.destroy(socket, err);\n        }\n      }\n      finish() {\n        try {\n          try {\n            currentParser = this;\n          } finally {\n            currentParser = null;\n          }\n        } catch (err) {\n          util2.destroy(this.socket, err);\n        }\n      }\n      destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n      }\n      onStatus(buf) {\n        this.statusText = buf.toString();\n      }\n      onMessageBegin() {\n        const { socket, client } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        if (!request2) {\n          return -1;\n        }\n      }\n      onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n          this.headers.push(buf);\n        } else {\n          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n        }\n        this.trackHeader(buf.length);\n      }\n      onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n          this.headers.push(buf);\n          len += 1;\n        } else {\n          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === \"keep-alive\") {\n          this.keepAlive += buf.toString();\n        } else if (key.length === 14 && key.toString().toLowerCase() === \"content-length\") {\n          this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n      }\n      trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n          util2.destroy(this.socket, new HeadersOverflowError());\n        }\n      }\n      onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request2.upgrade || request2.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        socket.removeListener(\"error\", onSocketError).removeListener(\"readable\", onSocketReadable).removeListener(\"end\", onSocketEnd).removeListener(\"close\", onSocketClose);\n        client[kSocket] = null;\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [client], new InformationalError(\"upgrade\"));\n        try {\n          request2.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n          util2.destroy(socket, err);\n        }\n        resume(client);\n      }\n      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        if (!request2) {\n          return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n          util2.destroy(socket, new SocketError(\"bad response\", util2.getSocketInfo(socket)));\n          return -1;\n        }\n        if (upgrade && !request2.upgrade) {\n          util2.destroy(socket, new SocketError(\"bad upgrade\", util2.getSocketInfo(socket)));\n          return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive;\n        if (this.statusCode >= 200) {\n          const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client[kBodyTimeout];\n          this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        if (request2.method === \"CONNECT\") {\n          assert(client[kRunning] === 1);\n          this.upgrade = true;\n          return 2;\n        }\n        if (upgrade) {\n          assert(client[kRunning] === 1);\n          this.upgrade = true;\n          return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (shouldKeepAlive && client[kPipelining]) {\n          const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;\n          if (keepAliveTimeout != null) {\n            const timeout = Math.min(\n              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n              client[kKeepAliveMaxTimeout]\n            );\n            if (timeout <= 0) {\n              socket[kReset] = true;\n            } else {\n              client[kKeepAliveTimeoutValue] = timeout;\n            }\n          } else {\n            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n          }\n        } else {\n          socket[kReset] = true;\n        }\n        let pause;\n        try {\n          pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        } catch (err) {\n          util2.destroy(socket, err);\n          return -1;\n        }\n        if (request2.method === \"HEAD\") {\n          assert(socket[kReset]);\n          return 1;\n        }\n        if (statusCode < 200) {\n          return 1;\n        }\n        if (socket[kBlocking]) {\n          socket[kBlocking] = false;\n          resume(client);\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n      }\n      onBody(buf) {\n        const { client, socket, statusCode } = this;\n        if (socket.destroyed) {\n          return -1;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n          if (this.timeout.refresh) {\n            this.timeout.refresh();\n          }\n        }\n        assert(statusCode >= 200);\n        this.bytesRead += buf.length;\n        try {\n          if (request2.onData(buf) === false) {\n            return constants.ERROR.PAUSED;\n          }\n        } catch (err) {\n          util2.destroy(socket, err);\n          return -1;\n        }\n      }\n      onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n          return -1;\n        }\n        if (upgrade) {\n          return;\n        }\n        const request2 = client[kQueue][client[kRunningIdx]];\n        assert(request2);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n          return;\n        }\n        if (request2.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n          util2.destroy(socket, new ResponseContentLengthMismatchError());\n          return -1;\n        }\n        try {\n          request2.onComplete(headers);\n        } catch (err) {\n          errorRequest(client, request2, err);\n        }\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n          assert.strictEqual(client[kRunning], 0);\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n          util2.destroy(socket, new InformationalError(\"reset\"));\n          return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] === 1) {\n          setImmediate(resume, client);\n        } else {\n          resume(client);\n        }\n      }\n    };\n    __name(Parser, \"Parser\");\n    function onParserTimeout(parser) {\n      const { socket, timeoutType, client } = parser;\n      if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n          assert(!parser.paused, \"cannot be paused while waiting for headers\");\n          util2.destroy(socket, new HeadersTimeoutError());\n        }\n      } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n          util2.destroy(socket, new BodyTimeoutError());\n        }\n      } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util2.destroy(socket, new InformationalError(\"socket idle timeout\"));\n      }\n    }\n    __name(onParserTimeout, \"onParserTimeout\");\n    function onSocketReadable() {\n      const { [kParser]: parser } = this;\n      parser.readMore();\n    }\n    __name(onSocketReadable, \"onSocketReadable\");\n    function onSocketError(err) {\n      const { [kParser]: parser } = this;\n      assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n      if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n        parser.finish();\n        return;\n      }\n      this[kError] = err;\n      onError(this[kClient], err);\n    }\n    __name(onSocketError, \"onSocketError\");\n    function onError(client, err) {\n      if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for (let i = 0; i < requests.length; i++) {\n          const request2 = requests[i];\n          errorRequest(client, request2, err);\n        }\n        assert(client[kSize] === 0);\n      }\n    }\n    __name(onError, \"onError\");\n    function onSocketEnd() {\n      const { [kParser]: parser } = this;\n      if (parser.statusCode && !parser.shouldKeepAlive) {\n        parser.finish();\n        return;\n      }\n      util2.destroy(this, new SocketError(\"other side closed\", util2.getSocketInfo(this)));\n    }\n    __name(onSocketEnd, \"onSocketEnd\");\n    function onSocketClose() {\n      const { [kClient]: client } = this;\n      this[kParser].destroy();\n      this[kParser] = null;\n      const err = this[kError] || new SocketError(\"closed\", util2.getSocketInfo(this));\n      client[kSocket] = null;\n      if (client.destroyed) {\n        assert(client[kPending] === 0);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for (let i = 0; i < requests.length; i++) {\n          const request2 = requests[i];\n          errorRequest(client, request2, err);\n        }\n      } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n        const request2 = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request2, err);\n      }\n      client[kPendingIdx] = client[kRunningIdx];\n      assert(client[kRunning] === 0);\n      client.emit(\"disconnect\", client[kUrl], [client], err);\n      resume(client);\n    }\n    __name(onSocketClose, \"onSocketClose\");\n    async function connect(client) {\n      assert(!client[kConnecting]);\n      assert(!client[kSocket]);\n      let { host, hostname: hostname3, protocol, port } = client[kUrl];\n      if (hostname3[0] === \"[\") {\n        const idx = hostname3.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname3.substr(1, idx - 1);\n        assert(net2.isIP(ip));\n        hostname3 = ip;\n      }\n      client[kConnecting] = true;\n      if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n          connectParams: {\n            host,\n            hostname: hostname3,\n            protocol,\n            port,\n            servername: client[kServerName]\n          },\n          connector: client[kConnector]\n        });\n      }\n      try {\n        const socket = await new Promise((resolve, reject) => {\n          client[kConnector]({\n            host,\n            hostname: hostname3,\n            protocol,\n            port,\n            servername: client[kServerName]\n          }, (err, socket2) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(socket2);\n            }\n          });\n        });\n        if (!llhttpInstance) {\n          llhttpInstance = await llhttpPromise;\n          llhttpPromise = null;\n        }\n        client[kConnecting] = false;\n        assert(socket);\n        client[kSocket] = socket;\n        socket[kNoRef] = false;\n        socket[kWriting] = false;\n        socket[kReset] = false;\n        socket[kBlocking] = false;\n        socket[kError] = null;\n        socket[kParser] = new Parser(client, socket, llhttpInstance);\n        socket[kClient] = client;\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket.on(\"error\", onSocketError).on(\"readable\", onSocketReadable).on(\"end\", onSocketEnd).on(\"close\", onSocketClose);\n        if (channels.connected.hasSubscribers) {\n          channels.connected.publish({\n            connectParams: {\n              host,\n              hostname: hostname3,\n              protocol,\n              port,\n              servername: client[kServerName]\n            },\n            connector: client[kConnector],\n            socket\n          });\n        }\n        client.emit(\"connect\", client[kUrl], [client]);\n      } catch (err) {\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n          channels.connectError.publish({\n            connectParams: {\n              host,\n              hostname: hostname3,\n              protocol,\n              port,\n              servername: client[kServerName]\n            },\n            connector: client[kConnector],\n            error: err\n          });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n          assert(client[kRunning] === 0);\n          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n            const request2 = client[kQueue][client[kPendingIdx]++];\n            errorRequest(client, request2, err);\n          }\n        } else {\n          onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [client], err);\n      }\n      resume(client);\n    }\n    __name(connect, \"connect\");\n    function emitDrain(client) {\n      client[kNeedDrain] = 0;\n      client.emit(\"drain\", client[kUrl], [client]);\n    }\n    __name(emitDrain, \"emitDrain\");\n    function resume(client, sync) {\n      if (client[kResuming] === 2) {\n        return;\n      }\n      client[kResuming] = 2;\n      _resume(client, sync);\n      client[kResuming] = 0;\n      if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n      }\n    }\n    __name(resume, \"resume\");\n    function _resume(client, sync) {\n      while (true) {\n        if (client.destroyed) {\n          assert(client[kPending] === 0);\n          return;\n        }\n        if (client.closed && !client[kSize]) {\n          client.destroy();\n          return;\n        }\n        const socket = client[kSocket];\n        if (socket) {\n          if (client[kSize] === 0) {\n            if (!socket[kNoRef] && socket.unref) {\n              socket.unref();\n              socket[kNoRef] = true;\n            }\n          } else if (socket[kNoRef] && socket.ref) {\n            socket.ref();\n            socket[kNoRef] = false;\n          }\n          if (client[kSize] === 0) {\n            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n            }\n          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n              const request3 = client[kQueue][client[kRunningIdx]];\n              const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client[kHeadersTimeout];\n              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n            }\n          }\n        }\n        if (client[kBusy]) {\n          client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n          if (sync) {\n            client[kNeedDrain] = 1;\n            process.nextTick(emitDrain, client);\n          } else {\n            emitDrain(client);\n          }\n          continue;\n        }\n        if (client[kPending] === 0) {\n          return;\n        }\n        if (client[kRunning] >= (client[kPipelining] || 1)) {\n          return;\n        }\n        const request2 = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request2.servername) {\n          if (client[kRunning] > 0) {\n            return;\n          }\n          client[kServerName] = request2.servername;\n          if (socket && socket.servername !== request2.servername) {\n            util2.destroy(socket, new InformationalError(\"servername changed\"));\n            return;\n          }\n        }\n        if (client[kConnecting]) {\n          return;\n        }\n        if (!socket) {\n          connect(client);\n          continue;\n        }\n        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n          return;\n        }\n        if (client[kRunning] > 0 && !request2.idempotent) {\n          return;\n        }\n        if (client[kRunning] > 0 && (request2.upgrade || request2.method === \"CONNECT\")) {\n          return;\n        }\n        if (util2.isStream(request2.body) && util2.bodyLength(request2.body) === 0) {\n          request2.body.on(\"data\", function() {\n            assert(false);\n          }).on(\"error\", function(err) {\n            errorRequest(client, request2, err);\n          }).on(\"end\", function() {\n            util2.destroy(this);\n          });\n          request2.body = null;\n        }\n        if (client[kRunning] > 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body))) {\n          return;\n        }\n        if (!request2.aborted && write(client, request2)) {\n          client[kPendingIdx]++;\n        } else {\n          client[kQueue].splice(client[kPendingIdx], 1);\n        }\n      }\n    }\n    __name(_resume, \"_resume\");\n    function write(client, request2) {\n      const { body, method, path: path7, host, upgrade, headers, blocking } = request2;\n      const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n      if (body && typeof body.read === \"function\") {\n        body.read(0);\n      }\n      let contentLength = util2.bodyLength(body);\n      if (contentLength === null) {\n        contentLength = request2.contentLength;\n      }\n      if (contentLength === 0 && !expectsPayload) {\n        contentLength = null;\n      }\n      if (request2.contentLength !== null && request2.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n          errorRequest(client, request2, new RequestContentLengthMismatchError());\n          return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n      const socket = client[kSocket];\n      try {\n        request2.onConnect((err) => {\n          if (request2.aborted || request2.completed) {\n            return;\n          }\n          errorRequest(client, request2, err || new RequestAbortedError());\n          util2.destroy(socket, new InformationalError(\"aborted\"));\n        });\n      } catch (err) {\n        errorRequest(client, request2, err);\n      }\n      if (request2.aborted) {\n        return false;\n      }\n      if (method === \"HEAD\") {\n        socket[kReset] = true;\n      }\n      if (upgrade || method === \"CONNECT\") {\n        socket[kReset] = true;\n      }\n      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n      }\n      if (blocking) {\n        socket[kBlocking] = true;\n      }\n      let header = `${method} ${path7} HTTP/1.1\\r\n`;\n      if (typeof host === \"string\") {\n        header += `host: ${host}\\r\n`;\n      } else {\n        header += client[kHostHeader];\n      }\n      if (upgrade) {\n        header += `connection: upgrade\\r\nupgrade: ${upgrade}\\r\n`;\n      } else if (client[kPipelining]) {\n        header += \"connection: keep-alive\\r\\n\";\n      } else {\n        header += \"connection: close\\r\\n\";\n      }\n      if (headers) {\n        header += headers;\n      }\n      if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({ request: request2, headers: header, socket });\n      }\n      if (!body) {\n        if (contentLength === 0) {\n          socket.write(`${header}content-length: 0\\r\n\\r\n`, \"ascii\");\n        } else {\n          assert(contentLength === null, \"no body must not have content length\");\n          socket.write(`${header}\\r\n`, \"ascii\");\n        }\n        request2.onRequestSent();\n      } else if (util2.isBuffer(body)) {\n        assert(contentLength === body.byteLength, \"buffer body must have content length\");\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n        socket.write(body);\n        socket.uncork();\n        request2.onBodySent(body);\n        request2.onRequestSent();\n        if (!expectsPayload) {\n          socket[kReset] = true;\n        }\n      } else if (util2.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n          writeIterable({ body: body.stream(), client, request: request2, socket, contentLength, header, expectsPayload });\n        } else {\n          writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n        }\n      } else if (util2.isStream(body)) {\n        writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n      } else if (util2.isIterable(body)) {\n        writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload });\n      } else {\n        assert(false);\n      }\n      return true;\n    }\n    __name(write, \"write\");\n    function writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n      let finished = false;\n      const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });\n      const onData = /* @__PURE__ */ __name(function(chunk) {\n        try {\n          assert(!finished);\n          if (!writer.write(chunk) && this.pause) {\n            this.pause();\n          }\n        } catch (err) {\n          util2.destroy(this, err);\n        }\n      }, \"onData\");\n      const onDrain = /* @__PURE__ */ __name(function() {\n        assert(!finished);\n        if (body.resume) {\n          body.resume();\n        }\n      }, \"onDrain\");\n      const onAbort = /* @__PURE__ */ __name(function() {\n        onFinished(new RequestAbortedError());\n      }, \"onAbort\");\n      const onFinished = /* @__PURE__ */ __name(function(err) {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"error\", onFinished).removeListener(\"close\", onAbort);\n        if (!err) {\n          try {\n            writer.end();\n          } catch (er) {\n            err = er;\n          }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n          util2.destroy(body, err);\n        } else {\n          util2.destroy(body);\n        }\n      }, \"onFinished\");\n      body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onAbort);\n      if (body.resume) {\n        body.resume();\n      }\n      socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n    }\n    __name(writeStream, \"writeStream\");\n    async function writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength === body.size, \"blob body must have content length\");\n      try {\n        if (contentLength != null && contentLength !== body.size) {\n          throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n        socket.write(buffer);\n        socket.uncork();\n        request2.onBodySent(buffer);\n        request2.onRequestSent();\n        if (!expectsPayload) {\n          socket[kReset] = true;\n        }\n        resume(client);\n      } catch (err) {\n        util2.destroy(socket, err);\n      }\n    }\n    __name(writeBlob, \"writeBlob\");\n    async function writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {\n      assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n      let callback = null;\n      function onDrain() {\n        if (callback) {\n          const cb = callback;\n          callback = null;\n          cb();\n        }\n      }\n      __name(onDrain, \"onDrain\");\n      const waitForDrain = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {\n        assert(callback === null);\n        if (socket[kError]) {\n          reject(socket[kError]);\n        } else {\n          callback = resolve;\n        }\n      }), \"waitForDrain\");\n      socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n      const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });\n      try {\n        for await (const chunk of body) {\n          if (socket[kError]) {\n            throw socket[kError];\n          }\n          if (!writer.write(chunk)) {\n            await waitForDrain();\n          }\n        }\n        writer.end();\n      } catch (err) {\n        writer.destroy(err);\n      } finally {\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n      }\n    }\n    __name(writeIterable, \"writeIterable\");\n    var AsyncWriter = class {\n      constructor({ socket, request: request2, contentLength, client, expectsPayload, header }) {\n        this.socket = socket;\n        this.request = request2;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[kWriting] = true;\n      }\n      write(chunk) {\n        const { socket, request: request2, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n          throw socket[kError];\n        }\n        if (socket.destroyed) {\n          return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n          return true;\n        }\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n          if (client[kStrictContentLength]) {\n            throw new RequestContentLengthMismatchError();\n          }\n          process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        if (bytesWritten === 0) {\n          if (!expectsPayload) {\n            socket[kReset] = true;\n          }\n          if (contentLength === null) {\n            socket.write(`${header}transfer-encoding: chunked\\r\n`, \"ascii\");\n          } else {\n            socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`, \"ascii\");\n          }\n        }\n        if (contentLength === null) {\n          socket.write(`\\r\n${len.toString(16)}\\r\n`, \"ascii\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        request2.onBodySent(chunk);\n        if (!ret) {\n          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            if (socket[kParser].timeout.refresh) {\n              socket[kParser].timeout.refresh();\n            }\n          }\n        }\n        return ret;\n      }\n      end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request2 } = this;\n        request2.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n          throw socket[kError];\n        }\n        if (socket.destroyed) {\n          return;\n        }\n        if (bytesWritten === 0) {\n          if (expectsPayload) {\n            socket.write(`${header}content-length: 0\\r\n\\r\n`, \"ascii\");\n          } else {\n            socket.write(`${header}\\r\n`, \"ascii\");\n          }\n        } else if (contentLength === null) {\n          socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"ascii\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n          if (client[kStrictContentLength]) {\n            throw new RequestContentLengthMismatchError();\n          } else {\n            process.emitWarning(new RequestContentLengthMismatchError());\n          }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n          if (socket[kParser].timeout.refresh) {\n            socket[kParser].timeout.refresh();\n          }\n        }\n        resume(client);\n      }\n      destroy(err) {\n        const { socket, client } = this;\n        socket[kWriting] = false;\n        if (err) {\n          assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n          util2.destroy(socket, err);\n        }\n      }\n    };\n    __name(AsyncWriter, \"AsyncWriter\");\n    function errorRequest(client, request2, err) {\n      try {\n        request2.onError(err);\n        assert(request2.aborted);\n      } catch (err2) {\n        client.emit(\"error\", err2);\n      }\n    }\n    __name(errorRequest, \"errorRequest\");\n    module2.exports = Client;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/node/fixed-queue.js\nvar require_fixed_queue = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/node/fixed-queue.js\"(exports, module2) {\n    \"use strict\";\n    var kSize = 2048;\n    var kMask = kSize - 1;\n    var FixedCircularBuffer = class {\n      constructor() {\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n      }\n      isEmpty() {\n        return this.top === this.bottom;\n      }\n      isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n      }\n      push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n      }\n      shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === void 0)\n          return null;\n        this.list[this.bottom] = void 0;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n      }\n    };\n    __name(FixedCircularBuffer, \"FixedCircularBuffer\");\n    module2.exports = /* @__PURE__ */ __name(class FixedQueue {\n      constructor() {\n        this.head = this.tail = new FixedCircularBuffer();\n      }\n      isEmpty() {\n        return this.head.isEmpty();\n      }\n      push(data) {\n        if (this.head.isFull()) {\n          this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n      }\n      shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n          this.tail = tail.next;\n        }\n        return next;\n      }\n    }, \"FixedQueue\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-stats.js\nvar require_pool_stats = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-stats.js\"(exports, module2) {\n    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();\n    var kPool = Symbol(\"pool\");\n    var PoolStats = class {\n      constructor(pool) {\n        this[kPool] = pool;\n      }\n      get connected() {\n        return this[kPool][kConnected];\n      }\n      get free() {\n        return this[kPool][kFree];\n      }\n      get pending() {\n        return this[kPool][kPending];\n      }\n      get queued() {\n        return this[kPool][kQueued];\n      }\n      get running() {\n        return this[kPool][kRunning];\n      }\n      get size() {\n        return this[kPool][kSize];\n      }\n    };\n    __name(PoolStats, \"PoolStats\");\n    module2.exports = PoolStats;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-base.js\nvar require_pool_base = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool-base.js\"(exports, module2) {\n    \"use strict\";\n    var DispatcherBase = require_dispatcher_base();\n    var FixedQueue = require_fixed_queue();\n    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();\n    var PoolStats = require_pool_stats();\n    var kClients = Symbol(\"clients\");\n    var kNeedDrain = Symbol(\"needDrain\");\n    var kQueue = Symbol(\"queue\");\n    var kClosedResolve = Symbol(\"closed resolve\");\n    var kOnDrain = Symbol(\"onDrain\");\n    var kOnConnect = Symbol(\"onConnect\");\n    var kOnDisconnect = Symbol(\"onDisconnect\");\n    var kOnConnectionError = Symbol(\"onConnectionError\");\n    var kGetDispatcher = Symbol(\"get dispatcher\");\n    var kAddClient = Symbol(\"add client\");\n    var kRemoveClient = Symbol(\"remove client\");\n    var kStats = Symbol(\"stats\");\n    var PoolBase = class extends DispatcherBase {\n      constructor() {\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = /* @__PURE__ */ __name(function onDrain(origin, targets) {\n          const queue = pool[kQueue];\n          let needDrain = false;\n          while (!needDrain) {\n            const item = queue.shift();\n            if (!item) {\n              break;\n            }\n            pool[kQueued]--;\n            needDrain = !this.dispatch(item.opts, item.handler);\n          }\n          this[kNeedDrain] = needDrain;\n          if (!this[kNeedDrain] && pool[kNeedDrain]) {\n            pool[kNeedDrain] = false;\n            pool.emit(\"drain\", origin, [pool, ...targets]);\n          }\n          if (pool[kClosedResolve] && queue.isEmpty()) {\n            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);\n          }\n        }, \"onDrain\");\n        this[kOnConnect] = (origin, targets) => {\n          pool.emit(\"connect\", origin, [pool, ...targets]);\n        };\n        this[kOnDisconnect] = (origin, targets, err) => {\n          pool.emit(\"disconnect\", origin, [pool, ...targets], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err) => {\n          pool.emit(\"connectionError\", origin, [pool, ...targets], err);\n        };\n        this[kStats] = new PoolStats(this);\n      }\n      get [kBusy]() {\n        return this[kNeedDrain];\n      }\n      get [kConnected]() {\n        return this[kClients].filter((client) => client[kConnected]).length;\n      }\n      get [kFree]() {\n        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;\n      }\n      get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]) {\n          ret += pending;\n        }\n        return ret;\n      }\n      get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]) {\n          ret += running;\n        }\n        return ret;\n      }\n      get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]) {\n          ret += size;\n        }\n        return ret;\n      }\n      get stats() {\n        return this[kStats];\n      }\n      async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n          return Promise.all(this[kClients].map((c) => c.close()));\n        } else {\n          return new Promise((resolve) => {\n            this[kClosedResolve] = resolve;\n          });\n        }\n      }\n      async [kDestroy](err) {\n        while (true) {\n          const item = this[kQueue].shift();\n          if (!item) {\n            break;\n          }\n          item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c) => c.destroy(err)));\n      }\n      [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n          this[kNeedDrain] = true;\n          this[kQueue].push({ opts, handler });\n          this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n          dispatcher[kNeedDrain] = true;\n          this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n      }\n      [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n          process.nextTick(() => {\n            if (this[kNeedDrain]) {\n              this[kOnDrain](client[kUrl], [this, client]);\n            }\n          });\n        }\n        return this;\n      }\n      [kRemoveClient](client) {\n        client.close(() => {\n          const idx = this[kClients].indexOf(client);\n          if (idx !== -1) {\n            this[kClients].splice(idx, 1);\n          }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n      }\n    };\n    __name(PoolBase, \"PoolBase\");\n    module2.exports = {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kRemoveClient,\n      kGetDispatcher\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool.js\nvar require_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/pool.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kGetDispatcher\n    } = require_pool_base();\n    var Client = require_client();\n    var {\n      InvalidArgumentError\n    } = require_errors();\n    var util2 = require_util2();\n    var { kUrl } = require_symbols();\n    var buildConnector = require_connect();\n    var kOptions = Symbol(\"options\");\n    var kConnections = Symbol(\"connections\");\n    var kFactory = Symbol(\"factory\");\n    function defaultFactory(origin, opts) {\n      return new Client(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var Pool = class extends PoolBase {\n      constructor(origin, {\n        connections,\n        factory = defaultFactory,\n        connect,\n        connectTimeout,\n        tls,\n        maxCachedSessions,\n        socketPath,\n        ...options\n      } = {}) {\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n          throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n          connect = buildConnector({\n            ...tls,\n            maxCachedSessions,\n            socketPath,\n            timeout: connectTimeout == null ? 1e4 : connectTimeout,\n            ...connect\n          });\n        }\n        this[kConnections] = connections || null;\n        this[kUrl] = util2.parseOrigin(origin);\n        this[kOptions] = { ...util2.deepClone(options), connect };\n        this[kFactory] = factory;\n      }\n      [kGetDispatcher]() {\n        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);\n        if (dispatcher) {\n          return dispatcher;\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n          dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n          this[kAddClient](dispatcher);\n        }\n        return dispatcher;\n      }\n    };\n    __name(Pool, \"Pool\");\n    module2.exports = Pool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/balanced-pool.js\nvar require_balanced_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/balanced-pool.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      BalancedPoolMissingUpstreamError,\n      InvalidArgumentError\n    } = require_errors();\n    var {\n      PoolBase,\n      kClients,\n      kNeedDrain,\n      kAddClient,\n      kRemoveClient,\n      kGetDispatcher\n    } = require_pool_base();\n    var Pool = require_pool();\n    var { kUrl } = require_symbols();\n    var { parseOrigin } = require_util2();\n    var kFactory = Symbol(\"factory\");\n    var kOptions = Symbol(\"options\");\n    var kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\n    var kCurrentWeight = Symbol(\"kCurrentWeight\");\n    var kIndex = Symbol(\"kIndex\");\n    var kWeight = Symbol(\"kWeight\");\n    var kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\n    var kErrorPenalty = Symbol(\"kErrorPenalty\");\n    function getGreatestCommonDivisor(a, b) {\n      if (b === 0)\n        return a;\n      return getGreatestCommonDivisor(b, a % b);\n    }\n    __name(getGreatestCommonDivisor, \"getGreatestCommonDivisor\");\n    function defaultFactory(origin, opts) {\n      return new Pool(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var BalancedPool = class extends PoolBase {\n      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n          upstreams = [upstreams];\n        }\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kFactory] = factory;\n        for (const upstream of upstreams) {\n          this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n      }\n      addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {\n          return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", () => {\n          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", () => {\n          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n          this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args) => {\n          const err = args[2];\n          if (err && err.code === \"UND_ERR_SOCKET\") {\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n          }\n        });\n        for (const client of this[kClients]) {\n          client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n      }\n      _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n      }\n      removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);\n        if (pool) {\n          this[kRemoveClient](pool);\n        }\n        return this;\n      }\n      get upstreams() {\n        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);\n      }\n      [kGetDispatcher]() {\n        if (this[kClients].length === 0) {\n          throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);\n        if (!dispatcher) {\n          return;\n        }\n        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);\n        if (allClientsBusy) {\n          return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);\n        while (counter++ < this[kClients].length) {\n          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n          const pool = this[kClients][this[kIndex]];\n          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n            maxWeightIndex = this[kIndex];\n          }\n          if (this[kIndex] === 0) {\n            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n            if (this[kCurrentWeight] <= 0) {\n              this[kCurrentWeight] = this[kMaxWeightPerServer];\n            }\n          }\n          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n            return pool;\n          }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n      }\n    };\n    __name(BalancedPool, \"BalancedPool\");\n    module2.exports = BalancedPool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/compat/dispatcher-weakref.js\nvar require_dispatcher_weakref = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/compat/dispatcher-weakref.js\"(exports, module2) {\n    \"use strict\";\n    var { kConnected, kSize } = require_symbols();\n    var CompatWeakRef = class {\n      constructor(value) {\n        this.value = value;\n      }\n      deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;\n      }\n    };\n    __name(CompatWeakRef, \"CompatWeakRef\");\n    var CompatFinalizer = class {\n      constructor(finalizer) {\n        this.finalizer = finalizer;\n      }\n      register(dispatcher, key) {\n        dispatcher.on(\"disconnect\", () => {\n          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n            this.finalizer(key);\n          }\n        });\n      }\n    };\n    __name(CompatFinalizer, \"CompatFinalizer\");\n    module2.exports = function() {\n      return {\n        WeakRef: global.WeakRef || CompatWeakRef,\n        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n      };\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/agent.js\nvar require_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/agent.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError } = require_errors();\n    var { kClients, kRunning, kClose, kDestroy, kDispatch } = require_symbols();\n    var DispatcherBase = require_dispatcher_base();\n    var Pool = require_pool();\n    var Client = require_client();\n    var util2 = require_util2();\n    var RedirectHandler = require_redirect();\n    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();\n    var kOnConnect = Symbol(\"onConnect\");\n    var kOnDisconnect = Symbol(\"onDisconnect\");\n    var kOnConnectionError = Symbol(\"onConnectionError\");\n    var kMaxRedirections = Symbol(\"maxRedirections\");\n    var kOnDrain = Symbol(\"onDrain\");\n    var kFactory = Symbol(\"factory\");\n    var kFinalizer = Symbol(\"finalizer\");\n    var kOptions = Symbol(\"options\");\n    function defaultFactory(origin, opts) {\n      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n    }\n    __name(defaultFactory, \"defaultFactory\");\n    var Agent = class extends DispatcherBase {\n      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n        super();\n        if (typeof factory !== \"function\") {\n          throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n          throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n          throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n          connect = { ...connect };\n        }\n        this[kOptions] = { ...util2.deepClone(options), connect };\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = /* @__PURE__ */ new Map();\n        this[kFinalizer] = new FinalizationRegistry((key) => {\n          const ref = this[kClients].get(key);\n          if (ref !== void 0 && ref.deref() === void 0) {\n            this[kClients].delete(key);\n          }\n        });\n        const agent = this;\n        this[kOnDrain] = (origin, targets) => {\n          agent.emit(\"drain\", origin, [agent, ...targets]);\n        };\n        this[kOnConnect] = (origin, targets) => {\n          agent.emit(\"connect\", origin, [agent, ...targets]);\n        };\n        this[kOnDisconnect] = (origin, targets, err) => {\n          agent.emit(\"disconnect\", origin, [agent, ...targets], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err) => {\n          agent.emit(\"connectionError\", origin, [agent, ...targets], err);\n        };\n      }\n      get [kRunning]() {\n        let ret = 0;\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            ret += client[kRunning];\n          }\n        }\n        return ret;\n      }\n      [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n          key = String(opts.origin);\n        } else {\n          throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        const ref = this[kClients].get(key);\n        let dispatcher = ref ? ref.deref() : null;\n        if (!dispatcher) {\n          dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n          this[kClients].set(key, new WeakRef2(dispatcher));\n          this[kFinalizer].register(dispatcher, key);\n        }\n        const { maxRedirections = this[kMaxRedirections] } = opts;\n        if (maxRedirections != null && maxRedirections !== 0) {\n          opts = { ...opts, maxRedirections: 0 };\n          handler = new RedirectHandler(this, maxRedirections, opts, handler);\n        }\n        return dispatcher.dispatch(opts, handler);\n      }\n      async [kClose]() {\n        const closePromises = [];\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            closePromises.push(client.close());\n          }\n        }\n        await Promise.all(closePromises);\n      }\n      async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const ref of this[kClients].values()) {\n          const client = ref.deref();\n          if (client) {\n            destroyPromises.push(client.destroy(err));\n          }\n        }\n        await Promise.all(destroyPromises);\n      }\n    };\n    __name(Agent, \"Agent\");\n    module2.exports = Agent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/readable.js\nvar require_readable = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/readable.js\"(exports, module2) {\n    \"use strict\";\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { Readable } = __webpack_require__(/*! stream */ \"stream\");\n    var { RequestAbortedError, NotSupportedError } = require_errors();\n    var util2 = require_util2();\n    var { ReadableStreamFrom, toUSVString } = require_util2();\n    var Blob;\n    var kConsume = Symbol(\"kConsume\");\n    var kReading = Symbol(\"kReading\");\n    var kBody = Symbol(\"kBody\");\n    var kAbort = Symbol(\"abort\");\n    var kContentType = Symbol(\"kContentType\");\n    module2.exports = /* @__PURE__ */ __name(class BodyReadable extends Readable {\n      constructor(resume, abort, contentType = \"\") {\n        super({\n          autoDestroy: true,\n          read: resume,\n          highWaterMark: 64 * 1024\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        this[kReading] = false;\n      }\n      destroy(err) {\n        if (this.destroyed) {\n          return this;\n        }\n        if (!err && !this._readableState.endEmitted) {\n          err = new RequestAbortedError();\n        }\n        if (err) {\n          this[kAbort]();\n        }\n        return super.destroy(err);\n      }\n      emit(ev, ...args) {\n        if (ev === \"data\") {\n          this._readableState.dataEmitted = true;\n        } else if (ev === \"error\") {\n          this._readableState.errorEmitted = true;\n        }\n        return super.emit(ev, ...args);\n      }\n      on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n          this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n      }\n      addListener(ev, ...args) {\n        return this.on(ev, ...args);\n      }\n      off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n          this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n      }\n      removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n      }\n      push(chunk) {\n        if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n          consumePush(this[kConsume], chunk);\n          return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n      }\n      async text() {\n        return consume(this, \"text\");\n      }\n      async json() {\n        return consume(this, \"json\");\n      }\n      async blob() {\n        return consume(this, \"blob\");\n      }\n      async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n      }\n      async formData() {\n        throw new NotSupportedError();\n      }\n      get bodyUsed() {\n        return util2.isDisturbed(this);\n      }\n      get body() {\n        if (!this[kBody]) {\n          this[kBody] = ReadableStreamFrom(this);\n          if (this[kConsume]) {\n            this[kBody].getReader();\n            assert(this[kBody].locked);\n          }\n        }\n        return this[kBody];\n      }\n      async dump(opts) {\n        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n        try {\n          for await (const chunk of this) {\n            limit -= Buffer.byteLength(chunk);\n            if (limit < 0) {\n              return;\n            }\n          }\n        } catch (e) {\n        }\n      }\n    }, \"BodyReadable\");\n    function isLocked(self2) {\n      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];\n    }\n    __name(isLocked, \"isLocked\");\n    function isUnusable(self2) {\n      return util2.isDisturbed(self2) || isLocked(self2);\n    }\n    __name(isUnusable, \"isUnusable\");\n    async function consume(stream2, type) {\n      if (isUnusable(stream2)) {\n        throw new TypeError(\"unusable\");\n      }\n      assert(!stream2[kConsume]);\n      return new Promise((resolve, reject) => {\n        stream2[kConsume] = {\n          type,\n          stream: stream2,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        };\n        stream2.on(\"error\", function(err) {\n          consumeFinish(this[kConsume], err);\n        }).on(\"close\", function() {\n          if (this[kConsume].body !== null) {\n            consumeFinish(this[kConsume], new RequestAbortedError());\n          }\n        });\n        process.nextTick(consumeStart, stream2[kConsume]);\n      });\n    }\n    __name(consume, \"consume\");\n    function consumeStart(consume2) {\n      if (consume2.body === null) {\n        return;\n      }\n      const { _readableState: state } = consume2.stream;\n      for (const chunk of state.buffer) {\n        consumePush(consume2, chunk);\n      }\n      if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n      } else {\n        consume2.stream.on(\"end\", function() {\n          consumeEnd(this[kConsume]);\n        });\n      }\n      consume2.stream.resume();\n      while (consume2.stream.read() != null) {\n      }\n    }\n    __name(consumeStart, \"consumeStart\");\n    function consumeEnd(consume2) {\n      const { type, body, resolve, stream: stream2, length } = consume2;\n      try {\n        if (type === \"text\") {\n          resolve(toUSVString(Buffer.concat(body)));\n        } else if (type === \"json\") {\n          resolve(JSON.parse(Buffer.concat(body)));\n        } else if (type === \"arrayBuffer\") {\n          const dst = new Uint8Array(length);\n          let pos = 0;\n          for (const buf of body) {\n            dst.set(buf, pos);\n            pos += buf.byteLength;\n          }\n          resolve(dst);\n        } else if (type === \"blob\") {\n          if (!Blob) {\n            Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob);\n          }\n          resolve(new Blob(body, { type: stream2[kContentType] }));\n        }\n        consumeFinish(consume2);\n      } catch (err) {\n        stream2.destroy(err);\n      }\n    }\n    __name(consumeEnd, \"consumeEnd\");\n    function consumePush(consume2, chunk) {\n      consume2.length += chunk.length;\n      consume2.body.push(chunk);\n    }\n    __name(consumePush, \"consumePush\");\n    function consumeFinish(consume2, err) {\n      if (consume2.body === null) {\n        return;\n      }\n      if (err) {\n        consume2.reject(err);\n      } else {\n        consume2.resolve();\n      }\n      consume2.type = null;\n      consume2.stream = null;\n      consume2.resolve = null;\n      consume2.reject = null;\n      consume2.length = 0;\n      consume2.body = null;\n    }\n    __name(consumeFinish, \"consumeFinish\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/abort-signal.js\nvar require_abort_signal = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/abort-signal.js\"(exports, module2) {\n    var { RequestAbortedError } = require_errors();\n    var kListener = Symbol(\"kListener\");\n    var kSignal = Symbol(\"kSignal\");\n    function abort(self2) {\n      if (self2.abort) {\n        self2.abort();\n      } else {\n        self2.onError(new RequestAbortedError());\n      }\n    }\n    __name(abort, \"abort\");\n    function addSignal(self2, signal) {\n      self2[kSignal] = null;\n      self2[kListener] = null;\n      if (!signal) {\n        return;\n      }\n      if (signal.aborted) {\n        abort(self2);\n        return;\n      }\n      self2[kSignal] = signal;\n      self2[kListener] = () => {\n        abort(self2);\n      };\n      if (\"addEventListener\" in self2[kSignal]) {\n        self2[kSignal].addEventListener(\"abort\", self2[kListener]);\n      } else {\n        self2[kSignal].addListener(\"abort\", self2[kListener]);\n      }\n    }\n    __name(addSignal, \"addSignal\");\n    function removeSignal(self2) {\n      if (!self2[kSignal]) {\n        return;\n      }\n      if (\"removeEventListener\" in self2[kSignal]) {\n        self2[kSignal].removeEventListener(\"abort\", self2[kListener]);\n      } else {\n        self2[kSignal].removeListener(\"abort\", self2[kListener]);\n      }\n      self2[kSignal] = null;\n      self2[kListener] = null;\n    }\n    __name(removeSignal, \"removeSignal\");\n    module2.exports = {\n      addSignal,\n      removeSignal\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-request.js\nvar require_api_request = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-request.js\"(exports, module2) {\n    \"use strict\";\n    var Readable = require_readable();\n    var {\n      InvalidArgumentError,\n      RequestAbortedError,\n      ResponseStatusCodeError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var RequestHandler2 = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n          if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n          }\n          if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n          }\n          if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n          }\n          if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n          }\n          super(\"UNDICI_REQUEST\");\n        } catch (err) {\n          if (util2.isStream(body)) {\n            util2.destroy(body.on(\"error\", util2.nop), err);\n          }\n          throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        if (util2.isStream(body)) {\n          body.on(\"error\", (err) => {\n            this.onError(err);\n          });\n        }\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers2 = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers: headers2 });\n          }\n          return;\n        }\n        const parsedHeaders = util2.parseHeaders(rawHeaders);\n        const contentType = parsedHeaders[\"content-type\"];\n        const body = new Readable(resume, abort, contentType);\n        this.callback = null;\n        this.res = body;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        if (callback !== null) {\n          if (this.throwOnError && statusCode >= 400) {\n            this.runInAsyncScope(\n              getResolveErrorBodyCallback,\n              null,\n              { callback, body, contentType, statusCode, statusMessage, headers }\n            );\n            return;\n          }\n          this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            trailers: this.trailers,\n            opaque,\n            body,\n            context: context3\n          });\n        }\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        util2.parseHeaders(trailers, this.trailers);\n        res.push(null);\n      }\n      onError(err) {\n        const { res, callback, body, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n        if (res) {\n          this.res = null;\n          queueMicrotask(() => {\n            util2.destroy(res, err);\n          });\n        }\n        if (body) {\n          this.body = null;\n          util2.destroy(body, err);\n        }\n      }\n    };\n    __name(RequestHandler2, \"RequestHandler\");\n    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n      if (statusCode === 204 || !contentType) {\n        body.dump();\n        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n        return;\n      }\n      try {\n        if (contentType.startsWith(\"application/json\")) {\n          const payload = await body.json();\n          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n          return;\n        }\n        if (contentType.startsWith(\"text/\")) {\n          const payload = await body.text();\n          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n          return;\n        }\n      } catch (err) {\n      }\n      body.dump();\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n    }\n    __name(getResolveErrorBodyCallback, \"getResolveErrorBodyCallback\");\n    function request2(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          request2.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        this.dispatch(opts, new RequestHandler2(opts, callback));\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(request2, \"request\");\n    module2.exports = request2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-stream.js\nvar require_api_stream = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-stream.js\"(exports, module2) {\n    \"use strict\";\n    var { finished } = __webpack_require__(/*! stream */ \"stream\");\n    var {\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var StreamHandler = class extends AsyncResource2 {\n      constructor(opts, factory, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;\n        try {\n          if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n          }\n          if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"invalid factory\");\n          }\n          if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n          }\n          if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n          }\n          if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n          }\n          super(\"UNDICI_STREAM\");\n        } catch (err) {\n          if (util2.isStream(body)) {\n            util2.destroy(body.on(\"error\", util2.nop), err);\n          }\n          throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        if (util2.isStream(body)) {\n          body.on(\"error\", (err) => {\n            this.onError(err);\n          });\n        }\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume) {\n        const { factory, opaque, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers2 = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers: headers2 });\n          }\n          return;\n        }\n        this.factory = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        const res = this.runInAsyncScope(factory, null, {\n          statusCode,\n          headers,\n          opaque,\n          context: context3\n        });\n        if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n          throw new InvalidReturnValueError(\"expected Writable\");\n        }\n        res.on(\"drain\", resume);\n        finished(res, { readable: false }, (err) => {\n          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;\n          this.res = null;\n          if (err || !res2.readable) {\n            util2.destroy(res2, err);\n          }\n          this.callback = null;\n          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });\n          if (err) {\n            abort();\n          }\n        });\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n        return needDrain !== true;\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.write(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        this.trailers = util2.parseHeaders(trailers);\n        res.end();\n      }\n      onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n          this.res = null;\n          util2.destroy(res, err);\n        } else if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n        if (body) {\n          this.body = null;\n          util2.destroy(body, err);\n        }\n      }\n    };\n    __name(StreamHandler, \"StreamHandler\");\n    function stream2(opts, factory, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          stream2.call(this, opts, factory, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(stream2, \"stream\");\n    module2.exports = stream2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-pipeline.js\nvar require_api_pipeline = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-pipeline.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      Readable,\n      Duplex,\n      PassThrough\n    } = __webpack_require__(/*! stream */ \"stream\");\n    var {\n      InvalidArgumentError,\n      InvalidReturnValueError,\n      RequestAbortedError\n    } = require_errors();\n    var util2 = require_util2();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var { addSignal, removeSignal } = require_abort_signal();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var kResume = Symbol(\"resume\");\n    var PipelineRequest = class extends Readable {\n      constructor() {\n        super({ autoDestroy: true });\n        this[kResume] = null;\n      }\n      _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n          this[kResume] = null;\n          resume();\n        }\n      }\n      _destroy(err, callback) {\n        this._read();\n        callback(err);\n      }\n    };\n    __name(PipelineRequest, \"PipelineRequest\");\n    var PipelineResponse = class extends Readable {\n      constructor(resume) {\n        super({ autoDestroy: true });\n        this[kResume] = resume;\n      }\n      _read() {\n        this[kResume]();\n      }\n      _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n          err = new RequestAbortedError();\n        }\n        callback(err);\n      }\n    };\n    __name(PipelineResponse, \"PipelineResponse\");\n    var PipelineHandler = class extends AsyncResource2 {\n      constructor(opts, handler) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n          throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n          throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n          throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util2.nop);\n        this.ret = new Duplex({\n          readableObjectMode: opts.objectMode,\n          autoDestroy: true,\n          read: () => {\n            const { body } = this;\n            if (body && body.resume) {\n              body.resume();\n            }\n          },\n          write: (chunk, encoding, callback) => {\n            const { req } = this;\n            if (req.push(chunk, encoding) || req._readableState.destroyed) {\n              callback();\n            } else {\n              req[kResume] = callback;\n            }\n          },\n          destroy: (err, callback) => {\n            const { body, req, res, ret, abort } = this;\n            if (!err && !ret._readableState.endEmitted) {\n              err = new RequestAbortedError();\n            }\n            if (abort && err) {\n              abort();\n            }\n            util2.destroy(body, err);\n            util2.destroy(req, err);\n            util2.destroy(res, err);\n            removeSignal(this);\n            callback(err);\n          }\n        }).on(\"prefinish\", () => {\n          const { req } = this;\n          req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        const { ret, res } = this;\n        assert(!res, \"pipeline cannot be retried\");\n        if (ret.destroyed) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context: context3 } = this;\n        if (statusCode < 200) {\n          if (this.onInfo) {\n            const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n            this.onInfo({ statusCode, headers });\n          }\n          return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n          this.handler = null;\n          const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n          body = this.runInAsyncScope(handler, null, {\n            statusCode,\n            headers,\n            opaque,\n            body: this.res,\n            context: context3\n          });\n        } catch (err) {\n          this.res.on(\"error\", util2.nop);\n          throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n          throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk) => {\n          const { ret, body: body2 } = this;\n          if (!ret.push(chunk) && body2.pause) {\n            body2.pause();\n          }\n        }).on(\"error\", (err) => {\n          const { ret } = this;\n          util2.destroy(ret, err);\n        }).on(\"end\", () => {\n          const { ret } = this;\n          ret.push(null);\n        }).on(\"close\", () => {\n          const { ret } = this;\n          if (!ret._readableState.ended) {\n            util2.destroy(ret, new RequestAbortedError());\n          }\n        });\n        this.body = body;\n      }\n      onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n      }\n      onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n      }\n      onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util2.destroy(ret, err);\n      }\n    };\n    __name(PipelineHandler, \"PipelineHandler\");\n    function pipeline(opts, handler) {\n      try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);\n        return pipelineHandler.ret;\n      } catch (err) {\n        return new PassThrough().destroy(err);\n      }\n    }\n    __name(pipeline, \"pipeline\");\n    module2.exports = pipeline;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-upgrade.js\nvar require_api_upgrade = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-upgrade.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var util2 = require_util2();\n    var { addSignal, removeSignal } = require_abort_signal();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var UpgradeHandler = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = null;\n      }\n      onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n      }\n      onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context: context3 } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n          headers,\n          socket,\n          opaque,\n          context: context3\n        });\n      }\n      onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n      }\n    };\n    __name(UpgradeHandler, \"UpgradeHandler\");\n    function upgrade(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          upgrade.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n          ...opts,\n          method: opts.method || \"GET\",\n          upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(upgrade, \"upgrade\");\n    module2.exports = upgrade;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-connect.js\nvar require_api_connect = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/api-connect.js\"(exports, module2) {\n    \"use strict\";\n    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();\n    var { AsyncResource: AsyncResource2 } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var util2 = require_util2();\n    var { addSignal, removeSignal } = require_abort_signal();\n    var ConnectHandler = class extends AsyncResource2 {\n      constructor(opts, callback) {\n        if (!opts || typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n          throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n          throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n      }\n      onConnect(abort, context3) {\n        if (!this.callback) {\n          throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context3;\n      }\n      onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n      }\n      onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context: context3 } = this;\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          socket,\n          opaque,\n          context: context3\n        });\n      }\n      onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n          this.callback = null;\n          queueMicrotask(() => {\n            this.runInAsyncScope(callback, null, err, { opaque });\n          });\n        }\n      }\n    };\n    __name(ConnectHandler, \"ConnectHandler\");\n    function connect(opts, callback) {\n      if (callback === void 0) {\n        return new Promise((resolve, reject) => {\n          connect.call(this, opts, (err, data) => {\n            return err ? reject(err) : resolve(data);\n          });\n        });\n      }\n      try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({ ...opts, method: \"CONNECT\" }, connectHandler);\n      } catch (err) {\n        if (typeof callback !== \"function\") {\n          throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(() => callback(err, { opaque }));\n      }\n    }\n    __name(connect, \"connect\");\n    module2.exports = connect;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/index.js\nvar require_api = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/api/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports.request = require_api_request();\n    module2.exports.stream = require_api_stream();\n    module2.exports.pipeline = require_api_pipeline();\n    module2.exports.upgrade = require_api_upgrade();\n    module2.exports.connect = require_api_connect();\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-errors.js\nvar require_mock_errors = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-errors.js\"(exports, module2) {\n    \"use strict\";\n    var { UndiciError } = require_errors();\n    var MockNotMatchedError = class extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n      }\n    };\n    __name(MockNotMatchedError, \"MockNotMatchedError\");\n    module2.exports = {\n      MockNotMatchedError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-symbols.js\nvar require_mock_symbols = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-symbols.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      kAgent: Symbol(\"agent\"),\n      kOptions: Symbol(\"options\"),\n      kFactory: Symbol(\"factory\"),\n      kDispatches: Symbol(\"dispatches\"),\n      kDispatchKey: Symbol(\"dispatch key\"),\n      kDefaultHeaders: Symbol(\"default headers\"),\n      kDefaultTrailers: Symbol(\"default trailers\"),\n      kContentLength: Symbol(\"content length\"),\n      kMockAgent: Symbol(\"mock agent\"),\n      kMockAgentSet: Symbol(\"mock agent set\"),\n      kMockAgentGet: Symbol(\"mock agent get\"),\n      kMockDispatch: Symbol(\"mock dispatch\"),\n      kClose: Symbol(\"close\"),\n      kOriginalClose: Symbol(\"original agent close\"),\n      kOrigin: Symbol(\"origin\"),\n      kIsMockActive: Symbol(\"is mock active\"),\n      kNetConnect: Symbol(\"net connect\"),\n      kGetNetConnect: Symbol(\"get net connect\"),\n      kConnected: Symbol(\"connected\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-utils.js\nvar require_mock_utils = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-utils.js\"(exports, module2) {\n    \"use strict\";\n    var { MockNotMatchedError } = require_mock_errors();\n    var {\n      kDispatches,\n      kMockAgent,\n      kOriginalDispatch,\n      kOrigin,\n      kGetNetConnect\n    } = require_mock_symbols();\n    var { buildURL, nop } = require_util2();\n    function matchValue(match, value) {\n      if (typeof match === \"string\") {\n        return match === value;\n      }\n      if (match instanceof RegExp) {\n        return match.test(value);\n      }\n      if (typeof match === \"function\") {\n        return match(value) === true;\n      }\n      return false;\n    }\n    __name(matchValue, \"matchValue\");\n    function lowerCaseEntries(headers) {\n      return Object.fromEntries(\n        Object.entries(headers).map(([headerName, headerValue]) => {\n          return [headerName.toLocaleLowerCase(), headerValue];\n        })\n      );\n    }\n    __name(lowerCaseEntries, \"lowerCaseEntries\");\n    function getHeaderByName(headers, key) {\n      if (Array.isArray(headers)) {\n        for (let i = 0; i < headers.length; i += 2) {\n          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n            return headers[i + 1];\n          }\n        }\n        return void 0;\n      } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n      } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n      }\n    }\n    __name(getHeaderByName, \"getHeaderByName\");\n    function buildHeadersFromArray(headers) {\n      const clone2 = headers.slice();\n      const entries = [];\n      for (let index = 0; index < clone2.length; index += 2) {\n        entries.push([clone2[index], clone2[index + 1]]);\n      }\n      return Object.fromEntries(entries);\n    }\n    __name(buildHeadersFromArray, \"buildHeadersFromArray\");\n    function matchHeaders(mockDispatch2, headers) {\n      if (typeof mockDispatch2.headers === \"function\") {\n        if (Array.isArray(headers)) {\n          headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});\n      }\n      if (typeof mockDispatch2.headers === \"undefined\") {\n        return true;\n      }\n      if (typeof headers !== \"object\" || typeof mockDispatch2.headers !== \"object\") {\n        return false;\n      }\n      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(matchHeaders, \"matchHeaders\");\n    function safeUrl(path7) {\n      if (typeof path7 !== \"string\") {\n        return path7;\n      }\n      const pathSegments = path7.split(\"?\");\n      if (pathSegments.length !== 2) {\n        return path7;\n      }\n      const qp = new URLSearchParams(pathSegments.pop());\n      qp.sort();\n      return [...pathSegments, qp.toString()].join(\"?\");\n    }\n    __name(safeUrl, \"safeUrl\");\n    function matchKey(mockDispatch2, { path: path7, method, body, headers }) {\n      const pathMatch = matchValue(mockDispatch2.path, path7);\n      const methodMatch = matchValue(mockDispatch2.method, method);\n      const bodyMatch = typeof mockDispatch2.body !== \"undefined\" ? matchValue(mockDispatch2.body, body) : true;\n      const headersMatch = matchHeaders(mockDispatch2, headers);\n      return pathMatch && methodMatch && bodyMatch && headersMatch;\n    }\n    __name(matchKey, \"matchKey\");\n    function getResponseData(data) {\n      if (Buffer.isBuffer(data)) {\n        return data;\n      } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n      } else {\n        return data.toString();\n      }\n    }\n    __name(getResponseData, \"getResponseData\");\n    function getMockDispatch(mockDispatches, key) {\n      const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n      const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path7 }) => matchValue(safeUrl(path7), resolvedPath));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n      }\n      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));\n      if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers}'`);\n      }\n      return matchedMockDispatches[0];\n    }\n    __name(getMockDispatch, \"getMockDispatch\");\n    function addMockDispatch(mockDispatches, key, data) {\n      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };\n      const replyData = typeof data === \"function\" ? { callback: data } : { ...data };\n      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };\n      mockDispatches.push(newMockDispatch);\n      return newMockDispatch;\n    }\n    __name(addMockDispatch, \"addMockDispatch\");\n    function deleteMockDispatch(mockDispatches, key) {\n      const index = mockDispatches.findIndex((dispatch) => {\n        if (!dispatch.consumed) {\n          return false;\n        }\n        return matchKey(dispatch, key);\n      });\n      if (index !== -1) {\n        mockDispatches.splice(index, 1);\n      }\n    }\n    __name(deleteMockDispatch, \"deleteMockDispatch\");\n    function buildKey(opts) {\n      const { path: path7, method, body, headers, query: query2 } = opts;\n      return {\n        path: path7,\n        method,\n        body,\n        headers,\n        query: query2\n      };\n    }\n    __name(buildKey, \"buildKey\");\n    function generateKeyValues(data) {\n      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);\n    }\n    __name(generateKeyValues, \"generateKeyValues\");\n    function getStatusText(statusCode) {\n      switch (statusCode) {\n        case 100:\n          return \"Continue\";\n        case 101:\n          return \"Switching Protocols\";\n        case 102:\n          return \"Processing\";\n        case 103:\n          return \"Early Hints\";\n        case 200:\n          return \"OK\";\n        case 201:\n          return \"Created\";\n        case 202:\n          return \"Accepted\";\n        case 203:\n          return \"Non-Authoritative Information\";\n        case 204:\n          return \"No Content\";\n        case 205:\n          return \"Reset Content\";\n        case 206:\n          return \"Partial Content\";\n        case 207:\n          return \"Multi-Status\";\n        case 208:\n          return \"Already Reported\";\n        case 226:\n          return \"IM Used\";\n        case 300:\n          return \"Multiple Choice\";\n        case 301:\n          return \"Moved Permanently\";\n        case 302:\n          return \"Found\";\n        case 303:\n          return \"See Other\";\n        case 304:\n          return \"Not Modified\";\n        case 305:\n          return \"Use Proxy\";\n        case 306:\n          return \"unused\";\n        case 307:\n          return \"Temporary Redirect\";\n        case 308:\n          return \"Permanent Redirect\";\n        case 400:\n          return \"Bad Request\";\n        case 401:\n          return \"Unauthorized\";\n        case 402:\n          return \"Payment Required\";\n        case 403:\n          return \"Forbidden\";\n        case 404:\n          return \"Not Found\";\n        case 405:\n          return \"Method Not Allowed\";\n        case 406:\n          return \"Not Acceptable\";\n        case 407:\n          return \"Proxy Authentication Required\";\n        case 408:\n          return \"Request Timeout\";\n        case 409:\n          return \"Conflict\";\n        case 410:\n          return \"Gone\";\n        case 411:\n          return \"Length Required\";\n        case 412:\n          return \"Precondition Failed\";\n        case 413:\n          return \"Payload Too Large\";\n        case 414:\n          return \"URI Too Large\";\n        case 415:\n          return \"Unsupported Media Type\";\n        case 416:\n          return \"Range Not Satisfiable\";\n        case 417:\n          return \"Expectation Failed\";\n        case 418:\n          return \"I'm a teapot\";\n        case 421:\n          return \"Misdirected Request\";\n        case 422:\n          return \"Unprocessable Entity\";\n        case 423:\n          return \"Locked\";\n        case 424:\n          return \"Failed Dependency\";\n        case 425:\n          return \"Too Early\";\n        case 426:\n          return \"Upgrade Required\";\n        case 428:\n          return \"Precondition Required\";\n        case 429:\n          return \"Too Many Requests\";\n        case 431:\n          return \"Request Header Fields Too Large\";\n        case 451:\n          return \"Unavailable For Legal Reasons\";\n        case 500:\n          return \"Internal Server Error\";\n        case 501:\n          return \"Not Implemented\";\n        case 502:\n          return \"Bad Gateway\";\n        case 503:\n          return \"Service Unavailable\";\n        case 504:\n          return \"Gateway Timeout\";\n        case 505:\n          return \"HTTP Version Not Supported\";\n        case 506:\n          return \"Variant Also Negotiates\";\n        case 507:\n          return \"Insufficient Storage\";\n        case 508:\n          return \"Loop Detected\";\n        case 510:\n          return \"Not Extended\";\n        case 511:\n          return \"Network Authentication Required\";\n        default:\n          return \"unknown\";\n      }\n    }\n    __name(getStatusText, \"getStatusText\");\n    async function getResponse(body) {\n      const buffers = [];\n      for await (const data of body) {\n        buffers.push(data);\n      }\n      return Buffer.concat(buffers).toString(\"utf8\");\n    }\n    __name(getResponse, \"getResponse\");\n    function mockDispatch(opts, handler) {\n      const key = buildKey(opts);\n      const mockDispatch2 = getMockDispatch(this[kDispatches], key);\n      mockDispatch2.timesInvoked++;\n      if (mockDispatch2.data.callback) {\n        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };\n      }\n      const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;\n      const { timesInvoked, times } = mockDispatch2;\n      mockDispatch2.consumed = !persist && timesInvoked >= times;\n      mockDispatch2.pending = timesInvoked < times;\n      if (error2 !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error2);\n        return true;\n      }\n      if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(() => {\n          handleReply(this[kDispatches]);\n        }, delay);\n      } else {\n        handleReply(this[kDispatches]);\n      }\n      function handleReply(mockDispatches) {\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const responseData = getResponseData(\n          typeof data === \"function\" ? data({ ...opts, headers: optsHeaders }) : data\n        );\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.abort = nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n      }\n      __name(handleReply, \"handleReply\");\n      function resume() {\n      }\n      __name(resume, \"resume\");\n      return true;\n    }\n    __name(mockDispatch, \"mockDispatch\");\n    function buildMockDispatch() {\n      const agent = this[kMockAgent];\n      const origin = this[kOrigin];\n      const originalDispatch = this[kOriginalDispatch];\n      return /* @__PURE__ */ __name(function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n          try {\n            mockDispatch.call(this, opts, handler);\n          } catch (error2) {\n            if (error2 instanceof MockNotMatchedError) {\n              const netConnect = agent[kGetNetConnect]();\n              if (netConnect === false) {\n                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n              }\n              if (checkNetConnect(netConnect, origin)) {\n                originalDispatch.call(this, opts, handler);\n              } else {\n                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n              }\n            } else {\n              throw error2;\n            }\n          }\n        } else {\n          originalDispatch.call(this, opts, handler);\n        }\n      }, \"dispatch\");\n    }\n    __name(buildMockDispatch, \"buildMockDispatch\");\n    function checkNetConnect(netConnect, origin) {\n      const url = new URL(origin);\n      if (netConnect === true) {\n        return true;\n      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n        return true;\n      }\n      return false;\n    }\n    __name(checkNetConnect, \"checkNetConnect\");\n    function buildMockOptions(opts) {\n      if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n      }\n    }\n    __name(buildMockOptions, \"buildMockOptions\");\n    module2.exports = {\n      getResponseData,\n      getMockDispatch,\n      addMockDispatch,\n      deleteMockDispatch,\n      buildKey,\n      generateKeyValues,\n      matchValue,\n      getResponse,\n      getStatusText,\n      mockDispatch,\n      buildMockDispatch,\n      checkNetConnect,\n      buildMockOptions,\n      getHeaderByName\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-interceptor.js\nvar require_mock_interceptor = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-interceptor.js\"(exports, module2) {\n    \"use strict\";\n    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kDispatchKey,\n      kDefaultHeaders,\n      kDefaultTrailers,\n      kContentLength,\n      kMockDispatch\n    } = require_mock_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var { buildURL } = require_util2();\n    var MockScope = class {\n      constructor(mockDispatch) {\n        this[kMockDispatch] = mockDispatch;\n      }\n      delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n          throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n      }\n      persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n      }\n      times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n          throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n      }\n    };\n    __name(MockScope, \"MockScope\");\n    var MockInterceptor = class {\n      constructor(opts, mockDispatches) {\n        if (typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n          throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n          opts.method = \"GET\";\n        }\n        if (typeof opts.path === \"string\") {\n          if (opts.query) {\n            opts.path = buildURL(opts.path, opts.query);\n          } else {\n            const parsedURL = new URL(opts.path, \"data://\");\n            opts.path = parsedURL.pathname + parsedURL.search;\n          }\n        }\n        if (typeof opts.method === \"string\") {\n          opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n      }\n      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? { \"content-length\": responseData.length } : {};\n        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };\n        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };\n        return { statusCode, data, headers, trailers };\n      }\n      validateReplyParameters(statusCode, data, responseOptions) {\n        if (typeof statusCode === \"undefined\") {\n          throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof data === \"undefined\") {\n          throw new InvalidArgumentError(\"data must be defined\");\n        }\n        if (typeof responseOptions !== \"object\") {\n          throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n      }\n      reply(replyData) {\n        if (typeof replyData === \"function\") {\n          const wrappedDefaultsCallback = /* @__PURE__ */ __name((opts) => {\n            const resolvedData = replyData(opts);\n            if (typeof resolvedData !== \"object\") {\n              throw new InvalidArgumentError(\"reply options callback must return an object\");\n            }\n            const { statusCode: statusCode2, data: data2 = \"\", responseOptions: responseOptions2 = {} } = resolvedData;\n            this.validateReplyParameters(statusCode2, data2, responseOptions2);\n            return {\n              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)\n            };\n          }, \"wrappedDefaultsCallback\");\n          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n          return new MockScope(newMockDispatch2);\n        }\n        const [statusCode, data = \"\", responseOptions = {}] = [...arguments];\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n      }\n      replyWithError(error2) {\n        if (typeof error2 === \"undefined\") {\n          throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });\n        return new MockScope(newMockDispatch);\n      }\n      defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n          throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n      }\n      defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n          throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n      }\n      replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n      }\n    };\n    __name(MockInterceptor, \"MockInterceptor\");\n    module2.exports.MockInterceptor = MockInterceptor;\n    module2.exports.MockScope = MockScope;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-client.js\nvar require_mock_client = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-client.js\"(exports, module2) {\n    \"use strict\";\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var Client = require_client();\n    var { buildMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kMockAgent,\n      kClose,\n      kOriginalClose,\n      kOrigin,\n      kOriginalDispatch,\n      kConnected\n    } = require_mock_symbols();\n    var { MockInterceptor } = require_mock_interceptor();\n    var Symbols = require_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var MockClient = class extends Client {\n      constructor(origin, opts) {\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n      }\n      get [Symbols.kConnected]() {\n        return this[kConnected];\n      }\n      intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n      }\n      async [kClose]() {\n        await promisify4(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n      }\n    };\n    __name(MockClient, \"MockClient\");\n    module2.exports = MockClient;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-pool.js\nvar require_mock_pool = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-pool.js\"(exports, module2) {\n    \"use strict\";\n    var { promisify: promisify4 } = __webpack_require__(/*! util */ \"util\");\n    var Pool = require_pool();\n    var { buildMockDispatch } = require_mock_utils();\n    var {\n      kDispatches,\n      kMockAgent,\n      kClose,\n      kOriginalClose,\n      kOrigin,\n      kOriginalDispatch,\n      kConnected\n    } = require_mock_symbols();\n    var { MockInterceptor } = require_mock_interceptor();\n    var Symbols = require_symbols();\n    var { InvalidArgumentError } = require_errors();\n    var MockPool = class extends Pool {\n      constructor(origin, opts) {\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n      }\n      get [Symbols.kConnected]() {\n        return this[kConnected];\n      }\n      intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n      }\n      async [kClose]() {\n        await promisify4(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n      }\n    };\n    __name(MockPool, \"MockPool\");\n    module2.exports = MockPool;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pluralizer.js\nvar require_pluralizer = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pluralizer.js\"(exports, module2) {\n    \"use strict\";\n    var singulars = {\n      pronoun: \"it\",\n      is: \"is\",\n      was: \"was\",\n      this: \"this\"\n    };\n    var plurals = {\n      pronoun: \"they\",\n      is: \"are\",\n      was: \"were\",\n      this: \"these\"\n    };\n    module2.exports = /* @__PURE__ */ __name(class Pluralizer {\n      constructor(singular, plural) {\n        this.singular = singular;\n        this.plural = plural;\n      }\n      pluralize(count2) {\n        const one = count2 === 1;\n        const keys2 = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return { ...keys2, count: count2, noun };\n      }\n    }, \"Pluralizer\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js\nvar require_pending_interceptors_formatter = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js\"(exports, module2) {\n    \"use strict\";\n    var { Transform } = __webpack_require__(/*! stream */ \"stream\");\n    var { Console } = __webpack_require__(/*! console */ \"console\");\n    module2.exports = /* @__PURE__ */ __name(class PendingInterceptorsFormatter {\n      constructor({ disableColors } = {}) {\n        this.transform = new Transform({\n          transform(chunk, _enc, cb) {\n            cb(null, chunk);\n          }\n        });\n        this.logger = new Console({\n          stdout: this.transform,\n          inspectOptions: {\n            colors: !disableColors && !process.env.CI\n          }\n        });\n      }\n      format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(\n          ({ method, path: path7, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n            Method: method,\n            Origin: origin,\n            Path: path7,\n            \"Status code\": statusCode,\n            Persistent: persist ? \"\\u2705\" : \"\\u274C\",\n            Invocations: timesInvoked,\n            Remaining: persist ? Infinity : times - timesInvoked\n          })\n        );\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n      }\n    }, \"PendingInterceptorsFormatter\");\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-agent.js\nvar require_mock_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/mock/mock-agent.js\"(exports, module2) {\n    \"use strict\";\n    var { kClients } = require_symbols();\n    var Agent = require_agent();\n    var {\n      kAgent,\n      kMockAgentSet,\n      kMockAgentGet,\n      kDispatches,\n      kIsMockActive,\n      kNetConnect,\n      kGetNetConnect,\n      kOptions,\n      kFactory\n    } = require_mock_symbols();\n    var MockClient = require_mock_client();\n    var MockPool = require_mock_pool();\n    var { matchValue, buildMockOptions } = require_mock_utils();\n    var { InvalidArgumentError, UndiciError } = require_errors();\n    var Dispatcher = require_dispatcher();\n    var Pluralizer = require_pluralizer();\n    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();\n    var FakeWeakRef = class {\n      constructor(value) {\n        this.value = value;\n      }\n      deref() {\n        return this.value;\n      }\n    };\n    __name(FakeWeakRef, \"FakeWeakRef\");\n    var MockAgent = class extends Dispatcher {\n      constructor(opts) {\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        if (opts && opts.agent && typeof opts.agent.dispatch !== \"function\") {\n          throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n      }\n      get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n          dispatcher = this[kFactory](origin);\n          this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n      }\n      dispatch(opts, handler) {\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n      }\n      async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n      }\n      deactivate() {\n        this[kIsMockActive] = false;\n      }\n      activate() {\n        this[kIsMockActive] = true;\n      }\n      enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n          if (Array.isArray(this[kNetConnect])) {\n            this[kNetConnect].push(matcher);\n          } else {\n            this[kNetConnect] = [matcher];\n          }\n        } else if (typeof matcher === \"undefined\") {\n          this[kNetConnect] = true;\n        } else {\n          throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n      }\n      disableNetConnect() {\n        this[kNetConnect] = false;\n      }\n      get isMockActive() {\n        return this[kIsMockActive];\n      }\n      [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, new FakeWeakRef(dispatcher));\n      }\n      [kFactory](origin) {\n        const mockOptions = Object.assign({ agent: this }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n      }\n      [kMockAgentGet](origin) {\n        const ref = this[kClients].get(origin);\n        if (ref) {\n          return ref.deref();\n        }\n        if (typeof origin !== \"string\") {\n          const dispatcher = this[kFactory](\"http://localhost:9999\");\n          this[kMockAgentSet](origin, dispatcher);\n          return dispatcher;\n        }\n        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n          const nonExplicitDispatcher = nonExplicitRef.deref();\n          if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n            const dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n            return dispatcher;\n          }\n        }\n      }\n      [kGetNetConnect]() {\n        return this[kNetConnect];\n      }\n      pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);\n      }\n      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n          return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n      }\n    };\n    __name(MockAgent, \"MockAgent\");\n    module2.exports = MockAgent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/proxy-agent.js\nvar require_proxy_agent = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/proxy-agent.js\"(exports, module2) {\n    \"use strict\";\n    var { kClose, kDestroy } = require_symbols();\n    var Client = require_agent();\n    var Agent = require_agent();\n    var DispatcherBase = require_dispatcher_base();\n    var { InvalidArgumentError, RequestAbortedError } = require_errors();\n    var buildConnector = require_connect();\n    var kAgent = Symbol(\"proxy agent\");\n    var kClient = Symbol(\"proxy client\");\n    var kProxyHeaders = Symbol(\"proxy headers\");\n    var kRequestTls = Symbol(\"request tls settings\");\n    var kProxyTls = Symbol(\"proxy tls settings\");\n    var kConnectEndpoint = Symbol(\"connect endpoint function\");\n    function defaultProtocolPort(protocol) {\n      return protocol === \"https:\" ? 443 : 80;\n    }\n    __name(defaultProtocolPort, \"defaultProtocolPort\");\n    var ProxyAgent = class extends DispatcherBase {\n      constructor(opts) {\n        super(opts);\n        if (typeof opts === \"string\") {\n          opts = { uri: opts };\n        }\n        if (!opts || !opts.uri) {\n          throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n        }\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = {};\n        if (opts.auth) {\n          this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        }\n        const { origin, port } = new URL(opts.uri);\n        const connect = buildConnector({ ...opts.proxyTls });\n        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });\n        this[kClient] = new Client({ origin: opts.origin, connect });\n        this[kAgent] = new Agent({\n          ...opts,\n          connect: async (opts2, callback) => {\n            let requestedHost = opts2.host;\n            if (!opts2.port) {\n              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;\n            }\n            try {\n              const { socket, statusCode } = await this[kClient].connect({\n                origin,\n                port,\n                path: requestedHost,\n                signal: opts2.signal,\n                headers: {\n                  ...this[kProxyHeaders],\n                  host: opts2.host\n                }\n              });\n              if (statusCode !== 200) {\n                socket.on(\"error\", () => {\n                }).destroy();\n                callback(new RequestAbortedError(\"Proxy response !== 200 when HTTP Tunneling\"));\n              }\n              if (opts2.protocol !== \"https:\") {\n                callback(null, socket);\n                return;\n              }\n              let servername;\n              if (this[kRequestTls]) {\n                servername = this[kRequestTls].servername;\n              } else {\n                servername = opts2.servername;\n              }\n              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        });\n      }\n      dispatch(opts, handler) {\n        const { host } = new URL(opts.origin);\n        const headers = buildHeaders2(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        return this[kAgent].dispatch(\n          {\n            ...opts,\n            headers: {\n              ...headers,\n              host\n            }\n          },\n          handler\n        );\n      }\n      async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n      }\n      async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n      }\n    };\n    __name(ProxyAgent, \"ProxyAgent\");\n    function buildHeaders2(headers) {\n      if (Array.isArray(headers)) {\n        const headersPair = {};\n        for (let i = 0; i < headers.length; i += 2) {\n          headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n      }\n      return headers;\n    }\n    __name(buildHeaders2, \"buildHeaders\");\n    function throwIfProxyAuthIsSent(headers) {\n      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === \"proxy-authorization\");\n      if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n      }\n    }\n    __name(throwIfProxyAuthIsSent, \"throwIfProxyAuthIsSent\");\n    module2.exports = ProxyAgent;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/global.js\nvar require_global = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/global.js\"(exports, module2) {\n    \"use strict\";\n    var globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\n    var { InvalidArgumentError } = require_errors();\n    var Agent = require_agent();\n    if (getGlobalDispatcher() === void 0) {\n      setGlobalDispatcher(new Agent());\n    }\n    function setGlobalDispatcher(agent) {\n      if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n      }\n      Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n      });\n    }\n    __name(setGlobalDispatcher, \"setGlobalDispatcher\");\n    function getGlobalDispatcher() {\n      return globalThis[globalDispatcher];\n    }\n    __name(getGlobalDispatcher, \"getGlobalDispatcher\");\n    module2.exports = {\n      setGlobalDispatcher,\n      getGlobalDispatcher\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/headers.js\nvar require_headers = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/headers.js\"(exports, module2) {\n    \"use strict\";\n    var { kHeadersList } = require_symbols();\n    var { kGuard } = require_symbols2();\n    var { kEnumerableProperty } = require_util2();\n    var {\n      makeIterator,\n      isValidHeaderName,\n      isValidHeaderValue\n    } = require_util3();\n    var { webidl } = require_webidl();\n    var kHeadersMap = Symbol(\"headers map\");\n    var kHeadersSortedMap = Symbol(\"headers map sorted\");\n    function headerValueNormalize(potentialValue) {\n      return potentialValue.replace(\n        /^[\\r\\n\\t ]+|[\\r\\n\\t ]+$/g,\n        \"\"\n      );\n    }\n    __name(headerValueNormalize, \"headerValueNormalize\");\n    function fill(headers, object) {\n      if (Array.isArray(object)) {\n        for (const header of object) {\n          if (header.length !== 2) {\n            webidl.errors.exception({\n              header: \"Headers constructor\",\n              message: `expected name/value pair to be length 2, found ${header.length}.`\n            });\n          }\n          headers.append(header[0], header[1]);\n        }\n      } else if (typeof object === \"object\" && object !== null) {\n        for (const [key, value] of Object.entries(object)) {\n          headers.append(key, value);\n        }\n      } else {\n        webidl.errors.conversionFailed({\n          prefix: \"Headers constructor\",\n          argument: \"Argument 1\",\n          types: [\"sequence<sequence<ByteString>>\", \"record<ByteString, ByteString>\"]\n        });\n      }\n    }\n    __name(fill, \"fill\");\n    var HeadersList = class {\n      constructor(init) {\n        if (init instanceof HeadersList) {\n          this[kHeadersMap] = new Map(init[kHeadersMap]);\n          this[kHeadersSortedMap] = init[kHeadersSortedMap];\n        } else {\n          this[kHeadersMap] = new Map(init);\n          this[kHeadersSortedMap] = null;\n        }\n      }\n      contains(name) {\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n      }\n      clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n      }\n      append(name, value) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        const exists4 = this[kHeadersMap].get(name);\n        if (exists4) {\n          this[kHeadersMap].set(name, `${exists4}, ${value}`);\n        } else {\n          this[kHeadersMap].set(name, `${value}`);\n        }\n      }\n      set(name, value) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        return this[kHeadersMap].set(name, value);\n      }\n      delete(name) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        return this[kHeadersMap].delete(name);\n      }\n      get(name) {\n        var _a3;\n        name = name.toLowerCase();\n        if (!this.contains(name)) {\n          return null;\n        }\n        return (_a3 = this[kHeadersMap].get(name)) != null ? _a3 : null;\n      }\n      has(name) {\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n      }\n      keys() {\n        return this[kHeadersMap].keys();\n      }\n      values() {\n        return this[kHeadersMap].values();\n      }\n      entries() {\n        return this[kHeadersMap].entries();\n      }\n      [Symbol.iterator]() {\n        return this[kHeadersMap][Symbol.iterator]();\n      }\n    };\n    __name(HeadersList, \"HeadersList\");\n    var Headers = class {\n      constructor(init = void 0) {\n        this[kHeadersList] = new HeadersList();\n        this[kGuard] = \"none\";\n        if (init !== void 0) {\n          init = webidl.converters.HeadersInit(init);\n          fill(this, init);\n        }\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      append(name, value) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        value = headerValueNormalize(value);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value: name,\n            type: \"header name\"\n          });\n        } else if (!isValidHeaderValue(value)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value,\n            type: \"header value\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        return this[kHeadersList].append(name, value);\n      }\n      delete(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.delete\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        if (!this[kHeadersList].contains(name)) {\n          return;\n        }\n        return this[kHeadersList].delete(name);\n      }\n      get(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.get\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        return this[kHeadersList].get(name);\n      }\n      has(name) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.has\",\n            value: name,\n            type: \"header name\"\n          });\n        }\n        return this[kHeadersList].contains(name);\n      }\n      set(name, value) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\n            `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`\n          );\n        }\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        value = headerValueNormalize(value);\n        if (!isValidHeaderName(name)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.set\",\n            value: name,\n            type: \"header name\"\n          });\n        } else if (!isValidHeaderValue(value)) {\n          webidl.errors.invalidArgument({\n            prefix: \"Headers.set\",\n            value,\n            type: \"header value\"\n          });\n        }\n        if (this[kGuard] === \"immutable\") {\n          throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        }\n        return this[kHeadersList].set(name, value);\n      }\n      get [kHeadersSortedMap]() {\n        var _a3, _b2;\n        (_b2 = (_a3 = this[kHeadersList])[kHeadersSortedMap]) != null ? _b2 : _a3[kHeadersSortedMap] = new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1));\n        return this[kHeadersList][kHeadersSortedMap];\n      }\n      keys() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].keys(), \"Headers\");\n      }\n      values() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].values(), \"Headers\");\n      }\n      entries() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return makeIterator(this[kHeadersSortedMap].entries(), \"Headers\");\n      }\n      forEach(callbackFn, thisArg = globalThis) {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        if (typeof callbackFn !== \"function\") {\n          throw new TypeError(\n            \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n          );\n        }\n        for (const [key, value] of this) {\n          callbackFn.apply(thisArg, [value, key, this]);\n        }\n      }\n      [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        if (!(this instanceof Headers)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeadersList];\n      }\n    };\n    __name(Headers, \"Headers\");\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n    Object.defineProperties(Headers.prototype, {\n      append: kEnumerableProperty,\n      delete: kEnumerableProperty,\n      get: kEnumerableProperty,\n      has: kEnumerableProperty,\n      set: kEnumerableProperty,\n      keys: kEnumerableProperty,\n      values: kEnumerableProperty,\n      entries: kEnumerableProperty,\n      forEach: kEnumerableProperty\n    });\n    webidl.converters.HeadersInit = function(V) {\n      if (webidl.util.Type(V) === \"Object\") {\n        if (V[Symbol.iterator]) {\n          return webidl.converters[\"sequence<sequence<ByteString>>\"](V);\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V);\n      }\n      webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\"sequence<sequence<ByteString>>\", \"record<ByteString, ByteString>\"]\n      });\n    };\n    module2.exports = {\n      fill,\n      Headers,\n      HeadersList\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/response.js\nvar require_response = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/response.js\"(exports, module2) {\n    \"use strict\";\n    var { Headers, HeadersList, fill } = require_headers();\n    var { extractBody, cloneBody, mixinBody } = require_body();\n    var util2 = require_util2();\n    var { kEnumerableProperty } = util2;\n    var {\n      responseURL,\n      isValidReasonPhrase,\n      isCancelled,\n      isAborted,\n      isBlobLike,\n      serializeJavascriptValueToJSONString,\n      isErrorLike\n    } = require_util3();\n    var {\n      redirectStatus,\n      nullBodyStatus,\n      DOMException\n    } = require_constants();\n    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { FormData } = require_formdata();\n    var { kHeadersList } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { types } = __webpack_require__(/*! util */ \"util\");\n    var ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    var Response = class {\n      static error() {\n        const relevantRealm = { settingsObject: {} };\n        const responseObject = new Response();\n        responseObject[kState] = makeNetworkError();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        return responseObject;\n      }\n      static json(data, init = {}) {\n        if (arguments.length === 0) {\n          throw new TypeError(\n            \"Failed to execute 'json' on 'Response': 1 argument required, but 0 present.\"\n          );\n        }\n        if (init !== null) {\n          init = webidl.converters.ResponseInit(init);\n        }\n        const bytes = new TextEncoder(\"utf-8\").encode(\n          serializeJavascriptValueToJSONString(data)\n        );\n        const body = extractBody(bytes);\n        const relevantRealm = { settingsObject: {} };\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"response\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        initializeResponse(responseObject, init, { body: body[0], type: \"application/json\" });\n        return responseObject;\n      }\n      static redirect(url, status = 302) {\n        const relevantRealm = { settingsObject: {} };\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        let parsedURL;\n        try {\n          parsedURL = new URL(url);\n        } catch (err) {\n          throw Object.assign(new TypeError(\"Failed to parse URL from \" + url), {\n            cause: err\n          });\n        }\n        if (!redirectStatus.includes(status)) {\n          throw new RangeError(\"Invalid status code\");\n        }\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        responseObject[kState].status = status;\n        const value = parsedURL.toString();\n        responseObject[kState].headersList.append(\"location\", value);\n        return responseObject;\n      }\n      constructor(body = null, init = {}) {\n        if (body !== null) {\n          body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        this[kRealm] = { settingsObject: {} };\n        this[kState] = makeResponse({});\n        this[kHeaders] = new Headers();\n        this[kHeaders][kGuard] = \"response\";\n        this[kHeaders][kHeadersList] = this[kState].headersList;\n        this[kHeaders][kRealm] = this[kRealm];\n        let bodyWithType = null;\n        if (body != null) {\n          const [extractedBody, type] = extractBody(body);\n          bodyWithType = { body: extractedBody, type };\n        }\n        initializeResponse(this, init, bodyWithType);\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      get type() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].type;\n      }\n      get url() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        let url = responseURL(this[kState]);\n        if (url == null) {\n          return \"\";\n        }\n        if (url.hash) {\n          url = new URL(url);\n          url.hash = \"\";\n        }\n        return url.toString();\n      }\n      get redirected() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].urlList.length > 1;\n      }\n      get status() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].status;\n      }\n      get ok() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].status >= 200 && this[kState].status <= 299;\n      }\n      get statusText() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].statusText;\n      }\n      get headers() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeaders];\n      }\n      clone() {\n        if (!(this instanceof Response)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this.bodyUsed || this.body && this.body.locked) {\n          webidl.errors.exception({\n            header: \"Response.clone\",\n            message: \"Body has already been consumed.\"\n          });\n        }\n        const clonedResponse = cloneResponse(this[kState]);\n        const clonedResponseObject = new Response();\n        clonedResponseObject[kState] = clonedResponse;\n        clonedResponseObject[kRealm] = this[kRealm];\n        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        return clonedResponseObject;\n      }\n    };\n    __name(Response, \"Response\");\n    mixinBody(Response);\n    Object.defineProperties(Response.prototype, {\n      type: kEnumerableProperty,\n      url: kEnumerableProperty,\n      status: kEnumerableProperty,\n      ok: kEnumerableProperty,\n      redirected: kEnumerableProperty,\n      statusText: kEnumerableProperty,\n      headers: kEnumerableProperty,\n      clone: kEnumerableProperty\n    });\n    function cloneResponse(response) {\n      if (response.internalResponse) {\n        return filterResponse(\n          cloneResponse(response.internalResponse),\n          response.type\n        );\n      }\n      const newResponse = makeResponse({ ...response, body: null });\n      if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n      }\n      return newResponse;\n    }\n    __name(cloneResponse, \"cloneResponse\");\n    function makeResponse(init) {\n      return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n        urlList: init.urlList ? [...init.urlList] : []\n      };\n    }\n    __name(makeResponse, \"makeResponse\");\n    function makeNetworkError(reason) {\n      const isError2 = isErrorLike(reason);\n      return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError2 ? reason : new Error(reason ? String(reason) : reason, {\n          cause: isError2 ? reason : void 0\n        }),\n        aborted: reason && reason.name === \"AbortError\"\n      });\n    }\n    __name(makeNetworkError, \"makeNetworkError\");\n    function makeFilteredResponse(response, state) {\n      state = {\n        internalResponse: response,\n        ...state\n      };\n      return new Proxy(response, {\n        get(target, p) {\n          return p in state ? state[p] : target[p];\n        },\n        set(target, p, value) {\n          assert(!(p in state));\n          target[p] = value;\n          return true;\n        }\n      });\n    }\n    __name(makeFilteredResponse, \"makeFilteredResponse\");\n    function filterResponse(response, type) {\n      if (type === \"basic\") {\n        return makeFilteredResponse(response, {\n          type: \"basic\",\n          headersList: response.headersList\n        });\n      } else if (type === \"cors\") {\n        return makeFilteredResponse(response, {\n          type: \"cors\",\n          headersList: response.headersList\n        });\n      } else if (type === \"opaque\") {\n        return makeFilteredResponse(response, {\n          type: \"opaque\",\n          urlList: Object.freeze([]),\n          status: 0,\n          statusText: \"\",\n          body: null\n        });\n      } else if (type === \"opaqueredirect\") {\n        return makeFilteredResponse(response, {\n          type: \"opaqueredirect\",\n          status: 0,\n          statusText: \"\",\n          headersList: [],\n          body: null\n        });\n      } else {\n        assert(false);\n      }\n    }\n    __name(filterResponse, \"filterResponse\");\n    function makeAppropriateNetworkError(fetchParams) {\n      assert(isCancelled(fetchParams));\n      return isAborted(fetchParams) ? makeNetworkError(new DOMException(\"The operation was aborted.\", \"AbortError\")) : makeNetworkError(fetchParams.controller.terminated.reason);\n    }\n    __name(makeAppropriateNetworkError, \"makeAppropriateNetworkError\");\n    function initializeResponse(response, init, body) {\n      if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n      }\n      if (\"statusText\" in init && init.statusText != null) {\n        if (!isValidReasonPhrase(String(init.statusText))) {\n          throw new TypeError(\"Invalid statusText\");\n        }\n      }\n      if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n      }\n      if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n      }\n      if (\"headers\" in init && init.headers != null) {\n        fill(response[kState].headersList, init.headers);\n      }\n      if (body) {\n        if (nullBodyStatus.includes(response.status)) {\n          webidl.errors.exception({\n            header: \"Response constructor\",\n            message: \"Invalid response status code.\"\n          });\n        }\n        response[kState].body = body.body;\n        if (body.type != null && !response[kState].headersList.has(\"Content-Type\")) {\n          response[kState].headersList.append(\"content-type\", body.type);\n        }\n      }\n    }\n    __name(initializeResponse, \"initializeResponse\");\n    webidl.converters.ReadableStream = webidl.interfaceConverter(\n      ReadableStream\n    );\n    webidl.converters.FormData = webidl.interfaceConverter(\n      FormData\n    );\n    webidl.converters.URLSearchParams = webidl.interfaceConverter(\n      URLSearchParams\n    );\n    webidl.converters.XMLHttpRequestBodyInit = function(V) {\n      if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n      }\n      if (isBlobLike(V)) {\n        return webidl.converters.Blob(V);\n      }\n      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n        return webidl.converters.BufferSource(V);\n      }\n      if (V instanceof FormData) {\n        return webidl.converters.FormData(V);\n      }\n      if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V);\n      }\n      return webidl.converters.DOMString(V);\n    };\n    webidl.converters.BodyInit = function(V) {\n      if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V);\n      }\n      if (V == null ? void 0 : V[Symbol.asyncIterator]) {\n        return V;\n      }\n      return webidl.converters.XMLHttpRequestBodyInit(V);\n    };\n    webidl.converters.ResponseInit = webidl.dictionaryConverter([\n      {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 200\n      },\n      {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: \"\"\n      },\n      {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n      }\n    ]);\n    module2.exports = {\n      makeNetworkError,\n      makeResponse,\n      makeAppropriateNetworkError,\n      filterResponse,\n      Response\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/request.js\nvar require_request2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/request.js\"(exports, module2) {\n    \"use strict\";\n    var { extractBody, mixinBody, cloneBody } = require_body();\n    var { Headers, fill: fillHeaders, HeadersList } = require_headers();\n    var { FinalizationRegistry } = require_dispatcher_weakref()();\n    var util2 = require_util2();\n    var {\n      isValidHTTPToken,\n      sameOrigin,\n      normalizeMethod\n    } = require_util3();\n    var {\n      forbiddenMethods,\n      corsSafeListedMethods,\n      referrerPolicy,\n      requestRedirect,\n      requestMode,\n      requestCredentials,\n      requestCache\n    } = require_constants();\n    var { kEnumerableProperty } = util2;\n    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();\n    var { webidl } = require_webidl();\n    var { kHeadersList } = require_symbols();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var TransformStream;\n    var kInit = Symbol(\"init\");\n    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n      signal.removeEventListener(\"abort\", abort);\n    });\n    var Request = class {\n      constructor(input, init = {}) {\n        var _a3, _b2;\n        if (input === kInit) {\n          return;\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n            `Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`\n          );\n        }\n        input = webidl.converters.RequestInfo(input);\n        init = webidl.converters.RequestInit(init);\n        this[kRealm] = { settingsObject: {} };\n        let request2 = null;\n        let fallbackMode = null;\n        const baseUrl = this[kRealm].settingsObject.baseUrl;\n        let signal = null;\n        if (typeof input === \"string\") {\n          let parsedURL;\n          try {\n            parsedURL = new URL(input, baseUrl);\n          } catch (err) {\n            throw new TypeError(\"Failed to parse URL from \" + input, { cause: err });\n          }\n          if (parsedURL.username || parsedURL.password) {\n            throw new TypeError(\n              \"Request cannot be constructed from a URL that includes credentials: \" + input\n            );\n          }\n          request2 = makeRequest({ urlList: [parsedURL] });\n          fallbackMode = \"cors\";\n        } else {\n          assert(input instanceof Request);\n          request2 = input[kState];\n          signal = input[kSignal];\n        }\n        const origin = this[kRealm].settingsObject.origin;\n        let window2 = \"client\";\n        if (((_b2 = (_a3 = request2.window) == null ? void 0 : _a3.constructor) == null ? void 0 : _b2.name) === \"EnvironmentSettingsObject\" && sameOrigin(request2.window, origin)) {\n          window2 = request2.window;\n        }\n        if (init.window !== void 0 && init.window != null) {\n          throw new TypeError(`'window' option '${window2}' must be null`);\n        }\n        if (init.window !== void 0) {\n          window2 = \"no-window\";\n        }\n        request2 = makeRequest({\n          method: request2.method,\n          headersList: request2.headersList,\n          unsafeRequest: request2.unsafeRequest,\n          client: this[kRealm].settingsObject,\n          window: window2,\n          priority: request2.priority,\n          origin: request2.origin,\n          referrer: request2.referrer,\n          referrerPolicy: request2.referrerPolicy,\n          mode: request2.mode,\n          credentials: request2.credentials,\n          cache: request2.cache,\n          redirect: request2.redirect,\n          integrity: request2.integrity,\n          keepalive: request2.keepalive,\n          reloadNavigation: request2.reloadNavigation,\n          historyNavigation: request2.historyNavigation,\n          urlList: [...request2.urlList]\n        });\n        if (Object.keys(init).length > 0) {\n          if (request2.mode === \"navigate\") {\n            request2.mode = \"same-origin\";\n          }\n          request2.reloadNavigation = false;\n          request2.historyNavigation = false;\n          request2.origin = \"client\";\n          request2.referrer = \"client\";\n          request2.referrerPolicy = \"\";\n          request2.url = request2.urlList[request2.urlList.length - 1];\n          request2.urlList = [request2.url];\n        }\n        if (init.referrer !== void 0) {\n          const referrer = init.referrer;\n          if (referrer === \"\") {\n            request2.referrer = \"no-referrer\";\n          } else {\n            let parsedReferrer;\n            try {\n              parsedReferrer = new URL(referrer, baseUrl);\n            } catch (err) {\n              throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err });\n            }\n            request2.referrer = parsedReferrer;\n          }\n        }\n        if (init.referrerPolicy !== void 0) {\n          request2.referrerPolicy = init.referrerPolicy;\n          if (!referrerPolicy.includes(request2.referrerPolicy)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n            );\n          }\n        }\n        let mode;\n        if (init.mode !== void 0) {\n          mode = init.mode;\n          if (!requestMode.includes(mode)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.mode}' is not a valid enum value of type RequestMode.`\n            );\n          }\n        } else {\n          mode = fallbackMode;\n        }\n        if (mode === \"navigate\") {\n          webidl.errors.exception({\n            header: \"Request constructor\",\n            message: \"invalid request mode navigate.\"\n          });\n        }\n        if (mode != null) {\n          request2.mode = mode;\n        }\n        if (init.credentials !== void 0) {\n          request2.credentials = init.credentials;\n          if (!requestCredentials.includes(request2.credentials)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.credentials}' is not a valid enum value of type RequestCredentials.`\n            );\n          }\n        }\n        if (init.cache !== void 0) {\n          request2.cache = init.cache;\n          if (!requestCache.includes(request2.cache)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.cache}' is not a valid enum value of type RequestCache.`\n            );\n          }\n        }\n        if (request2.cache === \"only-if-cached\" && request2.mode !== \"same-origin\") {\n          throw new TypeError(\n            \"'only-if-cached' can be set only with 'same-origin' mode\"\n          );\n        }\n        if (init.redirect !== void 0) {\n          request2.redirect = init.redirect;\n          if (!requestRedirect.includes(request2.redirect)) {\n            throw new TypeError(\n              `Failed to construct 'Request': The provided value '${request2.redirect}' is not a valid enum value of type RequestRedirect.`\n            );\n          }\n        }\n        if (init.integrity !== void 0 && init.integrity != null) {\n          request2.integrity = String(init.integrity);\n        }\n        if (init.keepalive !== void 0) {\n          request2.keepalive = Boolean(init.keepalive);\n        }\n        if (init.method !== void 0) {\n          let method = init.method;\n          if (!isValidHTTPToken(init.method)) {\n            throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n          }\n          if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n            throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n          }\n          method = normalizeMethod(init.method);\n          request2.method = method;\n        }\n        if (init.signal !== void 0) {\n          signal = init.signal;\n        }\n        this[kState] = request2;\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        this[kSignal][kRealm] = this[kRealm];\n        if (signal != null) {\n          if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n            throw new TypeError(\n              \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n            );\n          }\n          if (signal.aborted) {\n            ac.abort(signal.reason);\n          } else {\n            const abort = /* @__PURE__ */ __name(() => ac.abort(signal.reason), \"abort\");\n            signal.addEventListener(\"abort\", abort, { once: true });\n            requestFinalizer.register(this, { signal, abort });\n          }\n        }\n        this[kHeaders] = new Headers();\n        this[kHeaders][kHeadersList] = request2.headersList;\n        this[kHeaders][kGuard] = \"request\";\n        this[kHeaders][kRealm] = this[kRealm];\n        if (mode === \"no-cors\") {\n          if (!corsSafeListedMethods.includes(request2.method)) {\n            throw new TypeError(\n              `'${request2.method} is unsupported in no-cors mode.`\n            );\n          }\n          this[kHeaders][kGuard] = \"request-no-cors\";\n        }\n        if (Object.keys(init).length !== 0) {\n          let headers = new Headers(this[kHeaders]);\n          if (init.headers !== void 0) {\n            headers = init.headers;\n          }\n          this[kHeaders][kHeadersList].clear();\n          if (headers.constructor.name === \"Headers\") {\n            for (const [key, val] of headers) {\n              this[kHeaders].append(key, val);\n            }\n          } else {\n            fillHeaders(this[kHeaders], headers);\n          }\n        }\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        if ((init.body !== void 0 && init.body != null || inputBody != null) && (request2.method === \"GET\" || request2.method === \"HEAD\")) {\n          throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        let initBody = null;\n        if (init.body !== void 0 && init.body != null) {\n          const [extractedBody, contentType] = extractBody(\n            init.body,\n            request2.keepalive\n          );\n          initBody = extractedBody;\n          if (contentType && !this[kHeaders].has(\"content-type\")) {\n            this[kHeaders].append(\"content-type\", contentType);\n          }\n        }\n        const inputOrInitBody = initBody != null ? initBody : inputBody;\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n          if (request2.mode !== \"same-origin\" && request2.mode !== \"cors\") {\n            throw new TypeError(\n              'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n            );\n          }\n          request2.useCORSPreflightFlag = true;\n        }\n        let finalBody = inputOrInitBody;\n        if (initBody == null && inputBody != null) {\n          if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n            throw new TypeError(\n              \"Cannot construct a Request with a Request object that has already been used.\"\n            );\n          }\n          if (!TransformStream) {\n            TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream);\n          }\n          const identityTransform = new TransformStream();\n          inputBody.stream.pipeThrough(identityTransform);\n          finalBody = {\n            source: inputBody.source,\n            length: inputBody.length,\n            stream: identityTransform.readable\n          };\n        }\n        this[kState].body = finalBody;\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      get method() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].method;\n      }\n      get url() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].url.toString();\n      }\n      get headers() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kHeaders];\n      }\n      get destination() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].destination;\n      }\n      get referrer() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this[kState].referrer === \"no-referrer\") {\n          return \"\";\n        }\n        if (this[kState].referrer === \"client\") {\n          return \"about:client\";\n        }\n        return this[kState].referrer.toString();\n      }\n      get referrerPolicy() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].referrerPolicy;\n      }\n      get mode() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].mode;\n      }\n      get credentials() {\n        return this[kState].credentials;\n      }\n      get cache() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].cache;\n      }\n      get redirect() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].redirect;\n      }\n      get integrity() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].integrity;\n      }\n      get keepalive() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].keepalive;\n      }\n      get isReloadNavigation() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].reloadNavigation;\n      }\n      get isHistoryNavigation() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kState].historyNavigation;\n      }\n      get signal() {\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[kSignal];\n      }\n      clone() {\n        var _a3;\n        if (!(this instanceof Request)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (this.bodyUsed || ((_a3 = this.body) == null ? void 0 : _a3.locked)) {\n          throw new TypeError(\"unusable\");\n        }\n        const clonedRequest = cloneRequest(this[kState]);\n        const clonedRequestObject = new Request(kInit);\n        clonedRequestObject[kState] = clonedRequest;\n        clonedRequestObject[kRealm] = this[kRealm];\n        clonedRequestObject[kHeaders] = new Headers();\n        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n          ac.abort(this.signal.reason);\n        } else {\n          this.signal.addEventListener(\n            \"abort\",\n            () => {\n              ac.abort(this.signal.reason);\n            },\n            { once: true }\n          );\n        }\n        clonedRequestObject[kSignal] = ac.signal;\n        return clonedRequestObject;\n      }\n    };\n    __name(Request, \"Request\");\n    mixinBody(Request);\n    function makeRequest(init) {\n      const request2 = {\n        method: \"GET\",\n        localURLsOnly: false,\n        unsafeRequest: false,\n        body: null,\n        client: null,\n        reservedClient: null,\n        replacesClientId: \"\",\n        window: \"client\",\n        keepalive: false,\n        serviceWorkers: \"all\",\n        initiator: \"\",\n        destination: \"\",\n        priority: null,\n        origin: \"client\",\n        policyContainer: \"client\",\n        referrer: \"client\",\n        referrerPolicy: \"\",\n        mode: \"no-cors\",\n        useCORSPreflightFlag: false,\n        credentials: \"same-origin\",\n        useCredentials: false,\n        cache: \"default\",\n        redirect: \"follow\",\n        integrity: \"\",\n        cryptoGraphicsNonceMetadata: \"\",\n        parserMetadata: \"\",\n        reloadNavigation: false,\n        historyNavigation: false,\n        userActivation: false,\n        taintedOrigin: false,\n        redirectCount: 0,\n        responseTainting: \"basic\",\n        preventNoCacheCacheControlHeaderModification: false,\n        done: false,\n        timingAllowFailed: false,\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n      };\n      request2.url = request2.urlList[0];\n      return request2;\n    }\n    __name(makeRequest, \"makeRequest\");\n    function cloneRequest(request2) {\n      const newRequest = makeRequest({ ...request2, body: null });\n      if (request2.body != null) {\n        newRequest.body = cloneBody(request2.body);\n      }\n      return newRequest;\n    }\n    __name(cloneRequest, \"cloneRequest\");\n    Object.defineProperties(Request.prototype, {\n      method: kEnumerableProperty,\n      url: kEnumerableProperty,\n      headers: kEnumerableProperty,\n      redirect: kEnumerableProperty,\n      clone: kEnumerableProperty,\n      signal: kEnumerableProperty\n    });\n    webidl.converters.Request = webidl.interfaceConverter(\n      Request\n    );\n    webidl.converters.RequestInfo = function(V) {\n      if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n      }\n      if (V instanceof Request) {\n        return webidl.converters.Request(V);\n      }\n      return webidl.converters.USVString(V);\n    };\n    webidl.converters.AbortSignal = webidl.interfaceConverter(\n      AbortSignal\n    );\n    webidl.converters.RequestInit = webidl.dictionaryConverter([\n      {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n      },\n      {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n      },\n      {\n        key: \"body\",\n        converter: webidl.nullableConverter(\n          webidl.converters.BodyInit\n        )\n      },\n      {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n      },\n      {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"\",\n          \"no-referrer\",\n          \"no-referrer-when-downgrade\",\n          \"same-origin\",\n          \"origin\",\n          \"strict-origin\",\n          \"origin-when-cross-origin\",\n          \"strict-origin-when-cross-origin\",\n          \"unsafe-url\"\n        ]\n      },\n      {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"same-origin\",\n          \"cors\",\n          \"no-cors\",\n          \"navigate\",\n          \"websocket\"\n        ]\n      },\n      {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"omit\",\n          \"same-origin\",\n          \"include\"\n        ]\n      },\n      {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"default\",\n          \"no-store\",\n          \"reload\",\n          \"no-cache\",\n          \"force-cache\",\n          \"only-if-cached\"\n        ]\n      },\n      {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        allowedValues: [\n          \"follow\",\n          \"error\",\n          \"manual\"\n        ]\n      },\n      {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n      },\n      {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n      },\n      {\n        key: \"signal\",\n        converter: webidl.nullableConverter(\n          (signal) => webidl.converters.AbortSignal(\n            signal,\n            { strict: false }\n          )\n        )\n      },\n      {\n        key: \"window\",\n        converter: webidl.converters.any\n      }\n    ]);\n    module2.exports = { Request, makeRequest };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/dataURL.js\nvar require_dataURL = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/dataURL.js\"(exports, module2) {\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { atob: atob2 } = __webpack_require__(/*! buffer */ \"buffer\");\n    var encoder = new TextEncoder();\n    function dataURLProcessor(dataURL) {\n      assert(dataURL.protocol === \"data:\");\n      let input = URLSerializer(dataURL, true);\n      input = input.slice(5);\n      const position = { position: 0 };\n      let mimeType = collectASequenceOfCodePoints(\n        (char) => char !== \",\",\n        input,\n        position\n      );\n      const mimeTypeLength = mimeType.length;\n      mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, \"\");\n      if (position.position >= input.length) {\n        return \"failure\";\n      }\n      position.position++;\n      const encodedBody = input.slice(mimeTypeLength + 1);\n      let body = stringPercentDecode(encodedBody);\n      if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        const stringBody = decodeURIComponent(new TextDecoder(\"utf-8\").decode(body));\n        body = forgivingBase64(stringBody);\n        if (body === \"failure\") {\n          return \"failure\";\n        }\n        mimeType = mimeType.slice(0, -6);\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        mimeType = mimeType.slice(0, -1);\n      }\n      if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n      }\n      let mimeTypeRecord = parseMIMEType(mimeType);\n      if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n      }\n      return { mimeType: mimeTypeRecord, body };\n    }\n    __name(dataURLProcessor, \"dataURLProcessor\");\n    function URLSerializer(url, excludeFragment = false) {\n      let output = url.protocol;\n      if (url.host.length > 0) {\n        output += \"//\";\n        if (url.username.length > 0 || url.password.length > 0) {\n          output += url.username;\n          if (url.password.length > 0) {\n            output += \":\" + url.password;\n          }\n          output += \"@\";\n        }\n        output += decodeURIComponent(url.host);\n        if (url.port.length > 0) {\n          output += \":\" + url.port;\n        }\n      }\n      if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === \".\") {\n        output += \"/.\";\n      }\n      output += url.pathname;\n      if (url.search.length > 0) {\n        output += url.search;\n      }\n      if (excludeFragment === false && url.hash.length > 0) {\n        output += url.hash;\n      }\n      return output;\n    }\n    __name(URLSerializer, \"URLSerializer\");\n    function collectASequenceOfCodePoints(condition, input, position) {\n      let result = \"\";\n      while (position.position < input.length && condition(input[position.position])) {\n        result += input[position.position];\n        position.position++;\n      }\n      return result;\n    }\n    __name(collectASequenceOfCodePoints, \"collectASequenceOfCodePoints\");\n    function stringPercentDecode(input) {\n      const bytes = encoder.encode(input);\n      return percentDecode(bytes);\n    }\n    __name(stringPercentDecode, \"stringPercentDecode\");\n    function percentDecode(input) {\n      const output = [];\n      for (let i = 0; i < input.length; i++) {\n        const byte = input[i];\n        if (byte !== 37) {\n          output.push(byte);\n        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n          output.push(37);\n        } else {\n          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n          const bytePoint = Number.parseInt(nextTwoBytes, 16);\n          output.push(bytePoint);\n          i += 2;\n        }\n      }\n      return Uint8Array.from(output);\n    }\n    __name(percentDecode, \"percentDecode\");\n    function parseMIMEType(input) {\n      input = input.trim();\n      const position = { position: 0 };\n      const type = collectASequenceOfCodePoints(\n        (char) => char !== \"/\",\n        input,\n        position\n      );\n      if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n        return \"failure\";\n      }\n      if (position.position > input.length) {\n        return \"failure\";\n      }\n      position.position++;\n      let subtype = collectASequenceOfCodePoints(\n        (char) => char !== \";\",\n        input,\n        position\n      );\n      subtype = subtype.trim();\n      if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n        return \"failure\";\n      }\n      const mimeType = {\n        type: type.toLowerCase(),\n        subtype: subtype.toLowerCase(),\n        parameters: /* @__PURE__ */ new Map()\n      };\n      while (position.position < input.length) {\n        position.position++;\n        collectASequenceOfCodePoints(\n          (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n          input,\n          position\n        );\n        let parameterName = collectASequenceOfCodePoints(\n          (char) => char !== \";\" && char !== \"=\",\n          input,\n          position\n        );\n        parameterName = parameterName.toLowerCase();\n        if (position.position < input.length) {\n          if (input[position.position] === \";\") {\n            continue;\n          }\n          position.position++;\n        }\n        if (position.position > input.length) {\n          break;\n        }\n        let parameterValue = null;\n        if (input[position.position] === '\"') {\n          parameterValue = collectAnHTTPQuotedString(input, position);\n          collectASequenceOfCodePoints(\n            (char) => char !== \";\",\n            input,\n            position\n          );\n        } else {\n          parameterValue = collectASequenceOfCodePoints(\n            (char) => char !== \";\",\n            input,\n            position\n          );\n          parameterValue = parameterValue.trim();\n          if (parameterValue.length === 0) {\n            continue;\n          }\n        }\n        if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {\n          mimeType.parameters.set(parameterName, parameterValue);\n        }\n      }\n      return mimeType;\n    }\n    __name(parseMIMEType, \"parseMIMEType\");\n    function forgivingBase64(data) {\n      data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, \"\");\n      if (data.length % 4 === 0) {\n        data = data.replace(/=?=$/, \"\");\n      }\n      if (data.length % 4 === 1) {\n        return \"failure\";\n      }\n      if (/[^+/0-9A-Za-z]/.test(data)) {\n        return \"failure\";\n      }\n      const binary = atob2(data);\n      const bytes = new Uint8Array(binary.length);\n      for (let byte = 0; byte < binary.length; byte++) {\n        bytes[byte] = binary.charCodeAt(byte);\n      }\n      return bytes;\n    }\n    __name(forgivingBase64, \"forgivingBase64\");\n    function collectAnHTTPQuotedString(input, position, extractValue) {\n      const positionStart = position.position;\n      let value = \"\";\n      assert(input[position.position] === '\"');\n      position.position++;\n      while (true) {\n        value += collectASequenceOfCodePoints(\n          (char) => char !== '\"' && char !== \"\\\\\",\n          input,\n          position\n        );\n        if (position.position >= input.length) {\n          break;\n        }\n        const quoteOrBackslash = input[position.position];\n        position.position++;\n        if (quoteOrBackslash === \"\\\\\") {\n          if (position.position >= input.length) {\n            value += \"\\\\\";\n            break;\n          }\n          value += input[position.position];\n          position.position++;\n        } else {\n          assert(quoteOrBackslash === '\"');\n          break;\n        }\n      }\n      if (extractValue) {\n        return value;\n      }\n      return input.slice(positionStart, position.position);\n    }\n    __name(collectAnHTTPQuotedString, \"collectAnHTTPQuotedString\");\n    module2.exports = {\n      dataURLProcessor,\n      URLSerializer,\n      collectASequenceOfCodePoints,\n      stringPercentDecode,\n      parseMIMEType,\n      collectAnHTTPQuotedString\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/index.js\nvar require_fetch = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/lib/fetch/index.js\"(exports, module2) {\n    \"use strict\";\n    var {\n      Response,\n      makeNetworkError,\n      makeAppropriateNetworkError,\n      filterResponse,\n      makeResponse\n    } = require_response();\n    var { Headers } = require_headers();\n    var { Request, makeRequest } = require_request2();\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    var {\n      bytesMatch,\n      makePolicyContainer,\n      clonePolicyContainer,\n      requestBadPort,\n      TAOCheck,\n      appendRequestOriginHeader,\n      responseLocationURL,\n      requestCurrentURL,\n      setRequestReferrerPolicyOnRedirect,\n      tryUpgradeRequestToAPotentiallyTrustworthyURL,\n      createOpaqueTimingInfo,\n      appendFetchMetadata,\n      corsCheck,\n      crossOriginResourcePolicyCheck,\n      determineRequestsReferrer,\n      coarsenedSharedCurrentTime,\n      createDeferredPromise,\n      isBlobLike,\n      sameOrigin,\n      isCancelled,\n      isAborted,\n      isErrorLike,\n      fullyReadBody\n    } = require_util3();\n    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();\n    var assert = __webpack_require__(/*! assert */ \"assert\");\n    var { safelyExtractBody, extractBody } = require_body();\n    var {\n      redirectStatus,\n      nullBodyStatus,\n      safeMethods,\n      requestBodyHeader,\n      subresource,\n      DOMException\n    } = require_constants();\n    var { kHeadersList } = require_symbols();\n    var EE = __webpack_require__(/*! events */ \"events\");\n    var { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\");\n    var { isErrored, isReadable } = require_util2();\n    var { dataURLProcessor } = require_dataURL();\n    var { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\n    var resolveObjectURL;\n    var ReadableStream;\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    var Fetch = class extends EE {\n      constructor(dispatcher) {\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n      }\n      terminate(reason) {\n        var _a3;\n        if (this.state !== \"ongoing\") {\n          return;\n        }\n        this.state = \"terminated\";\n        (_a3 = this.connection) == null ? void 0 : _a3.destroy(reason);\n        this.emit(\"terminated\", reason);\n      }\n      abort() {\n        var _a3;\n        if (this.state !== \"ongoing\") {\n          return;\n        }\n        const reason = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        this.state = \"aborted\";\n        (_a3 = this.connection) == null ? void 0 : _a3.destroy(reason);\n        this.emit(\"terminated\", reason);\n      }\n    };\n    __name(Fetch, \"Fetch\");\n    async function fetch2(input, init = {}) {\n      var _a3;\n      if (arguments.length < 1) {\n        throw new TypeError(\n          `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`\n        );\n      }\n      const p = createDeferredPromise();\n      let requestObject;\n      try {\n        requestObject = new Request(input, init);\n      } catch (e) {\n        p.reject(e);\n        return p.promise;\n      }\n      const request2 = requestObject[kState];\n      if (requestObject.signal.aborted) {\n        abortFetch(p, request2, null);\n        return p.promise;\n      }\n      const globalObject = request2.client.globalObject;\n      if (((_a3 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a3.name) === \"ServiceWorkerGlobalScope\") {\n        request2.serviceWorkers = \"none\";\n      }\n      let responseObject = null;\n      const relevantRealm = null;\n      let locallyAborted = false;\n      let controller = null;\n      requestObject.signal.addEventListener(\n        \"abort\",\n        () => {\n          locallyAborted = true;\n          abortFetch(p, request2, responseObject);\n          if (controller != null) {\n            controller.abort();\n          }\n        },\n        { once: true }\n      );\n      const handleFetchDone = /* @__PURE__ */ __name((response) => finalizeAndReportTiming(response, \"fetch\"), \"handleFetchDone\");\n      const processResponse = /* @__PURE__ */ __name((response) => {\n        if (locallyAborted) {\n          return;\n        }\n        if (response.aborted) {\n          abortFetch(p, request2, responseObject);\n          return;\n        }\n        if (response.type === \"error\") {\n          p.reject(\n            Object.assign(new TypeError(\"fetch failed\"), { cause: response.error })\n          );\n          return;\n        }\n        responseObject = new Response();\n        responseObject[kState] = response;\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = response.headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        p.resolve(responseObject);\n      }, \"processResponse\");\n      controller = fetching({\n        request: request2,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: this\n      });\n      return p.promise;\n    }\n    __name(fetch2, \"fetch\");\n    function finalizeAndReportTiming(response, initiatorType = \"other\") {\n      var _a3;\n      if (response.type === \"error\" && response.aborted) {\n        return;\n      }\n      if (!((_a3 = response.urlList) == null ? void 0 : _a3.length)) {\n        return;\n      }\n      const originalURL = response.urlList[0];\n      let timingInfo = response.timingInfo;\n      let cacheState = response.cacheState;\n      if (!/^https?:/.test(originalURL.protocol)) {\n        return;\n      }\n      if (timingInfo === null) {\n        return;\n      }\n      if (!timingInfo.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo({\n          startTime: timingInfo.startTime\n        });\n        cacheState = \"\";\n      }\n      response.timingInfo.endTime = coarsenedSharedCurrentTime();\n      response.timingInfo = timingInfo;\n      markResourceTiming(\n        timingInfo,\n        originalURL,\n        initiatorType,\n        globalThis,\n        cacheState\n      );\n    }\n    __name(finalizeAndReportTiming, \"finalizeAndReportTiming\");\n    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {\n      if (nodeMajor >= 18 && nodeMinor >= 2) {\n        performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);\n      }\n    }\n    __name(markResourceTiming, \"markResourceTiming\");\n    function abortFetch(p, request2, responseObject) {\n      var _a3, _b2;\n      const error2 = new DOMException(\"The operation was aborted.\", \"AbortError\");\n      p.reject(error2);\n      if (request2.body != null && isReadable((_a3 = request2.body) == null ? void 0 : _a3.stream)) {\n        request2.body.stream.cancel(error2).catch((err) => {\n          if (err.code === \"ERR_INVALID_STATE\") {\n            return;\n          }\n          throw err;\n        });\n      }\n      if (responseObject == null) {\n        return;\n      }\n      const response = responseObject[kState];\n      if (response.body != null && isReadable((_b2 = response.body) == null ? void 0 : _b2.stream)) {\n        response.body.stream.cancel(error2).catch((err) => {\n          if (err.code === \"ERR_INVALID_STATE\") {\n            return;\n          }\n          throw err;\n        });\n      }\n    }\n    __name(abortFetch, \"abortFetch\");\n    function fetching({\n      request: request2,\n      processRequestBodyChunkLength,\n      processRequestEndOfBody,\n      processResponse,\n      processResponseEndOfBody,\n      processResponseConsumeBody,\n      useParallelQueue = false,\n      dispatcher\n    }) {\n      var _a3, _b2, _c, _d;\n      let taskDestination = null;\n      let crossOriginIsolatedCapability = false;\n      if (request2.client != null) {\n        taskDestination = request2.client.globalObject;\n        crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;\n      }\n      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n      const timingInfo = createOpaqueTimingInfo({\n        startTime: currenTime\n      });\n      const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request: request2,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n      };\n      assert(!request2.body || request2.body.stream);\n      if (request2.window === \"client\") {\n        request2.window = ((_c = (_b2 = (_a3 = request2.client) == null ? void 0 : _a3.globalObject) == null ? void 0 : _b2.constructor) == null ? void 0 : _c.name) === \"Window\" ? request2.client : \"no-window\";\n      }\n      if (request2.origin === \"client\") {\n        request2.origin = (_d = request2.client) == null ? void 0 : _d.origin;\n      }\n      if (request2.policyContainer === \"client\") {\n        if (request2.client != null) {\n          request2.policyContainer = clonePolicyContainer(\n            request2.client.policyContainer\n          );\n        } else {\n          request2.policyContainer = makePolicyContainer();\n        }\n      }\n      if (!request2.headersList.has(\"accept\")) {\n        const value = \"*/*\";\n        request2.headersList.append(\"accept\", value);\n      }\n      if (!request2.headersList.has(\"accept-language\")) {\n        request2.headersList.append(\"accept-language\", \"*\");\n      }\n      if (request2.priority === null) {\n      }\n      if (subresource.includes(request2.destination)) {\n      }\n      mainFetch(fetchParams).catch((err) => {\n        fetchParams.controller.terminate(err);\n      });\n      return fetchParams.controller;\n    }\n    __name(fetching, \"fetching\");\n    async function mainFetch(fetchParams, recursive = false) {\n      const request2 = fetchParams.request;\n      let response = null;\n      if (request2.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request2).protocol)) {\n        response = makeNetworkError(\"local URLs only\");\n      }\n      tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);\n      if (requestBadPort(request2) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n      }\n      if (request2.referrerPolicy === \"\") {\n        request2.referrerPolicy = request2.policyContainer.referrerPolicy;\n      }\n      if (request2.referrer !== \"no-referrer\") {\n        request2.referrer = determineRequestsReferrer(request2);\n      }\n      if (response === null) {\n        response = await (async () => {\n          const currentURL = requestCurrentURL(request2);\n          if (sameOrigin(currentURL, request2.url) && request2.responseTainting === \"basic\" || currentURL.protocol === \"data:\" || (request2.mode === \"navigate\" || request2.mode === \"websocket\")) {\n            request2.responseTainting = \"basic\";\n            return await schemeFetch(fetchParams);\n          }\n          if (request2.mode === \"same-origin\") {\n            return makeNetworkError('request mode cannot be \"same-origin\"');\n          }\n          if (request2.mode === \"no-cors\") {\n            if (request2.redirect !== \"follow\") {\n              return makeNetworkError(\n                'redirect mode cannot be \"follow\" for \"no-cors\" request'\n              );\n            }\n            request2.responseTainting = \"opaque\";\n            return await schemeFetch(fetchParams);\n          }\n          if (!/^https?:/.test(requestCurrentURL(request2).protocol)) {\n            return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n          }\n          request2.responseTainting = \"cors\";\n          return await httpFetch(fetchParams);\n        })();\n      }\n      if (recursive) {\n        return response;\n      }\n      if (response.status !== 0 && !response.internalResponse) {\n        if (request2.responseTainting === \"cors\") {\n        }\n        if (request2.responseTainting === \"basic\") {\n          response = filterResponse(response, \"basic\");\n        } else if (request2.responseTainting === \"cors\") {\n          response = filterResponse(response, \"cors\");\n        } else if (request2.responseTainting === \"opaque\") {\n          response = filterResponse(response, \"opaque\");\n        } else {\n          assert(false);\n        }\n      }\n      let internalResponse = response.status === 0 ? response : response.internalResponse;\n      if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request2.urlList);\n      }\n      if (!request2.timingAllowFailed) {\n        response.timingAllowPassed = true;\n      }\n      if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.has(\"range\")) {\n        response = internalResponse = makeNetworkError();\n      }\n      if (response.status !== 0 && (request2.method === \"HEAD\" || request2.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n      }\n      if (request2.integrity) {\n        const processBodyError = /* @__PURE__ */ __name((reason) => fetchFinale(fetchParams, makeNetworkError(reason)), \"processBodyError\");\n        if (request2.responseTainting === \"opaque\" || response.body == null) {\n          processBodyError(response.error);\n          return;\n        }\n        const processBody = /* @__PURE__ */ __name((bytes) => {\n          if (!bytesMatch(bytes, request2.integrity)) {\n            processBodyError(\"integrity mismatch\");\n            return;\n          }\n          response.body = safelyExtractBody(bytes)[0];\n          fetchFinale(fetchParams, response);\n        }, \"processBody\");\n        await fullyReadBody(response.body, processBody, processBodyError);\n      } else {\n        fetchFinale(fetchParams, response);\n      }\n    }\n    __name(mainFetch, \"mainFetch\");\n    async function schemeFetch(fetchParams) {\n      const { request: request2 } = fetchParams;\n      const {\n        protocol: scheme,\n        pathname: path7\n      } = requestCurrentURL(request2);\n      switch (scheme) {\n        case \"about:\": {\n          if (path7 === \"blank\") {\n            const resp = makeResponse({\n              statusText: \"OK\",\n              headersList: [\n                [\"content-type\", \"text/html;charset=utf-8\"]\n              ]\n            });\n            resp.urlList = [new URL(\"about:blank\")];\n            return resp;\n          }\n          return makeNetworkError(\"invalid path called\");\n        }\n        case \"blob:\": {\n          resolveObjectURL = resolveObjectURL || (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL);\n          const currentURL = requestCurrentURL(request2);\n          if (currentURL.search.length !== 0) {\n            return makeNetworkError(\"NetworkError when attempting to fetch resource.\");\n          }\n          const blob = resolveObjectURL(currentURL.toString());\n          if (request2.method !== \"GET\" || !isBlobLike(blob)) {\n            return makeNetworkError(\"invalid method\");\n          }\n          const response = makeResponse({ statusText: \"OK\", urlList: [currentURL] });\n          response.headersList.set(\"content-length\", `${blob.size}`);\n          response.headersList.set(\"content-type\", blob.type);\n          response.body = extractBody(blob)[0];\n          return response;\n        }\n        case \"data:\": {\n          const currentURL = requestCurrentURL(request2);\n          const dataURLStruct = dataURLProcessor(currentURL);\n          if (dataURLStruct === \"failure\") {\n            return makeNetworkError(\"failed to fetch the data URL\");\n          }\n          const { mimeType } = dataURLStruct;\n          let contentType = `${mimeType.type}/${mimeType.subtype}`;\n          const contentTypeParams = [];\n          if (mimeType.parameters.size > 0) {\n            contentType += \";\";\n          }\n          for (const [key, value] of mimeType.parameters) {\n            if (value.length > 0) {\n              contentTypeParams.push(`${key}=${value}`);\n            } else {\n              contentTypeParams.push(key);\n            }\n          }\n          contentType += contentTypeParams.join(\",\");\n          return makeResponse({\n            statusText: \"OK\",\n            headersList: [\n              [\"content-type\", contentType]\n            ],\n            body: extractBody(dataURLStruct.body)[0]\n          });\n        }\n        case \"file:\": {\n          return makeNetworkError(\"not implemented... yet...\");\n        }\n        case \"http:\":\n        case \"https:\": {\n          return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));\n        }\n        default: {\n          return makeNetworkError(\"unknown scheme\");\n        }\n      }\n    }\n    __name(schemeFetch, \"schemeFetch\");\n    function finalizeResponse(fetchParams, response) {\n      fetchParams.request.done = true;\n      if (fetchParams.processResponseDone != null) {\n        queueMicrotask(() => fetchParams.processResponseDone(response));\n      }\n    }\n    __name(finalizeResponse, \"finalizeResponse\");\n    async function fetchFinale(fetchParams, response) {\n      if (response.type === \"error\") {\n        response.urlList = [fetchParams.request.urlList[0]];\n        response.timingInfo = createOpaqueTimingInfo({\n          startTime: fetchParams.timingInfo.startTime\n        });\n      }\n      const processResponseEndOfBody = /* @__PURE__ */ __name(() => {\n        fetchParams.request.done = true;\n        if (fetchParams.processResponseEndOfBody != null) {\n          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));\n        }\n      }, \"processResponseEndOfBody\");\n      if (fetchParams.processResponse != null) {\n        queueMicrotask(() => fetchParams.processResponse(response));\n      }\n      if (response.body == null) {\n        processResponseEndOfBody();\n      } else {\n        const identityTransformAlgorithm = /* @__PURE__ */ __name((chunk, controller) => {\n          controller.enqueue(chunk);\n        }, \"identityTransformAlgorithm\");\n        const transformStream = new TransformStream({\n          start() {\n          },\n          transform: identityTransformAlgorithm,\n          flush: processResponseEndOfBody\n        });\n        response.body = { stream: response.body.stream.pipeThrough(transformStream) };\n      }\n      if (fetchParams.processResponseConsumeBody != null) {\n        const processBody = /* @__PURE__ */ __name((nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), \"processBody\");\n        const processBodyError = /* @__PURE__ */ __name((failure) => fetchParams.processResponseConsumeBody(response, failure), \"processBodyError\");\n        if (response.body == null) {\n          queueMicrotask(() => processBody(null));\n        } else {\n          await fullyReadBody(response.body, processBody, processBodyError);\n        }\n      }\n    }\n    __name(fetchFinale, \"fetchFinale\");\n    async function httpFetch(fetchParams) {\n      const request2 = fetchParams.request;\n      let response = null;\n      let actualResponse = null;\n      const timingInfo = fetchParams.timingInfo;\n      if (request2.serviceWorkers === \"all\") {\n      }\n      if (response === null) {\n        if (request2.redirect === \"follow\") {\n          request2.serviceWorkers = \"none\";\n        }\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        if (request2.responseTainting === \"cors\" && corsCheck(request2, response) === \"failure\") {\n          return makeNetworkError(\"cors failure\");\n        }\n        if (TAOCheck(request2, response) === \"failure\") {\n          request2.timingAllowFailed = true;\n        }\n      }\n      if ((request2.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(\n        request2.origin,\n        request2.client,\n        request2.destination,\n        actualResponse\n      ) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n      }\n      if (redirectStatus.includes(actualResponse.status)) {\n        fetchParams.controller.connection.destroy();\n        if (request2.redirect === \"error\") {\n          response = makeNetworkError(\"unexpected redirect\");\n        } else if (request2.redirect === \"manual\") {\n          response = actualResponse;\n        } else if (request2.redirect === \"follow\") {\n          response = await httpRedirectFetch(fetchParams, response);\n        } else {\n          assert(false);\n        }\n      }\n      response.timingInfo = timingInfo;\n      return response;\n    }\n    __name(httpFetch, \"httpFetch\");\n    async function httpRedirectFetch(fetchParams, response) {\n      const request2 = fetchParams.request;\n      const actualResponse = response.internalResponse ? response.internalResponse : response;\n      let locationURL;\n      try {\n        locationURL = responseLocationURL(\n          actualResponse,\n          requestCurrentURL(request2).hash\n        );\n        if (locationURL == null) {\n          return response;\n        }\n      } catch (err) {\n        return makeNetworkError(err);\n      }\n      if (!/^https?:/.test(locationURL.protocol)) {\n        return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n      }\n      if (request2.redirectCount === 20) {\n        return makeNetworkError(\"redirect count exceeded\");\n      }\n      request2.redirectCount += 1;\n      if (request2.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {\n        return makeNetworkError('cross origin not allowed for request mode \"cors\"');\n      }\n      if (request2.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return makeNetworkError(\n          'URL cannot contain credentials for request mode \"cors\"'\n        );\n      }\n      if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {\n        return makeNetworkError();\n      }\n      if ([301, 302].includes(actualResponse.status) && request2.method === \"POST\" || actualResponse.status === 303 && ![\"GET\", \"HEAD\"].includes(request2.method)) {\n        request2.method = \"GET\";\n        request2.body = null;\n        for (const headerName of requestBodyHeader) {\n          request2.headersList.delete(headerName);\n        }\n      }\n      if (request2.body != null) {\n        assert(request2.body.source);\n        request2.body = safelyExtractBody(request2.body.source)[0];\n      }\n      const timingInfo = fetchParams.timingInfo;\n      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n      if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n      }\n      request2.urlList.push(locationURL);\n      setRequestReferrerPolicyOnRedirect(request2, actualResponse);\n      return mainFetch(fetchParams, true);\n    }\n    __name(httpRedirectFetch, \"httpRedirectFetch\");\n    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n      const request2 = fetchParams.request;\n      let httpFetchParams = null;\n      let httpRequest = null;\n      let response = null;\n      const httpCache = null;\n      const revalidatingFlag = false;\n      if (request2.window === \"no-window\" && request2.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request2;\n      } else {\n        httpRequest = makeRequest(request2);\n        httpFetchParams = { ...fetchParams };\n        httpFetchParams.request = httpRequest;\n      }\n      const includeCredentials = request2.credentials === \"include\" || request2.credentials === \"same-origin\" && request2.responseTainting === \"basic\";\n      const contentLength = httpRequest.body ? httpRequest.body.length : null;\n      let contentLengthHeaderValue = null;\n      if (httpRequest.body == null && [\"POST\", \"PUT\"].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n      }\n      if (contentLength != null) {\n        contentLengthHeaderValue = String(contentLength);\n      }\n      if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue);\n      }\n      if (contentLength != null && httpRequest.keepalive) {\n      }\n      if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", httpRequest.referrer.href);\n      }\n      appendRequestOriginHeader(httpRequest);\n      appendFetchMetadata(httpRequest);\n      if (!httpRequest.headersList.has(\"user-agent\")) {\n        httpRequest.headersList.append(\"user-agent\", \"undici\");\n      }\n      if (httpRequest.cache === \"default\" && (httpRequest.headersList.has(\"if-modified-since\") || httpRequest.headersList.has(\"if-none-match\") || httpRequest.headersList.has(\"if-unmodified-since\") || httpRequest.headersList.has(\"if-match\") || httpRequest.headersList.has(\"if-range\"))) {\n        httpRequest.cache = \"no-store\";\n      }\n      if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has(\"cache-control\")) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\");\n      }\n      if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        if (!httpRequest.headersList.has(\"pragma\")) {\n          httpRequest.headersList.append(\"pragma\", \"no-cache\");\n        }\n        if (!httpRequest.headersList.has(\"cache-control\")) {\n          httpRequest.headersList.append(\"cache-control\", \"no-cache\");\n        }\n      }\n      if (httpRequest.headersList.has(\"range\")) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\");\n      }\n      if (!httpRequest.headersList.has(\"accept-encoding\")) {\n        if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n          httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\");\n        } else {\n          httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\");\n        }\n      }\n      if (includeCredentials) {\n      }\n      if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n      }\n      if (httpRequest.mode !== \"no-store\" && httpRequest.mode !== \"reload\") {\n      }\n      if (response == null) {\n        if (httpRequest.mode === \"only-if-cached\") {\n          return makeNetworkError(\"only if cached\");\n        }\n        const forwardResponse = await httpNetworkFetch(\n          httpFetchParams,\n          includeCredentials,\n          isNewConnectionFetch\n        );\n        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        }\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        }\n        if (response == null) {\n          response = forwardResponse;\n        }\n      }\n      response.urlList = [...httpRequest.urlList];\n      if (httpRequest.headersList.has(\"range\")) {\n        response.rangeRequested = true;\n      }\n      response.requestIncludesCredentials = includeCredentials;\n      if (response.status === 407) {\n        if (request2.window === \"no-window\") {\n          return makeNetworkError();\n        }\n        if (isCancelled(fetchParams)) {\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        return makeNetworkError(\"proxy authentication required\");\n      }\n      if (response.status === 421 && !isNewConnectionFetch && (request2.body == null || request2.body.source != null)) {\n        if (isCancelled(fetchParams)) {\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(\n          fetchParams,\n          isAuthenticationFetch,\n          true\n        );\n      }\n      if (isAuthenticationFetch) {\n      }\n      return response;\n    }\n    __name(httpNetworkOrCacheFetch, \"httpNetworkOrCacheFetch\");\n    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n      fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy(err) {\n          var _a3;\n          if (!this.destroyed) {\n            this.destroyed = true;\n            (_a3 = this.abort) == null ? void 0 : _a3.call(this, err != null ? err : new DOMException(\"The operation was aborted.\", \"AbortError\"));\n          }\n        }\n      };\n      const request2 = fetchParams.request;\n      let response = null;\n      const timingInfo = fetchParams.timingInfo;\n      const httpCache = null;\n      if (httpCache == null) {\n        request2.cache = \"no-store\";\n      }\n      const newConnection = forceNewConnection ? \"yes\" : \"no\";\n      if (request2.mode === \"websocket\") {\n      } else {\n      }\n      let requestBody = null;\n      if (request2.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(() => fetchParams.processRequestEndOfBody());\n      } else if (request2.body != null) {\n        const processBodyChunk = /* @__PURE__ */ __name(async function* (bytes) {\n          var _a3;\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          yield bytes;\n          (_a3 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a3.call(fetchParams, bytes.byteLength);\n        }, \"processBodyChunk\");\n        const processEndOfBody = /* @__PURE__ */ __name(() => {\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          if (fetchParams.processRequestEndOfBody) {\n            fetchParams.processRequestEndOfBody();\n          }\n        }, \"processEndOfBody\");\n        const processBodyError = /* @__PURE__ */ __name((e) => {\n          if (isCancelled(fetchParams)) {\n            return;\n          }\n          if (e.name === \"AbortError\") {\n            fetchParams.controller.abort();\n          } else {\n            fetchParams.controller.terminate(e);\n          }\n        }, \"processBodyError\");\n        requestBody = async function* () {\n          try {\n            for await (const bytes of request2.body.stream) {\n              yield* processBodyChunk(bytes);\n            }\n            processEndOfBody();\n          } catch (err) {\n            processBodyError(err);\n          }\n        }();\n      }\n      try {\n        const { body, status, statusText, headersList } = await dispatch({ body: requestBody });\n        const iterator = body[Symbol.asyncIterator]();\n        fetchParams.controller.next = () => iterator.next();\n        response = makeResponse({ status, statusText, headersList });\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          fetchParams.controller.connection.destroy();\n          return makeAppropriateNetworkError(fetchParams);\n        }\n        return makeNetworkError(err);\n      }\n      const pullAlgorithm = /* @__PURE__ */ __name(() => {\n        fetchParams.controller.resume();\n      }, \"pullAlgorithm\");\n      const cancelAlgorithm = /* @__PURE__ */ __name(() => {\n        fetchParams.controller.abort();\n      }, \"cancelAlgorithm\");\n      if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n      }\n      const stream2 = new ReadableStream(\n        {\n          async start(controller) {\n            fetchParams.controller.controller = controller;\n          },\n          async pull(controller) {\n            await pullAlgorithm(controller);\n          },\n          async cancel(reason) {\n            await cancelAlgorithm(reason);\n          }\n        },\n        { highWaterMark: 0 }\n      );\n      response.body = { stream: stream2 };\n      fetchParams.controller.on(\"terminated\", onAborted);\n      fetchParams.controller.resume = async () => {\n        var _a3;\n        while (true) {\n          let bytes;\n          try {\n            const { done, value } = await fetchParams.controller.next();\n            if (isAborted(fetchParams)) {\n              break;\n            }\n            bytes = done ? void 0 : value;\n          } catch (err) {\n            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n              bytes = void 0;\n            } else {\n              bytes = err;\n            }\n          }\n          if (bytes === void 0) {\n            try {\n              fetchParams.controller.controller.close();\n            } catch (err) {\n              if (!/Controller is already closed/.test(err)) {\n                throw err;\n              }\n            }\n            finalizeResponse(fetchParams, response);\n            return;\n          }\n          timingInfo.decodedBodySize += (_a3 = bytes == null ? void 0 : bytes.byteLength) != null ? _a3 : 0;\n          if (isErrorLike(bytes)) {\n            fetchParams.controller.terminate(bytes);\n            return;\n          }\n          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n          if (isErrored(stream2)) {\n            fetchParams.controller.terminate();\n            return;\n          }\n          if (!fetchParams.controller.controller.desiredSize) {\n            return;\n          }\n        }\n      };\n      function onAborted(reason) {\n        if (isAborted(fetchParams)) {\n          response.aborted = true;\n          if (isReadable(stream2)) {\n            fetchParams.controller.controller.error(\n              new DOMException(\"The operation was aborted.\", \"AbortError\")\n            );\n          }\n        } else {\n          if (isReadable(stream2)) {\n            fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n              cause: isErrorLike(reason) ? reason : void 0\n            }));\n          }\n        }\n        fetchParams.controller.connection.destroy();\n      }\n      __name(onAborted, \"onAborted\");\n      return response;\n      async function dispatch({ body }) {\n        const url = requestCurrentURL(request2);\n        return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(\n          {\n            path: url.pathname + url.search,\n            origin: url.origin,\n            method: request2.method,\n            body: fetchParams.controller.dispatcher.isMockActive ? request2.body && request2.body.source : body,\n            headers: [...request2.headersList].flat(),\n            maxRedirections: 0,\n            bodyTimeout: 3e5,\n            headersTimeout: 3e5\n          },\n          {\n            body: null,\n            abort: null,\n            onConnect(abort) {\n              const { connection } = fetchParams.controller;\n              if (connection.destroyed) {\n                abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n              } else {\n                fetchParams.controller.on(\"terminated\", abort);\n                this.abort = connection.abort = abort;\n              }\n            },\n            onHeaders(status, headersList, resume, statusText) {\n              if (status < 200) {\n                return;\n              }\n              let codings = [];\n              let location = \"\";\n              const headers = new Headers();\n              for (let n = 0; n < headersList.length; n += 2) {\n                const key = headersList[n + 0].toString(\"latin1\");\n                const val = headersList[n + 1].toString(\"latin1\");\n                if (key.toLowerCase() === \"content-encoding\") {\n                  codings = val.split(\",\").map((x) => x.trim());\n                } else if (key.toLowerCase() === \"location\") {\n                  location = val;\n                }\n                headers.append(key, val);\n              }\n              this.body = new Readable({ read: resume });\n              const decoders = [];\n              if (request2.method !== \"HEAD\" && request2.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !(request2.redirect === \"follow\" && location)) {\n                for (const coding of codings) {\n                  if (/(x-)?gzip/.test(coding)) {\n                    decoders.push(zlib.createGunzip());\n                  } else if (/(x-)?deflate/.test(coding)) {\n                    decoders.push(zlib.createInflate());\n                  } else if (coding === \"br\") {\n                    decoders.push(zlib.createBrotliDecompress());\n                  } else {\n                    decoders.length = 0;\n                    break;\n                  }\n                }\n              }\n              resolve({\n                status,\n                statusText,\n                headersList: headers[kHeadersList],\n                body: decoders.length ? pipeline(this.body, ...decoders, () => {\n                }) : this.body.on(\"error\", () => {\n                })\n              });\n              return true;\n            },\n            onData(chunk) {\n              if (fetchParams.controller.dump) {\n                return;\n              }\n              const bytes = chunk;\n              timingInfo.encodedBodySize += bytes.byteLength;\n              return this.body.push(bytes);\n            },\n            onComplete() {\n              if (this.abort) {\n                fetchParams.controller.off(\"terminated\", this.abort);\n              }\n              fetchParams.controller.ended = true;\n              this.body.push(null);\n            },\n            onError(error2) {\n              var _a3;\n              if (this.abort) {\n                fetchParams.controller.off(\"terminated\", this.abort);\n              }\n              (_a3 = this.body) == null ? void 0 : _a3.destroy(error2);\n              fetchParams.controller.terminate(error2);\n              reject(error2);\n            }\n          }\n        ));\n      }\n      __name(dispatch, \"dispatch\");\n    }\n    __name(httpNetworkFetch, \"httpNetworkFetch\");\n    module2.exports = fetch2;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/index.js\nvar require_undici = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.10.0/node_modules/undici/index.js\"(exports, module2) {\n    \"use strict\";\n    var Client = require_client();\n    var Dispatcher = require_dispatcher();\n    var errors = require_errors();\n    var Pool = require_pool();\n    var BalancedPool = require_balanced_pool();\n    var Agent = require_agent();\n    var util2 = require_util2();\n    var { InvalidArgumentError } = errors;\n    var api = require_api();\n    var buildConnector = require_connect();\n    var MockClient = require_mock_client();\n    var MockAgent = require_mock_agent();\n    var MockPool = require_mock_pool();\n    var mockErrors = require_mock_errors();\n    var ProxyAgent = require_proxy_agent();\n    var { getGlobalDispatcher, setGlobalDispatcher } = require_global();\n    var nodeVersion = process.versions.node.split(\".\");\n    var nodeMajor = Number(nodeVersion[0]);\n    var nodeMinor = Number(nodeVersion[1]);\n    Object.assign(Dispatcher.prototype, api);\n    module2.exports.Dispatcher = Dispatcher;\n    module2.exports.Client = Client;\n    module2.exports.Pool = Pool;\n    module2.exports.BalancedPool = BalancedPool;\n    module2.exports.Agent = Agent;\n    module2.exports.ProxyAgent = ProxyAgent;\n    module2.exports.buildConnector = buildConnector;\n    module2.exports.errors = errors;\n    function makeDispatcher(fn) {\n      return (url, opts, handler) => {\n        if (typeof opts === \"function\") {\n          handler = opts;\n          opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n          throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n          throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n          if (typeof opts.path !== \"string\") {\n            throw new InvalidArgumentError(\"invalid opts.path\");\n          }\n          let path7 = opts.path;\n          if (!opts.path.startsWith(\"/\")) {\n            path7 = `/${path7}`;\n          }\n          url = new URL(util2.parseOrigin(url).origin + path7);\n        } else {\n          if (!opts) {\n            opts = typeof url === \"object\" ? url : {};\n          }\n          url = util2.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n          throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n          ...opts,\n          origin: url.origin,\n          path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n          method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n      };\n    }\n    __name(makeDispatcher, \"makeDispatcher\");\n    module2.exports.setGlobalDispatcher = setGlobalDispatcher;\n    module2.exports.getGlobalDispatcher = getGlobalDispatcher;\n    if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 8) {\n      let fetchImpl = null;\n      module2.exports.fetch = /* @__PURE__ */ __name(async function fetch2(resource) {\n        if (!fetchImpl) {\n          fetchImpl = require_fetch();\n        }\n        const dispatcher = arguments[1] && arguments[1].dispatcher || getGlobalDispatcher();\n        return fetchImpl.apply(dispatcher, arguments);\n      }, \"fetch\");\n      module2.exports.Headers = require_headers().Headers;\n      module2.exports.Response = require_response().Response;\n      module2.exports.Request = require_request2().Request;\n      module2.exports.FormData = require_formdata().FormData;\n      module2.exports.File = require_file().File;\n    }\n    module2.exports.request = makeDispatcher(api.request);\n    module2.exports.stream = makeDispatcher(api.stream);\n    module2.exports.pipeline = makeDispatcher(api.pipeline);\n    module2.exports.connect = makeDispatcher(api.connect);\n    module2.exports.upgrade = makeDispatcher(api.upgrade);\n    module2.exports.MockClient = MockClient;\n    module2.exports.MockPool = MockPool;\n    module2.exports.MockAgent = MockAgent;\n    module2.exports.mockErrors = mockErrors;\n  }\n});\n\n// ../../node_modules/.pnpm/dotenv@16.0.1/node_modules/dotenv/lib/main.js\nvar require_main2 = __commonJS({\n  \"../../node_modules/.pnpm/dotenv@16.0.1/node_modules/dotenv/lib/main.js\"(exports, module2) {\n    var fs11 = __webpack_require__(/*! fs */ \"fs\");\n    var path7 = __webpack_require__(/*! path */ \"path\");\n    var os3 = __webpack_require__(/*! os */ \"os\");\n    var LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n    function parse2(src) {\n      const obj = {};\n      let lines = src.toString();\n      lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n      let match;\n      while ((match = LINE.exec(lines)) != null) {\n        const key = match[1];\n        let value = match[2] || \"\";\n        value = value.trim();\n        const maybeQuote = value[0];\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        if (maybeQuote === '\"') {\n          value = value.replace(/\\\\n/g, \"\\n\");\n          value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        obj[key] = value;\n      }\n      return obj;\n    }\n    __name(parse2, \"parse\");\n    function _log(message) {\n      console.log(`[dotenv][DEBUG] ${message}`);\n    }\n    __name(_log, \"_log\");\n    function _resolveHome(envPath) {\n      return envPath[0] === \"~\" ? path7.join(os3.homedir(), envPath.slice(1)) : envPath;\n    }\n    __name(_resolveHome, \"_resolveHome\");\n    function config2(options) {\n      let dotenvPath = path7.resolve(process.cwd(), \".env\");\n      let encoding = \"utf8\";\n      const debug13 = Boolean(options && options.debug);\n      const override = Boolean(options && options.override);\n      if (options) {\n        if (options.path != null) {\n          dotenvPath = _resolveHome(options.path);\n        }\n        if (options.encoding != null) {\n          encoding = options.encoding;\n        }\n      }\n      try {\n        const parsed = DotenvModule.parse(fs11.readFileSync(dotenvPath, { encoding }));\n        Object.keys(parsed).forEach(function(key) {\n          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n            process.env[key] = parsed[key];\n          } else {\n            if (override === true) {\n              process.env[key] = parsed[key];\n            }\n            if (debug13) {\n              if (override === true) {\n                _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`);\n              } else {\n                _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`);\n              }\n            }\n          }\n        });\n        return { parsed };\n      } catch (e) {\n        if (debug13) {\n          _log(`Failed to load ${dotenvPath} ${e.message}`);\n        }\n        return { error: e };\n      }\n    }\n    __name(config2, \"config\");\n    var DotenvModule = {\n      config: config2,\n      parse: parse2\n    };\n    module2.exports.config = DotenvModule.config;\n    module2.exports.parse = DotenvModule.parse;\n    module2.exports = DotenvModule;\n  }\n});\n\n// ../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js\nvar require_arg = __commonJS({\n  \"../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js\"(exports, module2) {\n    var flagSymbol = Symbol(\"arg flag\");\n    var ArgError = class extends Error {\n      constructor(msg, code) {\n        super(msg);\n        this.name = \"ArgError\";\n        this.code = code;\n        Object.setPrototypeOf(this, ArgError.prototype);\n      }\n    };\n    __name(ArgError, \"ArgError\");\n    function arg2(opts, {\n      argv = process.argv.slice(2),\n      permissive = false,\n      stopAtPositional = false\n    } = {}) {\n      if (!opts) {\n        throw new ArgError(\n          \"argument specification object is required\",\n          \"ARG_CONFIG_NO_SPEC\"\n        );\n      }\n      const result = { _: [] };\n      const aliases = {};\n      const handlers = {};\n      for (const key of Object.keys(opts)) {\n        if (!key) {\n          throw new ArgError(\n            \"argument key cannot be an empty string\",\n            \"ARG_CONFIG_EMPTY_KEY\"\n          );\n        }\n        if (key[0] !== \"-\") {\n          throw new ArgError(\n            `argument key must start with '-' but found: '${key}'`,\n            \"ARG_CONFIG_NONOPT_KEY\"\n          );\n        }\n        if (key.length === 1) {\n          throw new ArgError(\n            `argument key must have a name; singular '-' keys are not allowed: ${key}`,\n            \"ARG_CONFIG_NONAME_KEY\"\n          );\n        }\n        if (typeof opts[key] === \"string\") {\n          aliases[key] = opts[key];\n          continue;\n        }\n        let type = opts[key];\n        let isFlag = false;\n        if (Array.isArray(type) && type.length === 1 && typeof type[0] === \"function\") {\n          const [fn] = type;\n          type = /* @__PURE__ */ __name((value, name, prev = []) => {\n            prev.push(fn(value, name, prev[prev.length - 1]));\n            return prev;\n          }, \"type\");\n          isFlag = fn === Boolean || fn[flagSymbol] === true;\n        } else if (typeof type === \"function\") {\n          isFlag = type === Boolean || type[flagSymbol] === true;\n        } else {\n          throw new ArgError(\n            `type missing or not a function or valid array type: ${key}`,\n            \"ARG_CONFIG_VAD_TYPE\"\n          );\n        }\n        if (key[1] !== \"-\" && key.length > 2) {\n          throw new ArgError(\n            `short argument keys (with a single hyphen) must have only one character: ${key}`,\n            \"ARG_CONFIG_SHORTOPT_TOOLONG\"\n          );\n        }\n        handlers[key] = [type, isFlag];\n      }\n      for (let i = 0, len = argv.length; i < len; i++) {\n        const wholeArg = argv[i];\n        if (stopAtPositional && result._.length > 0) {\n          result._ = result._.concat(argv.slice(i));\n          break;\n        }\n        if (wholeArg === \"--\") {\n          result._ = result._.concat(argv.slice(i + 1));\n          break;\n        }\n        if (wholeArg.length > 1 && wholeArg[0] === \"-\") {\n          const separatedArguments = wholeArg[1] === \"-\" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split(\"\").map((a) => `-${a}`);\n          for (let j = 0; j < separatedArguments.length; j++) {\n            const arg3 = separatedArguments[j];\n            const [originalArgName, argStr] = arg3[1] === \"-\" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];\n            let argName = originalArgName;\n            while (argName in aliases) {\n              argName = aliases[argName];\n            }\n            if (!(argName in handlers)) {\n              if (permissive) {\n                result._.push(arg3);\n                continue;\n              } else {\n                throw new ArgError(\n                  `unknown or unexpected option: ${originalArgName}`,\n                  \"ARG_UNKNOWN_OPTION\"\n                );\n              }\n            }\n            const [type, isFlag] = handlers[argName];\n            if (!isFlag && j + 1 < separatedArguments.length) {\n              throw new ArgError(\n                `option requires argument (but was followed by another short argument): ${originalArgName}`,\n                \"ARG_MISSING_REQUIRED_SHORTARG\"\n              );\n            }\n            if (isFlag) {\n              result[argName] = type(true, argName, result[argName]);\n            } else if (argStr === void 0) {\n              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === \"-\" && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number || typeof BigInt !== \"undefined\" && type === BigInt))) {\n                const extended = originalArgName === argName ? \"\" : ` (alias for ${argName})`;\n                throw new ArgError(\n                  `option requires argument: ${originalArgName}${extended}`,\n                  \"ARG_MISSING_REQUIRED_LONGARG\"\n                );\n              }\n              result[argName] = type(argv[i + 1], argName, result[argName]);\n              ++i;\n            } else {\n              result[argName] = type(argStr, argName, result[argName]);\n            }\n          }\n        } else {\n          result._.push(wholeArg);\n        }\n      }\n      return result;\n    }\n    __name(arg2, \"arg\");\n    arg2.flag = (fn) => {\n      fn[flagSymbol] = true;\n      return fn;\n    };\n    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);\n    arg2.ArgError = ArgError;\n    module2.exports = arg2;\n  }\n});\n\n// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js\nvar require_min_indent = __commonJS({\n  \"../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (string) => {\n      const match = string.match(/^[ \\t]*(?=\\S)/gm);\n      if (!match) {\n        return 0;\n      }\n      return match.reduce((r, a) => Math.min(r, a.length), Infinity);\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js\nvar require_strip_indent = __commonJS({\n  \"../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js\"(exports, module2) {\n    \"use strict\";\n    var minIndent = require_min_indent();\n    module2.exports = (string) => {\n      const indent4 = minIndent(string);\n      if (indent4 === 0) {\n        return string;\n      }\n      const regex = new RegExp(`^[ \\\\t]{${indent4}}`, \"gm\");\n      return string.replace(regex, \"\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js\nvar require_pluralize = __commonJS({\n  \"../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js\"(exports, module2) {\n    (function(root, pluralize2) {\n      if ( true && typeof exports === \"object\" && typeof module2 === \"object\") {\n        module2.exports = pluralize2();\n      } else if (false) {} else {\n        root.pluralize = pluralize2();\n      }\n    })(exports, function() {\n      var pluralRules = [];\n      var singularRules = [];\n      var uncountables = {};\n      var irregularPlurals = {};\n      var irregularSingles = {};\n      function sanitizeRule(rule) {\n        if (typeof rule === \"string\") {\n          return new RegExp(\"^\" + rule + \"$\", \"i\");\n        }\n        return rule;\n      }\n      __name(sanitizeRule, \"sanitizeRule\");\n      function restoreCase(word, token) {\n        if (word === token)\n          return token;\n        if (word === word.toLowerCase())\n          return token.toLowerCase();\n        if (word === word.toUpperCase())\n          return token.toUpperCase();\n        if (word[0] === word[0].toUpperCase()) {\n          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();\n        }\n        return token.toLowerCase();\n      }\n      __name(restoreCase, \"restoreCase\");\n      function interpolate(str, args) {\n        return str.replace(/\\$(\\d{1,2})/g, function(match, index) {\n          return args[index] || \"\";\n        });\n      }\n      __name(interpolate, \"interpolate\");\n      function replace(word, rule) {\n        return word.replace(rule[0], function(match, index) {\n          var result = interpolate(rule[1], arguments);\n          if (match === \"\") {\n            return restoreCase(word[index - 1], result);\n          }\n          return restoreCase(match, result);\n        });\n      }\n      __name(replace, \"replace\");\n      function sanitizeWord(token, word, rules) {\n        if (!token.length || uncountables.hasOwnProperty(token)) {\n          return word;\n        }\n        var len = rules.length;\n        while (len--) {\n          var rule = rules[len];\n          if (rule[0].test(word))\n            return replace(word, rule);\n        }\n        return word;\n      }\n      __name(sanitizeWord, \"sanitizeWord\");\n      function replaceWord(replaceMap, keepMap, rules) {\n        return function(word) {\n          var token = word.toLowerCase();\n          if (keepMap.hasOwnProperty(token)) {\n            return restoreCase(word, token);\n          }\n          if (replaceMap.hasOwnProperty(token)) {\n            return restoreCase(word, replaceMap[token]);\n          }\n          return sanitizeWord(token, word, rules);\n        };\n      }\n      __name(replaceWord, \"replaceWord\");\n      function checkWord(replaceMap, keepMap, rules, bool) {\n        return function(word) {\n          var token = word.toLowerCase();\n          if (keepMap.hasOwnProperty(token))\n            return true;\n          if (replaceMap.hasOwnProperty(token))\n            return false;\n          return sanitizeWord(token, token, rules) === token;\n        };\n      }\n      __name(checkWord, \"checkWord\");\n      function pluralize2(word, count2, inclusive) {\n        var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);\n        return (inclusive ? count2 + \" \" : \"\") + pluralized;\n      }\n      __name(pluralize2, \"pluralize\");\n      pluralize2.plural = replaceWord(\n        irregularSingles,\n        irregularPlurals,\n        pluralRules\n      );\n      pluralize2.isPlural = checkWord(\n        irregularSingles,\n        irregularPlurals,\n        pluralRules\n      );\n      pluralize2.singular = replaceWord(\n        irregularPlurals,\n        irregularSingles,\n        singularRules\n      );\n      pluralize2.isSingular = checkWord(\n        irregularPlurals,\n        irregularSingles,\n        singularRules\n      );\n      pluralize2.addPluralRule = function(rule, replacement) {\n        pluralRules.push([sanitizeRule(rule), replacement]);\n      };\n      pluralize2.addSingularRule = function(rule, replacement) {\n        singularRules.push([sanitizeRule(rule), replacement]);\n      };\n      pluralize2.addUncountableRule = function(word) {\n        if (typeof word === \"string\") {\n          uncountables[word.toLowerCase()] = true;\n          return;\n        }\n        pluralize2.addPluralRule(word, \"$0\");\n        pluralize2.addSingularRule(word, \"$0\");\n      };\n      pluralize2.addIrregularRule = function(single, plural) {\n        plural = plural.toLowerCase();\n        single = single.toLowerCase();\n        irregularSingles[single] = plural;\n        irregularPlurals[plural] = single;\n      };\n      [\n        [\"I\", \"we\"],\n        [\"me\", \"us\"],\n        [\"he\", \"they\"],\n        [\"she\", \"they\"],\n        [\"them\", \"them\"],\n        [\"myself\", \"ourselves\"],\n        [\"yourself\", \"yourselves\"],\n        [\"itself\", \"themselves\"],\n        [\"herself\", \"themselves\"],\n        [\"himself\", \"themselves\"],\n        [\"themself\", \"themselves\"],\n        [\"is\", \"are\"],\n        [\"was\", \"were\"],\n        [\"has\", \"have\"],\n        [\"this\", \"these\"],\n        [\"that\", \"those\"],\n        [\"echo\", \"echoes\"],\n        [\"dingo\", \"dingoes\"],\n        [\"volcano\", \"volcanoes\"],\n        [\"tornado\", \"tornadoes\"],\n        [\"torpedo\", \"torpedoes\"],\n        [\"genus\", \"genera\"],\n        [\"viscus\", \"viscera\"],\n        [\"stigma\", \"stigmata\"],\n        [\"stoma\", \"stomata\"],\n        [\"dogma\", \"dogmata\"],\n        [\"lemma\", \"lemmata\"],\n        [\"schema\", \"schemata\"],\n        [\"anathema\", \"anathemata\"],\n        [\"ox\", \"oxen\"],\n        [\"axe\", \"axes\"],\n        [\"die\", \"dice\"],\n        [\"yes\", \"yeses\"],\n        [\"foot\", \"feet\"],\n        [\"eave\", \"eaves\"],\n        [\"goose\", \"geese\"],\n        [\"tooth\", \"teeth\"],\n        [\"quiz\", \"quizzes\"],\n        [\"human\", \"humans\"],\n        [\"proof\", \"proofs\"],\n        [\"carve\", \"carves\"],\n        [\"valve\", \"valves\"],\n        [\"looey\", \"looies\"],\n        [\"thief\", \"thieves\"],\n        [\"groove\", \"grooves\"],\n        [\"pickaxe\", \"pickaxes\"],\n        [\"passerby\", \"passersby\"]\n      ].forEach(function(rule) {\n        return pluralize2.addIrregularRule(rule[0], rule[1]);\n      });\n      [\n        [/s?$/i, \"s\"],\n        [/[^\\u0000-\\u007F]$/i, \"$0\"],\n        [/([^aeiou]ese)$/i, \"$1\"],\n        [/(ax|test)is$/i, \"$1es\"],\n        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, \"$1es\"],\n        [/(e[mn]u)s?$/i, \"$1s\"],\n        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, \"$1\"],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, \"$1i\"],\n        [/(alumn|alg|vertebr)(?:a|ae)$/i, \"$1ae\"],\n        [/(seraph|cherub)(?:im)?$/i, \"$1im\"],\n        [/(her|at|gr)o$/i, \"$1oes\"],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, \"$1a\"],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, \"$1a\"],\n        [/sis$/i, \"ses\"],\n        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, \"$1$2ves\"],\n        [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n        [/([^ch][ieo][ln])ey$/i, \"$1ies\"],\n        [/(x|ch|ss|sh|zz)$/i, \"$1es\"],\n        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, \"$1ices\"],\n        [/\\b((?:tit)?m|l)(?:ice|ouse)$/i, \"$1ice\"],\n        [/(pe)(?:rson|ople)$/i, \"$1ople\"],\n        [/(child)(?:ren)?$/i, \"$1ren\"],\n        [/eaux$/i, \"$0\"],\n        [/m[ae]n$/i, \"men\"],\n        [\"thou\", \"you\"]\n      ].forEach(function(rule) {\n        return pluralize2.addPluralRule(rule[0], rule[1]);\n      });\n      [\n        [/s$/i, \"\"],\n        [/(ss)$/i, \"$1\"],\n        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\\w]|^)li)ves$/i, \"$1fe\"],\n        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, \"$1f\"],\n        [/ies$/i, \"y\"],\n        [/\\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, \"$1ie\"],\n        [/\\b(mon|smil)ies$/i, \"$1ey\"],\n        [/\\b((?:tit)?m|l)ice$/i, \"$1ouse\"],\n        [/(seraph|cherub)im$/i, \"$1\"],\n        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, \"$1\"],\n        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, \"$1sis\"],\n        [/(movie|twelve|abuse|e[mn]u)s$/i, \"$1\"],\n        [/(test)(?:is|es)$/i, \"$1is\"],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, \"$1us\"],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, \"$1um\"],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, \"$1on\"],\n        [/(alumn|alg|vertebr)ae$/i, \"$1a\"],\n        [/(cod|mur|sil|vert|ind)ices$/i, \"$1ex\"],\n        [/(matr|append)ices$/i, \"$1ix\"],\n        [/(pe)(rson|ople)$/i, \"$1rson\"],\n        [/(child)ren$/i, \"$1\"],\n        [/(eau)x?$/i, \"$1\"],\n        [/men$/i, \"man\"]\n      ].forEach(function(rule) {\n        return pluralize2.addSingularRule(rule[0], rule[1]);\n      });\n      [\n        \"adulthood\",\n        \"advice\",\n        \"agenda\",\n        \"aid\",\n        \"aircraft\",\n        \"alcohol\",\n        \"ammo\",\n        \"analytics\",\n        \"anime\",\n        \"athletics\",\n        \"audio\",\n        \"bison\",\n        \"blood\",\n        \"bream\",\n        \"buffalo\",\n        \"butter\",\n        \"carp\",\n        \"cash\",\n        \"chassis\",\n        \"chess\",\n        \"clothing\",\n        \"cod\",\n        \"commerce\",\n        \"cooperation\",\n        \"corps\",\n        \"debris\",\n        \"diabetes\",\n        \"digestion\",\n        \"elk\",\n        \"energy\",\n        \"equipment\",\n        \"excretion\",\n        \"expertise\",\n        \"firmware\",\n        \"flounder\",\n        \"fun\",\n        \"gallows\",\n        \"garbage\",\n        \"graffiti\",\n        \"hardware\",\n        \"headquarters\",\n        \"health\",\n        \"herpes\",\n        \"highjinks\",\n        \"homework\",\n        \"housework\",\n        \"information\",\n        \"jeans\",\n        \"justice\",\n        \"kudos\",\n        \"labour\",\n        \"literature\",\n        \"machinery\",\n        \"mackerel\",\n        \"mail\",\n        \"media\",\n        \"mews\",\n        \"moose\",\n        \"music\",\n        \"mud\",\n        \"manga\",\n        \"news\",\n        \"only\",\n        \"personnel\",\n        \"pike\",\n        \"plankton\",\n        \"pliers\",\n        \"police\",\n        \"pollution\",\n        \"premises\",\n        \"rain\",\n        \"research\",\n        \"rice\",\n        \"salmon\",\n        \"scissors\",\n        \"series\",\n        \"sewage\",\n        \"shambles\",\n        \"shrimp\",\n        \"software\",\n        \"species\",\n        \"staff\",\n        \"swine\",\n        \"tennis\",\n        \"traffic\",\n        \"transportation\",\n        \"trout\",\n        \"tuna\",\n        \"wealth\",\n        \"welfare\",\n        \"whiting\",\n        \"wildebeest\",\n        \"wildlife\",\n        \"you\",\n        /pok[e]mon$/i,\n        /[^aeiou]ese$/i,\n        /deer$/i,\n        /fish$/i,\n        /measles$/i,\n        /o[iu]s$/i,\n        /pox$/i,\n        /sheep$/i\n      ].forEach(pluralize2.addUncountableRule);\n      return pluralize2;\n    });\n  }\n});\n\n// ../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js\nvar require_is_regexp = __commonJS({\n  \"../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (input) => Object.prototype.toString.call(input) === \"[object RegExp]\";\n  }\n});\n\n// ../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js\nvar require_is_obj = __commonJS({\n  \"../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (value) => {\n      const type = typeof value;\n      return value !== null && (type === \"object\" || type === \"function\");\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js\nvar require_lib = __commonJS({\n  \"../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));\n  }\n});\n\n// package.json\nvar require_package2 = __commonJS({\n  \"package.json\"(exports, module2) {\n    module2.exports = {\n      name: \"@prisma/client\",\n      version: \"4.3.1\",\n      description: \"Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.\",\n      keywords: [\n        \"orm\",\n        \"prisma2\",\n        \"prisma\",\n        \"client\",\n        \"query\",\n        \"database\",\n        \"sql\",\n        \"postgres\",\n        \"postgresql\",\n        \"mysql\",\n        \"sqlite\",\n        \"mariadb\",\n        \"mssql\",\n        \"typescript\",\n        \"query-builder\"\n      ],\n      main: \"index.js\",\n      browser: \"index-browser.js\",\n      types: \"index.d.ts\",\n      license: \"Apache-2.0\",\n      engines: {\n        node: \">=14.17\"\n      },\n      homepage: \"https://www.prisma.io\",\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/prisma/prisma.git\",\n        directory: \"packages/client\"\n      },\n      author: \"Tim Suchanek <suchanek@prisma.io>\",\n      bugs: \"https://github.com/prisma/prisma/issues\",\n      scripts: {\n        dev: \"DEV=true node -r esbuild-register helpers/build.ts\",\n        build: \"node -r esbuild-register helpers/build.ts\",\n        test: \"jest --verbose\",\n        \"test:functional\": \"node -r esbuild-register helpers/functional-test/run-tests.ts\",\n        \"test:memory\": \"node -r esbuild-register helpers/memory-tests.ts\",\n        \"test:functional:code\": \"node -r esbuild-register helpers/functional-test/run-tests.ts --no-types\",\n        \"test:functional:types\": \"node -r esbuild-register helpers/functional-test/run-tests.ts --types-only\",\n        \"test-notypes\": \"jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts\",\n        generate: \"node scripts/postinstall.js\",\n        postinstall: \"node scripts/postinstall.js\",\n        prepublishOnly: \"pnpm run build\",\n        \"new-test\": \"NODE_OPTIONS='-r ts-node/register' yo ./helpers/generator-test/index.ts\"\n      },\n      files: [\n        \"README.md\",\n        \"runtime\",\n        \"scripts\",\n        \"generator-build\",\n        \"edge.js\",\n        \"edge.d.ts\",\n        \"index.js\",\n        \"index.d.ts\",\n        \"index-browser.js\"\n      ],\n      devDependencies: {\n        \"@faker-js/faker\": \"7.4.0\",\n        \"@jest/test-sequencer\": \"28.1.3\",\n        \"@microsoft/api-extractor\": \"7.29.5\",\n        \"@opentelemetry/api\": \"1.1.0\",\n        \"@opentelemetry/context-async-hooks\": \"1.5.0\",\n        \"@opentelemetry/instrumentation\": \"0.31.0\",\n        \"@opentelemetry/resources\": \"1.5.0\",\n        \"@opentelemetry/sdk-trace-base\": \"1.5.0\",\n        \"@opentelemetry/semantic-conventions\": \"1.5.0\",\n        \"@prisma/debug\": \"workspace:4.3.1\",\n        \"@prisma/engine-core\": \"workspace:4.3.1\",\n        \"@prisma/engines\": \"workspace:4.3.1\",\n        \"@prisma/fetch-engine\": \"workspace:4.3.1\",\n        \"@prisma/generator-helper\": \"workspace:4.3.1\",\n        \"@prisma/get-platform\": \"workspace:4.3.1\",\n        \"@prisma/instrumentation\": \"workspace:4.3.1\",\n        \"@prisma/internals\": \"workspace:4.3.1\",\n        \"@prisma/migrate\": \"workspace:4.3.1\",\n        \"@swc-node/register\": \"1.5.1\",\n        \"@swc/core\": \"1.2.242\",\n        \"@swc/jest\": \"0.2.22\",\n        \"@timsuchanek/copy\": \"1.4.5\",\n        \"@types/debug\": \"4.1.7\",\n        \"@types/jest\": \"28.1.7\",\n        \"@types/js-levenshtein\": \"1.1.1\",\n        \"@types/mssql\": \"8.1.1\",\n        \"@types/node\": \"14.18.26\",\n        \"@types/pg\": \"8.6.5\",\n        \"@types/yeoman-generator\": \"5.2.11\",\n        arg: \"5.0.2\",\n        benchmark: \"2.1.4\",\n        chalk: \"4.1.2\",\n        cuid: \"2.1.8\",\n        \"decimal.js\": \"10.4.0\",\n        esbuild: \"0.15.5\",\n        execa: \"5.1.1\",\n        \"expect-type\": \"0.13.0\",\n        \"flat-map-polyfill\": \"0.3.8\",\n        \"fs-extra\": \"10.1.0\",\n        \"fs-monkey\": \"1.0.3\",\n        \"get-own-enumerable-property-symbols\": \"3.0.2\",\n        globby: \"11.1.0\",\n        \"indent-string\": \"4.0.0\",\n        \"is-obj\": \"2.0.0\",\n        \"is-regexp\": \"2.1.0\",\n        jest: \"28.1.3\",\n        \"jest-junit\": \"14.0.0\",\n        \"jest-snapshot\": \"28.1.3\",\n        \"js-levenshtein\": \"1.1.6\",\n        klona: \"2.0.5\",\n        \"lz-string\": \"1.4.4\",\n        \"make-dir\": \"3.1.0\",\n        mariadb: \"3.0.1\",\n        memfs: \"3.4.7\",\n        mssql: \"9.0.1\",\n        pg: \"8.8.0\",\n        \"pkg-up\": \"3.1.0\",\n        pluralize: \"8.0.0\",\n        \"replace-string\": \"3.1.0\",\n        resolve: \"1.22.1\",\n        rimraf: \"3.0.2\",\n        \"simple-statistics\": \"7.7.6\",\n        \"sort-keys\": \"4.2.0\",\n        \"source-map-support\": \"0.5.21\",\n        \"sql-template-tag\": \"5.0.3\",\n        \"stacktrace-parser\": \"0.1.10\",\n        \"strip-ansi\": \"6.0.1\",\n        \"strip-indent\": \"3.0.0\",\n        \"ts-jest\": \"28.0.8\",\n        \"ts-node\": \"10.9.1\",\n        tsd: \"0.21.0\",\n        typescript: \"4.8.2\",\n        \"yeoman-generator\": \"5.7.0\",\n        yo: \"4.3.0\"\n      },\n      peerDependencies: {\n        prisma: \"*\"\n      },\n      peerDependenciesMeta: {\n        prisma: {\n          optional: true\n        }\n      },\n      dependencies: {\n        \"@prisma/engines-version\": \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\"\n      },\n      sideEffects: false\n    };\n  }\n});\n\n// src/runtime/index.ts\nvar runtime_exports = {};\n__export(runtime_exports, {\n  DMMF: () => DMMF,\n  DMMFClass: () => DMMFHelper,\n  Debug: () => Debug,\n  Decimal: () => decimal_default,\n  Engine: () => Engine,\n  MetricsClient: () => MetricsClient,\n  NotFoundError: () => NotFoundError2,\n  PrismaClientInitializationError: () => PrismaClientInitializationError,\n  PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,\n  PrismaClientRustPanicError: () => PrismaClientRustPanicError,\n  PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,\n  PrismaClientValidationError: () => PrismaClientValidationError,\n  Sql: () => Sql,\n  decompressFromBase64: () => decompressFromBase642,\n  empty: () => empty,\n  findSync: () => findSync,\n  getPrismaClient: () => getPrismaClient,\n  join: () => join,\n  makeDocument: () => makeDocument,\n  makeStrictEnum: () => makeStrictEnum,\n  objectEnumValues: () => objectEnumValues,\n  raw: () => raw,\n  sqltag: () => sql,\n  transformDocument: () => transformDocument,\n  unpack: () => unpack,\n  warnEnvConflicts: () => warnEnvConflicts\n});\nmodule.exports = __toCommonJS(runtime_exports);\nvar lzString = __toESM(require_lz_string());\n\n// src/runtime/core/metrics/MetricsClient.ts\nvar MetricsClient = class {\n  constructor(engine) {\n    this._engine = engine;\n  }\n  prometheus(options) {\n    return this._engine.metrics({ format: \"prometheus\", ...options });\n  }\n  json(options) {\n    return this._engine.metrics({ format: \"json\", ...options });\n  }\n};\n__name(MetricsClient, \"MetricsClient\");\n\n// src/runtime/utils/applyMixins.ts\nfunction applyMixins(derivedCtor, constructors) {\n  var _a3;\n  for (const baseCtor of constructors) {\n    for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        (_a3 = Object.getOwnPropertyDescriptor(baseCtor.prototype, name)) != null ? _a3 : /* @__PURE__ */ Object.create(null)\n      );\n    }\n  }\n}\n__name(applyMixins, \"applyMixins\");\n\n// src/runtime/utils/common.ts\nvar import_chalk = __toESM(require_source());\n\n// ../../node_modules/.pnpm/decimal.js@10.4.0/node_modules/decimal.js/decimal.mjs\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  precision: 20,\n  rounding: 4,\n  modulo: 1,\n  toExpNeg: -7,\n  toExpPos: 21,\n  minE: -EXP_LIMIT,\n  maxE: EXP_LIMIT,\n  crypto: false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0)\n    x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s)\n    return new Ctor(NaN);\n  if (min2.gt(max2))\n    throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0])\n    return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys)\n    return xs;\n  if (x.e !== y.e)\n    return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i])\n      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d)\n    return new Ctor(NaN);\n  if (!x.d[0])\n    return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3)\n      n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w)\n      for (; w % 10 == 0; w /= 10)\n        n--;\n    if (n < 0)\n      n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite())\n    return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero())\n    return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(x.s);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero())\n    return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.asin();\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return halfPi.minus(x);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1))\n    return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.e >= 0)\n    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1)\n    return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero())\n    return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s)\n      return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i)\n    x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0)\n      for (i = j; r.d[i] === t.d[i] && i--; )\n        ;\n  }\n  if (k)\n    r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1))\n      return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg2.d;\n  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; )\n        k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg2, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg2, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (x.d)\n      y.s = -y.s;\n    else\n      y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0])\n      y.s = -y.s;\n    else if (xd[0])\n      y = new Ctor(x);\n    else\n      return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; )\n      d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy)\n      len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i)\n    xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; )\n        xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; )\n    xd.pop();\n  for (; xd[0] === 0; xd.shift())\n    --e;\n  if (!xd[0])\n    return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0])\n    return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (!x.d)\n      y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0])\n      y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; )\n      d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; )\n    xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)\n    throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k)\n      k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0)\n      n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; )\n    r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; )\n    r.pop();\n  if (carry)\n    ++e;\n  else\n    r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0)\n    return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0)\n    rm = Ctor.rounding;\n  else\n    checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd)\n    return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1))\n      throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1)\n      break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d)\n      return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d)\n      return y.s ? x : y;\n    if (!y.d) {\n      if (y.s)\n        y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0])\n    return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1))\n    return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1))\n    return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1)\n      return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0)\n      s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)\n    return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k)\n        str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k)\n      str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; )\n    w /= 10;\n  return str + w;\n}\n__name(digitsToString, \"digitsToString\");\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\n__name(checkInt32, \"checkInt32\");\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10)\n    --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0)\n        rd = rd / 100 | 0;\n      else if (i == 1)\n        rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0)\n        rd = rd / 1e3 | 0;\n      else if (i == 1)\n        rd = rd / 100 | 0;\n      else if (i == 2)\n        rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\n__name(checkRoundingDigits, \"checkRoundingDigits\");\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; )\n      arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0)\n          arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\n__name(convertBase, \"convertBase\");\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero())\n    return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\n__name(cosine, \"cosine\");\nvar divide = function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry)\n      x.unshift(carry);\n    return x;\n  }\n  __name(multiplyInteger, \"multiplyInteger\");\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  __name(compare, \"compare\");\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; )\n      a.shift();\n  }\n  __name(subtract, \"subtract\");\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0\n      );\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++)\n      ;\n    if (yd[i] > (xd[i] || 0))\n      e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; )\n          rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2)\n          ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL)\n              rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base)\n                k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0)\n                cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL)\n              prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0])\n        qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10)\n        i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out:\n    if (sd != null) {\n      xd = x.d;\n      if (!xd)\n        return x;\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10)\n        digits++;\n      i = sd - digits;\n      if (i < 0) {\n        i += LOG_BASE;\n        j = sd;\n        w = xd[xdi = 0];\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n      } else {\n        xdi = Math.ceil((i + 1) / LOG_BASE);\n        k = xd.length;\n        if (xdi >= k) {\n          if (isTruncated) {\n            for (; k++ <= xdi; )\n              xd.push(0);\n            w = rd = 0;\n            digits = 1;\n            i %= LOG_BASE;\n            j = i - LOG_BASE + 1;\n          } else {\n            break out;\n          }\n        } else {\n          w = k = xd[xdi];\n          for (digits = 1; k >= 10; k /= 10)\n            digits++;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + digits;\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n        }\n      }\n      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n      if (sd < 1 || !xd[0]) {\n        xd.length = 0;\n        if (roundUp) {\n          sd -= x.e + 1;\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n          x.e = -sd || 0;\n        } else {\n          xd[0] = x.e = 0;\n        }\n        return x;\n      }\n      if (i == 0) {\n        xd.length = xdi;\n        k = 1;\n        xdi--;\n      } else {\n        xd.length = xdi + 1;\n        k = mathpow(10, LOG_BASE - i);\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n      }\n      if (roundUp) {\n        for (; ; ) {\n          if (xdi == 0) {\n            for (i = 1, j = xd[0]; j >= 10; j /= 10)\n              i++;\n            j = xd[0] += k;\n            for (k = 1; j >= 10; j /= 10)\n              k++;\n            if (i != k) {\n              x.e++;\n              if (xd[0] == BASE)\n                xd[0] = 1;\n            }\n            break;\n          } else {\n            xd[xdi] += k;\n            if (xd[xdi] != BASE)\n              break;\n            xd[xdi--] = 0;\n            k = 1;\n          }\n        }\n      }\n      for (i = xd.length; xd[--i] === 0; )\n        xd.pop();\n    }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\n__name(finalise, \"finalise\");\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite())\n    return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0)\n      str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0)\n      str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len)\n      str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len)\n        str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\n__name(finiteToString, \"finiteToString\");\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10)\n    e++;\n  return e;\n}\n__name(getBase10Exponent, \"getBase10Exponent\");\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr)\n      Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\n__name(getLn10, \"getLn10\");\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION)\n    throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\n__name(getPi, \"getPi\");\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10)\n      len--;\n    for (w = digits[0]; w >= 10; w /= 10)\n      len++;\n  }\n  return len;\n}\n__name(getPrecision, \"getPrecision\");\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; )\n    zs += \"0\";\n  return zs;\n}\n__name(getZeroString, \"getZeroString\");\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k))\n        isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0)\n        ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\n__name(intPow, \"intPow\");\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\n__name(isOdd, \"isOdd\");\nfunction maxOrMin(Ctor, args, ltgt) {\n  var y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    } else if (x[ltgt](y)) {\n      x = y;\n    }\n  }\n  return x;\n}\n__name(maxOrMin, \"maxOrMin\");\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum3 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum3.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {\n      j = k;\n      while (j--)\n        sum3 = finalise(sum3.times(sum3), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum3, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum3;\n      }\n    }\n    sum3 = t;\n  }\n}\n__name(naturalExponential, \"naturalExponential\");\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {\n      sum3 = sum3.times(2);\n      if (e !== 0)\n        sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum3 = divide(sum3, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum3, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum3;\n      }\n    }\n    sum3 = t;\n    denominator += 2;\n  }\n}\n__name(naturalLogarithm, \"naturalLogarithm\");\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\n__name(nonFiniteToString, \"nonFiniteToString\");\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1)\n    str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0)\n      e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++)\n    ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)\n    ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0)\n      i += LOG_BASE;\n    if (i < len) {\n      if (i)\n        x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; )\n        x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; )\n      str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\n__name(parseDecimal, \"parseDecimal\");\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str))\n      return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str)\n      x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i)\n    xd.pop();\n  if (i < 0)\n    return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat)\n    x = divide(x, divisor, len * 4);\n  if (p)\n    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\n__name(parseOther, \"parseOther\");\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\n__name(sine, \"sine\");\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; )\n        ;\n      if (j == -1)\n        break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\n__name(taylorSeries, \"taylorSeries\");\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e)\n    n *= b;\n  return n;\n}\n__name(tinyPow, \"tinyPow\");\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\n__name(toLessThanHalfPi, \"toLessThanHalfPi\");\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; )\n      xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len)\n        ;\n      for (i = 0, str = \"\"; i < len; i++)\n        str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++)\n              str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len)\n              ;\n            for (i = 1, str = \"1.\"; i < len; i++)\n              str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; )\n          str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len)\n          for (e -= len; e--; )\n            str += \"0\";\n        else if (e < len)\n          str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\n__name(toStringBinary, \"toStringBinary\");\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\n__name(truncate, \"truncate\");\nfunction abs(x) {\n  return new this(x).abs();\n}\n__name(abs, \"abs\");\nfunction acos(x) {\n  return new this(x).acos();\n}\n__name(acos, \"acos\");\nfunction acosh(x) {\n  return new this(x).acosh();\n}\n__name(acosh, \"acosh\");\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\n__name(add, \"add\");\nfunction asin(x) {\n  return new this(x).asin();\n}\n__name(asin, \"asin\");\nfunction asinh(x) {\n  return new this(x).asinh();\n}\n__name(asinh, \"asinh\");\nfunction atan(x) {\n  return new this(x).atan();\n}\n__name(atan, \"atan\");\nfunction atanh(x) {\n  return new this(x).atanh();\n}\n__name(atanh, \"atanh\");\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\n__name(atan2, \"atan2\");\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\n__name(cbrt, \"cbrt\");\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\n__name(ceil, \"ceil\");\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\n__name(clamp, \"clamp\");\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\")\n    throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults)\n      this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])\n        this[p] = v;\n      else\n        throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults)\n    this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\n__name(config, \"config\");\nfunction cos(x) {\n  return new this(x).cos();\n}\n__name(cos, \"cos\");\nfunction cosh(x) {\n  return new this(x).cosh();\n}\n__name(cosh, \"cosh\");\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2))\n      return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)\n          e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      } else if (v * 0 !== 0) {\n        if (!v)\n          x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    } else if (t !== \"string\") {\n      throw Error(invalidArgument + v);\n    }\n    if ((i2 = v.charCodeAt(0)) === 45) {\n      v = v.slice(1);\n      x.s = -1;\n    } else {\n      if (i2 === 43)\n        v = v.slice(1);\n      x.s = 1;\n    }\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n  }\n  __name(Decimal2, \"Decimal\");\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0)\n    obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; )\n        if (!obj.hasOwnProperty(p = ps[i++]))\n          obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\n__name(clone, \"clone\");\nfunction div(x, y) {\n  return new this(x).div(y);\n}\n__name(div, \"div\");\nfunction exp(x) {\n  return new this(x).exp();\n}\n__name(exp, \"exp\");\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\n__name(floor, \"floor\");\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\n__name(hypot, \"hypot\");\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n__name(isDecimalInstance, \"isDecimalInstance\");\nfunction ln(x) {\n  return new this(x).ln();\n}\n__name(ln, \"ln\");\nfunction log(x, y) {\n  return new this(x).log(y);\n}\n__name(log, \"log\");\nfunction log2(x) {\n  return new this(x).log(2);\n}\n__name(log2, \"log2\");\nfunction log10(x) {\n  return new this(x).log(10);\n}\n__name(log10, \"log10\");\nfunction max() {\n  return maxOrMin(this, arguments, \"lt\");\n}\n__name(max, \"max\");\nfunction min() {\n  return maxOrMin(this, arguments, \"gt\");\n}\n__name(min, \"min\");\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\n__name(mod, \"mod\");\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\n__name(mul, \"mul\");\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\n__name(pow, \"pow\");\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0)\n    sd = this.precision;\n  else\n    checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; )\n      rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--)\n    rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE)\n      rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10)\n      k++;\n    if (k < LOG_BASE)\n      e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\n__name(random, \"random\");\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n__name(round, \"round\");\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n__name(sign, \"sign\");\nfunction sin(x) {\n  return new this(x).sin();\n}\n__name(sin, \"sin\");\nfunction sinh(x) {\n  return new this(x).sinh();\n}\n__name(sinh, \"sinh\");\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\n__name(sqrt, \"sqrt\");\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\n__name(sub, \"sub\");\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; )\n    x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\n__name(sum, \"sum\");\nfunction tan(x) {\n  return new this(x).tan();\n}\n__name(tan, \"tan\");\nfunction tanh(x) {\n  return new this(x).tanh();\n}\n__name(tanh, \"tanh\");\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\n__name(trunc, \"trunc\");\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\nvar decimal_default = Decimal;\n\n// src/runtime/utils/common.ts\nvar import_indent_string = __toESM(require_indent_string());\nvar import_js_levenshtein = __toESM(require_js_levenshtein());\n\n// src/runtime/core/model/FieldRef.ts\nvar FieldRefImpl = class {\n  constructor(modelName, name, fieldType, isList) {\n    this.modelName = modelName;\n    this.name = name;\n    this.typeName = fieldType;\n    this.isList = isList;\n  }\n  _toGraphQLInputType() {\n    const prefix = this.isList ? `List${this.typeName}` : this.typeName;\n    return `${prefix}FieldRefInput<${this.modelName}>`;\n  }\n};\n__name(FieldRefImpl, \"FieldRefImpl\");\n\n// src/runtime/object-enums.ts\nvar objectEnumNames = [\"JsonNullValueInput\", \"NullableJsonNullValueInput\", \"JsonNullValueFilter\"];\nvar secret = Symbol();\nvar representations = /* @__PURE__ */ new WeakMap();\nvar ObjectEnumValue = class {\n  constructor(arg2) {\n    if (arg2 === secret) {\n      representations.set(this, `Prisma.${this._getName()}`);\n    } else {\n      representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);\n    }\n  }\n  _getName() {\n    return this.constructor.name;\n  }\n  toString() {\n    return representations.get(this);\n  }\n};\n__name(ObjectEnumValue, \"ObjectEnumValue\");\nvar NullTypesEnumValue = class extends ObjectEnumValue {\n  _getNamespace() {\n    return \"NullTypes\";\n  }\n};\n__name(NullTypesEnumValue, \"NullTypesEnumValue\");\nvar DbNull = class extends NullTypesEnumValue {\n};\n__name(DbNull, \"DbNull\");\nvar JsonNull = class extends NullTypesEnumValue {\n};\n__name(JsonNull, \"JsonNull\");\nvar AnyNull = class extends NullTypesEnumValue {\n};\n__name(AnyNull, \"AnyNull\");\nvar objectEnumValues = {\n  classes: {\n    DbNull,\n    JsonNull,\n    AnyNull\n  },\n  instances: {\n    DbNull: new DbNull(secret),\n    JsonNull: new JsonNull(secret),\n    AnyNull: new AnyNull(secret)\n  }\n};\n\n// src/runtime/utils/decimalJsLike.ts\nfunction isDecimalJsLike(value) {\n  if (Decimal.isDecimal(value)) {\n    return true;\n  }\n  return value !== null && typeof value === \"object\" && typeof value.s === \"number\" && typeof value.e === \"number\" && Array.isArray(value.d);\n}\n__name(isDecimalJsLike, \"isDecimalJsLike\");\nfunction stringifyDecimalJsLike(value) {\n  if (Decimal.isDecimal(value)) {\n    return String(value);\n  }\n  const tmpDecimal = new Decimal(0);\n  tmpDecimal.d = value.d;\n  tmpDecimal.e = value.e;\n  tmpDecimal.s = value.s;\n  return String(tmpDecimal);\n}\n__name(stringifyDecimalJsLike, \"stringifyDecimalJsLike\");\n\n// src/runtime/utils/common.ts\nvar keyBy = /* @__PURE__ */ __name((collection, prop) => {\n  const acc = {};\n  for (const obj of collection) {\n    const key = obj[prop];\n    acc[key] = obj;\n  }\n  return acc;\n}, \"keyBy\");\nvar ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Decimal: true,\n  BigInt: true\n};\nvar JSTypeToGraphQLType = {\n  string: \"String\",\n  boolean: \"Boolean\",\n  object: \"Json\",\n  symbol: \"Symbol\"\n};\nfunction stringifyGraphQLType(type) {\n  if (typeof type === \"string\") {\n    return type;\n  }\n  return type.name;\n}\n__name(stringifyGraphQLType, \"stringifyGraphQLType\");\nfunction wrapWithList(str, isList) {\n  if (isList) {\n    return `List<${str}>`;\n  }\n  return str;\n}\n__name(wrapWithList, \"wrapWithList\");\nvar RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\nvar UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nfunction getGraphQLType(value, inputType) {\n  const potentialType = inputType == null ? void 0 : inputType.type;\n  if (value === null) {\n    return \"null\";\n  }\n  if (Object.prototype.toString.call(value) === \"[object BigInt]\") {\n    return \"BigInt\";\n  }\n  if (decimal_default.isDecimal(value)) {\n    return \"Decimal\";\n  }\n  if (potentialType === \"Decimal\" && isDecimalJsLike(value)) {\n    return \"Decimal\";\n  }\n  if (Buffer.isBuffer(value)) {\n    return \"Bytes\";\n  }\n  if (isValidEnumValue(value, inputType)) {\n    return potentialType.name;\n  }\n  if (value instanceof ObjectEnumValue) {\n    return value._getName();\n  }\n  if (value instanceof FieldRefImpl) {\n    return value._toGraphQLInputType();\n  }\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, inputType);\n      if (!acc.includes(type)) {\n        acc.push(type);\n      }\n      return acc;\n    }, []);\n    if (scalarTypes.includes(\"Float\") && scalarTypes.includes(\"Int\")) {\n      scalarTypes = [\"Float\"];\n    }\n    return `List<${scalarTypes.join(\" | \")}>`;\n  }\n  const jsType = typeof value;\n  if (jsType === \"number\") {\n    if (Math.trunc(value) === value) {\n      return \"Int\";\n    } else {\n      return \"Float\";\n    }\n  }\n  if (Object.prototype.toString.call(value) === \"[object Date]\") {\n    return \"DateTime\";\n  }\n  if (jsType === \"string\") {\n    if (UUID_REGEX.test(value)) {\n      return \"UUID\";\n    }\n    const date = new Date(value);\n    if (date.toString() === \"Invalid Date\") {\n      return \"String\";\n    }\n    if (RFC_3339_REGEX.test(value)) {\n      return \"DateTime\";\n    }\n  }\n  return JSTypeToGraphQLType[jsType];\n}\n__name(getGraphQLType, \"getGraphQLType\");\nfunction isValidEnumValue(value, inputType) {\n  var _a3;\n  const enumType = inputType == null ? void 0 : inputType.type;\n  if (!isSchemaEnum(enumType)) {\n    return false;\n  }\n  if ((inputType == null ? void 0 : inputType.namespace) === \"prisma\" && objectEnumNames.includes(enumType.name)) {\n    const name = (_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name;\n    return typeof name === \"string\" && objectEnumValues.instances[name] === value && enumType.values.includes(name);\n  }\n  return typeof value === \"string\" && enumType.values.includes(value);\n}\n__name(isValidEnumValue, \"isValidEnumValue\");\nfunction getSuggestion(str, possibilities) {\n  const bestMatch = possibilities.reduce(\n    (acc, curr) => {\n      const distance = (0, import_js_levenshtein.default)(str, curr);\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr\n        };\n      }\n      return acc;\n    },\n    {\n      distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),\n      str: null\n    }\n  );\n  return bestMatch.str;\n}\n__name(getSuggestion, \"getSuggestion\");\nfunction stringifyInputType(input, greenKeys = false) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  if (input.values) {\n    return `enum ${input.name} {\n${(0, import_indent_string.default)(input.values.join(\", \"), 2)}\n}`;\n  } else {\n    const body = (0, import_indent_string.default)(\n      input.fields.map((arg2) => {\n        const key = `${arg2.name}`;\n        const str = `${greenKeys ? import_chalk.default.green(key) : key}${arg2.isRequired ? \"\" : \"?\"}: ${import_chalk.default.white(\n          arg2.inputTypes.map((argType) => {\n            return wrapWithList(\n              argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type),\n              argType.isList\n            );\n          }).join(\" | \")\n        )}`;\n        if (!arg2.isRequired) {\n          return import_chalk.default.dim(str);\n        }\n        return str;\n      }).join(\"\\n\"),\n      2\n    );\n    return `${import_chalk.default.dim(\"type\")} ${import_chalk.default.bold.dim(input.name)} ${import_chalk.default.dim(\"{\")}\n${body}\n${import_chalk.default.dim(\"}\")}`;\n  }\n}\n__name(stringifyInputType, \"stringifyInputType\");\nfunction argIsInputType(arg2) {\n  if (typeof arg2 === \"string\") {\n    return false;\n  }\n  return true;\n}\n__name(argIsInputType, \"argIsInputType\");\nfunction getInputTypeName(input) {\n  if (typeof input === \"string\") {\n    if (input === \"Null\") {\n      return \"null\";\n    }\n    return input;\n  }\n  return input.name;\n}\n__name(getInputTypeName, \"getInputTypeName\");\nfunction getOutputTypeName(input) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  return input.name;\n}\n__name(getOutputTypeName, \"getOutputTypeName\");\nfunction inputTypeToJson(input, isRequired, nameOnly = false) {\n  if (typeof input === \"string\") {\n    if (input === \"Null\") {\n      return \"null\";\n    }\n    return input;\n  }\n  if (input.values) {\n    return input.values.join(\" | \");\n  }\n  const inputType = input;\n  const showDeepType = isRequired && inputType.fields.every(\n    (arg2) => {\n      var _a3;\n      return arg2.inputTypes[0].location === \"inputObjectTypes\" || ((_a3 = arg2.inputTypes[1]) == null ? void 0 : _a3.location) === \"inputObjectTypes\";\n    }\n  );\n  if (nameOnly) {\n    return getInputTypeName(input);\n  }\n  return inputType.fields.reduce((acc, curr) => {\n    let str = \"\";\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(\" | \");\n    } else {\n      str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(\" | \");\n    }\n    acc[curr.name + (curr.isRequired ? \"\" : \"?\")] = str;\n    return acc;\n  }, {});\n}\n__name(inputTypeToJson, \"inputTypeToJson\");\nfunction unionBy(arr1, arr2, iteratee) {\n  const map = {};\n  for (const element of arr1) {\n    map[iteratee(element)] = element;\n  }\n  for (const element of arr2) {\n    const key = iteratee(element);\n    if (!map[key]) {\n      map[key] = element;\n    }\n  }\n  return Object.values(map);\n}\n__name(unionBy, \"unionBy\");\nfunction lowerCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\n__name(lowerCase, \"lowerCase\");\nfunction isGroupByOutputName(type) {\n  return type.endsWith(\"GroupByOutputType\");\n}\n__name(isGroupByOutputName, \"isGroupByOutputName\");\nfunction isSchemaEnum(type) {\n  return typeof type === \"object\" && type !== null && typeof type.name === \"string\" && Array.isArray(type.values);\n}\n__name(isSchemaEnum, \"isSchemaEnum\");\n\n// src/runtime/dmmf.ts\nvar DMMFDatamodelHelper = class {\n  constructor({ datamodel }) {\n    this.datamodel = datamodel;\n    this.datamodelEnumMap = this.getDatamodelEnumMap();\n    this.modelMap = this.getModelMap();\n    this.typeMap = this.getTypeMap();\n    this.typeAndModelMap = this.getTypeModelMap();\n  }\n  getDatamodelEnumMap() {\n    return keyBy(this.datamodel.enums, \"name\");\n  }\n  getModelMap() {\n    return { ...keyBy(this.datamodel.models, \"name\") };\n  }\n  getTypeMap() {\n    return { ...keyBy(this.datamodel.types, \"name\") };\n  }\n  getTypeModelMap() {\n    return { ...this.getTypeMap(), ...this.getModelMap() };\n  }\n};\n__name(DMMFDatamodelHelper, \"DMMFDatamodelHelper\");\nvar DMMFMappingsHelper = class {\n  constructor({ mappings }) {\n    this.mappings = mappings;\n    this.mappingsMap = this.getMappingsMap();\n  }\n  getMappingsMap() {\n    return keyBy(this.mappings.modelOperations, \"model\");\n  }\n};\n__name(DMMFMappingsHelper, \"DMMFMappingsHelper\");\nvar DMMFSchemaHelper = class {\n  constructor({ schema }) {\n    this.outputTypeToMergedOutputType = /* @__PURE__ */ __name((outputType) => {\n      return {\n        ...outputType,\n        fields: outputType.fields\n      };\n    }, \"outputTypeToMergedOutputType\");\n    this.schema = schema;\n    this.enumMap = this.getEnumMap();\n    this.queryType = this.getQueryType();\n    this.mutationType = this.getMutationType();\n    this.outputTypes = this.getOutputTypes();\n    this.outputTypeMap = this.getMergedOutputTypeMap();\n    this.resolveOutputTypes();\n    this.inputObjectTypes = this.schema.inputObjectTypes;\n    this.inputTypeMap = this.getInputTypeMap();\n    this.resolveInputTypes();\n    this.resolveFieldArgumentTypes();\n    this.queryType = this.outputTypeMap.Query;\n    this.mutationType = this.outputTypeMap.Mutation;\n    this.rootFieldMap = this.getRootFieldMap();\n  }\n  get [Symbol.toStringTag]() {\n    return \"DMMFClass\";\n  }\n  resolveOutputTypes() {\n    for (const type of this.outputTypes.model) {\n      for (const field of type.fields) {\n        if (typeof field.outputType.type === \"string\" && !ScalarTypeTable[field.outputType.type]) {\n          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n    for (const type of this.outputTypes.prisma) {\n      for (const field of type.fields) {\n        if (typeof field.outputType.type === \"string\" && !ScalarTypeTable[field.outputType.type]) {\n          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n  }\n  resolveInputTypes() {\n    const inputTypes = this.inputObjectTypes.prisma;\n    if (this.inputObjectTypes.model) {\n      inputTypes.push(...this.inputObjectTypes.model);\n    }\n    for (const type of inputTypes) {\n      for (const field of type.fields) {\n        for (const fieldInputType of field.inputTypes) {\n          const fieldType = fieldInputType.type;\n          if (typeof fieldType === \"string\" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {\n            fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;\n          }\n        }\n      }\n      type.fieldMap = keyBy(type.fields, \"name\");\n    }\n  }\n  resolveFieldArgumentTypes() {\n    for (const type of this.outputTypes.prisma) {\n      for (const field of type.fields) {\n        for (const arg2 of field.args) {\n          for (const argInputType of arg2.inputTypes) {\n            const argType = argInputType.type;\n            if (typeof argType === \"string\" && !ScalarTypeTable[argType]) {\n              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;\n            }\n          }\n        }\n      }\n    }\n    for (const type of this.outputTypes.model) {\n      for (const field of type.fields) {\n        for (const arg2 of field.args) {\n          for (const argInputType of arg2.inputTypes) {\n            const argType = argInputType.type;\n            if (typeof argType === \"string\" && !ScalarTypeTable[argType]) {\n              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;\n            }\n          }\n        }\n      }\n    }\n  }\n  getQueryType() {\n    return this.schema.outputObjectTypes.prisma.find((t) => t.name === \"Query\");\n  }\n  getMutationType() {\n    return this.schema.outputObjectTypes.prisma.find((t) => t.name === \"Mutation\");\n  }\n  getOutputTypes() {\n    return {\n      model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),\n      prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)\n    };\n  }\n  getEnumMap() {\n    return {\n      ...keyBy(this.schema.enumTypes.prisma, \"name\"),\n      ...this.schema.enumTypes.model ? keyBy(this.schema.enumTypes.model, \"name\") : void 0\n    };\n  }\n  hasEnumInNamespace(enumName, namespace) {\n    var _a3;\n    return ((_a3 = this.schema.enumTypes[namespace]) == null ? void 0 : _a3.find((schemaEnum) => schemaEnum.name === enumName)) !== void 0;\n  }\n  getMergedOutputTypeMap() {\n    return {\n      ...keyBy(this.outputTypes.model, \"name\"),\n      ...keyBy(this.outputTypes.prisma, \"name\")\n    };\n  }\n  getInputTypeMap() {\n    return {\n      ...this.schema.inputObjectTypes.model ? keyBy(this.schema.inputObjectTypes.model, \"name\") : void 0,\n      ...keyBy(this.schema.inputObjectTypes.prisma, \"name\")\n    };\n  }\n  getRootFieldMap() {\n    return { ...keyBy(this.queryType.fields, \"name\"), ...keyBy(this.mutationType.fields, \"name\") };\n  }\n};\n__name(DMMFSchemaHelper, \"DMMFSchemaHelper\");\nvar BaseDMMFHelper = class {\n  constructor(dmmf) {\n    return Object.assign(this, new DMMFDatamodelHelper(dmmf), new DMMFMappingsHelper(dmmf));\n  }\n};\n__name(BaseDMMFHelper, \"BaseDMMFHelper\");\napplyMixins(BaseDMMFHelper, [DMMFDatamodelHelper, DMMFMappingsHelper]);\nvar DMMFHelper = class {\n  constructor(dmmf) {\n    return Object.assign(this, new BaseDMMFHelper(dmmf), new DMMFSchemaHelper(dmmf));\n  }\n};\n__name(DMMFHelper, \"DMMFHelper\");\napplyMixins(DMMFHelper, [BaseDMMFHelper, DMMFSchemaHelper]);\n\n// ../generator-helper/src/dmmf.ts\nvar DMMF;\n((DMMF2) => {\n  let ModelAction;\n  ((ModelAction2) => {\n    ModelAction2[\"findUnique\"] = \"findUnique\";\n    ModelAction2[\"findFirst\"] = \"findFirst\";\n    ModelAction2[\"findMany\"] = \"findMany\";\n    ModelAction2[\"create\"] = \"create\";\n    ModelAction2[\"createMany\"] = \"createMany\";\n    ModelAction2[\"update\"] = \"update\";\n    ModelAction2[\"updateMany\"] = \"updateMany\";\n    ModelAction2[\"upsert\"] = \"upsert\";\n    ModelAction2[\"delete\"] = \"delete\";\n    ModelAction2[\"deleteMany\"] = \"deleteMany\";\n    ModelAction2[\"groupBy\"] = \"groupBy\";\n    ModelAction2[\"count\"] = \"count\";\n    ModelAction2[\"aggregate\"] = \"aggregate\";\n    ModelAction2[\"findRaw\"] = \"findRaw\";\n    ModelAction2[\"aggregateRaw\"] = \"aggregateRaw\";\n  })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));\n})(DMMF || (DMMF = {}));\n\n// ../debug/src/index.ts\nvar import_debug = __toESM(require_src());\nvar MAX_LOGS = 100;\nvar debugArgsHistory = [];\nvar _a, _b;\nif (typeof process !== \"undefined\" && typeof ((_a = process.stderr) == null ? void 0 : _a.write) !== \"function\") {\n  import_debug.default.log = (_b = console.debug) != null ? _b : console.log;\n}\nfunction debugCall(namespace) {\n  const debugNamespace = (0, import_debug.default)(namespace);\n  const call = Object.assign((...args) => {\n    debugNamespace.log = call.log;\n    if (args.length !== 0) {\n      debugArgsHistory.push([namespace, ...args]);\n    }\n    if (debugArgsHistory.length > MAX_LOGS) {\n      debugArgsHistory.shift();\n    }\n    return debugNamespace(\"\", ...args);\n  }, debugNamespace);\n  return call;\n}\n__name(debugCall, \"debugCall\");\nvar Debug = Object.assign(debugCall, import_debug.default);\nfunction getLogs(numChars = 7500) {\n  const output = debugArgsHistory.map(\n    (c) => c.map((item) => {\n      if (typeof item === \"string\") {\n        return item;\n      }\n      return JSON.stringify(item);\n    }).join(\" \")\n  ).join(\"\\n\");\n  if (output.length < numChars) {\n    return output;\n  }\n  return output.slice(-numChars);\n}\n__name(getLogs, \"getLogs\");\nvar src_default = Debug;\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js\nvar _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/version.js\nvar VERSION = \"1.1.0\";\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js\nvar re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\nfunction _makeCompatibilityCheck(ownVersion) {\n  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);\n  var rejectedVersions = /* @__PURE__ */ new Set();\n  var myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    return function() {\n      return false;\n    };\n  }\n  var ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4]\n  };\n  if (ownVersionParsed.prerelease != null) {\n    return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {\n      return globalVersion === ownVersion;\n    }, \"isExactmatch\");\n  }\n  function _reject(v) {\n    rejectedVersions.add(v);\n    return false;\n  }\n  __name(_reject, \"_reject\");\n  function _accept(v) {\n    acceptedVersions.add(v);\n    return true;\n  }\n  __name(_accept, \"_accept\");\n  return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n    var globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      return _reject(globalVersion);\n    }\n    var globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4]\n    };\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major === 0) {\n      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {\n        return _accept(globalVersion);\n      }\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n    return _reject(globalVersion);\n  }, \"isCompatible\");\n}\n__name(_makeCompatibilityCheck, \"_makeCompatibilityCheck\");\nvar isCompatible = _makeCompatibilityCheck(VERSION);\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js\nvar major = VERSION.split(\".\")[0];\nvar GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\"opentelemetry.js.api.\" + major);\nvar _global = _globalThis;\nfunction registerGlobal(type, instance, diag3, allowOverride) {\n  var _a3;\n  if (allowOverride === void 0) {\n    allowOverride = false;\n  }\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a3 !== void 0 ? _a3 : {\n    version: VERSION\n  };\n  if (!allowOverride && api[type]) {\n    var err = new Error(\"@opentelemetry/api: Attempted duplicate registration of API: \" + type);\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  if (api.version !== VERSION) {\n    var err = new Error(\"@opentelemetry/api: All API registration versions must match\");\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  api[type] = instance;\n  diag3.debug(\"@opentelemetry/api: Registered a global for \" + type + \" v\" + VERSION + \".\");\n  return true;\n}\n__name(registerGlobal, \"registerGlobal\");\nfunction getGlobal(type) {\n  var _a3, _b2;\n  var globalVersion = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a3 === void 0 ? void 0 : _a3.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === void 0 ? void 0 : _b2[type];\n}\n__name(getGlobal, \"getGlobal\");\nfunction unregisterGlobal(type, diag3) {\n  diag3.debug(\"@opentelemetry/api: Unregistering a global for \" + type + \" v\" + VERSION + \".\");\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n  if (api) {\n    delete api[type];\n  }\n}\n__name(unregisterGlobal, \"unregisterGlobal\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js\nvar DiagComponentLogger = function() {\n  function DiagComponentLogger2(props) {\n    this._namespace = props.namespace || \"DiagComponentLogger\";\n  }\n  __name(DiagComponentLogger2, \"DiagComponentLogger\");\n  DiagComponentLogger2.prototype.debug = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"debug\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.error = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"error\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.info = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"info\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.warn = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"warn\", this._namespace, args);\n  };\n  DiagComponentLogger2.prototype.verbose = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return logProxy(\"verbose\", this._namespace, args);\n  };\n  return DiagComponentLogger2;\n}();\nfunction logProxy(funcName, namespace, args) {\n  var logger2 = getGlobal(\"diag\");\n  if (!logger2) {\n    return;\n  }\n  args.unshift(namespace);\n  return logger2[funcName].apply(logger2, args);\n}\n__name(logProxy, \"logProxy\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/types.js\nvar DiagLogLevel;\n(function(DiagLogLevel2) {\n  DiagLogLevel2[DiagLogLevel2[\"NONE\"] = 0] = \"NONE\";\n  DiagLogLevel2[DiagLogLevel2[\"ERROR\"] = 30] = \"ERROR\";\n  DiagLogLevel2[DiagLogLevel2[\"WARN\"] = 50] = \"WARN\";\n  DiagLogLevel2[DiagLogLevel2[\"INFO\"] = 60] = \"INFO\";\n  DiagLogLevel2[DiagLogLevel2[\"DEBUG\"] = 70] = \"DEBUG\";\n  DiagLogLevel2[DiagLogLevel2[\"VERBOSE\"] = 80] = \"VERBOSE\";\n  DiagLogLevel2[DiagLogLevel2[\"ALL\"] = 9999] = \"ALL\";\n})(DiagLogLevel || (DiagLogLevel = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js\nfunction createLogLevelDiagLogger(maxLevel, logger2) {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n  logger2 = logger2 || {};\n  function _filterFunc(funcName, theLevel) {\n    var theFunc = logger2[funcName];\n    if (typeof theFunc === \"function\" && maxLevel >= theLevel) {\n      return theFunc.bind(logger2);\n    }\n    return function() {\n    };\n  }\n  __name(_filterFunc, \"_filterFunc\");\n  return {\n    error: _filterFunc(\"error\", DiagLogLevel.ERROR),\n    warn: _filterFunc(\"warn\", DiagLogLevel.WARN),\n    info: _filterFunc(\"info\", DiagLogLevel.INFO),\n    debug: _filterFunc(\"debug\", DiagLogLevel.DEBUG),\n    verbose: _filterFunc(\"verbose\", DiagLogLevel.VERBOSE)\n  };\n}\n__name(createLogLevelDiagLogger, \"createLogLevelDiagLogger\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/diag.js\nvar API_NAME = \"diag\";\nvar DiagAPI = function() {\n  function DiagAPI2() {\n    function _logProxy(funcName) {\n      return function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var logger2 = getGlobal(\"diag\");\n        if (!logger2)\n          return;\n        return logger2[funcName].apply(logger2, args);\n      };\n    }\n    __name(_logProxy, \"_logProxy\");\n    var self2 = this;\n    self2.setLogger = function(logger2, logLevel) {\n      var _a3, _b2;\n      if (logLevel === void 0) {\n        logLevel = DiagLogLevel.INFO;\n      }\n      if (logger2 === self2) {\n        var err = new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");\n        self2.error((_a3 = err.stack) !== null && _a3 !== void 0 ? _a3 : err.message);\n        return false;\n      }\n      var oldLogger = getGlobal(\"diag\");\n      var newLogger = createLogLevelDiagLogger(logLevel, logger2);\n      if (oldLogger) {\n        var stack = (_b2 = new Error().stack) !== null && _b2 !== void 0 ? _b2 : \"<failed to generate stacktrace>\";\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n      return registerGlobal(\"diag\", newLogger, self2, true);\n    };\n    self2.disable = function() {\n      unregisterGlobal(API_NAME, self2);\n    };\n    self2.createComponentLogger = function(options) {\n      return new DiagComponentLogger(options);\n    };\n    self2.verbose = _logProxy(\"verbose\");\n    self2.debug = _logProxy(\"debug\");\n    self2.info = _logProxy(\"info\");\n    self2.warn = _logProxy(\"warn\");\n    self2.error = _logProxy(\"error\");\n  }\n  __name(DiagAPI2, \"DiagAPI\");\n  DiagAPI2.instance = function() {\n    if (!this._instance) {\n      this._instance = new DiagAPI2();\n    }\n    return this._instance;\n  };\n  return DiagAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js\nvar BaggageImpl = function() {\n  function BaggageImpl2(entries) {\n    this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();\n  }\n  __name(BaggageImpl2, \"BaggageImpl\");\n  BaggageImpl2.prototype.getEntry = function(key) {\n    var entry = this._entries.get(key);\n    if (!entry) {\n      return void 0;\n    }\n    return Object.assign({}, entry);\n  };\n  BaggageImpl2.prototype.getAllEntries = function() {\n    return Array.from(this._entries.entries()).map(function(_a3) {\n      var k = _a3[0], v = _a3[1];\n      return [k, v];\n    });\n  };\n  BaggageImpl2.prototype.setEntry = function(key, entry) {\n    var newBaggage = new BaggageImpl2(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.removeEntry = function(key) {\n    var newBaggage = new BaggageImpl2(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.removeEntries = function() {\n    var keys2 = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      keys2[_i] = arguments[_i];\n    }\n    var newBaggage = new BaggageImpl2(this._entries);\n    for (var _a3 = 0, keys_1 = keys2; _a3 < keys_1.length; _a3++) {\n      var key = keys_1[_a3];\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  };\n  BaggageImpl2.prototype.clear = function() {\n    return new BaggageImpl2();\n  };\n  return BaggageImpl2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js\nvar baggageEntryMetadataSymbol = Symbol(\"BaggageEntryMetadata\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/utils.js\nvar diag = DiagAPI.instance();\nfunction createBaggage(entries) {\n  if (entries === void 0) {\n    entries = {};\n  }\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n__name(createBaggage, \"createBaggage\");\nfunction baggageEntryMetadataFromString(str) {\n  if (typeof str !== \"string\") {\n    diag.error(\"Cannot create baggage metadata from unknown type: \" + typeof str);\n    str = \"\";\n  }\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString: function() {\n      return str;\n    }\n  };\n}\n__name(baggageEntryMetadataFromString, \"baggageEntryMetadataFromString\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js\nvar consoleMap = [\n  { n: \"error\", c: \"error\" },\n  { n: \"warn\", c: \"warn\" },\n  { n: \"info\", c: \"info\" },\n  { n: \"debug\", c: \"debug\" },\n  { n: \"verbose\", c: \"trace\" }\n];\nvar DiagConsoleLogger = function() {\n  function DiagConsoleLogger2() {\n    function _consoleFunc(funcName) {\n      return function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        if (console) {\n          var theFunc = console[funcName];\n          if (typeof theFunc !== \"function\") {\n            theFunc = console.log;\n          }\n          if (typeof theFunc === \"function\") {\n            return theFunc.apply(console, args);\n          }\n        }\n      };\n    }\n    __name(_consoleFunc, \"_consoleFunc\");\n    for (var i = 0; i < consoleMap.length; i++) {\n      this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);\n    }\n  }\n  __name(DiagConsoleLogger2, \"DiagConsoleLogger\");\n  return DiagConsoleLogger2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js\nvar defaultTextMapGetter = {\n  get: function(carrier, key) {\n    if (carrier == null) {\n      return void 0;\n    }\n    return carrier[key];\n  },\n  keys: function(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  }\n};\nvar defaultTextMapSetter = {\n  set: function(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n    carrier[key] = value;\n  }\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/context/context.js\nfunction createContextKey(description) {\n  return Symbol.for(description);\n}\n__name(createContextKey, \"createContextKey\");\nvar BaseContext = function() {\n  function BaseContext2(parentContext) {\n    var self2 = this;\n    self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();\n    self2.getValue = function(key) {\n      return self2._currentContext.get(key);\n    };\n    self2.setValue = function(key, value) {\n      var context3 = new BaseContext2(self2._currentContext);\n      context3._currentContext.set(key, value);\n      return context3;\n    };\n    self2.deleteValue = function(key) {\n      var context3 = new BaseContext2(self2._currentContext);\n      context3._currentContext.delete(key);\n      return context3;\n    };\n  }\n  __name(BaseContext2, \"BaseContext\");\n  return BaseContext2;\n}();\nvar ROOT_CONTEXT = new BaseContext();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js\nvar __spreadArray = function(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};\nvar NoopContextManager = function() {\n  function NoopContextManager2() {\n  }\n  __name(NoopContextManager2, \"NoopContextManager\");\n  NoopContextManager2.prototype.active = function() {\n    return ROOT_CONTEXT;\n  };\n  NoopContextManager2.prototype.with = function(_context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return fn.call.apply(fn, __spreadArray([thisArg], args));\n  };\n  NoopContextManager2.prototype.bind = function(_context, target) {\n    return target;\n  };\n  NoopContextManager2.prototype.enable = function() {\n    return this;\n  };\n  NoopContextManager2.prototype.disable = function() {\n    return this;\n  };\n  return NoopContextManager2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/context.js\nvar __spreadArray2 = function(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};\nvar API_NAME2 = \"context\";\nvar NOOP_CONTEXT_MANAGER = new NoopContextManager();\nvar ContextAPI = function() {\n  function ContextAPI2() {\n  }\n  __name(ContextAPI2, \"ContextAPI\");\n  ContextAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new ContextAPI2();\n    }\n    return this._instance;\n  };\n  ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {\n    return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());\n  };\n  ContextAPI2.prototype.active = function() {\n    return this._getContextManager().active();\n  };\n  ContextAPI2.prototype.with = function(context3, fn, thisArg) {\n    var _a3;\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    return (_a3 = this._getContextManager()).with.apply(_a3, __spreadArray2([context3, fn, thisArg], args));\n  };\n  ContextAPI2.prototype.bind = function(context3, target) {\n    return this._getContextManager().bind(context3, target);\n  };\n  ContextAPI2.prototype._getContextManager = function() {\n    return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;\n  };\n  ContextAPI2.prototype.disable = function() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME2, DiagAPI.instance());\n  };\n  return ContextAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js\nvar TraceFlags;\n(function(TraceFlags2) {\n  TraceFlags2[TraceFlags2[\"NONE\"] = 0] = \"NONE\";\n  TraceFlags2[TraceFlags2[\"SAMPLED\"] = 1] = \"SAMPLED\";\n})(TraceFlags || (TraceFlags = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js\nvar INVALID_SPANID = \"0000000000000000\";\nvar INVALID_TRACEID = \"00000000000000000000000000000000\";\nvar INVALID_SPAN_CONTEXT = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js\nvar NonRecordingSpan = function() {\n  function NonRecordingSpan2(_spanContext) {\n    if (_spanContext === void 0) {\n      _spanContext = INVALID_SPAN_CONTEXT;\n    }\n    this._spanContext = _spanContext;\n  }\n  __name(NonRecordingSpan2, \"NonRecordingSpan\");\n  NonRecordingSpan2.prototype.spanContext = function() {\n    return this._spanContext;\n  };\n  NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setAttributes = function(_attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.setStatus = function(_status) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.updateName = function(_name) {\n    return this;\n  };\n  NonRecordingSpan2.prototype.end = function(_endTime) {\n  };\n  NonRecordingSpan2.prototype.isRecording = function() {\n    return false;\n  };\n  NonRecordingSpan2.prototype.recordException = function(_exception, _time) {\n  };\n  return NonRecordingSpan2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js\nvar SPAN_KEY = createContextKey(\"OpenTelemetry Context Key SPAN\");\nfunction getSpan(context3) {\n  return context3.getValue(SPAN_KEY) || void 0;\n}\n__name(getSpan, \"getSpan\");\nfunction setSpan(context3, span) {\n  return context3.setValue(SPAN_KEY, span);\n}\n__name(setSpan, \"setSpan\");\nfunction deleteSpan(context3) {\n  return context3.deleteValue(SPAN_KEY);\n}\n__name(deleteSpan, \"deleteSpan\");\nfunction setSpanContext(context3, spanContext) {\n  return setSpan(context3, new NonRecordingSpan(spanContext));\n}\n__name(setSpanContext, \"setSpanContext\");\nfunction getSpanContext(context3) {\n  var _a3;\n  return (_a3 = getSpan(context3)) === null || _a3 === void 0 ? void 0 : _a3.spanContext();\n}\n__name(getSpanContext, \"getSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js\nvar VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nvar VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\nfunction isValidTraceId(traceId) {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n__name(isValidTraceId, \"isValidTraceId\");\nfunction isValidSpanId(spanId) {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n__name(isValidSpanId, \"isValidSpanId\");\nfunction isSpanContextValid(spanContext) {\n  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);\n}\n__name(isSpanContextValid, \"isSpanContextValid\");\nfunction wrapSpanContext(spanContext) {\n  return new NonRecordingSpan(spanContext);\n}\n__name(wrapSpanContext, \"wrapSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js\nvar context = ContextAPI.getInstance();\nvar NoopTracer = function() {\n  function NoopTracer2() {\n  }\n  __name(NoopTracer2, \"NoopTracer\");\n  NoopTracer2.prototype.startSpan = function(name, options, context3) {\n    var root = Boolean(options === null || options === void 0 ? void 0 : options.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n    var parentFromContext = context3 && getSpanContext(context3);\n    if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  };\n  NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = setSpan(parentContext, span);\n    return context.with(contextWithSpanSet, fn, void 0, span);\n  };\n  return NoopTracer2;\n}();\nfunction isSpanContext(spanContext) {\n  return typeof spanContext === \"object\" && typeof spanContext[\"spanId\"] === \"string\" && typeof spanContext[\"traceId\"] === \"string\" && typeof spanContext[\"traceFlags\"] === \"number\";\n}\n__name(isSpanContext, \"isSpanContext\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js\nvar NOOP_TRACER = new NoopTracer();\nvar ProxyTracer = function() {\n  function ProxyTracer2(_provider, name, version, options) {\n    this._provider = _provider;\n    this.name = name;\n    this.version = version;\n    this.options = options;\n  }\n  __name(ProxyTracer2, \"ProxyTracer\");\n  ProxyTracer2.prototype.startSpan = function(name, options, context3) {\n    return this._getTracer().startSpan(name, options, context3);\n  };\n  ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {\n    var tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  };\n  ProxyTracer2.prototype._getTracer = function() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n    var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n    this._delegate = tracer;\n    return this._delegate;\n  };\n  return ProxyTracer2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js\nvar NoopTracerProvider = function() {\n  function NoopTracerProvider2() {\n  }\n  __name(NoopTracerProvider2, \"NoopTracerProvider\");\n  NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {\n    return new NoopTracer();\n  };\n  return NoopTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js\nvar NOOP_TRACER_PROVIDER = new NoopTracerProvider();\nvar ProxyTracerProvider = function() {\n  function ProxyTracerProvider2() {\n  }\n  __name(ProxyTracerProvider2, \"ProxyTracerProvider\");\n  ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {\n    var _a3;\n    return (_a3 = this.getDelegateTracer(name, version, options)) !== null && _a3 !== void 0 ? _a3 : new ProxyTracer(this, name, version, options);\n  };\n  ProxyTracerProvider2.prototype.getDelegate = function() {\n    var _a3;\n    return (_a3 = this._delegate) !== null && _a3 !== void 0 ? _a3 : NOOP_TRACER_PROVIDER;\n  };\n  ProxyTracerProvider2.prototype.setDelegate = function(delegate) {\n    this._delegate = delegate;\n  };\n  ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {\n    var _a3;\n    return (_a3 = this._delegate) === null || _a3 === void 0 ? void 0 : _a3.getTracer(name, version, options);\n  };\n  return ProxyTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js\nvar SamplingDecision;\n(function(SamplingDecision3) {\n  SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n})(SamplingDecision || (SamplingDecision = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/span_kind.js\nvar SpanKind;\n(function(SpanKind2) {\n  SpanKind2[SpanKind2[\"INTERNAL\"] = 0] = \"INTERNAL\";\n  SpanKind2[SpanKind2[\"SERVER\"] = 1] = \"SERVER\";\n  SpanKind2[SpanKind2[\"CLIENT\"] = 2] = \"CLIENT\";\n  SpanKind2[SpanKind2[\"PRODUCER\"] = 3] = \"PRODUCER\";\n  SpanKind2[SpanKind2[\"CONSUMER\"] = 4] = \"CONSUMER\";\n})(SpanKind || (SpanKind = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/status.js\nvar SpanStatusCode;\n(function(SpanStatusCode2) {\n  SpanStatusCode2[SpanStatusCode2[\"UNSET\"] = 0] = \"UNSET\";\n  SpanStatusCode2[SpanStatusCode2[\"OK\"] = 1] = \"OK\";\n  SpanStatusCode2[SpanStatusCode2[\"ERROR\"] = 2] = \"ERROR\";\n})(SpanStatusCode || (SpanStatusCode = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js\nvar VALID_KEY_CHAR_RANGE = \"[_0-9a-z-*/]\";\nvar VALID_KEY = \"[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,255}\";\nvar VALID_VENDOR_KEY = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,13}\";\nvar VALID_KEY_REGEX = new RegExp(\"^(?:\" + VALID_KEY + \"|\" + VALID_VENDOR_KEY + \")$\");\nvar VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nvar INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\nfunction validateKey(key) {\n  return VALID_KEY_REGEX.test(key);\n}\n__name(validateKey, \"validateKey\");\nfunction validateValue(value) {\n  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);\n}\n__name(validateValue, \"validateValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js\nvar MAX_TRACE_STATE_ITEMS = 32;\nvar MAX_TRACE_STATE_LEN = 512;\nvar LIST_MEMBERS_SEPARATOR = \",\";\nvar LIST_MEMBER_KEY_VALUE_SPLITTER = \"=\";\nvar TraceStateImpl = function() {\n  function TraceStateImpl2(rawTraceState) {\n    this._internalState = /* @__PURE__ */ new Map();\n    if (rawTraceState)\n      this._parse(rawTraceState);\n  }\n  __name(TraceStateImpl2, \"TraceStateImpl\");\n  TraceStateImpl2.prototype.set = function(key, value) {\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceStateImpl2.prototype.unset = function(key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceStateImpl2.prototype.get = function(key) {\n    return this._internalState.get(key);\n  };\n  TraceStateImpl2.prototype.serialize = function() {\n    var _this = this;\n    return this._keys().reduce(function(agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  };\n  TraceStateImpl2.prototype._parse = function(rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN)\n      return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {\n      var listMember = part.trim();\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {\n        }\n      }\n      return agg;\n    }, /* @__PURE__ */ new Map());\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  };\n  TraceStateImpl2.prototype._keys = function() {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceStateImpl2.prototype._clone = function() {\n    var traceState = new TraceStateImpl2();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceStateImpl2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/trace.js\nvar API_NAME3 = \"trace\";\nvar TraceAPI = function() {\n  function TraceAPI2() {\n    this._proxyTracerProvider = new ProxyTracerProvider();\n    this.wrapSpanContext = wrapSpanContext;\n    this.isSpanContextValid = isSpanContextValid;\n    this.deleteSpan = deleteSpan;\n    this.getSpan = getSpan;\n    this.getSpanContext = getSpanContext;\n    this.setSpan = setSpan;\n    this.setSpanContext = setSpanContext;\n  }\n  __name(TraceAPI2, \"TraceAPI\");\n  TraceAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new TraceAPI2();\n    }\n    return this._instance;\n  };\n  TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {\n    var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  };\n  TraceAPI2.prototype.getTracerProvider = function() {\n    return getGlobal(API_NAME3) || this._proxyTracerProvider;\n  };\n  TraceAPI2.prototype.getTracer = function(name, version) {\n    return this.getTracerProvider().getTracer(name, version);\n  };\n  TraceAPI2.prototype.disable = function() {\n    unregisterGlobal(API_NAME3, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  };\n  return TraceAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js\nvar NoopTextMapPropagator = function() {\n  function NoopTextMapPropagator2() {\n  }\n  __name(NoopTextMapPropagator2, \"NoopTextMapPropagator\");\n  NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {\n  };\n  NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {\n    return context3;\n  };\n  NoopTextMapPropagator2.prototype.fields = function() {\n    return [];\n  };\n  return NoopTextMapPropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js\nvar BAGGAGE_KEY = createContextKey(\"OpenTelemetry Baggage Key\");\nfunction getBaggage(context3) {\n  return context3.getValue(BAGGAGE_KEY) || void 0;\n}\n__name(getBaggage, \"getBaggage\");\nfunction setBaggage(context3, baggage) {\n  return context3.setValue(BAGGAGE_KEY, baggage);\n}\n__name(setBaggage, \"setBaggage\");\nfunction deleteBaggage(context3) {\n  return context3.deleteValue(BAGGAGE_KEY);\n}\n__name(deleteBaggage, \"deleteBaggage\");\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/api/propagation.js\nvar API_NAME4 = \"propagation\";\nvar NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\nvar PropagationAPI = function() {\n  function PropagationAPI2() {\n    this.createBaggage = createBaggage;\n    this.getBaggage = getBaggage;\n    this.setBaggage = setBaggage;\n    this.deleteBaggage = deleteBaggage;\n  }\n  __name(PropagationAPI2, \"PropagationAPI\");\n  PropagationAPI2.getInstance = function() {\n    if (!this._instance) {\n      this._instance = new PropagationAPI2();\n    }\n    return this._instance;\n  };\n  PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {\n    return registerGlobal(API_NAME4, propagator, DiagAPI.instance());\n  };\n  PropagationAPI2.prototype.inject = function(context3, carrier, setter) {\n    if (setter === void 0) {\n      setter = defaultTextMapSetter;\n    }\n    return this._getGlobalPropagator().inject(context3, carrier, setter);\n  };\n  PropagationAPI2.prototype.extract = function(context3, carrier, getter) {\n    if (getter === void 0) {\n      getter = defaultTextMapGetter;\n    }\n    return this._getGlobalPropagator().extract(context3, carrier, getter);\n  };\n  PropagationAPI2.prototype.fields = function() {\n    return this._getGlobalPropagator().fields();\n  };\n  PropagationAPI2.prototype.disable = function() {\n    unregisterGlobal(API_NAME4, DiagAPI.instance());\n  };\n  PropagationAPI2.prototype._getGlobalPropagator = function() {\n    return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;\n  };\n  return PropagationAPI2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+api@1.1.0/node_modules/@opentelemetry/api/build/esm/index.js\nvar context2 = ContextAPI.getInstance();\nvar trace = TraceAPI.getInstance();\nvar propagation = PropagationAPI.getInstance();\nvar diag2 = DiagAPI.instance();\n\n// ../engines/src/index.ts\nvar import_engines_version = __toESM(require_engines_version());\n\n// ../get-platform/src/getNodeAPIName.ts\nvar NODE_API_QUERY_ENGINE_URL_BASE = \"libquery_engine\";\nfunction getNodeAPIName(platform3, type) {\n  const isUrl = type === \"url\";\n  if (platform3.includes(\"windows\")) {\n    return isUrl ? `query_engine.dll.node` : `query_engine-${platform3}.dll.node`;\n  } else if (platform3.includes(\"darwin\")) {\n    return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.dylib.node`;\n  } else {\n    return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.so.node`;\n  }\n}\n__name(getNodeAPIName, \"getNodeAPIName\");\n\n// ../get-platform/src/getPlatform.ts\nvar import_child_process = __webpack_require__(/*! child_process */ \"child_process\");\nvar import_fs = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_os = __toESM(__webpack_require__(/*! os */ \"os\"));\nvar import_util = __webpack_require__(/*! util */ \"util\");\nvar readFile = (0, import_util.promisify)(import_fs.default.readFile);\nvar exists = (0, import_util.promisify)(import_fs.default.exists);\nasync function getos() {\n  const platform3 = import_os.default.platform();\n  const arch2 = process.arch;\n  if (platform3 === \"freebsd\") {\n    const version = await gracefulExec(`freebsd-version`);\n    if (version && version.trim().length > 0) {\n      const regex = /^(\\d+)\\.?/;\n      const match = regex.exec(version);\n      if (match) {\n        return {\n          platform: \"freebsd\",\n          distro: `freebsd${match[1]}`,\n          arch: arch2\n        };\n      }\n    }\n  }\n  if (platform3 !== \"linux\") {\n    return {\n      platform: platform3,\n      arch: arch2\n    };\n  }\n  return {\n    platform: \"linux\",\n    libssl: await getOpenSSLVersion(),\n    distro: await resolveDistro(),\n    arch: arch2\n  };\n}\n__name(getos, \"getos\");\nfunction parseDistro(input) {\n  const idRegex = /^ID=\"?([^\"\\n]*)\"?$/im;\n  const idLikeRegex = /^ID_LIKE=\"?([^\"\\n]*)\"?$/im;\n  const idMatch = idRegex.exec(input);\n  const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || \"\";\n  const idLikeMatch = idLikeRegex.exec(input);\n  const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || \"\";\n  if (id === \"raspbian\") {\n    return \"arm\";\n  }\n  if (id === \"nixos\") {\n    return \"nixos\";\n  }\n  if (idLike.includes(\"centos\") || idLike.includes(\"fedora\") || idLike.includes(\"rhel\") || id === \"fedora\") {\n    return \"rhel\";\n  }\n  if (idLike.includes(\"debian\") || idLike.includes(\"ubuntu\") || id === \"debian\") {\n    return \"debian\";\n  }\n  return;\n}\n__name(parseDistro, \"parseDistro\");\nasync function resolveDistro() {\n  const osReleaseFile = \"/etc/os-release\";\n  const alpineReleaseFile = \"/etc/alpine-release\";\n  if (await exists(alpineReleaseFile)) {\n    return \"musl\";\n  } else if (await exists(osReleaseFile)) {\n    return parseDistro(await readFile(osReleaseFile, \"utf-8\"));\n  } else {\n    return;\n  }\n}\n__name(resolveDistro, \"resolveDistro\");\nfunction parseOpenSSLVersion(input) {\n  const match = /^OpenSSL\\s(\\d+\\.\\d+)\\.\\d+/.exec(input);\n  if (match) {\n    return match[1] + \".x\";\n  }\n  return;\n}\n__name(parseOpenSSLVersion, \"parseOpenSSLVersion\");\nasync function getOpenSSLVersion() {\n  const [version, ls] = await Promise.all([\n    gracefulExec(`openssl version -v`),\n    gracefulExec(`\n      ls -l /lib64 | grep ssl;\n      ls -l /usr/lib64 | grep ssl;\n    `)\n  ]);\n  if (version) {\n    const v = parseOpenSSLVersion(version);\n    if (v) {\n      return v;\n    }\n  }\n  if (ls) {\n    const match = /libssl\\.so\\.(\\d+\\.\\d+)\\.\\d+/.exec(ls);\n    if (match) {\n      return match[1] + \".x\";\n    }\n  }\n  return void 0;\n}\n__name(getOpenSSLVersion, \"getOpenSSLVersion\");\nasync function gracefulExec(cmd) {\n  return new Promise((resolve) => {\n    try {\n      (0, import_child_process.exec)(cmd, (err, stdout) => {\n        resolve(String(stdout));\n      });\n    } catch (e) {\n      resolve(void 0);\n      return void 0;\n    }\n    return void 0;\n  });\n}\n__name(gracefulExec, \"gracefulExec\");\nasync function getPlatform() {\n  const { platform: platform3, libssl, distro, arch: arch2 } = await getos();\n  if (platform3 === \"darwin\" && arch2 === \"arm64\") {\n    return \"darwin-arm64\";\n  }\n  if (platform3 === \"darwin\") {\n    return \"darwin\";\n  }\n  if (platform3 === \"win32\") {\n    return \"windows\";\n  }\n  if (platform3 === \"freebsd\") {\n    return distro;\n  }\n  if (platform3 === \"openbsd\") {\n    return \"openbsd\";\n  }\n  if (platform3 === \"netbsd\") {\n    return \"netbsd\";\n  }\n  if (platform3 === \"linux\" && arch2 === \"arm64\") {\n    return `linux-arm64-openssl-${libssl}`;\n  }\n  if (platform3 === \"linux\" && arch2 === \"arm\") {\n    return `linux-arm-openssl-${libssl}`;\n  }\n  if (platform3 === \"linux\" && distro === \"nixos\") {\n    return \"linux-nixos\";\n  }\n  if (platform3 === \"linux\" && distro === \"musl\") {\n    return \"linux-musl\";\n  }\n  if (platform3 === \"linux\" && distro && libssl) {\n    return distro + \"-openssl-\" + libssl;\n  }\n  if (libssl) {\n    return \"debian-openssl-\" + libssl;\n  }\n  if (distro) {\n    return distro + \"-openssl-1.1.x\";\n  }\n  return \"debian-openssl-1.1.x\";\n}\n__name(getPlatform, \"getPlatform\");\n\n// ../get-platform/src/isNodeAPISupported.ts\nvar import_fs2 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nasync function isNodeAPISupported() {\n  const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;\n  const customLibraryExists = customLibraryPath && import_fs2.default.existsSync(customLibraryPath);\n  const os3 = await getos();\n  if (!customLibraryExists && (os3.arch === \"x32\" || os3.arch === \"ia32\")) {\n    throw new Error(\n      `The default query engine type (Node-API, \"library\") is currently not supported for 32bit Node. Please set \\`engineType = \"binary\"\\` in the \"generator\" block of your \"schema.prisma\" file (or use the environment variables \"PRISMA_CLIENT_ENGINE_TYPE=binary\" and/or \"PRISMA_CLI_QUERY_ENGINE_TYPE=binary\".)`\n    );\n  }\n}\n__name(isNodeAPISupported, \"isNodeAPISupported\");\n\n// ../get-platform/src/platforms.ts\nvar platforms = [\n  \"darwin\",\n  \"darwin-arm64\",\n  \"debian-openssl-1.0.x\",\n  \"debian-openssl-1.1.x\",\n  \"debian-openssl-3.0.x\",\n  \"rhel-openssl-1.0.x\",\n  \"rhel-openssl-1.1.x\",\n  \"rhel-openssl-3.0.x\",\n  \"linux-arm64-openssl-1.1.x\",\n  \"linux-arm64-openssl-1.0.x\",\n  \"linux-arm64-openssl-3.0.x\",\n  \"linux-arm-openssl-1.1.x\",\n  \"linux-arm-openssl-1.0.x\",\n  \"linux-arm-openssl-3.0.x\",\n  \"linux-musl\",\n  \"linux-nixos\",\n  \"windows\",\n  \"freebsd11\",\n  \"freebsd12\",\n  \"freebsd13\",\n  \"openbsd\",\n  \"netbsd\",\n  \"arm\"\n];\n\n// ../engines/src/index.ts\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_engines_version2 = __toESM(require_engines_version());\nvar debug2 = src_default(\"prisma:engines\");\nfunction getEnginesPath() {\n  return import_path.default.join(__dirname, \"../\");\n}\n__name(getEnginesPath, \"getEnginesPath\");\nvar DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = \"libquery-engine\" /* libqueryEngine */;\nimport_path.default.join(__dirname, \"../query-engine-darwin\");\nimport_path.default.join(__dirname, \"../introspection-engine-darwin\");\nimport_path.default.join(__dirname, \"../prisma-fmt-darwin\");\nimport_path.default.join(__dirname, \"../query-engine-darwin-arm64\");\nimport_path.default.join(__dirname, \"../introspection-engine-darwin-arm64\");\nimport_path.default.join(__dirname, \"../prisma-fmt-darwin-arm64\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../query-engine-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-debian-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-1.0.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-1.1.x\");\nimport_path.default.join(__dirname, \"../query-engine-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../introspection-engine-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../prisma-fmt-rhel-openssl-3.0.x\");\nimport_path.default.join(__dirname, \"../libquery_engine-darwin.dylib.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-darwin-arm64.dylib.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-debian-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-arm64-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-linux-musl.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-1.0.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-1.1.x.so.node\");\nimport_path.default.join(__dirname, \"../libquery_engine-rhel-openssl-3.0.x.so.node\");\nimport_path.default.join(__dirname, \"../query_engine-windows.dll.node\");\n\n// ../engine-core/src/binary/BinaryEngine.ts\nvar import_chalk3 = __toESM(require_source());\nvar import_child_process2 = __webpack_require__(/*! child_process */ \"child_process\");\nvar import_events = __toESM(__webpack_require__(/*! events */ \"events\"));\nvar import_execa = __toESM(require_execa());\nvar import_fs4 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_net = __toESM(__webpack_require__(/*! net */ \"net\"));\nvar import_p_retry = __toESM(require_p_retry());\nvar import_path2 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_url = __webpack_require__(/*! url */ \"url\");\nvar import_util4 = __webpack_require__(/*! util */ \"util\");\n\n// ../engine-core/src/common/Engine.ts\nvar Engine = class {\n};\n__name(Engine, \"Engine\");\n\n// ../engine-core/src/common/errors/PrismaClientInitializationError.ts\nvar PrismaClientInitializationError = class extends Error {\n  constructor(message, clientVersion2, errorCode) {\n    super(message);\n    this.clientVersion = clientVersion2;\n    this.errorCode = errorCode;\n    Error.captureStackTrace(PrismaClientInitializationError);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientInitializationError\";\n  }\n};\n__name(PrismaClientInitializationError, \"PrismaClientInitializationError\");\n\n// ../engine-core/src/common/errors/PrismaClientKnownRequestError.ts\nvar PrismaClientKnownRequestError = class extends Error {\n  constructor(message, code, clientVersion2, meta) {\n    super(message);\n    this.code = code;\n    this.clientVersion = clientVersion2;\n    this.meta = meta;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientKnownRequestError\";\n  }\n};\n__name(PrismaClientKnownRequestError, \"PrismaClientKnownRequestError\");\n\n// ../engine-core/src/common/errors/utils/log.ts\nfunction getMessage(log4) {\n  if (typeof log4 === \"string\") {\n    return log4;\n  } else if (isRustError(log4)) {\n    return getBacktraceFromRustError(log4);\n  } else if (isRustLog(log4)) {\n    return getBacktraceFromLog(log4);\n  }\n  return JSON.stringify(log4);\n}\n__name(getMessage, \"getMessage\");\nfunction getBacktraceFromLog(log4) {\n  var _a3, _b2, _c, _d, _e, _f, _g;\n  if ((_a3 = log4.fields) == null ? void 0 : _a3.message) {\n    let str = (_b2 = log4.fields) == null ? void 0 : _b2.message;\n    if ((_c = log4.fields) == null ? void 0 : _c.file) {\n      str += ` in ${log4.fields.file}`;\n      if ((_d = log4.fields) == null ? void 0 : _d.line) {\n        str += `:${log4.fields.line}`;\n      }\n      if ((_e = log4.fields) == null ? void 0 : _e.column) {\n        str += `:${log4.fields.column}`;\n      }\n    }\n    if ((_f = log4.fields) == null ? void 0 : _f.reason) {\n      str += `\n${(_g = log4.fields) == null ? void 0 : _g.reason}`;\n    }\n    return str;\n  }\n  return \"Unknown error\";\n}\n__name(getBacktraceFromLog, \"getBacktraceFromLog\");\nfunction getBacktraceFromRustError(err) {\n  let str = \"\";\n  if (err.is_panic) {\n    str += `PANIC`;\n  }\n  if (err.backtrace) {\n    str += ` in ${err.backtrace}`;\n  }\n  if (err.message) {\n    str += `\n${err.message}`;\n  }\n  return str;\n}\n__name(getBacktraceFromRustError, \"getBacktraceFromRustError\");\nfunction isRustLog(e) {\n  return e.timestamp && typeof e.level === \"string\" && typeof e.target === \"string\";\n}\n__name(isRustLog, \"isRustLog\");\nfunction isRustErrorLog(e) {\n  var _a3, _b2;\n  return isRustLog(e) && (e.level === \"error\" || ((_b2 = (_a3 = e.fields) == null ? void 0 : _a3.message) == null ? void 0 : _b2.includes(\"fatal error\")));\n}\n__name(isRustErrorLog, \"isRustErrorLog\");\nfunction isRustError(e) {\n  return typeof e.is_panic !== \"undefined\";\n}\n__name(isRustError, \"isRustError\");\nfunction convertLog(rustLog) {\n  const isQuery = isQueryLog(rustLog.fields);\n  const level = isQuery ? \"query\" : rustLog.level.toLowerCase();\n  return {\n    ...rustLog,\n    level,\n    timestamp: new Date(rustLog.timestamp)\n  };\n}\n__name(convertLog, \"convertLog\");\nfunction isQueryLog(fields) {\n  return Boolean(fields.query);\n}\n__name(isQueryLog, \"isQueryLog\");\n\n// ../engine-core/src/common/errors/PrismaClientRustError.ts\nvar PrismaClientRustError = class extends Error {\n  constructor({ clientVersion: clientVersion2, log: log4, error: error2 }) {\n    var __super = (...args) => {\n      super(...args);\n    };\n    if (log4) {\n      const backtrace = getBacktraceFromLog(log4);\n      __super(backtrace != null ? backtrace : \"Unknown error\");\n    } else if (error2) {\n      const backtrace = getBacktraceFromRustError(error2);\n      __super(backtrace);\n    } else {\n      __super(`Unknown error`);\n    }\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\n__name(PrismaClientRustError, \"PrismaClientRustError\");\n\n// ../engine-core/src/common/errors/PrismaClientRustPanicError.ts\nvar PrismaClientRustPanicError = class extends Error {\n  constructor(message, clientVersion2) {\n    super(message);\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\n__name(PrismaClientRustPanicError, \"PrismaClientRustPanicError\");\n\n// ../engine-core/src/common/errors/PrismaClientUnknownRequestError.ts\nvar PrismaClientUnknownRequestError = class extends Error {\n  constructor(message, clientVersion2) {\n    super(message);\n    this.clientVersion = clientVersion2;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientUnknownRequestError\";\n  }\n};\n__name(PrismaClientUnknownRequestError, \"PrismaClientUnknownRequestError\");\n\n// ../engine-core/src/common/errors/utils/getErrorMessageWithLink.ts\nvar import_chalk2 = __toESM(require_source());\nvar import_strip_ansi = __toESM(require_strip_ansi());\n\n// ../engine-core/src/common/utils/util.ts\nvar import_fs3 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_new_github_issue_url = __toESM(require_new_github_issue_url());\nvar debug3 = src_default(\"plusX\");\nfunction plusX(file) {\n  const s = import_fs3.default.statSync(file);\n  const newMode = s.mode | 64 | 8 | 1;\n  if (s.mode === newMode) {\n    debug3(`Execution permissions of ${file} are fine`);\n    return;\n  }\n  const base8 = newMode.toString(8).slice(-3);\n  debug3(`Have to call plusX on ${file}`);\n  import_fs3.default.chmodSync(file, base8);\n}\n__name(plusX, \"plusX\");\nfunction transformPlatformToEnvValue(platform3) {\n  return { fromEnvVar: null, value: platform3 };\n}\n__name(transformPlatformToEnvValue, \"transformPlatformToEnvValue\");\nfunction fixBinaryTargets(binaryTargets, platform3) {\n  binaryTargets = binaryTargets || [];\n  if (!binaryTargets.find((object) => object.value === \"native\")) {\n    return [transformPlatformToEnvValue(\"native\"), ...binaryTargets];\n  }\n  return [...binaryTargets, transformPlatformToEnvValue(platform3)];\n}\n__name(fixBinaryTargets, \"fixBinaryTargets\");\nfunction getGithubIssueUrl({\n  title,\n  user = \"prisma\",\n  repo = \"prisma\",\n  template = \"bug_report.md\",\n  body\n}) {\n  return (0, import_new_github_issue_url.default)({\n    user,\n    repo,\n    template,\n    title,\n    body\n  });\n}\n__name(getGithubIssueUrl, \"getGithubIssueUrl\");\n\n// ../engine-core/src/common/errors/utils/maskQuery.ts\nfunction maskQuery(query2) {\n  if (!query2) {\n    return \"\";\n  }\n  return query2.replace(/\".*\"/g, '\"X\"').replace(/[\\s:\\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {\n    return `${substr[0]}5`;\n  });\n}\n__name(maskQuery, \"maskQuery\");\n\n// ../engine-core/src/common/errors/utils/normalizeLogs.ts\nfunction normalizeLogs(logs) {\n  return logs.split(\"\\n\").map((l) => {\n    return l.replace(/^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)\\s*/, \"\").replace(/\\+\\d+\\s*ms$/, \"\");\n  }).join(\"\\n\");\n}\n__name(normalizeLogs, \"normalizeLogs\");\n\n// ../engine-core/src/common/errors/utils/getErrorMessageWithLink.ts\nfunction getErrorMessageWithLink({\n  version,\n  platform: platform3,\n  title,\n  description,\n  engineVersion,\n  database,\n  query: query2\n}) {\n  var _a3, _b2;\n  const gotLogs = getLogs(6e3 - ((_a3 = query2 == null ? void 0 : query2.length) != null ? _a3 : 0));\n  const logs = normalizeLogs((0, import_strip_ansi.default)(gotLogs));\n  const moreInfo = description ? `# Description\n\\`\\`\\`\n${description}\n\\`\\`\\`` : \"\";\n  const body = (0, import_strip_ansi.default)(\n    `Hi Prisma Team! My Prisma Client just crashed. This is the report:\n## Versions\n\n| Name            | Version            |\n|-----------------|--------------------|\n| Node            | ${(_b2 = process.version) == null ? void 0 : _b2.padEnd(19)}| \n| OS              | ${platform3 == null ? void 0 : platform3.padEnd(19)}|\n| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|\n| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|\n| Database        | ${database == null ? void 0 : database.padEnd(19)}|\n\n${moreInfo}\n\n## Logs\n\\`\\`\\`\n${logs}\n\\`\\`\\`\n\n## Client Snippet\n\\`\\`\\`ts\n// PLEASE FILL YOUR CODE SNIPPET HERE\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`prisma\n// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE\n\\`\\`\\`\n\n## Prisma Engine Query\n\\`\\`\\`\n${query2 ? maskQuery(query2) : \"\"}\n\\`\\`\\`\n`\n  );\n  const url = getGithubIssueUrl({ title, body });\n  return `${title}\n\nThis is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.\n\n${import_chalk2.default.underline(url)}\n\nIf you want the Prisma team to look into it, please open the link above \\u{1F64F}\nTo increase the chance of success, please post your schema and a snippet of\nhow you used Prisma Client in the issue. \n`;\n}\n__name(getErrorMessageWithLink, \"getErrorMessageWithLink\");\n\n// ../engine-core/src/common/errors/utils/prismaGraphQLToJSError.ts\nfunction prismaGraphQLToJSError(error2, clientVersion2) {\n  if (error2.user_facing_error.error_code) {\n    return new PrismaClientKnownRequestError(\n      error2.user_facing_error.message,\n      error2.user_facing_error.error_code,\n      clientVersion2,\n      error2.user_facing_error.meta\n    );\n  }\n  return new PrismaClientUnknownRequestError(error2.error, clientVersion2);\n}\n__name(prismaGraphQLToJSError, \"prismaGraphQLToJSError\");\n\n// ../engine-core/src/common/utils/printGeneratorConfig.ts\nvar import_indent_string2 = __toESM(require_indent_string());\nfunction printGeneratorConfig(config2) {\n  return String(new GeneratorConfigClass(config2));\n}\n__name(printGeneratorConfig, \"printGeneratorConfig\");\nvar GeneratorConfigClass = class {\n  constructor(config2) {\n    this.config = config2;\n  }\n  toString() {\n    const { config: config2 } = this;\n    const provider = config2.provider.fromEnvVar ? `env(\"${config2.provider.fromEnvVar}\")` : config2.provider.value;\n    const obj = JSON.parse(\n      JSON.stringify({\n        provider,\n        binaryTargets: getOriginalBinaryTargetsValue(config2.binaryTargets)\n      })\n    );\n    return `generator ${config2.name} {\n${(0, import_indent_string2.default)(printDatamodelObject(obj), 2)}\n}`;\n  }\n};\n__name(GeneratorConfigClass, \"GeneratorConfigClass\");\nfunction getOriginalBinaryTargetsValue(binaryTargets) {\n  let value;\n  if (binaryTargets.length > 0) {\n    const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);\n    if (binaryTargetsFromEnvVar) {\n      value = `env(\"${binaryTargetsFromEnvVar.fromEnvVar}\")`;\n    } else {\n      value = binaryTargets.map((object) => object.value);\n    }\n  } else {\n    value = void 0;\n  }\n  return value;\n}\n__name(getOriginalBinaryTargetsValue, \"getOriginalBinaryTargetsValue\");\nfunction printDatamodelObject(obj) {\n  const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);\n  return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join(\"\\n\");\n}\n__name(printDatamodelObject, \"printDatamodelObject\");\nfunction niceStringify(value) {\n  return JSON.parse(\n    JSON.stringify(value, (_, value2) => {\n      if (Array.isArray(value2)) {\n        return `[${value2.map((element) => JSON.stringify(element)).join(\", \")}]`;\n      }\n      return JSON.stringify(value2);\n    })\n  );\n}\n__name(niceStringify, \"niceStringify\");\n\n// ../engine-core/src/tools/byline.ts\nvar import_stream = __toESM(__webpack_require__(/*! stream */ \"stream\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nfunction byline(readStream, options) {\n  return createStream(readStream, options);\n}\n__name(byline, \"byline\");\nfunction createStream(readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options);\n  } else {\n    return new LineStream(options);\n  }\n}\n__name(createStream, \"createStream\");\nfunction createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error(\"expected readStream\");\n  }\n  if (!readStream.readable) {\n    throw new Error(\"readStream must be readable\");\n  }\n  const ls = new LineStream(options);\n  readStream.pipe(ls);\n  return ls;\n}\n__name(createLineStream, \"createLineStream\");\nfunction LineStream(options) {\n  import_stream.default.Transform.call(this, options);\n  options = options || {};\n  this._readableState.objectMode = true;\n  this._lineBuffer = [];\n  this._keepEmptyLines = options.keepEmptyLines || false;\n  this._lastChunkEndedWithCR = false;\n  this.on(\"pipe\", function(src) {\n    if (!this.encoding) {\n      if (src instanceof import_stream.default.Readable) {\n        this.encoding = src._readableState.encoding;\n      }\n    }\n  });\n}\n__name(LineStream, \"LineStream\");\nimport_util3.default.inherits(LineStream, import_stream.default.Transform);\nLineStream.prototype._transform = function(chunk, encoding, done) {\n  encoding = encoding || \"utf8\";\n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == \"buffer\") {\n      chunk = chunk.toString();\n      encoding = \"utf8\";\n    } else {\n      chunk = chunk.toString(encoding);\n    }\n  }\n  this._chunkEncoding = encoding;\n  const lines = chunk.split(/\\r\\n|\\r|\\n/g);\n  if (this._lastChunkEndedWithCR && chunk[0] == \"\\n\") {\n    lines.shift();\n  }\n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];\n    lines.shift();\n  }\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == \"\\r\";\n  this._lineBuffer = this._lineBuffer.concat(lines);\n  this._pushBuffer(encoding, 1, done);\n};\nLineStream.prototype._pushBuffer = function(encoding, keep, done) {\n  while (this._lineBuffer.length > keep) {\n    const line = this._lineBuffer.shift();\n    if (this._keepEmptyLines || line.length > 0) {\n      if (!this.push(this._reencode(line, encoding))) {\n        const self2 = this;\n        setImmediate(function() {\n          self2._pushBuffer(encoding, keep, done);\n        });\n        return;\n      }\n    }\n  }\n  done();\n};\nLineStream.prototype._flush = function(done) {\n  this._pushBuffer(this._chunkEncoding, 0, done);\n};\nLineStream.prototype._reencode = function(line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return Buffer.from(line, chunkEncoding).toString(this.encoding);\n  } else if (this.encoding) {\n    return line;\n  } else {\n    return Buffer.from(line, chunkEncoding);\n  }\n};\n\n// ../engine-core/src/tools/omit.ts\nfunction omit(obj, keys2) {\n  return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {\n    result[key] = obj[key];\n    return result;\n  }, {});\n}\n__name(omit, \"omit\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js\nvar SUPPRESS_TRACING_KEY = createContextKey(\"OpenTelemetry SDK Context Key SUPPRESS_TRACING\");\nfunction suppressTracing(context3) {\n  return context3.setValue(SUPPRESS_TRACING_KEY, true);\n}\n__name(suppressTracing, \"suppressTracing\");\nfunction isTracingSuppressed(context3) {\n  return context3.getValue(SUPPRESS_TRACING_KEY) === true;\n}\n__name(isTracingSuppressed, \"isTracingSuppressed\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/constants.js\nvar BAGGAGE_KEY_PAIR_SEPARATOR = \"=\";\nvar BAGGAGE_PROPERTIES_SEPARATOR = \";\";\nvar BAGGAGE_ITEMS_SEPARATOR = \",\";\nvar BAGGAGE_HEADER = \"baggage\";\nvar BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;\nvar BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;\nvar BAGGAGE_MAX_TOTAL_LENGTH = 8192;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/utils.js\nvar __read = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce(function(hValue, current) {\n    var value = \"\" + hValue + (hValue !== \"\" ? BAGGAGE_ITEMS_SEPARATOR : \"\") + current;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, \"\");\n}\n__name(serializeKeyPairs, \"serializeKeyPairs\");\nfunction getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(function(_a3) {\n    var _b2 = __read(_a3, 2), key = _b2[0], value = _b2[1];\n    var entry = encodeURIComponent(key) + \"=\" + encodeURIComponent(value.value);\n    if (value.metadata !== void 0) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n    return entry;\n  });\n}\n__name(getKeyPairs, \"getKeyPairs\");\nfunction parsePairKeyValue(entry) {\n  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0)\n    return;\n  var keyPairPart = valueProps.shift();\n  if (!keyPairPart)\n    return;\n  var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (keyPair.length !== 2)\n    return;\n  var key = decodeURIComponent(keyPair[0].trim());\n  var value = decodeURIComponent(keyPair[1].trim());\n  var metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n  return { key, value, metadata };\n}\n__name(parsePairKeyValue, \"parsePairKeyValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js\nvar W3CBaggagePropagator = function() {\n  function W3CBaggagePropagator2() {\n  }\n  __name(W3CBaggagePropagator2, \"W3CBaggagePropagator\");\n  W3CBaggagePropagator2.prototype.inject = function(context3, carrier, setter) {\n    var baggage = propagation.getBaggage(context3);\n    if (!baggage || isTracingSuppressed(context3))\n      return;\n    var keyPairs = getKeyPairs(baggage).filter(function(pair) {\n      return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;\n    }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);\n    var headerValue = serializeKeyPairs(keyPairs);\n    if (headerValue.length > 0) {\n      setter.set(carrier, BAGGAGE_HEADER, headerValue);\n    }\n  };\n  W3CBaggagePropagator2.prototype.extract = function(context3, carrier, getter) {\n    var headerValue = getter.get(carrier, BAGGAGE_HEADER);\n    var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;\n    if (!baggageString)\n      return context3;\n    var baggage = {};\n    if (baggageString.length === 0) {\n      return context3;\n    }\n    var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);\n    pairs.forEach(function(entry) {\n      var keyPair = parsePairKeyValue(entry);\n      if (keyPair) {\n        var baggageEntry = { value: keyPair.value };\n        if (keyPair.metadata) {\n          baggageEntry.metadata = keyPair.metadata;\n        }\n        baggage[keyPair.key] = baggageEntry;\n      }\n    });\n    if (Object.entries(baggage).length === 0) {\n      return context3;\n    }\n    return propagation.setBaggage(context3, propagation.createBaggage(baggage));\n  };\n  W3CBaggagePropagator2.prototype.fields = function() {\n    return [BAGGAGE_HEADER];\n  };\n  return W3CBaggagePropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/attributes.js\nvar __values = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read2 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction sanitizeAttributes(attributes) {\n  var e_1, _a3;\n  var out = {};\n  if (typeof attributes !== \"object\" || attributes == null) {\n    return out;\n  }\n  try {\n    for (var _b2 = __values(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n      var _d = __read2(_c.value, 2), key = _d[0], val = _d[1];\n      if (!isAttributeKey(key)) {\n        diag2.warn(\"Invalid attribute key: \" + key);\n        continue;\n      }\n      if (!isAttributeValue(val)) {\n        diag2.warn(\"Invalid attribute value set for key: \" + key);\n        continue;\n      }\n      if (Array.isArray(val)) {\n        out[key] = val.slice();\n      } else {\n        out[key] = val;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a3 = _b2.return))\n        _a3.call(_b2);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return out;\n}\n__name(sanitizeAttributes, \"sanitizeAttributes\");\nfunction isAttributeKey(key) {\n  return typeof key === \"string\" && key.length > 0;\n}\n__name(isAttributeKey, \"isAttributeKey\");\nfunction isAttributeValue(val) {\n  if (val == null) {\n    return true;\n  }\n  if (Array.isArray(val)) {\n    return isHomogeneousAttributeValueArray(val);\n  }\n  return isValidPrimitiveAttributeValue(val);\n}\n__name(isAttributeValue, \"isAttributeValue\");\nfunction isHomogeneousAttributeValueArray(arr) {\n  var e_2, _a3;\n  var type;\n  try {\n    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n      var element = arr_1_1.value;\n      if (element == null)\n        continue;\n      if (!type) {\n        if (isValidPrimitiveAttributeValue(element)) {\n          type = typeof element;\n          continue;\n        }\n        return false;\n      }\n      if (typeof element === type) {\n        continue;\n      }\n      return false;\n    }\n  } catch (e_2_1) {\n    e_2 = { error: e_2_1 };\n  } finally {\n    try {\n      if (arr_1_1 && !arr_1_1.done && (_a3 = arr_1.return))\n        _a3.call(arr_1);\n    } finally {\n      if (e_2)\n        throw e_2.error;\n    }\n  }\n  return true;\n}\n__name(isHomogeneousAttributeValueArray, \"isHomogeneousAttributeValueArray\");\nfunction isValidPrimitiveAttributeValue(val) {\n  switch (typeof val) {\n    case \"number\":\n    case \"boolean\":\n    case \"string\":\n      return true;\n  }\n  return false;\n}\n__name(isValidPrimitiveAttributeValue, \"isValidPrimitiveAttributeValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js\nfunction loggingErrorHandler() {\n  return function(ex) {\n    diag2.error(stringifyException(ex));\n  };\n}\n__name(loggingErrorHandler, \"loggingErrorHandler\");\nfunction stringifyException(ex) {\n  if (typeof ex === \"string\") {\n    return ex;\n  } else {\n    return JSON.stringify(flattenException(ex));\n  }\n}\n__name(stringifyException, \"stringifyException\");\nfunction flattenException(ex) {\n  var result = {};\n  var current = ex;\n  while (current !== null) {\n    Object.getOwnPropertyNames(current).forEach(function(propertyName) {\n      if (result[propertyName])\n        return;\n      var value = current[propertyName];\n      if (value) {\n        result[propertyName] = String(value);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n  return result;\n}\n__name(flattenException, \"flattenException\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js\nvar delegateHandler = loggingErrorHandler();\nfunction globalErrorHandler(ex) {\n  try {\n    delegateHandler(ex);\n  } catch (_a3) {\n  }\n}\n__name(globalErrorHandler, \"globalErrorHandler\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\nvar os2 = __toESM(__webpack_require__(/*! os */ \"os\"));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/sampling.js\nvar TracesSamplerValues;\n(function(TracesSamplerValues2) {\n  TracesSamplerValues2[\"AlwaysOff\"] = \"always_off\";\n  TracesSamplerValues2[\"AlwaysOn\"] = \"always_on\";\n  TracesSamplerValues2[\"ParentBasedAlwaysOff\"] = \"parentbased_always_off\";\n  TracesSamplerValues2[\"ParentBasedAlwaysOn\"] = \"parentbased_always_on\";\n  TracesSamplerValues2[\"ParentBasedTraceIdRatio\"] = \"parentbased_traceidratio\";\n  TracesSamplerValues2[\"TraceIdRatio\"] = \"traceidratio\";\n})(TracesSamplerValues || (TracesSamplerValues = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js\nvar _globalThis2 = typeof globalThis === \"object\" ? globalThis : typeof self === \"object\" ? self : typeof window === \"object\" ? window : typeof global === \"object\" ? global : {};\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/environment.js\nvar DEFAULT_LIST_SEPARATOR = \",\";\nvar ENVIRONMENT_NUMBERS_KEYS = [\n  \"OTEL_BSP_EXPORT_TIMEOUT\",\n  \"OTEL_BSP_MAX_EXPORT_BATCH_SIZE\",\n  \"OTEL_BSP_MAX_QUEUE_SIZE\",\n  \"OTEL_BSP_SCHEDULE_DELAY\",\n  \"OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n  \"OTEL_ATTRIBUTE_COUNT_LIMIT\",\n  \"OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n  \"OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT\",\n  \"OTEL_SPAN_EVENT_COUNT_LIMIT\",\n  \"OTEL_SPAN_LINK_COUNT_LIMIT\",\n  \"OTEL_EXPORTER_OTLP_TIMEOUT\",\n  \"OTEL_EXPORTER_OTLP_TRACES_TIMEOUT\",\n  \"OTEL_EXPORTER_OTLP_METRICS_TIMEOUT\",\n  \"OTEL_EXPORTER_JAEGER_AGENT_PORT\"\n];\nfunction isEnvVarANumber(key) {\n  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;\n}\n__name(isEnvVarANumber, \"isEnvVarANumber\");\nvar ENVIRONMENT_LISTS_KEYS = [\n  \"OTEL_NO_PATCH_MODULES\",\n  \"OTEL_PROPAGATORS\"\n];\nfunction isEnvVarAList(key) {\n  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;\n}\n__name(isEnvVarAList, \"isEnvVarAList\");\nvar DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\nvar DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\nvar DEFAULT_ENVIRONMENT = {\n  CONTAINER_NAME: \"\",\n  ECS_CONTAINER_METADATA_URI_V4: \"\",\n  ECS_CONTAINER_METADATA_URI: \"\",\n  HOSTNAME: \"\",\n  KUBERNETES_SERVICE_HOST: \"\",\n  NAMESPACE: \"\",\n  OTEL_BSP_EXPORT_TIMEOUT: 3e4,\n  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,\n  OTEL_BSP_MAX_QUEUE_SIZE: 2048,\n  OTEL_BSP_SCHEDULE_DELAY: 5e3,\n  OTEL_EXPORTER_JAEGER_AGENT_HOST: \"\",\n  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,\n  OTEL_EXPORTER_JAEGER_ENDPOINT: \"\",\n  OTEL_EXPORTER_JAEGER_PASSWORD: \"\",\n  OTEL_EXPORTER_JAEGER_USER: \"\",\n  OTEL_EXPORTER_OTLP_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: \"\",\n  OTEL_EXPORTER_OTLP_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_HEADERS: \"\",\n  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,\n  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,\n  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,\n  OTEL_EXPORTER_ZIPKIN_ENDPOINT: \"http://localhost:9411/api/v2/spans\",\n  OTEL_LOG_LEVEL: DiagLogLevel.INFO,\n  OTEL_NO_PATCH_MODULES: [],\n  OTEL_PROPAGATORS: [\"tracecontext\", \"baggage\"],\n  OTEL_RESOURCE_ATTRIBUTES: \"\",\n  OTEL_SERVICE_NAME: \"\",\n  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,\n  OTEL_SPAN_LINK_COUNT_LIMIT: 128,\n  OTEL_TRACES_EXPORTER: \"none\",\n  OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,\n  OTEL_TRACES_SAMPLER_ARG: \"\",\n  OTEL_EXPORTER_OTLP_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_INSECURE: \"\",\n  OTEL_EXPORTER_OTLP_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: \"\",\n  OTEL_EXPORTER_OTLP_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: \"\",\n  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: \"\",\n  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: \"\"\n};\nfunction parseNumber(name, environment, values, min2, max2) {\n  if (min2 === void 0) {\n    min2 = -Infinity;\n  }\n  if (max2 === void 0) {\n    max2 = Infinity;\n  }\n  if (typeof values[name] !== \"undefined\") {\n    var value = Number(values[name]);\n    if (!isNaN(value)) {\n      if (value < min2) {\n        environment[name] = min2;\n      } else if (value > max2) {\n        environment[name] = max2;\n      } else {\n        environment[name] = value;\n      }\n    }\n  }\n}\n__name(parseNumber, \"parseNumber\");\nfunction parseStringList(name, output, input, separator) {\n  if (separator === void 0) {\n    separator = DEFAULT_LIST_SEPARATOR;\n  }\n  var givenValue = input[name];\n  if (typeof givenValue === \"string\") {\n    output[name] = givenValue.split(separator).map(function(v) {\n      return v.trim();\n    });\n  }\n}\n__name(parseStringList, \"parseStringList\");\nvar logLevelMap = {\n  ALL: DiagLogLevel.ALL,\n  VERBOSE: DiagLogLevel.VERBOSE,\n  DEBUG: DiagLogLevel.DEBUG,\n  INFO: DiagLogLevel.INFO,\n  WARN: DiagLogLevel.WARN,\n  ERROR: DiagLogLevel.ERROR,\n  NONE: DiagLogLevel.NONE\n};\nfunction setLogLevelFromEnv(key, environment, values) {\n  var value = values[key];\n  if (typeof value === \"string\") {\n    var theLevel = logLevelMap[value.toUpperCase()];\n    if (theLevel != null) {\n      environment[key] = theLevel;\n    }\n  }\n}\n__name(setLogLevelFromEnv, \"setLogLevelFromEnv\");\nfunction parseEnvironment(values) {\n  var environment = {};\n  for (var env2 in DEFAULT_ENVIRONMENT) {\n    var key = env2;\n    switch (key) {\n      case \"OTEL_LOG_LEVEL\":\n        setLogLevelFromEnv(key, environment, values);\n        break;\n      default:\n        if (isEnvVarANumber(key)) {\n          parseNumber(key, environment, values);\n        } else if (isEnvVarAList(key)) {\n          parseStringList(key, environment, values);\n        } else {\n          var value = values[key];\n          if (typeof value !== \"undefined\" && value !== null) {\n            environment[key] = String(value);\n          }\n        }\n    }\n  }\n  return environment;\n}\n__name(parseEnvironment, \"parseEnvironment\");\nfunction getEnvWithoutDefaults() {\n  return typeof process !== \"undefined\" ? parseEnvironment(process.env) : parseEnvironment(_globalThis2);\n}\n__name(getEnvWithoutDefaults, \"getEnvWithoutDefaults\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\nfunction getEnv() {\n  var processEnv = parseEnvironment(process.env);\n  return Object.assign({\n    HOSTNAME: os2.hostname()\n  }, DEFAULT_ENVIRONMENT, processEnv);\n}\n__name(getEnv, \"getEnv\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js\nvar _globalThis3 = typeof globalThis === \"object\" ? globalThis : global;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js\nvar buf8 = Buffer.alloc(8);\nvar buf16 = Buffer.alloc(16);\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js\nvar SPAN_ID_BYTES = 8;\nvar TRACE_ID_BYTES = 16;\nvar RandomIdGenerator = function() {\n  function RandomIdGenerator3() {\n    this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n    this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n  }\n  __name(RandomIdGenerator3, \"RandomIdGenerator\");\n  return RandomIdGenerator3;\n}();\nvar SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes) {\n  return /* @__PURE__ */ __name(function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER.toString(\"hex\", 0, bytes);\n  }, \"generateId\");\n}\n__name(getIdGenerator, \"getIdGenerator\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/performance.js\nvar import_perf_hooks = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nvar otperformance = import_perf_hooks.performance;\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/version.js\nvar VERSION2 = \"1.6.0\";\n\n// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.6.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js\nvar SemanticAttributes = {\n  AWS_LAMBDA_INVOKED_ARN: \"aws.lambda.invoked_arn\",\n  DB_SYSTEM: \"db.system\",\n  DB_CONNECTION_STRING: \"db.connection_string\",\n  DB_USER: \"db.user\",\n  DB_JDBC_DRIVER_CLASSNAME: \"db.jdbc.driver_classname\",\n  DB_NAME: \"db.name\",\n  DB_STATEMENT: \"db.statement\",\n  DB_OPERATION: \"db.operation\",\n  DB_MSSQL_INSTANCE_NAME: \"db.mssql.instance_name\",\n  DB_CASSANDRA_KEYSPACE: \"db.cassandra.keyspace\",\n  DB_CASSANDRA_PAGE_SIZE: \"db.cassandra.page_size\",\n  DB_CASSANDRA_CONSISTENCY_LEVEL: \"db.cassandra.consistency_level\",\n  DB_CASSANDRA_TABLE: \"db.cassandra.table\",\n  DB_CASSANDRA_IDEMPOTENCE: \"db.cassandra.idempotence\",\n  DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: \"db.cassandra.speculative_execution_count\",\n  DB_CASSANDRA_COORDINATOR_ID: \"db.cassandra.coordinator.id\",\n  DB_CASSANDRA_COORDINATOR_DC: \"db.cassandra.coordinator.dc\",\n  DB_HBASE_NAMESPACE: \"db.hbase.namespace\",\n  DB_REDIS_DATABASE_INDEX: \"db.redis.database_index\",\n  DB_MONGODB_COLLECTION: \"db.mongodb.collection\",\n  DB_SQL_TABLE: \"db.sql.table\",\n  EXCEPTION_TYPE: \"exception.type\",\n  EXCEPTION_MESSAGE: \"exception.message\",\n  EXCEPTION_STACKTRACE: \"exception.stacktrace\",\n  EXCEPTION_ESCAPED: \"exception.escaped\",\n  FAAS_TRIGGER: \"faas.trigger\",\n  FAAS_EXECUTION: \"faas.execution\",\n  FAAS_DOCUMENT_COLLECTION: \"faas.document.collection\",\n  FAAS_DOCUMENT_OPERATION: \"faas.document.operation\",\n  FAAS_DOCUMENT_TIME: \"faas.document.time\",\n  FAAS_DOCUMENT_NAME: \"faas.document.name\",\n  FAAS_TIME: \"faas.time\",\n  FAAS_CRON: \"faas.cron\",\n  FAAS_COLDSTART: \"faas.coldstart\",\n  FAAS_INVOKED_NAME: \"faas.invoked_name\",\n  FAAS_INVOKED_PROVIDER: \"faas.invoked_provider\",\n  FAAS_INVOKED_REGION: \"faas.invoked_region\",\n  NET_TRANSPORT: \"net.transport\",\n  NET_PEER_IP: \"net.peer.ip\",\n  NET_PEER_PORT: \"net.peer.port\",\n  NET_PEER_NAME: \"net.peer.name\",\n  NET_HOST_IP: \"net.host.ip\",\n  NET_HOST_PORT: \"net.host.port\",\n  NET_HOST_NAME: \"net.host.name\",\n  NET_HOST_CONNECTION_TYPE: \"net.host.connection.type\",\n  NET_HOST_CONNECTION_SUBTYPE: \"net.host.connection.subtype\",\n  NET_HOST_CARRIER_NAME: \"net.host.carrier.name\",\n  NET_HOST_CARRIER_MCC: \"net.host.carrier.mcc\",\n  NET_HOST_CARRIER_MNC: \"net.host.carrier.mnc\",\n  NET_HOST_CARRIER_ICC: \"net.host.carrier.icc\",\n  PEER_SERVICE: \"peer.service\",\n  ENDUSER_ID: \"enduser.id\",\n  ENDUSER_ROLE: \"enduser.role\",\n  ENDUSER_SCOPE: \"enduser.scope\",\n  THREAD_ID: \"thread.id\",\n  THREAD_NAME: \"thread.name\",\n  CODE_FUNCTION: \"code.function\",\n  CODE_NAMESPACE: \"code.namespace\",\n  CODE_FILEPATH: \"code.filepath\",\n  CODE_LINENO: \"code.lineno\",\n  HTTP_METHOD: \"http.method\",\n  HTTP_URL: \"http.url\",\n  HTTP_TARGET: \"http.target\",\n  HTTP_HOST: \"http.host\",\n  HTTP_SCHEME: \"http.scheme\",\n  HTTP_STATUS_CODE: \"http.status_code\",\n  HTTP_FLAVOR: \"http.flavor\",\n  HTTP_USER_AGENT: \"http.user_agent\",\n  HTTP_REQUEST_CONTENT_LENGTH: \"http.request_content_length\",\n  HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: \"http.request_content_length_uncompressed\",\n  HTTP_RESPONSE_CONTENT_LENGTH: \"http.response_content_length\",\n  HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: \"http.response_content_length_uncompressed\",\n  HTTP_SERVER_NAME: \"http.server_name\",\n  HTTP_ROUTE: \"http.route\",\n  HTTP_CLIENT_IP: \"http.client_ip\",\n  AWS_DYNAMODB_TABLE_NAMES: \"aws.dynamodb.table_names\",\n  AWS_DYNAMODB_CONSUMED_CAPACITY: \"aws.dynamodb.consumed_capacity\",\n  AWS_DYNAMODB_ITEM_COLLECTION_METRICS: \"aws.dynamodb.item_collection_metrics\",\n  AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: \"aws.dynamodb.provisioned_read_capacity\",\n  AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: \"aws.dynamodb.provisioned_write_capacity\",\n  AWS_DYNAMODB_CONSISTENT_READ: \"aws.dynamodb.consistent_read\",\n  AWS_DYNAMODB_PROJECTION: \"aws.dynamodb.projection\",\n  AWS_DYNAMODB_LIMIT: \"aws.dynamodb.limit\",\n  AWS_DYNAMODB_ATTRIBUTES_TO_GET: \"aws.dynamodb.attributes_to_get\",\n  AWS_DYNAMODB_INDEX_NAME: \"aws.dynamodb.index_name\",\n  AWS_DYNAMODB_SELECT: \"aws.dynamodb.select\",\n  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: \"aws.dynamodb.global_secondary_indexes\",\n  AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: \"aws.dynamodb.local_secondary_indexes\",\n  AWS_DYNAMODB_EXCLUSIVE_START_TABLE: \"aws.dynamodb.exclusive_start_table\",\n  AWS_DYNAMODB_TABLE_COUNT: \"aws.dynamodb.table_count\",\n  AWS_DYNAMODB_SCAN_FORWARD: \"aws.dynamodb.scan_forward\",\n  AWS_DYNAMODB_SEGMENT: \"aws.dynamodb.segment\",\n  AWS_DYNAMODB_TOTAL_SEGMENTS: \"aws.dynamodb.total_segments\",\n  AWS_DYNAMODB_COUNT: \"aws.dynamodb.count\",\n  AWS_DYNAMODB_SCANNED_COUNT: \"aws.dynamodb.scanned_count\",\n  AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: \"aws.dynamodb.attribute_definitions\",\n  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: \"aws.dynamodb.global_secondary_index_updates\",\n  MESSAGING_SYSTEM: \"messaging.system\",\n  MESSAGING_DESTINATION: \"messaging.destination\",\n  MESSAGING_DESTINATION_KIND: \"messaging.destination_kind\",\n  MESSAGING_TEMP_DESTINATION: \"messaging.temp_destination\",\n  MESSAGING_PROTOCOL: \"messaging.protocol\",\n  MESSAGING_PROTOCOL_VERSION: \"messaging.protocol_version\",\n  MESSAGING_URL: \"messaging.url\",\n  MESSAGING_MESSAGE_ID: \"messaging.message_id\",\n  MESSAGING_CONVERSATION_ID: \"messaging.conversation_id\",\n  MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: \"messaging.message_payload_size_bytes\",\n  MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: \"messaging.message_payload_compressed_size_bytes\",\n  MESSAGING_OPERATION: \"messaging.operation\",\n  MESSAGING_CONSUMER_ID: \"messaging.consumer_id\",\n  MESSAGING_RABBITMQ_ROUTING_KEY: \"messaging.rabbitmq.routing_key\",\n  MESSAGING_KAFKA_MESSAGE_KEY: \"messaging.kafka.message_key\",\n  MESSAGING_KAFKA_CONSUMER_GROUP: \"messaging.kafka.consumer_group\",\n  MESSAGING_KAFKA_CLIENT_ID: \"messaging.kafka.client_id\",\n  MESSAGING_KAFKA_PARTITION: \"messaging.kafka.partition\",\n  MESSAGING_KAFKA_TOMBSTONE: \"messaging.kafka.tombstone\",\n  RPC_SYSTEM: \"rpc.system\",\n  RPC_SERVICE: \"rpc.service\",\n  RPC_METHOD: \"rpc.method\",\n  RPC_GRPC_STATUS_CODE: \"rpc.grpc.status_code\",\n  RPC_JSONRPC_VERSION: \"rpc.jsonrpc.version\",\n  RPC_JSONRPC_REQUEST_ID: \"rpc.jsonrpc.request_id\",\n  RPC_JSONRPC_ERROR_CODE: \"rpc.jsonrpc.error_code\",\n  RPC_JSONRPC_ERROR_MESSAGE: \"rpc.jsonrpc.error_message\",\n  MESSAGE_TYPE: \"message.type\",\n  MESSAGE_ID: \"message.id\",\n  MESSAGE_COMPRESSED_SIZE: \"message.compressed_size\",\n  MESSAGE_UNCOMPRESSED_SIZE: \"message.uncompressed_size\"\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.6.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js\nvar SemanticResourceAttributes = {\n  CLOUD_PROVIDER: \"cloud.provider\",\n  CLOUD_ACCOUNT_ID: \"cloud.account.id\",\n  CLOUD_REGION: \"cloud.region\",\n  CLOUD_AVAILABILITY_ZONE: \"cloud.availability_zone\",\n  CLOUD_PLATFORM: \"cloud.platform\",\n  AWS_ECS_CONTAINER_ARN: \"aws.ecs.container.arn\",\n  AWS_ECS_CLUSTER_ARN: \"aws.ecs.cluster.arn\",\n  AWS_ECS_LAUNCHTYPE: \"aws.ecs.launchtype\",\n  AWS_ECS_TASK_ARN: \"aws.ecs.task.arn\",\n  AWS_ECS_TASK_FAMILY: \"aws.ecs.task.family\",\n  AWS_ECS_TASK_REVISION: \"aws.ecs.task.revision\",\n  AWS_EKS_CLUSTER_ARN: \"aws.eks.cluster.arn\",\n  AWS_LOG_GROUP_NAMES: \"aws.log.group.names\",\n  AWS_LOG_GROUP_ARNS: \"aws.log.group.arns\",\n  AWS_LOG_STREAM_NAMES: \"aws.log.stream.names\",\n  AWS_LOG_STREAM_ARNS: \"aws.log.stream.arns\",\n  CONTAINER_NAME: \"container.name\",\n  CONTAINER_ID: \"container.id\",\n  CONTAINER_RUNTIME: \"container.runtime\",\n  CONTAINER_IMAGE_NAME: \"container.image.name\",\n  CONTAINER_IMAGE_TAG: \"container.image.tag\",\n  DEPLOYMENT_ENVIRONMENT: \"deployment.environment\",\n  DEVICE_ID: \"device.id\",\n  DEVICE_MODEL_IDENTIFIER: \"device.model.identifier\",\n  DEVICE_MODEL_NAME: \"device.model.name\",\n  FAAS_NAME: \"faas.name\",\n  FAAS_ID: \"faas.id\",\n  FAAS_VERSION: \"faas.version\",\n  FAAS_INSTANCE: \"faas.instance\",\n  FAAS_MAX_MEMORY: \"faas.max_memory\",\n  HOST_ID: \"host.id\",\n  HOST_NAME: \"host.name\",\n  HOST_TYPE: \"host.type\",\n  HOST_ARCH: \"host.arch\",\n  HOST_IMAGE_NAME: \"host.image.name\",\n  HOST_IMAGE_ID: \"host.image.id\",\n  HOST_IMAGE_VERSION: \"host.image.version\",\n  K8S_CLUSTER_NAME: \"k8s.cluster.name\",\n  K8S_NODE_NAME: \"k8s.node.name\",\n  K8S_NODE_UID: \"k8s.node.uid\",\n  K8S_NAMESPACE_NAME: \"k8s.namespace.name\",\n  K8S_POD_UID: \"k8s.pod.uid\",\n  K8S_POD_NAME: \"k8s.pod.name\",\n  K8S_CONTAINER_NAME: \"k8s.container.name\",\n  K8S_REPLICASET_UID: \"k8s.replicaset.uid\",\n  K8S_REPLICASET_NAME: \"k8s.replicaset.name\",\n  K8S_DEPLOYMENT_UID: \"k8s.deployment.uid\",\n  K8S_DEPLOYMENT_NAME: \"k8s.deployment.name\",\n  K8S_STATEFULSET_UID: \"k8s.statefulset.uid\",\n  K8S_STATEFULSET_NAME: \"k8s.statefulset.name\",\n  K8S_DAEMONSET_UID: \"k8s.daemonset.uid\",\n  K8S_DAEMONSET_NAME: \"k8s.daemonset.name\",\n  K8S_JOB_UID: \"k8s.job.uid\",\n  K8S_JOB_NAME: \"k8s.job.name\",\n  K8S_CRONJOB_UID: \"k8s.cronjob.uid\",\n  K8S_CRONJOB_NAME: \"k8s.cronjob.name\",\n  OS_TYPE: \"os.type\",\n  OS_DESCRIPTION: \"os.description\",\n  OS_NAME: \"os.name\",\n  OS_VERSION: \"os.version\",\n  PROCESS_PID: \"process.pid\",\n  PROCESS_EXECUTABLE_NAME: \"process.executable.name\",\n  PROCESS_EXECUTABLE_PATH: \"process.executable.path\",\n  PROCESS_COMMAND: \"process.command\",\n  PROCESS_COMMAND_LINE: \"process.command_line\",\n  PROCESS_COMMAND_ARGS: \"process.command_args\",\n  PROCESS_OWNER: \"process.owner\",\n  PROCESS_RUNTIME_NAME: \"process.runtime.name\",\n  PROCESS_RUNTIME_VERSION: \"process.runtime.version\",\n  PROCESS_RUNTIME_DESCRIPTION: \"process.runtime.description\",\n  SERVICE_NAME: \"service.name\",\n  SERVICE_NAMESPACE: \"service.namespace\",\n  SERVICE_INSTANCE_ID: \"service.instance.id\",\n  SERVICE_VERSION: \"service.version\",\n  TELEMETRY_SDK_NAME: \"telemetry.sdk.name\",\n  TELEMETRY_SDK_LANGUAGE: \"telemetry.sdk.language\",\n  TELEMETRY_SDK_VERSION: \"telemetry.sdk.version\",\n  TELEMETRY_AUTO_VERSION: \"telemetry.auto.version\",\n  WEBENGINE_NAME: \"webengine.name\",\n  WEBENGINE_VERSION: \"webengine.version\",\n  WEBENGINE_DESCRIPTION: \"webengine.description\"\n};\nvar TelemetrySdkLanguageValues = {\n  CPP: \"cpp\",\n  DOTNET: \"dotnet\",\n  ERLANG: \"erlang\",\n  GO: \"go\",\n  JAVA: \"java\",\n  NODEJS: \"nodejs\",\n  PHP: \"php\",\n  PYTHON: \"python\",\n  RUBY: \"ruby\",\n  WEBJS: \"webjs\"\n};\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js\nvar _a2;\nvar SDK_INFO = (_a2 = {}, _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = \"opentelemetry\", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"node\", _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.NODEJS, _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION2, _a2);\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js\nfunction unrefTimer(timer) {\n  timer.unref();\n}\n__name(unrefTimer, \"unrefTimer\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/common/time.js\nvar NANOSECOND_DIGITS = 9;\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\nfunction numberToHrtime(epochMillis) {\n  var epochSeconds = epochMillis / 1e3;\n  var seconds = Math.trunc(epochSeconds);\n  var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) * SECOND_TO_NANOSECONDS;\n  return [seconds, nanos];\n}\n__name(numberToHrtime, \"numberToHrtime\");\nfunction getTimeOrigin() {\n  var timeOrigin = otperformance.timeOrigin;\n  if (typeof timeOrigin !== \"number\") {\n    var perf = otperformance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\n__name(getTimeOrigin, \"getTimeOrigin\");\nfunction hrTime(performanceNow) {\n  var timeOrigin = numberToHrtime(getTimeOrigin());\n  var now = numberToHrtime(typeof performanceNow === \"number\" ? performanceNow : otperformance.now());\n  var seconds = timeOrigin[0] + now[0];\n  var nanos = timeOrigin[1] + now[1];\n  if (nanos > SECOND_TO_NANOSECONDS) {\n    nanos -= SECOND_TO_NANOSECONDS;\n    seconds += 1;\n  }\n  return [seconds, nanos];\n}\n__name(hrTime, \"hrTime\");\nfunction timeInputToHrTime(time) {\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === \"number\") {\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      return numberToHrtime(time);\n    }\n  } else if (time instanceof Date) {\n    return numberToHrtime(time.getTime());\n  } else {\n    throw TypeError(\"Invalid input type\");\n  }\n}\n__name(timeInputToHrTime, \"timeInputToHrTime\");\nfunction hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1];\n  if (nanos < 0) {\n    seconds -= 1;\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n  return [seconds, nanos];\n}\n__name(hrTimeDuration, \"hrTimeDuration\");\nfunction hrTimeToMicroseconds(time) {\n  return Math.round(time[0] * 1e6 + time[1] / 1e3);\n}\n__name(hrTimeToMicroseconds, \"hrTimeToMicroseconds\");\nfunction isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === \"number\" && typeof value[1] === \"number\";\n}\n__name(isTimeInputHrTime, \"isTimeInputHrTime\");\nfunction isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === \"number\" || value instanceof Date;\n}\n__name(isTimeInput, \"isTimeInput\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/ExportResult.js\nvar ExportResultCode;\n(function(ExportResultCode2) {\n  ExportResultCode2[ExportResultCode2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  ExportResultCode2[ExportResultCode2[\"FAILED\"] = 1] = \"FAILED\";\n})(ExportResultCode || (ExportResultCode = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/propagation/composite.js\nvar __values2 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar CompositePropagator = function() {\n  function CompositePropagator2(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    var _a3;\n    this._propagators = (_a3 = config2.propagators) !== null && _a3 !== void 0 ? _a3 : [];\n    this._fields = Array.from(new Set(this._propagators.map(function(p) {\n      return typeof p.fields === \"function\" ? p.fields() : [];\n    }).reduce(function(x, y) {\n      return x.concat(y);\n    }, [])));\n  }\n  __name(CompositePropagator2, \"CompositePropagator\");\n  CompositePropagator2.prototype.inject = function(context3, carrier, setter) {\n    var e_1, _a3;\n    try {\n      for (var _b2 = __values2(this._propagators), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var propagator = _c.value;\n        try {\n          propagator.inject(context3, carrier, setter);\n        } catch (err) {\n          diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n  };\n  CompositePropagator2.prototype.extract = function(context3, carrier, getter) {\n    return this._propagators.reduce(function(ctx, propagator) {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n      }\n      return ctx;\n    }, context3);\n  };\n  CompositePropagator2.prototype.fields = function() {\n    return this._fields.slice();\n  };\n  return CompositePropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/internal/validators.js\nvar VALID_KEY_CHAR_RANGE2 = \"[_0-9a-z-*/]\";\nvar VALID_KEY2 = \"[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,255}\";\nvar VALID_VENDOR_KEY2 = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE2 + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,13}\";\nvar VALID_KEY_REGEX2 = new RegExp(\"^(?:\" + VALID_KEY2 + \"|\" + VALID_VENDOR_KEY2 + \")$\");\nvar VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;\nvar INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;\nfunction validateKey2(key) {\n  return VALID_KEY_REGEX2.test(key);\n}\n__name(validateKey2, \"validateKey\");\nfunction validateValue2(value) {\n  return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);\n}\n__name(validateValue2, \"validateValue\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js\nvar MAX_TRACE_STATE_ITEMS2 = 32;\nvar MAX_TRACE_STATE_LEN2 = 512;\nvar LIST_MEMBERS_SEPARATOR2 = \",\";\nvar LIST_MEMBER_KEY_VALUE_SPLITTER2 = \"=\";\nvar TraceState = function() {\n  function TraceState2(rawTraceState) {\n    this._internalState = /* @__PURE__ */ new Map();\n    if (rawTraceState)\n      this._parse(rawTraceState);\n  }\n  __name(TraceState2, \"TraceState\");\n  TraceState2.prototype.set = function(key, value) {\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceState2.prototype.unset = function(key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceState2.prototype.get = function(key) {\n    return this._internalState.get(key);\n  };\n  TraceState2.prototype.serialize = function() {\n    var _this = this;\n    return this._keys().reduce(function(agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR2);\n  };\n  TraceState2.prototype._parse = function(rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN2)\n      return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce(function(agg, part) {\n      var listMember = part.trim();\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey2(key) && validateValue2(value)) {\n          agg.set(key, value);\n        } else {\n        }\n      }\n      return agg;\n    }, /* @__PURE__ */ new Map());\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));\n    }\n  };\n  TraceState2.prototype._keys = function() {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceState2.prototype._clone = function() {\n    var traceState = new TraceState2();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceState2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js\nvar TRACE_PARENT_HEADER = \"traceparent\";\nvar TRACE_STATE_HEADER = \"tracestate\";\nvar VERSION3 = \"00\";\nvar VERSION_PART = \"(?!ff)[\\\\da-f]{2}\";\nvar TRACE_ID_PART = \"(?![0]{32})[\\\\da-f]{32}\";\nvar PARENT_ID_PART = \"(?![0]{16})[\\\\da-f]{16}\";\nvar FLAGS_PART = \"[\\\\da-f]{2}\";\nvar TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\nfunction parseTraceParent(traceParent) {\n  var match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match)\n    return null;\n  if (match[1] === \"00\" && match[5])\n    return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\n__name(parseTraceParent, \"parseTraceParent\");\nvar W3CTraceContextPropagator = function() {\n  function W3CTraceContextPropagator2() {\n  }\n  __name(W3CTraceContextPropagator2, \"W3CTraceContextPropagator\");\n  W3CTraceContextPropagator2.prototype.inject = function(context3, carrier, setter) {\n    var spanContext = trace.getSpanContext(context3);\n    if (!spanContext || isTracingSuppressed(context3) || !isSpanContextValid(spanContext))\n      return;\n    var traceParent = VERSION3 + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n    }\n  };\n  W3CTraceContextPropagator2.prototype.extract = function(context3, carrier, getter) {\n    var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader)\n      return context3;\n    var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n    if (typeof traceParent !== \"string\")\n      return context3;\n    var spanContext = parseTraceParent(traceParent);\n    if (!spanContext)\n      return context3;\n    spanContext.isRemote = true;\n    var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(\",\") : traceStateHeader;\n      spanContext.traceState = new TraceState(typeof state === \"string\" ? state : void 0);\n    }\n    return trace.setSpanContext(context3, spanContext);\n  };\n  W3CTraceContextPropagator2.prototype.fields = function() {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  };\n  return W3CTraceContextPropagator2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js\nvar RPC_METADATA_KEY = createContextKey(\"OpenTelemetry SDK Context Key RPC_METADATA\");\nvar RPCType;\n(function(RPCType2) {\n  RPCType2[\"HTTP\"] = \"http\";\n})(RPCType || (RPCType = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler = function() {\n  function AlwaysOffSampler3() {\n  }\n  __name(AlwaysOffSampler3, \"AlwaysOffSampler\");\n  AlwaysOffSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision.NOT_RECORD\n    };\n  };\n  AlwaysOffSampler3.prototype.toString = function() {\n    return \"AlwaysOffSampler\";\n  };\n  return AlwaysOffSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler = function() {\n  function AlwaysOnSampler3() {\n  }\n  __name(AlwaysOnSampler3, \"AlwaysOnSampler\");\n  AlwaysOnSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED\n    };\n  };\n  AlwaysOnSampler3.prototype.toString = function() {\n    return \"AlwaysOnSampler\";\n  };\n  return AlwaysOnSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js\nvar ParentBasedSampler = function() {\n  function ParentBasedSampler3(config2) {\n    var _a3, _b2, _c, _d;\n    this._root = config2.root;\n    if (!this._root) {\n      globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n      this._root = new AlwaysOnSampler();\n    }\n    this._remoteParentSampled = (_a3 = config2.remoteParentSampled) !== null && _a3 !== void 0 ? _a3 : new AlwaysOnSampler();\n    this._remoteParentNotSampled = (_b2 = config2.remoteParentNotSampled) !== null && _b2 !== void 0 ? _b2 : new AlwaysOffSampler();\n    this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();\n    this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();\n  }\n  __name(ParentBasedSampler3, \"ParentBasedSampler\");\n  ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {\n    var parentContext = trace.getSpanContext(context3);\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n      }\n      return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n  };\n  ParentBasedSampler3.prototype.toString = function() {\n    return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n  };\n  return ParentBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler = function() {\n  function TraceIdRatioBasedSampler3(_ratio) {\n    if (_ratio === void 0) {\n      _ratio = 0;\n    }\n    this._ratio = _ratio;\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 4294967295);\n  }\n  __name(TraceIdRatioBasedSampler3, \"TraceIdRatioBasedSampler\");\n  TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {\n    return {\n      decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD\n    };\n  };\n  TraceIdRatioBasedSampler3.prototype.toString = function() {\n    return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n  };\n  TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n    if (typeof ratio !== \"number\" || isNaN(ratio))\n      return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  };\n  TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n    var accumulation = 0;\n    for (var i = 0; i < traceId.length / 8; i++) {\n      var pos = i * 8;\n      var part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  };\n  return TraceIdRatioBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js\nvar objectTag = \"[object Object]\";\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nvar objectCtorString = funcToString.call(Object);\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar symToStringTag = Symbol ? Symbol.toStringTag : void 0;\nvar nativeObjectToString = objectProto.toString;\nfunction overArg(func, transform) {\n  return function(arg2) {\n    return func(transform(arg2));\n  };\n}\n__name(overArg, \"overArg\");\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;\n}\n__name(isPlainObject, \"isPlainObject\");\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\n__name(isObjectLike, \"isObjectLike\");\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n__name(baseGetTag, \"baseGetTag\");\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];\n  var unmasked = false;\n  try {\n    value[symToStringTag] = void 0;\n    unmasked = true;\n  } catch (e) {\n  }\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag2;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n__name(getRawTag, \"getRawTag\");\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n__name(objectToString, \"objectToString\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/merge.js\nvar MAX_LEVEL = 20;\nfunction merge() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var result = args.shift();\n  var objects = /* @__PURE__ */ new WeakMap();\n  while (args.length > 0) {\n    result = mergeTwoObjects(result, args.shift(), 0, objects);\n  }\n  return result;\n}\n__name(merge, \"merge\");\nfunction takeValue(value) {\n  if (isArray(value)) {\n    return value.slice();\n  }\n  return value;\n}\n__name(takeValue, \"takeValue\");\nfunction mergeTwoObjects(one, two, level, objects) {\n  if (level === void 0) {\n    level = 0;\n  }\n  var result;\n  if (level > MAX_LEVEL) {\n    return void 0;\n  }\n  level++;\n  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {\n    result = takeValue(two);\n  } else if (isArray(one)) {\n    result = one.slice();\n    if (isArray(two)) {\n      for (var i = 0, j = two.length; i < j; i++) {\n        result.push(takeValue(two[i]));\n      }\n    } else if (isObject(two)) {\n      var keys2 = Object.keys(two);\n      for (var i = 0, j = keys2.length; i < j; i++) {\n        var key = keys2[i];\n        result[key] = takeValue(two[key]);\n      }\n    }\n  } else if (isObject(one)) {\n    if (isObject(two)) {\n      if (!shouldMerge(one, two)) {\n        return two;\n      }\n      result = Object.assign({}, one);\n      var keys2 = Object.keys(two);\n      for (var i = 0, j = keys2.length; i < j; i++) {\n        var key = keys2[i];\n        var twoValue = two[key];\n        if (isPrimitive(twoValue)) {\n          if (typeof twoValue === \"undefined\") {\n            delete result[key];\n          } else {\n            result[key] = twoValue;\n          }\n        } else {\n          var obj1 = result[key];\n          var obj2 = twoValue;\n          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {\n            delete result[key];\n          } else {\n            if (isObject(obj1) && isObject(obj2)) {\n              var arr1 = objects.get(obj1) || [];\n              var arr2 = objects.get(obj2) || [];\n              arr1.push({ obj: one, key });\n              arr2.push({ obj: two, key });\n              objects.set(obj1, arr1);\n              objects.set(obj2, arr2);\n            }\n            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);\n          }\n        }\n      }\n    } else {\n      result = two;\n    }\n  }\n  return result;\n}\n__name(mergeTwoObjects, \"mergeTwoObjects\");\nfunction wasObjectReferenced(obj, key, objects) {\n  var arr = objects.get(obj[key]) || [];\n  for (var i = 0, j = arr.length; i < j; i++) {\n    var info2 = arr[i];\n    if (info2.key === key && info2.obj === obj) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(wasObjectReferenced, \"wasObjectReferenced\");\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n__name(isArray, \"isArray\");\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n__name(isFunction, \"isFunction\");\nfunction isObject(value) {\n  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === \"object\";\n}\n__name(isObject, \"isObject\");\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"undefined\" || value instanceof Date || value instanceof RegExp || value === null;\n}\n__name(isPrimitive, \"isPrimitive\");\nfunction shouldMerge(one, two) {\n  if (!isPlainObject(one) || !isPlainObject(two)) {\n    return false;\n  }\n  return true;\n}\n__name(shouldMerge, \"shouldMerge\");\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/promise.js\nvar Deferred = function() {\n  function Deferred2() {\n    var _this = this;\n    this._promise = new Promise(function(resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  }\n  __name(Deferred2, \"Deferred\");\n  Object.defineProperty(Deferred2.prototype, \"promise\", {\n    get: function() {\n      return this._promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Deferred2.prototype.resolve = function(val) {\n    this._resolve(val);\n  };\n  Deferred2.prototype.reject = function(err) {\n    this._reject(err);\n  };\n  return Deferred2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+core@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/core/build/esm/utils/callback.js\nvar __read3 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray3 = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar BindOnceFuture = function() {\n  function BindOnceFuture2(_callback, _that) {\n    this._callback = _callback;\n    this._that = _that;\n    this._isCalled = false;\n    this._deferred = new Deferred();\n  }\n  __name(BindOnceFuture2, \"BindOnceFuture\");\n  Object.defineProperty(BindOnceFuture2.prototype, \"isCalled\", {\n    get: function() {\n      return this._isCalled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BindOnceFuture2.prototype, \"promise\", {\n    get: function() {\n      return this._deferred.promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BindOnceFuture2.prototype.call = function() {\n    var _a3;\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (!this._isCalled) {\n      this._isCalled = true;\n      try {\n        Promise.resolve((_a3 = this._callback).call.apply(_a3, __spreadArray3([this._that], __read3(args), false))).then(function(val) {\n          return _this._deferred.resolve(val);\n        }, function(err) {\n          return _this._deferred.reject(err);\n        });\n      } catch (err) {\n        this._deferred.reject(err);\n      }\n    }\n    return this._deferred.promise;\n  };\n  return BindOnceFuture2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js\nvar ExceptionEventName = \"exception\";\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js\nvar __values3 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read4 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar Span = function() {\n  function Span3(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links, startTime) {\n    if (links === void 0) {\n      links = [];\n    }\n    if (startTime === void 0) {\n      startTime = hrTime();\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this.status = {\n      code: SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    this.startTime = timeInputToHrTime(startTime);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context3);\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n  }\n  __name(Span3, \"Span\");\n  Span3.prototype.spanContext = function() {\n    return this._spanContext;\n  };\n  Span3.prototype.setAttribute = function(key, value) {\n    if (value == null || this._isSpanEnded())\n      return this;\n    if (key.length === 0) {\n      diag2.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag2.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span3.prototype.setAttributes = function(attributes) {\n    var e_1, _a3;\n    try {\n      for (var _b2 = __values3(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var _d = __read4(_c.value, 2), k = _d[0], v = _d[1];\n        this.setAttribute(k, v);\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return this;\n  };\n  Span3.prototype.addEvent = function(name, attributesOrStartTime, startTime) {\n    if (this._isSpanEnded())\n      return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag2.warn(\"No events allowed.\");\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      diag2.warn(\"Dropping extra events.\");\n      this.events.shift();\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (typeof startTime === \"undefined\") {\n        startTime = attributesOrStartTime;\n      }\n      attributesOrStartTime = void 0;\n    }\n    if (typeof startTime === \"undefined\") {\n      startTime = hrTime();\n    }\n    var attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name,\n      attributes,\n      time: timeInputToHrTime(startTime)\n    });\n    return this;\n  };\n  Span3.prototype.setStatus = function(status) {\n    if (this._isSpanEnded())\n      return this;\n    this.status = status;\n    return this;\n  };\n  Span3.prototype.updateName = function(name) {\n    if (this._isSpanEnded())\n      return this;\n    this.name = name;\n    return this;\n  };\n  Span3.prototype.end = function(endTime) {\n    if (endTime === void 0) {\n      endTime = hrTime();\n    }\n    if (this._isSpanEnded()) {\n      diag2.error(\"You can only call end() on a span once.\");\n      return;\n    }\n    this._ended = true;\n    this.endTime = timeInputToHrTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag2.warn(\"Inconsistent start and end time, startTime > endTime\", this.startTime, this.endTime);\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span3.prototype.isRecording = function() {\n    return this._ended === false;\n  };\n  Span3.prototype.recordException = function(exception, time) {\n    if (time === void 0) {\n      time = hrTime();\n    }\n    var attributes = {};\n    if (typeof exception === \"string\") {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag2.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span3.prototype, \"duration\", {\n    get: function() {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span3.prototype, \"ended\", {\n    get: function() {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span3.prototype._isSpanEnded = function() {\n    if (this._ended) {\n      diag2.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  Span3.prototype._truncateToLimitUtil = function(value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  };\n  Span3.prototype._truncateToSize = function(value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    if (limit <= 0) {\n      diag2.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    if (typeof value === \"string\") {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    if (Array.isArray(value)) {\n      return value.map(function(val) {\n        return typeof val === \"string\" ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    return value;\n  };\n  return Span3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js\nvar SamplingDecision2;\n(function(SamplingDecision3) {\n  SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n  SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n})(SamplingDecision2 || (SamplingDecision2 = {}));\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler2 = function() {\n  function AlwaysOffSampler3() {\n  }\n  __name(AlwaysOffSampler3, \"AlwaysOffSampler\");\n  AlwaysOffSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision2.NOT_RECORD\n    };\n  };\n  AlwaysOffSampler3.prototype.toString = function() {\n    return \"AlwaysOffSampler\";\n  };\n  return AlwaysOffSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler2 = function() {\n  function AlwaysOnSampler3() {\n  }\n  __name(AlwaysOnSampler3, \"AlwaysOnSampler\");\n  AlwaysOnSampler3.prototype.shouldSample = function() {\n    return {\n      decision: SamplingDecision2.RECORD_AND_SAMPLED\n    };\n  };\n  AlwaysOnSampler3.prototype.toString = function() {\n    return \"AlwaysOnSampler\";\n  };\n  return AlwaysOnSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js\nvar ParentBasedSampler2 = function() {\n  function ParentBasedSampler3(config2) {\n    var _a3, _b2, _c, _d;\n    this._root = config2.root;\n    if (!this._root) {\n      globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n      this._root = new AlwaysOnSampler2();\n    }\n    this._remoteParentSampled = (_a3 = config2.remoteParentSampled) !== null && _a3 !== void 0 ? _a3 : new AlwaysOnSampler2();\n    this._remoteParentNotSampled = (_b2 = config2.remoteParentNotSampled) !== null && _b2 !== void 0 ? _b2 : new AlwaysOffSampler2();\n    this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler2();\n    this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler2();\n  }\n  __name(ParentBasedSampler3, \"ParentBasedSampler\");\n  ParentBasedSampler3.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {\n    var parentContext = trace.getSpanContext(context3);\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n      }\n      return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n    }\n    return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);\n  };\n  ParentBasedSampler3.prototype.toString = function() {\n    return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n  };\n  return ParentBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler2 = function() {\n  function TraceIdRatioBasedSampler3(_ratio) {\n    if (_ratio === void 0) {\n      _ratio = 0;\n    }\n    this._ratio = _ratio;\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 4294967295);\n  }\n  __name(TraceIdRatioBasedSampler3, \"TraceIdRatioBasedSampler\");\n  TraceIdRatioBasedSampler3.prototype.shouldSample = function(context3, traceId) {\n    return {\n      decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision2.RECORD_AND_SAMPLED : SamplingDecision2.NOT_RECORD\n    };\n  };\n  TraceIdRatioBasedSampler3.prototype.toString = function() {\n    return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n  };\n  TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n    if (typeof ratio !== \"number\" || isNaN(ratio))\n      return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  };\n  TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n    var accumulation = 0;\n    for (var i = 0; i < traceId.length / 8; i++) {\n      var pos = i * 8;\n      var part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  };\n  return TraceIdRatioBasedSampler3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js\nvar env = getEnv();\nvar FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;\nvar DEFAULT_RATIO = 1;\nfunction loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(env),\n    forceFlushTimeoutMillis: 3e4,\n    generalLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT\n    },\n    spanLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n      linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,\n      eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT\n    }\n  };\n}\n__name(loadDefaultConfig, \"loadDefaultConfig\");\nfunction buildSamplerFromEnv(environment) {\n  if (environment === void 0) {\n    environment = getEnv();\n  }\n  switch (environment.OTEL_TRACES_SAMPLER) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler2();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler2();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler2({\n        root: new AlwaysOnSampler2()\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler2({\n        root: new AlwaysOffSampler2()\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment));\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler2({\n        root: new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment))\n      });\n    default:\n      diag2.error('OTEL_TRACES_SAMPLER value \"' + environment.OTEL_TRACES_SAMPLER + \" invalid, defaulting to \" + FALLBACK_OTEL_TRACES_SAMPLER + '\".');\n      return new AlwaysOnSampler2();\n  }\n}\n__name(buildSamplerFromEnv, \"buildSamplerFromEnv\");\nfunction getSamplerProbabilityFromEnv(environment) {\n  if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === \"\") {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG is blank, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);\n  if (isNaN(probability)) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is invalid, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  if (probability < 0 || probability > 1) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is out of range ([0..1]), defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  return probability;\n}\n__name(getSamplerProbabilityFromEnv, \"getSamplerProbabilityFromEnv\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js\nfunction mergeConfig(userConfig) {\n  var perInstanceDefaults = {\n    sampler: buildSamplerFromEnv()\n  };\n  var DEFAULT_CONFIG = loadDefaultConfig();\n  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);\n  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});\n  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});\n  return target;\n}\n__name(mergeConfig, \"mergeConfig\");\nfunction reconfigureLimits(userConfig) {\n  var _a3, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n  var spanLimits = Object.assign({}, userConfig.spanLimits);\n  var parsedEnvConfig = getEnvWithoutDefaults();\n  spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b2 = (_a3 = userConfig.spanLimits) === null || _a3 === void 0 ? void 0 : _a3.attributeCountLimit) !== null && _b2 !== void 0 ? _b2 : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n  return Object.assign({}, userConfig, { spanLimits });\n}\n__name(reconfigureLimits, \"reconfigureLimits\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js\nvar BatchSpanProcessorBase = function() {\n  function BatchSpanProcessorBase2(_exporter, config2) {\n    this._exporter = _exporter;\n    this._finishedSpans = [];\n    var env2 = getEnv();\n    this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === \"number\" ? config2.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === \"number\" ? config2.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === \"number\" ? config2.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === \"number\" ? config2.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n  __name(BatchSpanProcessorBase2, \"BatchSpanProcessorBase\");\n  BatchSpanProcessorBase2.prototype.forceFlush = function() {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  };\n  BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {\n  };\n  BatchSpanProcessorBase2.prototype.onEnd = function(span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    this._addToBuffer(span);\n  };\n  BatchSpanProcessorBase2.prototype.shutdown = function() {\n    return this._shutdownOnce.call();\n  };\n  BatchSpanProcessorBase2.prototype._shutdown = function() {\n    var _this = this;\n    return Promise.resolve().then(function() {\n      return _this.onShutdown();\n    }).then(function() {\n      return _this._flushAll();\n    }).then(function() {\n      return _this._exporter.shutdown();\n    });\n  };\n  BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      return;\n    }\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  };\n  BatchSpanProcessorBase2.prototype._flushAll = function() {\n    var _this = this;\n    return new Promise(function(resolve, reject) {\n      var promises = [];\n      var count2 = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n      for (var i = 0, j = count2; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n      Promise.all(promises).then(function() {\n        resolve();\n      }).catch(reject);\n    });\n  };\n  BatchSpanProcessorBase2.prototype._flushOneBatch = function() {\n    var _this = this;\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise(function(resolve, reject) {\n      var timer = setTimeout(function() {\n        reject(new Error(\"Timeout\"));\n      }, _this._exportTimeoutMillis);\n      context2.with(suppressTracing(context2.active()), function() {\n        _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function(result) {\n          var _a3;\n          clearTimeout(timer);\n          if (result.code === ExportResultCode.SUCCESS) {\n            resolve();\n          } else {\n            reject((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error(\"BatchSpanProcessor: span export failed\"));\n          }\n        });\n      });\n    });\n  };\n  BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {\n    var _this = this;\n    if (this._timer !== void 0)\n      return;\n    this._timer = setTimeout(function() {\n      _this._flushOneBatch().then(function() {\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n          _this._maybeStartTimer();\n        }\n      }).catch(function(e) {\n        globalErrorHandler(e);\n      });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n  BatchSpanProcessorBase2.prototype._clearTimer = function() {\n    if (this._timer !== void 0) {\n      clearTimeout(this._timer);\n      this._timer = void 0;\n    }\n  };\n  return BatchSpanProcessorBase2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js\nvar __extends = function() {\n  var extendStatics = /* @__PURE__ */ __name(function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  }, \"extendStatics\");\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    __name(__, \"__\");\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar BatchSpanProcessor = function(_super) {\n  __extends(BatchSpanProcessor2, _super);\n  function BatchSpanProcessor2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  __name(BatchSpanProcessor2, \"BatchSpanProcessor\");\n  BatchSpanProcessor2.prototype.onShutdown = function() {\n  };\n  return BatchSpanProcessor2;\n}(BatchSpanProcessorBase);\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js\nvar SPAN_ID_BYTES2 = 8;\nvar TRACE_ID_BYTES2 = 16;\nvar RandomIdGenerator2 = function() {\n  function RandomIdGenerator3() {\n    this.generateTraceId = getIdGenerator2(TRACE_ID_BYTES2);\n    this.generateSpanId = getIdGenerator2(SPAN_ID_BYTES2);\n  }\n  __name(RandomIdGenerator3, \"RandomIdGenerator\");\n  return RandomIdGenerator3;\n}();\nvar SHARED_BUFFER2 = Buffer.allocUnsafe(TRACE_ID_BYTES2);\nfunction getIdGenerator2(bytes) {\n  return /* @__PURE__ */ __name(function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER2.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER2[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER2[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER2.toString(\"hex\", 0, bytes);\n  }, \"generateId\");\n}\n__name(getIdGenerator2, \"getIdGenerator\");\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js\nvar Tracer = function() {\n  function Tracer3(instrumentationLibrary, config2, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config2);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config2.idGenerator || new RandomIdGenerator2();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  __name(Tracer3, \"Tracer\");\n  Tracer3.prototype.startSpan = function(name, options, context3) {\n    var _a3, _b2;\n    if (options === void 0) {\n      options = {};\n    }\n    if (context3 === void 0) {\n      context3 = context2.active();\n    }\n    if (isTracingSuppressed(context3)) {\n      diag2.debug(\"Instrumentation suppressed, returning Noop Span\");\n      return trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n    }\n    if (options.root) {\n      context3 = trace.deleteSpan(context3);\n    }\n    var parentSpanContext = trace.getSpanContext(context3);\n    var spanId = this._idGenerator.generateSpanId();\n    var traceId;\n    var traceState;\n    var parentSpanId;\n    if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n    var spanKind = (_a3 = options.kind) !== null && _a3 !== void 0 ? _a3 : SpanKind.INTERNAL;\n    var links = ((_b2 = options.links) !== null && _b2 !== void 0 ? _b2 : []).map(function(link) {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    var attributes = sanitizeAttributes(options.attributes);\n    var samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);\n    var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;\n    var spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === SamplingDecision.NOT_RECORD) {\n      diag2.debug(\"Recording is off, propagating context in a non-recording span\");\n      return trace.wrapSpanContext(spanContext);\n    }\n    var span = new Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime);\n    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    span.setAttributes(initAttributes);\n    return span;\n  };\n  Tracer3.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : context2.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = trace.setSpan(parentContext, span);\n    return context2.with(contextWithSpanSet, fn, void 0, span);\n  };\n  Tracer3.prototype.getGeneralLimits = function() {\n    return this._generalLimits;\n  };\n  Tracer3.prototype.getSpanLimits = function() {\n    return this._spanLimits;\n  };\n  Tracer3.prototype.getActiveSpanProcessor = function() {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n  return Tracer3;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\nfunction defaultServiceName() {\n  return \"unknown_service:\" + process.argv0;\n}\n__name(defaultServiceName, \"defaultServiceName\");\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetector.js\nvar import_os2 = __webpack_require__(/*! os */ \"os\");\nvar __awaiter = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar HostDetector = function() {\n  function HostDetector2() {\n  }\n  __name(HostDetector2, \"HostDetector\");\n  HostDetector2.prototype.detect = function(_config) {\n    return __awaiter(this, void 0, void 0, function() {\n      var attributes;\n      var _a3;\n      return __generator(this, function(_b2) {\n        attributes = (_a3 = {}, _a3[SemanticResourceAttributes.HOST_NAME] = (0, import_os2.hostname)(), _a3[SemanticResourceAttributes.HOST_ARCH] = this._normalizeArch((0, import_os2.arch)()), _a3);\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  HostDetector2.prototype._normalizeArch = function(nodeArchString) {\n    switch (nodeArchString) {\n      case \"arm\":\n        return \"arm32\";\n      case \"ppc\":\n        return \"ppc32\";\n      case \"x64\":\n        return \"amd64\";\n      default:\n        return nodeArchString;\n    }\n  };\n  return HostDetector2;\n}();\nvar hostDetector = new HostDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetector.js\nvar import_os3 = __webpack_require__(/*! os */ \"os\");\nvar __awaiter2 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator2 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar OSDetector = function() {\n  function OSDetector2() {\n  }\n  __name(OSDetector2, \"OSDetector\");\n  OSDetector2.prototype.detect = function(_config) {\n    return __awaiter2(this, void 0, void 0, function() {\n      var attributes;\n      var _a3;\n      return __generator2(this, function(_b2) {\n        attributes = (_a3 = {}, _a3[SemanticResourceAttributes.OS_TYPE] = this._normalizeType((0, import_os3.platform)()), _a3[SemanticResourceAttributes.OS_VERSION] = (0, import_os3.release)(), _a3);\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  OSDetector2.prototype._normalizeType = function(nodePlatform) {\n    switch (nodePlatform) {\n      case \"sunos\":\n        return \"solaris\";\n      case \"win32\":\n        return \"windows\";\n      default:\n        return nodePlatform;\n    }\n  };\n  return OSDetector2;\n}();\nvar osDetector = new OSDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/Resource.js\nvar Resource = function() {\n  function Resource2(attributes) {\n    this.attributes = attributes;\n  }\n  __name(Resource2, \"Resource\");\n  Resource2.empty = function() {\n    return Resource2.EMPTY;\n  };\n  Resource2.default = function() {\n    var _a3;\n    return new Resource2((_a3 = {}, _a3[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a3[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a3[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a3[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a3));\n  };\n  Resource2.prototype.merge = function(other) {\n    if (!other || !Object.keys(other.attributes).length)\n      return this;\n    var mergedAttributes = Object.assign({}, this.attributes, other.attributes);\n    return new Resource2(mergedAttributes);\n  };\n  Resource2.EMPTY = new Resource2({});\n  return Resource2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetector.js\nvar __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter3 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator3 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar BrowserDetector = function() {\n  function BrowserDetector2() {\n  }\n  __name(BrowserDetector2, \"BrowserDetector\");\n  BrowserDetector2.prototype.detect = function(config2) {\n    return __awaiter3(this, void 0, void 0, function() {\n      var isBrowser, browserResource;\n      var _a3;\n      return __generator3(this, function(_b2) {\n        isBrowser = typeof navigator !== \"undefined\";\n        if (!isBrowser) {\n          return [2, Resource.empty()];\n        }\n        browserResource = (_a3 = {}, _a3[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"browser\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Web Browser\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a3);\n        return [2, this._getResourceAttributes(browserResource, config2)];\n      });\n    });\n  };\n  BrowserDetector2.prototype._getResourceAttributes = function(browserResource, _config) {\n    if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === \"\") {\n      diag2.debug(\"BrowserDetector failed: Unable to find required browser resources. \");\n      return Resource.empty();\n    } else {\n      return new Resource(__assign({}, browserResource));\n    }\n  };\n  return BrowserDetector2;\n}();\nvar browserDetector = new BrowserDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetector.js\nvar __awaiter4 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator4 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar __values4 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read5 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar EnvDetector = function() {\n  function EnvDetector2() {\n    this._MAX_LENGTH = 255;\n    this._COMMA_SEPARATOR = \",\";\n    this._LABEL_KEY_VALUE_SPLITTER = \"=\";\n    this._ERROR_MESSAGE_INVALID_CHARS = \"should be a ASCII string with a length greater than 0 and not exceed \" + this._MAX_LENGTH + \" characters.\";\n    this._ERROR_MESSAGE_INVALID_VALUE = \"should be a ASCII string with a length not exceed \" + this._MAX_LENGTH + \" characters.\";\n  }\n  __name(EnvDetector2, \"EnvDetector\");\n  EnvDetector2.prototype.detect = function(_config) {\n    return __awaiter4(this, void 0, void 0, function() {\n      var attributes, env2, rawAttributes, serviceName, parsedAttributes;\n      return __generator4(this, function(_a3) {\n        attributes = {};\n        env2 = getEnv();\n        rawAttributes = env2.OTEL_RESOURCE_ATTRIBUTES;\n        serviceName = env2.OTEL_SERVICE_NAME;\n        if (rawAttributes) {\n          try {\n            parsedAttributes = this._parseResourceAttributes(rawAttributes);\n            Object.assign(attributes, parsedAttributes);\n          } catch (e) {\n            diag2.debug(\"EnvDetector failed: \" + e.message);\n          }\n        }\n        if (serviceName) {\n          attributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;\n        }\n        return [2, new Resource(attributes)];\n      });\n    });\n  };\n  EnvDetector2.prototype._parseResourceAttributes = function(rawEnvAttributes) {\n    var e_1, _a3;\n    if (!rawEnvAttributes)\n      return {};\n    var attributes = {};\n    var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);\n    try {\n      for (var rawAttributes_1 = __values4(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {\n        var rawAttribute = rawAttributes_1_1.value;\n        var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);\n        if (keyValuePair.length !== 2) {\n          continue;\n        }\n        var _b2 = __read5(keyValuePair, 2), key = _b2[0], value = _b2[1];\n        key = key.trim();\n        value = value.trim().split('^\"|\"$').join(\"\");\n        if (!this._isValidAndNotEmpty(key)) {\n          throw new Error(\"Attribute key \" + this._ERROR_MESSAGE_INVALID_CHARS);\n        }\n        if (!this._isValid(value)) {\n          throw new Error(\"Attribute value \" + this._ERROR_MESSAGE_INVALID_VALUE);\n        }\n        attributes[key] = value;\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a3 = rawAttributes_1.return))\n          _a3.call(rawAttributes_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return attributes;\n  };\n  EnvDetector2.prototype._isValid = function(name) {\n    return name.length <= this._MAX_LENGTH && this._isPrintableString(name);\n  };\n  EnvDetector2.prototype._isPrintableString = function(str) {\n    for (var i = 0; i < str.length; i++) {\n      var ch = str.charAt(i);\n      if (ch <= \" \" || ch >= \"~\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  EnvDetector2.prototype._isValidAndNotEmpty = function(str) {\n    return str.length > 0 && this._isValid(str);\n  };\n  return EnvDetector2;\n}();\nvar envDetector = new EnvDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+resources@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/resources/build/esm/detectors/ProcessDetector.js\nvar __assign2 = function() {\n  __assign2 = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign2.apply(this, arguments);\n};\nvar __awaiter5 = function(thisArg, _arguments, P3, generator) {\n  function adopt(value) {\n    return value instanceof P3 ? value : new P3(function(resolve) {\n      resolve(value);\n    });\n  }\n  __name(adopt, \"adopt\");\n  return new (P3 || (P3 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(fulfilled, \"fulfilled\");\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    __name(rejected, \"rejected\");\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    __name(step, \"step\");\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator5 = function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  __name(verb, \"verb\");\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n  __name(step, \"step\");\n};\nvar ProcessDetector = function() {\n  function ProcessDetector2() {\n  }\n  __name(ProcessDetector2, \"ProcessDetector\");\n  ProcessDetector2.prototype.detect = function(config2) {\n    return __awaiter5(this, void 0, void 0, function() {\n      var processResource;\n      var _a3;\n      return __generator5(this, function(_b2) {\n        if (typeof process !== \"object\") {\n          return [2, Resource.empty()];\n        }\n        processResource = (_a3 = {}, _a3[SemanticResourceAttributes.PROCESS_PID] = process.pid, _a3[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title || \"\", _a3[SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1] || \"\", _a3[SemanticResourceAttributes.PROCESS_COMMAND_LINE] = process.argv.join(\" \") || \"\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node, _a3[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"nodejs\", _a3[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Node.js\", _a3);\n        return [2, this._getResourceAttributes(processResource, config2)];\n      });\n    });\n  };\n  ProcessDetector2.prototype._getResourceAttributes = function(processResource, _config) {\n    if (processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] === \"\" || processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] === \"\" || processResource[SemanticResourceAttributes.PROCESS_COMMAND] === \"\" || processResource[SemanticResourceAttributes.PROCESS_COMMAND_LINE] === \"\" || processResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === \"\") {\n      diag2.debug(\"ProcessDetector failed: Unable to find required process resources. \");\n      return Resource.empty();\n    } else {\n      return new Resource(__assign2({}, processResource));\n    }\n  };\n  return ProcessDetector2;\n}();\nvar processDetector = new ProcessDetector();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js\nvar __values5 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar MultiSpanProcessor = function() {\n  function MultiSpanProcessor2(_spanProcessors) {\n    this._spanProcessors = _spanProcessors;\n  }\n  __name(MultiSpanProcessor2, \"MultiSpanProcessor\");\n  MultiSpanProcessor2.prototype.forceFlush = function() {\n    var e_1, _a3;\n    var promises = [];\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.forceFlush());\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return new Promise(function(resolve) {\n      Promise.all(promises).then(function() {\n        resolve();\n      }).catch(function(error2) {\n        globalErrorHandler(error2 || new Error(\"MultiSpanProcessor: forceFlush failed\"));\n        resolve();\n      });\n    });\n  };\n  MultiSpanProcessor2.prototype.onStart = function(span, context3) {\n    var e_2, _a3;\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onStart(span, context3);\n      }\n    } catch (e_2_1) {\n      e_2 = { error: e_2_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_2)\n          throw e_2.error;\n      }\n    }\n  };\n  MultiSpanProcessor2.prototype.onEnd = function(span) {\n    var e_3, _a3;\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onEnd(span);\n      }\n    } catch (e_3_1) {\n      e_3 = { error: e_3_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_3)\n          throw e_3.error;\n      }\n    }\n  };\n  MultiSpanProcessor2.prototype.shutdown = function() {\n    var e_4, _a3;\n    var promises = [];\n    try {\n      for (var _b2 = __values5(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.shutdown());\n      }\n    } catch (e_4_1) {\n      e_4 = { error: e_4_1 };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a3 = _b2.return))\n          _a3.call(_b2);\n      } finally {\n        if (e_4)\n          throw e_4.error;\n      }\n    }\n    return new Promise(function(resolve, reject) {\n      Promise.all(promises).then(function() {\n        resolve();\n      }, reject);\n    });\n  };\n  return MultiSpanProcessor2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js\nvar NoopSpanProcessor = function() {\n  function NoopSpanProcessor2() {\n  }\n  __name(NoopSpanProcessor2, \"NoopSpanProcessor\");\n  NoopSpanProcessor2.prototype.onStart = function(_span, _context) {\n  };\n  NoopSpanProcessor2.prototype.onEnd = function(_span) {\n  };\n  NoopSpanProcessor2.prototype.shutdown = function() {\n    return Promise.resolve();\n  };\n  NoopSpanProcessor2.prototype.forceFlush = function() {\n    return Promise.resolve();\n  };\n  return NoopSpanProcessor2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js\nvar ForceFlushState;\n(function(ForceFlushState2) {\n  ForceFlushState2[ForceFlushState2[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState2[ForceFlushState2[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState2[ForceFlushState2[\"error\"] = 2] = \"error\";\n  ForceFlushState2[ForceFlushState2[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\nvar BasicTracerProvider = function() {\n  function BasicTracerProvider2(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    var _a3;\n    this._registeredSpanProcessors = [];\n    this._tracers = /* @__PURE__ */ new Map();\n    var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config2));\n    this.resource = (_a3 = mergedConfig.resource) !== null && _a3 !== void 0 ? _a3 : Resource.empty();\n    this.resource = Resource.default().merge(this.resource);\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource\n    });\n    var defaultExporter = this._buildExporterFromEnv();\n    if (defaultExporter !== void 0) {\n      var batchProcessor = new BatchSpanProcessor(defaultExporter);\n      this.activeSpanProcessor = batchProcessor;\n    } else {\n      this.activeSpanProcessor = new NoopSpanProcessor();\n    }\n  }\n  __name(BasicTracerProvider2, \"BasicTracerProvider\");\n  BasicTracerProvider2.prototype.getTracer = function(name, version, options) {\n    var key = name + \"@\" + (version || \"\") + \":\" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || \"\");\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));\n    }\n    return this._tracers.get(key);\n  };\n  BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {\n    if (this._registeredSpanProcessors.length === 0) {\n      this.activeSpanProcessor.shutdown().catch(function(err) {\n        return diag2.error(\"Error while trying to shutdown current span processor\", err);\n      });\n    }\n    this._registeredSpanProcessors.push(spanProcessor);\n    this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n  };\n  BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {\n    return this.activeSpanProcessor;\n  };\n  BasicTracerProvider2.prototype.register = function(config2) {\n    if (config2 === void 0) {\n      config2 = {};\n    }\n    trace.setGlobalTracerProvider(this);\n    if (config2.propagator === void 0) {\n      config2.propagator = this._buildPropagatorFromEnv();\n    }\n    if (config2.contextManager) {\n      context2.setGlobalContextManager(config2.contextManager);\n    }\n    if (config2.propagator) {\n      propagation.setGlobalPropagator(config2.propagator);\n    }\n  };\n  BasicTracerProvider2.prototype.forceFlush = function() {\n    var timeout = this._config.forceFlushTimeoutMillis;\n    var promises = this._registeredSpanProcessors.map(function(spanProcessor) {\n      return new Promise(function(resolve) {\n        var state;\n        var timeoutInterval = setTimeout(function() {\n          resolve(new Error(\"Span processor did not completed within timeout period of \" + timeout + \" ms\"));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(function() {\n          clearTimeout(timeoutInterval);\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(function(error2) {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error2);\n        });\n      });\n    });\n    return new Promise(function(resolve, reject) {\n      Promise.all(promises).then(function(results) {\n        var errors = results.filter(function(result) {\n          return result !== ForceFlushState.resolved;\n        });\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(function(error2) {\n        return reject([error2]);\n      });\n    });\n  };\n  BasicTracerProvider2.prototype.shutdown = function() {\n    return this.activeSpanProcessor.shutdown();\n  };\n  BasicTracerProvider2.prototype._getPropagator = function(name) {\n    var _a3;\n    return (_a3 = this.constructor._registeredPropagators.get(name)) === null || _a3 === void 0 ? void 0 : _a3();\n  };\n  BasicTracerProvider2.prototype._getSpanExporter = function(name) {\n    var _a3;\n    return (_a3 = this.constructor._registeredExporters.get(name)) === null || _a3 === void 0 ? void 0 : _a3();\n  };\n  BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {\n    var _this = this;\n    var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));\n    var propagators = uniquePropagatorNames.map(function(name) {\n      var propagator = _this._getPropagator(name);\n      if (!propagator) {\n        diag2.warn('Propagator \"' + name + '\" requested through environment variable is unavailable.');\n      }\n      return propagator;\n    });\n    var validPropagators = propagators.reduce(function(list, item) {\n      if (item) {\n        list.push(item);\n      }\n      return list;\n    }, []);\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators\n      });\n    }\n  };\n  BasicTracerProvider2.prototype._buildExporterFromEnv = function() {\n    var exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === \"none\")\n      return;\n    var exporter = this._getSpanExporter(exporterName);\n    if (!exporter) {\n      diag2.error('Exporter \"' + exporterName + '\" requested through environment variable is unavailable.');\n    }\n    return exporter;\n  };\n  BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([\n    [\"tracecontext\", function() {\n      return new W3CTraceContextPropagator();\n    }],\n    [\"baggage\", function() {\n      return new W3CBaggagePropagator();\n    }]\n  ]);\n  BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();\n  return BasicTracerProvider2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ConsoleSpanExporter.js\nvar __values6 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar ConsoleSpanExporter = function() {\n  function ConsoleSpanExporter2() {\n  }\n  __name(ConsoleSpanExporter2, \"ConsoleSpanExporter\");\n  ConsoleSpanExporter2.prototype.export = function(spans, resultCallback) {\n    return this._sendSpans(spans, resultCallback);\n  };\n  ConsoleSpanExporter2.prototype.shutdown = function() {\n    this._sendSpans([]);\n    return Promise.resolve();\n  };\n  ConsoleSpanExporter2.prototype._exportInfo = function(span) {\n    return {\n      traceId: span.spanContext().traceId,\n      parentId: span.parentSpanId,\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links\n    };\n  };\n  ConsoleSpanExporter2.prototype._sendSpans = function(spans, done) {\n    var e_1, _a3;\n    try {\n      for (var spans_1 = __values6(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {\n        var span = spans_1_1.value;\n        console.dir(this._exportInfo(span), { depth: 3 });\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (spans_1_1 && !spans_1_1.done && (_a3 = spans_1.return))\n          _a3.call(spans_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  };\n  return ConsoleSpanExporter2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/InMemorySpanExporter.js\nvar __read6 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray4 = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar InMemorySpanExporter = function() {\n  function InMemorySpanExporter2() {\n    this._finishedSpans = [];\n    this._stopped = false;\n  }\n  __name(InMemorySpanExporter2, \"InMemorySpanExporter\");\n  InMemorySpanExporter2.prototype.export = function(spans, resultCallback) {\n    var _a3;\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error(\"Exporter has been stopped\")\n      });\n    (_a3 = this._finishedSpans).push.apply(_a3, __spreadArray4([], __read6(spans), false));\n    setTimeout(function() {\n      return resultCallback({ code: ExportResultCode.SUCCESS });\n    }, 0);\n  };\n  InMemorySpanExporter2.prototype.shutdown = function() {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return Promise.resolve();\n  };\n  InMemorySpanExporter2.prototype.reset = function() {\n    this._finishedSpans = [];\n  };\n  InMemorySpanExporter2.prototype.getFinishedSpans = function() {\n    return this._finishedSpans;\n  };\n  return InMemorySpanExporter2;\n}();\n\n// ../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.6.0_@opentelemetry+api@1.1.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SimpleSpanProcessor.js\nvar SimpleSpanProcessor = function() {\n  function SimpleSpanProcessor2(_exporter) {\n    this._exporter = _exporter;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n  __name(SimpleSpanProcessor2, \"SimpleSpanProcessor\");\n  SimpleSpanProcessor2.prototype.forceFlush = function() {\n    return Promise.resolve();\n  };\n  SimpleSpanProcessor2.prototype.onStart = function(_span, _parentContext) {\n  };\n  SimpleSpanProcessor2.prototype.onEnd = function(span) {\n    var _this = this;\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    context2.with(suppressTracing(context2.active()), function() {\n      _this._exporter.export([span], function(result) {\n        var _a3;\n        if (result.code !== ExportResultCode.SUCCESS) {\n          globalErrorHandler((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error(\"SimpleSpanProcessor: span export failed (status \" + result + \")\"));\n        }\n      });\n    });\n  };\n  SimpleSpanProcessor2.prototype.shutdown = function() {\n    return this._shutdownOnce.call();\n  };\n  SimpleSpanProcessor2.prototype._shutdown = function() {\n    return this._exporter.shutdown();\n  };\n  return SimpleSpanProcessor2;\n}();\n\n// ../engine-core/src/tracing/createSpan.ts\nasync function createSpan(engineSpanEvent) {\n  await new Promise((res) => setTimeout(res, 0));\n  const tracer = trace.getTracer(\"prisma\");\n  engineSpanEvent.spans.forEach((engineSpan) => {\n    var _a3;\n    const spanContext = {\n      traceId: engineSpan.trace_id,\n      spanId: engineSpan.span_id,\n      traceFlags: TraceFlags.SAMPLED\n    };\n    const links = (_a3 = engineSpan.links) == null ? void 0 : _a3.map((link) => {\n      return {\n        context: {\n          traceId: link.trace_id,\n          spanId: link.span_id,\n          traceFlags: TraceFlags.SAMPLED\n        }\n      };\n    });\n    const span = new Span(\n      tracer,\n      ROOT_CONTEXT,\n      engineSpan.name,\n      spanContext,\n      SpanKind.INTERNAL,\n      engineSpan.parent_span_id,\n      links,\n      engineSpan.start_time\n    );\n    if (engineSpan.attributes) {\n      span.setAttributes(engineSpan.attributes);\n    }\n    span.end(engineSpan.end_time);\n  });\n}\n__name(createSpan, \"createSpan\");\n\n// ../engine-core/src/tracing/getTraceParent.ts\nfunction getTraceParent({\n  context: context3,\n  tracingConfig\n}) {\n  const span = trace.getSpanContext(context3 != null ? context3 : context2.active());\n  if ((tracingConfig == null ? void 0 : tracingConfig.enabled) && (span == null ? void 0 : span.traceFlags) === 1) {\n    return `00-${span.traceId}-${span.spanId}-01`;\n  } else {\n    return `00-00-00-00`;\n  }\n}\n__name(getTraceParent, \"getTraceParent\");\n\n// ../engine-core/src/tracing/getTracingConfig.ts\nfunction getTracingConfig(previewFeatures) {\n  const hasTracingPreviewFeatureFlagEnabled = previewFeatures.includes(\"tracing\");\n  return {\n    get enabled() {\n      return Boolean(globalThis.PRISMA_INSTRUMENTATION && hasTracingPreviewFeatureFlagEnabled);\n    },\n    get middleware() {\n      return Boolean(globalThis.PRISMA_INSTRUMENTATION && globalThis.PRISMA_INSTRUMENTATION.middleware);\n    }\n  };\n}\n__name(getTracingConfig, \"getTracingConfig\");\n\n// ../engine-core/src/tracing/runInChildSpan.ts\nasync function runInChildSpan(options, cb) {\n  var _a3;\n  if (options.enabled === false)\n    return cb();\n  const tracer = trace.getTracer(\"prisma\");\n  const context3 = (_a3 = options.context) != null ? _a3 : context2.active();\n  if (options.active === false) {\n    const span = tracer.startSpan(`prisma:client:${options.name}`, options, context3);\n    try {\n      return await cb(span, context3);\n    } finally {\n      span.end();\n    }\n  }\n  return tracer.startActiveSpan(`prisma:client:${options.name}`, options, context3, async (span) => {\n    try {\n      return await cb(span, context2.active());\n    } finally {\n      span.end();\n    }\n  });\n}\n__name(runInChildSpan, \"runInChildSpan\");\n\n// ../engine-core/src/binary/Connection.ts\nvar import_get_stream = __toESM(require_get_stream());\nvar undici = /* @__PURE__ */ __name(() => require_undici(), \"undici\");\nfunction assertHasPool(pool) {\n  if (pool === void 0) {\n    throw new Error(\"Connection has not been opened\");\n  }\n}\n__name(assertHasPool, \"assertHasPool\");\nvar Connection = class {\n  constructor() {\n  }\n  static async onHttpError(response, handler) {\n    const _response = await response;\n    if (_response.statusCode >= 400) {\n      return handler(_response);\n    }\n    return _response;\n  }\n  open(url, options) {\n    if (this._pool)\n      return;\n    this._pool = new (undici()).Pool(url, {\n      connections: 1e3,\n      keepAliveMaxTimeout: 6e5,\n      headersTimeout: 0,\n      bodyTimeout: 0,\n      ...options\n    });\n  }\n  async raw(method, endpoint, headers, body, parseResponse = true) {\n    assertHasPool(this._pool);\n    const response = await this._pool.request({\n      path: endpoint,\n      method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body\n    });\n    const bodyString = await (0, import_get_stream.default)(response.body);\n    return {\n      statusCode: response.statusCode,\n      headers: response.headers,\n      data: parseResponse ? JSON.parse(bodyString) : bodyString\n    };\n  }\n  post(endpoint, body, headers, parseResponse) {\n    return this.raw(\"POST\", endpoint, headers, body, parseResponse);\n  }\n  get(path7, headers) {\n    return this.raw(\"GET\", path7, headers);\n  }\n  close() {\n    if (this._pool) {\n      this._pool.close(() => {\n      });\n    }\n    this._pool = void 0;\n  }\n};\n__name(Connection, \"Connection\");\n\n// ../engine-core/src/binary/BinaryEngine.ts\nvar debug4 = src_default(\"prisma:engine\");\nvar exists2 = (0, import_util4.promisify)(import_fs4.default.exists);\nvar logger = /* @__PURE__ */ __name((...args) => {\n}, \"logger\");\nvar knownPlatforms = [...platforms, \"native\"];\nvar engines = [];\nvar socketPaths = [];\nvar MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;\nvar MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;\nvar BinaryEngine = class extends Engine {\n  constructor({\n    cwd,\n    datamodelPath,\n    prismaPath,\n    generator,\n    datasources,\n    showColors,\n    logLevel,\n    logQueries,\n    env: env2,\n    flags,\n    clientVersion: clientVersion2,\n    previewFeatures,\n    engineEndpoint,\n    enableDebugLogs,\n    allowTriggerPanic,\n    dirname: dirname2,\n    activeProvider,\n    tracingConfig\n  }) {\n    var _a3;\n    super();\n    this.startCount = 0;\n    this.previewFeatures = [];\n    this.stderrLogs = \"\";\n    this.handleRequestError = /* @__PURE__ */ __name(async (error2, graceful = false) => {\n      var _a3, _b2;\n      debug4({ error: error2 });\n      if (this.startPromise) {\n        await this.startPromise;\n      }\n      this.throwAsyncErrorIfExists();\n      if ((_a3 = this.currentRequestPromise) == null ? void 0 : _a3.isCanceled) {\n        this.throwAsyncErrorIfExists();\n      } else if (error2.code === \"ECONNRESET\" || error2.code === \"ECONNREFUSED\" || error2.code === \"UND_ERR_CLOSED\" || error2.code === \"UND_ERR_SOCKET\" || error2.code === \"UND_ERR_DESTROYED\" || error2.code === \"UND_ERR_ABORTED\" || error2.message.toLowerCase().includes(\"client is destroyed\") || error2.message.toLowerCase().includes(\"other side closed\") || error2.message.toLowerCase().includes(\"the client is closed\")) {\n        if (this.globalKillSignalReceived && !((_b2 = this.child) == null ? void 0 : _b2.connected)) {\n          throw new PrismaClientUnknownRequestError(\n            `The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited\nand your request can't be processed.\nYou probably have some open handle that prevents your process from exiting.\nIt could be an open http server or stream that didn't close yet.\nWe recommend using the \\`wtfnode\\` package to debug open handles.`,\n            this.clientVersion\n          );\n        }\n        this.throwAsyncErrorIfExists();\n        if (this.startCount > MAX_STARTS) {\n          for (let i = 0; i < 5; i++) {\n            await new Promise((r) => setTimeout(r, 50));\n            this.throwAsyncErrorIfExists(true);\n          }\n          throw new Error(`Query engine is trying to restart, but can't.\nPlease look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);\n        }\n      }\n      if (!graceful) {\n        this.throwAsyncErrorIfExists(true);\n        throw error2;\n      }\n      return false;\n    }, \"handleRequestError\");\n    this.dirname = dirname2;\n    this.env = env2;\n    this.cwd = this.resolveCwd(cwd);\n    this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;\n    this.allowTriggerPanic = allowTriggerPanic != null ? allowTriggerPanic : false;\n    this.datamodelPath = datamodelPath;\n    this.prismaPath = (_a3 = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a3 : prismaPath;\n    this.generator = generator;\n    this.datasources = datasources;\n    this.tracingConfig = tracingConfig;\n    this.logEmitter = new import_events.default();\n    this.logEmitter.on(\"error\", () => {\n    });\n    this.showColors = showColors != null ? showColors : false;\n    this.logLevel = logLevel;\n    this.logQueries = logQueries != null ? logQueries : false;\n    this.clientVersion = clientVersion2;\n    this.flags = flags != null ? flags : [];\n    this.previewFeatures = previewFeatures != null ? previewFeatures : [];\n    this.activeProvider = activeProvider;\n    this.connection = new Connection();\n    initHooks();\n    const removedFlags = [\n      \"middlewares\",\n      \"aggregateApi\",\n      \"distinct\",\n      \"aggregations\",\n      \"insensitiveFilters\",\n      \"atomicNumberOperations\",\n      \"transactionApi\",\n      \"transaction\",\n      \"connectOrCreate\",\n      \"uncheckedScalarInputs\",\n      \"nativeTypes\",\n      \"createMany\",\n      \"groupBy\",\n      \"referentialActions\",\n      \"microsoftSqlServer\"\n    ];\n    const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));\n    if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {\n      console.log(\n        `${import_chalk3.default.blueBright(\"info\")} The preview flags \\`${removedFlagsUsed.join(\n          \"`, `\"\n        )}\\` were removed, you can now safely remove them from your schema.prisma.`\n      );\n    }\n    this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));\n    this.engineEndpoint = engineEndpoint;\n    if (engineEndpoint) {\n      const url = new import_url.URL(engineEndpoint);\n      this.port = Number(url.port);\n    }\n    if (this.platform) {\n      if (!knownPlatforms.includes(this.platform) && !import_fs4.default.existsSync(this.platform)) {\n        throw new PrismaClientInitializationError(\n          `Unknown ${import_chalk3.default.red(\"PRISMA_QUERY_ENGINE_BINARY\")} ${import_chalk3.default.redBright.bold(\n            this.platform\n          )}. Possible binaryTargets: ${import_chalk3.default.greenBright(\n            knownPlatforms.join(\", \")\n          )} or a path to the query engine binary.\nYou may have to run ${import_chalk3.default.greenBright(\"prisma generate\")} for your changes to take effect.`,\n          this.clientVersion\n        );\n      }\n    } else {\n      void this.getPlatform();\n    }\n    if (this.enableDebugLogs) {\n      src_default.enable(\"*\");\n    }\n    engines.push(this);\n    this.checkForTooManyEngines();\n  }\n  setError(err) {\n    var _a3;\n    if (isRustError(err)) {\n      this.lastRustError = err;\n      this.logEmitter.emit(\n        \"error\",\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion,\n          error: err\n        })\n      );\n      if (err.is_panic) {\n        this.handlePanic();\n      }\n    } else if (isRustErrorLog(err)) {\n      this.lastErrorLog = err;\n      this.logEmitter.emit(\n        \"error\",\n        new PrismaClientRustError({\n          clientVersion: this.clientVersion,\n          log: err\n        })\n      );\n      if (((_a3 = err.fields) == null ? void 0 : _a3.message) === \"PANIC\") {\n        this.handlePanic();\n      }\n    } else {\n      this.logEmitter.emit(\"error\", err);\n    }\n  }\n  checkForTooManyEngines() {\n    if (engines.length >= 10) {\n      const runningEngines = engines.filter((e) => e.child);\n      if (runningEngines.length === 10) {\n        console.warn(\n          `${import_chalk3.default.yellow(\"warn(prisma-client)\")} There are already 10 instances of Prisma Client actively running.`\n        );\n      }\n    }\n  }\n  resolveCwd(cwd) {\n    if (cwd && import_fs4.default.existsSync(cwd) && import_fs4.default.lstatSync(cwd).isDirectory()) {\n      return cwd;\n    }\n    return process.cwd();\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      this.beforeExitListener = listener;\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async emitExit() {\n    if (this.beforeExitListener) {\n      try {\n        await this.beforeExitListener();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n  async getPlatform() {\n    if (this.platformPromise) {\n      return this.platformPromise;\n    }\n    this.platformPromise = getPlatform();\n    return this.platformPromise;\n  }\n  getQueryEnginePath(platform3, prefix = __dirname) {\n    let queryEnginePath = import_path2.default.join(prefix, `query-engine-${platform3}`);\n    if (platform3 === \"windows\") {\n      queryEnginePath = `${queryEnginePath}.exe`;\n    }\n    return queryEnginePath;\n  }\n  handlePanic() {\n    var _a3;\n    if (this.child) {\n      this.stopPromise = killProcessAndWait(this.child);\n    }\n    if ((_a3 = this.currentRequestPromise) == null ? void 0 : _a3.cancel) {\n      this.currentRequestPromise.cancel();\n    }\n  }\n  async resolvePrismaPath() {\n    var _a3, _b2, _c;\n    const searchedLocations = [];\n    let enginePath;\n    if (this.prismaPath) {\n      return { prismaPath: this.prismaPath, searchedLocations };\n    }\n    const platform = await this.getPlatform();\n    if (this.platform && this.platform !== platform) {\n      this.incorrectlyPinnedBinaryTarget = this.platform;\n    }\n    this.platform = this.platform || platform;\n    if (__filename.includes(\"BinaryEngine\")) {\n      enginePath = this.getQueryEnginePath(this.platform, getEnginesPath());\n      return { prismaPath: enginePath, searchedLocations };\n    }\n    const searchLocations = [\n      eval(`require('path').join(__dirname, '../../../.prisma/client')`),\n      (_c = (_b2 = (_a3 = this.generator) == null ? void 0 : _a3.output) == null ? void 0 : _b2.value) != null ? _c : eval(\"__dirname\"),\n      import_path2.default.join(eval(\"__dirname\"), \"..\"),\n      import_path2.default.dirname(this.datamodelPath),\n      this.cwd,\n      \"/tmp/prisma-engines\"\n    ];\n    if (this.dirname) {\n      searchLocations.push(this.dirname);\n    }\n    for (const location of searchLocations) {\n      searchedLocations.push(location);\n      debug4(`Search for Query Engine in ${location}`);\n      enginePath = this.getQueryEnginePath(this.platform, location);\n      if (import_fs4.default.existsSync(enginePath)) {\n        return { prismaPath: enginePath, searchedLocations };\n      }\n    }\n    enginePath = this.getQueryEnginePath(this.platform);\n    return { prismaPath: enginePath != null ? enginePath : \"\", searchedLocations };\n  }\n  async getPrismaPath() {\n    const { prismaPath, searchedLocations: searchedLocations2 } = await this.resolvePrismaPath();\n    const platform3 = await this.getPlatform();\n    if (!await exists2(prismaPath)) {\n      const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `\nYou incorrectly pinned it to ${import_chalk3.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}\n` : \"\";\n      let errorText = `Query engine binary for current platform \"${import_chalk3.default.bold(\n        platform3\n      )}\" could not be found.${pinnedStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${import_chalk3.default.underline(prismaPath)}\")\n\nSearched Locations:\n\n${searchedLocations2.map((f) => {\n        let msg = `  ${f}`;\n        if (process.env.DEBUG === \"node-engine-search-locations\" && import_fs4.default.existsSync(f)) {\n          const dir = import_fs4.default.readdirSync(f);\n          msg += dir.map((d) => `    ${d}`).join(\"\\n\");\n        }\n        return msg;\n      }).join(\"\\n\" + (process.env.DEBUG === \"node-engine-search-locations\" ? \"\\n\" : \"\"))}\n`;\n      if (this.generator) {\n        if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === \"native\")) {\n          errorText += `\nYou already added the platform${this.generator.binaryTargets.length > 1 ? \"s\" : \"\"} ${this.generator.binaryTargets.map((t) => `\"${import_chalk3.default.bold(t.value)}\"`).join(\", \")} to the \"${import_chalk3.default.underline(\"generator\")}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`;\n          errorText += ``;\n        } else {\n          errorText += `\n\nTo solve this problem, add the platform \"${this.platform}\" to the \"${import_chalk3.default.underline(\n            \"binaryTargets\"\n          )}\" attribute in the \"${import_chalk3.default.underline(\"generator\")}\" block in the \"schema.prisma\" file:\n${import_chalk3.default.greenBright(this.getFixedGenerator())}\n\nThen run \"${import_chalk3.default.greenBright(\"prisma generate\")}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`;\n        }\n      } else {\n        errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;\n      }\n      throw new PrismaClientInitializationError(errorText, this.clientVersion);\n    }\n    if (this.incorrectlyPinnedBinaryTarget) {\n      console.error(`${import_chalk3.default.yellow(\"Warning:\")} You pinned the platform ${import_chalk3.default.bold(\n        this.incorrectlyPinnedBinaryTarget\n      )}, but Prisma Client detects ${import_chalk3.default.bold(await this.getPlatform())}.\nThis means you should very likely pin the platform ${import_chalk3.default.greenBright(await this.getPlatform())} instead.\n${import_chalk3.default.dim(\"In case we're mistaken, please report this to us \\u{1F64F}.\")}`);\n    }\n    if (process.platform !== \"win32\") {\n      plusX(prismaPath);\n    }\n    return prismaPath;\n  }\n  getFixedGenerator() {\n    const fixedGenerator = {\n      ...this.generator,\n      binaryTargets: fixBinaryTargets(this.generator.binaryTargets, this.platform)\n    };\n    return printGeneratorConfig(fixedGenerator);\n  }\n  printDatasources() {\n    if (this.datasources) {\n      return JSON.stringify(this.datasources);\n    }\n    return \"[]\";\n  }\n  async start() {\n    if (this.stopPromise) {\n      await this.stopPromise;\n    }\n    const startFn = /* @__PURE__ */ __name(async () => {\n      if (!this.startPromise) {\n        this.startCount++;\n        this.startPromise = this.internalStart();\n      }\n      await this.startPromise;\n      if (!this.child && !this.engineEndpoint) {\n        throw new PrismaClientUnknownRequestError(\n          `Can't perform request, as the Engine has already been stopped`,\n          this.clientVersion\n        );\n      }\n    }, \"startFn\");\n    const spanOptions = {\n      name: \"connect\",\n      enabled: this.tracingConfig.enabled && !this.startPromise\n    };\n    return runInChildSpan(spanOptions, startFn);\n  }\n  getEngineEnvVars() {\n    var _a3, _b2;\n    const env2 = {\n      PRISMA_DML_PATH: this.datamodelPath\n    };\n    if (this.logQueries || this.logLevel === \"info\") {\n      if (this.logQueries) {\n        env2.LOG_QUERIES = \"true\";\n      }\n    }\n    if (this.datasources) {\n      env2.OVERWRITE_DATASOURCES = this.printDatasources();\n    }\n    if (!process.env.NO_COLOR && this.showColors) {\n      env2.CLICOLOR_FORCE = \"1\";\n    }\n    return {\n      ...this.env,\n      ...process.env,\n      ...env2,\n      RUST_BACKTRACE: (_a3 = process.env.RUST_BACKTRACE) != null ? _a3 : \"1\",\n      RUST_LOG: (_b2 = process.env.RUST_LOG) != null ? _b2 : \"info\"\n    };\n  }\n  internalStart() {\n    return new Promise(async (resolve, reject) => {\n      var _a3, _b2, _c;\n      await new Promise((r) => process.nextTick(r));\n      if (this.stopPromise) {\n        await this.stopPromise;\n      }\n      if (this.engineEndpoint) {\n        try {\n          this.connection.open(this.engineEndpoint);\n          await (0, import_p_retry.default)(() => this.connection.get(\"/status\"), {\n            retries: 10\n          });\n        } catch (e) {\n          return reject(e);\n        }\n        return resolve();\n      }\n      try {\n        if (((_a3 = this.child) == null ? void 0 : _a3.connected) || this.child && !((_b2 = this.child) == null ? void 0 : _b2.killed)) {\n          debug4(`There is a child that still runs and we want to start again`);\n        }\n        this.lastRustError = void 0;\n        this.lastErrorLog = void 0;\n        this.lastPanic = void 0;\n        logger(\"startin & resettin\");\n        this.globalKillSignalReceived = void 0;\n        debug4({ cwd: this.cwd });\n        const prismaPath = await this.getPrismaPath();\n        const additionalFlag = this.allowTriggerPanic ? [\"--debug\"] : [];\n        const flags = [\n          \"--enable-raw-queries\",\n          \"--enable-metrics\",\n          \"--enable-open-telemetry\",\n          ...this.flags,\n          ...additionalFlag\n        ];\n        this.port = await this.getFreePort();\n        flags.push(\"--port\", String(this.port));\n        debug4({ flags });\n        const env2 = this.getEngineEnvVars();\n        this.child = (0, import_child_process2.spawn)(prismaPath, flags, {\n          env: env2,\n          cwd: this.cwd,\n          windowsHide: true,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"]\n        });\n        byline(this.child.stderr).on(\"data\", (msg) => {\n          const data = String(msg);\n          debug4(\"stderr\", data);\n          try {\n            const json = JSON.parse(data);\n            if (typeof json.is_panic !== \"undefined\") {\n              debug4(json);\n              this.setError(json);\n              if (this.engineStartDeferred) {\n                const err = new PrismaClientInitializationError(json.message, this.clientVersion, json.error_code);\n                this.engineStartDeferred.reject(err);\n              }\n            }\n          } catch (e) {\n            if (!data.includes(\"Printing to stderr\") && !data.includes(\"Listening on \")) {\n              this.stderrLogs += \"\\n\" + data;\n            }\n          }\n        });\n        byline(this.child.stdout).on(\"data\", (msg) => {\n          var _a4, _b3;\n          const data = String(msg);\n          try {\n            const json = JSON.parse(data);\n            debug4(\"stdout\", getMessage(json));\n            if (this.engineStartDeferred && json.level === \"INFO\" && json.target === \"query_engine::server\" && ((_b3 = (_a4 = json.fields) == null ? void 0 : _a4.message) == null ? void 0 : _b3.startsWith(\"Started query engine http server\"))) {\n              this.connection.open(`http://127.0.0.1:${this.port}`);\n              this.engineStartDeferred.resolve();\n              this.engineStartDeferred = void 0;\n            }\n            if (typeof json.is_panic === \"undefined\") {\n              if (json.span === true) {\n                if (this.tracingConfig.enabled === true) {\n                  void createSpan(json);\n                }\n                return;\n              }\n              const log4 = convertLog(json);\n              const logIsRustErrorLog = isRustErrorLog(log4);\n              if (logIsRustErrorLog) {\n                this.setError(log4);\n              } else {\n                this.logEmitter.emit(log4.level, log4);\n              }\n            } else {\n              this.setError(json);\n            }\n          } catch (e) {\n            debug4(e, data);\n          }\n        });\n        this.child.on(\"exit\", (code) => {\n          var _a4;\n          logger(\"removing startPromise\");\n          this.startPromise = void 0;\n          if (this.engineStopDeferred) {\n            this.engineStopDeferred.resolve(code);\n            return;\n          }\n          this.connection.close();\n          if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {\n            let err;\n            let msg = this.stderrLogs;\n            if (this.lastRustError) {\n              msg = getMessage(this.lastRustError);\n            } else if (this.lastErrorLog) {\n              msg = getMessage(this.lastErrorLog);\n            }\n            if (code !== null) {\n              err = new PrismaClientInitializationError(\n                `Query engine exited with code ${code}\n` + msg,\n                this.clientVersion\n              );\n            } else if ((_a4 = this.child) == null ? void 0 : _a4.signalCode) {\n              err = new PrismaClientInitializationError(\n                `Query engine process killed with signal ${this.child.signalCode} for unknown reason.\nMake sure that the engine binary at ${prismaPath} is not corrupt.\n` + msg,\n                this.clientVersion\n              );\n            } else {\n              err = new PrismaClientInitializationError(msg, this.clientVersion);\n            }\n            this.engineStartDeferred.reject(err);\n          }\n          if (!this.child) {\n            return;\n          }\n          if (this.lastRustError) {\n            return;\n          }\n          if (code === 126) {\n            this.setError({\n              timestamp: new Date(),\n              target: \"exit\",\n              level: \"error\",\n              fields: {\n                message: `Couldn't start query engine as it's not executable on this operating system.\nYou very likely have the wrong \"binaryTarget\" defined in the schema.prisma file.`\n              }\n            });\n          }\n        });\n        this.child.on(\"error\", (err) => {\n          this.setError({\n            message: err.message,\n            backtrace: \"Could not start query engine\",\n            is_panic: false\n          });\n          reject(err);\n        });\n        this.child.on(\"close\", (code, signal) => {\n          var _a4;\n          this.connection.close();\n          if (code === null && signal === \"SIGABRT\" && this.child) {\n            const error2 = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\"Panic in Query Engine with SIGABRT signal\"),\n              this.clientVersion\n            );\n            this.logEmitter.emit(\"error\", error2);\n          } else if (code === 255 && signal === null && ((_a4 = this.lastErrorLog) == null ? void 0 : _a4.fields.message) === \"PANIC\" && !this.lastPanic) {\n            const error2 = new PrismaClientRustPanicError(\n              this.getErrorMessageWithLink(\n                `${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`\n              ),\n              this.clientVersion\n            );\n            this.setError(error2);\n          }\n        });\n        if (this.lastRustError) {\n          return reject(new PrismaClientInitializationError(getMessage(this.lastRustError), this.clientVersion));\n        }\n        if (this.lastErrorLog) {\n          return reject(new PrismaClientInitializationError(getMessage(this.lastErrorLog), this.clientVersion));\n        }\n        try {\n          await new Promise((resolve2, reject2) => {\n            this.engineStartDeferred = { resolve: resolve2, reject: reject2 };\n          });\n        } catch (err) {\n          (_c = this.child) == null ? void 0 : _c.kill();\n          throw err;\n        }\n        void (async () => {\n          try {\n            const engineVersion = await this.version(true);\n            debug4(`Client Version: ${this.clientVersion}`);\n            debug4(`Engine Version: ${engineVersion}`);\n            debug4(`Active provider: ${this.activeProvider}`);\n          } catch (e) {\n            debug4(e);\n          }\n        })();\n        this.stopPromise = void 0;\n        resolve();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  async stop() {\n    const stopFn = /* @__PURE__ */ __name(async () => {\n      if (!this.stopPromise) {\n        this.stopPromise = this._stop();\n      }\n      return this.stopPromise;\n    }, \"stopFn\");\n    const spanOptions = {\n      name: \"disconnect\",\n      enabled: this.tracingConfig.enabled\n    };\n    return runInChildSpan(spanOptions, stopFn);\n  }\n  async _stop() {\n    var _a3;\n    if (this.startPromise) {\n      await this.startPromise;\n    }\n    await new Promise((resolve) => process.nextTick(resolve));\n    if (this.currentRequestPromise) {\n      try {\n        await this.currentRequestPromise;\n      } catch (e) {\n      }\n    }\n    this.getConfigPromise = void 0;\n    let stopChildPromise;\n    if (this.child) {\n      debug4(`Stopping Prisma engine4`);\n      if (this.startPromise) {\n        debug4(`Waiting for start promise`);\n        await this.startPromise;\n      }\n      debug4(`Done waiting for start promise`);\n      stopChildPromise = new Promise((resolve, reject) => {\n        this.engineStopDeferred = { resolve, reject };\n      });\n      this.connection.close();\n      (_a3 = this.child) == null ? void 0 : _a3.kill();\n      this.child = void 0;\n    }\n    if (stopChildPromise) {\n      await stopChildPromise;\n    }\n    await new Promise((r) => process.nextTick(r));\n    this.startPromise = void 0;\n    this.engineStopDeferred = void 0;\n  }\n  kill(signal) {\n    var _a3;\n    this.getConfigPromise = void 0;\n    this.globalKillSignalReceived = signal;\n    (_a3 = this.child) == null ? void 0 : _a3.kill();\n    this.connection.close();\n  }\n  getFreePort() {\n    return new Promise((resolve, reject) => {\n      const server = import_net.default.createServer((s) => s.end(\"\"));\n      server.unref();\n      server.on(\"error\", reject);\n      server.listen(0, () => {\n        const address = server.address();\n        const port = typeof address === \"string\" ? parseInt(address.split(\":\").slice(-1)[0], 10) : address.port;\n        server.close((e) => {\n          if (e) {\n            reject(e);\n          }\n          resolve(port);\n        });\n      });\n    });\n  }\n  async getConfig() {\n    if (!this.getConfigPromise) {\n      this.getConfigPromise = this._getConfig();\n    }\n    return this.getConfigPromise;\n  }\n  async _getConfig() {\n    const prismaPath = await this.getPrismaPath();\n    const env2 = await this.getEngineEnvVars();\n    const result = await (0, import_execa.default)(prismaPath, [\"cli\", \"get-config\"], {\n      env: omit(env2, [\"PORT\"]),\n      cwd: this.cwd\n    });\n    return JSON.parse(result.stdout);\n  }\n  async getDmmf() {\n    if (!this.getDmmfPromise) {\n      this.getDmmfPromise = this._getDmmf();\n    }\n    return this.getDmmfPromise;\n  }\n  async _getDmmf() {\n    const prismaPath = await this.getPrismaPath();\n    const env2 = await this.getEngineEnvVars();\n    const result = await (0, import_execa.default)(prismaPath, [\"--enable-raw-queries\", \"cli\", \"dmmf\"], {\n      env: omit(env2, [\"PORT\"]),\n      cwd: this.cwd\n    });\n    return JSON.parse(result.stdout);\n  }\n  async version(forceRun = false) {\n    if (this.versionPromise && !forceRun) {\n      return this.versionPromise;\n    }\n    this.versionPromise = this.internalVersion();\n    return this.versionPromise;\n  }\n  async internalVersion() {\n    const prismaPath = await this.getPrismaPath();\n    const result = await (0, import_execa.default)(prismaPath, [\"--version\"]);\n    this.lastVersion = result.stdout;\n    return this.lastVersion;\n  }\n  async request(query2, headers = {}, numTry = 1) {\n    await this.start();\n    this.currentRequestPromise = this.connection.post(\"/\", stringifyQuery(query2), runtimeHeadersToHttpHeaders(headers));\n    this.lastQuery = query2;\n    try {\n      const { data, headers: headers2 } = await this.currentRequestPromise;\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n        }\n        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);\n      }\n      const elapsed = parseInt(headers2[\"x-elapsed\"]) / 1e3;\n      if (this.startCount > 0) {\n        this.startCount = 0;\n      }\n      this.currentRequestPromise = void 0;\n      return { data, elapsed };\n    } catch (e) {\n      logger(\"req - e\", e);\n      if (e instanceof PrismaClientKnownRequestError) {\n        throw e;\n      }\n      await this.handleRequestError(e, numTry <= MAX_REQUEST_RETRIES);\n      if (numTry <= MAX_REQUEST_RETRIES) {\n        logger(\"trying a retry now\");\n        return this.request(query2, headers, numTry + 1);\n      }\n    }\n    return null;\n  }\n  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {\n    await this.start();\n    const request2 = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction\n    };\n    this.lastQuery = JSON.stringify(request2);\n    this.currentRequestPromise = this.connection.post(\"/\", this.lastQuery, runtimeHeadersToHttpHeaders(headers));\n    return this.currentRequestPromise.then(({ data, headers: headers2 }) => {\n      const elapsed = parseInt(headers2[\"x-elapsed\"]) / 1e3;\n      const { batchResult, errors } = data;\n      if (Array.isArray(batchResult)) {\n        return batchResult.map((result) => {\n          if (result.errors) {\n            throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n          }\n          return {\n            data: result,\n            elapsed\n          };\n        });\n      } else {\n        throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);\n      }\n    }).catch(async (e) => {\n      const isError2 = await this.handleRequestError(e, numTry < 3);\n      if (!isError2) {\n        if (numTry <= MAX_REQUEST_RETRIES) {\n          return this.requestBatch(queries, headers, transaction, numTry + 1);\n        }\n      }\n      throw isError2;\n    });\n  }\n  async transaction(action, headers, arg2) {\n    var _a3, _b2;\n    await this.start();\n    if (action === \"start\") {\n      const jsonOptions = JSON.stringify({\n        max_wait: (_a3 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a3 : 2e3,\n        timeout: (_b2 = arg2 == null ? void 0 : arg2.timeout) != null ? _b2 : 5e3,\n        isolation_level: arg2 == null ? void 0 : arg2.isolationLevel\n      });\n      const result = await Connection.onHttpError(\n        this.connection.post(\"/transaction/start\", jsonOptions, runtimeHeadersToHttpHeaders(headers)),\n        transactionHttpErrorHandler\n      );\n      return result.data;\n    } else if (action === \"commit\") {\n      await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/commit`), transactionHttpErrorHandler);\n    } else if (action === \"rollback\") {\n      await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/rollback`), transactionHttpErrorHandler);\n    }\n    return void 0;\n  }\n  get hasMaxRestarts() {\n    return this.startCount >= MAX_STARTS;\n  }\n  throwAsyncErrorIfExists(forceThrow = false) {\n    var _a3, _b2;\n    logger(\"throwAsyncErrorIfExists\", this.startCount, this.hasMaxRestarts);\n    if (this.lastRustError) {\n      const err = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(getMessage(this.lastRustError)),\n        this.clientVersion\n      );\n      if (this.lastRustError.is_panic) {\n        this.lastPanic = err;\n      }\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err;\n      }\n    }\n    if (this.lastErrorLog && isRustErrorLog(this.lastErrorLog)) {\n      const err = new PrismaClientUnknownRequestError(\n        this.getErrorMessageWithLink(getMessage(this.lastErrorLog)),\n        this.clientVersion\n      );\n      if (((_b2 = (_a3 = this.lastErrorLog) == null ? void 0 : _a3.fields) == null ? void 0 : _b2.message) === \"PANIC\") {\n        this.lastPanic = err;\n      }\n      if (this.hasMaxRestarts || forceThrow) {\n        throw err;\n      }\n    }\n  }\n  getErrorMessageWithLink(title) {\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.clientVersion,\n      engineVersion: this.lastVersion,\n      database: this.lastActiveProvider,\n      query: this.lastQuery\n    });\n  }\n  async metrics({ format: format2, globalLabels }) {\n    await this.start();\n    const parseResponse = format2 === \"json\";\n    const response = await this.connection.post(\n      `/metrics?format=${encodeURIComponent(format2)}`,\n      JSON.stringify(globalLabels),\n      null,\n      parseResponse\n    );\n    return response.data;\n  }\n};\n__name(BinaryEngine, \"BinaryEngine\");\nfunction stringifyQuery(q) {\n  return `{\"variables\":{},\"query\":${JSON.stringify(q)}}`;\n}\n__name(stringifyQuery, \"stringifyQuery\");\nfunction hookProcess(handler, exit = false) {\n  process.once(handler, async () => {\n    for (const engine of engines) {\n      await engine.emitExit();\n      engine.kill(handler);\n    }\n    engines.splice(0, engines.length);\n    if (socketPaths.length > 0) {\n      for (const socketPath of socketPaths) {\n        try {\n          import_fs4.default.unlinkSync(socketPath);\n        } catch (e) {\n        }\n      }\n    }\n    if (exit && process.listenerCount(handler) === 0) {\n      process.exit();\n    }\n  });\n}\n__name(hookProcess, \"hookProcess\");\nvar hooksInitialized = false;\nfunction initHooks() {\n  if (!hooksInitialized) {\n    hookProcess(\"beforeExit\");\n    hookProcess(\"exit\");\n    hookProcess(\"SIGINT\", true);\n    hookProcess(\"SIGUSR2\", true);\n    hookProcess(\"SIGTERM\", true);\n    hooksInitialized = true;\n  }\n}\n__name(initHooks, \"initHooks\");\nfunction transactionHttpErrorHandler(result) {\n  throw result.data;\n}\n__name(transactionHttpErrorHandler, \"transactionHttpErrorHandler\");\nfunction runtimeHeadersToHttpHeaders(headers) {\n  return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {\n    let httpHeaderKey = runtimeHeaderKey;\n    if (runtimeHeaderKey === \"transactionId\") {\n      httpHeaderKey = \"X-transaction-id\";\n    }\n    acc[httpHeaderKey] = headers[runtimeHeaderKey];\n    return acc;\n  }, {});\n}\n__name(runtimeHeadersToHttpHeaders, \"runtimeHeadersToHttpHeaders\");\nfunction killProcessAndWait(childProcess) {\n  return new Promise((resolve) => {\n    childProcess.once(\"exit\", resolve);\n    childProcess.kill();\n  });\n}\n__name(killProcessAndWait, \"killProcessAndWait\");\n\n// ../engine-core/src/data-proxy/DataProxyEngine.ts\nvar import_events2 = __toESM(__webpack_require__(/*! events */ \"events\"));\n\n// ../engine-core/src/common/errors/PrismaClientError.ts\nvar PrismaClientError = class extends Error {\n  constructor(message, info2) {\n    super(message);\n    this.clientVersion = info2.clientVersion;\n    this.cause = info2.cause;\n  }\n  get [Symbol.toStringTag]() {\n    return this.name;\n  }\n};\n__name(PrismaClientError, \"PrismaClientError\");\n\n// ../engine-core/src/data-proxy/errors/DataProxyError.ts\nvar DataProxyError = class extends PrismaClientError {\n  constructor(message, info2) {\n    var _a3;\n    super(message, info2);\n    this.isRetryable = (_a3 = info2.isRetryable) != null ? _a3 : true;\n  }\n};\n__name(DataProxyError, \"DataProxyError\");\n\n// ../engine-core/src/data-proxy/errors/utils/setRetryable.ts\nfunction setRetryable(info2, retryable) {\n  return {\n    ...info2,\n    isRetryable: retryable\n  };\n}\n__name(setRetryable, \"setRetryable\");\n\n// ../engine-core/src/data-proxy/errors/ForcedRetryError.ts\nvar ForcedRetryError = class extends DataProxyError {\n  constructor(info2) {\n    super(\"This request must be retried\", setRetryable(info2, true));\n    this.name = \"ForcedRetryError\";\n    this.code = \"P5001\";\n  }\n};\n__name(ForcedRetryError, \"ForcedRetryError\");\n\n// ../engine-core/src/data-proxy/errors/InvalidDatasourceError.ts\nvar InvalidDatasourceError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(message, setRetryable(info2, false));\n    this.name = \"InvalidDatasourceError\";\n    this.code = \"P5002\";\n  }\n};\n__name(InvalidDatasourceError, \"InvalidDatasourceError\");\n\n// ../engine-core/src/data-proxy/errors/NotImplementedYetError.ts\nvar NotImplementedYetError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(message, setRetryable(info2, false));\n    this.name = \"NotImplementedYetError\";\n    this.code = \"P5004\";\n  }\n};\n__name(NotImplementedYetError, \"NotImplementedYetError\");\n\n// ../engine-core/src/data-proxy/errors/DataProxyAPIError.ts\nvar DataProxyAPIError = class extends DataProxyError {\n  constructor(message, info2) {\n    var _a3;\n    super(message, info2);\n    this.response = info2.response;\n    const requestId = (_a3 = this.response.headers) == null ? void 0 : _a3[\"Prisma-Request-Id\"];\n    if (requestId) {\n      const messageSuffix = `(The request id was: ${requestId})`;\n      this.message = this.message + \" \" + messageSuffix;\n    }\n  }\n};\n__name(DataProxyAPIError, \"DataProxyAPIError\");\n\n// ../engine-core/src/data-proxy/errors/SchemaMissingError.ts\nvar SchemaMissingError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Schema needs to be uploaded\", setRetryable(info2, true));\n    this.name = \"SchemaMissingError\";\n    this.code = \"P5005\";\n  }\n};\n__name(SchemaMissingError, \"SchemaMissingError\");\n\n// ../engine-core/src/data-proxy/errors/BadRequestError.ts\nvar BAD_REQUEST_DEFAULT_MESSAGE = \"This request could not be understood by the server\";\nvar BadRequestError = class extends DataProxyAPIError {\n  constructor(info2, message, code) {\n    super(message || BAD_REQUEST_DEFAULT_MESSAGE, setRetryable(info2, false));\n    this.name = \"BadRequestError\";\n    this.code = \"P5000\";\n    if (code)\n      this.code = code;\n  }\n};\n__name(BadRequestError, \"BadRequestError\");\n\n// ../engine-core/src/data-proxy/errors/GatewayTimeoutError.ts\nvar GatewayTimeoutError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Request timed out\", setRetryable(info2, false));\n    this.name = \"GatewayTimeoutError\";\n    this.code = \"P5009\";\n  }\n};\n__name(GatewayTimeoutError, \"GatewayTimeoutError\");\n\n// ../engine-core/src/data-proxy/errors/NotFoundError.ts\nvar NotFoundError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Requested resource does not exist\", setRetryable(info2, false));\n    this.name = \"NotFoundError\";\n    this.code = \"P5003\";\n  }\n};\n__name(NotFoundError, \"NotFoundError\");\n\n// ../engine-core/src/data-proxy/errors/ServerError.ts\nvar SERVER_ERROR_DEFAULT_MESSAGE = \"Unknown server error\";\nvar ServerError = class extends DataProxyAPIError {\n  constructor(info2, message, logs) {\n    super(message || SERVER_ERROR_DEFAULT_MESSAGE, setRetryable(info2, true));\n    this.name = \"ServerError\";\n    this.code = \"P5006\";\n    this.logs = logs;\n  }\n};\n__name(ServerError, \"ServerError\");\n\n// ../engine-core/src/data-proxy/errors/UnauthorizedError.ts\nvar UnauthorizedError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Unauthorized, check your connection string\", setRetryable(info2, false));\n    this.name = \"UnauthorizedError\";\n    this.code = \"P5007\";\n  }\n};\n__name(UnauthorizedError, \"UnauthorizedError\");\n\n// ../engine-core/src/data-proxy/errors/UsageExceededError.ts\nvar UsageExceededError = class extends DataProxyAPIError {\n  constructor(info2) {\n    super(\"Usage exceeded, retry again later\", setRetryable(info2, true));\n    this.name = \"UsageExceededError\";\n    this.code = \"P5008\";\n  }\n};\n__name(UsageExceededError, \"UsageExceededError\");\n\n// ../engine-core/src/data-proxy/errors/utils/responseToError.ts\nasync function responseToError(response, clientVersion2) {\n  var _a3, _b2, _c, _d, _e;\n  if (response.ok)\n    return void 0;\n  const info2 = { clientVersion: clientVersion2, response };\n  if (response.status === 400) {\n    let knownError;\n    try {\n      const body = await response.json();\n      knownError = (_b2 = (_a3 = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _a3.reason) == null ? void 0 : _b2.KnownEngineStartupError;\n    } catch (_) {\n    }\n    if (knownError) {\n      throw new BadRequestError(info2, knownError.msg, knownError.error_code);\n    }\n  }\n  if (response.status === 401) {\n    throw new UnauthorizedError(info2);\n  }\n  if (response.status === 404) {\n    try {\n      const body = await response.json();\n      const isSchemaMissing = ((_c = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _c.reason) === \"SchemaMissing\";\n      return isSchemaMissing ? new SchemaMissingError(info2) : new NotFoundError(info2);\n    } catch (err) {\n      return new NotFoundError(info2);\n    }\n  }\n  if (response.status === 429) {\n    throw new UsageExceededError(info2);\n  }\n  if (response.status === 504) {\n    throw new GatewayTimeoutError(info2);\n  }\n  if (response.status >= 500) {\n    let body;\n    try {\n      body = await response.json();\n    } catch (err) {\n      throw new ServerError(info2);\n    }\n    if (typeof ((_d = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _d.reason) === \"string\") {\n      throw new ServerError(info2, body.EngineNotStarted.reason);\n    } else if (typeof ((_e = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _e.reason) === \"object\") {\n      const keys2 = Object.keys(body.EngineNotStarted.reason);\n      if (keys2.length > 0) {\n        const reason = body.EngineNotStarted.reason;\n        const content = reason[keys2[0]];\n        throw new ServerError(info2, keys2[0], content.logs);\n      }\n    }\n    throw new ServerError(info2);\n  }\n  if (response.status >= 400) {\n    throw new BadRequestError(info2);\n  }\n  return void 0;\n}\n__name(responseToError, \"responseToError\");\n\n// ../engine-core/src/data-proxy/utils/backOff.ts\nvar BACKOFF_INTERVAL = 50;\nfunction backOff(n) {\n  const baseDelay = Math.pow(2, n) * BACKOFF_INTERVAL;\n  const jitter = Math.ceil(Math.random() * baseDelay) - Math.ceil(baseDelay / 2);\n  const total = baseDelay + jitter;\n  return new Promise((done) => setTimeout(() => done(total), total));\n}\n__name(backOff, \"backOff\");\n\n// ../engines/package.json\nvar devDependencies = {\n  \"@prisma/debug\": \"workspace:4.3.1\",\n  \"@prisma/engines-version\": \"4.3.0-32.c875e43600dfe042452e0b868f7a48b817b9640b\",\n  \"@prisma/fetch-engine\": \"workspace:4.3.1\",\n  \"@prisma/get-platform\": \"workspace:4.3.1\",\n  \"@swc/core\": \"1.2.242\",\n  \"@swc/jest\": \"0.2.22\",\n  \"@types/jest\": \"28.1.7\",\n  \"@types/node\": \"16.11.56\",\n  execa: \"5.1.1\",\n  jest: \"28.1.3\",\n  typescript: \"4.8.2\"\n};\n\n// ../engine-core/src/data-proxy/errors/NetworkError.ts\nvar RequestError = class extends DataProxyError {\n  constructor(message, info2) {\n    super(`Cannot fetch data from service:\n${message}`, setRetryable(info2, true));\n    this.name = \"RequestError\";\n    this.code = \"P5010\";\n  }\n};\n__name(RequestError, \"RequestError\");\n\n// ../engine-core/src/data-proxy/utils/getJSRuntimeName.ts\nfunction getJSRuntimeName() {\n  if (typeof self === \"undefined\") {\n    return \"node\";\n  }\n  return \"browser\";\n}\n__name(getJSRuntimeName, \"getJSRuntimeName\");\n\n// ../engine-core/src/data-proxy/utils/request.ts\nasync function request(url, options) {\n  var _a3;\n  const clientVersion2 = options.clientVersion;\n  const jsRuntimeName = getJSRuntimeName();\n  try {\n    if (jsRuntimeName === \"browser\") {\n      return await fetch(url, options);\n    } else {\n      return await nodeFetch(url, options);\n    }\n  } catch (e) {\n    const message = (_a3 = e.message) != null ? _a3 : \"Unknown error\";\n    throw new RequestError(message, { clientVersion: clientVersion2 });\n  }\n}\n__name(request, \"request\");\nfunction buildHeaders(options) {\n  return {\n    ...options.headers,\n    \"Content-Type\": \"application/json\"\n  };\n}\n__name(buildHeaders, \"buildHeaders\");\nfunction buildOptions(options) {\n  return {\n    method: options.method,\n    headers: buildHeaders(options)\n  };\n}\n__name(buildOptions, \"buildOptions\");\nfunction buildResponse(incomingData, response) {\n  return {\n    text: () => Buffer.concat(incomingData).toString(),\n    json: () => JSON.parse(Buffer.concat(incomingData).toString()),\n    ok: response.statusCode >= 200 && response.statusCode <= 299,\n    status: response.statusCode,\n    url: response.url,\n    headers: response.headers\n  };\n}\n__name(buildResponse, \"buildResponse\");\nasync function nodeFetch(url, options = {}) {\n  const https = include(\"https\");\n  const httpsOptions = buildOptions(options);\n  const incomingData = [];\n  const { origin } = new URL(url);\n  return new Promise((resolve, reject) => {\n    var _a3;\n    const request2 = https.request(url, httpsOptions, (response) => {\n      const { statusCode, headers: { location } } = response;\n      if (statusCode >= 301 && statusCode <= 399 && location) {\n        if (location.startsWith(\"http\") === false) {\n          resolve(nodeFetch(`${origin}${location}`, options));\n        } else {\n          resolve(nodeFetch(location, options));\n        }\n      }\n      response.on(\"data\", (chunk) => incomingData.push(chunk));\n      response.on(\"end\", () => resolve(buildResponse(incomingData, response)));\n      response.on(\"error\", reject);\n    });\n    request2.on(\"error\", reject);\n    request2.end((_a3 = options.body) != null ? _a3 : \"\");\n  });\n}\n__name(nodeFetch, \"nodeFetch\");\nvar include = undefined;\n\n// ../engine-core/src/data-proxy/utils/getClientVersion.ts\nvar semverRegex = /^[1-9][0-9]*\\.[0-9]+\\.[0-9]+$/;\nvar debug5 = src_default(\"prisma:client:dataproxyEngine\");\nasync function _getClientVersion(config2) {\n  var _a3, _b2, _c;\n  const engineVersion = devDependencies[\"@prisma/engines-version\"];\n  const clientVersion2 = (_a3 = config2.clientVersion) != null ? _a3 : \"unknown\";\n  if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) {\n    return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;\n  }\n  const [version, suffix] = (_b2 = clientVersion2 == null ? void 0 : clientVersion2.split(\"-\")) != null ? _b2 : [];\n  if (suffix === void 0 && semverRegex.test(version)) {\n    return version;\n  }\n  if (suffix !== void 0 || clientVersion2 === \"0.0.0\") {\n    const [version2] = (_c = engineVersion.split(\"-\")) != null ? _c : [];\n    const [major2, minor, patch] = version2.split(\".\");\n    const pkgURL = prismaPkgURL(`<=${major2}.${minor}.${patch}`);\n    const res = await request(pkgURL, { clientVersion: clientVersion2 });\n    const bodyAsText = await res.text();\n    debug5(\"length of body fetched from unpkg.com\", bodyAsText.length);\n    let bodyAsJson;\n    try {\n      bodyAsJson = JSON.parse(bodyAsText);\n    } catch (e) {\n      console.error(\"JSON.parse error: body fetched from unpkg.com: \", bodyAsText);\n      throw e;\n    }\n    return bodyAsJson[\"version\"];\n  }\n  throw new NotImplementedYetError(\"Only `major.minor.patch` versions are supported by Prisma Data Proxy.\", {\n    clientVersion: clientVersion2\n  });\n}\n__name(_getClientVersion, \"_getClientVersion\");\nasync function getClientVersion(config2) {\n  const version = await _getClientVersion(config2);\n  debug5(\"version\", version);\n  return version;\n}\n__name(getClientVersion, \"getClientVersion\");\nfunction prismaPkgURL(version) {\n  return encodeURI(`https://unpkg.com/prisma@${version}/package.json`);\n}\n__name(prismaPkgURL, \"prismaPkgURL\");\n\n// ../engine-core/src/data-proxy/DataProxyEngine.ts\nvar MAX_RETRIES = 10;\nvar P2 = Promise.resolve();\nvar debug6 = src_default(\"prisma:client:dataproxyEngine\");\nvar DataProxyEngine = class extends Engine {\n  constructor(config2) {\n    var _a3, _b2, _c, _d;\n    super();\n    this.config = config2;\n    this.env = { ...this.config.env, ...process.env };\n    this.inlineSchema = (_a3 = config2.inlineSchema) != null ? _a3 : \"\";\n    this.inlineDatasources = (_b2 = config2.inlineDatasources) != null ? _b2 : {};\n    this.inlineSchemaHash = (_c = config2.inlineSchemaHash) != null ? _c : \"\";\n    this.clientVersion = (_d = config2.clientVersion) != null ? _d : \"unknown\";\n    this.logEmitter = new import_events2.default();\n    this.logEmitter.on(\"error\", () => {\n    });\n    const [host, apiKey] = this.extractHostAndApiKey();\n    this.remoteClientVersion = P2.then(() => getClientVersion(this.config));\n    this.headers = { Authorization: `Bearer ${apiKey}` };\n    this.host = host;\n    debug6(\"host\", this.host);\n  }\n  version() {\n    return \"unknown\";\n  }\n  async start() {\n  }\n  async stop() {\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      throw new NotImplementedYetError(\"beforeExit event is not yet supported\", {\n        clientVersion: this.clientVersion\n      });\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async url(s) {\n    return `https://${this.host}/${await this.remoteClientVersion}/${this.inlineSchemaHash}/${s}`;\n  }\n  async getConfig() {\n    return Promise.resolve({\n      datasources: [\n        {\n          activeProvider: this.config.activeProvider\n        }\n      ]\n    });\n  }\n  getDmmf() {\n    throw new NotImplementedYetError(\"getDmmf is not yet supported\", {\n      clientVersion: this.clientVersion\n    });\n  }\n  async uploadSchema() {\n    const response = await request(await this.url(\"schema\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: this.inlineSchema,\n      clientVersion: this.clientVersion\n    });\n    if (!response.ok) {\n      debug6(\"schema response status\", response.status);\n    }\n    const err = await responseToError(response, this.clientVersion);\n    if (err) {\n      this.logEmitter.emit(\"warn\", { message: `Error while uploading schema: ${err.message}` });\n      throw err;\n    } else {\n      this.logEmitter.emit(\"info\", {\n        message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`\n      });\n    }\n  }\n  request(query2, headers, attempt = 0) {\n    this.logEmitter.emit(\"query\", { query: query2 });\n    return this.requestInternal({ query: query2, variables: {} }, headers, attempt);\n  }\n  async requestBatch(queries, headers, isTransaction = false, attempt = 0) {\n    this.logEmitter.emit(\"query\", {\n      query: `Batch${isTransaction ? \" in transaction\" : \"\"} (${queries.length}):\n${queries.join(\"\\n\")}`\n    });\n    const body = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction: isTransaction\n    };\n    const { batchResult } = await this.requestInternal(body, headers, attempt);\n    return batchResult;\n  }\n  async requestInternal(body, headers, attempt) {\n    var _a3;\n    try {\n      this.logEmitter.emit(\"info\", {\n        message: `Calling ${await this.url(\"graphql\")} (n=${attempt})`\n      });\n      const response = await request(await this.url(\"graphql\"), {\n        method: \"POST\",\n        headers: { ...headers, ...this.headers },\n        body: JSON.stringify(body),\n        clientVersion: this.clientVersion\n      });\n      if (!response.ok) {\n        debug6(\"graphql response status\", response.status);\n      }\n      const e = await responseToError(response, this.clientVersion);\n      if (e instanceof SchemaMissingError) {\n        await this.uploadSchema();\n        throw new ForcedRetryError({\n          clientVersion: this.clientVersion,\n          cause: e\n        });\n      }\n      if (e)\n        throw e;\n      const data = await response.json();\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);\n        }\n      }\n      return data;\n    } catch (e) {\n      this.logEmitter.emit(\"error\", {\n        message: `Error while querying: ${(_a3 = e.message) != null ? _a3 : \"(unknown)\"}`\n      });\n      if (!(e instanceof DataProxyError))\n        throw e;\n      if (!e.isRetryable)\n        throw e;\n      if (attempt >= MAX_RETRIES) {\n        if (e instanceof ForcedRetryError) {\n          throw e.cause;\n        } else {\n          throw e;\n        }\n      }\n      this.logEmitter.emit(\"warn\", { message: \"This request can be retried\" });\n      const delay = await backOff(attempt);\n      this.logEmitter.emit(\"warn\", { message: `Retrying after ${delay}ms` });\n      return this.requestInternal(body, headers, attempt + 1);\n    }\n  }\n  transaction() {\n    throw new NotImplementedYetError(\"Interactive transactions are not yet supported\", {\n      clientVersion: this.clientVersion\n    });\n  }\n  extractHostAndApiKey() {\n    const datasources = this.mergeOverriddenDatasources();\n    const mainDatasourceName = Object.keys(datasources)[0];\n    const mainDatasource = datasources[mainDatasourceName];\n    const dataProxyURL = this.resolveDatasourceURL(mainDatasourceName, mainDatasource);\n    let url;\n    try {\n      url = new URL(dataProxyURL);\n    } catch (e) {\n      throw new InvalidDatasourceError(\"Could not parse URL of the datasource\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    const { protocol, host, searchParams } = url;\n    if (protocol !== \"prisma:\") {\n      throw new InvalidDatasourceError(\"Datasource URL must use prisma:// protocol when --data-proxy is used\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    const apiKey = searchParams.get(\"api_key\");\n    if (apiKey === null || apiKey.length < 1) {\n      throw new InvalidDatasourceError(\"No valid API key found in the datasource URL\", {\n        clientVersion: this.clientVersion\n      });\n    }\n    return [host, apiKey];\n  }\n  mergeOverriddenDatasources() {\n    if (this.config.datasources === void 0) {\n      return this.inlineDatasources;\n    }\n    const finalDatasources = { ...this.inlineDatasources };\n    for (const override of this.config.datasources) {\n      if (!this.inlineDatasources[override.name]) {\n        throw new Error(`Unknown datasource: ${override.name}`);\n      }\n      finalDatasources[override.name] = {\n        url: {\n          fromEnvVar: null,\n          value: override.url\n        }\n      };\n    }\n    return finalDatasources;\n  }\n  resolveDatasourceURL(name, datasource) {\n    if (datasource.url.value) {\n      return datasource.url.value;\n    }\n    if (datasource.url.fromEnvVar) {\n      const envVar = datasource.url.fromEnvVar;\n      const loadedEnvURL = this.env[envVar];\n      if (loadedEnvURL === void 0) {\n        throw new InvalidDatasourceError(\n          `Datasource \"${name}\" references an environment variable \"${envVar}\" that is not set`,\n          {\n            clientVersion: this.clientVersion\n          }\n        );\n      }\n      return loadedEnvURL;\n    }\n    throw new InvalidDatasourceError(\n      `Datasource \"${name}\" specification is invalid: both value and fromEnvVar are null`,\n      {\n        clientVersion: this.clientVersion\n      }\n    );\n  }\n  metrics(options) {\n    throw new NotImplementedYetError(\"Metric are not yet supported for Data Proxy\", {\n      clientVersion: this.clientVersion\n    });\n  }\n};\n__name(DataProxyEngine, \"DataProxyEngine\");\n\n// ../engine-core/src/library/LibraryEngine.ts\nvar import_chalk5 = __toESM(require_source());\nvar import_events3 = __toESM(__webpack_require__(/*! events */ \"events\"));\nvar import_fs6 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\n\n// ../engine-core/src/library/DefaultLibraryLoader.ts\nvar import_chalk4 = __toESM(require_source());\nvar import_fs5 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path3 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar debug7 = src_default(\"prisma:client:libraryEngine:loader\");\nvar DefaultLibraryLoader = class {\n  constructor(config2) {\n    this.libQueryEnginePath = null;\n    this.platform = null;\n    this.config = config2;\n  }\n  async loadLibrary() {\n    if (!this.libQueryEnginePath) {\n      this.libQueryEnginePath = await this.getLibQueryEnginePath();\n    }\n    debug7(`loadEngine using ${this.libQueryEnginePath}`);\n    try {\n      return eval(\"require\")(this.libQueryEnginePath);\n    } catch (e) {\n      if (import_fs5.default.existsSync(this.libQueryEnginePath)) {\n        if (this.libQueryEnginePath.endsWith(\".node\")) {\n          throw new PrismaClientInitializationError(\n            `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, Library may be corrupt`,\n            this.config.clientVersion\n          );\n        } else {\n          throw new PrismaClientInitializationError(\n            `Expected an Node-API Library but received ${import_chalk4.default.dim(this.libQueryEnginePath)}`,\n            this.config.clientVersion\n          );\n        }\n      } else {\n        throw new PrismaClientInitializationError(\n          `Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, It does not exist`,\n          this.config.clientVersion\n        );\n      }\n    }\n  }\n  async getLibQueryEnginePath() {\n    var _a3, _b2, _c, _d;\n    const libPath = (_a3 = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a3 : this.config.prismaPath;\n    if (libPath && import_fs5.default.existsSync(libPath) && libPath.endsWith(\".node\")) {\n      return libPath;\n    }\n    this.platform = (_b2 = this.platform) != null ? _b2 : await getPlatform();\n    const { enginePath: enginePath2, searchedLocations: searchedLocations2 } = await this.resolveEnginePath();\n    if (!import_fs5.default.existsSync(enginePath2)) {\n      const incorrectPinnedPlatformErrorStr = this.platform ? `\nYou incorrectly pinned it to ${import_chalk4.default.redBright.bold(`${this.platform}`)}\n` : \"\";\n      let errorText = `Query engine library for current platform \"${import_chalk4.default.bold(\n        this.platform\n      )}\" could not be found.${incorrectPinnedPlatformErrorStr}\nThis probably happens, because you built Prisma Client on a different platform.\n(Prisma Client looked in \"${import_chalk4.default.underline(enginePath2)}\")\n\nSearched Locations:\n\n${searchedLocations2.map((f) => {\n        let msg = `  ${f}`;\n        if (process.env.DEBUG === \"node-engine-search-locations\" && import_fs5.default.existsSync(f)) {\n          const dir = import_fs5.default.readdirSync(f);\n          msg += dir.map((d) => `    ${d}`).join(\"\\n\");\n        }\n        return msg;\n      }).join(\"\\n\" + (process.env.DEBUG === \"node-engine-search-locations\" ? \"\\n\" : \"\"))}\n`;\n      if (this.config.generator) {\n        this.platform = (_c = this.platform) != null ? _c : await getPlatform();\n        if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === \"native\")) {\n          errorText += `\nYou already added the platform${this.config.generator.binaryTargets.length > 1 ? \"s\" : \"\"} ${this.config.generator.binaryTargets.map((t) => `\"${import_chalk4.default.bold(t.value)}\"`).join(\", \")} to the \"${import_chalk4.default.underline(\"generator\")}\" block\nin the \"schema.prisma\" file as described in https://pris.ly/d/client-generator,\nbut something went wrong. That's suboptimal.\n\nPlease create an issue at https://github.com/prisma/prisma/issues/new`;\n          errorText += ``;\n        } else {\n          errorText += `\n\nTo solve this problem, add the platform \"${this.platform}\" to the \"${import_chalk4.default.underline(\n            \"binaryTargets\"\n          )}\" attribute in the \"${import_chalk4.default.underline(\"generator\")}\" block in the \"schema.prisma\" file:\n${import_chalk4.default.greenBright(this.getFixedGenerator())}\n\nThen run \"${import_chalk4.default.greenBright(\"prisma generate\")}\" for your changes to take effect.\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator`;\n        }\n      } else {\n        errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;\n      }\n      throw new PrismaClientInitializationError(errorText, this.config.clientVersion);\n    }\n    this.platform = (_d = this.platform) != null ? _d : await getPlatform();\n    return enginePath2;\n  }\n  async resolveEnginePath() {\n    var _a3, _b2, _c, _d;\n    const searchedLocations = [];\n    let enginePath;\n    if (this.libQueryEnginePath) {\n      return { enginePath: this.libQueryEnginePath, searchedLocations };\n    }\n    this.platform = (_a3 = this.platform) != null ? _a3 : await getPlatform();\n    if (__filename.includes(\"DefaultLibraryLoader\")) {\n      enginePath = import_path3.default.join(getEnginesPath(), getNodeAPIName(this.platform, \"fs\"));\n      return { enginePath, searchedLocations };\n    }\n    const dirname = eval(\"__dirname\");\n    const searchLocations = [\n      import_path3.default.resolve(dirname, \"../../../.prisma/client\"),\n      (_d = (_c = (_b2 = this.config.generator) == null ? void 0 : _b2.output) == null ? void 0 : _c.value) != null ? _d : dirname,\n      import_path3.default.resolve(dirname, \"..\"),\n      import_path3.default.dirname(this.config.datamodelPath),\n      this.config.cwd,\n      \"/tmp/prisma-engines\"\n    ];\n    if (this.config.dirname) {\n      searchLocations.push(this.config.dirname);\n    }\n    for (const location of searchLocations) {\n      searchedLocations.push(location);\n      debug7(`Searching for Query Engine Library in ${location}`);\n      enginePath = import_path3.default.join(location, getNodeAPIName(this.platform, \"fs\"));\n      if (import_fs5.default.existsSync(enginePath)) {\n        return { enginePath, searchedLocations };\n      }\n    }\n    enginePath = import_path3.default.join(__dirname, getNodeAPIName(this.platform, \"fs\"));\n    return { enginePath: enginePath != null ? enginePath : \"\", searchedLocations };\n  }\n  getFixedGenerator() {\n    const fixedGenerator = {\n      ...this.config.generator,\n      binaryTargets: fixBinaryTargets(this.config.generator.binaryTargets, this.platform)\n    };\n    return printGeneratorConfig(fixedGenerator);\n  }\n};\n__name(DefaultLibraryLoader, \"DefaultLibraryLoader\");\n\n// ../engine-core/src/library/ExitHooks.ts\nvar debug8 = src_default(\"prisma:client:libraryEngine:exitHooks\");\nvar ExitHooks = class {\n  constructor() {\n    this.nextOwnerId = 1;\n    this.ownerToIdMap = /* @__PURE__ */ new WeakMap();\n    this.idToListenerMap = /* @__PURE__ */ new Map();\n    this.areHooksInstalled = false;\n  }\n  install() {\n    if (this.areHooksInstalled) {\n      return;\n    }\n    this.installHook(\"beforeExit\");\n    this.installHook(\"exit\");\n    this.installHook(\"SIGINT\", true);\n    this.installHook(\"SIGUSR2\", true);\n    this.installHook(\"SIGTERM\", true);\n    this.areHooksInstalled = true;\n  }\n  setListener(owner, listener) {\n    if (listener) {\n      let id = this.ownerToIdMap.get(owner);\n      if (!id) {\n        id = this.nextOwnerId++;\n        this.ownerToIdMap.set(owner, id);\n      }\n      this.idToListenerMap.set(id, listener);\n    } else {\n      const id = this.ownerToIdMap.get(owner);\n      if (id !== void 0) {\n        this.ownerToIdMap.delete(owner);\n        this.idToListenerMap.delete(id);\n      }\n    }\n  }\n  getListener(owner) {\n    const id = this.ownerToIdMap.get(owner);\n    if (id === void 0) {\n      return void 0;\n    }\n    return this.idToListenerMap.get(id);\n  }\n  installHook(event, shouldExit = false) {\n    process.once(event, async (code) => {\n      debug8(`exit event received: ${event}`);\n      for (const listener of this.idToListenerMap.values()) {\n        await listener();\n      }\n      this.idToListenerMap.clear();\n      if (shouldExit && process.listenerCount(event) === 0) {\n        process.exit(code);\n      }\n    });\n  }\n};\n__name(ExitHooks, \"ExitHooks\");\n\n// ../engine-core/src/library/LibraryEngine.ts\nvar debug9 = src_default(\"prisma:client:libraryEngine\");\nfunction isQueryEvent(event) {\n  return event[\"item_type\"] === \"query\" && \"query\" in event;\n}\n__name(isQueryEvent, \"isQueryEvent\");\nfunction isPanicEvent(event) {\n  if (\"level\" in event) {\n    return event.level === \"error\" && event[\"message\"] === \"PANIC\";\n  } else {\n    return false;\n  }\n}\n__name(isPanicEvent, \"isPanicEvent\");\nvar knownPlatforms2 = [...platforms, \"native\"];\nvar engineInstanceCount = 0;\nvar exitHooks = new ExitHooks();\nvar LibraryEngine = class extends Engine {\n  constructor(config2, loader = new DefaultLibraryLoader(config2)) {\n    var _a3, _b2;\n    super();\n    this.datamodel = import_fs6.default.readFileSync(config2.datamodelPath, \"utf-8\");\n    this.config = config2;\n    this.libraryStarted = false;\n    this.logQueries = (_a3 = config2.logQueries) != null ? _a3 : false;\n    this.logLevel = (_b2 = config2.logLevel) != null ? _b2 : \"error\";\n    this.libraryLoader = loader;\n    this.logEmitter = new import_events3.default();\n    this.logEmitter.on(\"error\", (e) => {\n    });\n    this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};\n    if (config2.enableDebugLogs) {\n      this.logLevel = \"debug\";\n    }\n    this.libraryInstantiationPromise = this.instantiateLibrary();\n    exitHooks.install();\n    this.checkForTooManyEngines();\n  }\n  get beforeExitListener() {\n    return exitHooks.getListener(this);\n  }\n  set beforeExitListener(listener) {\n    exitHooks.setListener(this, listener);\n  }\n  checkForTooManyEngines() {\n    if (engineInstanceCount === 10) {\n      console.warn(\n        `${import_chalk5.default.yellow(\"warn(prisma-client)\")} There are already 10 instances of Prisma Client actively running.`\n      );\n    }\n  }\n  async transaction(action, headers, arg2) {\n    var _a3, _b2, _c, _d, _e;\n    await this.start();\n    const headerStr = JSON.stringify(headers);\n    let result;\n    if (action === \"start\") {\n      const jsonOptions = JSON.stringify({\n        max_wait: (_a3 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a3 : 2e3,\n        timeout: (_b2 = arg2 == null ? void 0 : arg2.timeout) != null ? _b2 : 5e3,\n        isolation_level: arg2 == null ? void 0 : arg2.isolationLevel\n      });\n      result = await ((_c = this.engine) == null ? void 0 : _c.startTransaction(jsonOptions, headerStr));\n    } else if (action === \"commit\") {\n      result = await ((_d = this.engine) == null ? void 0 : _d.commitTransaction(arg2.id, headerStr));\n    } else if (action === \"rollback\") {\n      result = await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg2.id, headerStr));\n    }\n    const response = this.parseEngineResponse(result);\n    if (response.error_code)\n      throw response;\n    return response;\n  }\n  async instantiateLibrary() {\n    debug9(\"internalSetup\");\n    if (this.libraryInstantiationPromise) {\n      return this.libraryInstantiationPromise;\n    }\n    await isNodeAPISupported();\n    this.platform = await this.getPlatform();\n    await this.loadEngine();\n    this.version();\n  }\n  async getPlatform() {\n    if (this.platform)\n      return this.platform;\n    const platform3 = await getPlatform();\n    if (!knownPlatforms2.includes(platform3)) {\n      throw new PrismaClientInitializationError(\n        `Unknown ${import_chalk5.default.red(\"PRISMA_QUERY_ENGINE_LIBRARY\")} ${import_chalk5.default.redBright.bold(\n          platform3\n        )}. Possible binaryTargets: ${import_chalk5.default.greenBright(\n          knownPlatforms2.join(\", \")\n        )} or a path to the query engine library.\nYou may have to run ${import_chalk5.default.greenBright(\"prisma generate\")} for your changes to take effect.`,\n        this.config.clientVersion\n      );\n    }\n    return platform3;\n  }\n  parseEngineResponse(response) {\n    if (!response) {\n      throw new PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);\n    }\n    try {\n      const config2 = JSON.parse(response);\n      return config2;\n    } catch (err) {\n      throw new PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);\n    }\n  }\n  convertDatasources(datasources) {\n    const obj = /* @__PURE__ */ Object.create(null);\n    for (const { name, url } of datasources) {\n      obj[name] = url;\n    }\n    return obj;\n  }\n  async loadEngine() {\n    var _a3;\n    if (!this.engine) {\n      if (!this.QueryEngineConstructor) {\n        this.library = await this.libraryLoader.loadLibrary();\n        this.QueryEngineConstructor = this.library.QueryEngine;\n      }\n      try {\n        const weakThis = new WeakRef(this);\n        this.engine = new this.QueryEngineConstructor(\n          {\n            datamodel: this.datamodel,\n            env: process.env,\n            logQueries: (_a3 = this.config.logQueries) != null ? _a3 : false,\n            ignoreEnvVarErrors: false,\n            datasourceOverrides: this.datasourceOverrides,\n            logLevel: this.logLevel,\n            configDir: this.config.cwd\n          },\n          (log4) => {\n            var _a4;\n            (_a4 = weakThis.deref()) == null ? void 0 : _a4.logger(log4);\n          }\n        );\n        engineInstanceCount++;\n      } catch (_e) {\n        const e = _e;\n        const error2 = this.parseInitError(e.message);\n        if (typeof error2 === \"string\") {\n          throw e;\n        } else {\n          throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);\n        }\n      }\n    }\n  }\n  logger(log4) {\n    var _a3;\n    const event = this.parseEngineResponse(log4);\n    if (!event)\n      return;\n    if (\"span\" in event) {\n      if (this.config.tracingConfig.enabled === true) {\n        void createSpan(event);\n      }\n      return;\n    }\n    event.level = (_a3 = event == null ? void 0 : event.level.toLowerCase()) != null ? _a3 : \"unknown\";\n    if (isQueryEvent(event)) {\n      this.logEmitter.emit(\"query\", {\n        timestamp: new Date(),\n        query: event.query,\n        params: event.params,\n        duration: Number(event.duration_ms),\n        target: event.module_path\n      });\n    } else if (isPanicEvent(event)) {\n      this.loggerRustPanic = new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(\n          `${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`\n        ),\n        this.config.clientVersion\n      );\n      this.logEmitter.emit(\"error\", this.loggerRustPanic);\n    } else {\n      this.logEmitter.emit(event.level, {\n        timestamp: new Date(),\n        message: event.message,\n        target: event.module_path\n      });\n    }\n  }\n  getErrorMessageWithLink(title) {\n    var _a3;\n    return getErrorMessageWithLink({\n      platform: this.platform,\n      title,\n      version: this.config.clientVersion,\n      engineVersion: (_a3 = this.versionInfo) == null ? void 0 : _a3.commit,\n      database: this.config.activeProvider,\n      query: this.lastQuery\n    });\n  }\n  parseInitError(str) {\n    try {\n      const error2 = JSON.parse(str);\n      return error2;\n    } catch (e) {\n    }\n    return str;\n  }\n  parseRequestError(str) {\n    try {\n      const error2 = JSON.parse(str);\n      return error2;\n    } catch (e) {\n    }\n    return str;\n  }\n  on(event, listener) {\n    if (event === \"beforeExit\") {\n      this.beforeExitListener = listener;\n    } else {\n      this.logEmitter.on(event, listener);\n    }\n  }\n  async start() {\n    await this.libraryInstantiationPromise;\n    await this.libraryStoppingPromise;\n    if (this.libraryStartingPromise) {\n      debug9(`library already starting, this.libraryStarted: ${this.libraryStarted}`);\n      return this.libraryStartingPromise;\n    }\n    if (this.libraryStarted) {\n      return;\n    }\n    const startFn = /* @__PURE__ */ __name(async () => {\n      var _a3;\n      debug9(\"library starting\");\n      try {\n        const headers = {\n          traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })\n        };\n        await ((_a3 = this.engine) == null ? void 0 : _a3.connect(JSON.stringify(headers)));\n        this.libraryStarted = true;\n        debug9(\"library started\");\n      } catch (err) {\n        const error2 = this.parseInitError(err.message);\n        if (typeof error2 === \"string\") {\n          throw err;\n        } else {\n          throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);\n        }\n      } finally {\n        this.libraryStartingPromise = void 0;\n      }\n    }, \"startFn\");\n    const spanConfig = {\n      name: \"connect\",\n      enabled: this.config.tracingConfig.enabled\n    };\n    this.libraryStartingPromise = runInChildSpan(spanConfig, startFn);\n    return this.libraryStartingPromise;\n  }\n  async stop() {\n    await this.libraryStartingPromise;\n    await this.executingQueryPromise;\n    if (this.libraryStoppingPromise) {\n      debug9(\"library is already stopping\");\n      return this.libraryStoppingPromise;\n    }\n    if (!this.libraryStarted) {\n      return;\n    }\n    const stopFn = /* @__PURE__ */ __name(async () => {\n      var _a3;\n      await new Promise((r) => setTimeout(r, 5));\n      debug9(\"library stopping\");\n      const headers = {\n        traceparent: getTraceParent({ tracingConfig: this.config.tracingConfig })\n      };\n      await ((_a3 = this.engine) == null ? void 0 : _a3.disconnect(JSON.stringify(headers)));\n      this.libraryStarted = false;\n      this.libraryStoppingPromise = void 0;\n      debug9(\"library stopped\");\n    }, \"stopFn\");\n    const spanConfig = {\n      name: \"disconnect\",\n      enabled: this.config.tracingConfig.enabled\n    };\n    this.libraryStoppingPromise = runInChildSpan(spanConfig, stopFn);\n    return this.libraryStoppingPromise;\n  }\n  async getConfig() {\n    await this.libraryInstantiationPromise;\n    return this.library.getConfig({\n      datamodel: this.datamodel,\n      datasourceOverrides: this.datasourceOverrides,\n      ignoreEnvVarErrors: true,\n      env: process.env\n    });\n  }\n  async getDmmf() {\n    await this.libraryInstantiationPromise;\n    return JSON.parse(await this.library.dmmf(this.datamodel));\n  }\n  version() {\n    var _a3, _b2, _c;\n    this.versionInfo = (_a3 = this.library) == null ? void 0 : _a3.version();\n    return (_c = (_b2 = this.versionInfo) == null ? void 0 : _b2.version) != null ? _c : \"unknown\";\n  }\n  debugPanic(message) {\n    var _a3;\n    return (_a3 = this.library) == null ? void 0 : _a3.debugPanic(message);\n  }\n  async request(query2, headers = {}, numTry = 1) {\n    var _a3, _b2;\n    debug9(`sending request, this.libraryStarted: ${this.libraryStarted}`);\n    const request2 = { query: query2, variables: {} };\n    const headerStr = JSON.stringify(headers);\n    const queryStr = JSON.stringify(request2);\n    try {\n      await this.start();\n      this.executingQueryPromise = (_a3 = this.engine) == null ? void 0 : _a3.query(queryStr, headerStr, headers.transactionId);\n      this.lastQuery = queryStr;\n      const data = this.parseEngineResponse(await this.executingQueryPromise);\n      if (data.errors) {\n        if (data.errors.length === 1) {\n          throw this.buildQueryError(data.errors[0]);\n        }\n        throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);\n      } else if (this.loggerRustPanic) {\n        throw this.loggerRustPanic;\n      }\n      return { data, elapsed: 0 };\n    } catch (e) {\n      if (e instanceof PrismaClientInitializationError) {\n        throw e;\n      }\n      if (e.code === \"GenericFailure\" && ((_b2 = e.message) == null ? void 0 : _b2.startsWith(\"PANIC:\"))) {\n        throw new PrismaClientRustPanicError(this.getErrorMessageWithLink(e.message), this.config.clientVersion);\n      }\n      const error2 = this.parseRequestError(e.message);\n      if (typeof error2 === \"string\") {\n        throw e;\n      } else {\n        throw new PrismaClientUnknownRequestError(`${error2.message}\n${error2.backtrace}`, this.config.clientVersion);\n      }\n    }\n  }\n  async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {\n    debug9(\"requestBatch\");\n    const request2 = {\n      batch: queries.map((query2) => ({ query: query2, variables: {} })),\n      transaction\n    };\n    await this.start();\n    this.lastQuery = JSON.stringify(request2);\n    this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);\n    const result = await this.executingQueryPromise;\n    const data = this.parseEngineResponse(result);\n    if (data.errors) {\n      if (data.errors.length === 1) {\n        throw this.buildQueryError(data.errors[0]);\n      }\n      throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);\n    }\n    const { batchResult, errors } = data;\n    if (Array.isArray(batchResult)) {\n      return batchResult.map((result2) => {\n        var _a3;\n        if (result2.errors) {\n          return (_a3 = this.loggerRustPanic) != null ? _a3 : this.buildQueryError(data.errors[0]);\n        }\n        return {\n          data: result2,\n          elapsed: 0\n        };\n      });\n    } else {\n      if (errors && errors.length === 1) {\n        throw new Error(errors[0].error);\n      }\n      throw new Error(JSON.stringify(data));\n    }\n  }\n  buildQueryError(error2) {\n    if (error2.user_facing_error.is_panic) {\n      return new PrismaClientRustPanicError(\n        this.getErrorMessageWithLink(error2.user_facing_error.message),\n        this.config.clientVersion\n      );\n    }\n    return prismaGraphQLToJSError(error2, this.config.clientVersion);\n  }\n  async metrics(options) {\n    await this.start();\n    const responseString = await this.engine.metrics(JSON.stringify(options));\n    if (options.format === \"prometheus\") {\n      return responseString;\n    }\n    return this.parseEngineResponse(responseString);\n  }\n};\n__name(LibraryEngine, \"LibraryEngine\");\n\n// ../internals/src/utils/tryLoadEnvs.ts\nvar import_chalk6 = __toESM(require_source());\nvar import_dotenv = __toESM(require_main2());\nvar import_fs7 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path4 = __toESM(__webpack_require__(/*! path */ \"path\"));\n\n// ../internals/src/dotenvExpand.ts\nfunction dotenvExpand(config2) {\n  const environment = config2.ignoreProcessEnv ? {} : process.env;\n  const interpolate = /* @__PURE__ */ __name((envValue) => {\n    const matches = envValue.match(/(.?\\${(?:[a-zA-Z0-9_]+)?})/g) || [];\n    return matches.reduce(function(newEnv, match) {\n      const parts = /(.?)\\${([a-zA-Z0-9_]+)?}/g.exec(match);\n      if (!parts) {\n        return newEnv;\n      }\n      const prefix = parts[1];\n      let value, replacePart;\n      if (prefix === \"\\\\\") {\n        replacePart = parts[0];\n        value = replacePart.replace(\"\\\\$\", \"$\");\n      } else {\n        const key = parts[2];\n        replacePart = parts[0].substring(prefix.length);\n        value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || \"\";\n        value = interpolate(value);\n      }\n      return newEnv.replace(replacePart, value);\n    }, envValue);\n  }, \"interpolate\");\n  for (const configKey in config2.parsed) {\n    const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];\n    config2.parsed[configKey] = interpolate(value);\n  }\n  for (const processKey in config2.parsed) {\n    environment[processKey] = config2.parsed[processKey];\n  }\n  return config2;\n}\n__name(dotenvExpand, \"dotenvExpand\");\n\n// ../internals/src/utils/tryLoadEnvs.ts\nvar debug10 = src_default(\"prisma:tryLoadEnv\");\nfunction tryLoadEnvs({\n  rootEnvPath,\n  schemaEnvPath\n}, opts = {\n  conflictCheck: \"none\"\n}) {\n  var _a3, _b2;\n  const rootEnvInfo = loadEnv(rootEnvPath);\n  if (opts.conflictCheck !== \"none\") {\n    checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);\n  }\n  let schemaEnvInfo = null;\n  if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {\n    schemaEnvInfo = loadEnv(schemaEnvPath);\n  }\n  if (!rootEnvInfo && !schemaEnvInfo) {\n    debug10(\"No Environment variables loaded\");\n  }\n  if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {\n    return console.error(import_chalk6.default.redBright.bold(\"Schema Env Error: \") + schemaEnvInfo.dotenvResult.error);\n  }\n  const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);\n  return {\n    message: messages.join(\"\\n\"),\n    parsed: {\n      ...(_a3 = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a3.parsed,\n      ...(_b2 = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b2.parsed\n    }\n  };\n}\n__name(tryLoadEnvs, \"tryLoadEnvs\");\nfunction checkForConflicts(rootEnvInfo, envPath, type) {\n  const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;\n  const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);\n  if (parsedRootEnv && envPath && areNotTheSame && import_fs7.default.existsSync(envPath)) {\n    const envConfig = import_dotenv.default.parse(import_fs7.default.readFileSync(envPath));\n    const conflicts = [];\n    for (const k in envConfig) {\n      if (parsedRootEnv[k] === envConfig[k]) {\n        conflicts.push(k);\n      }\n    }\n    if (conflicts.length > 0) {\n      const relativeRootEnvPath = import_path4.default.relative(process.cwd(), rootEnvInfo.path);\n      const relativeEnvPath = import_path4.default.relative(process.cwd(), envPath);\n      if (type === \"error\") {\n        const message = `There is a conflict between env var${conflicts.length > 1 ? \"s\" : \"\"} in ${import_chalk6.default.underline(\n          relativeRootEnvPath\n        )} and ${import_chalk6.default.underline(relativeEnvPath)}\nConflicting env vars:\n${conflicts.map((conflict) => `  ${import_chalk6.default.bold(conflict)}`).join(\"\\n\")}\n\nWe suggest to move the contents of ${import_chalk6.default.underline(relativeEnvPath)} to ${import_chalk6.default.underline(\n          relativeRootEnvPath\n        )} to consolidate your env vars.\n`;\n        throw new Error(message);\n      } else if (type === \"warn\") {\n        const message = `Conflict for env var${conflicts.length > 1 ? \"s\" : \"\"} ${conflicts.map((c) => import_chalk6.default.bold(c)).join(\", \")} in ${import_chalk6.default.underline(relativeRootEnvPath)} and ${import_chalk6.default.underline(relativeEnvPath)}\nEnv vars from ${import_chalk6.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk6.default.underline(relativeRootEnvPath)}\n      `;\n        console.warn(`${import_chalk6.default.yellow(\"warn(prisma)\")} ${message}`);\n      }\n    }\n  }\n}\n__name(checkForConflicts, \"checkForConflicts\");\nfunction loadEnv(envPath) {\n  if (exists3(envPath)) {\n    debug10(`Environment variables loaded from ${envPath}`);\n    return {\n      dotenvResult: dotenvExpand(\n        import_dotenv.default.config({\n          path: envPath,\n          debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0\n        })\n      ),\n      message: import_chalk6.default.dim(`Environment variables loaded from ${import_path4.default.relative(process.cwd(), envPath)}`),\n      path: envPath\n    };\n  } else {\n    debug10(`Environment variables not found at ${envPath}`);\n  }\n  return null;\n}\n__name(loadEnv, \"loadEnv\");\nfunction pathsEqual(path1, path22) {\n  return path1 && path22 && import_path4.default.resolve(path1) === import_path4.default.resolve(path22);\n}\n__name(pathsEqual, \"pathsEqual\");\nfunction exists3(p) {\n  return Boolean(p && import_fs7.default.existsSync(p));\n}\n__name(exists3, \"exists\");\n\n// ../internals/src/client/getClientEngineType.ts\nvar DEFAULT_CLIENT_ENGINE_TYPE = \"library\" /* Library */;\nfunction getClientEngineType(generatorConfig) {\n  const engineTypeFromEnvVar = getEngineTypeFromEnvVar();\n  if (engineTypeFromEnvVar)\n    return engineTypeFromEnvVar;\n  if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === \"library\" /* Library */) {\n    return \"library\" /* Library */;\n  } else if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === \"binary\" /* Binary */) {\n    return \"binary\" /* Binary */;\n  } else {\n    return DEFAULT_CLIENT_ENGINE_TYPE;\n  }\n}\n__name(getClientEngineType, \"getClientEngineType\");\nfunction getEngineTypeFromEnvVar() {\n  const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;\n  if (engineType === \"library\" /* Library */) {\n    return \"library\" /* Library */;\n  } else if (engineType === \"binary\" /* Binary */) {\n    return \"binary\" /* Binary */;\n  } else {\n    return void 0;\n  }\n}\n__name(getEngineTypeFromEnvVar, \"getEngineTypeFromEnvVar\");\n\n// ../internals/src/cli/utils.ts\nvar import_arg = __toESM(require_arg());\nvar import_strip_indent = __toESM(require_strip_indent());\nfunction isError(result) {\n  return result instanceof Error;\n}\n__name(isError, \"isError\");\n\n// ../internals/src/logger.ts\nvar logger_exports = {};\n__export(logger_exports, {\n  error: () => error,\n  info: () => info,\n  log: () => log3,\n  query: () => query,\n  should: () => should,\n  tags: () => tags,\n  warn: () => warn\n});\nvar import_chalk7 = __toESM(require_source());\nvar tags = {\n  error: import_chalk7.default.red(\"prisma:error\"),\n  warn: import_chalk7.default.yellow(\"prisma:warn\"),\n  info: import_chalk7.default.cyan(\"prisma:info\"),\n  query: import_chalk7.default.blue(\"prisma:query\")\n};\nvar should = {\n  warn: !process.env.PRISMA_DISABLE_WARNINGS\n};\nfunction log3(...data) {\n  console.log(...data);\n}\n__name(log3, \"log\");\nfunction warn(message, ...optionalParams) {\n  if (should.warn) {\n    console.warn(`${tags.warn} ${message}`, ...optionalParams);\n  }\n}\n__name(warn, \"warn\");\nfunction info(message, ...optionalParams) {\n  console.info(`${tags.info} ${message}`, ...optionalParams);\n}\n__name(info, \"info\");\nfunction error(message, ...optionalParams) {\n  console.error(`${tags.error} ${message}`, ...optionalParams);\n}\n__name(error, \"error\");\nfunction query(message, ...optionalParams) {\n  console.log(`${tags.query} ${message}`, ...optionalParams);\n}\n__name(query, \"query\");\n\n// ../internals/src/utils/assertNever.ts\nfunction assertNever(arg2, errorMessage) {\n  throw new Error(errorMessage);\n}\n__name(assertNever, \"assertNever\");\n\n// ../internals/src/utils/callOnce.ts\nfunction callOnce(fn) {\n  let result;\n  return (...args) => result != null ? result : result = fn(...args);\n}\n__name(callOnce, \"callOnce\");\n\n// ../internals/src/utils/keyBy.ts\nvar keyBy2 = /* @__PURE__ */ __name((collection, iteratee) => {\n  return collection.reduce((acc, curr) => {\n    acc[iteratee(curr)] = curr;\n    return acc;\n  }, {});\n}, \"keyBy\");\n\n// ../internals/src/warnOnce.ts\nvar alreadyWarned = /* @__PURE__ */ new Set();\nvar warnOnce = /* @__PURE__ */ __name((key, message, ...args) => {\n  if (!alreadyWarned.has(key)) {\n    alreadyWarned.add(key);\n    warn(message, ...args);\n  }\n}, \"warnOnce\");\n\n// src/runtime/getPrismaClient.ts\nvar import_async_hooks = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nvar import_fs9 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path5 = __toESM(__webpack_require__(/*! path */ \"path\"));\n\n// ../../node_modules/.pnpm/sql-template-tag@5.0.3/node_modules/sql-template-tag/dist/index.js\nvar Sql = class {\n  constructor(rawStrings, rawValues) {\n    if (rawStrings.length - 1 !== rawValues.length) {\n      if (rawStrings.length === 0) {\n        throw new TypeError(\"Expected at least 1 string\");\n      }\n      throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);\n    }\n    const valuesLength = rawValues.reduce((len, value) => len + (value instanceof Sql ? value.values.length : 1), 0);\n    this.values = new Array(valuesLength);\n    this.strings = new Array(valuesLength + 1);\n    this.strings[0] = rawStrings[0];\n    let i = 0, pos = 0;\n    while (i < rawValues.length) {\n      const child = rawValues[i++];\n      const rawString = rawStrings[i];\n      if (child instanceof Sql) {\n        this.strings[pos] += child.strings[0];\n        let childIndex = 0;\n        while (childIndex < child.values.length) {\n          this.values[pos++] = child.values[childIndex++];\n          this.strings[pos] = child.strings[childIndex];\n        }\n        this.strings[pos] += rawString;\n      } else {\n        this.values[pos++] = child;\n        this.strings[pos] = rawString;\n      }\n    }\n  }\n  get text() {\n    let i = 1, value = this.strings[0];\n    while (i < this.strings.length)\n      value += `$${i}${this.strings[i++]}`;\n    return value;\n  }\n  get sql() {\n    let i = 1, value = this.strings[0];\n    while (i < this.strings.length)\n      value += `?${this.strings[i++]}`;\n    return value;\n  }\n  inspect() {\n    return {\n      text: this.text,\n      sql: this.sql,\n      values: this.values\n    };\n  }\n};\n__name(Sql, \"Sql\");\nfunction join(values, separator = \",\", prefix = \"\", suffix = \"\") {\n  if (values.length === 0) {\n    throw new TypeError(\"Expected `join([])` to be called with an array of multiple elements, but got an empty array\");\n  }\n  return new Sql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);\n}\n__name(join, \"join\");\nfunction raw(value) {\n  return new Sql([value], []);\n}\n__name(raw, \"raw\");\nvar empty = raw(\"\");\nfunction sql(strings, ...values) {\n  return new Sql(strings, values);\n}\n__name(sql, \"sql\");\n\n// src/runtime/externalToInternalDmmf.ts\nvar import_pluralize = __toESM(require_pluralize());\nfunction externalToInternalDmmf(document2) {\n  return {\n    ...document2,\n    mappings: getMappings(document2.mappings, document2.datamodel)\n  };\n}\n__name(externalToInternalDmmf, \"externalToInternalDmmf\");\nfunction getMappings(mappings, datamodel) {\n  const modelOperations = mappings.modelOperations.filter((mapping) => {\n    const model = datamodel.models.find((m) => m.name === mapping.model);\n    if (!model) {\n      throw new Error(`Mapping without model ${mapping.model}`);\n    }\n    return model.fields.some((f) => f.kind !== \"object\");\n  }).map((mapping) => ({\n    model: mapping.model,\n    plural: (0, import_pluralize.default)(lowerCase(mapping.model)),\n    findUnique: mapping.findUnique || mapping.findSingle,\n    findFirst: mapping.findFirst,\n    findMany: mapping.findMany,\n    create: mapping.createOne || mapping.createSingle || mapping.create,\n    createMany: mapping.createMany,\n    delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,\n    update: mapping.updateOne || mapping.updateSingle || mapping.update,\n    deleteMany: mapping.deleteMany,\n    updateMany: mapping.updateMany,\n    upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,\n    aggregate: mapping.aggregate,\n    groupBy: mapping.groupBy,\n    findRaw: mapping.findRaw,\n    aggregateRaw: mapping.aggregateRaw\n  }));\n  return {\n    modelOperations,\n    otherOperations: mappings.otherOperations\n  };\n}\n__name(getMappings, \"getMappings\");\n\n// src/generation/getDMMF.ts\nfunction getPrismaClientDMMF(dmmf) {\n  return externalToInternalDmmf(dmmf);\n}\n__name(getPrismaClientDMMF, \"getPrismaClientDMMF\");\n\n// src/runtime/clientActions.ts\nvar clientOnlyActions = {\n  findUniqueOrThrow: {\n    wrappedAction: DMMF.ModelAction.findUnique\n  },\n  findFirstOrThrow: {\n    wrappedAction: DMMF.ModelAction.findFirst\n  }\n};\nfunction getDmmfActionName(name) {\n  if (isClientOnlyAction(name)) {\n    return clientOnlyActions[name].wrappedAction;\n  }\n  return name;\n}\n__name(getDmmfActionName, \"getDmmfActionName\");\nfunction isClientOnlyAction(action) {\n  return Object.prototype.hasOwnProperty.call(clientOnlyActions, action);\n}\n__name(isClientOnlyAction, \"isClientOnlyAction\");\nvar allClientModelActions = Object.keys(DMMF.ModelAction).concat(\n  Object.keys(clientOnlyActions)\n);\n\n// ../../node_modules/.pnpm/stacktrace-parser@0.1.10/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js\nvar UNKNOWN_FUNCTION = \"<unknown>\";\nfunction parse(stackString) {\n  var lines = stackString.split(\"\\n\");\n  return lines.reduce(function(stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n    return stack;\n  }, []);\n}\n__name(parse, \"parse\");\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  var isNative = parts[2] && parts[2].indexOf(\"native\") === 0;\n  var isEval = parts[2] && parts[2].indexOf(\"eval\") === 0;\n  var submatch = chromeEvalRe.exec(parts[2]);\n  if (isEval && submatch != null) {\n    parts[2] = submatch[1];\n    parts[3] = submatch[2];\n    parts[4] = submatch[3];\n  }\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseChrome, \"parseChrome\");\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseWinjs, \"parseWinjs\");\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  var isEval = parts[3] && parts[3].indexOf(\" > eval\") > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n  if (isEval && submatch != null) {\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null;\n  }\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(\",\") : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n__name(parseGecko, \"parseGecko\");\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n__name(parseJSC, \"parseJSC\");\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n__name(parseNode, \"parseNode\");\n\n// src/runtime/utils/CallSite.ts\nvar DisabledCallSite = class {\n  getLocation() {\n    return null;\n  }\n};\n__name(DisabledCallSite, \"DisabledCallSite\");\nvar EnabledCallSite = class {\n  constructor() {\n    this._error = new Error();\n  }\n  getLocation() {\n    const stack = this._error.stack;\n    if (!stack) {\n      return null;\n    }\n    const stackFrames = parse(stack);\n    const frame = stackFrames.find((t) => {\n      return t.file && t.file !== \"<anonymous>\" && !t.file.includes(\"@prisma\") && !t.file.includes(\"getPrismaClient\") && !t.file.startsWith(\"internal/\") && !t.methodName.includes(\"new \") && !t.methodName.includes(\"getCallSite\") && !t.methodName.includes(\"Proxy.\") && t.methodName.split(\".\").length < 4;\n    });\n    if (!frame || !frame.file) {\n      return null;\n    }\n    return {\n      fileName: frame.file,\n      lineNumber: frame.lineNumber,\n      columnNumber: frame.column\n    };\n  }\n};\n__name(EnabledCallSite, \"EnabledCallSite\");\nfunction getCallSite(errorFormat) {\n  if (errorFormat === \"minimal\") {\n    return new DisabledCallSite();\n  }\n  return new EnabledCallSite();\n}\n__name(getCallSite, \"getCallSite\");\n\n// src/runtime/core/request/createPrismaPromise.ts\nfunction createPrismaPromise(callback) {\n  let promise;\n  const _callback = /* @__PURE__ */ __name((txId, lock) => {\n    try {\n      return promise != null ? promise : promise = callback(txId, lock);\n    } catch (error2) {\n      return Promise.reject(error2);\n    }\n  }, \"_callback\");\n  return {\n    then(onFulfilled, onRejected, txId) {\n      return _callback(txId, void 0).then(onFulfilled, onRejected, txId);\n    },\n    catch(onRejected, txId) {\n      return _callback(txId, void 0).catch(onRejected, txId);\n    },\n    finally(onFinally, txId) {\n      return _callback(txId, void 0).finally(onFinally, txId);\n    },\n    requestTransaction(txId, lock) {\n      const promise2 = _callback(txId, lock);\n      if (promise2.requestTransaction) {\n        return promise2.requestTransaction(txId, lock);\n      }\n      return promise2;\n    },\n    [Symbol.toStringTag]: \"PrismaPromise\"\n  };\n}\n__name(createPrismaPromise, \"createPrismaPromise\");\n\n// src/runtime/core/model/aggregates/utils/aggregateMap.ts\nvar aggregateMap = {\n  _avg: true,\n  _count: true,\n  _sum: true,\n  _min: true,\n  _max: true\n};\n\n// src/runtime/core/model/aggregates/aggregate.ts\nfunction desugarUserArgs(userArgs) {\n  const _userArgs = desugarCountInUserArgs(userArgs);\n  const userArgsEntries = Object.entries(_userArgs);\n  return userArgsEntries.reduce(\n    (aggregateArgs, [key, value]) => {\n      if (aggregateMap[key] !== void 0) {\n        aggregateArgs[\"select\"][key] = { select: value };\n      } else {\n        aggregateArgs[key] = value;\n      }\n      return aggregateArgs;\n    },\n    { select: {} }\n  );\n}\n__name(desugarUserArgs, \"desugarUserArgs\");\nfunction desugarCountInUserArgs(userArgs) {\n  if (typeof userArgs[\"_count\"] === \"boolean\") {\n    return { ...userArgs, _count: { _all: userArgs[\"_count\"] } };\n  }\n  return userArgs;\n}\n__name(desugarCountInUserArgs, \"desugarCountInUserArgs\");\nfunction createUnpacker(userArgs) {\n  return (data) => {\n    if (typeof userArgs[\"_count\"] === \"boolean\") {\n      data[\"_count\"] = data[\"_count\"][\"_all\"];\n    }\n    return data;\n  };\n}\n__name(createUnpacker, \"createUnpacker\");\nfunction aggregate(client, userArgs, modelAction) {\n  const aggregateArgs = desugarUserArgs(userArgs != null ? userArgs : {});\n  const aggregateUnpacker = createUnpacker(userArgs != null ? userArgs : {});\n  return modelAction({\n    action: \"aggregate\",\n    unpacker: aggregateUnpacker\n  })(aggregateArgs);\n}\n__name(aggregate, \"aggregate\");\n\n// src/runtime/core/model/aggregates/count.ts\nfunction count(client, userArgs, modelAction) {\n  const { select, ..._userArgs } = userArgs != null ? userArgs : {};\n  if (typeof select === \"object\") {\n    return aggregate(\n      client,\n      { ..._userArgs, _count: select },\n      (p) => modelAction({ ...p, action: \"count\", unpacker: (data) => {\n        var _a3;\n        return (_a3 = p.unpacker) == null ? void 0 : _a3.call(p, data)[\"_count\"];\n      } })\n    );\n  } else {\n    return aggregate(\n      client,\n      { ..._userArgs, _count: { _all: true } },\n      (p) => modelAction({ ...p, action: \"count\", unpacker: (data) => {\n        var _a3;\n        return (_a3 = p.unpacker) == null ? void 0 : _a3.call(p, data)[\"_count\"][\"_all\"];\n      } })\n    );\n  }\n}\n__name(count, \"count\");\n\n// src/runtime/core/model/aggregates/groupBy.ts\nfunction desugarUserArgs2(userArgs) {\n  const _userArgs = desugarUserArgs(userArgs);\n  if (Array.isArray(userArgs[\"by\"])) {\n    for (const key of userArgs[\"by\"]) {\n      if (typeof key === \"string\") {\n        _userArgs[\"select\"][key] = true;\n      }\n    }\n  }\n  return _userArgs;\n}\n__name(desugarUserArgs2, \"desugarUserArgs\");\nfunction createUnpacker2(userArgs) {\n  return (data) => {\n    if (typeof userArgs[\"_count\"] === \"boolean\") {\n      data.forEach((row) => {\n        row[\"_count\"] = row[\"_count\"][\"_all\"];\n      });\n    }\n    return data;\n  };\n}\n__name(createUnpacker2, \"createUnpacker\");\nfunction groupBy(client, userArgs, modelAction) {\n  const groupByArgs = desugarUserArgs2(userArgs != null ? userArgs : {});\n  const groupByUnpacker = createUnpacker2(userArgs != null ? userArgs : {});\n  return modelAction({\n    action: \"groupBy\",\n    unpacker: groupByUnpacker\n  })(groupByArgs);\n}\n__name(groupBy, \"groupBy\");\n\n// src/runtime/core/model/applyAggregates.ts\nfunction applyAggregates(client, action, modelAction) {\n  if (action === \"aggregate\")\n    return (userArgs) => aggregate(client, userArgs, modelAction);\n  if (action === \"count\")\n    return (userArgs) => count(client, userArgs, modelAction);\n  if (action === \"groupBy\")\n    return (userArgs) => groupBy(client, userArgs, modelAction);\n  return void 0;\n}\n__name(applyAggregates, \"applyAggregates\");\n\n// src/runtime/query.ts\nvar import_chalk11 = __toESM(require_source());\nvar import_indent_string4 = __toESM(require_indent_string());\nvar import_strip_ansi3 = __toESM(require_strip_ansi());\n\n// src/runtime/utils/createErrorMessageWithContext.ts\nvar import_chalk9 = __toESM(require_source());\nvar import_indent_string3 = __toESM(require_indent_string());\n\n// src/runtime/utils/SourceFileSlice.ts\nvar import_fs8 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\n\n// src/runtime/highlight/theme.ts\nvar import_chalk8 = __toESM(require_source());\nvar orange = import_chalk8.default.rgb(246, 145, 95);\nvar darkBrightBlue = import_chalk8.default.rgb(107, 139, 140);\nvar blue = import_chalk8.default.cyan;\nvar brightBlue = import_chalk8.default.rgb(127, 155, 155);\nvar identity = /* @__PURE__ */ __name((str) => str, \"identity\");\nvar theme = {\n  keyword: blue,\n  entity: blue,\n  value: brightBlue,\n  punctuation: darkBrightBlue,\n  directive: blue,\n  function: blue,\n  variable: brightBlue,\n  string: import_chalk8.default.greenBright,\n  boolean: orange,\n  number: import_chalk8.default.cyan,\n  comment: import_chalk8.default.grey\n};\n\n// src/runtime/highlight/prism.ts\nvar _self = {};\nvar uniqueId = 0;\nvar Prism = {\n  manual: _self.Prism && _self.Prism.manual,\n  disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n  util: {\n    encode: function(tokens) {\n      if (tokens instanceof Token) {\n        const anyTokens = tokens;\n        return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);\n      } else if (Array.isArray(tokens)) {\n        return tokens.map(Prism.util.encode);\n      } else {\n        return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n      }\n    },\n    type: function(o) {\n      return Object.prototype.toString.call(o).slice(8, -1);\n    },\n    objId: function(obj) {\n      if (!obj[\"__id\"]) {\n        Object.defineProperty(obj, \"__id\", { value: ++uniqueId });\n      }\n      return obj[\"__id\"];\n    },\n    clone: /* @__PURE__ */ __name(function deepClone(o, visited) {\n      let clone2, id, type = Prism.util.type(o);\n      visited = visited || {};\n      switch (type) {\n        case \"Object\":\n          id = Prism.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone2 = {};\n          visited[id] = clone2;\n          for (const key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone2[key] = deepClone(o[key], visited);\n            }\n          }\n          return clone2;\n        case \"Array\":\n          id = Prism.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone2 = [];\n          visited[id] = clone2;\n          o.forEach(function(v, i) {\n            clone2[i] = deepClone(v, visited);\n          });\n          return clone2;\n        default:\n          return o;\n      }\n    }, \"deepClone\")\n  },\n  languages: {\n    extend: function(id, redef) {\n      const lang = Prism.util.clone(Prism.languages[id]);\n      for (const key in redef) {\n        lang[key] = redef[key];\n      }\n      return lang;\n    },\n    insertBefore: function(inside, before, insert, root) {\n      root = root || Prism.languages;\n      const grammar = root[inside];\n      const ret = {};\n      for (const token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (const newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken];\n              }\n            }\n          }\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token];\n          }\n        }\n      }\n      const old = root[inside];\n      root[inside] = ret;\n      Prism.languages.DFS(Prism.languages, function(key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret;\n        }\n      });\n      return ret;\n    },\n    DFS: /* @__PURE__ */ __name(function DFS(o, callback, type, visited) {\n      visited = visited || {};\n      const objId = Prism.util.objId;\n      for (const i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i);\n          const property = o[i], propertyType = Prism.util.type(property);\n          if (propertyType === \"Object\" && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, null, visited);\n          } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, i, visited);\n          }\n        }\n      }\n    }, \"DFS\")\n  },\n  plugins: {},\n  highlight: function(text, grammar, language) {\n    const env2 = {\n      code: text,\n      grammar,\n      language\n    };\n    Prism.hooks.run(\"before-tokenize\", env2);\n    env2.tokens = Prism.tokenize(env2.code, env2.grammar);\n    Prism.hooks.run(\"after-tokenize\", env2);\n    return Token.stringify(Prism.util.encode(env2.tokens), env2.language);\n  },\n  matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {\n    for (const token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue;\n      }\n      if (token == target) {\n        return;\n      }\n      let patterns = grammar[token];\n      patterns = Prism.util.type(patterns) === \"Array\" ? patterns : [patterns];\n      for (let j = 0; j < patterns.length; ++j) {\n        let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;\n        if (greedy && !pattern.pattern.global) {\n          const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\n          pattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\n        }\n        pattern = pattern.pattern || pattern;\n        for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {\n          let str = strarr[i];\n          if (strarr.length > text.length) {\n            return;\n          }\n          if (str instanceof Token) {\n            continue;\n          }\n          if (greedy && i != strarr.length - 1) {\n            pattern.lastIndex = pos;\n            var match = pattern.exec(text);\n            if (!match) {\n              break;\n            }\n            var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;\n            for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {\n              p += strarr[k].length;\n              if (from >= p) {\n                ++i;\n                pos = p;\n              }\n            }\n            if (strarr[i] instanceof Token) {\n              continue;\n            }\n            delNum = k - i;\n            str = text.slice(pos, p);\n            match.index -= pos;\n          } else {\n            pattern.lastIndex = 0;\n            var match = pattern.exec(str), delNum = 1;\n          }\n          if (!match) {\n            if (oneshot) {\n              break;\n            }\n            continue;\n          }\n          if (lookbehind) {\n            lookbehindLength = match[1] ? match[1].length : 0;\n          }\n          var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);\n          const args = [i, delNum];\n          if (before) {\n            ++i;\n            pos += before.length;\n            args.push(before);\n          }\n          const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);\n          args.push(wrapped);\n          if (after) {\n            args.push(after);\n          }\n          Array.prototype.splice.apply(strarr, args);\n          if (delNum != 1)\n            Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);\n          if (oneshot)\n            break;\n        }\n      }\n    }\n  },\n  tokenize: function(text, grammar) {\n    const strarr = [text];\n    const rest = grammar.rest;\n    if (rest) {\n      for (const token in rest) {\n        grammar[token] = rest[token];\n      }\n      delete grammar.rest;\n    }\n    Prism.matchGrammar(text, strarr, grammar, 0, 0, false);\n    return strarr;\n  },\n  hooks: {\n    all: {},\n    add: function(name, callback) {\n      const hooks = Prism.hooks.all;\n      hooks[name] = hooks[name] || [];\n      hooks[name].push(callback);\n    },\n    run: function(name, env2) {\n      const callbacks = Prism.hooks.all[name];\n      if (!callbacks || !callbacks.length) {\n        return;\n      }\n      for (var i = 0, callback; callback = callbacks[i++]; ) {\n        callback(env2);\n      }\n    }\n  },\n  Token\n};\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      lookbehind: true\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true,\n      greedy: true\n    }\n  ],\n  string: {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  \"class-name\": {\n    pattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      punctuation: /[.\\\\]/\n    }\n  },\n  keyword: /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  boolean: /\\b(?:true|false)\\b/,\n  function: /\\w+(?=\\()/,\n  number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  operator: /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n  punctuation: /[{}[\\];(),.:]/\n};\nPrism.languages.javascript = Prism.languages.extend(\"clike\", {\n  \"class-name\": [\n    Prism.languages.clike[\"class-name\"],\n    {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[_$A-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\.(?:prototype|constructor))/,\n      lookbehind: true\n    }\n  ],\n  keyword: [\n    {\n      pattern: /((?:^|})\\s*)(?:catch|finally)\\b/,\n      lookbehind: true\n    },\n    {\n      pattern: /(^|[^.])\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n      lookbehind: true\n    }\n  ],\n  number: /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n  function: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  operator: /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n  regex: {\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=\\s*($|[\\r\\n,.;})\\]]))/,\n    lookbehind: true,\n    greedy: true\n  },\n  \"function-variable\": {\n    pattern: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/,\n    alias: \"function\"\n  },\n  parameter: [\n    {\n      pattern: /(function(?:\\s+[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)?\\s*\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\))/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=>)/i,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /(\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*=>)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    {\n      pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*\\s*)\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*\\{)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    }\n  ],\n  constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nif (Prism.languages.markup) {\n  Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\nPrism.languages.typescript = Prism.languages.extend(\"javascript\", {\n  keyword: /\\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\\b/,\n  builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/\n});\nPrism.languages.ts = Prism.languages.typescript;\nfunction Token(type, content, alias, matchedStr, greedy) {\n  this.type = type;\n  this.content = content;\n  this.alias = alias;\n  this.length = (matchedStr || \"\").length | 0;\n  this.greedy = !!greedy;\n}\n__name(Token, \"Token\");\nToken.stringify = function(o, language) {\n  if (typeof o == \"string\") {\n    return o;\n  }\n  if (Array.isArray(o)) {\n    return o.map(function(element) {\n      return Token.stringify(element, language);\n    }).join(\"\");\n  }\n  return getColorForSyntaxKind(o.type)(o.content);\n};\nfunction getColorForSyntaxKind(syntaxKind) {\n  return theme[syntaxKind] || identity;\n}\n__name(getColorForSyntaxKind, \"getColorForSyntaxKind\");\n\n// src/runtime/highlight/highlight.ts\nfunction highlightTS(str) {\n  return highlight(str, Prism.languages.javascript);\n}\n__name(highlightTS, \"highlightTS\");\nfunction highlight(str, grammar) {\n  const tokens = Prism.tokenize(str, grammar);\n  return tokens.map((t) => Token.stringify(t)).join(\"\");\n}\n__name(highlight, \"highlight\");\n\n// src/runtime/utils/dedent.ts\nvar import_strip_indent2 = __toESM(require_strip_indent());\nfunction dedent2(str) {\n  return (0, import_strip_indent2.default)(str);\n}\n__name(dedent2, \"dedent\");\n\n// src/runtime/utils/SourceFileSlice.ts\nvar SourceFileSlice = class {\n  static read(filePath) {\n    let content;\n    try {\n      content = import_fs8.default.readFileSync(filePath, \"utf-8\");\n    } catch (e) {\n      return null;\n    }\n    return SourceFileSlice.fromContent(content);\n  }\n  static fromContent(content) {\n    const lines = content.split(/\\r?\\n/);\n    return new SourceFileSlice(1, lines);\n  }\n  constructor(firstLine, lines) {\n    this.firstLineNumber = firstLine;\n    this.lines = lines;\n  }\n  get lastLineNumber() {\n    return this.firstLineNumber + this.lines.length - 1;\n  }\n  mapLineAt(lineNumber, mapFn) {\n    if (lineNumber < this.firstLineNumber || lineNumber > this.lines.length + this.firstLineNumber) {\n      return this;\n    }\n    const idx = lineNumber - this.firstLineNumber;\n    const newLines = [...this.lines];\n    newLines[idx] = mapFn(newLines[idx]);\n    return new SourceFileSlice(this.firstLineNumber, newLines);\n  }\n  mapLines(mapFn) {\n    return new SourceFileSlice(\n      this.firstLineNumber,\n      this.lines.map((line, i) => mapFn(line, this.firstLineNumber + i))\n    );\n  }\n  lineAt(lineNumber) {\n    return this.lines[lineNumber - this.firstLineNumber];\n  }\n  prependSymbolAt(atLine, str) {\n    return this.mapLines((line, lineNumber) => {\n      if (lineNumber === atLine) {\n        return `${str} ${line}`;\n      }\n      return `  ${line}`;\n    });\n  }\n  slice(fromLine, toLine) {\n    const slicedLines = this.lines.slice(fromLine - 1, toLine).join(\"\\n\");\n    return new SourceFileSlice(fromLine, dedent2(slicedLines).split(\"\\n\"));\n  }\n  highlight() {\n    const highlighted = highlightTS(this.toString());\n    return new SourceFileSlice(this.firstLineNumber, highlighted.split(\"\\n\"));\n  }\n  toString() {\n    return this.lines.join(\"\\n\");\n  }\n};\n__name(SourceFileSlice, \"SourceFileSlice\");\n\n// src/runtime/utils/createErrorMessageWithContext.ts\nvar colorsEnabled = {\n  red: (str) => import_chalk9.default.red(str),\n  gray: (str) => import_chalk9.default.gray(str),\n  dim: (str) => import_chalk9.default.dim(str),\n  bold: (str) => import_chalk9.default.bold(str),\n  underline: (str) => import_chalk9.default.underline(str),\n  highlightSource: (source) => source.highlight()\n};\nvar colorsDisabled = {\n  red: (str) => str,\n  gray: (str) => str,\n  dim: (str) => str,\n  bold: (str) => str,\n  underline: (str) => str,\n  highlightSource: (source) => source\n};\nfunction getTemplateParameters({ callsite, message, originalMethod, isPanic, callArguments }, colors) {\n  var _a3;\n  const templateParameters = {\n    functionName: `prisma.${originalMethod}()`,\n    message,\n    isPanic: isPanic != null ? isPanic : false,\n    callArguments\n  };\n  if (!callsite || typeof window !== \"undefined\") {\n    return templateParameters;\n  }\n  if (false) {}\n  const callLocation = callsite.getLocation();\n  if (!callLocation || !callLocation.lineNumber || !callLocation.columnNumber) {\n    return templateParameters;\n  }\n  const contextFirstLine = Math.max(1, callLocation.lineNumber - 3);\n  let source = (_a3 = SourceFileSlice.read(callLocation.fileName)) == null ? void 0 : _a3.slice(contextFirstLine, callLocation.lineNumber);\n  if (source) {\n    const invocationLine = source.lineAt(callLocation.lineNumber);\n    const invocationLineIndent = getIndent(invocationLine);\n    const invocationCallCode = findPrismaActionCall(invocationLine);\n    if (!invocationCallCode) {\n      return templateParameters;\n    }\n    templateParameters.functionName = `${invocationCallCode.code})`;\n    templateParameters.location = callLocation;\n    if (!isPanic) {\n      source = source.mapLineAt(callLocation.lineNumber, (line) => line.slice(0, invocationCallCode.openingBraceIndex));\n    }\n    source = colors.highlightSource(source);\n    const numberColumnWidth = String(source.lastLineNumber).length;\n    templateParameters.contextLines = source.mapLines((line, lineNumber) => colors.gray(String(lineNumber).padStart(numberColumnWidth)) + \" \" + line).mapLines((line) => colors.dim(line)).prependSymbolAt(callLocation.lineNumber, colors.bold(colors.red(\"\\u2192\")));\n    if (callArguments) {\n      let indentValue = invocationLineIndent + numberColumnWidth + 1;\n      indentValue += 2;\n      templateParameters.callArguments = (0, import_indent_string3.default)(callArguments, indentValue).slice(indentValue);\n    }\n  }\n  return templateParameters;\n}\n__name(getTemplateParameters, \"getTemplateParameters\");\nfunction findPrismaActionCall(str) {\n  const allActions = allClientModelActions.join(\"|\");\n  const regexp = new RegExp(String.raw`\\S+(${allActions})\\(`);\n  const match = regexp.exec(str);\n  if (match) {\n    return {\n      code: match[0],\n      openingBraceIndex: match.index + match[0].length\n    };\n  }\n  return null;\n}\n__name(findPrismaActionCall, \"findPrismaActionCall\");\nfunction getIndent(line) {\n  let spaceCount = 0;\n  for (let i = 0; i < line.length; i++) {\n    if (line.charAt(i) !== \" \") {\n      return spaceCount;\n    }\n    spaceCount++;\n  }\n  return spaceCount;\n}\n__name(getIndent, \"getIndent\");\nfunction stringifyErrorMessage({ functionName, location, message, isPanic, contextLines, callArguments }, colors) {\n  const lines = [\"\"];\n  const introSuffix = location ? \" in\" : \":\";\n  if (isPanic) {\n    lines.push(colors.red(`Oops, an unknown error occured! This is ${colors.bold(\"on us\")}, you did nothing wrong.`));\n    lines.push(colors.red(`It occured in the ${colors.bold(`\\`${functionName}\\``)} invocation${introSuffix}`));\n  } else {\n    lines.push(colors.red(`Invalid ${colors.bold(`\\`${functionName}\\``)} invocation${introSuffix}`));\n  }\n  if (location) {\n    lines.push(colors.underline(stringifyLocationInFile(location)));\n  }\n  if (contextLines) {\n    lines.push(\"\");\n    const contextLineParts = [contextLines.toString()];\n    if (callArguments) {\n      contextLineParts.push(callArguments);\n      contextLineParts.push(colors.dim(\")\"));\n    }\n    lines.push(contextLineParts.join(\"\"));\n    if (callArguments) {\n      lines.push(\"\");\n    }\n  } else {\n    lines.push(\"\");\n    if (callArguments) {\n      lines.push(callArguments);\n    }\n    lines.push(\"\");\n  }\n  lines.push(message);\n  return lines.join(\"\\n\");\n}\n__name(stringifyErrorMessage, \"stringifyErrorMessage\");\nfunction stringifyLocationInFile(location) {\n  const parts = [location.fileName];\n  if (location.lineNumber) {\n    parts.push(String(location.lineNumber));\n  }\n  if (location.columnNumber) {\n    parts.push(String(location.columnNumber));\n  }\n  return parts.join(\":\");\n}\n__name(stringifyLocationInFile, \"stringifyLocationInFile\");\nfunction createErrorMessageWithContext(args) {\n  const colors = args.showColors ? colorsEnabled : colorsDisabled;\n  const templateParameters = getTemplateParameters(args, colors);\n  return stringifyErrorMessage(templateParameters, colors);\n}\n__name(createErrorMessageWithContext, \"createErrorMessageWithContext\");\n\n// src/runtime/utils/deep-extend.ts\nfunction isSpecificValue(val) {\n  return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;\n}\n__name(isSpecificValue, \"isSpecificValue\");\nfunction cloneSpecificValue(val) {\n  if (val instanceof Buffer) {\n    const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);\n    val.copy(x);\n    return x;\n  } else if (val instanceof Date) {\n    return new Date(val.getTime());\n  } else if (val instanceof RegExp) {\n    return new RegExp(val);\n  } else {\n    throw new Error(\"Unexpected situation\");\n  }\n}\n__name(cloneSpecificValue, \"cloneSpecificValue\");\nfunction deepCloneArray(arr) {\n  const clone2 = [];\n  arr.forEach(function(item, index) {\n    if (typeof item === \"object\" && item !== null) {\n      if (Array.isArray(item)) {\n        clone2[index] = deepCloneArray(item);\n      } else if (isSpecificValue(item)) {\n        clone2[index] = cloneSpecificValue(item);\n      } else {\n        clone2[index] = deepExtend({}, item);\n      }\n    } else {\n      clone2[index] = item;\n    }\n  });\n  return clone2;\n}\n__name(deepCloneArray, \"deepCloneArray\");\nfunction safeGetProperty(object, property) {\n  return property === \"__proto__\" ? void 0 : object[property];\n}\n__name(safeGetProperty, \"safeGetProperty\");\nvar deepExtend = /* @__PURE__ */ __name(function(target, ...args) {\n  if (!target || typeof target !== \"object\") {\n    return false;\n  }\n  if (args.length === 0) {\n    return target;\n  }\n  let val, src;\n  for (const obj of args) {\n    if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n      continue;\n    }\n    for (const key of Object.keys(obj)) {\n      src = safeGetProperty(target, key);\n      val = safeGetProperty(obj, key);\n      if (val === target) {\n        continue;\n      } else if (typeof val !== \"object\" || val === null) {\n        target[key] = val;\n        continue;\n      } else if (Array.isArray(val)) {\n        target[key] = deepCloneArray(val);\n        continue;\n      } else if (isSpecificValue(val)) {\n        target[key] = cloneSpecificValue(val);\n        continue;\n      } else if (typeof src !== \"object\" || src === null || Array.isArray(src)) {\n        target[key] = deepExtend({}, val);\n        continue;\n      } else {\n        target[key] = deepExtend(src, val);\n        continue;\n      }\n    }\n  }\n  return target;\n}, \"deepExtend\");\n\n// src/runtime/utils/deep-set.ts\nvar keys = /* @__PURE__ */ __name((ks) => Array.isArray(ks) ? ks : ks.split(\".\"), \"keys\");\nvar deepGet = /* @__PURE__ */ __name((o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o), \"deepGet\");\nvar deepSet = /* @__PURE__ */ __name((o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v2 }), v), \"deepSet\");\n\n// src/runtime/utils/filterObject.ts\nfunction filterObject(obj, cb) {\n  if (!obj || typeof obj !== \"object\" || typeof obj.hasOwnProperty !== \"function\") {\n    return obj;\n  }\n  const newObj = {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {\n      newObj[key] = value;\n    }\n  }\n  return newObj;\n}\n__name(filterObject, \"filterObject\");\n\n// src/runtime/utils/flatMap.ts\nfunction flatten(array) {\n  return Array.prototype.concat.apply([], array);\n}\n__name(flatten, \"flatten\");\nfunction flatMap(array, callbackFn, thisArg) {\n  return flatten(array.map(callbackFn, thisArg));\n}\n__name(flatMap, \"flatMap\");\n\n// src/runtime/utils/isObject.ts\nvar notReallyObjects = {\n  \"[object Date]\": true,\n  \"[object Uint8Array]\": true,\n  \"[object Decimal]\": true\n};\nfunction isObject2(value) {\n  if (!value) {\n    return false;\n  }\n  return typeof value === \"object\" && !notReallyObjects[Object.prototype.toString.call(value)];\n}\n__name(isObject2, \"isObject\");\n\n// src/runtime/utils/omit.ts\nfunction omit2(object, path7) {\n  const result = {};\n  const paths = Array.isArray(path7) ? path7 : [path7];\n  for (const key in object) {\n    if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n__name(omit2, \"omit\");\n\n// src/runtime/utils/printJsonErrors.ts\nvar import_chalk10 = __toESM(require_source());\nvar import_strip_ansi2 = __toESM(require_strip_ansi());\n\n// src/runtime/utils/stringifyObject.ts\nvar isRegexp = require_is_regexp();\nvar isObj = require_is_obj();\nvar getOwnEnumPropSymbols = require_lib().default;\nvar stringifyObject = /* @__PURE__ */ __name((input, options, pad) => {\n  const seen = [];\n  return (/* @__PURE__ */ __name(function stringifyObject2(input2, options2 = {}, pad2 = \"\", path7 = []) {\n    options2.indent = options2.indent || \"\t\";\n    let tokens;\n    if (options2.inlineCharacterLimit === void 0) {\n      tokens = {\n        newLine: \"\\n\",\n        newLineOrSpace: \"\\n\",\n        pad: pad2,\n        indent: pad2 + options2.indent\n      };\n    } else {\n      tokens = {\n        newLine: \"@@__STRINGIFY_OBJECT_NEW_LINE__@@\",\n        newLineOrSpace: \"@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@\",\n        pad: \"@@__STRINGIFY_OBJECT_PAD__@@\",\n        indent: \"@@__STRINGIFY_OBJECT_INDENT__@@\"\n      };\n    }\n    const expandWhiteSpace = /* @__PURE__ */ __name((string) => {\n      if (options2.inlineCharacterLimit === void 0) {\n        return string;\n      }\n      const oneLined = string.replace(new RegExp(tokens.newLine, \"g\"), \"\").replace(new RegExp(tokens.newLineOrSpace, \"g\"), \" \").replace(new RegExp(tokens.pad + \"|\" + tokens.indent, \"g\"), \"\");\n      if (oneLined.length <= options2.inlineCharacterLimit) {\n        return oneLined;\n      }\n      return string.replace(new RegExp(tokens.newLine + \"|\" + tokens.newLineOrSpace, \"g\"), \"\\n\").replace(new RegExp(tokens.pad, \"g\"), pad2).replace(new RegExp(tokens.indent, \"g\"), pad2 + options2.indent);\n    }, \"expandWhiteSpace\");\n    if (seen.indexOf(input2) !== -1) {\n      return '\"[Circular]\"';\n    }\n    if (Buffer.isBuffer(input2)) {\n      return `Buffer(${Buffer.length})`;\n    }\n    if (input2 === null || input2 === void 0 || typeof input2 === \"number\" || typeof input2 === \"boolean\" || typeof input2 === \"function\" || typeof input2 === \"symbol\" || input2 instanceof ObjectEnumValue || isRegexp(input2)) {\n      return String(input2);\n    }\n    if (input2 instanceof Date) {\n      return `new Date('${input2.toISOString()}')`;\n    }\n    if (input2 instanceof FieldRefImpl) {\n      return `prisma.${lowerCase(input2.modelName)}.fields.${input2.name}`;\n    }\n    if (Array.isArray(input2)) {\n      if (input2.length === 0) {\n        return \"[]\";\n      }\n      seen.push(input2);\n      const ret = \"[\" + tokens.newLine + input2.map((el, i) => {\n        const eol = input2.length - 1 === i ? tokens.newLine : \",\" + tokens.newLineOrSpace;\n        let value = stringifyObject2(el, options2, pad2 + options2.indent, [...path7, i]);\n        if (options2.transformValue) {\n          value = options2.transformValue(input2, i, value);\n        }\n        return tokens.indent + value + eol;\n      }).join(\"\") + tokens.pad + \"]\";\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n    if (isObj(input2)) {\n      let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));\n      if (options2.filter) {\n        objKeys = objKeys.filter((el) => options2.filter(input2, el));\n      }\n      if (objKeys.length === 0) {\n        return \"{}\";\n      }\n      seen.push(input2);\n      const ret = \"{\" + tokens.newLine + objKeys.map((el, i) => {\n        const eol = objKeys.length - 1 === i ? tokens.newLine : \",\" + tokens.newLineOrSpace;\n        const isSymbol = typeof el === \"symbol\";\n        const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);\n        const key = isSymbol || isClassic ? el : stringifyObject2(el, options2, void 0, [...path7, el]);\n        let value = stringifyObject2(input2[el], options2, pad2 + options2.indent, [...path7, el]);\n        if (options2.transformValue) {\n          value = options2.transformValue(input2, el, value);\n        }\n        let line = tokens.indent + String(key) + \": \" + value + eol;\n        if (options2.transformLine) {\n          line = options2.transformLine({\n            obj: input2,\n            indent: tokens.indent,\n            key,\n            stringifiedValue: value,\n            value: input2[el],\n            eol,\n            originalLine: line,\n            path: path7.concat(key)\n          });\n        }\n        return line;\n      }).join(\"\") + tokens.pad + \"}\";\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n    input2 = String(input2).replace(/[\\r\\n]/g, (x) => x === \"\\n\" ? \"\\\\n\" : \"\\\\r\");\n    if (options2.singleQuotes === false) {\n      input2 = input2.replace(/\"/g, '\\\\\"');\n      return `\"${input2}\"`;\n    }\n    input2 = input2.replace(/\\\\?'/g, \"\\\\'\");\n    return `'${input2}'`;\n  }, \"stringifyObject\"))(input, options, pad);\n}, \"stringifyObject\");\nvar stringifyObject_default = stringifyObject;\n\n// src/runtime/utils/printJsonErrors.ts\nvar DIM_TOKEN = \"@@__DIM_POINTER__@@\";\nfunction printJsonWithErrors({ ast, keyPaths, valuePaths, missingItems }) {\n  let obj = ast;\n  for (const { path: path7, type } of missingItems) {\n    obj = deepSet(obj, path7, type);\n  }\n  return stringifyObject_default(obj, {\n    indent: \"  \",\n    transformLine: ({ indent: indent4, key, value, stringifiedValue, eol, path: path7 }) => {\n      const dottedPath = path7.join(\".\");\n      const keyError = keyPaths.includes(dottedPath);\n      const valueError = valuePaths.includes(dottedPath);\n      const missingItem = missingItems.find((item) => item.path === dottedPath);\n      let valueStr = stringifiedValue;\n      if (missingItem) {\n        if (typeof value === \"string\") {\n          valueStr = valueStr.slice(1, valueStr.length - 1);\n        }\n        const isRequiredStr = missingItem.isRequired ? \"\" : \"?\";\n        const prefix = missingItem.isRequired ? \"+\" : \"?\";\n        const color = missingItem.isRequired ? import_chalk10.default.greenBright : import_chalk10.default.green;\n        let output = color(prefixLines(key + isRequiredStr + \": \" + valueStr + eol, indent4, prefix));\n        if (!missingItem.isRequired) {\n          output = import_chalk10.default.dim(output);\n        }\n        return output;\n      } else {\n        const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));\n        const isOptional = key[key.length - 2] === \"?\";\n        if (isOptional) {\n          key = key.slice(1, key.length - 1);\n        }\n        if (isOptional && typeof value === \"object\" && value !== null) {\n          valueStr = valueStr.split(\"\\n\").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join(\"\\n\");\n        }\n        if (isOnMissingItemPath && typeof value === \"string\") {\n          valueStr = valueStr.slice(1, valueStr.length - 1);\n          if (!isOptional) {\n            valueStr = import_chalk10.default.bold(valueStr);\n          }\n        }\n        if ((typeof value !== \"object\" || value === null) && !valueError && !isOnMissingItemPath) {\n          valueStr = import_chalk10.default.dim(valueStr);\n        }\n        const keyStr = keyError ? import_chalk10.default.redBright(key) : key;\n        valueStr = valueError ? import_chalk10.default.redBright(valueStr) : valueStr;\n        let output = indent4 + keyStr + \": \" + valueStr + (isOnMissingItemPath ? eol : import_chalk10.default.dim(eol));\n        if (keyError || valueError) {\n          const lines = output.split(\"\\n\");\n          const keyLength = String(key).length;\n          const keyScribbles = keyError ? import_chalk10.default.redBright(\"~\".repeat(keyLength)) : \" \".repeat(keyLength);\n          const valueLength = valueError ? getValueLength(indent4, key, value, stringifiedValue) : 0;\n          const hideValueScribbles = valueError && isRenderedAsObject(value);\n          const valueScribbles = valueError ? \"  \" + import_chalk10.default.redBright(\"~\".repeat(valueLength)) : \"\";\n          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {\n            lines.splice(1, 0, indent4 + keyScribbles + valueScribbles);\n          }\n          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {\n            lines.splice(lines.length - 1, 0, indent4.slice(0, indent4.length - 2) + valueScribbles);\n          }\n          output = lines.join(\"\\n\");\n        }\n        return output;\n      }\n    }\n  });\n}\n__name(printJsonWithErrors, \"printJsonWithErrors\");\nfunction getValueLength(indent4, key, value, stringifiedValue) {\n  if (value === null) {\n    return 4;\n  }\n  if (typeof value === \"string\") {\n    return value.length + 2;\n  }\n  if (isRenderedAsObject(value)) {\n    return Math.abs(getLongestLine(`${key}: ${(0, import_strip_ansi2.default)(stringifiedValue)}`) - indent4.length);\n  }\n  return String(value).length;\n}\n__name(getValueLength, \"getValueLength\");\nfunction isRenderedAsObject(value) {\n  return typeof value === \"object\" && value !== null && !(value instanceof ObjectEnumValue);\n}\n__name(isRenderedAsObject, \"isRenderedAsObject\");\nfunction getLongestLine(str) {\n  return str.split(\"\\n\").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);\n}\n__name(getLongestLine, \"getLongestLine\");\nfunction prefixLines(str, indent4, prefix) {\n  return str.split(\"\\n\").map(\n    (line, index, arr) => index === 0 ? prefix + indent4.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line\n  ).map((line) => {\n    return (0, import_strip_ansi2.default)(line).includes(DIM_TOKEN) ? import_chalk10.default.dim(line.replace(DIM_TOKEN, \"\")) : line.includes(\"?\") ? import_chalk10.default.dim(line) : line;\n  }).join(\"\\n\");\n}\n__name(prefixLines, \"prefixLines\");\n\n// src/runtime/query.ts\nvar tab = 2;\nvar Document = class {\n  constructor(type, children) {\n    this.type = type;\n    this.children = children;\n    this.printFieldError = /* @__PURE__ */ __name(({ error: error2 }, missingItems, minimal) => {\n      if (error2.type === \"emptySelect\") {\n        const additional = minimal ? \"\" : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        return `The ${import_chalk11.default.redBright(\"`select`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} must not be empty.${additional}`;\n      }\n      if (error2.type === \"emptyInclude\") {\n        if (missingItems.length === 0) {\n          return `${import_chalk11.default.bold(\n            getOutputTypeName(error2.field.outputType.type)\n          )} does not have any relation and therefore can't have an ${import_chalk11.default.redBright(\"`include`\")} statement.`;\n        }\n        const additional = minimal ? \"\" : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        return `The ${import_chalk11.default.redBright(\"`include`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} must not be empty.${additional}`;\n      }\n      if (error2.type === \"noTrueSelect\") {\n        return `The ${import_chalk11.default.redBright(\"`select`\")} statement for type ${import_chalk11.default.bold(\n          getOutputTypeName(error2.field.outputType.type)\n        )} needs ${import_chalk11.default.bold(\"at least one truthy value\")}.`;\n      }\n      if (error2.type === \"includeAndSelect\") {\n        return `Please ${import_chalk11.default.bold(\"either\")} use ${import_chalk11.default.greenBright(\"`include`\")} or ${import_chalk11.default.greenBright(\n          \"`select`\"\n        )}, but ${import_chalk11.default.redBright(\"not both\")} at the same time.`;\n      }\n      if (error2.type === \"invalidFieldName\") {\n        const statement = error2.isInclude ? \"include\" : \"select\";\n        const wording = error2.isIncludeScalar ? \"Invalid scalar\" : \"Unknown\";\n        const additional = minimal ? \"\" : error2.isInclude && missingItems.length === 0 ? `\nThis model has no relations, so you can't use ${import_chalk11.default.redBright(\"include\")} with it.` : ` Available options are listed in ${import_chalk11.default.greenBright.dim(\"green\")}.`;\n        let str = `${wording} field ${import_chalk11.default.redBright(`\\`${error2.providedName}\\``)} for ${import_chalk11.default.bold(\n          statement\n        )} statement on model ${import_chalk11.default.bold.white(error2.modelName)}.${additional}`;\n        if (error2.didYouMean) {\n          str += ` Did you mean ${import_chalk11.default.greenBright(`\\`${error2.didYouMean}\\``)}?`;\n        }\n        if (error2.isIncludeScalar) {\n          str += `\nNote, that ${import_chalk11.default.bold(\"include\")} statements only accept relation fields.`;\n        }\n        return str;\n      }\n      if (error2.type === \"invalidFieldType\") {\n        const str = `Invalid value ${import_chalk11.default.redBright(\n          `${stringifyObject_default(error2.providedValue)}`\n        )} of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue, void 0))} for field ${import_chalk11.default.bold(\n          `${error2.fieldName}`\n        )} on model ${import_chalk11.default.bold.white(error2.modelName)}. Expected either ${import_chalk11.default.greenBright(\n          \"true\"\n        )} or ${import_chalk11.default.greenBright(\"false\")}.`;\n        return str;\n      }\n      return void 0;\n    }, \"printFieldError\");\n    this.printArgError = /* @__PURE__ */ __name(({ error: error2, path: path7, id }, hasMissingItems, minimal) => {\n      if (error2.type === \"invalidName\") {\n        let str = `Unknown arg ${import_chalk11.default.redBright(`\\`${error2.providedName}\\``)} in ${import_chalk11.default.bold(\n          path7.join(\".\")\n        )} for type ${import_chalk11.default.bold(error2.outputType ? error2.outputType.name : getInputTypeName(error2.originalType))}.`;\n        if (error2.didYouMeanField) {\n          str += `\n\\u2192 Did you forget to wrap it with \\`${import_chalk11.default.greenBright(\"select\")}\\`? ${import_chalk11.default.dim(\n            \"e.g. \" + import_chalk11.default.greenBright(`{ select: { ${error2.providedName}: ${error2.providedValue} } }`)\n          )}`;\n        } else if (error2.didYouMeanArg) {\n          str += ` Did you mean \\`${import_chalk11.default.greenBright(error2.didYouMeanArg)}\\`?`;\n          if (!hasMissingItems && !minimal) {\n            str += ` ${import_chalk11.default.dim(\"Available args:\")}\n` + stringifyInputType(error2.originalType, true);\n          }\n        } else {\n          if (error2.originalType.fields.length === 0) {\n            str += ` The field ${import_chalk11.default.bold(error2.originalType.name)} has no arguments.`;\n          } else if (!hasMissingItems && !minimal) {\n            str += ` Available args:\n\n` + stringifyInputType(error2.originalType, true);\n          }\n        }\n        return str;\n      }\n      if (error2.type === \"invalidType\") {\n        let valueStr = stringifyObject_default(error2.providedValue, { indent: \"  \" });\n        const multilineValue = valueStr.split(\"\\n\").length > 1;\n        if (multilineValue) {\n          valueStr = `\n${valueStr}\n`;\n        }\n        if (error2.requiredType.bestFittingType.location === \"enumTypes\") {\n          return `Argument ${import_chalk11.default.bold(error2.argName)}: Provided value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? \"\" : \" \"}of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue))} on ${import_chalk11.default.bold(\n            `prisma.${this.children[0].name}`\n          )} is not a ${import_chalk11.default.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error2.requiredType.bestFittingType.type),\n              error2.requiredType.bestFittingType.isList\n            )\n          )}.\n\\u2192 Possible values: ${error2.requiredType.bestFittingType.type.values.map((v) => import_chalk11.default.greenBright(`${stringifyGraphQLType(error2.requiredType.bestFittingType.type)}.${v}`)).join(\", \")}`;\n        }\n        let typeStr = \".\";\n        if (isInputArgType(error2.requiredType.bestFittingType.type)) {\n          typeStr = \":\\n\" + stringifyInputType(error2.requiredType.bestFittingType.type);\n        }\n        let expected = `${error2.requiredType.inputType.map(\n          (t) => import_chalk11.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error2.requiredType.bestFittingType.isList))\n        ).join(\" or \")}${typeStr}`;\n        const inputType = error2.requiredType.inputType.length === 2 && error2.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;\n        if (inputType) {\n          expected += `\n` + stringifyInputType(inputType.type, true);\n        }\n        return `Argument ${import_chalk11.default.bold(error2.argName)}: Got invalid value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? \"\" : \" \"}on ${import_chalk11.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk11.default.redBright(\n          getGraphQLType(error2.providedValue)\n        )}, expected ${expected}`;\n      }\n      if (error2.type === \"invalidNullArg\") {\n        const forStr = path7.length === 1 && path7[0] === error2.name ? \"\" : ` for ${import_chalk11.default.bold(`${path7.join(\".\")}`)}`;\n        const undefinedTip = ` Please use ${import_chalk11.default.bold.greenBright(\"undefined\")} instead.`;\n        return `Argument ${import_chalk11.default.greenBright(error2.name)}${forStr} must not be ${import_chalk11.default.bold(\"null\")}.${undefinedTip}`;\n      }\n      if (error2.type === \"missingArg\") {\n        const forStr = path7.length === 1 && path7[0] === error2.missingName ? \"\" : ` for ${import_chalk11.default.bold(`${path7.join(\".\")}`)}`;\n        return `Argument ${import_chalk11.default.greenBright(error2.missingName)}${forStr} is missing.`;\n      }\n      if (error2.type === \"atLeastOne\") {\n        const additional = minimal ? \"\" : ` Available args are listed in ${import_chalk11.default.dim.green(\"green\")}.`;\n        return `Argument ${import_chalk11.default.bold(path7.join(\".\"))} of type ${import_chalk11.default.bold(\n          error2.inputType.name\n        )} needs ${import_chalk11.default.greenBright(\"at least one\")} argument.${additional}`;\n      }\n      if (error2.type === \"atMostOne\") {\n        const additional = minimal ? \"\" : ` Please choose one. ${import_chalk11.default.dim(\"Available args:\")} \n${stringifyInputType(error2.inputType, true)}`;\n        return `Argument ${import_chalk11.default.bold(path7.join(\".\"))} of type ${import_chalk11.default.bold(\n          error2.inputType.name\n        )} needs ${import_chalk11.default.greenBright(\"exactly one\")} argument, but you provided ${error2.providedKeys.map((key) => import_chalk11.default.redBright(key)).join(\" and \")}.${additional}`;\n      }\n      return void 0;\n    }, \"printArgError\");\n    this.type = type;\n    this.children = children;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Document\";\n  }\n  toString() {\n    return `${this.type} {\n${(0, import_indent_string4.default)(this.children.map(String).join(\"\\n\"), tab)}\n}`;\n  }\n  validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {\n    var _a3;\n    if (!select) {\n      select = {};\n    }\n    const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);\n    if (invalidChildren.length === 0) {\n      return;\n    }\n    const fieldErrors = [];\n    const argErrors = [];\n    const prefix = select && select.select ? \"select\" : select.include ? \"include\" : void 0;\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix);\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1)\n        }))\n      );\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1)\n        }))\n      );\n    }\n    const topLevelQueryName = this.children[0].name;\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName;\n    const keyPaths = [];\n    const valuePaths = [];\n    const missingItems = [];\n    for (const fieldError of fieldErrors) {\n      const path7 = this.normalizePath(fieldError.path, select).join(\".\");\n      if (fieldError.error.type === \"invalidFieldName\") {\n        keyPaths.push(path7);\n        const fieldType = fieldError.error.outputType;\n        const { isInclude } = fieldError.error;\n        fieldType.fields.filter((field) => isInclude ? field.outputType.location === \"outputObjectTypes\" : true).forEach((field) => {\n          const splittedPath = path7.split(\".\");\n          missingItems.push({\n            path: `${splittedPath.slice(0, splittedPath.length - 1).join(\".\")}.${field.name}`,\n            type: \"true\",\n            isRequired: false\n          });\n        });\n      } else if (fieldError.error.type === \"includeAndSelect\") {\n        keyPaths.push(\"select\");\n        keyPaths.push(\"include\");\n      } else {\n        valuePaths.push(path7);\n      }\n      if (fieldError.error.type === \"emptySelect\" || fieldError.error.type === \"noTrueSelect\" || fieldError.error.type === \"emptyInclude\") {\n        const selectPathArray = this.normalizePath(fieldError.path, select);\n        const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(\".\");\n        const fieldType = fieldError.error.field.outputType.type;\n        (_a3 = fieldType.fields) == null ? void 0 : _a3.filter(\n          (field) => fieldError.error.type === \"emptyInclude\" ? field.outputType.location === \"outputObjectTypes\" : true\n        ).forEach((field) => {\n          missingItems.push({\n            path: `${selectPath}.${field.name}`,\n            type: \"true\",\n            isRequired: false\n          });\n        });\n      }\n    }\n    for (const argError of argErrors) {\n      const path7 = this.normalizePath(argError.path, select).join(\".\");\n      if (argError.error.type === \"invalidName\") {\n        keyPaths.push(path7);\n      } else if (argError.error.type !== \"missingArg\" && argError.error.type !== \"atLeastOne\") {\n        valuePaths.push(path7);\n      } else if (argError.error.type === \"missingArg\") {\n        const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {\n          const inputTypeName = getInputTypeName(t.type);\n          if (inputTypeName === \"Null\") {\n            return \"null\";\n          }\n          if (t.isList) {\n            return inputTypeName + \"[]\";\n          }\n          return inputTypeName;\n        }).join(\" | \");\n        missingItems.push({\n          path: path7,\n          type: inputTypeToJson(type, true, path7.split(\"where.\").length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        });\n      }\n    }\n    const renderErrorStr = /* @__PURE__ */ __name((callsite) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) => e.error.type === \"missingArg\" && e.error.missingArg.isRequired\n      );\n      const hasOptionalMissingArgsErrors = Boolean(\n        argErrors.find((e) => e.error.type === \"missingArg\" && !e.error.missingArg.isRequired)\n      );\n      const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;\n      let missingArgsLegend = \"\";\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\n${import_chalk11.default.dim(\"Note: Lines with \")}${import_chalk11.default.reset.greenBright(\"+\")} ${import_chalk11.default.dim(\n          \"are required\"\n        )}`;\n      }\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = \"\\n\";\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += import_chalk11.default.dim(`, lines with ${import_chalk11.default.green(\"?\")} are optional`);\n        } else {\n          missingArgsLegend += import_chalk11.default.dim(`Note: Lines with ${import_chalk11.default.green(\"?\")} are optional`);\n        }\n        missingArgsLegend += import_chalk11.default.dim(\".\");\n      }\n      const relevantArgErrors = argErrors.filter((e) => e.error.type !== \"missingArg\" || e.error.missingArg.isRequired);\n      let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === \"minimal\")).join(\"\\n\");\n      errorMessages += `\n${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === \"minimal\")).join(\"\\n\")}`;\n      if (errorFormat === \"minimal\") {\n        return (0, import_strip_ansi3.default)(errorMessages);\n      }\n      let printJsonArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems\n      };\n      if (originalMethod == null ? void 0 : originalMethod.endsWith(\"aggregate\")) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);\n      }\n      const errorStr = createErrorMessageWithContext({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === \"pretty\",\n        callArguments: printJsonWithErrors(printJsonArgs),\n        message: `${errorMessages}${missingArgsLegend}\n`\n      });\n      if (process.env.NO_COLOR || errorFormat === \"colorless\") {\n        return (0, import_strip_ansi3.default)(errorStr);\n      }\n      return errorStr;\n    }, \"renderErrorStr\");\n    const error2 = new PrismaClientValidationError(renderErrorStr(validationCallsite));\n    if (true) {\n      Object.defineProperty(error2, \"render\", {\n        get: () => renderErrorStr,\n        enumerable: false\n      });\n    }\n    throw error2;\n  }\n  normalizePath(inputPath, select) {\n    const path7 = inputPath.slice();\n    const newPath = [];\n    let key;\n    let pointer = select;\n    while ((key = path7.shift()) !== void 0) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue;\n      }\n      if (key === \"select\") {\n        if (!pointer[key]) {\n          pointer = pointer.include;\n        } else {\n          pointer = pointer[key];\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key];\n      }\n      newPath.push(key);\n    }\n    return newPath;\n  }\n};\n__name(Document, \"Document\");\nvar PrismaClientValidationError = class extends Error {\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientValidationError\";\n  }\n};\n__name(PrismaClientValidationError, \"PrismaClientValidationError\");\nvar PrismaClientConstructorValidationError = class extends Error {\n  constructor(message) {\n    super(message + `\nRead more at https://pris.ly/d/client-constructor`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientConstructorValidationError\";\n  }\n};\n__name(PrismaClientConstructorValidationError, \"PrismaClientConstructorValidationError\");\nvar Field = class {\n  constructor({ name, args, children, error: error2, schemaField }) {\n    this.name = name;\n    this.args = args;\n    this.children = children;\n    this.error = error2;\n    this.schemaField = schemaField;\n    this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;\n    this.hasInvalidArg = args ? args.hasInvalidArg : false;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Field\";\n  }\n  toString() {\n    let str = this.name;\n    if (this.error) {\n      return str + \" # INVALID_FIELD\";\n    }\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`;\n      } else {\n        str += `(\n${(0, import_indent_string4.default)(this.args.toString(), tab)}\n)`;\n      }\n    }\n    if (this.children) {\n      str += ` {\n${(0, import_indent_string4.default)(this.children.map(String).join(\"\\n\"), tab)}\n}`;\n    }\n    return str;\n  }\n  collectErrors(prefix = \"select\") {\n    const fieldErrors = [];\n    const argErrors = [];\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error\n      });\n    }\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix);\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path]\n          }))\n        );\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path]\n          }))\n        );\n      }\n    }\n    if (this.args) {\n      argErrors.push(...this.args.collectErrors().map((e) => ({ ...e, path: [this.name, ...e.path] })));\n    }\n    return {\n      fieldErrors,\n      argErrors\n    };\n  }\n};\n__name(Field, \"Field\");\nvar Args = class {\n  constructor(args = []) {\n    this.args = args;\n    this.hasInvalidArg = args ? args.some((arg2) => Boolean(arg2.hasError)) : false;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Args\";\n  }\n  toString() {\n    if (this.args.length === 0) {\n      return \"\";\n    }\n    return `${this.args.map((arg2) => arg2.toString()).filter((a) => a).join(\"\\n\")}`;\n  }\n  collectErrors() {\n    if (!this.hasInvalidArg) {\n      return [];\n    }\n    return flatMap(this.args, (arg2) => arg2.collectErrors());\n  }\n};\n__name(Args, \"Args\");\nfunction stringify(value, inputType) {\n  if (Buffer.isBuffer(value)) {\n    return JSON.stringify(value.toString(\"base64\"));\n  }\n  if (value instanceof FieldRefImpl) {\n    return `{ _ref: ${JSON.stringify(value.name)}}`;\n  }\n  if (Object.prototype.toString.call(value) === \"[object BigInt]\") {\n    return value.toString();\n  }\n  if (typeof (inputType == null ? void 0 : inputType.type) === \"string\" && inputType.type === \"Json\") {\n    if (value === null) {\n      return \"null\";\n    }\n    if (value && value.values && value.__prismaRawParamaters__) {\n      return JSON.stringify(value.values);\n    }\n    if ((inputType == null ? void 0 : inputType.isList) && Array.isArray(value)) {\n      return JSON.stringify(value.map((o) => JSON.stringify(o)));\n    }\n    return JSON.stringify(JSON.stringify(value));\n  }\n  if (value === void 0) {\n    return null;\n  }\n  if (value === null) {\n    return \"null\";\n  }\n  if (decimal_default.isDecimal(value) || (inputType == null ? void 0 : inputType.type) === \"Decimal\" && isDecimalJsLike(value)) {\n    return stringifyDecimalJsLike(value);\n  }\n  if ((inputType == null ? void 0 : inputType.location) === \"enumTypes\" && typeof value === \"string\") {\n    if (Array.isArray(value)) {\n      return `[${value.join(\", \")}]`;\n    }\n    return value;\n  }\n  return JSON.stringify(value, null, 2);\n}\n__name(stringify, \"stringify\");\nvar Arg2 = class {\n  constructor({ key, value, isEnum = false, error: error2, schemaArg, inputType }) {\n    this.inputType = inputType;\n    this.key = key;\n    this.value = value instanceof ObjectEnumValue ? value._getName() : value;\n    this.isEnum = isEnum;\n    this.error = error2;\n    this.schemaArg = schemaArg;\n    this.isNullable = (schemaArg == null ? void 0 : schemaArg.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true)) || false;\n    this.hasError = Boolean(error2) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);\n  }\n  get [Symbol.toStringTag]() {\n    return \"Arg\";\n  }\n  _toString(value, key) {\n    var _a3;\n    if (typeof value === \"undefined\") {\n      return void 0;\n    }\n    if (value instanceof Args) {\n      return `${key}: {\n${(0, import_indent_string4.default)(value.toString(), 2)}\n}`;\n    }\n    if (Array.isArray(value)) {\n      if (((_a3 = this.inputType) == null ? void 0 : _a3.type) === \"Json\") {\n        return `${key}: ${stringify(value, this.inputType)}`;\n      }\n      const isScalar = !value.some((v) => typeof v === \"object\");\n      return `${key}: [${isScalar ? \"\" : \"\\n\"}${(0, import_indent_string4.default)(\n        value.map((nestedValue) => {\n          if (nestedValue instanceof Args) {\n            return `{\n${(0, import_indent_string4.default)(nestedValue.toString(), tab)}\n}`;\n          }\n          return stringify(nestedValue, this.inputType);\n        }).join(`,${isScalar ? \" \" : \"\\n\"}`),\n        isScalar ? 0 : tab\n      )}${isScalar ? \"\" : \"\\n\"}]`;\n    }\n    return `${key}: ${stringify(value, this.inputType)}`;\n  }\n  toString() {\n    return this._toString(this.value, this.key);\n  }\n  collectErrors() {\n    var _a3;\n    if (!this.hasError) {\n      return [];\n    }\n    const errors = [];\n    if (this.error) {\n      const id = typeof ((_a3 = this.inputType) == null ? void 0 : _a3.type) === \"object\" ? `${this.inputType.type.name}${this.inputType.isList ? \"[]\" : \"\"}` : void 0;\n      errors.push({\n        error: this.error,\n        path: [this.key],\n        id\n      });\n    }\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...flatMap(this.value, (val, index) => {\n          if (!(val == null ? void 0 : val.collectErrors)) {\n            return [];\n          }\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] };\n          });\n        })\n      );\n    }\n    if (this.value instanceof Args) {\n      errors.push(...this.value.collectErrors().map((e) => ({ ...e, path: [this.key, ...e.path] })));\n    }\n    return errors;\n  }\n};\n__name(Arg2, \"Arg\");\nfunction makeDocument({ dmmf, rootTypeName, rootField, select, modelName }) {\n  if (!select) {\n    select = {};\n  }\n  const rootType = rootTypeName === \"query\" ? dmmf.queryType : dmmf.mutationType;\n  const fakeRootField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      location: \"outputObjectTypes\"\n    },\n    name: rootTypeName\n  };\n  const context3 = {\n    modelName\n  };\n  const children = selectionToFields(dmmf, { [rootField]: select }, fakeRootField, [rootTypeName], context3);\n  return new Document(rootTypeName, children);\n}\n__name(makeDocument, \"makeDocument\");\nfunction transformDocument(document2) {\n  return document2;\n}\n__name(transformDocument, \"transformDocument\");\nfunction selectionToFields(dmmf, selection, schemaField, path7, context3) {\n  const outputType = schemaField.outputType.type;\n  return Object.entries(selection).reduce((acc, [name, value]) => {\n    const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);\n    if (!field) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: \"invalidFieldName\",\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name)\n            ),\n            outputType\n          }\n        })\n      );\n      return acc;\n    }\n    if (field.outputType.location === \"scalar\" && field.args.length === 0 && typeof value !== \"boolean\") {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: \"invalidFieldType\",\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value\n          }\n        })\n      );\n      return acc;\n    }\n    if (value === false) {\n      return acc;\n    }\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    };\n    const argsWithoutIncludeAndSelect = typeof value === \"object\" ? omit2(value, [\"include\", \"select\"]) : void 0;\n    const args = argsWithoutIncludeAndSelect ? objectToArgs(\n      argsWithoutIncludeAndSelect,\n      transformedField,\n      context3,\n      [],\n      typeof field === \"string\" ? void 0 : field.outputType.type\n    ) : void 0;\n    const isRelation = field.outputType.location === \"outputObjectTypes\";\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: \"include\",\n                args: new Args(),\n                error: {\n                  type: \"includeAndSelect\",\n                  field\n                }\n              })\n            ]\n          })\n        );\n      } else if (value.include) {\n        const keys2 = Object.keys(value.include);\n        if (keys2.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"include\",\n                  args: new Args(),\n                  error: {\n                    type: \"emptyInclude\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n        if (field.outputType.location === \"outputObjectTypes\") {\n          const fieldOutputType = field.outputType.type;\n          const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === \"outputObjectTypes\").map((f) => f.name);\n          const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) => new Field({\n                  name: invalidKey,\n                  children: [\n                    new Field({\n                      name: invalidKey,\n                      args: new Args(),\n                      error: {\n                        type: \"invalidFieldName\",\n                        modelName: fieldOutputType.name,\n                        outputType: fieldOutputType,\n                        providedName: invalidKey,\n                        didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,\n                        isInclude: true,\n                        isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)\n                      }\n                    })\n                  ]\n                })\n              )\n            );\n            return acc;\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select);\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"select\",\n                  args: new Args(),\n                  error: {\n                    type: \"emptySelect\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n        const truthyValues = values.filter((v) => v);\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: \"select\",\n                  args: new Args(),\n                  error: {\n                    type: \"noTrueSelect\",\n                    field\n                  }\n                })\n              ]\n            })\n          );\n          return acc;\n        }\n      }\n    }\n    const defaultSelection = isRelation ? getDefaultSelection(dmmf, field.outputType.type) : null;\n    let select = defaultSelection;\n    if (value) {\n      if (value.select) {\n        select = value.select;\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include);\n      } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === \"prisma\" && field.outputType.location === \"outputObjectTypes\" && isGroupByOutputName(field.outputType.type.name)) {\n        select = byToSelect(value.by);\n      }\n    }\n    const children = select !== false && isRelation ? selectionToFields(dmmf, select, field, [...path7, name], context3) : void 0;\n    acc.push(new Field({ name, args, children, schemaField: field }));\n    return acc;\n  }, []);\n}\n__name(selectionToFields, \"selectionToFields\");\nfunction byToSelect(by) {\n  const obj = /* @__PURE__ */ Object.create(null);\n  for (const b of by) {\n    obj[b] = true;\n  }\n  return obj;\n}\n__name(byToSelect, \"byToSelect\");\nfunction getDefaultSelection(dmmf, outputType) {\n  const acc = /* @__PURE__ */ Object.create(null);\n  for (const f of outputType.fields) {\n    if (dmmf.typeMap[f.outputType.type.name] !== void 0) {\n      acc[f.name] = true;\n    }\n    if (f.outputType.location === \"scalar\" || f.outputType.location === \"enumTypes\") {\n      acc[f.name] = true;\n    }\n  }\n  return acc;\n}\n__name(getDefaultSelection, \"getDefaultSelection\");\nfunction getInvalidTypeArg(key, value, arg2, bestFittingType) {\n  const arrg = new Arg2({\n    key,\n    value,\n    isEnum: bestFittingType.location === \"enumTypes\",\n    inputType: bestFittingType,\n    error: {\n      type: \"invalidType\",\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg2.inputTypes,\n        bestFittingType\n      }\n    }\n  });\n  return arrg;\n}\n__name(getInvalidTypeArg, \"getInvalidTypeArg\");\nfunction hasCorrectScalarType(value, inputType, context3) {\n  const { isList } = inputType;\n  const expectedType = getExpectedType(inputType, context3);\n  const graphQLType = getGraphQLType(value, inputType);\n  if (graphQLType === expectedType) {\n    return true;\n  }\n  if (isList && graphQLType === \"List<>\") {\n    return true;\n  }\n  if (expectedType === \"Json\" && graphQLType !== \"Symbol\" && !(value instanceof ObjectEnumValue) && !(value instanceof FieldRefImpl)) {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"BigInt\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if (graphQLType === \"List<BigInt | Int>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int | BigInt>\" && expectedType === \"List<BigInt>\") {\n    return true;\n  }\n  if ((graphQLType === \"Int\" || graphQLType === \"Float\") && expectedType === \"Decimal\") {\n    return true;\n  }\n  if (isValidDecimalListInput(graphQLType, value) && expectedType === \"List<Decimal>\") {\n    return true;\n  }\n  if (graphQLType === \"DateTime\" && expectedType === \"String\") {\n    return true;\n  }\n  if (graphQLType === \"List<DateTime>\" && expectedType === \"List<String>\") {\n    return true;\n  }\n  if (graphQLType === \"UUID\" && expectedType === \"String\") {\n    return true;\n  }\n  if (graphQLType === \"List<UUID>\" && expectedType === \"List<String>\") {\n    return true;\n  }\n  if (graphQLType === \"String\" && expectedType === \"ID\") {\n    return true;\n  }\n  if (graphQLType === \"List<String>\" && expectedType === \"List<ID>\") {\n    return true;\n  }\n  if (graphQLType === \"List<String>\" && expectedType === \"List<Json>\") {\n    return true;\n  }\n  if (expectedType === \"List<String>\" && (graphQLType === \"List<String | UUID>\" || graphQLType === \"List<UUID | String>\")) {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"Float\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<Float>\") {\n    return true;\n  }\n  if (graphQLType === \"Int\" && expectedType === \"Long\") {\n    return true;\n  }\n  if (graphQLType === \"List<Int>\" && expectedType === \"List<Long>\") {\n    return true;\n  }\n  if (graphQLType === \"String\" && expectedType === \"Decimal\" && isDecimalString(value)) {\n    return true;\n  }\n  if (value === null) {\n    return true;\n  }\n  return false;\n}\n__name(hasCorrectScalarType, \"hasCorrectScalarType\");\nfunction getExpectedType(inputType, context3, isList = inputType.isList) {\n  let type = stringifyGraphQLType(inputType.type);\n  if (inputType.location === \"fieldRefTypes\" && context3.modelName) {\n    type += `<${context3.modelName}>`;\n  }\n  return wrapWithList(type, isList);\n}\n__name(getExpectedType, \"getExpectedType\");\nvar cleanObject = /* @__PURE__ */ __name((obj) => filterObject(obj, (k, v) => v !== void 0), \"cleanObject\");\nfunction isValidDecimalListInput(graphQLType, value) {\n  return graphQLType === \"List<Int>\" || graphQLType === \"List<Float>\" || graphQLType === \"List<String>\" && value.every(isDecimalString);\n}\n__name(isValidDecimalListInput, \"isValidDecimalListInput\");\nfunction isDecimalString(value) {\n  return /^\\-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value);\n}\n__name(isDecimalString, \"isDecimalString\");\nfunction valueToArg(key, value, arg2, context3) {\n  let maybeArg = null;\n  const argsWithErrors = [];\n  for (const inputType of arg2.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg2, inputType, context3);\n    if ((maybeArg == null ? void 0 : maybeArg.collectErrors().length) === 0) {\n      return maybeArg;\n    }\n    if (maybeArg && (maybeArg == null ? void 0 : maybeArg.collectErrors())) {\n      const argErrors = maybeArg == null ? void 0 : maybeArg.collectErrors();\n      if (argErrors && argErrors.length > 0) {\n        argsWithErrors.push({ arg: maybeArg, errors: argErrors });\n      }\n    }\n  }\n  if ((maybeArg == null ? void 0 : maybeArg.hasError) && argsWithErrors.length > 0) {\n    const argsWithScores = argsWithErrors.map(({ arg: arg3, errors }) => {\n      const errorScores = errors.map((e) => {\n        let score = 1;\n        if (e.error.type === \"invalidType\") {\n          score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;\n        }\n        score += Math.log(e.path.length);\n        if (e.error.type === \"missingArg\") {\n          if (arg3.inputType && isInputArgType(arg3.inputType.type) && arg3.inputType.type.name.includes(\"Unchecked\")) {\n            score *= 2;\n          }\n        }\n        if (e.error.type === \"invalidName\") {\n          if (isInputArgType(e.error.originalType)) {\n            if (e.error.originalType.name.includes(\"Unchecked\")) {\n              score *= 2;\n            }\n          }\n        }\n        return score;\n      });\n      return {\n        score: errors.length + sum2(errorScores),\n        arg: arg3,\n        errors\n      };\n    });\n    argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);\n    return argsWithScores[0].arg;\n  }\n  return maybeArg;\n}\n__name(valueToArg, \"valueToArg\");\nfunction getDepth(object) {\n  let level = 1;\n  if (!object || typeof object !== \"object\") {\n    return level;\n  }\n  for (const key in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, key)) {\n      continue;\n    }\n    if (typeof object[key] === \"object\") {\n      const depth = getDepth(object[key]) + 1;\n      level = Math.max(depth, level);\n    }\n  }\n  return level;\n}\n__name(getDepth, \"getDepth\");\nfunction sum2(n) {\n  return n.reduce((acc, curr) => acc + curr, 0);\n}\n__name(sum2, \"sum\");\nfunction tryInferArgs(key, value, arg2, inputType, context3) {\n  var _a3, _b2, _c, _d;\n  if (typeof value === \"undefined\") {\n    if (!arg2.isRequired) {\n      return null;\n    }\n    return new Arg2({\n      key,\n      value,\n      isEnum: inputType.location === \"enumTypes\",\n      inputType,\n      error: {\n        type: \"missingArg\",\n        missingName: key,\n        missingArg: arg2,\n        atLeastOne: false,\n        atMostOne: false\n      }\n    });\n  }\n  const { isNullable, isRequired } = arg2;\n  if (value === null && !isNullable && !isRequired) {\n    const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;\n    if (!isAtLeastOne) {\n      return new Arg2({\n        key,\n        value,\n        isEnum: inputType.location === \"enumTypes\",\n        inputType,\n        error: {\n          type: \"invalidNullArg\",\n          name: key,\n          invalidType: arg2.inputTypes,\n          atLeastOne: false,\n          atMostOne: false\n        }\n      });\n    }\n  }\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== \"object\" || Array.isArray(value) || inputType.location === \"inputObjectTypes\" && !isObject2(value)) {\n        return getInvalidTypeArg(key, value, arg2, inputType);\n      } else {\n        const val = cleanObject(value);\n        let error2;\n        const keys2 = Object.keys(val || {});\n        const numKeys = keys2.length;\n        if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === \"number\" && inputType.type.constraints.minNumFields > 0) {\n          error2 = {\n            type: \"atLeastOne\",\n            key,\n            inputType: inputType.type\n          };\n        } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === \"number\" && inputType.type.constraints.maxNumFields < 2) {\n          error2 = {\n            type: \"atMostOne\",\n            key,\n            inputType: inputType.type,\n            providedKeys: keys2\n          };\n        }\n        return new Arg2({\n          key,\n          value: val === null ? null : objectToArgs(val, inputType.type, context3, arg2.inputTypes),\n          isEnum: inputType.location === \"enumTypes\",\n          error: error2,\n          inputType,\n          schemaArg: arg2\n        });\n      }\n    } else {\n      return scalarToArg(key, value, arg2, inputType, context3);\n    }\n  }\n  if (!Array.isArray(value) && inputType.isList) {\n    if (key !== \"updateMany\") {\n      value = [value];\n    }\n  }\n  if (inputType.location === \"enumTypes\" || inputType.location === \"scalar\") {\n    return scalarToArg(key, value, arg2, inputType, context3);\n  }\n  const argInputType = inputType.type;\n  const hasAtLeastOneError = typeof ((_a3 = argInputType.constraints) == null ? void 0 : _a3.minNumFields) === \"number\" && ((_b2 = argInputType.constraints) == null ? void 0 : _b2.minNumFields) > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;\n  let err = hasAtLeastOneError ? {\n    inputType: argInputType,\n    key,\n    type: \"atLeastOne\"\n  } : void 0;\n  if (!err) {\n    const hasOneOfError = typeof ((_c = argInputType.constraints) == null ? void 0 : _c.maxNumFields) === \"number\" && ((_d = argInputType.constraints) == null ? void 0 : _d.maxNumFields) < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: \"atMostOne\",\n        providedKeys: Object.keys(hasOneOfError)\n      };\n    }\n  }\n  if (!Array.isArray(value)) {\n    for (const nestedArgInputType of arg2.inputTypes) {\n      const args = objectToArgs(value, nestedArgInputType.type, context3);\n      if (args.collectErrors().length === 0) {\n        return new Arg2({\n          key,\n          value: args,\n          isEnum: false,\n          schemaArg: arg2,\n          inputType: nestedArgInputType\n        });\n      }\n    }\n  }\n  return new Arg2({\n    key,\n    value: value.map((v) => {\n      if (inputType.isList && typeof v !== \"object\") {\n        return v;\n      }\n      if (typeof v !== \"object\" || !value) {\n        return getInvalidTypeArg(key, v, arg2, inputType);\n      }\n      return objectToArgs(v, argInputType, context3);\n    }),\n    isEnum: false,\n    inputType,\n    schemaArg: arg2,\n    error: err\n  });\n}\n__name(tryInferArgs, \"tryInferArgs\");\nfunction isInputArgType(argType) {\n  if (typeof argType === \"string\") {\n    return false;\n  }\n  if (Object.hasOwnProperty.call(argType, \"values\")) {\n    return false;\n  }\n  return true;\n}\n__name(isInputArgType, \"isInputArgType\");\nfunction scalarToArg(key, value, arg2, inputType, context3) {\n  if (hasCorrectScalarType(value, inputType, context3)) {\n    return new Arg2({\n      key,\n      value,\n      isEnum: inputType.location === \"enumTypes\",\n      schemaArg: arg2,\n      inputType\n    });\n  }\n  return getInvalidTypeArg(key, value, arg2, inputType);\n}\n__name(scalarToArg, \"scalarToArg\");\nfunction objectToArgs(initialObj, inputType, context3, possibilities, outputType) {\n  var _a3;\n  if ((_a3 = inputType.meta) == null ? void 0 : _a3.source) {\n    context3 = { modelName: inputType.meta.source };\n  }\n  const obj = cleanObject(initialObj);\n  const { fields: args, fieldMap } = inputType;\n  const requiredArgs = args.map((arg2) => [arg2.name, void 0]);\n  const objEntries = Object.entries(obj || {});\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0]);\n  const argsList = entries.reduce((acc, [argName, value]) => {\n    const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);\n    if (!schemaArg) {\n      const didYouMeanField = typeof value === \"boolean\" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;\n      acc.push(\n        new Arg2({\n          key: argName,\n          value,\n          error: {\n            type: \"invalidName\",\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg: !didYouMeanField && getSuggestion(argName, [...args.map((a) => a.name), \"select\"]) || void 0,\n            originalType: inputType,\n            possibilities,\n            outputType\n          }\n        })\n      );\n      return acc;\n    }\n    const arg2 = valueToArg(argName, value, schemaArg, context3);\n    if (arg2) {\n      acc.push(arg2);\n    }\n    return acc;\n  }, []);\n  if (typeof inputType.constraints.minNumFields === \"number\" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg2) => {\n    var _a4, _b2;\n    return ((_a4 = arg2.error) == null ? void 0 : _a4.type) === \"missingArg\" || ((_b2 = arg2.error) == null ? void 0 : _b2.type) === \"atLeastOne\";\n  })) {\n    const optionalMissingArgs = inputType.fields.filter(\n      (field) => !field.isRequired && obj && (typeof obj[field.name] === \"undefined\" || obj[field.name] === null)\n    );\n    argsList.push(\n      ...optionalMissingArgs.map((arg2) => {\n        const argInputType = arg2.inputTypes[0];\n        return new Arg2({\n          key: arg2.name,\n          value: void 0,\n          isEnum: argInputType.location === \"enumTypes\",\n          error: {\n            type: \"missingArg\",\n            missingName: arg2.name,\n            missingArg: arg2,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false\n          },\n          inputType: argInputType\n        });\n      })\n    );\n  }\n  return new Args(argsList);\n}\n__name(objectToArgs, \"objectToArgs\");\nfunction unpack({ document: document2, path: path7, data }) {\n  const result = deepGet(data, path7);\n  if (result === \"undefined\") {\n    return null;\n  }\n  if (typeof result !== \"object\") {\n    return result;\n  }\n  const field = getField(document2, path7);\n  return mapScalars({ field, data: result });\n}\n__name(unpack, \"unpack\");\nfunction mapScalars({ field, data }) {\n  var _a3;\n  if (!data || typeof data !== \"object\" || !field.children || !field.schemaField) {\n    return data;\n  }\n  const deserializers = {\n    DateTime: (value) => new Date(value),\n    Json: (value) => JSON.parse(value),\n    Bytes: (value) => Buffer.from(value, \"base64\"),\n    Decimal: (value) => {\n      return new decimal_default(value);\n    },\n    BigInt: (value) => BigInt(value)\n  };\n  for (const child of field.children) {\n    const outputType = (_a3 = child.schemaField) == null ? void 0 : _a3.outputType.type;\n    if (outputType && typeof outputType === \"string\") {\n      const deserializer = deserializers[outputType];\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            if (typeof entry[child.name] !== \"undefined\" && entry[child.name] !== null) {\n              if (Array.isArray(entry[child.name])) {\n                entry[child.name] = entry[child.name].map(deserializer);\n              } else {\n                entry[child.name] = deserializer(entry[child.name]);\n              }\n            }\n          }\n        } else {\n          if (typeof data[child.name] !== \"undefined\" && data[child.name] !== null) {\n            if (Array.isArray(data[child.name])) {\n              data[child.name] = data[child.name].map(deserializer);\n            } else {\n              data[child.name] = deserializer(data[child.name]);\n            }\n          }\n        }\n      }\n    }\n    if (child.schemaField && child.schemaField.outputType.location === \"outputObjectTypes\") {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] });\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] });\n      }\n    }\n  }\n  return data;\n}\n__name(mapScalars, \"mapScalars\");\nfunction getField(document2, path7) {\n  const todo = path7.slice();\n  const firstElement = todo.shift();\n  let pointer = document2.children.find((c) => c.name === firstElement);\n  if (!pointer) {\n    throw new Error(`Could not find field ${firstElement} in document ${document2}`);\n  }\n  while (todo.length > 0) {\n    const key = todo.shift();\n    if (!pointer.children) {\n      throw new Error(`Can't get children for field ${pointer} with child ${key}`);\n    }\n    const child = pointer.children.find((c) => c.name === key);\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`);\n    }\n    pointer = child;\n  }\n  return pointer;\n}\n__name(getField, \"getField\");\nfunction removeSelectFromPath(path7) {\n  return path7.split(\".\").filter((p) => p !== \"select\").join(\".\");\n}\n__name(removeSelectFromPath, \"removeSelectFromPath\");\nfunction removeSelectFromObject(obj) {\n  const type = Object.prototype.toString.call(obj);\n  if (type === \"[object Object]\") {\n    const copy = {};\n    for (const key in obj) {\n      if (key === \"select\") {\n        for (const subKey in obj[\"select\"]) {\n          copy[subKey] = removeSelectFromObject(obj[\"select\"][subKey]);\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key]);\n      }\n    }\n    return copy;\n  }\n  return obj;\n}\n__name(removeSelectFromObject, \"removeSelectFromObject\");\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths\n}) {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath);\n  const newValuePaths = valuePaths.map(removeSelectFromPath);\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type\n  }));\n  const newAst = removeSelectFromObject(ast);\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths\n  };\n}\n__name(transformAggregatePrintJsonArgs, \"transformAggregatePrintJsonArgs\");\n\n// src/runtime/utils/rejectOnNotFound.ts\nvar NotFoundError2 = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n};\n__name(NotFoundError2, \"NotFoundError\");\nfunction getRejectOnNotFound(action, modelName, args, clientInstance) {\n  let rejectOnNotFound;\n  if (args && typeof args === \"object\" && \"rejectOnNotFound\" in args && args[\"rejectOnNotFound\"] !== void 0) {\n    rejectOnNotFound = args[\"rejectOnNotFound\"];\n    delete args[\"rejectOnNotFound\"];\n  } else if (typeof clientInstance === \"boolean\") {\n    rejectOnNotFound = clientInstance;\n  } else if (clientInstance && typeof clientInstance === \"object\" && action in clientInstance) {\n    const rejectPerOperation = clientInstance[action];\n    if (rejectPerOperation && typeof rejectPerOperation === \"object\") {\n      if (modelName in rejectPerOperation) {\n        return rejectPerOperation[modelName];\n      }\n      return void 0;\n    }\n    rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);\n  } else if (typeof clientInstance === \"function\") {\n    rejectOnNotFound = clientInstance;\n  } else {\n    rejectOnNotFound = false;\n  }\n  return rejectOnNotFound;\n}\n__name(getRejectOnNotFound, \"getRejectOnNotFound\");\nvar REGEX = /(findUnique|findFirst)/;\nfunction throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {\n  if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {\n    if (typeof rejectOnNotFound === \"boolean\" && rejectOnNotFound) {\n      throw new NotFoundError2(`No ${typeName} found`);\n    } else if (typeof rejectOnNotFound === \"function\") {\n      throw rejectOnNotFound(new NotFoundError2(`No ${typeName} found`));\n    } else if (isError(rejectOnNotFound)) {\n      throw rejectOnNotFound;\n    }\n    throw new NotFoundError2(`No ${typeName} found`);\n  }\n}\n__name(throwIfNotFound, \"throwIfNotFound\");\n\n// src/runtime/core/model/applyClientOnlyWrapper.ts\nfunction wrapRequest(prop, dmmfModelName, requestCallback) {\n  if (prop === \"findFirstOrThrow\" || prop === \"findUniqueOrThrow\") {\n    return applyOrThrowWrapper(dmmfModelName, requestCallback);\n  }\n  assertNever(prop, \"Unknown wrapper name\");\n}\n__name(wrapRequest, \"wrapRequest\");\nfunction applyOrThrowWrapper(dmmfModelName, requestCallback) {\n  return async (requestParams) => {\n    if (\"rejectOnNotFound\" in requestParams.args) {\n      const message = createErrorMessageWithContext({\n        originalMethod: requestParams.clientMethod,\n        callsite: requestParams.callsite,\n        message: \"'rejectOnNotFound' option is not supported\"\n      });\n      throw new PrismaClientValidationError(message);\n    }\n    const result = await requestCallback(requestParams);\n    if (result === null || result === void 0) {\n      throw new NotFoundError2(`No ${dmmfModelName} found`);\n    }\n    return result;\n  };\n}\n__name(applyOrThrowWrapper, \"applyOrThrowWrapper\");\n\n// src/runtime/core/model/utils/defaultProxyHandlers.ts\nvar defaultPropertyDescriptor = {\n  enumerable: true,\n  configurable: true,\n  writable: true\n};\nfunction defaultProxyHandlers(ownKeys) {\n  const _ownKeys = new Set(ownKeys);\n  return {\n    getOwnPropertyDescriptor: () => defaultPropertyDescriptor,\n    has: (target, prop) => _ownKeys.has(prop),\n    set: (target, prop, value) => {\n      return _ownKeys.add(prop) && Reflect.set(target, prop, value);\n    },\n    ownKeys: () => [..._ownKeys]\n  };\n}\n__name(defaultProxyHandlers, \"defaultProxyHandlers\");\n\n// src/runtime/core/model/applyFieldsProxy.ts\nfunction applyFieldsProxy(model) {\n  const scalarFieldsList = model.fields.filter((field) => !field.relationName);\n  const scalarFields = keyBy2(scalarFieldsList, (field) => field.name);\n  return new Proxy(\n    {},\n    {\n      get(target, prop) {\n        if (prop in target || typeof prop === \"symbol\") {\n          return target[prop];\n        }\n        const dmmfField = scalarFields[prop];\n        if (dmmfField) {\n          return new FieldRefImpl(model.name, prop, dmmfField.type, dmmfField.isList);\n        }\n        return void 0;\n      },\n      ...defaultProxyHandlers(Object.keys(scalarFields))\n    }\n  );\n}\n__name(applyFieldsProxy, \"applyFieldsProxy\");\n\n// src/runtime/core/model/applyFluent.ts\nfunction getNextDataPath(fluentPropName, prevDataPath) {\n  if (fluentPropName === void 0 || prevDataPath === void 0)\n    return [];\n  return [...prevDataPath, \"select\", fluentPropName];\n}\n__name(getNextDataPath, \"getNextDataPath\");\nfunction getNextUserArgs(callArgs, prevArgs, nextDataPath) {\n  if (prevArgs === void 0)\n    return callArgs != null ? callArgs : {};\n  return deepSet(prevArgs, nextDataPath, callArgs || true);\n}\n__name(getNextUserArgs, \"getNextUserArgs\");\nfunction applyFluent(client, dmmfModelName, modelAction, fluentPropName, prevDataPath, prevUserArgs) {\n  const dmmfModel = client._baseDmmf.modelMap[dmmfModelName];\n  const dmmfModelFieldMap = dmmfModel.fields.reduce(\n    (acc, field) => ({ ...acc, [field.name]: field }),\n    {}\n  );\n  return (userArgs) => {\n    const callsite = getCallSite(client._errorFormat);\n    const nextDataPath = getNextDataPath(fluentPropName, prevDataPath);\n    const nextUserArgs = getNextUserArgs(userArgs, prevUserArgs, nextDataPath);\n    const prismaPromise = modelAction({ dataPath: nextDataPath, callsite })(nextUserArgs);\n    const ownKeys = getOwnKeys(client, dmmfModelName);\n    return new Proxy(prismaPromise, {\n      get(target, prop) {\n        if (!ownKeys.includes(prop))\n          return target[prop];\n        const dmmfModelName2 = dmmfModelFieldMap[prop].type;\n        const modelArgs = [dmmfModelName2, modelAction, prop];\n        const dataArgs = [nextDataPath, nextUserArgs];\n        return applyFluent(client, ...modelArgs, ...dataArgs);\n      },\n      ...defaultProxyHandlers([...ownKeys, ...Object.getOwnPropertyNames(prismaPromise)])\n    });\n  };\n}\n__name(applyFluent, \"applyFluent\");\nfunction getOwnKeys(client, dmmfModelName) {\n  return client._baseDmmf.modelMap[dmmfModelName].fields.filter((field) => field.kind === \"object\").map((field) => field.name);\n}\n__name(getOwnKeys, \"getOwnKeys\");\n\n// src/runtime/core/model/utils/dmmfToJSModelName.ts\nfunction dmmfToJSModelName(name) {\n  return name.replace(/^./, (str) => str.toLowerCase());\n}\n__name(dmmfToJSModelName, \"dmmfToJSModelName\");\n\n// src/runtime/core/model/applyModel.ts\nvar fluentProps = [\"findUnique\", \"findFirst\", \"create\", \"update\", \"upsert\", \"delete\"];\nvar aggregateProps = [\"aggregate\", \"count\", \"groupBy\"];\nfunction applyModel(client, dmmfModelName) {\n  var _a3;\n  const jsModelName = dmmfToJSModelName(dmmfModelName);\n  const model = client._baseDmmf.modelMap[dmmfModelName];\n  const fieldsProxyEnabled = (_a3 = client._engineConfig.previewFeatures) == null ? void 0 : _a3.includes(\"fieldReference\");\n  const ownKeys = getOwnKeys2(client, dmmfModelName);\n  const baseObject = {};\n  let fieldsProxy;\n  return new Proxy(baseObject, {\n    get(target, prop) {\n      if (prop in target || typeof prop === \"symbol\")\n        return target[prop];\n      if (prop === \"fields\" && fieldsProxyEnabled) {\n        return fieldsProxy != null ? fieldsProxy : fieldsProxy = applyFieldsProxy(model);\n      }\n      if (!isValidActionName(client, dmmfModelName, prop))\n        return void 0;\n      const dmmfActionName = getDmmfActionName(prop);\n      let requestFn = /* @__PURE__ */ __name((params) => client._request(params), \"requestFn\");\n      if (isClientOnlyAction(prop)) {\n        requestFn = wrapRequest(prop, dmmfModelName, requestFn);\n      }\n      const action = /* @__PURE__ */ __name((paramOverrides) => (userArgs) => {\n        const callSite = getCallSite(client._errorFormat);\n        return createPrismaPromise((txId, lock) => {\n          const data = { args: userArgs, dataPath: [] };\n          const action2 = { action: dmmfActionName, model: dmmfModelName };\n          const method = { clientMethod: `${jsModelName}.${prop}`, jsModelName };\n          const tx = { runInTransaction: !!txId, transactionId: txId, lock };\n          const trace2 = { callsite: callSite };\n          const params = { ...data, ...action2, ...method, ...tx, ...trace2 };\n          return requestFn({ ...params, ...paramOverrides });\n        });\n      }, \"action\");\n      if (fluentProps.includes(dmmfActionName)) {\n        return applyFluent(client, dmmfModelName, action);\n      }\n      if (isValidAggregateName(prop)) {\n        return applyAggregates(client, prop, action);\n      }\n      return action({});\n    },\n    ...defaultProxyHandlers(ownKeys)\n  });\n}\n__name(applyModel, \"applyModel\");\nfunction getOwnKeys2(client, dmmfModelName) {\n  return [...Object.keys(client._baseDmmf.mappingsMap[dmmfModelName]), \"count\"].filter(\n    (key) => ![\"model\", \"plural\"].includes(key)\n  );\n}\n__name(getOwnKeys2, \"getOwnKeys\");\nfunction isValidActionName(client, dmmfModelName, action) {\n  if (isClientOnlyAction(action)) {\n    return isValidActionName(client, dmmfModelName, clientOnlyActions[action].wrappedAction);\n  }\n  return getOwnKeys2(client, dmmfModelName).includes(action);\n}\n__name(isValidActionName, \"isValidActionName\");\nfunction isValidAggregateName(action) {\n  return aggregateProps.includes(action);\n}\n__name(isValidAggregateName, \"isValidAggregateName\");\n\n// src/runtime/core/model/utils/jsToDMMFModelName.ts\nfunction jsToDMMFModelName(name) {\n  return name.replace(/^./, (str) => str.toUpperCase());\n}\n__name(jsToDMMFModelName, \"jsToDMMFModelName\");\n\n// src/runtime/core/model/applyModels.ts\nfunction applyModels(client) {\n  const modelCache = {};\n  const ownKeys = getOwnKeys3(client);\n  return new Proxy(client, {\n    get(target, prop) {\n      if (prop in target || typeof prop === \"symbol\")\n        return target[prop];\n      const dmmfModelName = jsToDMMFModelName(prop);\n      if (modelCache[dmmfModelName] !== void 0) {\n        return modelCache[dmmfModelName];\n      }\n      if (client._baseDmmf.modelMap[dmmfModelName] !== void 0) {\n        return modelCache[dmmfModelName] = applyModel(client, dmmfModelName);\n      }\n      if (client._baseDmmf.modelMap[prop] !== void 0) {\n        return modelCache[dmmfModelName] = applyModel(client, prop);\n      }\n    },\n    ...defaultProxyHandlers(ownKeys)\n  });\n}\n__name(applyModels, \"applyModels\");\nfunction getOwnKeys3(client) {\n  return [...Object.keys(client._baseDmmf.modelMap).map(dmmfToJSModelName), ...Object.keys(client)];\n}\n__name(getOwnKeys3, \"getOwnKeys\");\n\n// src/runtime/core/transaction/utils/createLockCountPromise.ts\nfunction getLockCountPromise(knock, cb = () => {\n}) {\n  let resolve;\n  const lock = new Promise((res) => resolve = res);\n  return {\n    then(onFulfilled) {\n      if (--knock === 0)\n        resolve(cb());\n      return onFulfilled == null ? void 0 : onFulfilled(lock);\n    }\n  };\n}\n__name(getLockCountPromise, \"getLockCountPromise\");\n\n// src/runtime/getLogLevel.ts\nfunction getLogLevel(log4) {\n  if (typeof log4 === \"string\") {\n    return log4;\n  }\n  return log4.reduce((acc, curr) => {\n    const currentLevel = typeof curr === \"string\" ? curr : curr.level;\n    if (currentLevel === \"query\") {\n      return acc;\n    }\n    if (!acc) {\n      return currentLevel;\n    }\n    if (curr === \"info\" || acc === \"info\") {\n      return \"info\";\n    }\n    return currentLevel;\n  }, void 0);\n}\n__name(getLogLevel, \"getLogLevel\");\n\n// src/runtime/mergeBy.ts\nfunction mergeBy(arr1, arr2, cb) {\n  const groupedArr1 = groupBy2(arr1, cb);\n  const groupedArr2 = groupBy2(arr2, cb);\n  const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);\n  const arr2Keys = Object.keys(groupedArr2);\n  Object.entries(groupedArr1).forEach(([key, value]) => {\n    if (!arr2Keys.includes(key)) {\n      result.push(value[value.length - 1]);\n    }\n  });\n  return result;\n}\n__name(mergeBy, \"mergeBy\");\nvar groupBy2 = /* @__PURE__ */ __name((arr, cb) => {\n  return arr.reduce((acc, curr) => {\n    const key = cb(curr);\n    if (!acc[key]) {\n      acc[key] = [];\n    }\n    acc[key].push(curr);\n    return acc;\n  }, {});\n}, \"groupBy\");\n\n// src/runtime/MiddlewareHandler.ts\nvar MiddlewareHandler = class {\n  constructor() {\n    this._middlewares = [];\n  }\n  use(middleware) {\n    this._middlewares.push(middleware);\n  }\n  get(id) {\n    return this._middlewares[id];\n  }\n  has(id) {\n    return !!this._middlewares[id];\n  }\n  length() {\n    return this._middlewares.length;\n  }\n};\n__name(MiddlewareHandler, \"MiddlewareHandler\");\nvar Middlewares = class {\n  constructor() {\n    this.query = new MiddlewareHandler();\n    this.engine = new MiddlewareHandler();\n  }\n};\n__name(Middlewares, \"Middlewares\");\n\n// src/runtime/RequestHandler.ts\nvar import_strip_ansi4 = __toESM(require_strip_ansi());\n\n// src/runtime/DataLoader.ts\nvar DataLoader = class {\n  constructor(options) {\n    this.options = options;\n    this.tickActive = false;\n    this.batches = {};\n  }\n  request(request2) {\n    const hash = this.options.batchBy(request2);\n    if (!hash) {\n      return this.options.singleLoader(request2);\n    }\n    if (!this.batches[hash]) {\n      this.batches[hash] = [];\n      if (!this.tickActive) {\n        this.tickActive = true;\n        process.nextTick(() => {\n          this.dispatchBatches();\n          this.tickActive = false;\n        });\n      }\n    }\n    return new Promise((resolve, reject) => {\n      this.batches[hash].push({\n        request: request2,\n        resolve,\n        reject\n      });\n    });\n  }\n  dispatchBatches() {\n    for (const key in this.batches) {\n      const batch = this.batches[key];\n      delete this.batches[key];\n      if (batch.length === 1) {\n        this.options.singleLoader(batch[0].request).then((result) => {\n          if (result instanceof Error) {\n            batch[0].reject(result);\n          } else {\n            batch[0].resolve(result);\n          }\n        }).catch((e) => {\n          batch[0].reject(e);\n        });\n      } else {\n        this.options.batchLoader(batch.map((j) => j.request)).then((results) => {\n          if (results instanceof Error) {\n            for (let i = 0; i < batch.length; i++) {\n              batch[i].reject(results);\n            }\n          } else {\n            for (let i = 0; i < batch.length; i++) {\n              const value = results[i];\n              if (value instanceof Error) {\n                batch[i].reject(value);\n              } else {\n                batch[i].resolve(value);\n              }\n            }\n          }\n        }).catch((e) => {\n          for (let i = 0; i < batch.length; i++) {\n            batch[i].reject(e);\n          }\n        });\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"DataLoader\";\n  }\n};\n__name(DataLoader, \"DataLoader\");\n\n// src/runtime/RequestHandler.ts\nvar debug11 = src_default(\"prisma:client:request_handler\");\nfunction getRequestInfo(request2) {\n  var _a3;\n  const txId = request2.transactionId;\n  const inTx = request2.runInTransaction;\n  const headers = (_a3 = request2.headers) != null ? _a3 : {};\n  const traceparent = getTraceParent({ tracingConfig: request2.tracingConfig });\n  const _inTx = typeof txId === \"number\" && inTx ? true : void 0;\n  const _txId = typeof txId === \"string\" && inTx ? txId : void 0;\n  if (_txId !== void 0)\n    headers.transactionId = _txId;\n  if (traceparent !== void 0)\n    headers.traceparent = traceparent;\n  return { inTx: _inTx, headers };\n}\n__name(getRequestInfo, \"getRequestInfo\");\nvar RequestHandler = class {\n  constructor(client, hooks) {\n    this.client = client;\n    this.hooks = hooks;\n    this.dataloader = new DataLoader({\n      batchLoader: (requests) => {\n        const info2 = getRequestInfo(requests[0]);\n        const queries = requests.map((r) => String(r.document));\n        const traceparent = getTraceParent({ context: requests[0].otelParentCtx, tracingConfig: client._tracingConfig });\n        if (traceparent)\n          info2.headers.traceparent = traceparent;\n        return this.client._engine.requestBatch(queries, info2.headers, info2.inTx);\n      },\n      singleLoader: (request2) => {\n        const info2 = getRequestInfo(request2);\n        const query2 = String(request2.document);\n        return this.client._engine.request(query2, info2.headers);\n      },\n      batchBy: (request2) => {\n        if (request2.transactionId) {\n          return `transaction-${request2.transactionId}`;\n        }\n        return batchFindUniqueBy(request2);\n      }\n    });\n  }\n  async request({\n    document: document2,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    rejectOnNotFound,\n    clientMethod,\n    runInTransaction,\n    engineHook,\n    args,\n    headers,\n    transactionId,\n    unpacker,\n    otelParentCtx,\n    otelChildCtx\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query2 = String(document2);\n      this.hooks.beforeRequest({\n        query: query2,\n        path: dataPath,\n        rootField,\n        typeName,\n        document: document2,\n        isList,\n        clientMethod,\n        args\n      });\n    }\n    try {\n      let data, elapsed;\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document: document2,\n            runInTransaction\n          },\n          (params) => this.dataloader.request({ ...params, tracingConfig: this.client._tracingConfig })\n        );\n        data = result.data;\n        elapsed = result.elapsed;\n      } else {\n        const result = await this.dataloader.request({\n          document: document2,\n          runInTransaction,\n          headers,\n          transactionId,\n          otelParentCtx,\n          otelChildCtx,\n          tracingConfig: this.client._tracingConfig\n        });\n        data = result == null ? void 0 : result.data;\n        elapsed = result == null ? void 0 : result.elapsed;\n      }\n      const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);\n      throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed };\n      }\n      return unpackResult;\n    } catch (error2) {\n      this.handleRequestError({ error: error2, clientMethod, callsite });\n    }\n  }\n  handleRequestError({ error: error2, clientMethod, callsite }) {\n    debug11(error2);\n    let message = error2.message;\n    if (callsite) {\n      message = createErrorMessageWithContext({\n        callsite,\n        originalMethod: clientMethod,\n        isPanic: error2.isPanic,\n        showColors: this.client._errorFormat === \"pretty\",\n        message\n      });\n    }\n    message = this.sanitizeMessage(message);\n    if (error2.code) {\n      throw new PrismaClientKnownRequestError(message, error2.code, this.client._clientVersion, error2.meta);\n    } else if (error2.isPanic) {\n      throw new PrismaClientRustPanicError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientUnknownRequestError) {\n      throw new PrismaClientUnknownRequestError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientInitializationError) {\n      throw new PrismaClientInitializationError(message, this.client._clientVersion);\n    } else if (error2 instanceof PrismaClientRustPanicError) {\n      throw new PrismaClientRustPanicError(message, this.client._clientVersion);\n    }\n    error2.clientVersion = this.client._clientVersion;\n    throw error2;\n  }\n  sanitizeMessage(message) {\n    if (this.client._errorFormat && this.client._errorFormat !== \"pretty\") {\n      return (0, import_strip_ansi4.default)(message);\n    }\n    return message;\n  }\n  unpack(document2, data, path7, rootField, unpacker) {\n    if (data == null ? void 0 : data.data) {\n      data = data.data;\n    }\n    if (unpacker) {\n      data[rootField] = unpacker(data[rootField]);\n    }\n    const getPath = [];\n    if (rootField) {\n      getPath.push(rootField);\n    }\n    getPath.push(...path7.filter((p) => p !== \"select\" && p !== \"include\"));\n    return unpack({ document: document2, data, path: getPath });\n  }\n  get [Symbol.toStringTag]() {\n    return \"RequestHandler\";\n  }\n};\n__name(RequestHandler, \"RequestHandler\");\nfunction batchFindUniqueBy(request2) {\n  var _a3;\n  if (!request2.document.children[0].name.startsWith(\"findUnique\")) {\n    return void 0;\n  }\n  const args = (_a3 = request2.document.children[0].args) == null ? void 0 : _a3.args.map((a) => {\n    if (a.value instanceof Args) {\n      return `${a.key}-${a.value.args.map((a2) => a2.key).join(\",\")}`;\n    }\n    return a.key;\n  }).join(\",\");\n  const selectionSet = request2.document.children[0].children.join(\",\");\n  return `${request2.document.children[0].name}|${args}|${selectionSet}`;\n}\n__name(batchFindUniqueBy, \"batchFindUniqueBy\");\n\n// src/runtime/utils/clientVersion.ts\nvar clientVersion = require_package2().version;\n\n// src/runtime/utils/deserializeRawResults.ts\nfunction deserializeRawResults(rows) {\n  return rows.map((row) => {\n    const mappedRow = {};\n    for (const key of Object.keys(row)) {\n      mappedRow[key] = deserializeValue(row[key]);\n    }\n    return mappedRow;\n  });\n}\n__name(deserializeRawResults, \"deserializeRawResults\");\nfunction deserializeValue({ prisma__type: type, prisma__value: value }) {\n  switch (type) {\n    case \"bigint\":\n      return BigInt(value);\n    case \"bytes\":\n      return Buffer.from(value, \"base64\");\n    case \"decimal\":\n      return new decimal_default(value);\n    case \"datetime\":\n    case \"date\":\n      return new Date(value);\n    case \"time\":\n      return new Date(`1970-01-01T${value}Z`);\n    case \"array\":\n      return value.map(deserializeValue);\n    default:\n      return value;\n  }\n}\n__name(deserializeValue, \"deserializeValue\");\n\n// src/runtime/utils/mssqlPreparedStatement.ts\nvar mssqlPreparedStatement = /* @__PURE__ */ __name((template) => {\n  return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);\n}, \"mssqlPreparedStatement\");\n\n// src/runtime/utils/serializeRawParameters.ts\nfunction serializeRawParameters(parameters) {\n  try {\n    return serializeRawParametersInternal(parameters, \"fast\");\n  } catch (error2) {\n    return serializeRawParametersInternal(parameters, \"slow\");\n  }\n}\n__name(serializeRawParameters, \"serializeRawParameters\");\nfunction serializeRawParametersInternal(parameters, objectSerialization) {\n  return JSON.stringify(parameters.map((parameter) => encodeParameter(parameter, objectSerialization)));\n}\n__name(serializeRawParametersInternal, \"serializeRawParametersInternal\");\nfunction encodeParameter(parameter, objectSerialization) {\n  if (typeof parameter === \"bigint\") {\n    return {\n      prisma__type: \"bigint\",\n      prisma__value: parameter.toString()\n    };\n  }\n  if (isDate(parameter)) {\n    return {\n      prisma__type: \"date\",\n      prisma__value: parameter.toJSON()\n    };\n  }\n  if (decimal_default.isDecimal(parameter)) {\n    return {\n      prisma__type: \"decimal\",\n      prisma__value: parameter.toJSON()\n    };\n  }\n  if (Buffer.isBuffer(parameter)) {\n    return {\n      prisma__type: \"bytes\",\n      prisma__value: parameter.toString(\"base64\")\n    };\n  }\n  if (isArrayBufferLike(parameter) || ArrayBuffer.isView(parameter)) {\n    return {\n      prisma__type: \"bytes\",\n      prisma__value: Buffer.from(parameter).toString(\"base64\")\n    };\n  }\n  if (typeof parameter === \"object\" && objectSerialization === \"slow\") {\n    return preprocessObject(parameter);\n  }\n  return parameter;\n}\n__name(encodeParameter, \"encodeParameter\");\nfunction isDate(value) {\n  if (value instanceof Date) {\n    return true;\n  }\n  return Object.prototype.toString.call(value) === \"[object Date]\" && typeof value.toJSON === \"function\";\n}\n__name(isDate, \"isDate\");\nfunction isArrayBufferLike(value) {\n  if (value instanceof ArrayBuffer || value instanceof SharedArrayBuffer) {\n    return true;\n  }\n  if (typeof value === \"object\" && value !== null) {\n    return value[Symbol.toStringTag] === \"ArrayBuffer\" || value[Symbol.toStringTag] === \"SharedArrayBuffer\";\n  }\n  return false;\n}\n__name(isArrayBufferLike, \"isArrayBufferLike\");\nfunction preprocessObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  if (typeof obj.toJSON === \"function\") {\n    return obj.toJSON();\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(preprocessValueInObject);\n  }\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = preprocessValueInObject(obj[key]);\n  }\n  return result;\n}\n__name(preprocessObject, \"preprocessObject\");\nfunction preprocessValueInObject(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return preprocessObject(value);\n}\n__name(preprocessValueInObject, \"preprocessValueInObject\");\n\n// src/runtime/utils/validatePrismaClientOptions.ts\nvar import_js_levenshtein2 = __toESM(require_js_levenshtein());\nvar knownProperties = [\"datasources\", \"errorFormat\", \"log\", \"__internal\", \"rejectOnNotFound\"];\nvar errorFormats = [\"pretty\", \"colorless\", \"minimal\"];\nvar logLevels = [\"info\", \"query\", \"warn\", \"error\"];\nvar validators = {\n  datasources: (options, datasourceNames) => {\n    if (!options) {\n      return;\n    }\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"datasources\" provided to PrismaClient constructor`\n      );\n    }\n    for (const [key, value] of Object.entries(options)) {\n      if (!datasourceNames.includes(key)) {\n        const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(\", \")}`;\n        throw new PrismaClientConstructorValidationError(\n          `Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`\n        );\n      }\n      if (typeof value !== \"object\" || Array.isArray(value)) {\n        throw new PrismaClientConstructorValidationError(\n          `Invalid value ${JSON.stringify(options)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n        );\n      }\n      if (value && typeof value === \"object\") {\n        for (const [key1, value1] of Object.entries(value)) {\n          if (key1 !== \"url\") {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(options)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n            );\n          }\n          if (typeof value1 !== \"string\") {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(value1)} for datasource \"${key}\" provided to PrismaClient constructor.\nIt should have this form: { url: \"CONNECTION_STRING\" }`\n            );\n          }\n        }\n      }\n    }\n  },\n  errorFormat: (options) => {\n    if (!options) {\n      return;\n    }\n    if (typeof options !== \"string\") {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"errorFormat\" provided to PrismaClient constructor.`\n      );\n    }\n    if (!errorFormats.includes(options)) {\n      const didYouMean = getDidYouMean(options, errorFormats);\n      throw new PrismaClientConstructorValidationError(\n        `Invalid errorFormat ${options} provided to PrismaClient constructor.${didYouMean}`\n      );\n    }\n  },\n  log: (options) => {\n    if (!options) {\n      return;\n    }\n    if (!Array.isArray(options)) {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(options)} for \"log\" provided to PrismaClient constructor.`\n      );\n    }\n    function validateLogLevel(level) {\n      if (typeof level === \"string\") {\n        if (!logLevels.includes(level)) {\n          const didYouMean = getDidYouMean(level, logLevels);\n          throw new PrismaClientConstructorValidationError(\n            `Invalid log level \"${level}\" provided to PrismaClient constructor.${didYouMean}`\n          );\n        }\n      }\n    }\n    __name(validateLogLevel, \"validateLogLevel\");\n    for (const option of options) {\n      validateLogLevel(option);\n      const logValidators = {\n        level: validateLogLevel,\n        emit: (value) => {\n          const emits = [\"stdout\", \"event\"];\n          if (!emits.includes(value)) {\n            const didYouMean = getDidYouMean(value, emits);\n            throw new PrismaClientConstructorValidationError(\n              `Invalid value ${JSON.stringify(\n                value\n              )} for \"emit\" in logLevel provided to PrismaClient constructor.${didYouMean}`\n            );\n          }\n        }\n      };\n      if (option && typeof option === \"object\") {\n        for (const [key, value] of Object.entries(option)) {\n          if (logValidators[key]) {\n            logValidators[key](value);\n          } else {\n            throw new PrismaClientConstructorValidationError(\n              `Invalid property ${key} for \"log\" provided to PrismaClient constructor`\n            );\n          }\n        }\n      }\n    }\n  },\n  __internal: (value) => {\n    if (!value) {\n      return;\n    }\n    const knownKeys = [\"debug\", \"hooks\", \"engine\", \"measurePerformance\"];\n    if (typeof value !== \"object\") {\n      throw new PrismaClientConstructorValidationError(\n        `Invalid value ${JSON.stringify(value)} for \"__internal\" to PrismaClient constructor`\n      );\n    }\n    for (const [key] of Object.entries(value)) {\n      if (!knownKeys.includes(key)) {\n        const didYouMean = getDidYouMean(key, knownKeys);\n        throw new PrismaClientConstructorValidationError(\n          `Invalid property ${JSON.stringify(key)} for \"__internal\" provided to PrismaClient constructor.${didYouMean}`\n        );\n      }\n    }\n  },\n  rejectOnNotFound: (value) => {\n    if (!value) {\n      return;\n    }\n    if (isError(value) || typeof value === \"boolean\" || typeof value === \"object\" || typeof value === \"function\") {\n      return value;\n    }\n    throw new PrismaClientConstructorValidationError(\n      `Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(\n        value\n      )}`\n    );\n  }\n};\nfunction validatePrismaClientOptions(options, datasourceNames) {\n  for (const [key, value] of Object.entries(options)) {\n    if (!knownProperties.includes(key)) {\n      const didYouMean = getDidYouMean(key, knownProperties);\n      throw new PrismaClientConstructorValidationError(\n        `Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`\n      );\n    }\n    validators[key](value, datasourceNames);\n  }\n}\n__name(validatePrismaClientOptions, \"validatePrismaClientOptions\");\nfunction getDidYouMean(str, options) {\n  if (options.length === 0) {\n    return \"\";\n  }\n  if (typeof str !== \"string\") {\n    return \"\";\n  }\n  const alternative = getAlternative(str, options);\n  if (!alternative) {\n    return \"\";\n  }\n  return ` Did you mean \"${alternative}\"?`;\n}\n__name(getDidYouMean, \"getDidYouMean\");\nfunction getAlternative(str, options) {\n  if (options.length === 0) {\n    return null;\n  }\n  const optionsWithDistances = options.map((value) => ({\n    value,\n    distance: (0, import_js_levenshtein2.default)(str, value)\n  }));\n  optionsWithDistances.sort((a, b) => {\n    return a.distance < b.distance ? -1 : 1;\n  });\n  const bestAlternative = optionsWithDistances[0];\n  if (bestAlternative.distance < 3) {\n    return bestAlternative.value;\n  }\n  return null;\n}\n__name(getAlternative, \"getAlternative\");\n\n// src/runtime/getPrismaClient.ts\nvar debug12 = src_default(\"prisma:client\");\nvar ALTER_RE = /^(\\s*alter\\s)/i;\ntypeof globalThis === \"object\" ? globalThis.NODE_CLIENT = true : 0;\nfunction isReadonlyArray(arg2) {\n  return Array.isArray(arg2);\n}\n__name(isReadonlyArray, \"isReadonlyArray\");\nfunction checkAlter(query2, values, invalidCall) {\n  if (values.length > 0 && ALTER_RE.exec(query2)) {\n    throw new Error(`Running ALTER using ${invalidCall} is not supported\nUsing the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.\n\nExample:\n  await prisma.$executeRawUnsafe(\\`ALTER USER prisma WITH PASSWORD '\\${password}'\\`)\n\nMore Information: https://pris.ly/d/execute-raw\n`);\n  }\n}\n__name(checkAlter, \"checkAlter\");\nvar actionOperationMap = {\n  findUnique: \"query\",\n  findFirst: \"query\",\n  findMany: \"query\",\n  count: \"query\",\n  create: \"mutation\",\n  createMany: \"mutation\",\n  update: \"mutation\",\n  updateMany: \"mutation\",\n  upsert: \"mutation\",\n  delete: \"mutation\",\n  deleteMany: \"mutation\",\n  executeRaw: \"mutation\",\n  queryRaw: \"mutation\",\n  aggregate: \"query\",\n  groupBy: \"query\",\n  runCommandRaw: \"mutation\",\n  findRaw: \"query\",\n  aggregateRaw: \"query\"\n};\nvar TX_ID = Symbol.for(\"prisma.client.transaction.id\");\nfunction getPrismaClient(config2) {\n  class PrismaClient {\n    constructor(optionsArg) {\n      this._middlewares = new Middlewares();\n      this._transactionId = 1;\n      this._getDmmf = callOnce(async (params) => {\n        try {\n          const dmmf = await this._engine.getDmmf();\n          return new DMMFHelper(getPrismaClientDMMF(dmmf));\n        } catch (error2) {\n          this._fetcher.handleRequestError({ ...params, error: error2 });\n        }\n      });\n      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i;\n      if (optionsArg) {\n        validatePrismaClientOptions(optionsArg, config2.datasourceNames);\n      }\n      this._previewFeatures = (_b2 = (_a3 = config2.generator) == null ? void 0 : _a3.previewFeatures) != null ? _b2 : [];\n      this._rejectOnNotFound = optionsArg == null ? void 0 : optionsArg.rejectOnNotFound;\n      this._clientVersion = (_c = config2.clientVersion) != null ? _c : clientVersion;\n      this._activeProvider = config2.activeProvider;\n      this._dataProxy = config2.dataProxy;\n      this._tracingConfig = getTracingConfig(this._previewFeatures);\n      this._clientEngineType = getClientEngineType(config2.generator);\n      const envPaths = {\n        rootEnvPath: config2.relativeEnvPaths.rootEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),\n        schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)\n      };\n      const loadedEnv = tryLoadEnvs(envPaths, { conflictCheck: \"none\" });\n      try {\n        const options = optionsArg != null ? optionsArg : {};\n        const internal = (_d = options.__internal) != null ? _d : {};\n        const useDebug = internal.debug === true;\n        if (useDebug) {\n          src_default.enable(\"prisma:client\");\n        }\n        if (internal.hooks) {\n          this._hooks = internal.hooks;\n        }\n        let cwd = import_path5.default.resolve(config2.dirname, config2.relativePath);\n        if (!import_fs9.default.existsSync(cwd)) {\n          cwd = config2.dirname;\n        }\n        debug12(\"dirname\", config2.dirname);\n        debug12(\"relativePath\", config2.relativePath);\n        debug12(\"cwd\", cwd);\n        const thedatasources = options.datasources || {};\n        const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {\n          return source && source.url;\n        }).map(([name, { url }]) => ({\n          name,\n          url\n        }));\n        const datasources = mergeBy([], inputDatasources, (source) => source.name);\n        const engineConfig = internal.engine || {};\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat;\n        } else if (false) {} else if (process.env.NO_COLOR) {\n          this._errorFormat = \"colorless\";\n        } else {\n          this._errorFormat = \"colorless\";\n        }\n        this._baseDmmf = new BaseDMMFHelper(config2.document);\n        if (this._dataProxy) {\n          const rawDmmf = config2.document;\n          this._dmmf = new DMMFHelper(rawDmmf);\n        }\n        this._engineConfig = {\n          cwd,\n          dirname: config2.dirname,\n          enableDebugLogs: useDebug,\n          allowTriggerPanic: engineConfig.allowTriggerPanic,\n          datamodelPath: import_path5.default.join(config2.dirname, (_e = config2.filename) != null ? _e : \"schema.prisma\"),\n          prismaPath: (_f = engineConfig.binaryPath) != null ? _f : void 0,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config2.generator,\n          showColors: this._errorFormat === \"pretty\",\n          logLevel: options.log && getLogLevel(options.log),\n          logQueries: options.log && Boolean(\n            typeof options.log === \"string\" ? options.log === \"query\" : options.log.find((o) => typeof o === \"string\" ? o === \"query\" : o.level === \"query\")\n          ),\n          env: (_i = (_h = loadedEnv == null ? void 0 : loadedEnv.parsed) != null ? _h : (_g = config2.injectableEdgeEnv) == null ? void 0 : _g.parsed) != null ? _i : {},\n          flags: [],\n          clientVersion: config2.clientVersion,\n          previewFeatures: this._previewFeatures,\n          activeProvider: config2.activeProvider,\n          inlineSchema: config2.inlineSchema,\n          inlineDatasources: config2.inlineDatasources,\n          inlineSchemaHash: config2.inlineSchemaHash,\n          tracingConfig: this._tracingConfig\n        };\n        debug12(\"clientVersion\", config2.clientVersion);\n        debug12(\"clientEngineType\", this._dataProxy ? \"dataproxy\" : this._clientEngineType);\n        if (this._dataProxy) {\n          const runtime =  true ? \"Node.js\" : 0;\n          debug12(`using Data Proxy with ${runtime} runtime`);\n        }\n        this._engine = this.getEngine();\n        void this._getActiveProvider();\n        this._fetcher = new RequestHandler(this, this._hooks);\n        if (options.log) {\n          for (const log4 of options.log) {\n            const level = typeof log4 === \"string\" ? log4 : log4.emit === \"stdout\" ? log4.level : null;\n            if (level) {\n              this.$on(level, (event) => {\n                var _a4;\n                logger_exports.log(`${(_a4 = logger_exports.tags[level]) != null ? _a4 : \"\"}`, event.message || event.query);\n              });\n            }\n          }\n        }\n        this._metrics = new MetricsClient(this._engine);\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n      return applyModels(this);\n    }\n    get [Symbol.toStringTag]() {\n      return \"PrismaClient\";\n    }\n    getEngine() {\n      if (this._dataProxy === true) {\n        return new DataProxyEngine(this._engineConfig);\n      } else if (this._clientEngineType === \"library\" /* Library */) {\n        return new LibraryEngine(this._engineConfig);\n      } else if (this._clientEngineType === \"binary\" /* Binary */) {\n        return new BinaryEngine(this._engineConfig);\n      }\n      throw new PrismaClientValidationError(\"Invalid client engine type, please use `library` or `binary`\");\n    }\n    $use(arg0, arg1) {\n      if (typeof arg0 === \"function\") {\n        this._middlewares.query.use(arg0);\n      } else if (arg0 === \"all\") {\n        this._middlewares.query.use(arg1);\n      } else if (arg0 === \"engine\") {\n        this._middlewares.engine.use(arg1);\n      } else {\n        throw new Error(`Invalid middleware ${arg0}`);\n      }\n    }\n    $on(eventType, callback) {\n      if (eventType === \"beforeExit\") {\n        this._engine.on(\"beforeExit\", callback);\n      } else {\n        this._engine.on(eventType, (event) => {\n          var _a3, _b2, _c, _d;\n          const fields = event.fields;\n          if (eventType === \"query\") {\n            return callback({\n              timestamp: event.timestamp,\n              query: (_a3 = fields == null ? void 0 : fields.query) != null ? _a3 : event.query,\n              params: (_b2 = fields == null ? void 0 : fields.params) != null ? _b2 : event.params,\n              duration: (_c = fields == null ? void 0 : fields.duration_ms) != null ? _c : event.duration,\n              target: event.target\n            });\n          } else {\n            return callback({\n              timestamp: event.timestamp,\n              message: (_d = fields == null ? void 0 : fields.message) != null ? _d : event.message,\n              target: event.target\n            });\n          }\n        });\n      }\n    }\n    $connect() {\n      try {\n        return this._engine.start();\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n    }\n    async _runDisconnect() {\n      await this._engine.stop();\n      delete this._connectionPromise;\n      this._engine = this.getEngine();\n      delete this._disconnectionPromise;\n      delete this._getConfigPromise;\n    }\n    async $disconnect() {\n      try {\n        await this._engine.stop();\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      } finally {\n        if (!this._dataProxy) {\n          this._dmmf = void 0;\n        }\n      }\n    }\n    async _getActiveProvider() {\n      try {\n        const configResult = await this._engine.getConfig();\n        this._activeProvider = configResult.datasources[0].activeProvider;\n      } catch (e) {\n      }\n    }\n    $executeRawInternal(txId, lock, query2, ...values) {\n      let queryString = \"\";\n      let parameters = void 0;\n      if (typeof query2 === \"string\") {\n        queryString = query2;\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true\n        };\n        checkAlter(queryString, values, \"prisma.$executeRawUnsafe(<SQL>, [...values])\");\n      } else if (isReadonlyArray(query2)) {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.sql;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"cockroachdb\":\n          case \"postgresql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.text;\n            checkAlter(queryString, queryInstance.values, \"prisma.$executeRaw`<SQL>`\");\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"sqlserver\": {\n            queryString = mssqlPreparedStatement(query2);\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);\n          }\n        }\n      } else {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\":\n            queryString = query2.sql;\n            break;\n          case \"cockroachdb\":\n          case \"postgresql\":\n            queryString = query2.text;\n            checkAlter(queryString, query2.values, \"prisma.$executeRaw(sql`<SQL>`)\");\n            break;\n          case \"sqlserver\":\n            queryString = mssqlPreparedStatement(query2.strings);\n            break;\n          default:\n            throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);\n        }\n        parameters = {\n          values: serializeRawParameters(query2.values),\n          __prismaRawParamaters__: true\n        };\n      }\n      if (parameters == null ? void 0 : parameters.values) {\n        debug12(`prisma.$executeRaw(${queryString}, ${parameters.values})`);\n      } else {\n        debug12(`prisma.$executeRaw(${queryString})`);\n      }\n      const args = { query: queryString, parameters };\n      debug12(`Prisma Client call:`);\n      return this._request({\n        args,\n        clientMethod: \"$executeRaw\",\n        dataPath: [],\n        action: \"executeRaw\",\n        callsite: getCallSite(this._errorFormat),\n        runInTransaction: !!txId,\n        transactionId: txId,\n        lock\n      });\n    }\n    $executeRaw(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        if (query2.raw !== void 0 || query2.sql !== void 0) {\n          return this.$executeRawInternal(txId, lock, query2, ...values);\n        }\n        throw new PrismaClientValidationError(`\\`$executeRaw\\` is a tag function, please use it like the following:\n\\`\\`\\`\nconst result = await prisma.$executeRaw\\`UPDATE User SET cool = \\${true} WHERE email = \\${'user@email.com'};\\`\n\\`\\`\\`\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n`);\n      });\n    }\n    $executeRawUnsafe(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        return this.$executeRawInternal(txId, lock, query2, ...values);\n      });\n    }\n    $runCommandRaw(command) {\n      if (config2.activeProvider !== \"mongodb\") {\n        throw new PrismaClientValidationError(\n          `The ${config2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`\n        );\n      }\n      return createPrismaPromise((txId, lock) => {\n        return this._request({\n          args: { command },\n          clientMethod: \"$runCommandRaw\",\n          dataPath: [],\n          action: \"runCommandRaw\",\n          callsite: getCallSite(this._errorFormat),\n          runInTransaction: !!txId,\n          transactionId: txId,\n          lock\n        });\n      });\n    }\n    $queryRawInternal(txId, lock, query2, ...values) {\n      let queryString = \"\";\n      let parameters = void 0;\n      if (typeof query2 === \"string\") {\n        queryString = query2;\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true\n        };\n      } else if (isReadonlyArray(query2)) {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.sql;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"cockroachdb\":\n          case \"postgresql\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = queryInstance.text;\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          case \"sqlserver\": {\n            const queryInstance = new Sql(query2, values);\n            queryString = mssqlPreparedStatement(queryInstance.strings);\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true\n            };\n            break;\n          }\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);\n          }\n        }\n      } else {\n        switch (this._activeProvider) {\n          case \"sqlite\":\n          case \"mysql\":\n            queryString = query2.sql;\n            break;\n          case \"cockroachdb\":\n          case \"postgresql\":\n            queryString = query2.text;\n            break;\n          case \"sqlserver\":\n            queryString = mssqlPreparedStatement(query2.strings);\n            break;\n          default: {\n            throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);\n          }\n        }\n        parameters = {\n          values: serializeRawParameters(query2.values),\n          __prismaRawParamaters__: true\n        };\n      }\n      if (parameters == null ? void 0 : parameters.values) {\n        debug12(`prisma.queryRaw(${queryString}, ${parameters.values})`);\n      } else {\n        debug12(`prisma.queryRaw(${queryString})`);\n      }\n      const args = { query: queryString, parameters };\n      debug12(`Prisma Client call:`);\n      return this._request({\n        args,\n        clientMethod: \"$queryRaw\",\n        dataPath: [],\n        action: \"queryRaw\",\n        callsite: getCallSite(this._errorFormat),\n        runInTransaction: !!txId,\n        transactionId: txId,\n        lock\n      }).then(deserializeRawResults);\n    }\n    $queryRaw(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        if (query2.raw !== void 0 || query2.sql !== void 0) {\n          return this.$queryRawInternal(txId, lock, query2, ...values);\n        }\n        throw new PrismaClientValidationError(`\\`$queryRaw\\` is a tag function, please use it like the following:\n\\`\\`\\`\nconst result = await prisma.$queryRaw\\`SELECT * FROM User WHERE id = \\${1} OR email = \\${'user@email.com'};\\`\n\\`\\`\\`\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n`);\n      });\n    }\n    $queryRawUnsafe(query2, ...values) {\n      return createPrismaPromise((txId, lock) => {\n        return this.$queryRawInternal(txId, lock, query2, ...values);\n      });\n    }\n    __internal_triggerPanic(fatal) {\n      if (!this._engineConfig.allowTriggerPanic) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      allowTriggerPanic: true\n    }\n  }\n})`);\n      }\n      const headers = fatal ? { \"X-DEBUG-FATAL\": \"1\" } : { \"X-DEBUG-NON-FATAL\": \"1\" };\n      return this._request({\n        action: \"queryRaw\",\n        args: {\n          query: \"SELECT 1\",\n          parameters: void 0\n        },\n        clientMethod: \"queryRaw\",\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: getCallSite(this._errorFormat)\n      });\n    }\n    _transactionWithArray(promises) {\n      const txId = this._transactionId++;\n      const lock = getLockCountPromise(promises.length);\n      const requests = promises.map((request2) => {\n        var _a3;\n        if ((request2 == null ? void 0 : request2[Symbol.toStringTag]) !== \"PrismaPromise\") {\n          throw new Error(\n            `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`\n          );\n        }\n        return (_a3 = request2.requestTransaction) == null ? void 0 : _a3.call(request2, txId, lock);\n      });\n      return Promise.all(requests);\n    }\n    async _transactionWithCallback({\n      callback,\n      options\n    }) {\n      const headers = { traceparent: getTraceParent({ tracingConfig: this._tracingConfig }) };\n      const info2 = await this._engine.transaction(\"start\", headers, options);\n      let result;\n      try {\n        result = await callback(transactionProxy(this, info2.id));\n        await this._engine.transaction(\"commit\", headers, info2);\n      } catch (e) {\n        await this._engine.transaction(\"rollback\", headers, info2).catch(() => {\n        });\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n      return result;\n    }\n    $transaction(input, options) {\n      let callback;\n      if (typeof input === \"function\" && this._hasPreviewFlag(\"interactiveTransactions\")) {\n        callback = /* @__PURE__ */ __name(() => this._transactionWithCallback({ callback: input, options }), \"callback\");\n      } else {\n        callback = /* @__PURE__ */ __name(() => this._transactionWithArray(input), \"callback\");\n      }\n      const spanOptions = {\n        name: \"transaction\",\n        enabled: this._tracingConfig.enabled,\n        attributes: { method: \"$transaction\" }\n      };\n      return runInChildSpan(spanOptions, callback);\n    }\n    async _request(internalParams) {\n      internalParams.otelParentCtx = context2.active();\n      try {\n        const params = {\n          args: internalParams.args,\n          dataPath: internalParams.dataPath,\n          runInTransaction: internalParams.runInTransaction,\n          action: internalParams.action,\n          model: internalParams.model\n        };\n        const spanOptions = {\n          middleware: {\n            name: \"middleware\",\n            enabled: this._tracingConfig.middleware,\n            attributes: { method: \"$use\" },\n            active: false\n          },\n          operation: {\n            name: \"operation\",\n            enabled: this._tracingConfig.enabled,\n            attributes: {\n              method: params.action,\n              model: params.model,\n              name: `${params.model}.${params.action}`\n            }\n          }\n        };\n        let index = -1;\n        const consumer = /* @__PURE__ */ __name((changedParams) => {\n          const nextMiddleware = this._middlewares.query.get(++index);\n          if (nextMiddleware) {\n            return runInChildSpan(spanOptions.middleware, async (span) => {\n              return nextMiddleware(changedParams, (p) => (span == null ? void 0 : span.end(), consumer(p)));\n            });\n          }\n          return this._executeRequest({ ...internalParams, ...changedParams });\n        }, \"consumer\");\n        return await runInChildSpan(spanOptions.operation, () => {\n          if (true) {\n            const asyncRes = new import_async_hooks.AsyncResource(\"prisma-client-request\");\n            return asyncRes.runInAsyncScope(() => consumer(params));\n          }\n          return consumer(params);\n        });\n      } catch (e) {\n        e.clientVersion = this._clientVersion;\n        throw e;\n      }\n    }\n    async _executeRequest({\n      args,\n      clientMethod,\n      jsModelName,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n      transactionId,\n      lock,\n      unpacker,\n      otelParentCtx\n    }) {\n      var _a3, _b2;\n      if (this._dmmf === void 0) {\n        this._dmmf = await this._getDmmf({ clientMethod, callsite });\n      }\n      let rootField;\n      const operation = actionOperationMap[action];\n      if (action === \"executeRaw\" || action === \"queryRaw\" || action === \"runCommandRaw\") {\n        rootField = action;\n      }\n      let mapping;\n      if (model !== void 0) {\n        mapping = (_a3 = this._dmmf) == null ? void 0 : _a3.mappingsMap[model];\n        if (mapping === void 0) {\n          throw new Error(`Could not find mapping for model ${model}`);\n        }\n        rootField = mapping[action === \"count\" ? \"aggregate\" : action];\n      }\n      if (operation !== \"query\" && operation !== \"mutation\") {\n        throw new Error(`Invalid operation ${operation} for action ${action}`);\n      }\n      const field = (_b2 = this._dmmf) == null ? void 0 : _b2.rootFieldMap[rootField];\n      if (field === void 0) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`\n        );\n      }\n      const { isList } = field.outputType;\n      const typeName = getOutputTypeName(field.outputType.type);\n      const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);\n      warnAboutRejectOnNotFound(rejectOnNotFound, jsModelName, action);\n      const serializationFn = /* @__PURE__ */ __name(() => {\n        const document3 = makeDocument({\n          dmmf: this._dmmf,\n          rootField,\n          rootTypeName: operation,\n          select: args,\n          modelName: model\n        });\n        document3.validate(args, false, clientMethod, this._errorFormat, callsite);\n        return transformDocument(document3);\n      }, \"serializationFn\");\n      const spanOptions = {\n        name: \"serialize\",\n        enabled: this._tracingConfig.enabled\n      };\n      const document2 = await runInChildSpan(spanOptions, serializationFn);\n      if (src_default.enabled(\"prisma:client\")) {\n        const query2 = String(document2);\n        debug12(`Prisma Client call:`);\n        debug12(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: []\n          })})`\n        );\n        debug12(`Generated request:`);\n        debug12(query2 + \"\\n\");\n      }\n      await lock;\n      return this._fetcher.request({\n        document: document2,\n        clientMethod,\n        typeName,\n        dataPath,\n        rejectOnNotFound,\n        isList,\n        rootField,\n        callsite,\n        args,\n        engineHook: this._middlewares.engine.get(0),\n        runInTransaction,\n        headers,\n        transactionId,\n        unpacker,\n        otelParentCtx,\n        otelChildCtx: context2.active()\n      });\n    }\n    get $metrics() {\n      if (!this._hasPreviewFlag(\"metrics\")) {\n        throw new PrismaClientValidationError(\n          \"`metrics` preview feature must be enabled in order to access metrics API\"\n        );\n      }\n      return this._metrics;\n    }\n    _hasPreviewFlag(feature) {\n      var _a3;\n      return !!((_a3 = this._engineConfig.previewFeatures) == null ? void 0 : _a3.includes(feature));\n    }\n  }\n  __name(PrismaClient, \"PrismaClient\");\n  return PrismaClient;\n}\n__name(getPrismaClient, \"getPrismaClient\");\nvar forbidden = [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$use\"];\nfunction transactionProxy(thing, txId) {\n  if (typeof thing !== \"object\")\n    return thing;\n  return new Proxy(thing, {\n    get: (target, prop) => {\n      if (forbidden.includes(prop))\n        return void 0;\n      if (prop === TX_ID)\n        return txId;\n      if (typeof target[prop] === \"function\") {\n        return (...args) => {\n          if (prop === \"then\")\n            return target[prop](args[0], args[1], txId);\n          if (prop === \"catch\")\n            return target[prop](args[0], txId);\n          if (prop === \"finally\")\n            return target[prop](args[0], txId);\n          return transactionProxy(target[prop](...args), txId);\n        };\n      }\n      return transactionProxy(target[prop], txId);\n    }\n  });\n}\n__name(transactionProxy, \"transactionProxy\");\nvar rejectOnNotFoundReplacements = {\n  findUnique: \"findUniqueOrThrow\",\n  findFirst: \"findFirstOrThrow\"\n};\nfunction warnAboutRejectOnNotFound(rejectOnNotFound, model, action) {\n  if (rejectOnNotFound) {\n    const replacementAction = rejectOnNotFoundReplacements[action];\n    const replacementCall = model ? `prisma.${model}.${replacementAction}` : `prisma.${replacementAction}`;\n    const key = `rejectOnNotFound.${model != null ? model : \"\"}.${action}`;\n    warnOnce(\n      key,\n      `\\`rejectOnNotFound\\` option is deprecated and will be removed in Prisma 5. Please use \\`${replacementCall}\\` method instead`\n    );\n  }\n}\n__name(warnAboutRejectOnNotFound, \"warnAboutRejectOnNotFound\");\n\n// src/runtime/strictEnum.ts\nvar allowList = /* @__PURE__ */ new Set([\n  \"toJSON\",\n  \"asymmetricMatch\",\n  Symbol.iterator,\n  Symbol.toStringTag,\n  Symbol.isConcatSpreadable,\n  Symbol.toPrimitive\n]);\nfunction makeStrictEnum(definition) {\n  return new Proxy(definition, {\n    get(target, property) {\n      if (property in target) {\n        return target[property];\n      }\n      if (allowList.has(property)) {\n        return void 0;\n      }\n      throw new TypeError(`Invalid enum value: ${String(property)}`);\n    }\n  });\n}\n__name(makeStrictEnum, \"makeStrictEnum\");\n\n// src/runtime/utils/find.ts\nvar import_fs10 = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path6 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_util7 = __webpack_require__(/*! util */ \"util\");\nvar readdirAsync = (0, import_util7.promisify)(import_fs10.default.readdir);\nvar realpathAsync = (0, import_util7.promisify)(import_fs10.default.realpath);\nvar statAsync = (0, import_util7.promisify)(import_fs10.default.stat);\nvar readdirSync = import_fs10.default.readdirSync;\nvar realpathSync = import_fs10.default.realpathSync;\nvar statSync = import_fs10.default.statSync;\nfunction direntToType(dirent) {\n  return dirent.isFile() ? \"f\" : dirent.isDirectory() ? \"d\" : dirent.isSymbolicLink() ? \"l\" : void 0;\n}\n__name(direntToType, \"direntToType\");\nfunction isMatched(string, regexs) {\n  for (const regex of regexs) {\n    if (typeof regex === \"string\") {\n      if (string.includes(regex)) {\n        return true;\n      }\n    } else if (regex.exec(string)) {\n      return true;\n    }\n  }\n  return false;\n}\n__name(isMatched, \"isMatched\");\nfunction findSync(root, match, types = [\"f\", \"d\", \"l\"], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {\n  try {\n    const realRoot = realpathSync(root);\n    if (seen[realRoot]) {\n      return found;\n    }\n    if (limit - found.length <= 0) {\n      return found;\n    }\n    if (direntToType(statSync(realRoot)) !== \"d\") {\n      return found;\n    }\n    const items = readdirSync(root, { withFileTypes: true });\n    seen[realRoot] = true;\n    for (const item of items) {\n      const itemName = item.name;\n      const itemType = direntToType(item);\n      const itemPath = import_path6.default.join(root, item.name);\n      if (itemType && types.includes(itemType)) {\n        if (isMatched(itemPath, match)) {\n          const value = handler(root, itemName, itemType);\n          if (typeof value === \"string\") {\n            found.push(value);\n          } else if (value === true) {\n            found.push(itemPath);\n          }\n        }\n      }\n      if (deep.includes(itemType)) {\n        findSync(itemPath, match, types, deep, limit, handler, found, seen);\n      }\n    }\n  } catch (e) {\n  }\n  return found;\n}\n__name(findSync, \"findSync\");\n\n// src/runtime/warnEnvConflicts.ts\nfunction warnEnvConflicts(envPaths) {\n  tryLoadEnvs(envPaths, { conflictCheck: \"warn\" });\n}\n__name(warnEnvConflicts, \"warnEnvConflicts\");\n\n// src/runtime/index.ts\nvar decompressFromBase642 = lzString.decompressFromBase64;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*!\n *  decimal.js v10.4.0\n *  An arbitrary-precision Decimal type for JavaScript.\n *  https://github.com/MikeMcl/decimal.js\n *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\n *  MIT Licence\n */\n/*!\n * @description Recursive object extending\n * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>\n * @license MIT\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2018 Viacheslav Lotsmanov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHLDJFQUEyRSwrQkFBK0I7QUFDMUc7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSxLQUFxQyxFQUFFLEVBSTFDLENBQUM7QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGNBQWMsNkJBQTZCO0FBQzNDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsOEJBQThCO0FBQzNDLGlCQUFpQixrQ0FBa0M7QUFDbkQsZ0JBQWdCLGlDQUFpQztBQUNqRCxpQkFBaUIsa0NBQWtDO0FBQ25ELGFBQWEsc0NBQXNDO0FBQ25ELGVBQWUsNENBQTRDO0FBQzNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFLFVBQVUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0NBQXdDO0FBQ3RHLDREQUE0RCxzQ0FBc0M7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEVBQUUsRUFBRSxLQUFLO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsRUFBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQjtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsVUFBVSx3QkFBd0I7QUFDbEMsVUFBVSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxnQkFBSztBQUM1QixVQUFVLHVCQUF1QjtBQUNqQyxVQUFVLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLGtCQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhLElBQUksYUFBYSxHQUFHLEtBQUs7QUFDaEcscURBQXFELG1CQUFtQixFQUFFLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxzSEFBc0gsYUFBYTtBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsRUFBRSxJQUFJLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFF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O0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOENBQThDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNFQUFzRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9EQUFvRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlEQUFpRDtBQUN0RDtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwRkFBMEY7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxX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RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0dBQWtHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DLElBQUk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFxQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhEQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRix3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLCtCQUErQixjQUFjLEdBQUcsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUksR0FBRyxNQUFNO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1IsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0REFBNEQ7QUFDL0QsQ0FBQyxvQkFBb0I7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QyxvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDOztBQUV6QztBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQsNkRBQTZELE1BQU0sbUNBQW1DLEtBQUs7QUFDM0c7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osVUFBVTtBQUNWLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxjQUFJOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsOEJBQVk7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0QsK0RBQStELE1BQU0sb0NBQW9DLEtBQUs7QUFDOUc7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsNEJBQTRCLEdBQUcsVUFBVSxHQUFHO0FBQzVDLDZCQUE2QixHQUFHLFVBQVUsR0FBRztBQUM3QywyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbVRBQW1UO0FBQzNVO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrREFBK0QscUZBQXFGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4Qzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtVEFBbVQ7QUFDM1U7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFxRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBaUU7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjLGNBQWMsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTLGFBQWEsSUFBSTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSyxXQUFXLFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DLE1BQU07QUFDTixzREFBc0QsVUFBVTtBQUNoRSxNQUFNO0FBQ047QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsMkJBQTJCLGlCQUFpQixZQUFZLEdBQUcsS0FBSztBQUNoRSx1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw2QkFBNkIsOEJBQThCO0FBQzNELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1AsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EsWUFBWTtBQUNaLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEVBQTBFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxnREFBZ0Qsc0RBQXNEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0sR0FBRywyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksbUNBQW1DLEdBQUcsS0FBSyxHQUFHLGFBQWE7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxJQUFJLElBQUksRUFBRSxJQUFJO0FBQ2pFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDJCQUEyQjtBQUN2SDtBQUNBLGdDQUFnQyxLQUFLLHVDQUF1QyxXQUFXO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QixrQkFBa0IsSUFBSTtBQUMxRSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsa0JBQWtCLElBQUk7QUFDOUUsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0Isa0JBQWtCLElBQUk7QUFDN0UsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLHVDQUF1QyxXQUFXO0FBQzFGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNLHlDQUF5QyxXQUFXO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUIsOERBQThELFdBQVc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUIsd0RBQXdELFdBQVc7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOEJBQThCLGVBQWU7QUFDdkc7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLHVDQUF1QyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEOztBQUVBO0FBQ0EsdUVBQXVFLFNBQVM7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDLDBCQUEwQjtBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQixLQUFLO0FBQzlCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsS0FBcUMsRUFBRSxFQUVqRCxDQUFDO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5S0FBeUs7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUksZUFBZSxDQUFNO0FBQ25ELDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFzRDtBQUM1RixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVksSUFBSSxrQkFBa0I7QUFDeEUsUUFBUTtBQUNSLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsTUFBTSxpQkFBaUIsa0JBQWtCO0FBQzVHOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksSUFBSSxrQkFBa0I7QUFDckUsUUFBUTtBQUNSLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRyxjQUFjLGtCQUFrQjtBQUMzRzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDLHVCQUF1QixJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsOEJBQThCLG9DQUFvQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsMEJBQTBCO0FBQzFHLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLEdBQUcsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0MscUNBQXFDO0FBQzdFLFNBQVM7QUFDVDtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxhQUFhLE9BQU87QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVyxhQUFhLFFBQVEsWUFBWSxPQUFPLGNBQWMsVUFBVTtBQUNqSDtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWEsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sR0FBRyxrQkFBa0IsY0FBYyxrQkFBa0I7QUFDekcsb0NBQW9DLDJCQUEyQixHQUFHLE9BQU87QUFDekU7QUFDQTtBQUNBLGlHQUFpRyxnQkFBZ0I7QUFDakg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsY0FBSTtBQUN0QywyQkFBMkIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0EyQkw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29yZGVycy8uL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4LmpzPzk5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZDIpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZDIgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QyID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QyKSwgbW9kMi5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZDIsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZDIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QyKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIGlzTm9kZU1vZGUgfHwgIW1vZDIgfHwgIW1vZDIuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QyLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2QyXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kMikgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kMik7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x6LXN0cmluZ0AxLjQuNC9ub2RlX21vZHVsZXMvbHotc3RyaW5nL2xpYnMvbHotc3RyaW5nLmpzXG52YXIgcmVxdWlyZV9sel9zdHJpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHotc3RyaW5nQDEuNC40L25vZGVfbW9kdWxlcy9sei1zdHJpbmcvbGlicy9sei1zdHJpbmcuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIExaU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgICB2YXIga2V5U3RyQmFzZTY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgdmFyIGtleVN0clVyaVNhZmUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky0kXCI7XG4gICAgICB2YXIgYmFzZVJldmVyc2VEaWMgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGdldEJhc2VWYWx1ZShhbHBoYWJldCwgY2hhcmFjdGVyKSB7XG4gICAgICAgIGlmICghYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdKSB7XG4gICAgICAgICAgYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdW2NoYXJhY3Rlcl07XG4gICAgICB9XG4gICAgICBfX25hbWUoZ2V0QmFzZVZhbHVlLCBcImdldEJhc2VWYWx1ZVwiKTtcbiAgICAgIHZhciBMWlN0cmluZzIgPSB7XG4gICAgICAgIGNvbXByZXNzVG9CYXNlNjQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB2YXIgcmVzID0gTFpTdHJpbmcyLl9jb21wcmVzcyhpbnB1dCwgNiwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleVN0ckJhc2U2NC5jaGFyQXQoYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpdGNoIChyZXMubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcyArIFwiPT09XCI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiByZXMgKyBcIj09XCI7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiByZXMgKyBcIj1cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29tcHJlc3NGcm9tQmFzZTY0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgaWYgKGlucHV0ID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9kZWNvbXByZXNzKGlucHV0Lmxlbmd0aCwgMzIsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmFzZVZhbHVlKGtleVN0ckJhc2U2NCwgaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXByZXNzVG9VVEYxNjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBMWlN0cmluZzIuX2NvbXByZXNzKGlucHV0LCAxNSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGYoYSArIDMyKTtcbiAgICAgICAgICB9KSArIFwiIFwiO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvbXByZXNzRnJvbVVURjE2OiBmdW5jdGlvbihjb21wcmVzc2VkKSB7XG4gICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIGlmIChjb21wcmVzc2VkID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9kZWNvbXByZXNzKGNvbXByZXNzZWQubGVuZ3RoLCAxNjM4NCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaW5kZXgpIC0gMzI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXByZXNzVG9VaW50OEFycmF5OiBmdW5jdGlvbih1bmNvbXByZXNzZWQpIHtcbiAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IExaU3RyaW5nMi5jb21wcmVzcyh1bmNvbXByZXNzZWQpO1xuICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShjb21wcmVzc2VkLmxlbmd0aCAqIDIpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBUb3RhbExlbiA9IGNvbXByZXNzZWQubGVuZ3RoOyBpIDwgVG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfdmFsdWUgPSBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBidWZbaSAqIDJdID0gY3VycmVudF92YWx1ZSA+Pj4gODtcbiAgICAgICAgICAgIGJ1ZltpICogMiArIDFdID0gY3VycmVudF92YWx1ZSAlIDI1NjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OiBmdW5jdGlvbihjb21wcmVzc2VkKSB7XG4gICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IG51bGwgfHwgY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLmRlY29tcHJlc3MoY29tcHJlc3NlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQXJyYXkoY29tcHJlc3NlZC5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBUb3RhbExlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBUb3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZltpXSA9IGNvbXByZXNzZWRbaSAqIDJdICogMjU2ICsgY29tcHJlc3NlZFtpICogMiArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgYnVmLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChmKGMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5kZWNvbXByZXNzKHJlc3VsdC5qb2luKFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIExaU3RyaW5nMi5fY29tcHJlc3MoaW5wdXQsIDYsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTdHJVcmlTYWZlLmNoYXJBdChhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgaWYgKGlucHV0ID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyAvZywgXCIrXCIpO1xuICAgICAgICAgIHJldHVybiBMWlN0cmluZzIuX2RlY29tcHJlc3MoaW5wdXQubGVuZ3RoLCAzMiwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCYXNlVmFsdWUoa2V5U3RyVXJpU2FmZSwgaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXByZXNzOiBmdW5jdGlvbih1bmNvbXByZXNzZWQpIHtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9jb21wcmVzcyh1bmNvbXByZXNzZWQsIDE2LCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gZihhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NvbXByZXNzOiBmdW5jdGlvbih1bmNvbXByZXNzZWQsIGJpdHNQZXJDaGFyLCBnZXRDaGFyRnJvbUludCkge1xuICAgICAgICAgIGlmICh1bmNvbXByZXNzZWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIHZhciBpLCB2YWx1ZSwgY29udGV4dF9kaWN0aW9uYXJ5ID0ge30sIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlID0ge30sIGNvbnRleHRfYyA9IFwiXCIsIGNvbnRleHRfd2MgPSBcIlwiLCBjb250ZXh0X3cgPSBcIlwiLCBjb250ZXh0X2VubGFyZ2VJbiA9IDIsIGNvbnRleHRfZGljdFNpemUgPSAzLCBjb250ZXh0X251bUJpdHMgPSAyLCBjb250ZXh0X2RhdGEgPSBbXSwgY29udGV4dF9kYXRhX3ZhbCA9IDAsIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDAsIGlpO1xuICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IHVuY29tcHJlc3NlZC5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnRleHRfYyA9IHVuY29tcHJlc3NlZC5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5LCBjb250ZXh0X2MpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X2NdID0gY29udGV4dF9kaWN0U2l6ZSsrO1xuICAgICAgICAgICAgICBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZVtjb250ZXh0X2NdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHRfd2MgPSBjb250ZXh0X3cgKyBjb250ZXh0X2M7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHRfZGljdGlvbmFyeSwgY29udGV4dF93YykpIHtcbiAgICAgICAgICAgICAgY29udGV4dF93ID0gY29udGV4dF93YztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGUsIGNvbnRleHRfdykpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dF93LmNoYXJDb2RlQXQoMCkgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0X251bUJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxIHwgdmFsdWUgJiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHRfbnVtQml0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF93XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3ddO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0X251bUJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfd2NdID0gY29udGV4dF9kaWN0U2l6ZSsrO1xuICAgICAgICAgICAgICBjb250ZXh0X3cgPSBTdHJpbmcoY29udGV4dF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRleHRfdyAhPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZSwgY29udGV4dF93KSkge1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF93LmNoYXJDb2RlQXQoMCkgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDE7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29udGV4dF93LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXIgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0X251bUJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IGNvbnRleHRfZGF0YV92YWwgPDwgMSB8IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxIHwgdmFsdWUgJiAxO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF93XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfd107XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0X251bUJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZSAmIDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4tLTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICAgICAgY29udGV4dF9udW1CaXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gMjtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dF9udW1CaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSBjb250ZXh0X2RhdGFfdmFsIDw8IDEgfCB2YWx1ZSAmIDE7XG4gICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyIC0gMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gY29udGV4dF9kYXRhX3ZhbCA8PCAxO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhciAtIDEpIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRfZGF0YS5qb2luKFwiXCIpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvbXByZXNzOiBmdW5jdGlvbihjb21wcmVzc2VkKSB7XG4gICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIGlmIChjb21wcmVzc2VkID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gTFpTdHJpbmcyLl9kZWNvbXByZXNzKGNvbXByZXNzZWQubGVuZ3RoLCAzMjc2OCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZGVjb21wcmVzczogZnVuY3Rpb24obGVuZ3RoLCByZXNldFZhbHVlLCBnZXROZXh0VmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGljdGlvbmFyeSA9IFtdLCBuZXh0LCBlbmxhcmdlSW4gPSA0LCBkaWN0U2l6ZSA9IDQsIG51bUJpdHMgPSAzLCBlbnRyeSA9IFwiXCIsIHJlc3VsdCA9IFtdLCBpLCB3LCBiaXRzLCByZXNiLCBtYXhwb3dlciwgcG93ZXIsIGMsIGRhdGEgPSB7IHZhbDogZ2V0TmV4dFZhbHVlKDApLCBwb3NpdGlvbjogcmVzZXRWYWx1ZSwgaW5kZXg6IDEgfTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICAgICAgICBkaWN0aW9uYXJ5W2ldID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLCAyKTtcbiAgICAgICAgICBwb3dlciA9IDE7XG4gICAgICAgICAgd2hpbGUgKHBvd2VyICE9IG1heHBvd2VyKSB7XG4gICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IChyZXNiID4gMCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAobmV4dCA9IGJpdHMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwgOCk7XG4gICAgICAgICAgICAgIHBvd2VyID0gMTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvd2VyICE9IG1heHBvd2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjID0gZihiaXRzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsIDE2KTtcbiAgICAgICAgICAgICAgcG93ZXIgPSAxO1xuICAgICAgICAgICAgICB3aGlsZSAocG93ZXIgIT0gbWF4cG93ZXIpIHtcbiAgICAgICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaXRzIHw9IChyZXNiID4gMCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGMgPSBmKGJpdHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpY3Rpb25hcnlbM10gPSBjO1xuICAgICAgICAgIHcgPSBjO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5pbmRleCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLCBudW1CaXRzKTtcbiAgICAgICAgICAgIHBvd2VyID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChwb3dlciAhPSBtYXhwb3dlcikge1xuICAgICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiaXRzIHw9IChyZXNiID4gMCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgICBwb3dlciA8PD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoYyA9IGJpdHMpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwgOCk7XG4gICAgICAgICAgICAgICAgcG93ZXIgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3dlciAhPSBtYXhwb3dlcikge1xuICAgICAgICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2RpY3RTaXplKytdID0gZihiaXRzKTtcbiAgICAgICAgICAgICAgICBjID0gZGljdFNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VJbi0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLCAxNik7XG4gICAgICAgICAgICAgICAgcG93ZXIgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3dlciAhPSBtYXhwb3dlcikge1xuICAgICAgICAgICAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPj49IDE7XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbCA9IGdldE5leHRWYWx1ZShkYXRhLmluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYml0cyB8PSAocmVzYiA+IDAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2RpY3RTaXplKytdID0gZihiaXRzKTtcbiAgICAgICAgICAgICAgICBjID0gZGljdFNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VJbi0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgICAgIGVubGFyZ2VJbiA9IE1hdGgucG93KDIsIG51bUJpdHMpO1xuICAgICAgICAgICAgICBudW1CaXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGljdGlvbmFyeVtjXSkge1xuICAgICAgICAgICAgICBlbnRyeSA9IGRpY3Rpb25hcnlbY107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gZGljdFNpemUpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHcgKyB3LmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IHcgKyBlbnRyeS5jaGFyQXQoMCk7XG4gICAgICAgICAgICBlbmxhcmdlSW4tLTtcbiAgICAgICAgICAgIHcgPSBlbnRyeTtcbiAgICAgICAgICAgIGlmIChlbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgICAgICBlbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBudW1CaXRzKTtcbiAgICAgICAgICAgICAgbnVtQml0cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBMWlN0cmluZzI7XG4gICAgfSgpO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZmFsc2UpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIExaU3RyaW5nO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlMiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUyICE9IG51bGwpIHtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IExaU3RyaW5nO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jb2xvci1uYW1lQDEuMS40L25vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzXG52YXIgcmVxdWlyZV9jb2xvcl9uYW1lID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLW5hbWVAMS4xLjQvbm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgXCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxuICAgICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuICAgICAgXCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgICBcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxuICAgICAgXCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICBcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICAgIFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcbiAgICAgIFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuICAgICAgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgICBcImJsdWVcIjogWzAsIDAsIDI1NV0sXG4gICAgICBcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG4gICAgICBcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXG4gICAgICBcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXG4gICAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcbiAgICAgIFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxuICAgICAgXCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXG4gICAgICBcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuICAgICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXG4gICAgICBcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcbiAgICAgIFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuICAgICAgXCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgICBcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxuICAgICAgXCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuICAgICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxuICAgICAgXCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXG4gICAgICBcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcbiAgICAgIFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgXCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxuICAgICAgXCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuICAgICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxuICAgICAgXCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXG4gICAgICBcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG4gICAgICBcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXG4gICAgICBcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxuICAgICAgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuICAgICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXG4gICAgICBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxuICAgICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcbiAgICAgIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxuICAgICAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXG4gICAgICBcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxuICAgICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxuICAgICAgXCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgIFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICBcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXG4gICAgICBcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxuICAgICAgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXG4gICAgICBcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcbiAgICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcbiAgICAgIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgICBcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcbiAgICAgIFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxuICAgICAgXCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgIFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXG4gICAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuICAgICAgXCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgIFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxuICAgICAgXCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXG4gICAgICBcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXG4gICAgICBcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgIFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxuICAgICAgXCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgICBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxuICAgICAgXCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcbiAgICAgIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcbiAgICAgIFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICAgIFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgICBcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICAgIFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgIFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgICBcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICBcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXG4gICAgICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcbiAgICAgIFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcbiAgICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICAgIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgICBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICAgIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxuICAgICAgXCJsaW1lXCI6IFswLCAyNTUsIDBdLFxuICAgICAgXCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcbiAgICAgIFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxuICAgICAgXCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgICBcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcbiAgICAgIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgICBcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXG4gICAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcbiAgICAgIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcbiAgICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXG4gICAgICBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXG4gICAgICBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcbiAgICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxuICAgICAgXCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcbiAgICAgIFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcbiAgICAgIFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICAgIFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxuICAgICAgXCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgICBcIm5hdnlcIjogWzAsIDAsIDEyOF0sXG4gICAgICBcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxuICAgICAgXCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxuICAgICAgXCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXG4gICAgICBcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxuICAgICAgXCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxuICAgICAgXCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxuICAgICAgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcbiAgICAgIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxuICAgICAgXCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICAgIFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcbiAgICAgIFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgICBcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxuICAgICAgXCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICAgIFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXG4gICAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXG4gICAgICBcInJlZFwiOiBbMjU1LCAwLCAwXSxcbiAgICAgIFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcbiAgICAgIFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxuICAgICAgXCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxuICAgICAgXCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuICAgICAgXCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxuICAgICAgXCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxuICAgICAgXCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgICBcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxuICAgICAgXCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxuICAgICAgXCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICAgIFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxuICAgICAgXCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgICAgXCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgICAgXCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcbiAgICAgIFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcbiAgICAgIFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuICAgICAgXCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxuICAgICAgXCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXG4gICAgICBcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuICAgICAgXCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcbiAgICAgIFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxuICAgICAgXCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuICAgICAgXCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgICBcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgIFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgICBcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxuICAgICAgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItY29udmVydEAyLjAuMS9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qc1xudmFyIHJlcXVpcmVfY29udmVyc2lvbnMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItY29udmVydEAyLjAuMS9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY3NzS2V5d29yZHMgPSByZXF1aXJlX2NvbG9yX25hbWUoKTtcbiAgICB2YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3NzS2V5d29yZHMpKSB7XG4gICAgICByZXZlcnNlS2V5d29yZHNbY3NzS2V5d29yZHNba2V5XV0gPSBrZXk7XG4gICAgfVxuICAgIHZhciBjb252ZXJ0ID0ge1xuICAgICAgcmdiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwicmdiXCIgfSxcbiAgICAgIGhzbDogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImhzbFwiIH0sXG4gICAgICBoc3Y6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc3ZcIiB9LFxuICAgICAgaHdiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwiaHdiXCIgfSxcbiAgICAgIGNteWs6IHsgY2hhbm5lbHM6IDQsIGxhYmVsczogXCJjbXlrXCIgfSxcbiAgICAgIHh5ejogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInh5elwiIH0sXG4gICAgICBsYWI6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJsYWJcIiB9LFxuICAgICAgbGNoOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwibGNoXCIgfSxcbiAgICAgIGhleDogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJoZXhcIl0gfSxcbiAgICAgIGtleXdvcmQ6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wia2V5d29yZFwiXSB9LFxuICAgICAgYW5zaTE2OiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImFuc2kxNlwiXSB9LFxuICAgICAgYW5zaTI1NjogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJhbnNpMjU2XCJdIH0sXG4gICAgICBoY2c6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogW1wiaFwiLCBcImNcIiwgXCJnXCJdIH0sXG4gICAgICBhcHBsZTogeyBjaGFubmVsczogMywgbGFiZWxzOiBbXCJyMTZcIiwgXCJnMTZcIiwgXCJiMTZcIl0gfSxcbiAgICAgIGdyYXk6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiZ3JheVwiXSB9XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBjb252ZXJ0O1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoY29udmVydCkpIHtcbiAgICAgIGlmICghKFwiY2hhbm5lbHNcIiBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogXCIgKyBtb2RlbCk7XG4gICAgICB9XG4gICAgICBpZiAoIShcImxhYmVsc1wiIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiBcIiArIG1vZGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb252ZXJ0W21vZGVsXS5sYWJlbHMubGVuZ3RoICE9PSBjb252ZXJ0W21vZGVsXS5jaGFubmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6IFwiICsgbW9kZWwpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjaGFubmVscywgbGFiZWxzIH0gPSBjb252ZXJ0W21vZGVsXTtcbiAgICAgIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcbiAgICAgIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sIFwiY2hhbm5lbHNcIiwgeyB2YWx1ZTogY2hhbm5lbHMgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sIFwibGFiZWxzXCIsIHsgdmFsdWU6IGxhYmVscyB9KTtcbiAgICB9XG4gICAgY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgICBjb25zdCBtaW4yID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICBjb25zdCBtYXgyID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICBjb25zdCBkZWx0YSA9IG1heDIgLSBtaW4yO1xuICAgICAgbGV0IGg7XG4gICAgICBsZXQgcztcbiAgICAgIGlmIChtYXgyID09PSBtaW4yKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyID09PSBtYXgyKSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heDIpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IG1heDIpIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuICAgICAgY29uc3QgbCA9IChtaW4yICsgbWF4MikgLyAyO1xuICAgICAgaWYgKG1heDIgPT09IG1pbjIpIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIChtYXgyICsgbWluMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gZGVsdGEgLyAoMiAtIG1heDIgLSBtaW4yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGxldCByZGlmO1xuICAgICAgbGV0IGdkaWY7XG4gICAgICBsZXQgYmRpZjtcbiAgICAgIGxldCBoO1xuICAgICAgbGV0IHM7XG4gICAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgICBjb25zdCB2ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICBjb25zdCBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgY29uc3QgZGlmZmMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuICAgICAgfSwgXCJkaWZmY1wiKTtcbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgICBzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBkaWZmIC8gdjtcbiAgICAgICAgcmRpZiA9IGRpZmZjKHIpO1xuICAgICAgICBnZGlmID0gZGlmZmMoZyk7XG4gICAgICAgIGJkaWYgPSBkaWZmYyhiKTtcbiAgICAgICAgaWYgKHIgPT09IHYpIHtcbiAgICAgICAgICBoID0gYmRpZiAtIGdkaWY7XG4gICAgICAgIH0gZWxzZSBpZiAoZyA9PT0gdikge1xuICAgICAgICAgIGggPSAxIC8gMyArIHJkaWYgLSBiZGlmO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IHYpIHtcbiAgICAgICAgICBoID0gMiAvIDMgKyBnZGlmIC0gcmRpZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICBoICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICAgICAgICBoIC09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGggKiAzNjAsXG4gICAgICAgIHMgKiAxMDAsXG4gICAgICAgIHYgKiAxMDBcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGNvbnN0IHIgPSByZ2JbMF07XG4gICAgICBjb25zdCBnID0gcmdiWzFdO1xuICAgICAgbGV0IGIgPSByZ2JbMl07XG4gICAgICBjb25zdCBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG4gICAgICBjb25zdCB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcbiAgICAgIGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcbiAgICAgIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgICBjb25zdCBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gICAgICBjb25zdCBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICBjb25zdCBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICBjb25zdCB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG4gICAgICByZXR1cm4gKHhbMF0gLSB5WzBdKSAqKiAyICsgKHhbMV0gLSB5WzFdKSAqKiAyICsgKHhbMl0gLSB5WzJdKSAqKiAyO1xuICAgIH1cbiAgICBfX25hbWUoY29tcGFyYXRpdmVEaXN0YW5jZSwgXCJjb21wYXJhdGl2ZURpc3RhbmNlXCIpO1xuICAgIGNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGNvbnN0IHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG4gICAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2VkO1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIGxldCBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG4gICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2YgT2JqZWN0LmtleXMoY3NzS2V5d29yZHMpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3NzS2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gY29tcGFyYXRpdmVEaXN0YW5jZShyZ2IsIHZhbHVlKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICBjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuICAgIH07XG4gICAgY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICAgIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbiAgICB9O1xuICAgIGNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgbGV0IHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICBsZXQgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIGxldCBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgciA9IHIgPiAwLjA0MDQ1ID8gKChyICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IHIgLyAxMi45MjtcbiAgICAgIGcgPSBnID4gMC4wNDA0NSA/ICgoZyArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQgOiBnIC8gMTIuOTI7XG4gICAgICBiID0gYiA+IDAuMDQwNDUgPyAoKGIgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40IDogYiAvIDEyLjkyO1xuICAgICAgY29uc3QgeCA9IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNTtcbiAgICAgIGNvbnN0IHkgPSByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjI7XG4gICAgICBjb25zdCB6ID0gciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1O1xuICAgICAgcmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgY29uc3QgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG4gICAgICBsZXQgeCA9IHh5elswXTtcbiAgICAgIGxldCB5ID0geHl6WzFdO1xuICAgICAgbGV0IHogPSB4eXpbMl07XG4gICAgICB4IC89IDk1LjA0NztcbiAgICAgIHkgLz0gMTAwO1xuICAgICAgeiAvPSAxMDguODgzO1xuICAgICAgeCA9IHggPiA4ODU2ZS02ID8geCAqKiAoMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTY7XG4gICAgICB5ID0geSA+IDg4NTZlLTYgPyB5ICoqICgxIC8gMykgOiA3Ljc4NyAqIHkgKyAxNiAvIDExNjtcbiAgICAgIHogPSB6ID4gODg1NmUtNiA/IHogKiogKDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2O1xuICAgICAgY29uc3QgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgIGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgY29uc3QgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICByZXR1cm4gW2wsIGEsIGJdO1xuICAgIH07XG4gICAgY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24oaHNsKSB7XG4gICAgICBjb25zdCBoID0gaHNsWzBdIC8gMzYwO1xuICAgICAgY29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgICBsZXQgdDI7XG4gICAgICBsZXQgdDM7XG4gICAgICBsZXQgdmFsO1xuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgdmFsID0gbCAqIDI1NTtcbiAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgICAgIH1cbiAgICAgIGlmIChsIDwgMC41KSB7XG4gICAgICAgIHQyID0gbCAqICgxICsgcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gICAgICB9XG4gICAgICBjb25zdCB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuICAgICAgICBpZiAodDMgPCAwKSB7XG4gICAgICAgICAgdDMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodDMgPiAxKSB7XG4gICAgICAgICAgdDMtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoNiAqIHQzIDwgMSkge1xuICAgICAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgICAgICB9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcbiAgICAgICAgICB2YWwgPSB0MjtcbiAgICAgICAgfSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG4gICAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHQxO1xuICAgICAgICB9XG4gICAgICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcbiAgICBjb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbihoc2wpIHtcbiAgICAgIGNvbnN0IGggPSBoc2xbMF07XG4gICAgICBsZXQgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIGxldCBsID0gaHNsWzJdIC8gMTAwO1xuICAgICAgbGV0IHNtaW4gPSBzO1xuICAgICAgY29uc3QgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuICAgICAgbCAqPSAyO1xuICAgICAgcyAqPSBsIDw9IDEgPyBsIDogMiAtIGw7XG4gICAgICBzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcbiAgICAgIGNvbnN0IHYgPSAobCArIHMpIC8gMjtcbiAgICAgIGNvbnN0IHN2ID0gbCA9PT0gMCA/IDIgKiBzbWluIC8gKGxtaW4gKyBzbWluKSA6IDIgKiBzIC8gKGwgKyBzKTtcbiAgICAgIHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24oaHN2KSB7XG4gICAgICBjb25zdCBoID0gaHN2WzBdIC8gNjA7XG4gICAgICBjb25zdCBzID0gaHN2WzFdIC8gMTAwO1xuICAgICAgbGV0IHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgICBjb25zdCBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuICAgICAgY29uc3QgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuICAgICAgY29uc3QgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuICAgICAgY29uc3QgcSA9IDI1NSAqIHYgKiAoMSAtIHMgKiBmKTtcbiAgICAgIGNvbnN0IHQgPSAyNTUgKiB2ICogKDEgLSBzICogKDEgLSBmKSk7XG4gICAgICB2ICo9IDI1NTtcbiAgICAgIHN3aXRjaCAoaGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBbdiwgdCwgcF07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbcCwgcSwgdl07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uKGhzdikge1xuICAgICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICAgIGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgICBjb25zdCB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgY29uc3Qgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuICAgICAgbGV0IHNsO1xuICAgICAgbGV0IGw7XG4gICAgICBsID0gKDIgLSBzKSAqIHY7XG4gICAgICBjb25zdCBsbWluID0gKDIgLSBzKSAqIHZtaW47XG4gICAgICBzbCA9IHMgKiB2bWluO1xuICAgICAgc2wgLz0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuICAgICAgc2wgPSBzbCB8fCAwO1xuICAgICAgbCAvPSAyO1xuICAgICAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbihod2IpIHtcbiAgICAgIGNvbnN0IGggPSBod2JbMF0gLyAzNjA7XG4gICAgICBsZXQgd2ggPSBod2JbMV0gLyAxMDA7XG4gICAgICBsZXQgYmwgPSBod2JbMl0gLyAxMDA7XG4gICAgICBjb25zdCByYXRpbyA9IHdoICsgYmw7XG4gICAgICBsZXQgZjtcbiAgICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgICAgd2ggLz0gcmF0aW87XG4gICAgICAgIGJsIC89IHJhdGlvO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICAgICAgY29uc3QgdiA9IDEgLSBibDtcbiAgICAgIGYgPSA2ICogaCAtIGk7XG4gICAgICBpZiAoKGkgJiAxKSAhPT0gMCkge1xuICAgICAgICBmID0gMSAtIGY7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gd2ggKyBmICogKHYgLSB3aCk7XG4gICAgICBsZXQgcjtcbiAgICAgIGxldCBnO1xuICAgICAgbGV0IGI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IG47XG4gICAgICAgICAgYiA9IHdoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IG47XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHdoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHdoO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgciA9IHdoO1xuICAgICAgICAgIGcgPSBuO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IG47XG4gICAgICAgICAgZyA9IHdoO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHdoO1xuICAgICAgICAgIGIgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbiAgICB9O1xuICAgIGNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbihjbXlrKSB7XG4gICAgICBjb25zdCBjID0gY215a1swXSAvIDEwMDtcbiAgICAgIGNvbnN0IG0gPSBjbXlrWzFdIC8gMTAwO1xuICAgICAgY29uc3QgeSA9IGNteWtbMl0gLyAxMDA7XG4gICAgICBjb25zdCBrID0gY215a1szXSAvIDEwMDtcbiAgICAgIGNvbnN0IHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgICAgIGNvbnN0IGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcbiAgICAgIGNvbnN0IGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcbiAgICBjb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbih4eXopIHtcbiAgICAgIGNvbnN0IHggPSB4eXpbMF0gLyAxMDA7XG4gICAgICBjb25zdCB5ID0geHl6WzFdIC8gMTAwO1xuICAgICAgY29uc3QgeiA9IHh5elsyXSAvIDEwMDtcbiAgICAgIGxldCByO1xuICAgICAgbGV0IGc7XG4gICAgICBsZXQgYjtcbiAgICAgIHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcbiAgICAgIGcgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICAgICAgYiA9IHggKiAwLjA1NTcgKyB5ICogLTAuMjA0ICsgeiAqIDEuMDU3O1xuICAgICAgciA9IHIgPiAzMTMwOGUtNyA/IDEuMDU1ICogciAqKiAoMSAvIDIuNCkgLSAwLjA1NSA6IHIgKiAxMi45MjtcbiAgICAgIGcgPSBnID4gMzEzMDhlLTcgPyAxLjA1NSAqIGcgKiogKDEgLyAyLjQpIC0gMC4wNTUgOiBnICogMTIuOTI7XG4gICAgICBiID0gYiA+IDMxMzA4ZS03ID8gMS4wNTUgKiBiICoqICgxIC8gMi40KSAtIDAuMDU1IDogYiAqIDEyLjkyO1xuICAgICAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgICAgIGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG4gICAgICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbiAgICB9O1xuICAgIGNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uKHh5eikge1xuICAgICAgbGV0IHggPSB4eXpbMF07XG4gICAgICBsZXQgeSA9IHh5elsxXTtcbiAgICAgIGxldCB6ID0geHl6WzJdO1xuICAgICAgeCAvPSA5NS4wNDc7XG4gICAgICB5IC89IDEwMDtcbiAgICAgIHogLz0gMTA4Ljg4MztcbiAgICAgIHggPSB4ID4gODg1NmUtNiA/IHggKiogKDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICAgICAgeSA9IHkgPiA4ODU2ZS02ID8geSAqKiAoMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gICAgICB6ID0geiA+IDg4NTZlLTYgPyB6ICoqICgxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNjtcbiAgICAgIGNvbnN0IGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICBjb25zdCBhID0gNTAwICogKHggLSB5KTtcbiAgICAgIGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuICAgIGNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uKGxhYikge1xuICAgICAgY29uc3QgbCA9IGxhYlswXTtcbiAgICAgIGNvbnN0IGEgPSBsYWJbMV07XG4gICAgICBjb25zdCBiID0gbGFiWzJdO1xuICAgICAgbGV0IHg7XG4gICAgICBsZXQgeTtcbiAgICAgIGxldCB6O1xuICAgICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgICAgeCA9IGEgLyA1MDAgKyB5O1xuICAgICAgeiA9IHkgLSBiIC8gMjAwO1xuICAgICAgY29uc3QgeTIgPSB5ICoqIDM7XG4gICAgICBjb25zdCB4MiA9IHggKiogMztcbiAgICAgIGNvbnN0IHoyID0geiAqKiAzO1xuICAgICAgeSA9IHkyID4gODg1NmUtNiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICAgIHggPSB4MiA+IDg4NTZlLTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgICB6ID0gejIgPiA4ODU2ZS02ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgICAgeCAqPSA5NS4wNDc7XG4gICAgICB5ICo9IDEwMDtcbiAgICAgIHogKj0gMTA4Ljg4MztcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfTtcbiAgICBjb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbihsYWIpIHtcbiAgICAgIGNvbnN0IGwgPSBsYWJbMF07XG4gICAgICBjb25zdCBhID0gbGFiWzFdO1xuICAgICAgY29uc3QgYiA9IGxhYlsyXTtcbiAgICAgIGxldCBoO1xuICAgICAgY29uc3QgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICAgICAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuICAgIGNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uKGxjaCkge1xuICAgICAgY29uc3QgbCA9IGxjaFswXTtcbiAgICAgIGNvbnN0IGMgPSBsY2hbMV07XG4gICAgICBjb25zdCBoID0gbGNoWzJdO1xuICAgICAgY29uc3QgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gICAgICBjb25zdCBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgICAgIGNvbnN0IGIgPSBjICogTWF0aC5zaW4oaHIpO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuICAgIGNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uKGFyZ3MsIHNhdHVyYXRpb24gPSBudWxsKSB7XG4gICAgICBjb25zdCBbciwgZywgYl0gPSBhcmdzO1xuICAgICAgbGV0IHZhbHVlID0gc2F0dXJhdGlvbiA9PT0gbnVsbCA/IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXSA6IHNhdHVyYXRpb247XG4gICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgfVxuICAgICAgbGV0IGFuc2kgPSAzMCArIChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIgfCBNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEgfCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICBhbnNpICs9IDYwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFuc2k7XG4gICAgfTtcbiAgICBjb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgY29uc3QgciA9IGFyZ3NbMF07XG4gICAgICBjb25zdCBnID0gYXJnc1sxXTtcbiAgICAgIGNvbnN0IGIgPSBhcmdzWzJdO1xuICAgICAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuICAgICAgICBpZiAociA8IDgpIHtcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPiAyNDgpIHtcbiAgICAgICAgICByZXR1cm4gMjMxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChyIC0gOCkgLyAyNDcgKiAyNCkgKyAyMzI7XG4gICAgICB9XG4gICAgICBjb25zdCBhbnNpID0gMTYgKyAzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpICsgNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpICsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG4gICAgICByZXR1cm4gYW5zaTtcbiAgICB9O1xuICAgIGNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGxldCBjb2xvciA9IGFyZ3MgJSAxMDtcbiAgICAgIGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuICAgICAgICBpZiAoYXJncyA+IDUwKSB7XG4gICAgICAgICAgY29sb3IgKz0gMy41O1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuICAgICAgICByZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuICAgICAgfVxuICAgICAgY29uc3QgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG4gICAgICBjb25zdCByID0gKGNvbG9yICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgY29uc3QgZyA9IChjb2xvciA+PiAxICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgY29uc3QgYiA9IChjb2xvciA+PiAyICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICBpZiAoYXJncyA+PSAyMzIpIHtcbiAgICAgICAgY29uc3QgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcbiAgICAgICAgcmV0dXJuIFtjLCBjLCBjXTtcbiAgICAgIH1cbiAgICAgIGFyZ3MgLT0gMTY7XG4gICAgICBsZXQgcmVtO1xuICAgICAgY29uc3QgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG4gICAgICBjb25zdCBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcbiAgICAgIGNvbnN0IGIgPSByZW0gJSA2IC8gNSAqIDI1NTtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICBjb25zdCBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMjU1KSA8PCAxNikgKyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAyNTUpIDw8IDgpICsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAyNTUpO1xuICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBcIjAwMDAwMFwiLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbiAgICB9O1xuICAgIGNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgbGV0IGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG4gICAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNoYXIgKyBjaGFyO1xuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG4gICAgICBjb25zdCByID0gaW50ZWdlciA+PiAxNiAmIDI1NTtcbiAgICAgIGNvbnN0IGcgPSBpbnRlZ2VyID4+IDggJiAyNTU7XG4gICAgICBjb25zdCBiID0gaW50ZWdlciAmIDI1NTtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbihyZ2IpIHtcbiAgICAgIGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICBjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuICAgICAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICAgIGNvbnN0IG1heDIgPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG4gICAgICBjb25zdCBtaW4yID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuICAgICAgY29uc3QgY2hyb21hID0gbWF4MiAtIG1pbjI7XG4gICAgICBsZXQgZ3JheXNjYWxlO1xuICAgICAgbGV0IGh1ZTtcbiAgICAgIGlmIChjaHJvbWEgPCAxKSB7XG4gICAgICAgIGdyYXlzY2FsZSA9IG1pbjIgLyAoMSAtIGNocm9tYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmF5c2NhbGUgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGNocm9tYSA8PSAwKSB7XG4gICAgICAgIGh1ZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1heDIgPT09IHIpIHtcbiAgICAgICAgaHVlID0gKGcgLSBiKSAvIGNocm9tYSAlIDY7XG4gICAgICB9IGVsc2UgaWYgKG1heDIgPT09IGcpIHtcbiAgICAgICAgaHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYTtcbiAgICAgIH1cbiAgICAgIGh1ZSAvPSA2O1xuICAgICAgaHVlICU9IDE7XG4gICAgICByZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5oc2wuaGNnID0gZnVuY3Rpb24oaHNsKSB7XG4gICAgICBjb25zdCBzID0gaHNsWzFdIC8gMTAwO1xuICAgICAgY29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICAgIGNvbnN0IGMgPSBsIDwgMC41ID8gMiAqIHMgKiBsIDogMiAqIHMgKiAoMSAtIGwpO1xuICAgICAgbGV0IGYgPSAwO1xuICAgICAgaWYgKGMgPCAxKSB7XG4gICAgICAgIGYgPSAobCAtIDAuNSAqIGMpIC8gKDEgLSBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uKGhzdikge1xuICAgICAgY29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICAgIGNvbnN0IHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgICBjb25zdCBjID0gcyAqIHY7XG4gICAgICBsZXQgZiA9IDA7XG4gICAgICBpZiAoYyA8IDEpIHtcbiAgICAgICAgZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24oaGNnKSB7XG4gICAgICBjb25zdCBoID0gaGNnWzBdIC8gMzYwO1xuICAgICAgY29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVyZSA9IFswLCAwLCAwXTtcbiAgICAgIGNvbnN0IGhpID0gaCAlIDEgKiA2O1xuICAgICAgY29uc3QgdiA9IGhpICUgMTtcbiAgICAgIGNvbnN0IHcgPSAxIC0gdjtcbiAgICAgIGxldCBtZyA9IDA7XG4gICAgICBzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwdXJlWzBdID0gMTtcbiAgICAgICAgICBwdXJlWzFdID0gdjtcbiAgICAgICAgICBwdXJlWzJdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHB1cmVbMF0gPSB3O1xuICAgICAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgICAgIHB1cmVbMl0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcHVyZVswXSA9IDA7XG4gICAgICAgICAgcHVyZVsxXSA9IDE7XG4gICAgICAgICAgcHVyZVsyXSA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXJlWzBdID0gMDtcbiAgICAgICAgICBwdXJlWzFdID0gdztcbiAgICAgICAgICBwdXJlWzJdID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1cmVbMF0gPSB2O1xuICAgICAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgICAgIHB1cmVbMl0gPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1cmVbMF0gPSAxO1xuICAgICAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgICAgIHB1cmVbMl0gPSB3O1xuICAgICAgfVxuICAgICAgbWcgPSAoMSAtIGMpICogZztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcbiAgICAgICAgKGMgKiBwdXJlWzFdICsgbWcpICogMjU1LFxuICAgICAgICAoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbihoY2cpIHtcbiAgICAgIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICBjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgY29uc3QgdiA9IGMgKyBnICogKDEgLSBjKTtcbiAgICAgIGxldCBmID0gMDtcbiAgICAgIGlmICh2ID4gMCkge1xuICAgICAgICBmID0gYyAvIHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbihoY2cpIHtcbiAgICAgIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICBjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgY29uc3QgbCA9IGcgKiAoMSAtIGMpICsgMC41ICogYztcbiAgICAgIGxldCBzID0gMDtcbiAgICAgIGlmIChsID4gMCAmJiBsIDwgMC41KSB7XG4gICAgICAgIHMgPSBjIC8gKDIgKiBsKTtcbiAgICAgIH0gZWxzZSBpZiAobCA+PSAwLjUgJiYgbCA8IDEpIHtcbiAgICAgICAgcyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG4gICAgY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24oaGNnKSB7XG4gICAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgY29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIGNvbnN0IHYgPSBjICsgZyAqICgxIC0gYyk7XG4gICAgICByZXR1cm4gW2hjZ1swXSwgKHYgLSBjKSAqIDEwMCwgKDEgLSB2KSAqIDEwMF07XG4gICAgfTtcbiAgICBjb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbihod2IpIHtcbiAgICAgIGNvbnN0IHcgPSBod2JbMV0gLyAxMDA7XG4gICAgICBjb25zdCBiID0gaHdiWzJdIC8gMTAwO1xuICAgICAgY29uc3QgdiA9IDEgLSBiO1xuICAgICAgY29uc3QgYyA9IHYgLSB3O1xuICAgICAgbGV0IGcgPSAwO1xuICAgICAgaWYgKGMgPCAxKSB7XG4gICAgICAgIGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbiAgICB9O1xuICAgIGNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24oYXBwbGUpIHtcbiAgICAgIHJldHVybiBbYXBwbGVbMF0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMV0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMl0gLyA2NTUzNSAqIDI1NV07XG4gICAgfTtcbiAgICBjb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUgKiA2NTUzNSwgcmdiWzFdIC8gMjU1ICogNjU1MzUsIHJnYlsyXSAvIDI1NSAqIDY1NTM1XTtcbiAgICB9O1xuICAgIGNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xuICAgIH07XG4gICAgY29udmVydC5ncmF5LmhzbCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiBbMCwgMCwgYXJnc1swXV07XG4gICAgfTtcbiAgICBjb252ZXJ0LmdyYXkuaHN2ID0gY29udmVydC5ncmF5LmhzbDtcbiAgICBjb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24oZ3JheSkge1xuICAgICAgcmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xuICAgIH07XG4gICAgY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbihncmF5KSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xuICAgIH07XG4gICAgY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uKGdyYXkpIHtcbiAgICAgIHJldHVybiBbZ3JheVswXSwgMCwgMF07XG4gICAgfTtcbiAgICBjb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24oZ3JheSkge1xuICAgICAgY29uc3QgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDI1NTtcbiAgICAgIGNvbnN0IGludGVnZXIgPSAodmFsIDw8IDE2KSArICh2YWwgPDwgOCkgKyB2YWw7XG4gICAgICBjb25zdCBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIFwiMDAwMDAwXCIuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xuICAgIH07XG4gICAgY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uKHJnYikge1xuICAgICAgY29uc3QgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuICAgICAgcmV0dXJuIFt2YWwgLyAyNTUgKiAxMDBdO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItY29udmVydEAyLjAuMS9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9yb3V0ZS5qc1xudmFyIHJlcXVpcmVfcm91dGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItY29udmVydEAyLjAuMS9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9yb3V0ZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlX2NvbnZlcnNpb25zKCk7XG4gICAgZnVuY3Rpb24gYnVpbGRHcmFwaCgpIHtcbiAgICAgIGNvbnN0IGdyYXBoID0ge307XG4gICAgICBjb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG4gICAgICBmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGdyYXBoW21vZGVsc1tpXV0gPSB7XG4gICAgICAgICAgZGlzdGFuY2U6IC0xLFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRHcmFwaCwgXCJidWlsZEdyYXBoXCIpO1xuICAgIGZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcbiAgICAgIGNvbnN0IGdyYXBoID0gYnVpbGRHcmFwaCgpO1xuICAgICAgY29uc3QgcXVldWUgPSBbZnJvbU1vZGVsXTtcbiAgICAgIGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcXVldWUucG9wKCk7XG4gICAgICAgIGNvbnN0IGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcbiAgICAgICAgZm9yIChsZXQgbGVuID0gYWRqYWNlbnRzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFkamFjZW50ID0gYWRqYWNlbnRzW2ldO1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBncmFwaFthZGphY2VudF07XG4gICAgICAgICAgaWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG4gICAgICAgICAgICBub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcXVldWUudW5zaGlmdChhZGphY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxuICAgIF9fbmFtZShkZXJpdmVCRlMsIFwiZGVyaXZlQkZTXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiB0byhmcm9tKGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShsaW5rLCBcImxpbmtcIik7XG4gICAgZnVuY3Rpb24gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpIHtcbiAgICAgIGNvbnN0IHBhdGg3ID0gW2dyYXBoW3RvTW9kZWxdLnBhcmVudCwgdG9Nb2RlbF07XG4gICAgICBsZXQgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuICAgICAgbGV0IGN1ciA9IGdyYXBoW3RvTW9kZWxdLnBhcmVudDtcbiAgICAgIHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuICAgICAgICBwYXRoNy51bnNoaWZ0KGdyYXBoW2N1cl0ucGFyZW50KTtcbiAgICAgICAgZm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG4gICAgICAgIGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuICAgICAgfVxuICAgICAgZm4uY29udmVyc2lvbiA9IHBhdGg3O1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBfX25hbWUod3JhcENvbnZlcnNpb24sIFwid3JhcENvbnZlcnNpb25cIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oZnJvbU1vZGVsKSB7XG4gICAgICBjb25zdCBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuICAgICAgY29uc3QgY29udmVyc2lvbiA9IHt9O1xuICAgICAgY29uc3QgbW9kZWxzID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuICAgICAgZm9yIChsZXQgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB0b01vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgICBjb25zdCBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udmVyc2lvbjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbG9yLWNvbnZlcnRAMi4wLjEvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanNcbnZhciByZXF1aXJlX2NvbG9yX2NvbnZlcnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29sb3ItY29udmVydEAyLjAuMS9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlX2NvbnZlcnNpb25zKCk7XG4gICAgdmFyIHJvdXRlID0gcmVxdWlyZV9yb3V0ZSgpO1xuICAgIHZhciBjb252ZXJ0ID0ge307XG4gICAgdmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcbiAgICBmdW5jdGlvbiB3cmFwUmF3KGZuKSB7XG4gICAgICBjb25zdCB3cmFwcGVkRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnMCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChhcmcwID09PSB2b2lkIDAgfHwgYXJnMCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcmcwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzID0gYXJnMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4oYXJncyk7XG4gICAgICB9LCBcIndyYXBwZWRGblwiKTtcbiAgICAgIGlmIChcImNvbnZlcnNpb25cIiBpbiBmbikge1xuICAgICAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZEZuO1xuICAgIH1cbiAgICBfX25hbWUod3JhcFJhdywgXCJ3cmFwUmF3XCIpO1xuICAgIGZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG4gICAgICBjb25zdCB3cmFwcGVkRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnMCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChhcmcwID09PSB2b2lkIDAgfHwgYXJnMCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcmcwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzID0gYXJnMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBmbihhcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBmb3IgKGxldCBsZW4gPSByZXN1bHQubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBcIndyYXBwZWRGblwiKTtcbiAgICAgIGlmIChcImNvbnZlcnNpb25cIiBpbiBmbikge1xuICAgICAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZEZuO1xuICAgIH1cbiAgICBfX25hbWUod3JhcFJvdW5kZWQsIFwid3JhcFJvdW5kZWRcIik7XG4gICAgbW9kZWxzLmZvckVhY2goKGZyb21Nb2RlbCkgPT4ge1xuICAgICAgY29udmVydFtmcm9tTW9kZWxdID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCBcImNoYW5uZWxzXCIsIHsgdmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHMgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCBcImxhYmVsc1wiLCB7IHZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmxhYmVscyB9KTtcbiAgICAgIGNvbnN0IHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG4gICAgICBjb25zdCByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG4gICAgICByb3V0ZU1vZGVscy5mb3JFYWNoKCh0b01vZGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gcm91dGVzW3RvTW9kZWxdO1xuICAgICAgICBjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZChmbik7XG4gICAgICAgIGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNvbnZlcnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYW5zaS1zdHlsZXNANC4zLjAvbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9hbnNpX3N0eWxlcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hbnNpLXN0eWxlc0A0LjMuMC9ub2RlX21vZHVsZXMvYW5zaS1zdHlsZXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHdyYXBBbnNpMTYgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmbiwgb2Zmc2V0KSA9PiAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY29kZSA9IGZuKC4uLmFyZ3MpO1xuICAgICAgcmV0dXJuIGBcXHgxQlske2NvZGUgKyBvZmZzZXR9bWA7XG4gICAgfSwgXCJ3cmFwQW5zaTE2XCIpO1xuICAgIHZhciB3cmFwQW5zaTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gZm4oLi4uYXJncyk7XG4gICAgICByZXR1cm4gYFxceDFCWyR7MzggKyBvZmZzZXR9OzU7JHtjb2RlfW1gO1xuICAgIH0sIFwid3JhcEFuc2kyNTZcIik7XG4gICAgdmFyIHdyYXBBbnNpMTZtID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZm4sIG9mZnNldCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJnYiA9IGZuKC4uLmFyZ3MpO1xuICAgICAgcmV0dXJuIGBcXHgxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmdiWzBdfTske3JnYlsxXX07JHtyZ2JbMl19bWA7XG4gICAgfSwgXCJ3cmFwQW5zaTE2bVwiKTtcbiAgICB2YXIgYW5zaTJhbnNpID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobikgPT4gbiwgXCJhbnNpMmFuc2lcIik7XG4gICAgdmFyIHJnYjJyZ2IgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChyLCBnLCBiKSA9PiBbciwgZywgYl0sIFwicmdiMnJnYlwiKTtcbiAgICB2YXIgc2V0TGF6eVByb3BlcnR5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob2JqZWN0LCBwcm9wZXJ0eSwgZ2V0KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldCgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgXCJzZXRMYXp5UHJvcGVydHlcIik7XG4gICAgdmFyIGNvbG9yQ29udmVydDtcbiAgICB2YXIgbWFrZUR5bmFtaWNTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh3cmFwLCB0YXJnZXRTcGFjZSwgaWRlbnRpdHkyLCBpc0JhY2tncm91bmQpID0+IHtcbiAgICAgIGlmIChjb2xvckNvbnZlcnQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb2xvckNvbnZlcnQgPSByZXF1aXJlX2NvbG9yX2NvbnZlcnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja2dyb3VuZCA/IDEwIDogMDtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBbc291cmNlU3BhY2UsIHN1aXRlXSBvZiBPYmplY3QuZW50cmllcyhjb2xvckNvbnZlcnQpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzb3VyY2VTcGFjZSA9PT0gXCJhbnNpMTZcIiA/IFwiYW5zaVwiIDogc291cmNlU3BhY2U7XG4gICAgICAgIGlmIChzb3VyY2VTcGFjZSA9PT0gdGFyZ2V0U3BhY2UpIHtcbiAgICAgICAgICBzdHlsZXNbbmFtZV0gPSB3cmFwKGlkZW50aXR5Miwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3VpdGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzdHlsZXNbbmFtZV0gPSB3cmFwKHN1aXRlW3RhcmdldFNwYWNlXSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9LCBcIm1ha2VEeW5hbWljU3R5bGVzXCIpO1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuICAgICAgY29uc3QgY29kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgICBtb2RpZmllcjoge1xuICAgICAgICAgIHJlc2V0OiBbMCwgMF0sXG4gICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICBkaW06IFsyLCAyMl0sXG4gICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgICAgIGhpZGRlbjogWzgsIDI4XSxcbiAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgICAgIGJsYWNrQnJpZ2h0OiBbOTAsIDM5XSxcbiAgICAgICAgICByZWRCcmlnaHQ6IFs5MSwgMzldLFxuICAgICAgICAgIGdyZWVuQnJpZ2h0OiBbOTIsIDM5XSxcbiAgICAgICAgICB5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLFxuICAgICAgICAgIGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuICAgICAgICAgIG1hZ2VudGFCcmlnaHQ6IFs5NSwgMzldLFxuICAgICAgICAgIGN5YW5CcmlnaHQ6IFs5NiwgMzldLFxuICAgICAgICAgIHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuICAgICAgICB9LFxuICAgICAgICBiZ0NvbG9yOiB7XG4gICAgICAgICAgYmdCbGFjazogWzQwLCA0OV0sXG4gICAgICAgICAgYmdSZWQ6IFs0MSwgNDldLFxuICAgICAgICAgIGJnR3JlZW46IFs0MiwgNDldLFxuICAgICAgICAgIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgICAgICAgICBiZ0JsdWU6IFs0NCwgNDldLFxuICAgICAgICAgIGJnTWFnZW50YTogWzQ1LCA0OV0sXG4gICAgICAgICAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgICAgICAgICBiZ1doaXRlOiBbNDcsIDQ5XSxcbiAgICAgICAgICBiZ0JsYWNrQnJpZ2h0OiBbMTAwLCA0OV0sXG4gICAgICAgICAgYmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSxcbiAgICAgICAgICBiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG4gICAgICAgICAgYmdZZWxsb3dCcmlnaHQ6IFsxMDMsIDQ5XSxcbiAgICAgICAgICBiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSxcbiAgICAgICAgICBiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcbiAgICAgICAgICBiZ0N5YW5CcmlnaHQ6IFsxMDYsIDQ5XSxcbiAgICAgICAgICBiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5jb2xvci5ncmF5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYmdHcmF5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDtcbiAgICAgIHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYmdHcmV5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDtcbiAgICAgIGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7XG4gICAgICAgICAgc3R5bGVzW3N0eWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBvcGVuOiBgXFx4MUJbJHtzdHlsZVswXX1tYCxcbiAgICAgICAgICAgIGNsb3NlOiBgXFx4MUJbJHtzdHlsZVsxXX1tYFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgICAgIGNvZGVzLnNldChzdHlsZVswXSwgc3R5bGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBncm91cCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIFwiY29kZXNcIiwge1xuICAgICAgICB2YWx1ZTogY29kZXMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHN0eWxlcy5jb2xvci5jbG9zZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICBzdHlsZXMuYmdDb2xvci5jbG9zZSA9IFwiXFx4MUJbNDltXCI7XG4gICAgICBzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmNvbG9yLCBcImFuc2lcIiwgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNiwgXCJhbnNpMTZcIiwgYW5zaTJhbnNpLCBmYWxzZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5jb2xvciwgXCJhbnNpMjU2XCIsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMjU2LCBcImFuc2kyNTZcIiwgYW5zaTJhbnNpLCBmYWxzZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5jb2xvciwgXCJhbnNpMTZtXCIsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTZtLCBcInJnYlwiLCByZ2IycmdiLCBmYWxzZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCBcImFuc2lcIiwgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNiwgXCJhbnNpMTZcIiwgYW5zaTJhbnNpLCB0cnVlKSk7XG4gICAgICBzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmJnQ29sb3IsIFwiYW5zaTI1NlwiLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTI1NiwgXCJhbnNpMjU2XCIsIGFuc2kyYW5zaSwgdHJ1ZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCBcImFuc2kxNm1cIiwgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNm0sIFwicmdiXCIsIHJnYjJyZ2IsIHRydWUpKTtcbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuICAgIF9fbmFtZShhc3NlbWJsZVN0eWxlcywgXCJhc3NlbWJsZVN0eWxlc1wiKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlMiwgXCJleHBvcnRzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGFzc2VtYmxlU3R5bGVzXG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzLWZsYWdANC4wLjAvbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzXG52YXIgcmVxdWlyZV9oYXNfZmxhZyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXMtZmxhZ0A0LjAuMC9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKGZsYWcsIGFyZ3YgPSBwcm9jZXNzLmFyZ3YpID0+IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGZsYWcuc3RhcnRzV2l0aChcIi1cIikgPyBcIlwiIDogZmxhZy5sZW5ndGggPT09IDEgPyBcIi1cIiA6IFwiLS1cIjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuICAgICAgY29uc3QgdGVybWluYXRvclBvc2l0aW9uID0gYXJndi5pbmRleE9mKFwiLS1cIik7XG4gICAgICByZXR1cm4gcG9zaXRpb24gIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zaXRpb24gPT09IC0xIHx8IHBvc2l0aW9uIDwgdGVybWluYXRvclBvc2l0aW9uKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cHBvcnRzLWNvbG9yQDcuMi4wL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3VwcG9ydHNfY29sb3IgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwcG9ydHMtY29sb3JANy4yLjAvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBvczMgPSByZXF1aXJlKFwib3NcIik7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoXCJ0dHlcIik7XG4gICAgdmFyIGhhc0ZsYWcgPSByZXF1aXJlX2hhc19mbGFnKCk7XG4gICAgdmFyIHsgZW52OiBlbnYyIH0gPSBwcm9jZXNzO1xuICAgIHZhciBmb3JjZUNvbG9yO1xuICAgIGlmIChoYXNGbGFnKFwibm8tY29sb3JcIikgfHwgaGFzRmxhZyhcIm5vLWNvbG9yc1wiKSB8fCBoYXNGbGFnKFwiY29sb3I9ZmFsc2VcIikgfHwgaGFzRmxhZyhcImNvbG9yPW5ldmVyXCIpKSB7XG4gICAgICBmb3JjZUNvbG9yID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc0ZsYWcoXCJjb2xvclwiKSB8fCBoYXNGbGFnKFwiY29sb3JzXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj10cnVlXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj1hbHdheXNcIikpIHtcbiAgICAgIGZvcmNlQ29sb3IgPSAxO1xuICAgIH1cbiAgICBpZiAoXCJGT1JDRV9DT0xPUlwiIGluIGVudjIpIHtcbiAgICAgIGlmIChlbnYyLkZPUkNFX0NPTE9SID09PSBcInRydWVcIikge1xuICAgICAgICBmb3JjZUNvbG9yID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZW52Mi5GT1JDRV9DT0xPUiA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGZvcmNlQ29sb3IgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yY2VDb2xvciA9IGVudjIuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwID8gMSA6IE1hdGgubWluKHBhcnNlSW50KGVudjIuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUxldmVsKGxldmVsKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGhhc0Jhc2ljOiB0cnVlLFxuICAgICAgICBoYXMyNTY6IGxldmVsID49IDIsXG4gICAgICAgIGhhczE2bTogbGV2ZWwgPj0gM1xuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKHRyYW5zbGF0ZUxldmVsLCBcInRyYW5zbGF0ZUxldmVsXCIpO1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcbiAgICAgIGlmIChmb3JjZUNvbG9yID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0ZsYWcoXCJjb2xvcj0xNm1cIikgfHwgaGFzRmxhZyhcImNvbG9yPWZ1bGxcIikgfHwgaGFzRmxhZyhcImNvbG9yPXRydWVjb2xvclwiKSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH1cbiAgICAgIGlmIChoYXNGbGFnKFwiY29sb3I9MjU2XCIpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgICAgaWYgKGhhdmVTdHJlYW0gJiYgIXN0cmVhbUlzVFRZICYmIGZvcmNlQ29sb3IgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbjIgPSBmb3JjZUNvbG9yIHx8IDA7XG4gICAgICBpZiAoZW52Mi5URVJNID09PSBcImR1bWJcIikge1xuICAgICAgICByZXR1cm4gbWluMjtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgY29uc3Qgb3NSZWxlYXNlID0gb3MzLnJlbGVhc2UoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChOdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxMDU4Nikge1xuICAgICAgICAgIHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKFwiQ0lcIiBpbiBlbnYyKSB7XG4gICAgICAgIGlmIChbXCJUUkFWSVNcIiwgXCJDSVJDTEVDSVwiLCBcIkFQUFZFWU9SXCIsIFwiR0lUTEFCX0NJXCIsIFwiR0lUSFVCX0FDVElPTlNcIiwgXCJCVUlMREtJVEVcIl0uc29tZSgoc2lnbjIpID0+IHNpZ24yIGluIGVudjIpIHx8IGVudjIuQ0lfTkFNRSA9PT0gXCJjb2Rlc2hpcFwiKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjI7XG4gICAgICB9XG4gICAgICBpZiAoXCJURUFNQ0lUWV9WRVJTSU9OXCIgaW4gZW52Mikge1xuICAgICAgICByZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52Mi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGVudjIuQ09MT1JURVJNID09PSBcInRydWVjb2xvclwiKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuICAgICAgaWYgKFwiVEVSTV9QUk9HUkFNXCIgaW4gZW52Mikge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudjIuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgXCJcIikuc3BsaXQoXCIuXCIpWzBdLCAxMCk7XG4gICAgICAgIHN3aXRjaCAoZW52Mi5URVJNX1BST0dSQU0pIHtcbiAgICAgICAgICBjYXNlIFwiaVRlcm0uYXBwXCI6XG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG4gICAgICAgICAgY2FzZSBcIkFwcGxlX1Rlcm1pbmFsXCI6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYyLlRFUk0pKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgICAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYyLlRFUk0pKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKFwiQ09MT1JURVJNXCIgaW4gZW52Mikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW4yO1xuICAgIH1cbiAgICBfX25hbWUoc3VwcG9ydHNDb2xvciwgXCJzdXBwb3J0c0NvbG9yXCIpO1xuICAgIGZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0yKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtMiwgc3RyZWFtMiAmJiBzdHJlYW0yLmlzVFRZKTtcbiAgICAgIHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIF9fbmFtZShnZXRTdXBwb3J0TGV2ZWwsIFwiZ2V0U3VwcG9ydExldmVsXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcbiAgICAgIHN0ZG91dDogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG4gICAgICBzdGRlcnI6IHRyYW5zbGF0ZUxldmVsKHN1cHBvcnRzQ29sb3IodHJ1ZSwgdHR5LmlzYXR0eSgyKSkpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFsa0A0LjEuMi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3V0aWwuanNcbnZhciByZXF1aXJlX3V0aWwgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhbGtANC4xLjIvbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS91dGlsLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBzdHJpbmdSZXBsYWNlQWxsID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RyaW5nLCBzdWJzdHJpbmcsIHJlcGxhY2VyKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihzdWJzdHJpbmcpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Vic3RyaW5nTGVuZ3RoID0gc3Vic3RyaW5nLmxlbmd0aDtcbiAgICAgIGxldCBlbmRJbmRleCA9IDA7XG4gICAgICBsZXQgcmV0dXJuVmFsdWUgPSBcIlwiO1xuICAgICAgZG8ge1xuICAgICAgICByZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4LCBpbmRleCAtIGVuZEluZGV4KSArIHN1YnN0cmluZyArIHJlcGxhY2VyO1xuICAgICAgICBlbmRJbmRleCA9IGluZGV4ICsgc3Vic3RyaW5nTGVuZ3RoO1xuICAgICAgICBpbmRleCA9IHN0cmluZy5pbmRleE9mKHN1YnN0cmluZywgZW5kSW5kZXgpO1xuICAgICAgfSB3aGlsZSAoaW5kZXggIT09IC0xKTtcbiAgICAgIHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sIFwic3RyaW5nUmVwbGFjZUFsbFwiKTtcbiAgICB2YXIgc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RyaW5nLCBwcmVmaXgsIHBvc3RmaXgsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgICAgbGV0IHJldHVyblZhbHVlID0gXCJcIjtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZ290Q1IgPSBzdHJpbmdbaW5kZXggLSAxXSA9PT0gXCJcXHJcIjtcbiAgICAgICAgcmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCwgKGdvdENSID8gaW5kZXggLSAxIDogaW5kZXgpIC0gZW5kSW5kZXgpICsgcHJlZml4ICsgKGdvdENSID8gXCJcXHJcXG5cIiA6IFwiXFxuXCIpICsgcG9zdGZpeDtcbiAgICAgICAgZW5kSW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCJcXG5cIiwgZW5kSW5kZXgpO1xuICAgICAgfSB3aGlsZSAoaW5kZXggIT09IC0xKTtcbiAgICAgIHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sIFwic3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHN0cmluZ1JlcGxhY2VBbGwsXG4gICAgICBzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXhcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYWxrQDQuMS4yL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvdGVtcGxhdGVzLmpzXG52YXIgcmVxdWlyZV90ZW1wbGF0ZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhbGtANC4xLjIvbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS90ZW1wbGF0ZXMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFRFTVBMQVRFX1JFR0VYID0gLyg/OlxcXFwodSg/OlthLWZcXGRdezR9fFxce1thLWZcXGRdezEsNn1cXH0pfHhbYS1mXFxkXXsyfXwuKSl8KD86XFx7KH4pPyhcXHcrKD86XFwoW14pXSpcXCkpPyg/OlxcLlxcdysoPzpcXChbXildKlxcKSk/KSopKD86WyBcXHRdfCg/PVxccj9cXG4pKSl8KFxcfSl8KCg/Oi58W1xcclxcblxcZl0pKz8pL2dpO1xuICAgIHZhciBTVFlMRV9SRUdFWCA9IC8oPzpefFxcLikoXFx3KykoPzpcXCgoW14pXSopXFwpKT8vZztcbiAgICB2YXIgU1RSSU5HX1JFR0VYID0gL14oWydcIl0pKCg/OlxcXFwufCg/IVxcMSlbXlxcXFxdKSopXFwxJC87XG4gICAgdmFyIEVTQ0FQRV9SRUdFWCA9IC9cXFxcKHUoPzpbYS1mXFxkXXs0fXx7W2EtZlxcZF17MSw2fX0pfHhbYS1mXFxkXXsyfXwuKXwoW15cXFxcXSkvZ2k7XG4gICAgdmFyIEVTQ0FQRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICBbXCJuXCIsIFwiXFxuXCJdLFxuICAgICAgW1wiclwiLCBcIlxcclwiXSxcbiAgICAgIFtcInRcIiwgXCJcdFwiXSxcbiAgICAgIFtcImJcIiwgXCJcXGJcIl0sXG4gICAgICBbXCJmXCIsIFwiXFxmXCJdLFxuICAgICAgW1widlwiLCBcIlxcdlwiXSxcbiAgICAgIFtcIjBcIiwgXCJcXDBcIl0sXG4gICAgICBbXCJcXFxcXCIsIFwiXFxcXFwiXSxcbiAgICAgIFtcImVcIiwgXCJcXHgxQlwiXSxcbiAgICAgIFtcImFcIiwgXCJcXHgwN1wiXVxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKGMpIHtcbiAgICAgIGNvbnN0IHUgPSBjWzBdID09PSBcInVcIjtcbiAgICAgIGNvbnN0IGJyYWNrZXQgPSBjWzFdID09PSBcIntcIjtcbiAgICAgIGlmICh1ICYmICFicmFja2V0ICYmIGMubGVuZ3RoID09PSA1IHx8IGNbMF0gPT09IFwieFwiICYmIGMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGMuc2xpY2UoMSksIDE2KSk7XG4gICAgICB9XG4gICAgICBpZiAodSAmJiBicmFja2V0KSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChjLnNsaWNlKDIsIC0xKSwgMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFU0NBUEVTLmdldChjKSB8fCBjO1xuICAgIH1cbiAgICBfX25hbWUodW5lc2NhcGUsIFwidW5lc2NhcGVcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMobmFtZSwgYXJndW1lbnRzXykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgY29uc3QgY2h1bmtzID0gYXJndW1lbnRzXy50cmltKCkuc3BsaXQoL1xccyosXFxzKi9nKTtcbiAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgY29uc3QgbnVtYmVyID0gTnVtYmVyKGNodW5rKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChudW1iZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMgPSBjaHVuay5tYXRjaChTVFJJTkdfUkVHRVgpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoZXNbMl0ucmVwbGFjZShFU0NBUEVfUkVHRVgsIChtLCBlc2NhcGUsIGNoYXJhY3RlcikgPT4gZXNjYXBlID8gdW5lc2NhcGUoZXNjYXBlKSA6IGNoYXJhY3RlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDaGFsayB0ZW1wbGF0ZSBzdHlsZSBhcmd1bWVudDogJHtjaHVua30gKGluIHN0eWxlICcke25hbWV9JylgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZUFyZ3VtZW50cywgXCJwYXJzZUFyZ3VtZW50c1wiKTtcbiAgICBmdW5jdGlvbiBwYXJzZVN0eWxlKHN0eWxlKSB7XG4gICAgICBTVFlMRV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICB3aGlsZSAoKG1hdGNoZXMgPSBTVFlMRV9SRUdFWC5leGVjKHN0eWxlKSkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgIGlmIChtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzKG5hbWUsIG1hdGNoZXNbMl0pO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZVN0eWxlLCBcInBhcnNlU3R5bGVcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRTdHlsZShjaGFsazEyLCBzdHlsZXMpIHtcbiAgICAgIGNvbnN0IGVuYWJsZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygc3R5bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2YgbGF5ZXIuc3R5bGVzKSB7XG4gICAgICAgICAgZW5hYmxlZFtzdHlsZVswXV0gPSBsYXllci5pbnZlcnNlID8gbnVsbCA6IHN0eWxlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY3VycmVudCA9IGNoYWxrMTI7XG4gICAgICBmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlczJdIG9mIE9iamVjdC5lbnRyaWVzKGVuYWJsZWQpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZXMyKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0eWxlTmFtZSBpbiBjdXJyZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBDaGFsayBzdHlsZTogJHtzdHlsZU5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHN0eWxlczIubGVuZ3RoID4gMCA/IGN1cnJlbnRbc3R5bGVOYW1lXSguLi5zdHlsZXMyKSA6IGN1cnJlbnRbc3R5bGVOYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRTdHlsZSwgXCJidWlsZFN0eWxlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChjaGFsazEyLCB0ZW1wb3JhcnkpID0+IHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBsZXQgY2h1bmsgPSBbXTtcbiAgICAgIHRlbXBvcmFyeS5yZXBsYWNlKFRFTVBMQVRFX1JFR0VYLCAobSwgZXNjYXBlQ2hhcmFjdGVyLCBpbnZlcnNlLCBzdHlsZSwgY2xvc2UsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoZXNjYXBlQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgY2h1bmsucHVzaCh1bmVzY2FwZShlc2NhcGVDaGFyYWN0ZXIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSkge1xuICAgICAgICAgIGNvbnN0IHN0cmluZyA9IGNodW5rLmpvaW4oXCJcIik7XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBjaHVua3MucHVzaChzdHlsZXMubGVuZ3RoID09PSAwID8gc3RyaW5nIDogYnVpbGRTdHlsZShjaGFsazEyLCBzdHlsZXMpKHN0cmluZykpO1xuICAgICAgICAgIHN0eWxlcy5wdXNoKHsgaW52ZXJzZSwgc3R5bGVzOiBwYXJzZVN0eWxlKHN0eWxlKSB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbG9zZSkge1xuICAgICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBleHRyYW5lb3VzIH0gaW4gQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmtzLnB1c2goYnVpbGRTdHlsZShjaGFsazEyLCBzdHlsZXMpKGNodW5rLmpvaW4oXCJcIikpKTtcbiAgICAgICAgICBjaHVuayA9IFtdO1xuICAgICAgICAgIHN0eWxlcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuay5wdXNoKGNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmsuam9pbihcIlwiKSk7XG4gICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgJHtzdHlsZXMubGVuZ3RofSBjbG9zaW5nIGJyYWNrZXQke3N0eWxlcy5sZW5ndGggPT09IDEgPyBcIlwiIDogXCJzXCJ9IChcXGB9XFxgKWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3Muam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYWxrQDQuMS4yL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvaW5kZXguanNcbnZhciByZXF1aXJlX3NvdXJjZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFsa0A0LjEuMi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhbnNpU3R5bGVzID0gcmVxdWlyZV9hbnNpX3N0eWxlcygpO1xuICAgIHZhciB7IHN0ZG91dDogc3Rkb3V0Q29sb3IsIHN0ZGVycjogc3RkZXJyQ29sb3IgfSA9IHJlcXVpcmVfc3VwcG9ydHNfY29sb3IoKTtcbiAgICB2YXIge1xuICAgICAgc3RyaW5nUmVwbGFjZUFsbCxcbiAgICAgIHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleFxuICAgIH0gPSByZXF1aXJlX3V0aWwoKTtcbiAgICB2YXIgeyBpc0FycmF5OiBpc0FycmF5MiB9ID0gQXJyYXk7XG4gICAgdmFyIGxldmVsTWFwcGluZyA9IFtcbiAgICAgIFwiYW5zaVwiLFxuICAgICAgXCJhbnNpXCIsXG4gICAgICBcImFuc2kyNTZcIixcbiAgICAgIFwiYW5zaTE2bVwiXG4gICAgXTtcbiAgICB2YXIgc3R5bGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGFwcGx5T3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9iamVjdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5sZXZlbCAmJiAhKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sZXZlbCkgJiYgb3B0aW9ucy5sZXZlbCA+PSAwICYmIG9wdGlvbnMubGV2ZWwgPD0gMykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBsZXZlbGAgb3B0aW9uIHNob3VsZCBiZSBhbiBpbnRlZ2VyIGZyb20gMCB0byAzXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sb3JMZXZlbCA9IHN0ZG91dENvbG9yID8gc3Rkb3V0Q29sb3IubGV2ZWwgOiAwO1xuICAgICAgb2JqZWN0LmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdm9pZCAwID8gY29sb3JMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG4gICAgfSwgXCJhcHBseU9wdGlvbnNcIik7XG4gICAgdmFyIENoYWxrQ2xhc3MgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjaGFsa0ZhY3Rvcnkob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQ2hhbGtDbGFzcywgXCJDaGFsa0NsYXNzXCIpO1xuICAgIHZhciBjaGFsa0ZhY3RvcnkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBjaGFsazEzID0ge307XG4gICAgICBhcHBseU9wdGlvbnMoY2hhbGsxMywgb3B0aW9ucyk7XG4gICAgICBjaGFsazEzLnRlbXBsYXRlID0gKC4uLmFyZ3VtZW50c18pID0+IGNoYWxrVGFnKGNoYWxrMTMudGVtcGxhdGUsIC4uLmFyZ3VtZW50c18pO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrMTMsIENoYWxrLnByb3RvdHlwZSk7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGsxMy50ZW1wbGF0ZSwgY2hhbGsxMyk7XG4gICAgICBjaGFsazEzLnRlbXBsYXRlLmNvbnN0cnVjdG9yID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgY2hhbGsuY29uc3RydWN0b3IoKWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBuZXcgY2hhbGsuSW5zdGFuY2UoKWAgaW5zdGVhZC5cIik7XG4gICAgICB9O1xuICAgICAgY2hhbGsxMy50ZW1wbGF0ZS5JbnN0YW5jZSA9IENoYWxrQ2xhc3M7XG4gICAgICByZXR1cm4gY2hhbGsxMy50ZW1wbGF0ZTtcbiAgICB9LCBcImNoYWxrRmFjdG9yeVwiKTtcbiAgICBmdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xuICAgIH1cbiAgICBfX25hbWUoQ2hhbGssIFwiQ2hhbGtcIik7XG4gICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoYW5zaVN0eWxlcykpIHtcbiAgICAgIHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgY3JlYXRlU3R5bGVyKHN0eWxlLm9wZW4sIHN0eWxlLmNsb3NlLCB0aGlzLl9zdHlsZXIpLCB0aGlzLl9pc0VtcHR5KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3R5bGVOYW1lLCB7IHZhbHVlOiBidWlsZGVyIH0pO1xuICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBzdHlsZXMudmlzaWJsZSA9IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgdGhpcy5fc3R5bGVyLCB0cnVlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmlzaWJsZVwiLCB7IHZhbHVlOiBidWlsZGVyIH0pO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1c2VkTW9kZWxzID0gW1wicmdiXCIsIFwiaGV4XCIsIFwia2V5d29yZFwiLCBcImhzbFwiLCBcImhzdlwiLCBcImh3YlwiLCBcImFuc2lcIiwgXCJhbnNpMjU2XCJdO1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuICAgICAgc3R5bGVzW21vZGVsXSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHsgbGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3VtZW50c18pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlciA9IGNyZWF0ZVN0eWxlcihhbnNpU3R5bGVzLmNvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXSguLi5hcmd1bWVudHNfKSwgYW5zaVN0eWxlcy5jb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB1c2VkTW9kZWxzKSB7XG4gICAgICBjb25zdCBiZ01vZGVsID0gXCJiZ1wiICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuICAgICAgc3R5bGVzW2JnTW9kZWxdID0ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgeyBsZXZlbCB9ID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJndW1lbnRzXykge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMuYmdDb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuYmdDb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKCkgPT4ge1xuICAgIH0sIHtcbiAgICAgIC4uLnN0eWxlcyxcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdG9yLmxldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQobGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLl9nZW5lcmF0b3IubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBjcmVhdGVTdHlsZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcGVuLCBjbG9zZSwgcGFyZW50KSA9PiB7XG4gICAgICBsZXQgb3BlbkFsbDtcbiAgICAgIGxldCBjbG9zZUFsbDtcbiAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBvcGVuQWxsID0gb3BlbjtcbiAgICAgICAgY2xvc2VBbGwgPSBjbG9zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZW5BbGwgPSBwYXJlbnQub3BlbkFsbCArIG9wZW47XG4gICAgICAgIGNsb3NlQWxsID0gY2xvc2UgKyBwYXJlbnQuY2xvc2VBbGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuLFxuICAgICAgICBjbG9zZSxcbiAgICAgICAgb3BlbkFsbCxcbiAgICAgICAgY2xvc2VBbGwsXG4gICAgICAgIHBhcmVudFxuICAgICAgfTtcbiAgICB9LCBcImNyZWF0ZVN0eWxlclwiKTtcbiAgICB2YXIgY3JlYXRlQnVpbGRlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNlbGYyLCBfc3R5bGVyLCBfaXNFbXB0eSkgPT4ge1xuICAgICAgY29uc3QgYnVpbGRlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKC4uLmFyZ3VtZW50c18pID0+IHtcbiAgICAgICAgaWYgKGlzQXJyYXkyKGFyZ3VtZW50c19bMF0pICYmIGlzQXJyYXkyKGFyZ3VtZW50c19bMF0ucmF3KSkge1xuICAgICAgICAgIHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIGNoYWxrVGFnKGJ1aWxkZXIsIC4uLmFyZ3VtZW50c18pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHlTdHlsZShidWlsZGVyLCBhcmd1bWVudHNfLmxlbmd0aCA9PT0gMSA/IFwiXCIgKyBhcmd1bWVudHNfWzBdIDogYXJndW1lbnRzXy5qb2luKFwiIFwiKSk7XG4gICAgICB9LCBcImJ1aWxkZXJcIik7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVpbGRlciwgcHJvdG8pO1xuICAgICAgYnVpbGRlci5fZ2VuZXJhdG9yID0gc2VsZjI7XG4gICAgICBidWlsZGVyLl9zdHlsZXIgPSBfc3R5bGVyO1xuICAgICAgYnVpbGRlci5faXNFbXB0eSA9IF9pc0VtcHR5O1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSwgXCJjcmVhdGVCdWlsZGVyXCIpO1xuICAgIHZhciBhcHBseVN0eWxlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2VsZjIsIHN0cmluZykgPT4ge1xuICAgICAgaWYgKHNlbGYyLmxldmVsIDw9IDAgfHwgIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc2VsZjIuX2lzRW1wdHkgPyBcIlwiIDogc3RyaW5nO1xuICAgICAgfVxuICAgICAgbGV0IHN0eWxlciA9IHNlbGYyLl9zdHlsZXI7XG4gICAgICBpZiAoc3R5bGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgb3BlbkFsbCwgY2xvc2VBbGwgfSA9IHN0eWxlcjtcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZihcIlxceDFCXCIpICE9PSAtMSkge1xuICAgICAgICB3aGlsZSAoc3R5bGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmdSZXBsYWNlQWxsKHN0cmluZywgc3R5bGVyLmNsb3NlLCBzdHlsZXIub3Blbik7XG4gICAgICAgICAgc3R5bGVyID0gc3R5bGVyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGZJbmRleCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgaWYgKGxmSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleChzdHJpbmcsIGNsb3NlQWxsLCBvcGVuQWxsLCBsZkluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcGVuQWxsICsgc3RyaW5nICsgY2xvc2VBbGw7XG4gICAgfSwgXCJhcHBseVN0eWxlXCIpO1xuICAgIHZhciB0ZW1wbGF0ZTtcbiAgICB2YXIgY2hhbGtUYWcgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjaGFsazEzLCAuLi5zdHJpbmdzKSA9PiB7XG4gICAgICBjb25zdCBbZmlyc3RTdHJpbmddID0gc3RyaW5ncztcbiAgICAgIGlmICghaXNBcnJheTIoZmlyc3RTdHJpbmcpIHx8ICFpc0FycmF5MihmaXJzdFN0cmluZy5yYXcpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJndW1lbnRzXyA9IHN0cmluZ3Muc2xpY2UoMSk7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtmaXJzdFN0cmluZy5yYXdbMF1dO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFN0cmluZyhhcmd1bWVudHNfW2kgLSAxXSkucmVwbGFjZSgvW3t9XFxcXF0vZywgXCJcXFxcJCZcIiksXG4gICAgICAgICAgU3RyaW5nKGZpcnN0U3RyaW5nLnJhd1tpXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRlbXBsYXRlID0gcmVxdWlyZV90ZW1wbGF0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZShjaGFsazEzLCBwYXJ0cy5qb2luKFwiXCIpKTtcbiAgICB9LCBcImNoYWxrVGFnXCIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYWxrLnByb3RvdHlwZSwgc3R5bGVzKTtcbiAgICB2YXIgY2hhbGsxMiA9IENoYWxrKCk7XG4gICAgY2hhbGsxMi5zdXBwb3J0c0NvbG9yID0gc3Rkb3V0Q29sb3I7XG4gICAgY2hhbGsxMi5zdGRlcnIgPSBDaGFsayh7IGxldmVsOiBzdGRlcnJDb2xvciA/IHN0ZGVyckNvbG9yLmxldmVsIDogMCB9KTtcbiAgICBjaGFsazEyLnN0ZGVyci5zdXBwb3J0c0NvbG9yID0gc3RkZXJyQ29sb3I7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY2hhbGsxMjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pbmRlbnQtc3RyaW5nQDQuMC4wL25vZGVfbW9kdWxlcy9pbmRlbnQtc3RyaW5nL2luZGV4LmpzXG52YXIgcmVxdWlyZV9pbmRlbnRfc3RyaW5nID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2luZGVudC1zdHJpbmdANC4wLjAvbm9kZV9tb2R1bGVzL2luZGVudC1zdHJpbmcvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKHN0cmluZywgY291bnQyID0gMSwgb3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgaW5kZW50OiBcIiBcIixcbiAgICAgICAgaW5jbHVkZUVtcHR5TGluZXM6IGZhbHNlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgYSBcXGBzdHJpbmdcXGAsIGdvdCBcXGAke3R5cGVvZiBzdHJpbmd9XFxgYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb3VudDIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgXFxgY291bnRcXGAgdG8gYmUgYSBcXGBudW1iZXJcXGAsIGdvdCBcXGAke3R5cGVvZiBjb3VudDJ9XFxgYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluZGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBcXGBvcHRpb25zLmluZGVudFxcYCB0byBiZSBhIFxcYHN0cmluZ1xcYCwgZ290IFxcYCR7dHlwZW9mIG9wdGlvbnMuaW5kZW50fVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2V4ID0gb3B0aW9ucy5pbmNsdWRlRW1wdHlMaW5lcyA/IC9eL2dtIDogL14oPyFcXHMqJCkvZ207XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVnZXgsIG9wdGlvbnMuaW5kZW50LnJlcGVhdChjb3VudDIpKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzLWxldmVuc2h0ZWluQDEuMS42L25vZGVfbW9kdWxlcy9qcy1sZXZlbnNodGVpbi9pbmRleC5qc1xudmFyIHJlcXVpcmVfanNfbGV2ZW5zaHRlaW4gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vanMtbGV2ZW5zaHRlaW5AMS4xLjYvbm9kZV9tb2R1bGVzL2pzLWxldmVuc2h0ZWluL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gX21pbihkMCwgZDEsIGQyLCBieCwgYXkpIHtcbiAgICAgICAgcmV0dXJuIGQwIDwgZDEgfHwgZDIgPCBkMSA/IGQwID4gZDIgPyBkMiArIDEgOiBkMCArIDEgOiBieCA9PT0gYXkgPyBkMSA6IGQxICsgMTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShfbWluLCBcIl9taW5cIik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGE7XG4gICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgYiA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGEgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxiID0gYi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsYSA+IDAgJiYgYS5jaGFyQ29kZUF0KGxhIC0gMSkgPT09IGIuY2hhckNvZGVBdChsYiAtIDEpKSB7XG4gICAgICAgICAgbGEtLTtcbiAgICAgICAgICBsYi0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGEgJiYgYS5jaGFyQ29kZUF0KG9mZnNldCkgPT09IGIuY2hhckNvZGVBdChvZmZzZXQpKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGEgLT0gb2Zmc2V0O1xuICAgICAgICBsYiAtPSBvZmZzZXQ7XG4gICAgICAgIGlmIChsYSA9PT0gMCB8fCBsYiA8IDMpIHtcbiAgICAgICAgICByZXR1cm4gbGI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIGQwO1xuICAgICAgICB2YXIgZDE7XG4gICAgICAgIHZhciBkMjtcbiAgICAgICAgdmFyIGQzO1xuICAgICAgICB2YXIgZGQ7XG4gICAgICAgIHZhciBkeTtcbiAgICAgICAgdmFyIGF5O1xuICAgICAgICB2YXIgYngwO1xuICAgICAgICB2YXIgYngxO1xuICAgICAgICB2YXIgYngyO1xuICAgICAgICB2YXIgYngzO1xuICAgICAgICB2YXIgdmVjdG9yID0gW107XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBsYTsgeSsrKSB7XG4gICAgICAgICAgdmVjdG9yLnB1c2goeSArIDEpO1xuICAgICAgICAgIHZlY3Rvci5wdXNoKGEuY2hhckNvZGVBdChvZmZzZXQgKyB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IHZlY3Rvci5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKDsgeCA8IGxiIC0gMzsgKSB7XG4gICAgICAgICAgYngwID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMCA9IHgpKTtcbiAgICAgICAgICBieDEgPSBiLmNoYXJDb2RlQXQob2Zmc2V0ICsgKGQxID0geCArIDEpKTtcbiAgICAgICAgICBieDIgPSBiLmNoYXJDb2RlQXQob2Zmc2V0ICsgKGQyID0geCArIDIpKTtcbiAgICAgICAgICBieDMgPSBiLmNoYXJDb2RlQXQob2Zmc2V0ICsgKGQzID0geCArIDMpKTtcbiAgICAgICAgICBkZCA9IHggKz0gNDtcbiAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgbGVuOyB5ICs9IDIpIHtcbiAgICAgICAgICAgIGR5ID0gdmVjdG9yW3ldO1xuICAgICAgICAgICAgYXkgPSB2ZWN0b3JbeSArIDFdO1xuICAgICAgICAgICAgZDAgPSBfbWluKGR5LCBkMCwgZDEsIGJ4MCwgYXkpO1xuICAgICAgICAgICAgZDEgPSBfbWluKGQwLCBkMSwgZDIsIGJ4MSwgYXkpO1xuICAgICAgICAgICAgZDIgPSBfbWluKGQxLCBkMiwgZDMsIGJ4MiwgYXkpO1xuICAgICAgICAgICAgZGQgPSBfbWluKGQyLCBkMywgZGQsIGJ4MywgYXkpO1xuICAgICAgICAgICAgdmVjdG9yW3ldID0gZGQ7XG4gICAgICAgICAgICBkMyA9IGQyO1xuICAgICAgICAgICAgZDIgPSBkMTtcbiAgICAgICAgICAgIGQxID0gZDA7XG4gICAgICAgICAgICBkMCA9IGR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgeCA8IGxiOyApIHtcbiAgICAgICAgICBieDAgPSBiLmNoYXJDb2RlQXQob2Zmc2V0ICsgKGQwID0geCkpO1xuICAgICAgICAgIGRkID0gKyt4O1xuICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBsZW47IHkgKz0gMikge1xuICAgICAgICAgICAgZHkgPSB2ZWN0b3JbeV07XG4gICAgICAgICAgICB2ZWN0b3JbeV0gPSBkZCA9IF9taW4oZHksIGQwLCBkZCwgYngwLCB2ZWN0b3JbeSArIDFdKTtcbiAgICAgICAgICAgIGQwID0gZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZDtcbiAgICAgIH07XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21zQDIuMS4yL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfbXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXNAMi4xLjIvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBzID0gMWUzO1xuICAgIHZhciBtID0gcyAqIDYwO1xuICAgIHZhciBoID0gbSAqIDYwO1xuICAgIHZhciBkID0gaCAqIDI0O1xuICAgIHZhciB3ID0gZCAqIDc7XG4gICAgdmFyIHkgPSBkICogMzY1LjI1O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2UyKHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJ2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlMihzdHIpIHtcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgICAgICBzdHJcbiAgICAgICk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCBcIm1zXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgIGNhc2UgXCJ5cnNcIjpcbiAgICAgICAgY2FzZSBcInlyXCI6XG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiB5O1xuICAgICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHc7XG4gICAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIGQ7XG4gICAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICBjYXNlIFwiaG91clwiOlxuICAgICAgICBjYXNlIFwiaHJzXCI6XG4gICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgICBjYXNlIFwibWluc1wiOlxuICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBtO1xuICAgICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgIGNhc2UgXCJzZWNzXCI6XG4gICAgICAgIGNhc2UgXCJzZWNcIjpcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHM7XG4gICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICAgIGNhc2UgXCJtc2Vjc1wiOlxuICAgICAgICBjYXNlIFwibXNlY1wiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocGFyc2UyLCBcInBhcnNlXCIpO1xuICAgIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gICAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgXCJkXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgXCJoXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgXCJtXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgXCJzXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXMgKyBcIm1zXCI7XG4gICAgfVxuICAgIF9fbmFtZShmbXRTaG9ydCwgXCJmbXRTaG9ydFwiKTtcbiAgICBmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gICAgICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gICAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgXCJkYXlcIik7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgXCJob3VyXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IG0pIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sIFwibWludXRlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsIFwic2Vjb25kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zICsgXCIgbXNcIjtcbiAgICB9XG4gICAgX19uYW1lKGZtdExvbmcsIFwiZm10TG9uZ1wiKTtcbiAgICBmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gICAgICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArIFwiIFwiICsgbmFtZSArIChpc1BsdXJhbCA/IFwic1wiIDogXCJcIik7XG4gICAgfVxuICAgIF9fbmFtZShwbHVyYWwsIFwicGx1cmFsXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzXG52YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgZnVuY3Rpb24gc2V0dXAoZW52Mikge1xuICAgICAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgICAgIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgICAgIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgICAgIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgICAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICAgICAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmVfbXMoKTtcbiAgICAgIGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgICAgT2JqZWN0LmtleXMoZW52MikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnYyW2tleV07XG4gICAgICB9KTtcbiAgICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAgICAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgaGFzaCB8PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzZWxlY3RDb2xvciwgXCJzZWxlY3RDb2xvclwiKTtcbiAgICAgIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gICAgICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICAgICAgbGV0IHByZXZUaW1lO1xuICAgICAgICBsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuICAgICAgICBsZXQgbmFtZXNwYWNlc0NhY2hlO1xuICAgICAgICBsZXQgZW5hYmxlZENhY2hlO1xuICAgICAgICBmdW5jdGlvbiBkZWJ1ZzEzKC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoIWRlYnVnMTMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzZWxmMiA9IGRlYnVnMTM7XG4gICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgICAgICBjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICAgICAgc2VsZjIuZGlmZiA9IG1zO1xuICAgICAgICAgIHNlbGYyLnByZXYgPSBwcmV2VGltZTtcbiAgICAgICAgICBzZWxmMi5jdXJyID0gY3VycjtcbiAgICAgICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChcIiVPXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdDIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gXCIlJVwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdDJdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmMiwgdmFsKTtcbiAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmMiwgYXJncyk7XG4gICAgICAgICAgY29uc3QgbG9nRm4gPSBzZWxmMi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYyLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBfX25hbWUoZGVidWcxMywgXCJkZWJ1Z1wiKTtcbiAgICAgICAgZGVidWcxMy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIGRlYnVnMTMudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgICAgIGRlYnVnMTMuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgICAgICBkZWJ1ZzEzLmV4dGVuZCA9IGV4dGVuZDtcbiAgICAgICAgZGVidWcxMy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnMTMsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmFibGVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcbiAgICAgICAgICAgICAgZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRDYWNoZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogKHYpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZU92ZXJyaWRlID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcxMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlYnVnMTM7XG4gICAgICB9XG4gICAgICBfX25hbWUoY3JlYXRlRGVidWcsIFwiY3JlYXRlRGVidWdcIik7XG4gICAgICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgY29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSBcInVuZGVmaW5lZFwiID8gXCI6XCIgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgICAgICAgbmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG4gICAgICAgIHJldHVybiBuZXdEZWJ1ZztcbiAgICAgIH1cbiAgICAgIF9fbmFtZShleHRlbmQsIFwiZXh0ZW5kXCIpO1xuICAgICAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gXCJzdHJpbmdcIiA/IG5hbWVzcGFjZXMgOiBcIlwiKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgICAgICBjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csIFwiLio/XCIpO1xuICAgICAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiICsgbmFtZXNwYWNlcy5zbGljZSgxKSArIFwiJFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIG5hbWVzcGFjZXMgKyBcIiRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKGVuYWJsZSwgXCJlbmFibGVcIik7XG4gICAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gW1xuICAgICAgICAgIC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG4gICAgICAgICAgLi4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAoKG5hbWVzcGFjZSkgPT4gXCItXCIgKyBuYW1lc3BhY2UpXG4gICAgICAgIF0uam9pbihcIixcIik7XG4gICAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZShcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZXM7XG4gICAgICB9XG4gICAgICBfX25hbWUoZGlzYWJsZSwgXCJkaXNhYmxlXCIpO1xuICAgICAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShlbmFibGVkLCBcImVuYWJsZWRcIik7XG4gICAgICBmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4cC50b1N0cmluZygpLnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXC5cXCpcXD8kLywgXCIqXCIpO1xuICAgICAgfVxuICAgICAgX19uYW1lKHRvTmFtZXNwYWNlLCBcInRvTmFtZXNwYWNlXCIpO1xuICAgICAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgICBfX25hbWUoY29lcmNlLCBcImNvZXJjZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIik7XG4gICAgICB9XG4gICAgICBfX25hbWUoZGVzdHJveSwgXCJkZXN0cm95XCIpO1xuICAgICAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gICAgICByZXR1cm4gY3JlYXRlRGVidWc7XG4gICAgfVxuICAgIF9fbmFtZShzZXR1cCwgXCJzZXR1cFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzZXR1cDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcbnZhciByZXF1aXJlX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgZXhwb3J0cy5zYXZlID0gc2F2ZTtcbiAgICBleHBvcnRzLmxvYWQgPSBsb2FkO1xuICAgIGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuICAgIGV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuICAgIGV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG4gICAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGV4cG9ydHMuY29sb3JzID0gW1xuICAgICAgXCIjMDAwMENDXCIsXG4gICAgICBcIiMwMDAwRkZcIixcbiAgICAgIFwiIzAwMzNDQ1wiLFxuICAgICAgXCIjMDAzM0ZGXCIsXG4gICAgICBcIiMwMDY2Q0NcIixcbiAgICAgIFwiIzAwNjZGRlwiLFxuICAgICAgXCIjMDA5OUNDXCIsXG4gICAgICBcIiMwMDk5RkZcIixcbiAgICAgIFwiIzAwQ0MwMFwiLFxuICAgICAgXCIjMDBDQzMzXCIsXG4gICAgICBcIiMwMENDNjZcIixcbiAgICAgIFwiIzAwQ0M5OVwiLFxuICAgICAgXCIjMDBDQ0NDXCIsXG4gICAgICBcIiMwMENDRkZcIixcbiAgICAgIFwiIzMzMDBDQ1wiLFxuICAgICAgXCIjMzMwMEZGXCIsXG4gICAgICBcIiMzMzMzQ0NcIixcbiAgICAgIFwiIzMzMzNGRlwiLFxuICAgICAgXCIjMzM2NkNDXCIsXG4gICAgICBcIiMzMzY2RkZcIixcbiAgICAgIFwiIzMzOTlDQ1wiLFxuICAgICAgXCIjMzM5OUZGXCIsXG4gICAgICBcIiMzM0NDMDBcIixcbiAgICAgIFwiIzMzQ0MzM1wiLFxuICAgICAgXCIjMzNDQzY2XCIsXG4gICAgICBcIiMzM0NDOTlcIixcbiAgICAgIFwiIzMzQ0NDQ1wiLFxuICAgICAgXCIjMzNDQ0ZGXCIsXG4gICAgICBcIiM2NjAwQ0NcIixcbiAgICAgIFwiIzY2MDBGRlwiLFxuICAgICAgXCIjNjYzM0NDXCIsXG4gICAgICBcIiM2NjMzRkZcIixcbiAgICAgIFwiIzY2Q0MwMFwiLFxuICAgICAgXCIjNjZDQzMzXCIsXG4gICAgICBcIiM5OTAwQ0NcIixcbiAgICAgIFwiIzk5MDBGRlwiLFxuICAgICAgXCIjOTkzM0NDXCIsXG4gICAgICBcIiM5OTMzRkZcIixcbiAgICAgIFwiIzk5Q0MwMFwiLFxuICAgICAgXCIjOTlDQzMzXCIsXG4gICAgICBcIiNDQzAwMDBcIixcbiAgICAgIFwiI0NDMDAzM1wiLFxuICAgICAgXCIjQ0MwMDY2XCIsXG4gICAgICBcIiNDQzAwOTlcIixcbiAgICAgIFwiI0NDMDBDQ1wiLFxuICAgICAgXCIjQ0MwMEZGXCIsXG4gICAgICBcIiNDQzMzMDBcIixcbiAgICAgIFwiI0NDMzMzM1wiLFxuICAgICAgXCIjQ0MzMzY2XCIsXG4gICAgICBcIiNDQzMzOTlcIixcbiAgICAgIFwiI0NDMzNDQ1wiLFxuICAgICAgXCIjQ0MzM0ZGXCIsXG4gICAgICBcIiNDQzY2MDBcIixcbiAgICAgIFwiI0NDNjYzM1wiLFxuICAgICAgXCIjQ0M5OTAwXCIsXG4gICAgICBcIiNDQzk5MzNcIixcbiAgICAgIFwiI0NDQ0MwMFwiLFxuICAgICAgXCIjQ0NDQzMzXCIsXG4gICAgICBcIiNGRjAwMDBcIixcbiAgICAgIFwiI0ZGMDAzM1wiLFxuICAgICAgXCIjRkYwMDY2XCIsXG4gICAgICBcIiNGRjAwOTlcIixcbiAgICAgIFwiI0ZGMDBDQ1wiLFxuICAgICAgXCIjRkYwMEZGXCIsXG4gICAgICBcIiNGRjMzMDBcIixcbiAgICAgIFwiI0ZGMzMzM1wiLFxuICAgICAgXCIjRkYzMzY2XCIsXG4gICAgICBcIiNGRjMzOTlcIixcbiAgICAgIFwiI0ZGMzNDQ1wiLFxuICAgICAgXCIjRkYzM0ZGXCIsXG4gICAgICBcIiNGRjY2MDBcIixcbiAgICAgIFwiI0ZGNjYzM1wiLFxuICAgICAgXCIjRkY5OTAwXCIsXG4gICAgICBcIiNGRjk5MzNcIixcbiAgICAgIFwiI0ZGQ0MwMFwiLFxuICAgICAgXCIjRkZDQzMzXCJcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG4gICAgfVxuICAgIF9fbmFtZSh1c2VDb2xvcnMsIFwidXNlQ29sb3JzXCIpO1xuICAgIGZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICAgICAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/IFwiJWNcIiA6IFwiXCIpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyBcIiAlY1wiIDogXCIgXCIpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/IFwiJWMgXCIgOiBcIiBcIikgKyBcIitcIiArIG1vZHVsZTIuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuICAgICAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gXCJjb2xvcjogXCIgKyB0aGlzLmNvbG9yO1xuICAgICAgYXJncy5zcGxpY2UoMSwgMCwgYywgXCJjb2xvcjogaW5oZXJpdFwiKTtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBsZXQgbGFzdEMgPSAwO1xuICAgICAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIChtYXRjaCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2ggPT09IFwiJSVcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBpZiAobWF0Y2ggPT09IFwiJWNcIikge1xuICAgICAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICAgIH1cbiAgICBfX25hbWUoZm9ybWF0QXJncywgXCJmb3JtYXRBcmdzXCIpO1xuICAgIGV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsIG5hbWVzcGFjZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2F2ZSwgXCJzYXZlXCIpO1xuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICBsZXQgcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICB9XG4gICAgICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJlbnZcIiBpbiBwcm9jZXNzKSB7XG4gICAgICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBfX25hbWUobG9hZCwgXCJsb2FkXCIpO1xuICAgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGxvY2Fsc3RvcmFnZSwgXCJsb2NhbHN0b3JhZ2VcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9jb21tb24oKShleHBvcnRzKTtcbiAgICB2YXIgeyBmb3JtYXR0ZXJzIH0gPSBtb2R1bGUyLmV4cG9ydHM7XG4gICAgZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIHJldHVybiBcIltVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiBcIiArIGVycm9yMi5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzXG52YXIgcmVxdWlyZV9ub2RlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlYnVnQDQuMy40L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZShcInR0eVwiKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICBleHBvcnRzLmluaXQgPSBpbml0O1xuICAgIGV4cG9ydHMubG9nID0gbG9nNDtcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSB1dGlsMi5kZXByZWNhdGUoXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCJcbiAgICApO1xuICAgIGV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZV9zdXBwb3J0c19jb2xvcigpO1xuICAgICAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcbiAgICAgICAgZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAgICAgMjAsXG4gICAgICAgICAgMjEsXG4gICAgICAgICAgMjYsXG4gICAgICAgICAgMjcsXG4gICAgICAgICAgMzIsXG4gICAgICAgICAgMzMsXG4gICAgICAgICAgMzgsXG4gICAgICAgICAgMzksXG4gICAgICAgICAgNDAsXG4gICAgICAgICAgNDEsXG4gICAgICAgICAgNDIsXG4gICAgICAgICAgNDMsXG4gICAgICAgICAgNDQsXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgNTYsXG4gICAgICAgICAgNTcsXG4gICAgICAgICAgNjIsXG4gICAgICAgICAgNjMsXG4gICAgICAgICAgNjgsXG4gICAgICAgICAgNjksXG4gICAgICAgICAgNzQsXG4gICAgICAgICAgNzUsXG4gICAgICAgICAgNzYsXG4gICAgICAgICAgNzcsXG4gICAgICAgICAgNzgsXG4gICAgICAgICAgNzksXG4gICAgICAgICAgODAsXG4gICAgICAgICAgODEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMjgsXG4gICAgICAgICAgMTI5LFxuICAgICAgICAgIDEzNCxcbiAgICAgICAgICAxMzUsXG4gICAgICAgICAgMTQ4LFxuICAgICAgICAgIDE0OSxcbiAgICAgICAgICAxNjAsXG4gICAgICAgICAgMTYxLFxuICAgICAgICAgIDE2MixcbiAgICAgICAgICAxNjMsXG4gICAgICAgICAgMTY0LFxuICAgICAgICAgIDE2NSxcbiAgICAgICAgICAxNjYsXG4gICAgICAgICAgMTY3LFxuICAgICAgICAgIDE2OCxcbiAgICAgICAgICAxNjksXG4gICAgICAgICAgMTcwLFxuICAgICAgICAgIDE3MSxcbiAgICAgICAgICAxNzIsXG4gICAgICAgICAgMTczLFxuICAgICAgICAgIDE3OCxcbiAgICAgICAgICAxNzksXG4gICAgICAgICAgMTg0LFxuICAgICAgICAgIDE4NSxcbiAgICAgICAgICAxOTYsXG4gICAgICAgICAgMTk3LFxuICAgICAgICAgIDE5OCxcbiAgICAgICAgICAxOTksXG4gICAgICAgICAgMjAwLFxuICAgICAgICAgIDIwMSxcbiAgICAgICAgICAyMDIsXG4gICAgICAgICAgMjAzLFxuICAgICAgICAgIDIwNCxcbiAgICAgICAgICAyMDUsXG4gICAgICAgICAgMjA2LFxuICAgICAgICAgIDIwNyxcbiAgICAgICAgICAyMDgsXG4gICAgICAgICAgMjA5LFxuICAgICAgICAgIDIxNCxcbiAgICAgICAgICAyMTUsXG4gICAgICAgICAgMjIwLFxuICAgICAgICAgIDIyMVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIH1cbiAgICBleHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG4gICAgfSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgY29uc3QgcHJvcCA9IGtleS5zdWJzdHJpbmcoNikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuICAgICAgICByZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgICBsZXQgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgICAgIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcbiAgICAgICAgdmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHtcbiAgICAgICAgdmFsID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgfVxuICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAgICAgcmV0dXJuIFwiY29sb3JzXCIgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG4gICAgfVxuICAgIF9fbmFtZSh1c2VDb2xvcnMsIFwidXNlQ29sb3JzXCIpO1xuICAgIGZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICAgICAgY29uc3QgeyBuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yczogdXNlQ29sb3JzMiB9ID0gdGhpcztcbiAgICAgIGlmICh1c2VDb2xvcnMyKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbG9yO1xuICAgICAgICBjb25zdCBjb2xvckNvZGUgPSBcIlxceDFCWzNcIiArIChjIDwgOCA/IGMgOiBcIjg7NTtcIiArIGMpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxceDFCWzBtYDtcbiAgICAgICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoXCJcXG5cIikuam9pbihcIlxcblwiICsgcHJlZml4KTtcbiAgICAgICAgYXJncy5wdXNoKGNvbG9yQ29kZSArIFwibStcIiArIG1vZHVsZTIuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgXCJcXHgxQlswbVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgXCIgXCIgKyBhcmdzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZm9ybWF0QXJncywgXCJmb3JtYXRBcmdzXCIpO1xuICAgIGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcIiBcIjtcbiAgICB9XG4gICAgX19uYW1lKGdldERhdGUsIFwiZ2V0RGF0ZVwiKTtcbiAgICBmdW5jdGlvbiBsb2c0KC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsMi5mb3JtYXQoLi4uYXJncykgKyBcIlxcblwiKTtcbiAgICB9XG4gICAgX19uYW1lKGxvZzQsIFwibG9nXCIpO1xuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2F2ZSwgXCJzYXZlXCIpO1xuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG4gICAgfVxuICAgIF9fbmFtZShsb2FkLCBcImxvYWRcIik7XG4gICAgZnVuY3Rpb24gaW5pdChkZWJ1ZzEzKSB7XG4gICAgICBkZWJ1ZzEzLmluc3BlY3RPcHRzID0ge307XG4gICAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWJ1ZzEzLmluc3BlY3RPcHRzW2tleXMyW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5czJbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5pdCwgXCJpbml0XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfY29tbW9uKCkoZXhwb3J0cyk7XG4gICAgdmFyIHsgZm9ybWF0dGVycyB9ID0gbW9kdWxlMi5leHBvcnRzO1xuICAgIGZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gICAgICByZXR1cm4gdXRpbDIuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKS5zcGxpdChcIlxcblwiKS5tYXAoKHN0cikgPT4gc3RyLnRyaW0oKSkuam9pbihcIiBcIik7XG4gICAgfTtcbiAgICBmb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWJ1Z0A0LjMuNC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zcmMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVidWdANC4zLjQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2Jyb3dzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9ub2RlKCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzZXhlQDIuMC4wL25vZGVfbW9kdWxlcy9pc2V4ZS93aW5kb3dzLmpzXG52YXIgcmVxdWlyZV93aW5kb3dzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzZXhlQDIuMC4wL25vZGVfbW9kdWxlcy9pc2V4ZS93aW5kb3dzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGlzZXhlO1xuICAgIGlzZXhlLnN5bmMgPSBzeW5jO1xuICAgIHZhciBmczExID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGZ1bmN0aW9uIGNoZWNrUGF0aEV4dChwYXRoNywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhdGhleHQgPSBvcHRpb25zLnBhdGhFeHQgIT09IHZvaWQgMCA/IG9wdGlvbnMucGF0aEV4dCA6IHByb2Nlc3MuZW52LlBBVEhFWFQ7XG4gICAgICBpZiAoIXBhdGhleHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXRoZXh0ID0gcGF0aGV4dC5zcGxpdChcIjtcIik7XG4gICAgICBpZiAocGF0aGV4dC5pbmRleE9mKFwiXCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBhdGhleHRbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHAgJiYgcGF0aDcuc3Vic3RyKC1wLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gcCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShjaGVja1BhdGhFeHQsIFwiY2hlY2tQYXRoRXh0XCIpO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RhdChzdGF0LCBwYXRoNywgb3B0aW9ucykge1xuICAgICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkgJiYgIXN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoZWNrUGF0aEV4dChwYXRoNywgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShjaGVja1N0YXQsIFwiY2hlY2tTdGF0XCIpO1xuICAgIGZ1bmN0aW9uIGlzZXhlKHBhdGg3LCBvcHRpb25zLCBjYikge1xuICAgICAgZnMxMS5zdGF0KHBhdGg3LCBmdW5jdGlvbihlciwgc3RhdCkge1xuICAgICAgICBjYihlciwgZXIgPyBmYWxzZSA6IGNoZWNrU3RhdChzdGF0LCBwYXRoNywgb3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShpc2V4ZSwgXCJpc2V4ZVwiKTtcbiAgICBmdW5jdGlvbiBzeW5jKHBhdGg3LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY2hlY2tTdGF0KGZzMTEuc3RhdFN5bmMocGF0aDcpLCBwYXRoNywgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShzeW5jLCBcInN5bmNcIik7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXNleGVAMi4wLjAvbm9kZV9tb2R1bGVzL2lzZXhlL21vZGUuanNcbnZhciByZXF1aXJlX21vZGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXNleGVAMi4wLjAvbm9kZV9tb2R1bGVzL2lzZXhlL21vZGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gaXNleGU7XG4gICAgaXNleGUuc3luYyA9IHN5bmM7XG4gICAgdmFyIGZzMTEgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgZnVuY3Rpb24gaXNleGUocGF0aDcsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBmczExLnN0YXQocGF0aDcsIGZ1bmN0aW9uKGVyLCBzdGF0KSB7XG4gICAgICAgIGNiKGVyLCBlciA/IGZhbHNlIDogY2hlY2tTdGF0KHN0YXQsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaXNleGUsIFwiaXNleGVcIik7XG4gICAgZnVuY3Rpb24gc3luYyhwYXRoNywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNoZWNrU3RhdChmczExLnN0YXRTeW5jKHBhdGg3KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShzeW5jLCBcInN5bmNcIik7XG4gICAgZnVuY3Rpb24gY2hlY2tTdGF0KHN0YXQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdGF0LmlzRmlsZSgpICYmIGNoZWNrTW9kZShzdGF0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgX19uYW1lKGNoZWNrU3RhdCwgXCJjaGVja1N0YXRcIik7XG4gICAgZnVuY3Rpb24gY2hlY2tNb2RlKHN0YXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2QyID0gc3RhdC5tb2RlO1xuICAgICAgdmFyIHVpZCA9IHN0YXQudWlkO1xuICAgICAgdmFyIGdpZCA9IHN0YXQuZ2lkO1xuICAgICAgdmFyIG15VWlkID0gb3B0aW9ucy51aWQgIT09IHZvaWQgMCA/IG9wdGlvbnMudWlkIDogcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKTtcbiAgICAgIHZhciBteUdpZCA9IG9wdGlvbnMuZ2lkICE9PSB2b2lkIDAgPyBvcHRpb25zLmdpZCA6IHByb2Nlc3MuZ2V0Z2lkICYmIHByb2Nlc3MuZ2V0Z2lkKCk7XG4gICAgICB2YXIgdSA9IHBhcnNlSW50KFwiMTAwXCIsIDgpO1xuICAgICAgdmFyIGcgPSBwYXJzZUludChcIjAxMFwiLCA4KTtcbiAgICAgIHZhciBvID0gcGFyc2VJbnQoXCIwMDFcIiwgOCk7XG4gICAgICB2YXIgdWcgPSB1IHwgZztcbiAgICAgIHZhciByZXQgPSBtb2QyICYgbyB8fCBtb2QyICYgZyAmJiBnaWQgPT09IG15R2lkIHx8IG1vZDIgJiB1ICYmIHVpZCA9PT0gbXlVaWQgfHwgbW9kMiAmIHVnICYmIG15VWlkID09PSAwO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgX19uYW1lKGNoZWNrTW9kZSwgXCJjaGVja01vZGVcIik7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXNleGVAMi4wLjAvbm9kZV9tb2R1bGVzL2lzZXhlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9pc2V4ZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pc2V4ZUAyLjAuMC9ub2RlX21vZHVsZXMvaXNleGUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGZzMTEgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgdmFyIGNvcmU7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiB8fCBnbG9iYWwuVEVTVElOR19XSU5ET1dTKSB7XG4gICAgICBjb3JlID0gcmVxdWlyZV93aW5kb3dzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcmUgPSByZXF1aXJlX21vZGUoKTtcbiAgICB9XG4gICAgbW9kdWxlMi5leHBvcnRzID0gaXNleGU7XG4gICAgaXNleGUuc3luYyA9IHN5bmM7XG4gICAgZnVuY3Rpb24gaXNleGUocGF0aDcsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICghY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgbm90IHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpc2V4ZShwYXRoNywgb3B0aW9ucyB8fCB7fSwgZnVuY3Rpb24oZXIsIGlzKSB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvcmUocGF0aDcsIG9wdGlvbnMgfHwge30sIGZ1bmN0aW9uKGVyLCBpcykge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgICBlciA9IG51bGw7XG4gICAgICAgICAgICBpcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYihlciwgaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShpc2V4ZSwgXCJpc2V4ZVwiKTtcbiAgICBmdW5jdGlvbiBzeW5jKHBhdGg3LCBvcHRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29yZS5zeW5jKHBhdGg3LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlRXJyb3JzIHx8IGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHN5bmMsIFwic3luY1wiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93aGljaEAyLjAuMi9ub2RlX21vZHVsZXMvd2hpY2gvd2hpY2guanNcbnZhciByZXF1aXJlX3doaWNoID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3doaWNoQDIuMC4yL25vZGVfbW9kdWxlcy93aGljaC93aGljaC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiIHx8IHByb2Nlc3MuZW52Lk9TVFlQRSA9PT0gXCJjeWd3aW5cIiB8fCBwcm9jZXNzLmVudi5PU1RZUEUgPT09IFwibXN5c1wiO1xuICAgIHZhciBwYXRoNyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBDT0xPTiA9IGlzV2luZG93cyA/IFwiO1wiIDogXCI6XCI7XG4gICAgdmFyIGlzZXhlID0gcmVxdWlyZV9pc2V4ZSgpO1xuICAgIHZhciBnZXROb3RGb3VuZEVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY21kKSA9PiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgbm90IGZvdW5kOiAke2NtZH1gKSwgeyBjb2RlOiBcIkVOT0VOVFwiIH0pLCBcImdldE5vdEZvdW5kRXJyb3JcIik7XG4gICAgdmFyIGdldFBhdGhJbmZvID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY21kLCBvcHQpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9uID0gb3B0LmNvbG9uIHx8IENPTE9OO1xuICAgICAgY29uc3QgcGF0aEVudiA9IGNtZC5tYXRjaCgvXFwvLykgfHwgaXNXaW5kb3dzICYmIGNtZC5tYXRjaCgvXFxcXC8pID8gW1wiXCJdIDogW1xuICAgICAgICAuLi5pc1dpbmRvd3MgPyBbcHJvY2Vzcy5jd2QoKV0gOiBbXSxcbiAgICAgICAgLi4uKG9wdC5wYXRoIHx8IHByb2Nlc3MuZW52LlBBVEggfHwgXCJcIikuc3BsaXQoY29sb24pXG4gICAgICBdO1xuICAgICAgY29uc3QgcGF0aEV4dEV4ZSA9IGlzV2luZG93cyA/IG9wdC5wYXRoRXh0IHx8IHByb2Nlc3MuZW52LlBBVEhFWFQgfHwgXCIuRVhFOy5DTUQ7LkJBVDsuQ09NXCIgOiBcIlwiO1xuICAgICAgY29uc3QgcGF0aEV4dCA9IGlzV2luZG93cyA/IHBhdGhFeHRFeGUuc3BsaXQoY29sb24pIDogW1wiXCJdO1xuICAgICAgaWYgKGlzV2luZG93cykge1xuICAgICAgICBpZiAoY21kLmluZGV4T2YoXCIuXCIpICE9PSAtMSAmJiBwYXRoRXh0WzBdICE9PSBcIlwiKVxuICAgICAgICAgIHBhdGhFeHQudW5zaGlmdChcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhFbnYsXG4gICAgICAgIHBhdGhFeHQsXG4gICAgICAgIHBhdGhFeHRFeGVcbiAgICAgIH07XG4gICAgfSwgXCJnZXRQYXRoSW5mb1wiKTtcbiAgICB2YXIgd2hpY2ggPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjbWQsIG9wdCwgY2IpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2IgPSBvcHQ7XG4gICAgICAgIG9wdCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFvcHQpXG4gICAgICAgIG9wdCA9IHt9O1xuICAgICAgY29uc3QgeyBwYXRoRW52LCBwYXRoRXh0LCBwYXRoRXh0RXhlIH0gPSBnZXRQYXRoSW5mbyhjbWQsIG9wdCk7XG4gICAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgICAgY29uc3Qgc3RlcCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGkpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IHBhdGhFbnYubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBvcHQuYWxsICYmIGZvdW5kLmxlbmd0aCA/IHJlc29sdmUoZm91bmQpIDogcmVqZWN0KGdldE5vdEZvdW5kRXJyb3IoY21kKSk7XG4gICAgICAgIGNvbnN0IHBwUmF3ID0gcGF0aEVudltpXTtcbiAgICAgICAgY29uc3QgcGF0aFBhcnQgPSAvXlwiLipcIiQvLnRlc3QocHBSYXcpID8gcHBSYXcuc2xpY2UoMSwgLTEpIDogcHBSYXc7XG4gICAgICAgIGNvbnN0IHBDbWQgPSBwYXRoNy5qb2luKHBhdGhQYXJ0LCBjbWQpO1xuICAgICAgICBjb25zdCBwID0gIXBhdGhQYXJ0ICYmIC9eXFwuW1xcXFxcXC9dLy50ZXN0KGNtZCkgPyBjbWQuc2xpY2UoMCwgMikgKyBwQ21kIDogcENtZDtcbiAgICAgICAgcmVzb2x2ZShzdWJTdGVwKHAsIGksIDApKTtcbiAgICAgIH0pLCBcInN0ZXBcIik7XG4gICAgICBjb25zdCBzdWJTdGVwID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocCwgaSwgaWkpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGlpID09PSBwYXRoRXh0Lmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShzdGVwKGkgKyAxKSk7XG4gICAgICAgIGNvbnN0IGV4dCA9IHBhdGhFeHRbaWldO1xuICAgICAgICBpc2V4ZShwICsgZXh0LCB7IHBhdGhFeHQ6IHBhdGhFeHRFeGUgfSwgKGVyLCBpcykgPT4ge1xuICAgICAgICAgIGlmICghZXIgJiYgaXMpIHtcbiAgICAgICAgICAgIGlmIChvcHQuYWxsKVxuICAgICAgICAgICAgICBmb3VuZC5wdXNoKHAgKyBleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwICsgZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3ViU3RlcChwLCBpLCBpaSArIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgXCJzdWJTdGVwXCIpO1xuICAgICAgcmV0dXJuIGNiID8gc3RlcCgwKS50aGVuKChyZXMpID0+IGNiKG51bGwsIHJlcyksIGNiKSA6IHN0ZXAoMCk7XG4gICAgfSwgXCJ3aGljaFwiKTtcbiAgICB2YXIgd2hpY2hTeW5jID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY21kLCBvcHQpID0+IHtcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGNvbnN0IHsgcGF0aEVudiwgcGF0aEV4dCwgcGF0aEV4dEV4ZSB9ID0gZ2V0UGF0aEluZm8oY21kLCBvcHQpO1xuICAgICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEVudi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcFJhdyA9IHBhdGhFbnZbaV07XG4gICAgICAgIGNvbnN0IHBhdGhQYXJ0ID0gL15cIi4qXCIkLy50ZXN0KHBwUmF3KSA/IHBwUmF3LnNsaWNlKDEsIC0xKSA6IHBwUmF3O1xuICAgICAgICBjb25zdCBwQ21kID0gcGF0aDcuam9pbihwYXRoUGFydCwgY21kKTtcbiAgICAgICAgY29uc3QgcCA9ICFwYXRoUGFydCAmJiAvXlxcLltcXFxcXFwvXS8udGVzdChjbWQpID8gY21kLnNsaWNlKDAsIDIpICsgcENtZCA6IHBDbWQ7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aEV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGN1ciA9IHAgKyBwYXRoRXh0W2pdO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpcyA9IGlzZXhlLnN5bmMoY3VyLCB7IHBhdGhFeHQ6IHBhdGhFeHRFeGUgfSk7XG4gICAgICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdC5hbGwpXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChjdXIpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdC5hbGwgJiYgZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICBpZiAob3B0Lm5vdGhyb3cpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdGhyb3cgZ2V0Tm90Rm91bmRFcnJvcihjbWQpO1xuICAgIH0sIFwid2hpY2hTeW5jXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHdoaWNoO1xuICAgIHdoaWNoLnN5bmMgPSB3aGljaFN5bmM7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGF0aC1rZXlAMy4xLjEvbm9kZV9tb2R1bGVzL3BhdGgta2V5L2luZGV4LmpzXG52YXIgcmVxdWlyZV9wYXRoX2tleSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wYXRoLWtleUAzLjEuMS9ub2RlX21vZHVsZXMvcGF0aC1rZXkvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHBhdGhLZXkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnYgfHwgcHJvY2Vzcy5lbnY7XG4gICAgICBjb25zdCBwbGF0Zm9ybTMgPSBvcHRpb25zLnBsYXRmb3JtIHx8IHByb2Nlc3MucGxhdGZvcm07XG4gICAgICBpZiAocGxhdGZvcm0zICE9PSBcIndpbjMyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiUEFUSFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGVudmlyb25tZW50KS5yZXZlcnNlKCkuZmluZCgoa2V5KSA9PiBrZXkudG9VcHBlckNhc2UoKSA9PT0gXCJQQVRIXCIpIHx8IFwiUGF0aFwiO1xuICAgIH0sIFwicGF0aEtleVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwYXRoS2V5O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gcGF0aEtleTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvcmVzb2x2ZUNvbW1hbmQuanNcbnZhciByZXF1aXJlX3Jlc29sdmVDb21tYW5kID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvdXRpbC9yZXNvbHZlQ29tbWFuZC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGF0aDcgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICB2YXIgd2hpY2ggPSByZXF1aXJlX3doaWNoKCk7XG4gICAgdmFyIGdldFBhdGhLZXkgPSByZXF1aXJlX3BhdGhfa2V5KCk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbW1hbmRBdHRlbXB0KHBhcnNlZCwgd2l0aG91dFBhdGhFeHQpIHtcbiAgICAgIGNvbnN0IGVudjIgPSBwYXJzZWQub3B0aW9ucy5lbnYgfHwgcHJvY2Vzcy5lbnY7XG4gICAgICBjb25zdCBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgY29uc3QgaGFzQ3VzdG9tQ3dkID0gcGFyc2VkLm9wdGlvbnMuY3dkICE9IG51bGw7XG4gICAgICBjb25zdCBzaG91bGRTd2l0Y2hDd2QgPSBoYXNDdXN0b21Dd2QgJiYgcHJvY2Vzcy5jaGRpciAhPT0gdm9pZCAwICYmICFwcm9jZXNzLmNoZGlyLmRpc2FibGVkO1xuICAgICAgaWYgKHNob3VsZFN3aXRjaEN3ZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb2Nlc3MuY2hkaXIocGFyc2VkLm9wdGlvbnMuY3dkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCByZXNvbHZlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVkID0gd2hpY2guc3luYyhwYXJzZWQuY29tbWFuZCwge1xuICAgICAgICAgIHBhdGg6IGVudjJbZ2V0UGF0aEtleSh7IGVudjogZW52MiB9KV0sXG4gICAgICAgICAgcGF0aEV4dDogd2l0aG91dFBhdGhFeHQgPyBwYXRoNy5kZWxpbWl0ZXIgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoc2hvdWxkU3dpdGNoQ3dkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5jaGRpcihjd2QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSBwYXRoNy5yZXNvbHZlKGhhc0N1c3RvbUN3ZCA/IHBhcnNlZC5vcHRpb25zLmN3ZCA6IFwiXCIsIHJlc29sdmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG4gICAgX19uYW1lKHJlc29sdmVDb21tYW5kQXR0ZW1wdCwgXCJyZXNvbHZlQ29tbWFuZEF0dGVtcHRcIik7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbW1hbmQocGFyc2VkKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZUNvbW1hbmRBdHRlbXB0KHBhcnNlZCkgfHwgcmVzb2x2ZUNvbW1hbmRBdHRlbXB0KHBhcnNlZCwgdHJ1ZSk7XG4gICAgfVxuICAgIF9fbmFtZShyZXNvbHZlQ29tbWFuZCwgXCJyZXNvbHZlQ29tbWFuZFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXNvbHZlQ29tbWFuZDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvZXNjYXBlLmpzXG52YXIgcmVxdWlyZV9lc2NhcGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi91dGlsL2VzY2FwZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbWV0YUNoYXJzUmVnRXhwID0gLyhbKClcXF1bJSFeXCJgPD4mfDssICo/XSkvZztcbiAgICBmdW5jdGlvbiBlc2NhcGVDb21tYW5kKGFyZzIpIHtcbiAgICAgIGFyZzIgPSBhcmcyLnJlcGxhY2UobWV0YUNoYXJzUmVnRXhwLCBcIl4kMVwiKTtcbiAgICAgIHJldHVybiBhcmcyO1xuICAgIH1cbiAgICBfX25hbWUoZXNjYXBlQ29tbWFuZCwgXCJlc2NhcGVDb21tYW5kXCIpO1xuICAgIGZ1bmN0aW9uIGVzY2FwZUFyZ3VtZW50KGFyZzIsIGRvdWJsZUVzY2FwZU1ldGFDaGFycykge1xuICAgICAgYXJnMiA9IGAke2FyZzJ9YDtcbiAgICAgIGFyZzIgPSBhcmcyLnJlcGxhY2UoLyhcXFxcKilcIi9nLCAnJDEkMVxcXFxcIicpO1xuICAgICAgYXJnMiA9IGFyZzIucmVwbGFjZSgvKFxcXFwqKSQvLCBcIiQxJDFcIik7XG4gICAgICBhcmcyID0gYFwiJHthcmcyfVwiYDtcbiAgICAgIGFyZzIgPSBhcmcyLnJlcGxhY2UobWV0YUNoYXJzUmVnRXhwLCBcIl4kMVwiKTtcbiAgICAgIGlmIChkb3VibGVFc2NhcGVNZXRhQ2hhcnMpIHtcbiAgICAgICAgYXJnMiA9IGFyZzIucmVwbGFjZShtZXRhQ2hhcnNSZWdFeHAsIFwiXiQxXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZzI7XG4gICAgfVxuICAgIF9fbmFtZShlc2NhcGVBcmd1bWVudCwgXCJlc2NhcGVBcmd1bWVudFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29tbWFuZCA9IGVzY2FwZUNvbW1hbmQ7XG4gICAgbW9kdWxlMi5leHBvcnRzLmFyZ3VtZW50ID0gZXNjYXBlQXJndW1lbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2hlYmFuZy1yZWdleEAzLjAuMC9ub2RlX21vZHVsZXMvc2hlYmFuZy1yZWdleC9pbmRleC5qc1xudmFyIHJlcXVpcmVfc2hlYmFuZ19yZWdleCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGViYW5nLXJlZ2V4QDMuMC4wL25vZGVfbW9kdWxlcy9zaGViYW5nLXJlZ2V4L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IC9eIyEoLiopLztcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGViYW5nLWNvbW1hbmRAMi4wLjAvbm9kZV9tb2R1bGVzL3NoZWJhbmctY29tbWFuZC9pbmRleC5qc1xudmFyIHJlcXVpcmVfc2hlYmFuZ19jb21tYW5kID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoZWJhbmctY29tbWFuZEAyLjAuMC9ub2RlX21vZHVsZXMvc2hlYmFuZy1jb21tYW5kL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBzaGViYW5nUmVnZXggPSByZXF1aXJlX3NoZWJhbmdfcmVnZXgoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAoc3RyaW5nID0gXCJcIikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2goc2hlYmFuZ1JlZ2V4KTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBbcGF0aDcsIGFyZ3VtZW50XSA9IG1hdGNoWzBdLnJlcGxhY2UoLyMhID8vLCBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBiaW5hcnkgPSBwYXRoNy5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgICBpZiAoYmluYXJ5ID09PSBcImVudlwiKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmd1bWVudCA/IGAke2JpbmFyeX0gJHthcmd1bWVudH1gIDogYmluYXJ5O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi91dGlsL3JlYWRTaGViYW5nLmpzXG52YXIgcmVxdWlyZV9yZWFkU2hlYmFuZyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL3V0aWwvcmVhZFNoZWJhbmcuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZzMTEgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgdmFyIHNoZWJhbmdDb21tYW5kID0gcmVxdWlyZV9zaGViYW5nX2NvbW1hbmQoKTtcbiAgICBmdW5jdGlvbiByZWFkU2hlYmFuZyhjb21tYW5kKSB7XG4gICAgICBjb25zdCBzaXplID0gMTUwO1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgbGV0IGZkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmQgPSBmczExLm9wZW5TeW5jKGNvbW1hbmQsIFwiclwiKTtcbiAgICAgICAgZnMxMS5yZWFkU3luYyhmZCwgYnVmZmVyLCAwLCBzaXplLCAwKTtcbiAgICAgICAgZnMxMS5jbG9zZVN5bmMoZmQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoZWJhbmdDb21tYW5kKGJ1ZmZlci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgX19uYW1lKHJlYWRTaGViYW5nLCBcInJlYWRTaGViYW5nXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlYWRTaGViYW5nO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvcGFyc2UuanNcbnZhciByZXF1aXJlX3BhcnNlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLXNwYXduQDcuMC4zL25vZGVfbW9kdWxlcy9jcm9zcy1zcGF3bi9saWIvcGFyc2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHBhdGg3ID0gcmVxdWlyZShcInBhdGhcIik7XG4gICAgdmFyIHJlc29sdmVDb21tYW5kID0gcmVxdWlyZV9yZXNvbHZlQ29tbWFuZCgpO1xuICAgIHZhciBlc2NhcGUgPSByZXF1aXJlX2VzY2FwZSgpO1xuICAgIHZhciByZWFkU2hlYmFuZyA9IHJlcXVpcmVfcmVhZFNoZWJhbmcoKTtcbiAgICB2YXIgaXNXaW4gPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG4gICAgdmFyIGlzRXhlY3V0YWJsZVJlZ0V4cCA9IC9cXC4oPzpjb218ZXhlKSQvaTtcbiAgICB2YXIgaXNDbWRTaGltUmVnRXhwID0gL25vZGVfbW9kdWxlc1tcXFxcL10uYmluW1xcXFwvXVteXFxcXC9dK1xcLmNtZCQvaTtcbiAgICBmdW5jdGlvbiBkZXRlY3RTaGViYW5nKHBhcnNlZCkge1xuICAgICAgcGFyc2VkLmZpbGUgPSByZXNvbHZlQ29tbWFuZChwYXJzZWQpO1xuICAgICAgY29uc3Qgc2hlYmFuZyA9IHBhcnNlZC5maWxlICYmIHJlYWRTaGViYW5nKHBhcnNlZC5maWxlKTtcbiAgICAgIGlmIChzaGViYW5nKSB7XG4gICAgICAgIHBhcnNlZC5hcmdzLnVuc2hpZnQocGFyc2VkLmZpbGUpO1xuICAgICAgICBwYXJzZWQuY29tbWFuZCA9IHNoZWJhbmc7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tbWFuZChwYXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZC5maWxlO1xuICAgIH1cbiAgICBfX25hbWUoZGV0ZWN0U2hlYmFuZywgXCJkZXRlY3RTaGViYW5nXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlTm9uU2hlbGwocGFyc2VkKSB7XG4gICAgICBpZiAoIWlzV2luKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kRmlsZSA9IGRldGVjdFNoZWJhbmcocGFyc2VkKTtcbiAgICAgIGNvbnN0IG5lZWRzU2hlbGwgPSAhaXNFeGVjdXRhYmxlUmVnRXhwLnRlc3QoY29tbWFuZEZpbGUpO1xuICAgICAgaWYgKHBhcnNlZC5vcHRpb25zLmZvcmNlU2hlbGwgfHwgbmVlZHNTaGVsbCkge1xuICAgICAgICBjb25zdCBuZWVkc0RvdWJsZUVzY2FwZU1ldGFDaGFycyA9IGlzQ21kU2hpbVJlZ0V4cC50ZXN0KGNvbW1hbmRGaWxlKTtcbiAgICAgICAgcGFyc2VkLmNvbW1hbmQgPSBwYXRoNy5ub3JtYWxpemUocGFyc2VkLmNvbW1hbmQpO1xuICAgICAgICBwYXJzZWQuY29tbWFuZCA9IGVzY2FwZS5jb21tYW5kKHBhcnNlZC5jb21tYW5kKTtcbiAgICAgICAgcGFyc2VkLmFyZ3MgPSBwYXJzZWQuYXJncy5tYXAoKGFyZzIpID0+IGVzY2FwZS5hcmd1bWVudChhcmcyLCBuZWVkc0RvdWJsZUVzY2FwZU1ldGFDaGFycykpO1xuICAgICAgICBjb25zdCBzaGVsbENvbW1hbmQgPSBbcGFyc2VkLmNvbW1hbmRdLmNvbmNhdChwYXJzZWQuYXJncykuam9pbihcIiBcIik7XG4gICAgICAgIHBhcnNlZC5hcmdzID0gW1wiL2RcIiwgXCIvc1wiLCBcIi9jXCIsIGBcIiR7c2hlbGxDb21tYW5kfVwiYF07XG4gICAgICAgIHBhcnNlZC5jb21tYW5kID0gcHJvY2Vzcy5lbnYuY29tc3BlYyB8fCBcImNtZC5leGVcIjtcbiAgICAgICAgcGFyc2VkLm9wdGlvbnMud2luZG93c1ZlcmJhdGltQXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZU5vblNoZWxsLCBcInBhcnNlTm9uU2hlbGxcIik7XG4gICAgZnVuY3Rpb24gcGFyc2UyKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhcmdzICYmICFBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzO1xuICAgICAgICBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFyZ3MgPSBhcmdzID8gYXJncy5zbGljZSgwKSA6IFtdO1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICBjb21tYW5kLFxuICAgICAgICBhcmdzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmaWxlOiB2b2lkIDAsXG4gICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gb3B0aW9ucy5zaGVsbCA/IHBhcnNlZCA6IHBhcnNlTm9uU2hlbGwocGFyc2VkKTtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlMiwgXCJwYXJzZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwYXJzZTI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2xpYi9lbm9lbnQuanNcbnZhciByZXF1aXJlX2Vub2VudCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vbGliL2Vub2VudC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNXaW4gPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG4gICAgZnVuY3Rpb24gbm90Rm91bmRFcnJvcihvcmlnaW5hbCwgc3lzY2FsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGAke3N5c2NhbGx9ICR7b3JpZ2luYWwuY29tbWFuZH0gRU5PRU5UYCksIHtcbiAgICAgICAgY29kZTogXCJFTk9FTlRcIixcbiAgICAgICAgZXJybm86IFwiRU5PRU5UXCIsXG4gICAgICAgIHN5c2NhbGw6IGAke3N5c2NhbGx9ICR7b3JpZ2luYWwuY29tbWFuZH1gLFxuICAgICAgICBwYXRoOiBvcmlnaW5hbC5jb21tYW5kLFxuICAgICAgICBzcGF3bmFyZ3M6IG9yaWdpbmFsLmFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUobm90Rm91bmRFcnJvciwgXCJub3RGb3VuZEVycm9yXCIpO1xuICAgIGZ1bmN0aW9uIGhvb2tDaGlsZFByb2Nlc3MoY3AsIHBhcnNlZCkge1xuICAgICAgaWYgKCFpc1dpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcmlnaW5hbEVtaXQgPSBjcC5lbWl0O1xuICAgICAgY3AuZW1pdCA9IGZ1bmN0aW9uKG5hbWUsIGFyZzEpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiZXhpdFwiKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gdmVyaWZ5RU5PRU5UKGFyZzEsIHBhcnNlZCwgXCJzcGF3blwiKTtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxFbWl0LmNhbGwoY3AsIFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRW1pdC5hcHBseShjcCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShob29rQ2hpbGRQcm9jZXNzLCBcImhvb2tDaGlsZFByb2Nlc3NcIik7XG4gICAgZnVuY3Rpb24gdmVyaWZ5RU5PRU5UKHN0YXR1cywgcGFyc2VkKSB7XG4gICAgICBpZiAoaXNXaW4gJiYgc3RhdHVzID09PSAxICYmICFwYXJzZWQuZmlsZSkge1xuICAgICAgICByZXR1cm4gbm90Rm91bmRFcnJvcihwYXJzZWQub3JpZ2luYWwsIFwic3Bhd25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHZlcmlmeUVOT0VOVCwgXCJ2ZXJpZnlFTk9FTlRcIik7XG4gICAgZnVuY3Rpb24gdmVyaWZ5RU5PRU5UU3luYyhzdGF0dXMsIHBhcnNlZCkge1xuICAgICAgaWYgKGlzV2luICYmIHN0YXR1cyA9PT0gMSAmJiAhcGFyc2VkLmZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvdW5kRXJyb3IocGFyc2VkLm9yaWdpbmFsLCBcInNwYXduU3luY1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfX25hbWUodmVyaWZ5RU5PRU5UU3luYywgXCJ2ZXJpZnlFTk9FTlRTeW5jXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGhvb2tDaGlsZFByb2Nlc3MsXG4gICAgICB2ZXJpZnlFTk9FTlQsXG4gICAgICB2ZXJpZnlFTk9FTlRTeW5jLFxuICAgICAgbm90Rm91bmRFcnJvclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3Jvc3Mtc3Bhd25ANy4wLjMvbm9kZV9tb2R1bGVzL2Nyb3NzLXNwYXduL2luZGV4LmpzXG52YXIgcmVxdWlyZV9jcm9zc19zcGF3biA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jcm9zcy1zcGF3bkA3LjAuMy9ub2RlX21vZHVsZXMvY3Jvc3Mtc3Bhd24vaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNwID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG4gICAgdmFyIHBhcnNlMiA9IHJlcXVpcmVfcGFyc2UoKTtcbiAgICB2YXIgZW5vZW50ID0gcmVxdWlyZV9lbm9lbnQoKTtcbiAgICBmdW5jdGlvbiBzcGF3bjIoY29tbWFuZCwgYXJncywgb3B0aW9ucykge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UyKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc3Bhd25lZCA9IGNwLnNwYXduKHBhcnNlZC5jb21tYW5kLCBwYXJzZWQuYXJncywgcGFyc2VkLm9wdGlvbnMpO1xuICAgICAgZW5vZW50Lmhvb2tDaGlsZFByb2Nlc3Moc3Bhd25lZCwgcGFyc2VkKTtcbiAgICAgIHJldHVybiBzcGF3bmVkO1xuICAgIH1cbiAgICBfX25hbWUoc3Bhd24yLCBcInNwYXduXCIpO1xuICAgIGZ1bmN0aW9uIHNwYXduU3luYyhjb21tYW5kLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZTIoY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcC5zcGF3blN5bmMocGFyc2VkLmNvbW1hbmQsIHBhcnNlZC5hcmdzLCBwYXJzZWQub3B0aW9ucyk7XG4gICAgICByZXN1bHQuZXJyb3IgPSByZXN1bHQuZXJyb3IgfHwgZW5vZW50LnZlcmlmeUVOT0VOVFN5bmMocmVzdWx0LnN0YXR1cywgcGFyc2VkKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShzcGF3blN5bmMsIFwic3Bhd25TeW5jXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHNwYXduMjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuc3Bhd24gPSBzcGF3bjI7XG4gICAgbW9kdWxlMi5leHBvcnRzLnN5bmMgPSBzcGF3blN5bmM7XG4gICAgbW9kdWxlMi5leHBvcnRzLl9wYXJzZSA9IHBhcnNlMjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuX2Vub2VudCA9IGVub2VudDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJpc21hK2VuZ2luZXMtdmVyc2lvbkA0LjMuMC0zMi5jODc1ZTQzNjAwZGZlMDQyNDUyZTBiODY4ZjdhNDhiODE3Yjk2NDBiL25vZGVfbW9kdWxlcy9AcHJpc21hL2VuZ2luZXMtdmVyc2lvbi9wYWNrYWdlLmpzb25cbnZhciByZXF1aXJlX3BhY2thZ2UgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByaXNtYStlbmdpbmVzLXZlcnNpb25ANC4zLjAtMzIuYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYi9ub2RlX21vZHVsZXMvQHByaXNtYS9lbmdpbmVzLXZlcnNpb24vcGFja2FnZS5qc29uXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIG5hbWU6IFwiQHByaXNtYS9lbmdpbmVzLXZlcnNpb25cIixcbiAgICAgIHZlcnNpb246IFwiNC4zLjAtMzIuYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYlwiLFxuICAgICAgbWFpbjogXCJpbmRleC5qc1wiLFxuICAgICAgdHlwZXM6IFwiaW5kZXguZC50c1wiLFxuICAgICAgbGljZW5zZTogXCJBcGFjaGUtMi4wXCIsXG4gICAgICBhdXRob3I6IFwiVGltIFN1Y2hhbmVrIDxzdWNoYW5la0BwcmlzbWEuaW8+XCIsXG4gICAgICBwcmlzbWE6IHtcbiAgICAgICAgZW5naW5lc1ZlcnNpb246IFwiYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYlwiXG4gICAgICB9LFxuICAgICAgcmVwb3NpdG9yeToge1xuICAgICAgICB0eXBlOiBcImdpdFwiLFxuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9lbmdpbmVzLXdyYXBwZXIuZ2l0XCIsXG4gICAgICAgIGRpcmVjdG9yeTogXCJwYWNrYWdlcy9lbmdpbmVzLXZlcnNpb25cIlxuICAgICAgfSxcbiAgICAgIGRldkRlcGVuZGVuY2llczoge1xuICAgICAgICBcIkB0eXBlcy9ub2RlXCI6IFwiMTYuMTEuNTZcIixcbiAgICAgICAgdHlwZXNjcmlwdDogXCI0LjcuNFwiXG4gICAgICB9LFxuICAgICAgZmlsZXM6IFtcbiAgICAgICAgXCJpbmRleC5qc1wiLFxuICAgICAgICBcImluZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIHNjcmlwdHM6IHtcbiAgICAgICAgYnVpbGQ6IFwidHNjIC1kXCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BwcmlzbWErZW5naW5lcy12ZXJzaW9uQDQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGIvbm9kZV9tb2R1bGVzL0BwcmlzbWEvZW5naW5lcy12ZXJzaW9uL2luZGV4LmpzXG52YXIgcmVxdWlyZV9lbmdpbmVzX3ZlcnNpb24gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByaXNtYStlbmdpbmVzLXZlcnNpb25ANC4zLjAtMzIuYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYi9ub2RlX21vZHVsZXMvQHByaXNtYS9lbmdpbmVzLXZlcnNpb24vaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuZW5naW5lc1ZlcnNpb24gPSB2b2lkIDA7XG4gICAgZXhwb3J0cy5lbmdpbmVzVmVyc2lvbiA9IHJlcXVpcmVfcGFja2FnZSgpLnByaXNtYS5lbmdpbmVzVmVyc2lvbjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpcC1maW5hbC1uZXdsaW5lQDIuMC4wL25vZGVfbW9kdWxlcy9zdHJpcC1maW5hbC1uZXdsaW5lL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zdHJpcF9maW5hbF9uZXdsaW5lID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmlwLWZpbmFsLW5ld2xpbmVAMi4wLjAvbm9kZV9tb2R1bGVzL3N0cmlwLWZpbmFsLW5ld2xpbmUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBMRiA9IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IFwiXFxuXCIgOiBcIlxcblwiLmNoYXJDb2RlQXQoKTtcbiAgICAgIGNvbnN0IENSID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gXCJcXHJcIiA6IFwiXFxyXCIuY2hhckNvZGVBdCgpO1xuICAgICAgaWYgKGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdID09PSBMRikge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDAsIGlucHV0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdID09PSBDUikge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDAsIGlucHV0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbnBtLXJ1bi1wYXRoQDQuMC4xL25vZGVfbW9kdWxlcy9ucG0tcnVuLXBhdGgvaW5kZXguanNcbnZhciByZXF1aXJlX25wbV9ydW5fcGF0aCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ucG0tcnVuLXBhdGhANC4wLjEvbm9kZV9tb2R1bGVzL25wbS1ydW4tcGF0aC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGF0aDcgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICB2YXIgcGF0aEtleSA9IHJlcXVpcmVfcGF0aF9rZXkoKTtcbiAgICB2YXIgbnBtUnVuUGF0aCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICAgICAgcGF0aDogcHJvY2Vzcy5lbnZbcGF0aEtleSgpXSxcbiAgICAgICAgZXhlY1BhdGg6IHByb2Nlc3MuZXhlY1BhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBsZXQgcHJldmlvdXM7XG4gICAgICBsZXQgY3dkUGF0aCA9IHBhdGg3LnJlc29sdmUob3B0aW9ucy5jd2QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAocHJldmlvdXMgIT09IGN3ZFBhdGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGF0aDcuam9pbihjd2RQYXRoLCBcIm5vZGVfbW9kdWxlcy8uYmluXCIpKTtcbiAgICAgICAgcHJldmlvdXMgPSBjd2RQYXRoO1xuICAgICAgICBjd2RQYXRoID0gcGF0aDcucmVzb2x2ZShjd2RQYXRoLCBcIi4uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhlY1BhdGhEaXIgPSBwYXRoNy5yZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmV4ZWNQYXRoLCBcIi4uXCIpO1xuICAgICAgcmVzdWx0LnB1c2goZXhlY1BhdGhEaXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQob3B0aW9ucy5wYXRoKS5qb2luKHBhdGg3LmRlbGltaXRlcik7XG4gICAgfSwgXCJucG1SdW5QYXRoXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG5wbVJ1blBhdGg7XG4gICAgbW9kdWxlMi5leHBvcnRzLmRlZmF1bHQgPSBucG1SdW5QYXRoO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5lbnYgPSAob3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGVudjIgPSB7IC4uLm9wdGlvbnMuZW52IH07XG4gICAgICBjb25zdCBwYXRoOCA9IHBhdGhLZXkoeyBlbnY6IGVudjIgfSk7XG4gICAgICBvcHRpb25zLnBhdGggPSBlbnYyW3BhdGg4XTtcbiAgICAgIGVudjJbcGF0aDhdID0gbW9kdWxlMi5leHBvcnRzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGVudjI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW1pYy1mbkAyLjEuMC9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanNcbnZhciByZXF1aXJlX21pbWljX2ZuID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21pbWljLWZuQDIuMS4wL25vZGVfbW9kdWxlcy9taW1pYy1mbi9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbWltaWNGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHRvLCBmcm9tKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG87XG4gICAgfSwgXCJtaW1pY0ZuXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG1pbWljRm47XG4gICAgbW9kdWxlMi5leHBvcnRzLmRlZmF1bHQgPSBtaW1pY0ZuO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL29uZXRpbWVANS4xLjIvbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanNcbnZhciByZXF1aXJlX29uZXRpbWUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vb25ldGltZUA1LjEuMi9ub2RlX21vZHVsZXMvb25ldGltZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbWltaWNGbiA9IHJlcXVpcmVfbWltaWNfZm4oKTtcbiAgICB2YXIgY2FsbGVkRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIG9uZXRpbWUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmdW5jdGlvbl8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbl8gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8IFwiPGFub255bW91cz5cIjtcbiAgICAgIGNvbnN0IG9uZXRpbWUyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiguLi5hcmd1bWVudHNfKSB7XG4gICAgICAgIGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZTIsICsrY2FsbENvdW50KTtcbiAgICAgICAgaWYgKGNhbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gZnVuY3Rpb25fLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pO1xuICAgICAgICAgIGZ1bmN0aW9uXyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50aHJvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gXFxgJHtmdW5jdGlvbk5hbWV9XFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfSwgXCJvbmV0aW1lXCIpO1xuICAgICAgbWltaWNGbihvbmV0aW1lMiwgZnVuY3Rpb25fKTtcbiAgICAgIGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZTIsIGNhbGxDb3VudCk7XG4gICAgICByZXR1cm4gb25ldGltZTI7XG4gICAgfSwgXCJvbmV0aW1lXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG9uZXRpbWU7XG4gICAgbW9kdWxlMi5leHBvcnRzLmRlZmF1bHQgPSBvbmV0aW1lO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5jYWxsQ291bnQgPSAoZnVuY3Rpb25fKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZEZ1bmN0aW9ucy5oYXMoZnVuY3Rpb25fKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvY29yZS5qc1xudmFyIHJlcXVpcmVfY29yZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9jb3JlLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLlNJR05BTFMgPSB2b2lkIDA7XG4gICAgdmFyIFNJR05BTFMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHSFVQXCIsXG4gICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUZXJtaW5hbCBjbG9zZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdJTlRcIixcbiAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZXIgaW50ZXJydXB0aW9uIHdpdGggQ1RSTC1DXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImFuc2lcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdRVUlUXCIsXG4gICAgICAgIG51bWJlcjogMyxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVXNlciBpbnRlcnJ1cHRpb24gd2l0aCBDVFJMLVxcXFxcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdJTExcIixcbiAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnZhbGlkIG1hY2hpbmUgaW5zdHJ1Y3Rpb25cIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYW5zaVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1RSQVBcIixcbiAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWJ1Z2dlciBicmVha3BvaW50XCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQUJSVFwiLFxuICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFib3J0ZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYW5zaVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0lPVFwiLFxuICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFib3J0ZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQlVTXCIsXG4gICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQnVzIGVycm9yIGR1ZSB0byBtaXNhbGlnbmVkLCBub24tZXhpc3RpbmcgYWRkcmVzcyBvciBwYWdpbmcgZXJyb3JcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHRU1UXCIsXG4gICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDb21tYW5kIHNob3VsZCBiZSBlbXVsYXRlZCBidXQgaXMgbm90IGltcGxlbWVudGVkXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcIm90aGVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHRlBFXCIsXG4gICAgICAgIG51bWJlcjogOCxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBlcnJvclwiLFxuICAgICAgICBzdGFuZGFyZDogXCJhbnNpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHS0lMTFwiLFxuICAgICAgICBudW1iZXI6IDksXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRm9yY2VkIHRlcm1pbmF0aW9uXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCIsXG4gICAgICAgIGZvcmNlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdVU1IxXCIsXG4gICAgICAgIG51bWJlcjogMTAsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQXBwbGljYXRpb24tc3BlY2lmaWMgc2lnbmFsXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHU0VHVlwiLFxuICAgICAgICBudW1iZXI6IDExLFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZWdtZW50YXRpb24gZmF1bHRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYW5zaVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1VTUjJcIixcbiAgICAgICAgbnVtYmVyOiAxMixcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBcHBsaWNhdGlvbi1zcGVjaWZpYyBzaWduYWxcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdQSVBFXCIsXG4gICAgICAgIG51bWJlcjogMTMsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQnJva2VuIHBpcGUgb3Igc29ja2V0XCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHQUxSTVwiLFxuICAgICAgICBudW1iZXI6IDE0LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRpbWVvdXQgb3IgdGltZXJcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdURVJNXCIsXG4gICAgICAgIG51bWJlcjogMTUsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGVybWluYXRpb25cIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYW5zaVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1NUS0ZMVFwiLFxuICAgICAgICBudW1iZXI6IDE2LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlN0YWNrIGlzIGVtcHR5IG9yIG92ZXJmbG93ZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdDSExEXCIsXG4gICAgICAgIG51bWJlcjogMTcsXG4gICAgICAgIGFjdGlvbjogXCJpZ25vcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ2hpbGQgcHJvY2VzcyB0ZXJtaW5hdGVkLCBwYXVzZWQgb3IgdW5wYXVzZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdDTERcIixcbiAgICAgICAgbnVtYmVyOiAxNyxcbiAgICAgICAgYWN0aW9uOiBcImlnbm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDaGlsZCBwcm9jZXNzIHRlcm1pbmF0ZWQsIHBhdXNlZCBvciB1bnBhdXNlZFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0NPTlRcIixcbiAgICAgICAgbnVtYmVyOiAxOCxcbiAgICAgICAgYWN0aW9uOiBcInVucGF1c2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVW5wYXVzZWRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIixcbiAgICAgICAgZm9yY2VkOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1NUT1BcIixcbiAgICAgICAgbnVtYmVyOiAxOSxcbiAgICAgICAgYWN0aW9uOiBcInBhdXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBhdXNlZFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJwb3NpeFwiLFxuICAgICAgICBmb3JjZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVFNUUFwiLFxuICAgICAgICBudW1iZXI6IDIwLFxuICAgICAgICBhY3Rpb246IFwicGF1c2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246ICdQYXVzZWQgdXNpbmcgQ1RSTC1aIG9yIFwic3VzcGVuZFwiJyxcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdUVElOXCIsXG4gICAgICAgIG51bWJlcjogMjEsXG4gICAgICAgIGFjdGlvbjogXCJwYXVzZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJCYWNrZ3JvdW5kIHByb2Nlc3MgY2Fubm90IHJlYWQgdGVybWluYWwgaW5wdXRcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdCUkVBS1wiLFxuICAgICAgICBudW1iZXI6IDIxLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZXIgaW50ZXJydXB0aW9uIHdpdGggQ1RSTC1CUkVBS1wiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1RUT1VcIixcbiAgICAgICAgbnVtYmVyOiAyMixcbiAgICAgICAgYWN0aW9uOiBcInBhdXNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkJhY2tncm91bmQgcHJvY2VzcyBjYW5ub3Qgd3JpdGUgdG8gdGVybWluYWwgb3V0cHV0XCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInBvc2l4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHVVJHXCIsXG4gICAgICAgIG51bWJlcjogMjMsXG4gICAgICAgIGFjdGlvbjogXCJpZ25vcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU29ja2V0IHJlY2VpdmVkIG91dC1vZi1iYW5kIGRhdGFcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwiYnNkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHWENQVVwiLFxuICAgICAgICBudW1iZXI6IDI0LFxuICAgICAgICBhY3Rpb246IFwiY29yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJQcm9jZXNzIHRpbWVkIG91dFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJic2RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdYRlNaXCIsXG4gICAgICAgIG51bWJlcjogMjUsXG4gICAgICAgIGFjdGlvbjogXCJjb3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbGUgdG9vIGJpZ1wiLFxuICAgICAgICBzdGFuZGFyZDogXCJic2RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdWVEFMUk1cIixcbiAgICAgICAgbnVtYmVyOiAyNixcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaW1lb3V0IG9yIHRpbWVyXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImJzZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1BST0ZcIixcbiAgICAgICAgbnVtYmVyOiAyNyxcbiAgICAgICAgYWN0aW9uOiBcInRlcm1pbmF0ZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaW1lb3V0IG9yIHRpbWVyXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcImJzZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1dJTkNIXCIsXG4gICAgICAgIG51bWJlcjogMjgsXG4gICAgICAgIGFjdGlvbjogXCJpZ25vcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGVybWluYWwgd2luZG93IHNpemUgY2hhbmdlZFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJic2RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdJT1wiLFxuICAgICAgICBudW1iZXI6IDI5LFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkkvTyBpcyBhdmFpbGFibGVcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdQT0xMXCIsXG4gICAgICAgIG51bWJlcjogMjksXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiV2F0Y2hlZCBldmVudFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR0lORk9cIixcbiAgICAgICAgbnVtYmVyOiAyOSxcbiAgICAgICAgYWN0aW9uOiBcImlnbm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXF1ZXN0IGZvciBwcm9jZXNzIGluZm9ybWF0aW9uXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcIm90aGVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU0lHUFdSXCIsXG4gICAgICAgIG51bWJlcjogMzAsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRGV2aWNlIHJ1bm5pbmcgb3V0IG9mIHBvd2VyXCIsXG4gICAgICAgIHN0YW5kYXJkOiBcInN5c3RlbXZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJTSUdTWVNcIixcbiAgICAgICAgbnVtYmVyOiAzMSxcbiAgICAgICAgYWN0aW9uOiBcImNvcmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW52YWxpZCBzeXN0ZW0gY2FsbFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJvdGhlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlNJR1VOVVNFRFwiLFxuICAgICAgICBudW1iZXI6IDMxLFxuICAgICAgICBhY3Rpb246IFwidGVybWluYXRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkludmFsaWQgc3lzdGVtIGNhbGxcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwib3RoZXJcIlxuICAgICAgfVxuICAgIF07XG4gICAgZXhwb3J0cy5TSUdOQUxTID0gU0lHTkFMUztcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9yZWFsdGltZS5qc1xudmFyIHJlcXVpcmVfcmVhbHRpbWUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHVtYW4tc2lnbmFsc0AyLjEuMC9ub2RlX21vZHVsZXMvaHVtYW4tc2lnbmFscy9idWlsZC9zcmMvcmVhbHRpbWUuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuU0lHUlRNQVggPSBleHBvcnRzLmdldFJlYWx0aW1lU2lnbmFscyA9IHZvaWQgMDtcbiAgICB2YXIgZ2V0UmVhbHRpbWVTaWduYWxzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFNJR1JUTUFYIC0gU0lHUlRNSU4gKyAxO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgZ2V0UmVhbHRpbWVTaWduYWwpO1xuICAgIH0sIFwiZ2V0UmVhbHRpbWVTaWduYWxzXCIpO1xuICAgIGV4cG9ydHMuZ2V0UmVhbHRpbWVTaWduYWxzID0gZ2V0UmVhbHRpbWVTaWduYWxzO1xuICAgIHZhciBnZXRSZWFsdGltZVNpZ25hbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBgU0lHUlQke2luZGV4ICsgMX1gLFxuICAgICAgICBudW1iZXI6IFNJR1JUTUlOICsgaW5kZXgsXG4gICAgICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQXBwbGljYXRpb24tc3BlY2lmaWMgc2lnbmFsIChyZWFsdGltZSlcIixcbiAgICAgICAgc3RhbmRhcmQ6IFwicG9zaXhcIlxuICAgICAgfTtcbiAgICB9LCBcImdldFJlYWx0aW1lU2lnbmFsXCIpO1xuICAgIHZhciBTSUdSVE1JTiA9IDM0O1xuICAgIHZhciBTSUdSVE1BWCA9IDY0O1xuICAgIGV4cG9ydHMuU0lHUlRNQVggPSBTSUdSVE1BWDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9zaWduYWxzLmpzXG52YXIgcmVxdWlyZV9zaWduYWxzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h1bWFuLXNpZ25hbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2h1bWFuLXNpZ25hbHMvYnVpbGQvc3JjL3NpZ25hbHMuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuZ2V0U2lnbmFscyA9IHZvaWQgMDtcbiAgICB2YXIgX29zID0gcmVxdWlyZShcIm9zXCIpO1xuICAgIHZhciBfY29yZSA9IHJlcXVpcmVfY29yZSgpO1xuICAgIHZhciBfcmVhbHRpbWUgPSByZXF1aXJlX3JlYWx0aW1lKCk7XG4gICAgdmFyIGdldFNpZ25hbHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgcmVhbHRpbWVTaWduYWxzID0gKDAsIF9yZWFsdGltZS5nZXRSZWFsdGltZVNpZ25hbHMpKCk7XG4gICAgICBjb25zdCBzaWduYWxzID0gWy4uLl9jb3JlLlNJR05BTFMsIC4uLnJlYWx0aW1lU2lnbmFsc10ubWFwKG5vcm1hbGl6ZVNpZ25hbCk7XG4gICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9LCBcImdldFNpZ25hbHNcIik7XG4gICAgZXhwb3J0cy5nZXRTaWduYWxzID0gZ2V0U2lnbmFscztcbiAgICB2YXIgbm9ybWFsaXplU2lnbmFsID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih7XG4gICAgICBuYW1lLFxuICAgICAgbnVtYmVyOiBkZWZhdWx0TnVtYmVyLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBhY3Rpb24sXG4gICAgICBmb3JjZWQgPSBmYWxzZSxcbiAgICAgIHN0YW5kYXJkXG4gICAgfSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxzOiB7IFtuYW1lXTogY29uc3RhbnRTaWduYWwgfVxuICAgICAgfSA9IF9vcy5jb25zdGFudHM7XG4gICAgICBjb25zdCBzdXBwb3J0ZWQgPSBjb25zdGFudFNpZ25hbCAhPT0gdm9pZCAwO1xuICAgICAgY29uc3QgbnVtYmVyID0gc3VwcG9ydGVkID8gY29uc3RhbnRTaWduYWwgOiBkZWZhdWx0TnVtYmVyO1xuICAgICAgcmV0dXJuIHsgbmFtZSwgbnVtYmVyLCBkZXNjcmlwdGlvbiwgc3VwcG9ydGVkLCBhY3Rpb24sIGZvcmNlZCwgc3RhbmRhcmQgfTtcbiAgICB9LCBcIm5vcm1hbGl6ZVNpZ25hbFwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odW1hbi1zaWduYWxzQDIuMS4wL25vZGVfbW9kdWxlcy9odW1hbi1zaWduYWxzL2J1aWxkL3NyYy9tYWluLmpzXG52YXIgcmVxdWlyZV9tYWluID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h1bWFuLXNpZ25hbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2h1bWFuLXNpZ25hbHMvYnVpbGQvc3JjL21haW4uanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuc2lnbmFsc0J5TnVtYmVyID0gZXhwb3J0cy5zaWduYWxzQnlOYW1lID0gdm9pZCAwO1xuICAgIHZhciBfb3MgPSByZXF1aXJlKFwib3NcIik7XG4gICAgdmFyIF9zaWduYWxzID0gcmVxdWlyZV9zaWduYWxzKCk7XG4gICAgdmFyIF9yZWFsdGltZSA9IHJlcXVpcmVfcmVhbHRpbWUoKTtcbiAgICB2YXIgZ2V0U2lnbmFsc0J5TmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBzaWduYWxzID0gKDAsIF9zaWduYWxzLmdldFNpZ25hbHMpKCk7XG4gICAgICByZXR1cm4gc2lnbmFscy5yZWR1Y2UoZ2V0U2lnbmFsQnlOYW1lLCB7fSk7XG4gICAgfSwgXCJnZXRTaWduYWxzQnlOYW1lXCIpO1xuICAgIHZhciBnZXRTaWduYWxCeU5hbWUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHNpZ25hbEJ5TmFtZU1lbW8sIHsgbmFtZSwgbnVtYmVyLCBkZXNjcmlwdGlvbiwgc3VwcG9ydGVkLCBhY3Rpb24sIGZvcmNlZCwgc3RhbmRhcmQgfSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc2lnbmFsQnlOYW1lTWVtbyxcbiAgICAgICAgW25hbWVdOiB7IG5hbWUsIG51bWJlciwgZGVzY3JpcHRpb24sIHN1cHBvcnRlZCwgYWN0aW9uLCBmb3JjZWQsIHN0YW5kYXJkIH1cbiAgICAgIH07XG4gICAgfSwgXCJnZXRTaWduYWxCeU5hbWVcIik7XG4gICAgdmFyIHNpZ25hbHNCeU5hbWUgPSBnZXRTaWduYWxzQnlOYW1lKCk7XG4gICAgZXhwb3J0cy5zaWduYWxzQnlOYW1lID0gc2lnbmFsc0J5TmFtZTtcbiAgICB2YXIgZ2V0U2lnbmFsc0J5TnVtYmVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHNpZ25hbHMgPSAoMCwgX3NpZ25hbHMuZ2V0U2lnbmFscykoKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IF9yZWFsdGltZS5TSUdSVE1BWCArIDE7XG4gICAgICBjb25zdCBzaWduYWxzQSA9IEFycmF5LmZyb20oeyBsZW5ndGggfSwgKHZhbHVlLCBudW1iZXIpID0+IGdldFNpZ25hbEJ5TnVtYmVyKG51bWJlciwgc2lnbmFscykpO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIC4uLnNpZ25hbHNBKTtcbiAgICB9LCBcImdldFNpZ25hbHNCeU51bWJlclwiKTtcbiAgICB2YXIgZ2V0U2lnbmFsQnlOdW1iZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG51bWJlciwgc2lnbmFscykge1xuICAgICAgY29uc3Qgc2lnbmFsID0gZmluZFNpZ25hbEJ5TnVtYmVyKG51bWJlciwgc2lnbmFscyk7XG4gICAgICBpZiAoc2lnbmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiwgc3VwcG9ydGVkLCBhY3Rpb24sIGZvcmNlZCwgc3RhbmRhcmQgfSA9IHNpZ25hbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtudW1iZXJdOiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBudW1iZXIsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgc3VwcG9ydGVkLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBmb3JjZWQsXG4gICAgICAgICAgc3RhbmRhcmRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBcImdldFNpZ25hbEJ5TnVtYmVyXCIpO1xuICAgIHZhciBmaW5kU2lnbmFsQnlOdW1iZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG51bWJlciwgc2lnbmFscykge1xuICAgICAgY29uc3Qgc2lnbmFsID0gc2lnbmFscy5maW5kKCh7IG5hbWUgfSkgPT4gX29zLmNvbnN0YW50cy5zaWduYWxzW25hbWVdID09PSBudW1iZXIpO1xuICAgICAgaWYgKHNpZ25hbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzaWduYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmFscy5maW5kKChzaWduYWxBKSA9PiBzaWduYWxBLm51bWJlciA9PT0gbnVtYmVyKTtcbiAgICB9LCBcImZpbmRTaWduYWxCeU51bWJlclwiKTtcbiAgICB2YXIgc2lnbmFsc0J5TnVtYmVyID0gZ2V0U2lnbmFsc0J5TnVtYmVyKCk7XG4gICAgZXhwb3J0cy5zaWduYWxzQnlOdW1iZXIgPSBzaWduYWxzQnlOdW1iZXI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9lcnJvci5qc1xudmFyIHJlcXVpcmVfZXJyb3IgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9lcnJvci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBzaWduYWxzQnlOYW1lIH0gPSByZXF1aXJlX21haW4oKTtcbiAgICB2YXIgZ2V0RXJyb3JQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IHRpbWVkT3V0LCB0aW1lb3V0LCBlcnJvckNvZGUsIHNpZ25hbCwgc2lnbmFsRGVzY3JpcHRpb24sIGV4aXRDb2RlLCBpc0NhbmNlbGVkIH0pID0+IHtcbiAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICByZXR1cm4gYHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9IG1pbGxpc2Vjb25kc2A7XG4gICAgICB9XG4gICAgICBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgICByZXR1cm4gXCJ3YXMgY2FuY2VsZWRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvckNvZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gYGZhaWxlZCB3aXRoICR7ZXJyb3JDb2RlfWA7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGB3YXMga2lsbGVkIHdpdGggJHtzaWduYWx9ICgke3NpZ25hbERlc2NyaXB0aW9ufSlgO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXRDb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGBmYWlsZWQgd2l0aCBleGl0IGNvZGUgJHtleGl0Q29kZX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiZmFpbGVkXCI7XG4gICAgfSwgXCJnZXRFcnJvclByZWZpeFwiKTtcbiAgICB2YXIgbWFrZUVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoe1xuICAgICAgc3Rkb3V0LFxuICAgICAgc3RkZXJyLFxuICAgICAgYWxsLFxuICAgICAgZXJyb3I6IGVycm9yMixcbiAgICAgIHNpZ25hbCxcbiAgICAgIGV4aXRDb2RlLFxuICAgICAgY29tbWFuZCxcbiAgICAgIGVzY2FwZWRDb21tYW5kLFxuICAgICAgdGltZWRPdXQsXG4gICAgICBpc0NhbmNlbGVkLFxuICAgICAga2lsbGVkLFxuICAgICAgcGFyc2VkOiB7IG9wdGlvbnM6IHsgdGltZW91dCB9IH1cbiAgICB9KSA9PiB7XG4gICAgICBleGl0Q29kZSA9IGV4aXRDb2RlID09PSBudWxsID8gdm9pZCAwIDogZXhpdENvZGU7XG4gICAgICBzaWduYWwgPSBzaWduYWwgPT09IG51bGwgPyB2b2lkIDAgOiBzaWduYWw7XG4gICAgICBjb25zdCBzaWduYWxEZXNjcmlwdGlvbiA9IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsc0J5TmFtZVtzaWduYWxdLmRlc2NyaXB0aW9uO1xuICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IyICYmIGVycm9yMi5jb2RlO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0RXJyb3JQcmVmaXgoeyB0aW1lZE91dCwgdGltZW91dCwgZXJyb3JDb2RlLCBzaWduYWwsIHNpZ25hbERlc2NyaXB0aW9uLCBleGl0Q29kZSwgaXNDYW5jZWxlZCB9KTtcbiAgICAgIGNvbnN0IGV4ZWNhTWVzc2FnZSA9IGBDb21tYW5kICR7cHJlZml4fTogJHtjb21tYW5kfWA7XG4gICAgICBjb25zdCBpc0Vycm9yMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnJvcjIpID09PSBcIltvYmplY3QgRXJyb3JdXCI7XG4gICAgICBjb25zdCBzaG9ydE1lc3NhZ2UgPSBpc0Vycm9yMiA/IGAke2V4ZWNhTWVzc2FnZX1cbiR7ZXJyb3IyLm1lc3NhZ2V9YCA6IGV4ZWNhTWVzc2FnZTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbc2hvcnRNZXNzYWdlLCBzdGRlcnIsIHN0ZG91dF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgICBpZiAoaXNFcnJvcjIpIHtcbiAgICAgICAgZXJyb3IyLm9yaWdpbmFsTWVzc2FnZSA9IGVycm9yMi5tZXNzYWdlO1xuICAgICAgICBlcnJvcjIubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcjIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBlcnJvcjIuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgICAgZXJyb3IyLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgZXJyb3IyLmVzY2FwZWRDb21tYW5kID0gZXNjYXBlZENvbW1hbmQ7XG4gICAgICBlcnJvcjIuZXhpdENvZGUgPSBleGl0Q29kZTtcbiAgICAgIGVycm9yMi5zaWduYWwgPSBzaWduYWw7XG4gICAgICBlcnJvcjIuc2lnbmFsRGVzY3JpcHRpb24gPSBzaWduYWxEZXNjcmlwdGlvbjtcbiAgICAgIGVycm9yMi5zdGRvdXQgPSBzdGRvdXQ7XG4gICAgICBlcnJvcjIuc3RkZXJyID0gc3RkZXJyO1xuICAgICAgaWYgKGFsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGVycm9yMi5hbGwgPSBhbGw7XG4gICAgICB9XG4gICAgICBpZiAoXCJidWZmZXJlZERhdGFcIiBpbiBlcnJvcjIpIHtcbiAgICAgICAgZGVsZXRlIGVycm9yMi5idWZmZXJlZERhdGE7XG4gICAgICB9XG4gICAgICBlcnJvcjIuZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yMi50aW1lZE91dCA9IEJvb2xlYW4odGltZWRPdXQpO1xuICAgICAgZXJyb3IyLmlzQ2FuY2VsZWQgPSBpc0NhbmNlbGVkO1xuICAgICAgZXJyb3IyLmtpbGxlZCA9IGtpbGxlZCAmJiAhdGltZWRPdXQ7XG4gICAgICByZXR1cm4gZXJyb3IyO1xuICAgIH0sIFwibWFrZUVycm9yXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG1ha2VFcnJvcjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3N0ZGlvLmpzXG52YXIgcmVxdWlyZV9zdGRpbyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3N0ZGlvLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhbGlhc2VzID0gW1wic3RkaW5cIiwgXCJzdGRvdXRcIiwgXCJzdGRlcnJcIl07XG4gICAgdmFyIGhhc0FsaWFzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucykgPT4gYWxpYXNlcy5zb21lKChhbGlhcykgPT4gb3B0aW9uc1thbGlhc10gIT09IHZvaWQgMCksIFwiaGFzQWxpYXNcIik7XG4gICAgdmFyIG5vcm1hbGl6ZVN0ZGlvID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc3RkaW8gfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoc3RkaW8gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gYWxpYXNlcy5tYXAoKGFsaWFzKSA9PiBvcHRpb25zW2FsaWFzXSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzQWxpYXMob3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJdCdzIG5vdCBwb3NzaWJsZSB0byBwcm92aWRlIFxcYHN0ZGlvXFxgIGluIGNvbWJpbmF0aW9uIHdpdGggb25lIG9mICR7YWxpYXNlcy5tYXAoKGFsaWFzKSA9PiBgXFxgJHthbGlhc31cXGBgKS5qb2luKFwiLCBcIil9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHN0ZGlvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzdGRpbztcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGRpbykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RkaW9cXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgQXJyYXlcXGAsIGdvdCBcXGAke3R5cGVvZiBzdGRpb31cXGBgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KHN0ZGlvLmxlbmd0aCwgYWxpYXNlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKHZhbHVlLCBpbmRleCkgPT4gc3RkaW9baW5kZXhdKTtcbiAgICB9LCBcIm5vcm1hbGl6ZVN0ZGlvXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG5vcm1hbGl6ZVN0ZGlvO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5ub2RlID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0aW9ucyk7XG4gICAgICBpZiAoc3RkaW8gPT09IFwiaXBjXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaXBjXCI7XG4gICAgICB9XG4gICAgICBpZiAoc3RkaW8gPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RkaW8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtzdGRpbywgc3RkaW8sIHN0ZGlvLCBcImlwY1wiXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGRpby5pbmNsdWRlcyhcImlwY1wiKSkge1xuICAgICAgICByZXR1cm4gc3RkaW87XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLnN0ZGlvLCBcImlwY1wiXTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NpZ25hbC1leGl0QDMuMC43L25vZGVfbW9kdWxlcy9zaWduYWwtZXhpdC9zaWduYWxzLmpzXG52YXIgcmVxdWlyZV9zaWduYWxzMiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaWduYWwtZXhpdEAzLjAuNy9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvc2lnbmFscy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBbXG4gICAgICBcIlNJR0FCUlRcIixcbiAgICAgIFwiU0lHQUxSTVwiLFxuICAgICAgXCJTSUdIVVBcIixcbiAgICAgIFwiU0lHSU5UXCIsXG4gICAgICBcIlNJR1RFUk1cIlxuICAgIF07XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09IFwid2luMzJcIikge1xuICAgICAgbW9kdWxlMi5leHBvcnRzLnB1c2goXG4gICAgICAgIFwiU0lHVlRBTFJNXCIsXG4gICAgICAgIFwiU0lHWENQVVwiLFxuICAgICAgICBcIlNJR1hGU1pcIixcbiAgICAgICAgXCJTSUdVU1IyXCIsXG4gICAgICAgIFwiU0lHVFJBUFwiLFxuICAgICAgICBcIlNJR1NZU1wiLFxuICAgICAgICBcIlNJR1FVSVRcIixcbiAgICAgICAgXCJTSUdJT1RcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIikge1xuICAgICAgbW9kdWxlMi5leHBvcnRzLnB1c2goXG4gICAgICAgIFwiU0lHSU9cIixcbiAgICAgICAgXCJTSUdQT0xMXCIsXG4gICAgICAgIFwiU0lHUFdSXCIsXG4gICAgICAgIFwiU0lHU1RLRkxUXCIsXG4gICAgICAgIFwiU0lHVU5VU0VEXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NpZ25hbC1leGl0QDMuMC43L25vZGVfbW9kdWxlcy9zaWduYWwtZXhpdC9pbmRleC5qc1xudmFyIHJlcXVpcmVfc2lnbmFsX2V4aXQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2lnbmFsLWV4aXRAMy4wLjcvbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBwcm9jZXNzMiA9IGdsb2JhbC5wcm9jZXNzO1xuICAgIHZhciBwcm9jZXNzT2sgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHByb2Nlc3MzKSB7XG4gICAgICByZXR1cm4gcHJvY2VzczMgJiYgdHlwZW9mIHByb2Nlc3MzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzMy5yZW1vdmVMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9jZXNzMy5lbWl0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb2Nlc3MzLnJlYWxseUV4aXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvY2VzczMubGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb2Nlc3MzLmtpbGwgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvY2VzczMucGlkID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9jZXNzMy5vbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0sIFwicHJvY2Vzc09rXCIpO1xuICAgIGlmICghcHJvY2Vzc09rKHByb2Nlc3MyKSkge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgICBzaWduYWxzID0gcmVxdWlyZV9zaWduYWxzMigpO1xuICAgICAgaXNXaW4gPSAvXndpbi9pLnRlc3QocHJvY2VzczIucGxhdGZvcm0pO1xuICAgICAgRUUgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuICAgICAgaWYgKHR5cGVvZiBFRSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEVFID0gRUUuRXZlbnRFbWl0dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MyLl9fc2lnbmFsX2V4aXRfZW1pdHRlcl9fKSB7XG4gICAgICAgIGVtaXR0ZXIgPSBwcm9jZXNzMi5fX3NpZ25hbF9leGl0X2VtaXR0ZXJfXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXR0ZXIgPSBwcm9jZXNzMi5fX3NpZ25hbF9leGl0X2VtaXR0ZXJfXyA9IG5ldyBFRSgpO1xuICAgICAgICBlbWl0dGVyLmNvdW50ID0gMDtcbiAgICAgICAgZW1pdHRlci5lbWl0dGVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoIWVtaXR0ZXIuaW5maW5pdGUpIHtcbiAgICAgICAgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgICAgICBlbWl0dGVyLmluZmluaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiLCBvcHRzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc09rKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsIFwiZnVuY3Rpb25cIiwgXCJhIGNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQgZm9yIGV4aXQgaGFuZGxlclwiKTtcbiAgICAgICAgaWYgKGxvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ID0gXCJleGl0XCI7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuYWx3YXlzTGFzdCkge1xuICAgICAgICAgIGV2ID0gXCJhZnRlcmV4aXRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtb3ZlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2LCBjYik7XG4gICAgICAgICAgaWYgKGVtaXR0ZXIubGlzdGVuZXJzKFwiZXhpdFwiKS5sZW5ndGggPT09IDAgJiYgZW1pdHRlci5saXN0ZW5lcnMoXCJhZnRlcmV4aXRcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB1bmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFwicmVtb3ZlXCIpO1xuICAgICAgICBlbWl0dGVyLm9uKGV2LCBjYik7XG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgICB9O1xuICAgICAgdW5sb2FkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiB1bmxvYWQyKCkge1xuICAgICAgICBpZiAoIWxvYWRlZCB8fCAhcHJvY2Vzc09rKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9jZXNzMi5yZW1vdmVMaXN0ZW5lcihzaWcsIHNpZ0xpc3RlbmVyc1tzaWddKTtcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3MyLmVtaXQgPSBvcmlnaW5hbFByb2Nlc3NFbWl0O1xuICAgICAgICBwcm9jZXNzMi5yZWFsbHlFeGl0ID0gb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdDtcbiAgICAgICAgZW1pdHRlci5jb3VudCAtPSAxO1xuICAgICAgfSwgXCJ1bmxvYWRcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMudW5sb2FkID0gdW5sb2FkO1xuICAgICAgZW1pdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gZW1pdDIoZXZlbnQsIGNvZGUsIHNpZ25hbCkge1xuICAgICAgICBpZiAoZW1pdHRlci5lbWl0dGVkW2V2ZW50XSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLmVtaXR0ZWRbZXZlbnRdID0gdHJ1ZTtcbiAgICAgICAgZW1pdHRlci5lbWl0KGV2ZW50LCBjb2RlLCBzaWduYWwpO1xuICAgICAgfSwgXCJlbWl0XCIpO1xuICAgICAgc2lnTGlzdGVuZXJzID0ge307XG4gICAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIHNpZ0xpc3RlbmVyc1tzaWddID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgICBpZiAoIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHByb2Nlc3MyLmxpc3RlbmVycyhzaWcpO1xuICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSBlbWl0dGVyLmNvdW50KSB7XG4gICAgICAgICAgICB1bmxvYWQoKTtcbiAgICAgICAgICAgIGVtaXQoXCJleGl0XCIsIG51bGwsIHNpZyk7XG4gICAgICAgICAgICBlbWl0KFwiYWZ0ZXJleGl0XCIsIG51bGwsIHNpZyk7XG4gICAgICAgICAgICBpZiAoaXNXaW4gJiYgc2lnID09PSBcIlNJR0hVUFwiKSB7XG4gICAgICAgICAgICAgIHNpZyA9IFwiU0lHSU5UXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzMi5raWxsKHByb2Nlc3MyLnBpZCwgc2lnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFwibGlzdGVuZXJcIik7XG4gICAgICB9KTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5zaWduYWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgICAgfTtcbiAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgbG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gbG9hZDIoKSB7XG4gICAgICAgIGlmIChsb2FkZWQgfHwgIXByb2Nlc3NPayhnbG9iYWwucHJvY2VzcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgZW1pdHRlci5jb3VudCArPSAxO1xuICAgICAgICBzaWduYWxzID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2Nlc3MyLm9uKHNpZywgc2lnTGlzdGVuZXJzW3NpZ10pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzMi5lbWl0ID0gcHJvY2Vzc0VtaXQ7XG4gICAgICAgIHByb2Nlc3MyLnJlYWxseUV4aXQgPSBwcm9jZXNzUmVhbGx5RXhpdDtcbiAgICAgIH0sIFwibG9hZFwiKTtcbiAgICAgIG1vZHVsZTIuZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICAgIG9yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQgPSBwcm9jZXNzMi5yZWFsbHlFeGl0O1xuICAgICAgcHJvY2Vzc1JlYWxseUV4aXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIHByb2Nlc3NSZWFsbHlFeGl0Mihjb2RlKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc09rKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzMi5leGl0Q29kZSA9IGNvZGUgfHwgMDtcbiAgICAgICAgZW1pdChcImV4aXRcIiwgcHJvY2VzczIuZXhpdENvZGUsIG51bGwpO1xuICAgICAgICBlbWl0KFwiYWZ0ZXJleGl0XCIsIHByb2Nlc3MyLmV4aXRDb2RlLCBudWxsKTtcbiAgICAgICAgb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdC5jYWxsKHByb2Nlc3MyLCBwcm9jZXNzMi5leGl0Q29kZSk7XG4gICAgICB9LCBcInByb2Nlc3NSZWFsbHlFeGl0XCIpO1xuICAgICAgb3JpZ2luYWxQcm9jZXNzRW1pdCA9IHByb2Nlc3MyLmVtaXQ7XG4gICAgICBwcm9jZXNzRW1pdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gcHJvY2Vzc0VtaXQyKGV2LCBhcmcyKSB7XG4gICAgICAgIGlmIChldiA9PT0gXCJleGl0XCIgJiYgcHJvY2Vzc09rKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgICAgICAgIGlmIChhcmcyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHByb2Nlc3MyLmV4aXRDb2RlID0gYXJnMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJldCA9IG9yaWdpbmFsUHJvY2Vzc0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBlbWl0KFwiZXhpdFwiLCBwcm9jZXNzMi5leGl0Q29kZSwgbnVsbCk7XG4gICAgICAgICAgZW1pdChcImFmdGVyZXhpdFwiLCBwcm9jZXNzMi5leGl0Q29kZSwgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9jZXNzRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9LCBcInByb2Nlc3NFbWl0XCIpO1xuICAgIH1cbiAgICB2YXIgYXNzZXJ0O1xuICAgIHZhciBzaWduYWxzO1xuICAgIHZhciBpc1dpbjtcbiAgICB2YXIgRUU7XG4gICAgdmFyIGVtaXR0ZXI7XG4gICAgdmFyIHVubG9hZDtcbiAgICB2YXIgZW1pdDtcbiAgICB2YXIgc2lnTGlzdGVuZXJzO1xuICAgIHZhciBsb2FkZWQ7XG4gICAgdmFyIGxvYWQ7XG4gICAgdmFyIG9yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQ7XG4gICAgdmFyIHByb2Nlc3NSZWFsbHlFeGl0O1xuICAgIHZhciBvcmlnaW5hbFByb2Nlc3NFbWl0O1xuICAgIHZhciBwcm9jZXNzRW1pdDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL2tpbGwuanNcbnZhciByZXF1aXJlX2tpbGwgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9raWxsLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBvczMgPSByZXF1aXJlKFwib3NcIik7XG4gICAgdmFyIG9uRXhpdCA9IHJlcXVpcmVfc2lnbmFsX2V4aXQoKTtcbiAgICB2YXIgREVGQVVMVF9GT1JDRV9LSUxMX1RJTUVPVVQgPSAxZTMgKiA1O1xuICAgIHZhciBzcGF3bmVkS2lsbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGtpbGwsIHNpZ25hbCA9IFwiU0lHVEVSTVwiLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGtpbGxSZXN1bHQgPSBraWxsKHNpZ25hbCk7XG4gICAgICBzZXRLaWxsVGltZW91dChraWxsLCBzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpO1xuICAgICAgcmV0dXJuIGtpbGxSZXN1bHQ7XG4gICAgfSwgXCJzcGF3bmVkS2lsbFwiKTtcbiAgICB2YXIgc2V0S2lsbFRpbWVvdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChraWxsLCBzaWduYWwsIG9wdGlvbnMsIGtpbGxSZXN1bHQpID0+IHtcbiAgICAgIGlmICghc2hvdWxkRm9yY2VLaWxsKHNpZ25hbCwgb3B0aW9ucywga2lsbFJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZW91dCA9IGdldEZvcmNlS2lsbEFmdGVyVGltZW91dChvcHRpb25zKTtcbiAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAga2lsbChcIlNJR0tJTExcIik7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgIHQudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9LCBcInNldEtpbGxUaW1lb3V0XCIpO1xuICAgIHZhciBzaG91bGRGb3JjZUtpbGwgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzaWduYWwsIHsgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0IH0sIGtpbGxSZXN1bHQpID0+IHtcbiAgICAgIHJldHVybiBpc1NpZ3Rlcm0oc2lnbmFsKSAmJiBmb3JjZUtpbGxBZnRlclRpbWVvdXQgIT09IGZhbHNlICYmIGtpbGxSZXN1bHQ7XG4gICAgfSwgXCJzaG91bGRGb3JjZUtpbGxcIik7XG4gICAgdmFyIGlzU2lndGVybSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNpZ25hbCkgPT4ge1xuICAgICAgcmV0dXJuIHNpZ25hbCA9PT0gb3MzLmNvbnN0YW50cy5zaWduYWxzLlNJR1RFUk0gfHwgdHlwZW9mIHNpZ25hbCA9PT0gXCJzdHJpbmdcIiAmJiBzaWduYWwudG9VcHBlckNhc2UoKSA9PT0gXCJTSUdURVJNXCI7XG4gICAgfSwgXCJpc1NpZ3Rlcm1cIik7XG4gICAgdmFyIGdldEZvcmNlS2lsbEFmdGVyVGltZW91dCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHsgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0ID0gdHJ1ZSB9KSA9PiB7XG4gICAgICBpZiAoZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0ZPUkNFX0tJTExfVElNRU9VVDtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZvcmNlS2lsbEFmdGVyVGltZW91dCkgfHwgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgXFxgZm9yY2VLaWxsQWZ0ZXJUaW1lb3V0XFxgIG9wdGlvbiB0byBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3QgXFxgJHtmb3JjZUtpbGxBZnRlclRpbWVvdXR9XFxgICgke3R5cGVvZiBmb3JjZUtpbGxBZnRlclRpbWVvdXR9KWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlS2lsbEFmdGVyVGltZW91dDtcbiAgICB9LCBcImdldEZvcmNlS2lsbEFmdGVyVGltZW91dFwiKTtcbiAgICB2YXIgc3Bhd25lZENhbmNlbCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNwYXduZWQsIGNvbnRleHQzKSA9PiB7XG4gICAgICBjb25zdCBraWxsUmVzdWx0ID0gc3Bhd25lZC5raWxsKCk7XG4gICAgICBpZiAoa2lsbFJlc3VsdCkge1xuICAgICAgICBjb250ZXh0My5pc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCBcInNwYXduZWRDYW5jZWxcIik7XG4gICAgdmFyIHRpbWVvdXRLaWxsID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3Bhd25lZCwgc2lnbmFsLCByZWplY3QpID0+IHtcbiAgICAgIHNwYXduZWQua2lsbChzaWduYWwpO1xuICAgICAgcmVqZWN0KE9iamVjdC5hc3NpZ24obmV3IEVycm9yKFwiVGltZWQgb3V0XCIpLCB7IHRpbWVkT3V0OiB0cnVlLCBzaWduYWwgfSkpO1xuICAgIH0sIFwidGltZW91dEtpbGxcIik7XG4gICAgdmFyIHNldHVwVGltZW91dCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNwYXduZWQsIHsgdGltZW91dCwga2lsbFNpZ25hbCA9IFwiU0lHVEVSTVwiIH0sIHNwYXduZWRQcm9taXNlKSA9PiB7XG4gICAgICBpZiAodGltZW91dCA9PT0gMCB8fCB0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNwYXduZWRQcm9taXNlO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0S2lsbChzcGF3bmVkLCBraWxsU2lnbmFsLCByZWplY3QpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2FmZVNwYXduZWRQcm9taXNlID0gc3Bhd25lZFByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc2FmZVNwYXduZWRQcm9taXNlXSk7XG4gICAgfSwgXCJzZXR1cFRpbWVvdXRcIik7XG4gICAgdmFyIHZhbGlkYXRlVGltZW91dCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHsgdGltZW91dCB9KSA9PiB7XG4gICAgICBpZiAodGltZW91dCAhPT0gdm9pZCAwICYmICghTnVtYmVyLmlzRmluaXRlKHRpbWVvdXQpIHx8IHRpbWVvdXQgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgXFxgdGltZW91dFxcYCBvcHRpb24gdG8gYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290IFxcYCR7dGltZW91dH1cXGAgKCR7dHlwZW9mIHRpbWVvdXR9KWApO1xuICAgICAgfVxuICAgIH0sIFwidmFsaWRhdGVUaW1lb3V0XCIpO1xuICAgIHZhciBzZXRFeGl0SGFuZGxlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKHNwYXduZWQsIHsgY2xlYW51cCwgZGV0YWNoZWQgfSwgdGltZWRQcm9taXNlKSA9PiB7XG4gICAgICBpZiAoIWNsZWFudXAgfHwgZGV0YWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVkUHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbW92ZUV4aXRIYW5kbGVyID0gb25FeGl0KCgpID0+IHtcbiAgICAgICAgc3Bhd25lZC5raWxsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aW1lZFByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZUV4aXRIYW5kbGVyKCk7XG4gICAgICB9KTtcbiAgICB9LCBcInNldEV4aXRIYW5kbGVyXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHNwYXduZWRLaWxsLFxuICAgICAgc3Bhd25lZENhbmNlbCxcbiAgICAgIHNldHVwVGltZW91dCxcbiAgICAgIHZhbGlkYXRlVGltZW91dCxcbiAgICAgIHNldEV4aXRIYW5kbGVyXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1zdHJlYW1AMi4wLjEvbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfc3RyZWFtID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLXN0cmVhbUAyLjAuMS9ub2RlX21vZHVsZXMvaXMtc3RyZWFtL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBpc1N0cmVhbSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0cmVhbTIpID0+IHN0cmVhbTIgIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbTIgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHN0cmVhbTIucGlwZSA9PT0gXCJmdW5jdGlvblwiLCBcImlzU3RyZWFtXCIpO1xuICAgIGlzU3RyZWFtLndyaXRhYmxlID0gKHN0cmVhbTIpID0+IGlzU3RyZWFtKHN0cmVhbTIpICYmIHN0cmVhbTIud3JpdGFibGUgIT09IGZhbHNlICYmIHR5cGVvZiBzdHJlYW0yLl93cml0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzdHJlYW0yLl93cml0YWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xuICAgIGlzU3RyZWFtLnJlYWRhYmxlID0gKHN0cmVhbTIpID0+IGlzU3RyZWFtKHN0cmVhbTIpICYmIHN0cmVhbTIucmVhZGFibGUgIT09IGZhbHNlICYmIHR5cGVvZiBzdHJlYW0yLl9yZWFkID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHN0cmVhbTIuX3JlYWRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG4gICAgaXNTdHJlYW0uZHVwbGV4ID0gKHN0cmVhbTIpID0+IGlzU3RyZWFtLndyaXRhYmxlKHN0cmVhbTIpICYmIGlzU3RyZWFtLnJlYWRhYmxlKHN0cmVhbTIpO1xuICAgIGlzU3RyZWFtLnRyYW5zZm9ybSA9IChzdHJlYW0yKSA9PiBpc1N0cmVhbS5kdXBsZXgoc3RyZWFtMikgJiYgdHlwZW9mIHN0cmVhbTIuX3RyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGlzU3RyZWFtO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1zdHJlYW1ANi4wLjEvbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vYnVmZmVyLXN0cmVhbS5qc1xudmFyIHJlcXVpcmVfYnVmZmVyX3N0cmVhbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9nZXQtc3RyZWFtQDYuMC4xL25vZGVfbW9kdWxlcy9nZXQtc3RyZWFtL2J1ZmZlci1zdHJlYW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgUGFzc1Rocm91Z2g6IFBhc3NUaHJvdWdoU3RyZWFtIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICBjb25zdCB7IGFycmF5IH0gPSBvcHRpb25zO1xuICAgICAgbGV0IHsgZW5jb2RpbmcgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBpc0J1ZmZlciA9IGVuY29kaW5nID09PSBcImJ1ZmZlclwiO1xuICAgICAgbGV0IG9iamVjdE1vZGUgPSBmYWxzZTtcbiAgICAgIGlmIChhcnJheSkge1xuICAgICAgICBvYmplY3RNb2RlID0gIShlbmNvZGluZyB8fCBpc0J1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IFwidXRmOFwiO1xuICAgICAgfVxuICAgICAgaWYgKGlzQnVmZmVyKSB7XG4gICAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbTIgPSBuZXcgUGFzc1Rocm91Z2hTdHJlYW0oeyBvYmplY3RNb2RlIH0pO1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIHN0cmVhbTIuc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIHN0cmVhbTIub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIGlmIChvYmplY3RNb2RlKSB7XG4gICAgICAgICAgbGVuZ3RoID0gY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbTIuZ2V0QnVmZmVyZWRWYWx1ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNCdWZmZXIgPyBCdWZmZXIuY29uY2F0KGNodW5rcywgbGVuZ3RoKSA6IGNodW5rcy5qb2luKFwiXCIpO1xuICAgICAgfTtcbiAgICAgIHN0cmVhbTIuZ2V0QnVmZmVyZWRMZW5ndGggPSAoKSA9PiBsZW5ndGg7XG4gICAgICByZXR1cm4gc3RyZWFtMjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1zdHJlYW1ANi4wLjEvbm9kZV9tb2R1bGVzL2dldC1zdHJlYW0vaW5kZXguanNcbnZhciByZXF1aXJlX2dldF9zdHJlYW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZ2V0LXN0cmVhbUA2LjAuMS9ub2RlX21vZHVsZXMvZ2V0LXN0cmVhbS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBjb25zdGFudHM6IEJ1ZmZlckNvbnN0YW50cyB9ID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbiAgICB2YXIgc3RyZWFtMiA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgdmFyIHsgcHJvbWlzaWZ5OiBwcm9taXNpZnk0IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICB2YXIgYnVmZmVyU3RyZWFtID0gcmVxdWlyZV9idWZmZXJfc3RyZWFtKCk7XG4gICAgdmFyIHN0cmVhbVBpcGVsaW5lUHJvbWlzaWZpZWQgPSBwcm9taXNpZnk0KHN0cmVhbTIucGlwZWxpbmUpO1xuICAgIHZhciBNYXhCdWZmZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwibWF4QnVmZmVyIGV4Y2VlZGVkXCIpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk1heEJ1ZmZlckVycm9yXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoTWF4QnVmZmVyRXJyb3IsIFwiTWF4QnVmZmVyRXJyb3JcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RyZWFtMihpbnB1dFN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmVhbVwiKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG1heEJ1ZmZlcjogSW5maW5pdHksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCB7IG1heEJ1ZmZlciB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHN0cmVhbTMgPSBidWZmZXJTdHJlYW0ob3B0aW9ucyk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlamVjdFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlcnJvcjIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IyICYmIHN0cmVhbTMuZ2V0QnVmZmVyZWRMZW5ndGgoKSA8PSBCdWZmZXJDb25zdGFudHMuTUFYX0xFTkdUSCkge1xuICAgICAgICAgICAgZXJyb3IyLmJ1ZmZlcmVkRGF0YSA9IHN0cmVhbTMuZ2V0QnVmZmVyZWRWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgfSwgXCJyZWplY3RQcm9taXNlXCIpO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBzdHJlYW1QaXBlbGluZVByb21pc2lmaWVkKGlucHV0U3RyZWFtLCBzdHJlYW0zKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgIHJlamVjdFByb21pc2UoZXJyb3IyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHN0cmVhbTMub24oXCJkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICBpZiAoc3RyZWFtMy5nZXRCdWZmZXJlZExlbmd0aCgpID4gbWF4QnVmZmVyKSB7XG4gICAgICAgICAgICByZWplY3RQcm9taXNlKG5ldyBNYXhCdWZmZXJFcnJvcigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RyZWFtMy5nZXRCdWZmZXJlZFZhbHVlKCk7XG4gICAgfVxuICAgIF9fbmFtZShnZXRTdHJlYW0yLCBcImdldFN0cmVhbVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBnZXRTdHJlYW0yO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5idWZmZXIgPSAoc3RyZWFtMywgb3B0aW9ucykgPT4gZ2V0U3RyZWFtMihzdHJlYW0zLCB7IC4uLm9wdGlvbnMsIGVuY29kaW5nOiBcImJ1ZmZlclwiIH0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5hcnJheSA9IChzdHJlYW0zLCBvcHRpb25zKSA9PiBnZXRTdHJlYW0yKHN0cmVhbTMsIHsgLi4ub3B0aW9ucywgYXJyYXk6IHRydWUgfSk7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1heEJ1ZmZlckVycm9yID0gTWF4QnVmZmVyRXJyb3I7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWVyZ2Utc3RyZWFtQDIuMC4wL25vZGVfbW9kdWxlcy9tZXJnZS1zdHJlYW0vaW5kZXguanNcbnZhciByZXF1aXJlX21lcmdlX3N0cmVhbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJnZS1zdHJlYW1AMi4wLjAvbm9kZV9tb2R1bGVzL21lcmdlLXN0cmVhbS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICB2YXIgb3V0cHV0ID0gbmV3IFBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgIG91dHB1dC5zZXRNYXhMaXN0ZW5lcnMoMCk7XG4gICAgICBvdXRwdXQuYWRkID0gYWRkMjtcbiAgICAgIG91dHB1dC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICAgIG91dHB1dC5vbihcInVucGlwZVwiLCByZW1vdmUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5mb3JFYWNoKGFkZDIpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIGZ1bmN0aW9uIGFkZDIoc291cmNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICBzb3VyY2UuZm9yRWFjaChhZGQyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgc291cmNlLm9uY2UoXCJlbmRcIiwgcmVtb3ZlLmJpbmQobnVsbCwgc291cmNlKSk7XG4gICAgICAgIHNvdXJjZS5vbmNlKFwiZXJyb3JcIiwgb3V0cHV0LmVtaXQuYmluZChvdXRwdXQsIFwiZXJyb3JcIikpO1xuICAgICAgICBzb3VyY2UucGlwZShvdXRwdXQsIHsgZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBfX25hbWUoYWRkMiwgXCJhZGRcIik7XG4gICAgICBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gc291cmNlcy5sZW5ndGggPT0gMDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShpc0VtcHR5LCBcImlzRW1wdHlcIik7XG4gICAgICBmdW5jdGlvbiByZW1vdmUoc291cmNlKSB7XG4gICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzLmZpbHRlcihmdW5jdGlvbihpdCkge1xuICAgICAgICAgIHJldHVybiBpdCAhPT0gc291cmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzb3VyY2VzLmxlbmd0aCAmJiBvdXRwdXQucmVhZGFibGUpIHtcbiAgICAgICAgICBvdXRwdXQuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShyZW1vdmUsIFwicmVtb3ZlXCIpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9zdHJlYW0uanNcbnZhciByZXF1aXJlX3N0cmVhbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL3N0cmVhbS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTdHJlYW0gPSByZXF1aXJlX2lzX3N0cmVhbSgpO1xuICAgIHZhciBnZXRTdHJlYW0yID0gcmVxdWlyZV9nZXRfc3RyZWFtKCk7XG4gICAgdmFyIG1lcmdlU3RyZWFtID0gcmVxdWlyZV9tZXJnZV9zdHJlYW0oKTtcbiAgICB2YXIgaGFuZGxlSW5wdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzcGF3bmVkLCBpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDAgfHwgc3Bhd25lZC5zdGRpbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmVhbShpbnB1dCkpIHtcbiAgICAgICAgaW5wdXQucGlwZShzcGF3bmVkLnN0ZGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYXduZWQuc3RkaW4uZW5kKGlucHV0KTtcbiAgICAgIH1cbiAgICB9LCBcImhhbmRsZUlucHV0XCIpO1xuICAgIHZhciBtYWtlQWxsU3RyZWFtID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3Bhd25lZCwgeyBhbGwgfSkgPT4ge1xuICAgICAgaWYgKCFhbGwgfHwgIXNwYXduZWQuc3Rkb3V0ICYmICFzcGF3bmVkLnN0ZGVycikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtaXhlZCA9IG1lcmdlU3RyZWFtKCk7XG4gICAgICBpZiAoc3Bhd25lZC5zdGRvdXQpIHtcbiAgICAgICAgbWl4ZWQuYWRkKHNwYXduZWQuc3Rkb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGF3bmVkLnN0ZGVycikge1xuICAgICAgICBtaXhlZC5hZGQoc3Bhd25lZC5zdGRlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1peGVkO1xuICAgIH0sIFwibWFrZUFsbFN0cmVhbVwiKTtcbiAgICB2YXIgZ2V0QnVmZmVyZWREYXRhID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoc3RyZWFtMiwgc3RyZWFtUHJvbWlzZSkgPT4ge1xuICAgICAgaWYgKCFzdHJlYW0yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbTIuZGVzdHJveSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0cmVhbVByb21pc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yMi5idWZmZXJlZERhdGE7XG4gICAgICB9XG4gICAgfSwgXCJnZXRCdWZmZXJlZERhdGFcIik7XG4gICAgdmFyIGdldFN0cmVhbVByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdHJlYW0yLCB7IGVuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlciB9KSA9PiB7XG4gICAgICBpZiAoIXN0cmVhbTIgfHwgIWJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0cmVhbTIoc3RyZWFtMiwgeyBlbmNvZGluZywgbWF4QnVmZmVyIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFN0cmVhbTIuYnVmZmVyKHN0cmVhbTIsIHsgbWF4QnVmZmVyIH0pO1xuICAgIH0sIFwiZ2V0U3RyZWFtUHJvbWlzZVwiKTtcbiAgICB2YXIgZ2V0U3Bhd25lZFJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKHsgc3Rkb3V0LCBzdGRlcnIsIGFsbCB9LCB7IGVuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlciB9LCBwcm9jZXNzRG9uZSkgPT4ge1xuICAgICAgY29uc3Qgc3Rkb3V0UHJvbWlzZSA9IGdldFN0cmVhbVByb21pc2Uoc3Rkb3V0LCB7IGVuY29kaW5nLCBidWZmZXIsIG1heEJ1ZmZlciB9KTtcbiAgICAgIGNvbnN0IHN0ZGVyclByb21pc2UgPSBnZXRTdHJlYW1Qcm9taXNlKHN0ZGVyciwgeyBlbmNvZGluZywgYnVmZmVyLCBtYXhCdWZmZXIgfSk7XG4gICAgICBjb25zdCBhbGxQcm9taXNlID0gZ2V0U3RyZWFtUHJvbWlzZShhbGwsIHsgZW5jb2RpbmcsIGJ1ZmZlciwgbWF4QnVmZmVyOiBtYXhCdWZmZXIgKiAyIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFtwcm9jZXNzRG9uZSwgc3Rkb3V0UHJvbWlzZSwgc3RkZXJyUHJvbWlzZSwgYWxsUHJvbWlzZV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgeyBlcnJvcjogZXJyb3IyLCBzaWduYWw6IGVycm9yMi5zaWduYWwsIHRpbWVkT3V0OiBlcnJvcjIudGltZWRPdXQgfSxcbiAgICAgICAgICBnZXRCdWZmZXJlZERhdGEoc3Rkb3V0LCBzdGRvdXRQcm9taXNlKSxcbiAgICAgICAgICBnZXRCdWZmZXJlZERhdGEoc3RkZXJyLCBzdGRlcnJQcm9taXNlKSxcbiAgICAgICAgICBnZXRCdWZmZXJlZERhdGEoYWxsLCBhbGxQcm9taXNlKVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9LCBcImdldFNwYXduZWRSZXN1bHRcIik7XG4gICAgdmFyIHZhbGlkYXRlSW5wdXRTeW5jID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoeyBpbnB1dCB9KSA9PiB7XG4gICAgICBpZiAoaXNTdHJlYW0oaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgYGlucHV0YCBvcHRpb24gY2Fubm90IGJlIGEgc3RyZWFtIGluIHN5bmMgbW9kZVwiKTtcbiAgICAgIH1cbiAgICB9LCBcInZhbGlkYXRlSW5wdXRTeW5jXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGhhbmRsZUlucHV0LFxuICAgICAgbWFrZUFsbFN0cmVhbSxcbiAgICAgIGdldFNwYXduZWRSZXN1bHQsXG4gICAgICB2YWxpZGF0ZUlucHV0U3luY1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2xpYi9wcm9taXNlLmpzXG52YXIgcmVxdWlyZV9wcm9taXNlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvcHJvbWlzZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IChhc3luYyAoKSA9PiB7XG4gICAgfSkoKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0gW1widGhlblwiLCBcImNhdGNoXCIsIFwiZmluYWxseVwiXS5tYXAoKHByb3BlcnR5KSA9PiBbXG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5hdGl2ZVByb21pc2VQcm90b3R5cGUsIHByb3BlcnR5KVxuICAgIF0pO1xuICAgIHZhciBtZXJnZVByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzcGF3bmVkLCBwcm9taXNlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgZGVzY3JpcHRvcl0gb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgcHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiID8gKC4uLmFyZ3MpID0+IFJlZmxlY3QuYXBwbHkoZGVzY3JpcHRvci52YWx1ZSwgcHJvbWlzZSgpLCBhcmdzKSA6IGRlc2NyaXB0b3IudmFsdWUuYmluZChwcm9taXNlKTtcbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShzcGF3bmVkLCBwcm9wZXJ0eSwgeyAuLi5kZXNjcmlwdG9yLCB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGF3bmVkO1xuICAgIH0sIFwibWVyZ2VQcm9taXNlXCIpO1xuICAgIHZhciBnZXRTcGF3bmVkUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNwYXduZWQpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNwYXduZWQub24oXCJleGl0XCIsIChleGl0Q29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh7IGV4aXRDb2RlLCBzaWduYWwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGF3bmVkLm9uKFwiZXJyb3JcIiwgKGVycm9yMikgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNwYXduZWQuc3RkaW4pIHtcbiAgICAgICAgICBzcGF3bmVkLnN0ZGluLm9uKFwiZXJyb3JcIiwgKGVycm9yMikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIFwiZ2V0U3Bhd25lZFByb21pc2VcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgbWVyZ2VQcm9taXNlLFxuICAgICAgZ2V0U3Bhd25lZFByb21pc2VcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9saWIvY29tbWFuZC5qc1xudmFyIHJlcXVpcmVfY29tbWFuZCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9leGVjYUA1LjEuMS9ub2RlX21vZHVsZXMvZXhlY2EvbGliL2NvbW1hbmQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5vcm1hbGl6ZUFyZ3MgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmaWxlLCBhcmdzID0gW10pID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICByZXR1cm4gW2ZpbGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmaWxlLCAuLi5hcmdzXTtcbiAgICB9LCBcIm5vcm1hbGl6ZUFyZ3NcIik7XG4gICAgdmFyIE5PX0VTQ0FQRV9SRUdFWFAgPSAvXltcXHcuLV0rJC87XG4gICAgdmFyIERPVUJMRV9RVU9URVNfUkVHRVhQID0gL1wiL2c7XG4gICAgdmFyIGVzY2FwZUFyZyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGFyZzIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYXJnMiAhPT0gXCJzdHJpbmdcIiB8fCBOT19FU0NBUEVfUkVHRVhQLnRlc3QoYXJnMikpIHtcbiAgICAgICAgcmV0dXJuIGFyZzI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYFwiJHthcmcyLnJlcGxhY2UoRE9VQkxFX1FVT1RFU19SRUdFWFAsICdcXFxcXCInKX1cImA7XG4gICAgfSwgXCJlc2NhcGVBcmdcIik7XG4gICAgdmFyIGpvaW5Db21tYW5kID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmlsZSwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3MoZmlsZSwgYXJncykuam9pbihcIiBcIik7XG4gICAgfSwgXCJqb2luQ29tbWFuZFwiKTtcbiAgICB2YXIgZ2V0RXNjYXBlZENvbW1hbmQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmaWxlLCBhcmdzKSA9PiB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyhmaWxlLCBhcmdzKS5tYXAoKGFyZzIpID0+IGVzY2FwZUFyZyhhcmcyKSkuam9pbihcIiBcIik7XG4gICAgfSwgXCJnZXRFc2NhcGVkQ29tbWFuZFwiKTtcbiAgICB2YXIgU1BBQ0VTX1JFR0VYUCA9IC8gKy9nO1xuICAgIHZhciBwYXJzZUNvbW1hbmQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjb21tYW5kKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgY29tbWFuZC50cmltKCkuc3BsaXQoU1BBQ0VTX1JFR0VYUCkpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4uZW5kc1dpdGgoXCJcXFxcXCIpKSB7XG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IGAke3ByZXZpb3VzVG9rZW4uc2xpY2UoMCwgLTEpfSAke3Rva2VufWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH0sIFwicGFyc2VDb21tYW5kXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGpvaW5Db21tYW5kLFxuICAgICAgZ2V0RXNjYXBlZENvbW1hbmQsXG4gICAgICBwYXJzZUNvbW1hbmRcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V4ZWNhQDUuMS4xL25vZGVfbW9kdWxlcy9leGVjYS9pbmRleC5qc1xudmFyIHJlcXVpcmVfZXhlY2EgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXhlY2FANS4xLjEvbm9kZV9tb2R1bGVzL2V4ZWNhL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwYXRoNyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbiAgICB2YXIgY3Jvc3NTcGF3biA9IHJlcXVpcmVfY3Jvc3Nfc3Bhd24oKTtcbiAgICB2YXIgc3RyaXBGaW5hbE5ld2xpbmUgPSByZXF1aXJlX3N0cmlwX2ZpbmFsX25ld2xpbmUoKTtcbiAgICB2YXIgbnBtUnVuUGF0aCA9IHJlcXVpcmVfbnBtX3J1bl9wYXRoKCk7XG4gICAgdmFyIG9uZXRpbWUgPSByZXF1aXJlX29uZXRpbWUoKTtcbiAgICB2YXIgbWFrZUVycm9yID0gcmVxdWlyZV9lcnJvcigpO1xuICAgIHZhciBub3JtYWxpemVTdGRpbyA9IHJlcXVpcmVfc3RkaW8oKTtcbiAgICB2YXIgeyBzcGF3bmVkS2lsbCwgc3Bhd25lZENhbmNlbCwgc2V0dXBUaW1lb3V0LCB2YWxpZGF0ZVRpbWVvdXQsIHNldEV4aXRIYW5kbGVyIH0gPSByZXF1aXJlX2tpbGwoKTtcbiAgICB2YXIgeyBoYW5kbGVJbnB1dCwgZ2V0U3Bhd25lZFJlc3VsdCwgbWFrZUFsbFN0cmVhbSwgdmFsaWRhdGVJbnB1dFN5bmMgfSA9IHJlcXVpcmVfc3RyZWFtKCk7XG4gICAgdmFyIHsgbWVyZ2VQcm9taXNlLCBnZXRTcGF3bmVkUHJvbWlzZSB9ID0gcmVxdWlyZV9wcm9taXNlKCk7XG4gICAgdmFyIHsgam9pbkNvbW1hbmQsIHBhcnNlQ29tbWFuZCwgZ2V0RXNjYXBlZENvbW1hbmQgfSA9IHJlcXVpcmVfY29tbWFuZCgpO1xuICAgIHZhciBERUZBVUxUX01BWF9CVUZGRVIgPSAxZTMgKiAxZTMgKiAxMDA7XG4gICAgdmFyIGdldEVudjIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IGVudjogZW52T3B0aW9uLCBleHRlbmRFbnYsIHByZWZlckxvY2FsLCBsb2NhbERpciwgZXhlY1BhdGggfSkgPT4ge1xuICAgICAgY29uc3QgZW52MiA9IGV4dGVuZEVudiA/IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLmVudk9wdGlvbiB9IDogZW52T3B0aW9uO1xuICAgICAgaWYgKHByZWZlckxvY2FsKSB7XG4gICAgICAgIHJldHVybiBucG1SdW5QYXRoLmVudih7IGVudjogZW52MiwgY3dkOiBsb2NhbERpciwgZXhlY1BhdGggfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW52MjtcbiAgICB9LCBcImdldEVudlwiKTtcbiAgICB2YXIgaGFuZGxlQXJndW1lbnRzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmlsZSwgYXJncywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBjcm9zc1NwYXduLl9wYXJzZShmaWxlLCBhcmdzLCBvcHRpb25zKTtcbiAgICAgIGZpbGUgPSBwYXJzZWQuY29tbWFuZDtcbiAgICAgIGFyZ3MgPSBwYXJzZWQuYXJncztcbiAgICAgIG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG1heEJ1ZmZlcjogREVGQVVMVF9NQVhfQlVGRkVSLFxuICAgICAgICBidWZmZXI6IHRydWUsXG4gICAgICAgIHN0cmlwRmluYWxOZXdsaW5lOiB0cnVlLFxuICAgICAgICBleHRlbmRFbnY6IHRydWUsXG4gICAgICAgIHByZWZlckxvY2FsOiBmYWxzZSxcbiAgICAgICAgbG9jYWxEaXI6IG9wdGlvbnMuY3dkIHx8IHByb2Nlc3MuY3dkKCksXG4gICAgICAgIGV4ZWNQYXRoOiBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgICAgICBlbmNvZGluZzogXCJ1dGY4XCIsXG4gICAgICAgIHJlamVjdDogdHJ1ZSxcbiAgICAgICAgY2xlYW51cDogdHJ1ZSxcbiAgICAgICAgYWxsOiBmYWxzZSxcbiAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRpb25zLmVudiA9IGdldEVudjIob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnN0ZGlvID0gbm9ybWFsaXplU3RkaW8ob3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiICYmIHBhdGg3LmJhc2VuYW1lKGZpbGUsIFwiLmV4ZVwiKSA9PT0gXCJjbWRcIikge1xuICAgICAgICBhcmdzLnVuc2hpZnQoXCIvcVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGZpbGUsIGFyZ3MsIG9wdGlvbnMsIHBhcnNlZCB9O1xuICAgIH0sIFwiaGFuZGxlQXJndW1lbnRzXCIpO1xuICAgIHZhciBoYW5kbGVPdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zLCB2YWx1ZSwgZXJyb3IyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zdHJpcEZpbmFsTmV3bGluZSkge1xuICAgICAgICByZXR1cm4gc3RyaXBGaW5hbE5ld2xpbmUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIFwiaGFuZGxlT3V0cHV0XCIpO1xuICAgIHZhciBleGVjYTIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChmaWxlLCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBoYW5kbGVBcmd1bWVudHMoZmlsZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBjb21tYW5kID0gam9pbkNvbW1hbmQoZmlsZSwgYXJncyk7XG4gICAgICBjb25zdCBlc2NhcGVkQ29tbWFuZCA9IGdldEVzY2FwZWRDb21tYW5kKGZpbGUsIGFyZ3MpO1xuICAgICAgdmFsaWRhdGVUaW1lb3V0KHBhcnNlZC5vcHRpb25zKTtcbiAgICAgIGxldCBzcGF3bmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3Bhd25lZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bihwYXJzZWQuZmlsZSwgcGFyc2VkLmFyZ3MsIHBhcnNlZC5vcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBjb25zdCBkdW1teVNwYXduZWQgPSBuZXcgY2hpbGRQcm9jZXNzLkNoaWxkUHJvY2VzcygpO1xuICAgICAgICBjb25zdCBlcnJvclByb21pc2UgPSBQcm9taXNlLnJlamVjdChtYWtlRXJyb3Ioe1xuICAgICAgICAgIGVycm9yOiBlcnJvcjIsXG4gICAgICAgICAgc3Rkb3V0OiBcIlwiLFxuICAgICAgICAgIHN0ZGVycjogXCJcIixcbiAgICAgICAgICBhbGw6IFwiXCIsXG4gICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICBlc2NhcGVkQ29tbWFuZCxcbiAgICAgICAgICBwYXJzZWQsXG4gICAgICAgICAgdGltZWRPdXQ6IGZhbHNlLFxuICAgICAgICAgIGlzQ2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICAgIGtpbGxlZDogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbWVyZ2VQcm9taXNlKGR1bW15U3Bhd25lZCwgZXJyb3JQcm9taXNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYXduZWRQcm9taXNlID0gZ2V0U3Bhd25lZFByb21pc2Uoc3Bhd25lZCk7XG4gICAgICBjb25zdCB0aW1lZFByb21pc2UgPSBzZXR1cFRpbWVvdXQoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHNwYXduZWRQcm9taXNlKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NEb25lID0gc2V0RXhpdEhhbmRsZXIoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHRpbWVkUHJvbWlzZSk7XG4gICAgICBjb25zdCBjb250ZXh0MyA9IHsgaXNDYW5jZWxlZDogZmFsc2UgfTtcbiAgICAgIHNwYXduZWQua2lsbCA9IHNwYXduZWRLaWxsLmJpbmQobnVsbCwgc3Bhd25lZC5raWxsLmJpbmQoc3Bhd25lZCkpO1xuICAgICAgc3Bhd25lZC5jYW5jZWwgPSBzcGF3bmVkQ2FuY2VsLmJpbmQobnVsbCwgc3Bhd25lZCwgY29udGV4dDMpO1xuICAgICAgY29uc3QgaGFuZGxlUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBbeyBlcnJvcjogZXJyb3IyLCBleGl0Q29kZSwgc2lnbmFsLCB0aW1lZE91dCB9LCBzdGRvdXRSZXN1bHQsIHN0ZGVyclJlc3VsdCwgYWxsUmVzdWx0XSA9IGF3YWl0IGdldFNwYXduZWRSZXN1bHQoc3Bhd25lZCwgcGFyc2VkLm9wdGlvbnMsIHByb2Nlc3NEb25lKTtcbiAgICAgICAgY29uc3Qgc3Rkb3V0ID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCBzdGRvdXRSZXN1bHQpO1xuICAgICAgICBjb25zdCBzdGRlcnIgPSBoYW5kbGVPdXRwdXQocGFyc2VkLm9wdGlvbnMsIHN0ZGVyclJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGFsbCA9IGhhbmRsZU91dHB1dChwYXJzZWQub3B0aW9ucywgYWxsUmVzdWx0KTtcbiAgICAgICAgaWYgKGVycm9yMiB8fCBleGl0Q29kZSAhPT0gMCB8fCBzaWduYWwgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByZXR1cm5lZEVycm9yID0gbWFrZUVycm9yKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcjIsXG4gICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIHN0ZG91dCxcbiAgICAgICAgICAgIHN0ZGVycixcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBlc2NhcGVkQ29tbWFuZCxcbiAgICAgICAgICAgIHBhcnNlZCxcbiAgICAgICAgICAgIHRpbWVkT3V0LFxuICAgICAgICAgICAgaXNDYW5jZWxlZDogY29udGV4dDMuaXNDYW5jZWxlZCxcbiAgICAgICAgICAgIGtpbGxlZDogc3Bhd25lZC5raWxsZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXBhcnNlZC5vcHRpb25zLnJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJldHVybmVkRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIGVzY2FwZWRDb21tYW5kLFxuICAgICAgICAgIGV4aXRDb2RlOiAwLFxuICAgICAgICAgIHN0ZG91dCxcbiAgICAgICAgICBzdGRlcnIsXG4gICAgICAgICAgYWxsLFxuICAgICAgICAgIGZhaWxlZDogZmFsc2UsXG4gICAgICAgICAgdGltZWRPdXQ6IGZhbHNlLFxuICAgICAgICAgIGlzQ2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICAgIGtpbGxlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0sIFwiaGFuZGxlUHJvbWlzZVwiKTtcbiAgICAgIGNvbnN0IGhhbmRsZVByb21pc2VPbmNlID0gb25ldGltZShoYW5kbGVQcm9taXNlKTtcbiAgICAgIGhhbmRsZUlucHV0KHNwYXduZWQsIHBhcnNlZC5vcHRpb25zLmlucHV0KTtcbiAgICAgIHNwYXduZWQuYWxsID0gbWFrZUFsbFN0cmVhbShzcGF3bmVkLCBwYXJzZWQub3B0aW9ucyk7XG4gICAgICByZXR1cm4gbWVyZ2VQcm9taXNlKHNwYXduZWQsIGhhbmRsZVByb21pc2VPbmNlKTtcbiAgICB9LCBcImV4ZWNhXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGV4ZWNhMjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuc3luYyA9IChmaWxlLCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBoYW5kbGVBcmd1bWVudHMoZmlsZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBjb21tYW5kID0gam9pbkNvbW1hbmQoZmlsZSwgYXJncyk7XG4gICAgICBjb25zdCBlc2NhcGVkQ29tbWFuZCA9IGdldEVzY2FwZWRDb21tYW5kKGZpbGUsIGFyZ3MpO1xuICAgICAgdmFsaWRhdGVJbnB1dFN5bmMocGFyc2VkLm9wdGlvbnMpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNoaWxkUHJvY2Vzcy5zcGF3blN5bmMocGFyc2VkLmZpbGUsIHBhcnNlZC5hcmdzLCBwYXJzZWQub3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKHtcbiAgICAgICAgICBlcnJvcjogZXJyb3IyLFxuICAgICAgICAgIHN0ZG91dDogXCJcIixcbiAgICAgICAgICBzdGRlcnI6IFwiXCIsXG4gICAgICAgICAgYWxsOiBcIlwiLFxuICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgZXNjYXBlZENvbW1hbmQsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICBpc0NhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgICBraWxsZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Rkb3V0ID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCByZXN1bHQuc3Rkb3V0LCByZXN1bHQuZXJyb3IpO1xuICAgICAgY29uc3Qgc3RkZXJyID0gaGFuZGxlT3V0cHV0KHBhcnNlZC5vcHRpb25zLCByZXN1bHQuc3RkZXJyLCByZXN1bHQuZXJyb3IpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvciB8fCByZXN1bHQuc3RhdHVzICE9PSAwIHx8IHJlc3VsdC5zaWduYWwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZXJyb3IyID0gbWFrZUVycm9yKHtcbiAgICAgICAgICBzdGRvdXQsXG4gICAgICAgICAgc3RkZXJyLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3IsXG4gICAgICAgICAgc2lnbmFsOiByZXN1bHQuc2lnbmFsLFxuICAgICAgICAgIGV4aXRDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgZXNjYXBlZENvbW1hbmQsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHRpbWVkT3V0OiByZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmVycm9yLmNvZGUgPT09IFwiRVRJTUVET1VUXCIsXG4gICAgICAgICAgaXNDYW5jZWxlZDogZmFsc2UsXG4gICAgICAgICAga2lsbGVkOiByZXN1bHQuc2lnbmFsICE9PSBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBhcnNlZC5vcHRpb25zLnJlamVjdCkge1xuICAgICAgICAgIHJldHVybiBlcnJvcjI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWFuZCxcbiAgICAgICAgZXNjYXBlZENvbW1hbmQsXG4gICAgICAgIGV4aXRDb2RlOiAwLFxuICAgICAgICBzdGRvdXQsXG4gICAgICAgIHN0ZGVycixcbiAgICAgICAgZmFpbGVkOiBmYWxzZSxcbiAgICAgICAgdGltZWRPdXQ6IGZhbHNlLFxuICAgICAgICBpc0NhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAga2lsbGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5jb21tYW5kID0gKGNvbW1hbmQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IFtmaWxlLCAuLi5hcmdzXSA9IHBhcnNlQ29tbWFuZChjb21tYW5kKTtcbiAgICAgIHJldHVybiBleGVjYTIoZmlsZSwgYXJncywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29tbWFuZFN5bmMgPSAoY29tbWFuZCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgW2ZpbGUsIC4uLmFyZ3NdID0gcGFyc2VDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgcmV0dXJuIGV4ZWNhMi5zeW5jKGZpbGUsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzLm5vZGUgPSAoc2NyaXB0UGF0aCwgYXJncywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAoYXJncyAmJiAhQXJyYXkuaXNBcnJheShhcmdzKSAmJiB0eXBlb2YgYXJncyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gYXJncztcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RkaW8gPSBub3JtYWxpemVTdGRpby5ub2RlKG9wdGlvbnMpO1xuICAgICAgY29uc3QgZGVmYXVsdEV4ZWNBcmd2ID0gcHJvY2Vzcy5leGVjQXJndi5maWx0ZXIoKGFyZzIpID0+ICFhcmcyLnN0YXJ0c1dpdGgoXCItLWluc3BlY3RcIikpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlUGF0aCA9IHByb2Nlc3MuZXhlY1BhdGgsXG4gICAgICAgIG5vZGVPcHRpb25zID0gZGVmYXVsdEV4ZWNBcmd2XG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHJldHVybiBleGVjYTIoXG4gICAgICAgIG5vZGVQYXRoLFxuICAgICAgICBbXG4gICAgICAgICAgLi4ubm9kZU9wdGlvbnMsXG4gICAgICAgICAgc2NyaXB0UGF0aCxcbiAgICAgICAgICAuLi5BcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFtdXG4gICAgICAgIF0sXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHN0ZGluOiB2b2lkIDAsXG4gICAgICAgICAgc3Rkb3V0OiB2b2lkIDAsXG4gICAgICAgICAgc3RkZXJyOiB2b2lkIDAsXG4gICAgICAgICAgc3RkaW8sXG4gICAgICAgICAgc2hlbGw6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZXRyeUAwLjEzLjEvbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeV9vcGVyYXRpb24uanNcbnZhciByZXF1aXJlX3JldHJ5X29wZXJhdGlvbiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZXRyeUAwLjEzLjEvbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeV9vcGVyYXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlPcGVyYXRpb24odGltZW91dHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgZm9yZXZlcjogb3B0aW9ucyB9O1xuICAgICAgfVxuICAgICAgdGhpcy5fb3JpZ2luYWxUaW1lb3V0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZW91dHMpKTtcbiAgICAgIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG4gICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX21heFJldHJ5VGltZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWUgfHwgSW5maW5pdHk7XG4gICAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9yZXZlcikge1xuICAgICAgICB0aGlzLl9jYWNoZWRUaW1lb3V0cyA9IHRoaXMuX3RpbWVvdXRzLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoUmV0cnlPcGVyYXRpb24sIFwiUmV0cnlPcGVyYXRpb25cIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUmV0cnlPcGVyYXRpb247XG4gICAgUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gICAgICB0aGlzLl90aW1lb3V0cyA9IHRoaXMuX29yaWdpbmFsVGltZW91dHMuc2xpY2UoMCk7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICB9XG4gICAgICB0aGlzLl90aW1lb3V0cyA9IFtdO1xuICAgICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSBudWxsO1xuICAgIH07XG4gICAgUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB9XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGlmIChlcnIgJiYgY3VycmVudFRpbWUgLSB0aGlzLl9vcGVyYXRpb25TdGFydCA+PSB0aGlzLl9tYXhSZXRyeVRpbWUpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnVuc2hpZnQobmV3IEVycm9yKFwiUmV0cnlPcGVyYXRpb24gdGltZW91dCBvY2N1cnJlZFwiKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKGVycik7XG4gICAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gICAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRUaW1lb3V0cykge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5zcGxpY2UoMCwgdGhpcy5fZXJyb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIHRpbWVvdXQgPSB0aGlzLl9jYWNoZWRUaW1lb3V0cy5zbGljZSgtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmMi5fYXR0ZW1wdHMrKztcbiAgICAgICAgaWYgKHNlbGYyLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICAgICAgICBzZWxmMi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmMi5fb3BlcmF0aW9uVGltZW91dENiKHNlbGYyLl9hdHRlbXB0cyk7XG4gICAgICAgICAgfSwgc2VsZjIuX29wZXJhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIGlmIChzZWxmMi5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICAgICAgc2VsZjIuX3RpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZjIuX2ZuKHNlbGYyLl9hdHRlbXB0cyk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyLnVucmVmKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0ID0gZnVuY3Rpb24oZm4sIHRpbWVvdXRPcHMpIHtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBpZiAodGltZW91dE9wcykge1xuICAgICAgICBpZiAodGltZW91dE9wcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IHRpbWVvdXRPcHMudGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZW91dE9wcy5jYikge1xuICAgICAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IHRpbWVvdXRPcHMuY2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYyLl9vcGVyYXRpb25UaW1lb3V0Q2IoKTtcbiAgICAgICAgfSwgc2VsZjIuX29wZXJhdGlvblRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuX2ZuKHRoaXMuX2F0dGVtcHRzKTtcbiAgICB9O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnkgPSBmdW5jdGlvbihmbikge1xuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBSZXRyeU9wZXJhdGlvbi50cnkoKSBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgdGhpcy5hdHRlbXB0KGZuKTtcbiAgICB9O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIFJldHJ5T3BlcmF0aW9uLnN0YXJ0KCkgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgIHRoaXMuYXR0ZW1wdChmbik7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcnM7XG4gICAgfTtcbiAgICBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdHRlbXB0cztcbiAgICB9O1xuICAgIFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5tYWluRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNvdW50cyA9IHt9O1xuICAgICAgdmFyIG1haW5FcnJvciA9IG51bGw7XG4gICAgICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yMiA9IHRoaXMuX2Vycm9yc1tpXTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJvcjIubWVzc2FnZTtcbiAgICAgICAgdmFyIGNvdW50MiA9IChjb3VudHNbbWVzc2FnZV0gfHwgMCkgKyAxO1xuICAgICAgICBjb3VudHNbbWVzc2FnZV0gPSBjb3VudDI7XG4gICAgICAgIGlmIChjb3VudDIgPj0gbWFpbkVycm9yQ291bnQpIHtcbiAgICAgICAgICBtYWluRXJyb3IgPSBlcnJvcjI7XG4gICAgICAgICAgbWFpbkVycm9yQ291bnQgPSBjb3VudDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWluRXJyb3I7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZXRyeUAwLjEzLjEvbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeS5qc1xudmFyIHJlcXVpcmVfcmV0cnkgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanNcIihleHBvcnRzKSB7XG4gICAgdmFyIFJldHJ5T3BlcmF0aW9uID0gcmVxdWlyZV9yZXRyeV9vcGVyYXRpb24oKTtcbiAgICBleHBvcnRzLm9wZXJhdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0aW1lb3V0cyA9IGV4cG9ydHMudGltZW91dHMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICAgIGZvcmV2ZXI6IG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9yZXZlciB8fCBvcHRpb25zLnJldHJpZXMgPT09IEluZmluaXR5KSxcbiAgICAgICAgdW5yZWY6IG9wdGlvbnMgJiYgb3B0aW9ucy51bnJlZixcbiAgICAgICAgbWF4UmV0cnlUaW1lOiBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudGltZW91dHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcmV0cmllczogMTAsXG4gICAgICAgIGZhY3RvcjogMixcbiAgICAgICAgbWluVGltZW91dDogMSAqIDFlMyxcbiAgICAgICAgbWF4VGltZW91dDogSW5maW5pdHksXG4gICAgICAgIHJhbmRvbWl6ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5taW5UaW1lb3V0ID4gb3B0cy5tYXhUaW1lb3V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pblRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIG1heFRpbWVvdXRcIik7XG4gICAgICB9XG4gICAgICB2YXIgdGltZW91dHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICAgICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JldmVyICYmICF0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICAgICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICAgICAgfVxuICAgICAgdGltZW91dHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRpbWVvdXRzO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICAgICAgdmFyIHJhbmRvbTIgPSBvcHRzLnJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgKyAxIDogMTtcbiAgICAgIHZhciB0aW1lb3V0ID0gTWF0aC5yb3VuZChyYW5kb20yICogTWF0aC5tYXgob3B0cy5taW5UaW1lb3V0LCAxKSAqIE1hdGgucG93KG9wdHMuZmFjdG9yLCBhdHRlbXB0KSk7XG4gICAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0cy5tYXhUaW1lb3V0KTtcbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH07XG4gICAgZXhwb3J0cy53cmFwID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBtZXRob2RzKSB7XG4gICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIG1ldGhvZHMgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbWV0aG9kcykge1xuICAgICAgICBtZXRob2RzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXTtcbiAgICAgICAgb2JqW21ldGhvZF0gPSAoLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiByZXRyeVdyYXBwZXIob3JpZ2luYWwyKSB7XG4gICAgICAgICAgdmFyIG9wID0gZXhwb3J0cy5vcGVyYXRpb24ob3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKG9wLnJldHJ5KGVycikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBvcC5tYWluRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3AuYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsMi5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBcInJldHJ5V3JhcHBlclwiKSkuYmluZChvYmosIG9yaWdpbmFsKTtcbiAgICAgICAgb2JqW21ldGhvZF0ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZXRyeUAwLjEzLjEvbm9kZV9tb2R1bGVzL3JldHJ5L2luZGV4LmpzXG52YXIgcmVxdWlyZV9yZXRyeTIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3JldHJ5KCk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcC1yZXRyeUA0LjYuMi9ub2RlX21vZHVsZXMvcC1yZXRyeS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcF9yZXRyeSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wLXJldHJ5QDQuNi4yL25vZGVfbW9kdWxlcy9wLXJldHJ5L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByZXRyeSA9IHJlcXVpcmVfcmV0cnkyKCk7XG4gICAgdmFyIG5ldHdvcmtFcnJvck1zZ3MgPSBbXG4gICAgICBcIkZhaWxlZCB0byBmZXRjaFwiLFxuICAgICAgXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiLFxuICAgICAgXCJUaGUgSW50ZXJuZXQgY29ubmVjdGlvbiBhcHBlYXJzIHRvIGJlIG9mZmxpbmUuXCIsXG4gICAgICBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIlxuICAgIF07XG4gICAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG1lc3NhZ2U7XG4gICAgICAgICAgKHsgbWVzc2FnZSB9ID0gbWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvci5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQWJvcnRFcnJvciwgXCJBYm9ydEVycm9yXCIpO1xuICAgIHZhciBkZWNvcmF0ZUVycm9yV2l0aENvdW50cyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGVycm9yMiwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmV0cmllc0xlZnQgPSBvcHRpb25zLnJldHJpZXMgLSAoYXR0ZW1wdE51bWJlciAtIDEpO1xuICAgICAgZXJyb3IyLmF0dGVtcHROdW1iZXIgPSBhdHRlbXB0TnVtYmVyO1xuICAgICAgZXJyb3IyLnJldHJpZXNMZWZ0ID0gcmV0cmllc0xlZnQ7XG4gICAgICByZXR1cm4gZXJyb3IyO1xuICAgIH0sIFwiZGVjb3JhdGVFcnJvcldpdGhDb3VudHNcIik7XG4gICAgdmFyIGlzTmV0d29ya0Vycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZXJyb3JNZXNzYWdlKSA9PiBuZXR3b3JrRXJyb3JNc2dzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSksIFwiaXNOZXR3b3JrRXJyb3JcIik7XG4gICAgdmFyIHBSZXRyeTIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIHJldHJpZXM6IDEwLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcmV0cnkub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgb3BlcmF0aW9uLmF0dGVtcHQoYXN5bmMgKGF0dGVtcHROdW1iZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNvbHZlKGF3YWl0IGlucHV0KGF0dGVtcHROdW1iZXIpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgaWYgKCEoZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcihgTm9uLWVycm9yIHdhcyB0aHJvd246IFwiJHtlcnJvcjJ9XCIuIFlvdSBzaG91bGQgb25seSB0aHJvdyBlcnJvcnMuYCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgQWJvcnRFcnJvcikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcjIub3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgIWlzTmV0d29ya0Vycm9yKGVycm9yMi5tZXNzYWdlKSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWNvcmF0ZUVycm9yV2l0aENvdW50cyhlcnJvcjIsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgb3B0aW9ucy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24ucmV0cnkoZXJyb3IyKSkge1xuICAgICAgICAgICAgICByZWplY3Qob3BlcmF0aW9uLm1haW5FcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCBcInBSZXRyeVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwUmV0cnkyO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gcFJldHJ5MjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuQWJvcnRFcnJvciA9IEFib3J0RXJyb3I7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYW5zaS1yZWdleEA1LjAuMS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qc1xudmFyIHJlcXVpcmVfYW5zaV9yZWdleCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hbnNpLXJlZ2V4QDUuMC4xL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9ICh7IG9ubHlGaXJzdCA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgcGF0dGVybiA9IFtcbiAgICAgICAgXCJbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpXCIsXG4gICAgICAgIFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIlxuICAgICAgXS5qb2luKFwifFwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHZvaWQgMCA6IFwiZ1wiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmlwLWFuc2lANi4wLjEvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanNcbnZhciByZXF1aXJlX3N0cmlwX2Fuc2kgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyaXAtYW5zaUA2LjAuMS9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZV9hbnNpX3JlZ2V4KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKHN0cmluZykgPT4gdHlwZW9mIHN0cmluZyA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCBcIlwiKSA6IHN0cmluZztcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXctZ2l0aHViLWlzc3VlLXVybEAwLjIuMS9ub2RlX21vZHVsZXMvbmV3LWdpdGh1Yi1pc3N1ZS11cmwvaW5kZXguanNcbnZhciByZXF1aXJlX25ld19naXRodWJfaXNzdWVfdXJsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25ldy1naXRodWItaXNzdWUtdXJsQDAuMi4xL25vZGVfbW9kdWxlcy9uZXctZ2l0aHViLWlzc3VlLXVybC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBsZXQgcmVwb1VybDtcbiAgICAgIGlmIChvcHRpb25zLnJlcG9VcmwpIHtcbiAgICAgICAgcmVwb1VybCA9IG9wdGlvbnMucmVwb1VybDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy51c2VyICYmIG9wdGlvbnMucmVwbykge1xuICAgICAgICByZXBvVXJsID0gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke29wdGlvbnMudXNlcn0vJHtvcHRpb25zLnJlcG99YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgZWl0aGVyIHRoZSBgcmVwb1VybGAgb3B0aW9uIG9yIGJvdGggdGhlIGB1c2VyYCBhbmQgYHJlcG9gIG9wdGlvbnNcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3JlcG9Vcmx9L2lzc3Vlcy9uZXdgKTtcbiAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICBcImJvZHlcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcImxhYmVsc1wiLFxuICAgICAgICBcInRlbXBsYXRlXCIsXG4gICAgICAgIFwibWlsZXN0b25lXCIsXG4gICAgICAgIFwiYXNzaWduZWVcIixcbiAgICAgICAgXCJwcm9qZWN0c1wiXG4gICAgICBdO1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG9wdGlvbnNbdHlwZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwibGFiZWxzXCIgfHwgdHlwZSA9PT0gXCJwcm9qZWN0c1wiKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYCR7dHlwZX1cXGAgb3B0aW9uIHNob3VsZCBiZSBhbiBhcnJheWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlMi5leHBvcnRzO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9zeW1ib2xzLmpzXG52YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9zeW1ib2xzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGtDbG9zZTogU3ltYm9sKFwiY2xvc2VcIiksXG4gICAgICBrRGVzdHJveTogU3ltYm9sKFwiZGVzdHJveVwiKSxcbiAgICAgIGtEaXNwYXRjaDogU3ltYm9sKFwiZGlzcGF0Y2hcIiksXG4gICAgICBrVXJsOiBTeW1ib2woXCJ1cmxcIiksXG4gICAgICBrV3JpdGluZzogU3ltYm9sKFwid3JpdGluZ1wiKSxcbiAgICAgIGtSZXN1bWluZzogU3ltYm9sKFwicmVzdW1pbmdcIiksXG4gICAgICBrUXVldWU6IFN5bWJvbChcInF1ZXVlXCIpLFxuICAgICAga0Nvbm5lY3Q6IFN5bWJvbChcImNvbm5lY3RcIiksXG4gICAgICBrQ29ubmVjdGluZzogU3ltYm9sKFwiY29ubmVjdGluZ1wiKSxcbiAgICAgIGtIZWFkZXJzTGlzdDogU3ltYm9sKFwiaGVhZGVycyBsaXN0XCIpLFxuICAgICAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0OiBTeW1ib2woXCJkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dFwiKSxcbiAgICAgIGtLZWVwQWxpdmVNYXhUaW1lb3V0OiBTeW1ib2woXCJtYXgga2VlcCBhbGl2ZSB0aW1lb3V0XCIpLFxuICAgICAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQ6IFN5bWJvbChcImtlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGRcIiksXG4gICAgICBrS2VlcEFsaXZlVGltZW91dFZhbHVlOiBTeW1ib2woXCJrZWVwIGFsaXZlIHRpbWVvdXRcIiksXG4gICAgICBrS2VlcEFsaXZlOiBTeW1ib2woXCJrZWVwIGFsaXZlXCIpLFxuICAgICAga0hlYWRlcnNUaW1lb3V0OiBTeW1ib2woXCJoZWFkZXJzIHRpbWVvdXRcIiksXG4gICAgICBrQm9keVRpbWVvdXQ6IFN5bWJvbChcImJvZHkgdGltZW91dFwiKSxcbiAgICAgIGtTZXJ2ZXJOYW1lOiBTeW1ib2woXCJzZXJ2ZXIgbmFtZVwiKSxcbiAgICAgIGtIb3N0OiBTeW1ib2woXCJob3N0XCIpLFxuICAgICAga05vUmVmOiBTeW1ib2woXCJubyByZWZcIiksXG4gICAgICBrQm9keVVzZWQ6IFN5bWJvbChcInVzZWRcIiksXG4gICAgICBrUnVubmluZzogU3ltYm9sKFwicnVubmluZ1wiKSxcbiAgICAgIGtCbG9ja2luZzogU3ltYm9sKFwiYmxvY2tpbmdcIiksXG4gICAgICBrUGVuZGluZzogU3ltYm9sKFwicGVuZGluZ1wiKSxcbiAgICAgIGtTaXplOiBTeW1ib2woXCJzaXplXCIpLFxuICAgICAga0J1c3k6IFN5bWJvbChcImJ1c3lcIiksXG4gICAgICBrUXVldWVkOiBTeW1ib2woXCJxdWV1ZWRcIiksXG4gICAgICBrRnJlZTogU3ltYm9sKFwiZnJlZVwiKSxcbiAgICAgIGtDb25uZWN0ZWQ6IFN5bWJvbChcImNvbm5lY3RlZFwiKSxcbiAgICAgIGtDbG9zZWQ6IFN5bWJvbChcImNsb3NlZFwiKSxcbiAgICAgIGtOZWVkRHJhaW46IFN5bWJvbChcIm5lZWQgZHJhaW5cIiksXG4gICAgICBrUmVzZXQ6IFN5bWJvbChcInJlc2V0XCIpLFxuICAgICAga0Rlc3Ryb3llZDogU3ltYm9sKFwiZGVzdHJveWVkXCIpLFxuICAgICAga01heEhlYWRlcnNTaXplOiBTeW1ib2woXCJtYXggaGVhZGVycyBzaXplXCIpLFxuICAgICAga1J1bm5pbmdJZHg6IFN5bWJvbChcInJ1bm5pbmcgaW5kZXhcIiksXG4gICAgICBrUGVuZGluZ0lkeDogU3ltYm9sKFwicGVuZGluZyBpbmRleFwiKSxcbiAgICAgIGtFcnJvcjogU3ltYm9sKFwiZXJyb3JcIiksXG4gICAgICBrQ2xpZW50czogU3ltYm9sKFwiY2xpZW50c1wiKSxcbiAgICAgIGtDbGllbnQ6IFN5bWJvbChcImNsaWVudFwiKSxcbiAgICAgIGtQYXJzZXI6IFN5bWJvbChcInBhcnNlclwiKSxcbiAgICAgIGtPbkRlc3Ryb3llZDogU3ltYm9sKFwiZGVzdHJveSBjYWxsYmFja3NcIiksXG4gICAgICBrUGlwZWxpbmluZzogU3ltYm9sKFwicGlwZWxpbmlnXCIpLFxuICAgICAga1NvY2tldDogU3ltYm9sKFwic29ja2V0XCIpLFxuICAgICAga0hvc3RIZWFkZXI6IFN5bWJvbChcImhvc3QgaGVhZGVyXCIpLFxuICAgICAga0Nvbm5lY3RvcjogU3ltYm9sKFwiY29ubmVjdG9yXCIpLFxuICAgICAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbChcInN0cmljdCBjb250ZW50IGxlbmd0aFwiKSxcbiAgICAgIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbChcIm1heFJlZGlyZWN0aW9uc1wiKSxcbiAgICAgIGtNYXhSZXF1ZXN0czogU3ltYm9sKFwibWF4UmVxdWVzdHNQZXJDbGllbnRcIiksXG4gICAgICBrUHJveHk6IFN5bWJvbChcInByb3h5IGFnZW50IG9wdGlvbnNcIiksXG4gICAgICBrQ291bnRlcjogU3ltYm9sKFwic29ja2V0IHJlcXVlc3QgY291bnRlclwiKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qc1xudmFyIHJlcXVpcmVfZXJyb3JzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9lcnJvcnMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFVuZGljaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVuZGljaUVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUlwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFVuZGljaUVycm9yLCBcIlVuZGljaUVycm9yXCIpO1xuICAgIHZhciBDb25uZWN0VGltZW91dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDb25uZWN0VGltZW91dEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDb25uZWN0VGltZW91dEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJDb25uZWN0IFRpbWVvdXQgRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0NPTk5FQ1RfVElNRU9VVFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENvbm5lY3RUaW1lb3V0RXJyb3IsIFwiQ29ubmVjdFRpbWVvdXRFcnJvclwiKTtcbiAgICB2YXIgSGVhZGVyc1RpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSGVhZGVyc1RpbWVvdXRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSGVhZGVyc1RpbWVvdXRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiSGVhZGVycyBUaW1lb3V0IEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9IRUFERVJTX1RJTUVPVVRcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShIZWFkZXJzVGltZW91dEVycm9yLCBcIkhlYWRlcnNUaW1lb3V0RXJyb3JcIik7XG4gICAgdmFyIEhlYWRlcnNPdmVyZmxvd0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBIZWFkZXJzT3ZlcmZsb3dFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSGVhZGVyc092ZXJmbG93RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkhlYWRlcnMgT3ZlcmZsb3cgRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1dcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShIZWFkZXJzT3ZlcmZsb3dFcnJvciwgXCJIZWFkZXJzT3ZlcmZsb3dFcnJvclwiKTtcbiAgICB2YXIgQm9keVRpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQm9keVRpbWVvdXRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQm9keVRpbWVvdXRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiQm9keSBUaW1lb3V0IEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9CT0RZX1RJTUVPVVRcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShCb2R5VGltZW91dEVycm9yLCBcIkJvZHlUaW1lb3V0RXJyb3JcIik7XG4gICAgdmFyIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlJlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9SRVNQT05TRV9TVEFUVVNfQ09ERVwiO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsIFwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3JcIik7XG4gICAgdmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkQXJndW1lbnRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkludmFsaWQgQXJndW1lbnQgRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0lOVkFMSURfQVJHXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSW52YWxpZEFyZ3VtZW50RXJyb3IsIFwiSW52YWxpZEFyZ3VtZW50RXJyb3JcIik7XG4gICAgdmFyIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZFJldHVyblZhbHVlRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIkludmFsaWQgUmV0dXJuIFZhbHVlIEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRVwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLCBcIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yXCIpO1xuICAgIHZhciBSZXF1ZXN0QWJvcnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0QWJvcnRlZEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJSZXF1ZXN0IGFib3J0ZWRcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0FCT1JURURcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShSZXF1ZXN0QWJvcnRlZEVycm9yLCBcIlJlcXVlc3RBYm9ydGVkRXJyb3JcIik7XG4gICAgdmFyIEluZm9ybWF0aW9uYWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW5mb3JtYXRpb25hbEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbmZvcm1hdGlvbmFsRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlJlcXVlc3QgaW5mb3JtYXRpb25cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0lORk9cIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShJbmZvcm1hdGlvbmFsRXJyb3IsIFwiSW5mb3JtYXRpb25hbEVycm9yXCIpO1xuICAgIHZhciBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfUkVRX0NPTlRFTlRfTEVOR1RIX01JU01BVENIXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLCBcIlJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvclwiKTtcbiAgICB2YXIgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiUmVzcG9uc2UgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0hcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLCBcIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIik7XG4gICAgdmFyIENsaWVudERlc3Ryb3llZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDbGllbnREZXN0cm95ZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ2xpZW50RGVzdHJveWVkRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlRoZSBjbGllbnQgaXMgZGVzdHJveWVkXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9ERVNUUk9ZRURcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShDbGllbnREZXN0cm95ZWRFcnJvciwgXCJDbGllbnREZXN0cm95ZWRFcnJvclwiKTtcbiAgICB2YXIgQ2xpZW50Q2xvc2VkRXJyb3IgPSBjbGFzcyBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENsaWVudENsb3NlZEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDbGllbnRDbG9zZWRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiVGhlIGNsaWVudCBpcyBjbG9zZWRcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0NMT1NFRFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENsaWVudENsb3NlZEVycm9yLCBcIkNsaWVudENsb3NlZEVycm9yXCIpO1xuICAgIHZhciBTb2NrZXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgc29ja2V0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTb2NrZXRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU29ja2V0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlNvY2tldCBlcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIlVORF9FUlJfU09DS0VUXCI7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFNvY2tldEVycm9yLCBcIlNvY2tldEVycm9yXCIpO1xuICAgIHZhciBOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5vdFN1cHBvcnRlZEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJOb3Qgc3VwcG9ydGVkIGVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiVU5EX0VSUl9OT1RfU1VQUE9SVEVEXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoTm90U3VwcG9ydGVkRXJyb3IsIFwiTm90U3VwcG9ydGVkRXJyb3JcIik7XG4gICAgdmFyIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb3RTdXBwb3J0ZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWlzc2luZ1Vwc3RyZWFtRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIk5vIHVwc3RyZWFtIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBCYWxhbmNlZFBvb2xcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfRVJSX0JQTF9NSVNTSU5HX1VQU1RSRUFNXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsIFwiQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3JcIik7XG4gICAgdmFyIEhUVFBQYXJzZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSFRUUFBhcnNlckVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJIVFRQUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZSA/IGBIUEVfJHtjb2RlfWAgOiB2b2lkIDA7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgPyBkYXRhLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSFRUUFBhcnNlckVycm9yLCBcIkhUVFBQYXJzZXJFcnJvclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBIVFRQUGFyc2VyRXJyb3IsXG4gICAgICBVbmRpY2lFcnJvcixcbiAgICAgIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gICAgICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgICAgIEJvZHlUaW1lb3V0RXJyb3IsXG4gICAgICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gICAgICBDb25uZWN0VGltZW91dEVycm9yLFxuICAgICAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsXG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgICAgIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICAgICAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgICAgIENsaWVudERlc3Ryb3llZEVycm9yLFxuICAgICAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gICAgICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gICAgICBTb2NrZXRFcnJvcixcbiAgICAgIE5vdFN1cHBvcnRlZEVycm9yLFxuICAgICAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgICAgIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvdXRpbC5qc1xudmFyIHJlcXVpcmVfdXRpbDIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsga0Rlc3Ryb3llZCwga0JvZHlVc2VkIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoXCJodHRwXCIpO1xuICAgIHZhciBzdHJlYW0yID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiAgICB2YXIgbmV0MiA9IHJlcXVpcmUoXCJuZXRcIik7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHsgQmxvYiB9ID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbiAgICB2YXIgbm9kZVV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICBmdW5jdGlvbiBub3AoKSB7XG4gICAgfVxuICAgIF9fbmFtZShub3AsIFwibm9wXCIpO1xuICAgIGZ1bmN0aW9uIGlzU3RyZWFtKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgX19uYW1lKGlzU3RyZWFtLCBcImlzU3RyZWFtXCIpO1xuICAgIGZ1bmN0aW9uIGlzQmxvYkxpa2Uob2JqZWN0KSB7XG4gICAgICByZXR1cm4gQmxvYiAmJiBvYmplY3QgaW5zdGFuY2VvZiBCbG9iIHx8IG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmICh0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIikgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICAgIH1cbiAgICBfX25hbWUoaXNCbG9iTGlrZSwgXCJpc0Jsb2JMaWtlXCIpO1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0Myh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgX19uYW1lKGlzT2JqZWN0MywgXCJpc09iamVjdFwiKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCk7XG4gICAgfVxuICAgIF9fbmFtZShlbmNvZGUsIFwiZW5jb2RlXCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgIGlmICh1cmwuaW5jbHVkZXMoXCI/XCIpIHx8IHVybC5pbmNsdWRlcyhcIiNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBwYXJhbXMgY2Fubm90IGJlIHBhc3NlZCB3aGVuIHVybCBhbHJlYWR5IGNvbnRhaW5zIFwiP1wiIG9yIFwiI1wiLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdDMocXVlcnlQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5IHBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWwpIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QzKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzaW5nIG9iamVjdCBhcyBhIHF1ZXJ5IHBhcmFtIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSBzZXJpYWxpemUgdG8gc3RyaW5nIHVwLWZyb250XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgXCI9XCIgKyBlbmNvZGUodikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbihcIiZcIik7XG4gICAgICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgICB1cmwgKz0gXCI/XCIgKyBzZXJpYWxpemVkUGFyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkVVJMLCBcImJ1aWxkVVJMXCIpO1xuICAgIGZ1bmN0aW9uIHBhcnNlVVJMKHVybCkge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHVybFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwucG9ydCAhPSBudWxsICYmIHVybC5wb3J0ICE9PSBcIlwiICYmICFOdW1iZXIuaXNGaW5pdGUocGFyc2VJbnQodXJsLnBvcnQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHBvcnRcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsLnBhdGggIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwYXRoXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5wYXRobmFtZSAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwYXRobmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaG9zdG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLmhvc3RuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgaG9zdG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsLm9yaWdpbiAhPSBudWxsICYmIHR5cGVvZiB1cmwub3JpZ2luICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3JpZ2luXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEvXmh0dHBzPzovLnRlc3QodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvdG9jb2xcIik7XG4gICAgICB9XG4gICAgICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGNvbnN0IHBvcnQgPSB1cmwucG9ydCAhPSBudWxsID8gdXJsLnBvcnQgOiB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyA0NDMgOiA4MDtcbiAgICAgICAgbGV0IG9yaWdpbiA9IHVybC5vcmlnaW4gIT0gbnVsbCA/IHVybC5vcmlnaW4gOiBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX06JHtwb3J0fWA7XG4gICAgICAgIGxldCBwYXRoNyA9IHVybC5wYXRoICE9IG51bGwgPyB1cmwucGF0aCA6IGAke3VybC5wYXRobmFtZSB8fCBcIlwifSR7dXJsLnNlYXJjaCB8fCBcIlwifWA7XG4gICAgICAgIGlmIChvcmlnaW4uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgb3JpZ2luID0gb3JpZ2luLnN1YnN0cmluZygwLCBvcmlnaW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGg3ICYmICFwYXRoNy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgIHBhdGg3ID0gYC8ke3BhdGg3fWA7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gbmV3IFVSTChvcmlnaW4gKyBwYXRoNyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VVUkwsIFwicGFyc2VVUkxcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VPcmlnaW4odXJsKSB7XG4gICAgICB1cmwgPSBwYXJzZVVSTCh1cmwpO1xuICAgICAgaWYgKHVybC5wYXRobmFtZSAhPT0gXCIvXCIgfHwgdXJsLnNlYXJjaCB8fCB1cmwuaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHVybFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIF9fbmFtZShwYXJzZU9yaWdpbiwgXCJwYXJzZU9yaWdpblwiKTtcbiAgICBmdW5jdGlvbiBnZXRIb3N0bmFtZShob3N0KSB7XG4gICAgICBpZiAoaG9zdFswXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgY29uc3QgaWR4MiA9IGhvc3QuaW5kZXhPZihcIl1cIik7XG4gICAgICAgIGFzc2VydChpZHgyICE9PSAtMSk7XG4gICAgICAgIHJldHVybiBob3N0LnN1YnN0cigxLCBpZHgyIC0gMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoXCI6XCIpO1xuICAgICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBob3N0O1xuICAgICAgcmV0dXJuIGhvc3Quc3Vic3RyKDAsIGlkeCk7XG4gICAgfVxuICAgIF9fbmFtZShnZXRIb3N0bmFtZSwgXCJnZXRIb3N0bmFtZVwiKTtcbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lKGhvc3QpIHtcbiAgICAgIGlmICghaG9zdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgaG9zdCwgXCJzdHJpbmdcIik7XG4gICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gZ2V0SG9zdG5hbWUoaG9zdCk7XG4gICAgICBpZiAobmV0Mi5pc0lQKHNlcnZlcm5hbWUpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcnZlcm5hbWU7XG4gICAgfVxuICAgIF9fbmFtZShnZXRTZXJ2ZXJOYW1lLCBcImdldFNlcnZlck5hbWVcIik7XG4gICAgZnVuY3Rpb24gZGVlcENsb25lMihvYmopIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbiAgICBfX25hbWUoZGVlcENsb25lMiwgXCJkZWVwQ2xvbmVcIik7XG4gICAgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBfX25hbWUoaXNBc3luY0l0ZXJhYmxlLCBcImlzQXN5bmNJdGVyYWJsZVwiKTtcbiAgICBmdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSk7XG4gICAgfVxuICAgIF9fbmFtZShpc0l0ZXJhYmxlLCBcImlzSXRlcmFibGVcIik7XG4gICAgZnVuY3Rpb24gYm9keUxlbmd0aChib2R5KSB7XG4gICAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGJvZHkuX3JlYWRhYmxlU3RhdGU7XG4gICAgICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhdGUubGVuZ3RoKSA/IHN0YXRlLmxlbmd0aCA6IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkuc2l6ZSAhPSBudWxsID8gYm9keS5zaXplIDogbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfX25hbWUoYm9keUxlbmd0aCwgXCJib2R5TGVuZ3RoXCIpO1xuICAgIGZ1bmN0aW9uIGlzRGVzdHJveWVkKHN0cmVhbTMpIHtcbiAgICAgIHJldHVybiAhc3RyZWFtMyB8fCAhIShzdHJlYW0zLmRlc3Ryb3llZCB8fCBzdHJlYW0zW2tEZXN0cm95ZWRdKTtcbiAgICB9XG4gICAgX19uYW1lKGlzRGVzdHJveWVkLCBcImlzRGVzdHJveWVkXCIpO1xuICAgIGZ1bmN0aW9uIGlzUmVhZGFibGVBYm9ydGVkKHN0cmVhbTMpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtMyAmJiBzdHJlYW0zLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgcmV0dXJuIGlzRGVzdHJveWVkKHN0cmVhbTMpICYmIHN0YXRlICYmICFzdGF0ZS5lbmRFbWl0dGVkO1xuICAgIH1cbiAgICBfX25hbWUoaXNSZWFkYWJsZUFib3J0ZWQsIFwiaXNSZWFkYWJsZUFib3J0ZWRcIik7XG4gICAgZnVuY3Rpb24gZGVzdHJveShzdHJlYW0zLCBlcnIpIHtcbiAgICAgIGlmICghaXNTdHJlYW0oc3RyZWFtMykgfHwgaXNEZXN0cm95ZWQoc3RyZWFtMykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0zLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0cmVhbTMpLmNvbnN0cnVjdG9yID09PSBJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgICBzdHJlYW0zLnNvY2tldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtMy5kZXN0cm95KGVycik7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKChzdHJlYW00LCBlcnIyKSA9PiB7XG4gICAgICAgICAgc3RyZWFtNC5lbWl0KFwiZXJyb3JcIiwgZXJyMik7XG4gICAgICAgIH0sIHN0cmVhbTMsIGVycik7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtMy5kZXN0cm95ZWQgIT09IHRydWUpIHtcbiAgICAgICAgc3RyZWFtM1trRGVzdHJveWVkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShkZXN0cm95LCBcImRlc3Ryb3lcIik7XG4gICAgdmFyIEtFRVBBTElWRV9USU1FT1VUX0VYUFIgPSAvdGltZW91dD0oXFxkKykvO1xuICAgIGZ1bmN0aW9uIHBhcnNlS2VlcEFsaXZlVGltZW91dCh2YWwpIHtcbiAgICAgIGNvbnN0IG0gPSB2YWwudG9TdHJpbmcoKS5tYXRjaChLRUVQQUxJVkVfVElNRU9VVF9FWFBSKTtcbiAgICAgIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMWUzIDogbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlS2VlcEFsaXZlVGltZW91dCwgXCJwYXJzZUtlZXBBbGl2ZVRpbWVvdXRcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMsIG9iaiA9IHt9KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyc1tpXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxldCB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzW2kgKyAxXSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbC5wdXNoKGhlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VIZWFkZXJzLCBcInBhcnNlSGVhZGVyc1wiKTtcbiAgICBmdW5jdGlvbiBwYXJzZVJhd0hlYWRlcnMoaGVhZGVycykge1xuICAgICAgcmV0dXJuIGhlYWRlcnMubWFwKChoZWFkZXIpID0+IGhlYWRlci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlUmF3SGVhZGVycywgXCJwYXJzZVJhd0hlYWRlcnNcIik7XG4gICAgZnVuY3Rpb24gaXNCdWZmZXIoYnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKTtcbiAgICB9XG4gICAgX19uYW1lKGlzQnVmZmVyLCBcImlzQnVmZmVyXCIpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSGFuZGxlcihoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgICAgIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25Db25uZWN0IG1ldGhvZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkVycm9yIG1ldGhvZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSBcImZ1bmN0aW9uXCIgJiYgaGFuZGxlci5vbkJvZHlTZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkJvZHlTZW50IG1ldGhvZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gXCJDT05ORUNUXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvblVwZ3JhZGUgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uSGVhZGVycyBtZXRob2RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkRhdGEgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9uQ29tcGxldGUgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh2YWxpZGF0ZUhhbmRsZXIsIFwidmFsaWRhdGVIYW5kbGVyXCIpO1xuICAgIGZ1bmN0aW9uIGlzRGlzdHVyYmVkKGJvZHkpIHtcbiAgICAgIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0yLmlzRGlzdHVyYmVkID8gc3RyZWFtMi5pc0Rpc3R1cmJlZChib2R5KSB8fCBib2R5W2tCb2R5VXNlZF0gOiBib2R5W2tCb2R5VXNlZF0gfHwgYm9keS5yZWFkYWJsZURpZFJlYWQgfHwgYm9keS5fcmVhZGFibGVTdGF0ZSAmJiBib2R5Ll9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkIHx8IGlzUmVhZGFibGVBYm9ydGVkKGJvZHkpKSk7XG4gICAgfVxuICAgIF9fbmFtZShpc0Rpc3R1cmJlZCwgXCJpc0Rpc3R1cmJlZFwiKTtcbiAgICBmdW5jdGlvbiBpc0Vycm9yZWQoYm9keSkge1xuICAgICAgcmV0dXJuICEhKGJvZHkgJiYgKHN0cmVhbTIuaXNFcnJvcmVkID8gc3RyZWFtMi5pc0Vycm9yZWQoYm9keSkgOiAvc3RhdGU6ICdlcnJvcmVkJy8udGVzdChcbiAgICAgICAgbm9kZVV0aWwuaW5zcGVjdChib2R5KVxuICAgICAgKSkpO1xuICAgIH1cbiAgICBfX25hbWUoaXNFcnJvcmVkLCBcImlzRXJyb3JlZFwiKTtcbiAgICBmdW5jdGlvbiBpc1JlYWRhYmxlKGJvZHkpIHtcbiAgICAgIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0yLmlzUmVhZGFibGUgPyBzdHJlYW0yLmlzUmVhZGFibGUoYm9keSkgOiAvc3RhdGU6ICdyZWFkYWJsZScvLnRlc3QoXG4gICAgICAgIG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKTtcbiAgICB9XG4gICAgX19uYW1lKGlzUmVhZGFibGUsIFwiaXNSZWFkYWJsZVwiKTtcbiAgICBmdW5jdGlvbiBnZXRTb2NrZXRJbmZvKHNvY2tldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBzb2NrZXQubG9jYWxBZGRyZXNzLFxuICAgICAgICBsb2NhbFBvcnQ6IHNvY2tldC5sb2NhbFBvcnQsXG4gICAgICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICByZW1vdGVQb3J0OiBzb2NrZXQucmVtb3RlUG9ydCxcbiAgICAgICAgcmVtb3RlRmFtaWx5OiBzb2NrZXQucmVtb3RlRmFtaWx5LFxuICAgICAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICAgICAgYnl0ZXNXcml0dGVuOiBzb2NrZXQuYnl0ZXNXcml0dGVuLFxuICAgICAgICBieXRlc1JlYWQ6IHNvY2tldC5ieXRlc1JlYWRcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShnZXRTb2NrZXRJbmZvLCBcImdldFNvY2tldEluZm9cIik7XG4gICAgdmFyIFJlYWRhYmxlU3RyZWFtO1xuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpLlJlYWRhYmxlU3RyZWFtO1xuICAgICAgfVxuICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtLmZyb20pIHtcbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtLmZyb20oaXRlcmFibGUpO1xuICAgICAgfVxuICAgICAgbGV0IGl0ZXJhdG9yO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICAgICAge1xuICAgICAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgX19uYW1lKFJlYWRhYmxlU3RyZWFtRnJvbSwgXCJSZWFkYWJsZVN0cmVhbUZyb21cIik7XG4gICAgZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UoY2h1bmspIHtcbiAgICAgIHJldHVybiBjaHVuayAmJiBjaHVuay5jb25zdHJ1Y3RvciAmJiBjaHVuay5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkZvcm1EYXRhXCI7XG4gICAgfVxuICAgIF9fbmFtZShpc0Zvcm1EYXRhTGlrZSwgXCJpc0Zvcm1EYXRhTGlrZVwiKTtcbiAgICB2YXIga0VudW1lcmFibGVQcm9wZXJ0eSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGtFbnVtZXJhYmxlUHJvcGVydHkuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIG5vcCxcbiAgICAgIGlzRGlzdHVyYmVkLFxuICAgICAgaXNFcnJvcmVkLFxuICAgICAgaXNSZWFkYWJsZSxcbiAgICAgIHRvVVNWU3RyaW5nOiBub2RlVXRpbC50b1VTVlN0cmluZyB8fCAoKHZhbCkgPT4gYCR7dmFsfWApLFxuICAgICAgaXNSZWFkYWJsZUFib3J0ZWQsXG4gICAgICBpc0Jsb2JMaWtlLFxuICAgICAgcGFyc2VPcmlnaW4sXG4gICAgICBwYXJzZVVSTCxcbiAgICAgIGdldFNlcnZlck5hbWUsXG4gICAgICBpc1N0cmVhbSxcbiAgICAgIGlzSXRlcmFibGUsXG4gICAgICBpc0FzeW5jSXRlcmFibGUsXG4gICAgICBpc0Rlc3Ryb3llZCxcbiAgICAgIHBhcnNlUmF3SGVhZGVycyxcbiAgICAgIHBhcnNlSGVhZGVycyxcbiAgICAgIHBhcnNlS2VlcEFsaXZlVGltZW91dCxcbiAgICAgIGRlc3Ryb3ksXG4gICAgICBib2R5TGVuZ3RoLFxuICAgICAgZGVlcENsb25lOiBkZWVwQ2xvbmUyLFxuICAgICAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICAgICAgaXNCdWZmZXIsXG4gICAgICB2YWxpZGF0ZUhhbmRsZXIsXG4gICAgICBnZXRTb2NrZXRJbmZvLFxuICAgICAgaXNGb3JtRGF0YUxpa2UsXG4gICAgICBidWlsZFVSTFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9jb25zdGFudHMuanNcbnZhciByZXF1aXJlX2NvbnN0YW50cyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2NvbnN0YW50cy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgY29yc1NhZmVMaXN0ZWRNZXRob2RzID0gW1wiR0VUXCIsIFwiSEVBRFwiLCBcIlBPU1RcIl07XG4gICAgdmFyIG51bGxCb2R5U3RhdHVzID0gWzEwMSwgMjA0LCAyMDUsIDMwNF07XG4gICAgdmFyIHJlZGlyZWN0U3RhdHVzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcbiAgICB2YXIgcmVmZXJyZXJQb2xpY3kgPSBbXG4gICAgICBcIlwiLFxuICAgICAgXCJuby1yZWZlcnJlclwiLFxuICAgICAgXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLFxuICAgICAgXCJzYW1lLW9yaWdpblwiLFxuICAgICAgXCJvcmlnaW5cIixcbiAgICAgIFwic3RyaWN0LW9yaWdpblwiLFxuICAgICAgXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcbiAgICAgIFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgICAgXCJ1bnNhZmUtdXJsXCJcbiAgICBdO1xuICAgIHZhciByZXF1ZXN0UmVkaXJlY3QgPSBbXCJmb2xsb3dcIiwgXCJtYW51YWxcIiwgXCJlcnJvclwiXTtcbiAgICB2YXIgc2FmZU1ldGhvZHMgPSBbXCJHRVRcIiwgXCJIRUFEXCIsIFwiT1BUSU9OU1wiLCBcIlRSQUNFXCJdO1xuICAgIHZhciByZXF1ZXN0TW9kZSA9IFtcIm5hdmlnYXRlXCIsIFwic2FtZS1vcmlnaW5cIiwgXCJuby1jb3JzXCIsIFwiY29yc1wiXTtcbiAgICB2YXIgcmVxdWVzdENyZWRlbnRpYWxzID0gW1wib21pdFwiLCBcInNhbWUtb3JpZ2luXCIsIFwiaW5jbHVkZVwiXTtcbiAgICB2YXIgcmVxdWVzdENhY2hlID0gW1xuICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICBcIm5vLXN0b3JlXCIsXG4gICAgICBcInJlbG9hZFwiLFxuICAgICAgXCJuby1jYWNoZVwiLFxuICAgICAgXCJmb3JjZS1jYWNoZVwiLFxuICAgICAgXCJvbmx5LWlmLWNhY2hlZFwiXG4gICAgXTtcbiAgICB2YXIgcmVxdWVzdEJvZHlIZWFkZXIgPSBbXG4gICAgICBcImNvbnRlbnQtZW5jb2RpbmdcIixcbiAgICAgIFwiY29udGVudC1sYW5ndWFnZVwiLFxuICAgICAgXCJjb250ZW50LWxvY2F0aW9uXCIsXG4gICAgICBcImNvbnRlbnQtdHlwZVwiXG4gICAgXTtcbiAgICB2YXIgZm9yYmlkZGVuTWV0aG9kcyA9IFtcIkNPTk5FQ1RcIiwgXCJUUkFDRVwiLCBcIlRSQUNLXCJdO1xuICAgIHZhciBzdWJyZXNvdXJjZSA9IFtcbiAgICAgIFwiYXVkaW9cIixcbiAgICAgIFwiYXVkaW93b3JrbGV0XCIsXG4gICAgICBcImZvbnRcIixcbiAgICAgIFwiaW1hZ2VcIixcbiAgICAgIFwibWFuaWZlc3RcIixcbiAgICAgIFwicGFpbnR3b3JrbGV0XCIsXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAgXCJzdHlsZVwiLFxuICAgICAgXCJ0cmFja1wiLFxuICAgICAgXCJ2aWRlb1wiLFxuICAgICAgXCJ4c2x0XCIsXG4gICAgICBcIlwiXG4gICAgXTtcbiAgICB2YXIgX2EzO1xuICAgIHZhciBET01FeGNlcHRpb24gPSAoX2EzID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pICE9IG51bGwgPyBfYTMgOiAoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXRvYihcIn5cIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLmNvbnN0cnVjdG9yO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgRE9NRXhjZXB0aW9uLFxuICAgICAgc3VicmVzb3VyY2UsXG4gICAgICBmb3JiaWRkZW5NZXRob2RzLFxuICAgICAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gICAgICByZWZlcnJlclBvbGljeSxcbiAgICAgIHJlcXVlc3RSZWRpcmVjdCxcbiAgICAgIHJlcXVlc3RNb2RlLFxuICAgICAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdENhY2hlLFxuICAgICAgcmVkaXJlY3RTdGF0dXMsXG4gICAgICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gICAgICBudWxsQm9keVN0YXR1cyxcbiAgICAgIHNhZmVNZXRob2RzXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3N5bWJvbHMuanNcbnZhciByZXF1aXJlX3N5bWJvbHMyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvc3ltYm9scy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBrVXJsOiBTeW1ib2woXCJ1cmxcIiksXG4gICAgICBrSGVhZGVyczogU3ltYm9sKFwiaGVhZGVyc1wiKSxcbiAgICAgIGtTaWduYWw6IFN5bWJvbChcInNpZ25hbFwiKSxcbiAgICAgIGtTdGF0ZTogU3ltYm9sKFwic3RhdGVcIiksXG4gICAgICBrR3VhcmQ6IFN5bWJvbChcImd1YXJkXCIpLFxuICAgICAga1JlYWxtOiBTeW1ib2woXCJyZWFsbVwiKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanNcbnZhciByZXF1aXJlX3dlYmlkbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3dlYmlkbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyB0eXBlcyB9ID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgdmFyIHsgaGFzT3duLCB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZV91dGlsMygpO1xuICAgIHZhciB3ZWJpZGwgPSB7fTtcbiAgICB3ZWJpZGwuY29udmVydGVycyA9IHt9O1xuICAgIHdlYmlkbC51dGlsID0ge307XG4gICAgd2ViaWRsLmVycm9ycyA9IHt9O1xuICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHttZXNzYWdlLmhlYWRlcn06ICR7bWVzc2FnZS5tZXNzYWdlfWApO1xuICAgIH07XG4gICAgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkID0gZnVuY3Rpb24oY29udGV4dDMpIHtcbiAgICAgIGNvbnN0IHBsdXJhbCA9IGNvbnRleHQzLnR5cGVzLmxlbmd0aCA9PT0gMSA/IFwiXCIgOiBcIiBvbmUgb2ZcIjtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtjb250ZXh0My5hcmd1bWVudH0gY291bGQgbm90IGJlIGNvbnZlcnRlZCB0byR7cGx1cmFsfTogJHtjb250ZXh0My50eXBlcy5qb2luKFwiLCBcIil9LmA7XG4gICAgICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IGNvbnRleHQzLnByZWZpeCxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCA9IGZ1bmN0aW9uKGNvbnRleHQzKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IGNvbnRleHQzLnByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYFwiJHtjb250ZXh0My52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dDMudHlwZX0uYFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB3ZWJpZGwudXRpbC5UeXBlID0gZnVuY3Rpb24oVikge1xuICAgICAgc3dpdGNoICh0eXBlb2YgVikge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIFwiVW5kZWZpbmVkXCI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiQm9vbGVhblwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaW5nXCI7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm4gXCJTeW1ib2xcIjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHJldHVybiBcIk51bWJlclwiO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgcmV0dXJuIFwiQmlnSW50XCI7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJPYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24oViwgYml0TGVuZ3RoLCBzaWduZWRuZXNzLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCB1cHBlckJvdW5kO1xuICAgICAgbGV0IGxvd2VyQm91bmQ7XG4gICAgICBpZiAoYml0TGVuZ3RoID09PSA2NCkge1xuICAgICAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgICAgICAgaWYgKHNpZ25lZG5lc3MgPT09IFwidW5zaWduZWRcIikge1xuICAgICAgICAgIGxvd2VyQm91bmQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgNTMpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaWduZWRuZXNzID09PSBcInVuc2lnbmVkXCIpIHtcbiAgICAgICAgbG93ZXJCb3VuZCA9IDA7XG4gICAgICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgYml0TGVuZ3RoKSAtIDE7XG4gICAgICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKSAtIDE7XG4gICAgICB9XG4gICAgICBsZXQgeCA9IE51bWJlcihWKTtcbiAgICAgIGlmIChPYmplY3QuaXMoLTAsIHgpKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogXCJJbnRlZ2VyIGNvbnZlcnNpb25cIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGFuIGludGVnZXIuYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHggPSB3ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCh4KTtcbiAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIkludGVnZXIgY29udmVyc2lvblwiLFxuICAgICAgICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgYmV0d2VlbiAke2xvd2VyQm91bmR9LSR7dXBwZXJCb3VuZH0sIGdvdCAke3h9LmBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdHMuY2xhbXAgPT09IHRydWUpIHtcbiAgICAgICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IE1hdGguY2VpbCh4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkgfHwgT2JqZWN0LmlzKDAsIHgpIHx8IHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeCk7XG4gICAgICB4ID0geCAlIE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gICAgICBpZiAoc2lnbmVkbmVzcyA9PT0gXCJzaWduZWRcIiAmJiB4ID49IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxKSB7XG4gICAgICAgIHJldHVybiB4IC0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQgPSBmdW5jdGlvbihuKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC0xICogcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyID0gZnVuY3Rpb24oY29udmVydGVyKSB7XG4gICAgICByZXR1cm4gKFYpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IFwiU2VxdWVuY2VcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBvZiB0eXBlICR7d2ViaWRsLnV0aWwuVHlwZShWKX0gaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9hMyA9IFYgPT0gbnVsbCA/IHZvaWQgMCA6IFZbU3ltYm9sLml0ZXJhdG9yXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKFYpO1xuICAgICAgICBjb25zdCBzZXEgPSBbXTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXRob2QubmV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlNlcXVlbmNlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk9iamVjdCBpcyBub3QgYW4gaXRlcmF0b3IuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IG1ldGhvZC5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXEucHVzaChjb252ZXJ0ZXIodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIgPSBmdW5jdGlvbihrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gICAgICByZXR1cm4gKFYpID0+IHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0ge307XG4gICAgICAgIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKFYpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJVbmRlZmluZWRcIiB8fCB0eXBlID09PSBcIk51bGxcIikge1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IFwiUmVjb3JkXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtWfSB0byBiZSBhbiBPYmplY3QgdHlwZS5gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFYpKSB7XG4gICAgICAgICAga2V5ID0ga2V5Q29udmVydGVyKGtleSk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZUNvbnZlcnRlcih2YWx1ZSk7XG4gICAgICAgICAgcmVjb3JkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKFYsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3QgIT09IGZhbHNlICYmICEoViBpbnN0YW5jZW9mIGkpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBpLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtWfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke2kubmFtZX0uYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyID0gZnVuY3Rpb24oY29udmVydGVycykge1xuICAgICAgcmV0dXJuIChkaWN0aW9uYXJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpO1xuICAgICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICAgIGlmICh0eXBlICE9PSBcIk51bGxcIiAmJiB0eXBlICE9PSBcIlVuZGVmaW5lZFwiICYmIHR5cGUgIT09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7ZGljdGlvbmFyeX0gdG8gYmUgb25lIG9mOiBOdWxsLCBVbmRlZmluZWQsIE9iamVjdC5gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgZGVmYXVsdFZhbHVlLCByZXF1aXJlZCwgY29udmVydGVyIH0gPSBvcHRpb25zO1xuICAgICAgICAgIGlmIChyZXF1aXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24oZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBcIkRpY3Rpb25hcnlcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBrZXkgXCIke2tleX1cIi5gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSBkaWN0aW9uYXJ5W2tleV07XG4gICAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHRpb25zLCBcImRlZmF1bHRWYWx1ZVwiKTtcbiAgICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXF1aXJlZCB8fCBoYXNEZWZhdWx0IHx8IHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiYgIW9wdGlvbnMuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICAgIGhlYWRlcjogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7dmFsdWV9IGlzIG5vdCBhbiBhY2NlcHRlZCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgJHtvcHRpb25zLmFsbG93ZWRWYWx1ZXMuam9pbihcIiwgXCIpfS5gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGljdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgICAgfTtcbiAgICB9O1xuICAgIHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uKGNvbnZlcnRlcikge1xuICAgICAgcmV0dXJuIChWKSA9PiB7XG4gICAgICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlcihWKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcgPSBmdW5jdGlvbihWLCBvcHRzID0ge30pIHtcbiAgICAgIGlmIChWID09PSBudWxsICYmIG9wdHMubGVnYWN5TnVsbFRvRW1wdHlTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIFYgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgc3ltYm9sIHRvIHN0cmluZy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nKFYpO1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGNvbnN0IHggPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoVik7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgeC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSB4LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IHRvIGEgQnl0ZVN0cmluZyBiZWNhdXNlIHRoZSBjaGFyYWN0ZXIgYXRpbmRleCAke2luZGV4fSBoYXMgYSB2YWx1ZSBvZiAke2NoYXJDb2RlfSB3aGljaCBpcyBncmVhdGVyIHRoYW4gMjU1LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyA9IHRvVVNWU3RyaW5nO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4gPSBmdW5jdGlvbihWKSB7XG4gICAgICBjb25zdCB4ID0gQm9vbGVhbihWKTtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuYW55ID0gZnVuY3Rpb24oVikge1xuICAgICAgcmV0dXJuIFY7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVyc1tcImxvbmcgbG9uZ1wiXSA9IGZ1bmN0aW9uKFYsIG9wdHMpIHtcbiAgICAgIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsIFwic2lnbmVkXCIsIG9wdHMpO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVyc1tcInVuc2lnbmVkIHNob3J0XCJdID0gZnVuY3Rpb24oVikge1xuICAgICAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAxNiwgXCJ1bnNpZ25lZFwiKTtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihWLCBvcHRzID0ge30pIHtcbiAgICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBcIk9iamVjdFwiIHx8ICF0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgICAgIHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgICAgcHJlZml4OiBgJHtWfWAsXG4gICAgICAgICAgYXJndW1lbnQ6IGAke1Z9YCxcbiAgICAgICAgICB0eXBlczogW1wiQXJyYXlCdWZmZXJcIl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBcIkFycmF5QnVmZmVyXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBWO1xuICAgIH07XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheSA9IGZ1bmN0aW9uKFYsIFQsIG9wdHMgPSB7fSkge1xuICAgICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09IFwiT2JqZWN0XCIgfHwgIXR5cGVzLmlzVHlwZWRBcnJheShWKSB8fCBWLmNvbnN0cnVjdG9yLm5hbWUgIT09IFQubmFtZSkge1xuICAgICAgICB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICAgIHByZWZpeDogYCR7VC5uYW1lfWAsXG4gICAgICAgICAgYXJndW1lbnQ6IGAke1Z9YCxcbiAgICAgICAgICB0eXBlczogW1QubmFtZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogXCJBcnJheUJ1ZmZlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVjtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3ID0gZnVuY3Rpb24oViwgb3B0cyA9IHt9KSB7XG4gICAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gXCJPYmplY3RcIiB8fCAhdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBcIkRhdGFWaWV3XCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJPYmplY3QgaXMgbm90IGEgRGF0YVZpZXcuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogXCJBcnJheUJ1ZmZlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVjtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uKFYsIG9wdHMgPSB7fSkge1xuICAgICAgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIG9wdHMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzLmlzVHlwZWRBcnJheShWKSkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheShWLCBWLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyhWLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENvdWxkIG5vdCBjb252ZXJ0ICR7Vn0gdG8gYSBCdWZmZXJTb3VyY2UuYCk7XG4gICAgfTtcbiAgICB3ZWJpZGwuY29udmVydGVyc1tcInNlcXVlbmNlPEJ5dGVTdHJpbmc+XCJdID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cIl0gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVyc1tcInNlcXVlbmNlPEJ5dGVTdHJpbmc+XCJdXG4gICAgKTtcbiAgICB3ZWJpZGwuY29udmVydGVyc1tcInJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlwiXSA9IHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICAgICk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgd2ViaWRsXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2ZpbGUuanNcbnZhciByZXF1aXJlX2ZpbGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IEJsb2IgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgdmFyIHsgdHlwZXMgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciB7IGtTdGF0ZSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IGlzQmxvYkxpa2UgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIgeyB3ZWJpZGwgfSA9IHJlcXVpcmVfd2ViaWRsKCk7XG4gICAgdmFyIEZpbGUgPSBjbGFzcyBleHRlbmRzIEJsb2Ige1xuICAgICAgY29uc3RydWN0b3IoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIjIgYXJndW1lbnRzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVCaXRzID0gd2ViaWRsLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCbG9iUGFydD5cIl0oZmlsZUJpdHMpO1xuICAgICAgICBmaWxlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlTmFtZSk7XG4gICAgICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5GaWxlUHJvcGVydHlCYWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG4gPSBmaWxlTmFtZTtcbiAgICAgICAgY29uc3QgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkO1xuICAgICAgICBzdXBlcihwcm9jZXNzQmxvYlBhcnRzKGZpbGVCaXRzLCBvcHRpb25zKSwgeyB0eXBlOiBvcHRpb25zLnR5cGUgfSk7XG4gICAgICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgIGxhc3RNb2RpZmllZDogZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5uYW1lO1xuICAgICAgfVxuICAgICAgZ2V0IGxhc3RNb2RpZmllZCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZDtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShGaWxlLCBcIkZpbGVcIik7XG4gICAgdmFyIEZpbGVMaWtlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYmxvYkxpa2UsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgY29uc3QgbiA9IGZpbGVOYW1lO1xuICAgICAgICBjb25zdCB0ID0gb3B0aW9ucy50eXBlO1xuICAgICAgICBjb25zdCBkID0gKF9hMyA9IG9wdGlvbnMubGFzdE1vZGlmaWVkKSAhPSBudWxsID8gX2EzIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgICAgIGJsb2JMaWtlLFxuICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgdHlwZTogdCxcbiAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlTGlrZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc3RyZWFtKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgYXJyYXlCdWZmZXIoLi4uYXJncykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLmFycmF5QnVmZmVyKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgc2xpY2UoLi4uYXJncykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNsaWNlKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgdGV4dCguLi5hcmdzKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlTGlrZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudGV4dCguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlsZUxpa2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNpemU7XG4gICAgICB9XG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpbGVMaWtlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS50eXBlO1xuICAgICAgfVxuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlTGlrZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZTtcbiAgICAgIH1cbiAgICAgIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaWxlTGlrZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGFzdE1vZGlmaWVkO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJGaWxlXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoRmlsZUxpa2UsIFwiRmlsZUxpa2VcIik7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuQmxvYiA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoQmxvYik7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuQmxvYlBhcnQgPSBmdW5jdGlvbihWLCBvcHRzKSB7XG4gICAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYsIG9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8QmxvYlBhcnQ+XCJdID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnMuQmxvYlBhcnRcbiAgICApO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkZpbGVQcm9wZXJ0eUJhZyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImxhc3RNb2RpZmllZFwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzW1wibG9uZyBsb25nXCJdLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwidHlwZVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiZW5kaW5nc1wiLFxuICAgICAgICBjb252ZXJ0ZXI6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBcIm5hdGl2ZVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfVxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NCbG9iUGFydHMocGFydHMsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgcGFydHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbGV0IHMgPSBlbGVtZW50O1xuICAgICAgICAgIGlmIChvcHRpb25zLmVuZGluZ3MgPT09IFwibmF0aXZlXCIpIHtcbiAgICAgICAgICAgIHMgPSBjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUocyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ5dGVzLnB1c2gobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKGVsZW1lbnQpIHx8IHR5cGVzLmlzVHlwZWRBcnJheShlbGVtZW50KSkge1xuICAgICAgICAgIGlmICghZWxlbWVudC5idWZmZXIpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZWxlbWVudCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlciwgZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgYnl0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBfX25hbWUocHJvY2Vzc0Jsb2JQYXJ0cywgXCJwcm9jZXNzQmxvYlBhcnRzXCIpO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZShzKSB7XG4gICAgICBsZXQgbmF0aXZlTGluZUVuZGluZyA9IFwiXFxuXCI7XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIG5hdGl2ZUxpbmVFbmRpbmcgPSBcIlxcclxcblwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxyP1xcbi9nLCBuYXRpdmVMaW5lRW5kaW5nKTtcbiAgICB9XG4gICAgX19uYW1lKGNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZSwgXCJjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0geyBGaWxlLCBGaWxlTGlrZSB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qc1xudmFyIHJlcXVpcmVfdXRpbDMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC91dGlsLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IHJlZGlyZWN0U3RhdHVzIH0gPSByZXF1aXJlX2NvbnN0YW50cygpO1xuICAgIHZhciB7IHBlcmZvcm1hbmNlOiBwZXJmb3JtYW5jZTMgfSA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpO1xuICAgIHZhciB7IGlzQmxvYkxpa2UsIHRvVVNWU3RyaW5nLCBSZWFkYWJsZVN0cmVhbUZyb20gfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgeyBpc1VpbnQ4QXJyYXkgfSA9IHJlcXVpcmUoXCJ1dGlsL3R5cGVzXCIpO1xuICAgIHZhciBGaWxlO1xuICAgIHZhciBjcnlwdG8yO1xuICAgIHRyeSB7XG4gICAgICBjcnlwdG8yID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHZhciBiYWRQb3J0cyA9IFtcbiAgICAgIFwiMVwiLFxuICAgICAgXCI3XCIsXG4gICAgICBcIjlcIixcbiAgICAgIFwiMTFcIixcbiAgICAgIFwiMTNcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMTdcIixcbiAgICAgIFwiMTlcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjFcIixcbiAgICAgIFwiMjJcIixcbiAgICAgIFwiMjNcIixcbiAgICAgIFwiMjVcIixcbiAgICAgIFwiMzdcIixcbiAgICAgIFwiNDJcIixcbiAgICAgIFwiNDNcIixcbiAgICAgIFwiNTNcIixcbiAgICAgIFwiNjlcIixcbiAgICAgIFwiNzdcIixcbiAgICAgIFwiNzlcIixcbiAgICAgIFwiODdcIixcbiAgICAgIFwiOTVcIixcbiAgICAgIFwiMTAxXCIsXG4gICAgICBcIjEwMlwiLFxuICAgICAgXCIxMDNcIixcbiAgICAgIFwiMTA0XCIsXG4gICAgICBcIjEwOVwiLFxuICAgICAgXCIxMTBcIixcbiAgICAgIFwiMTExXCIsXG4gICAgICBcIjExM1wiLFxuICAgICAgXCIxMTVcIixcbiAgICAgIFwiMTE3XCIsXG4gICAgICBcIjExOVwiLFxuICAgICAgXCIxMjNcIixcbiAgICAgIFwiMTM1XCIsXG4gICAgICBcIjEzN1wiLFxuICAgICAgXCIxMzlcIixcbiAgICAgIFwiMTQzXCIsXG4gICAgICBcIjE2MVwiLFxuICAgICAgXCIxNzlcIixcbiAgICAgIFwiMzg5XCIsXG4gICAgICBcIjQyN1wiLFxuICAgICAgXCI0NjVcIixcbiAgICAgIFwiNTEyXCIsXG4gICAgICBcIjUxM1wiLFxuICAgICAgXCI1MTRcIixcbiAgICAgIFwiNTE1XCIsXG4gICAgICBcIjUyNlwiLFxuICAgICAgXCI1MzBcIixcbiAgICAgIFwiNTMxXCIsXG4gICAgICBcIjUzMlwiLFxuICAgICAgXCI1NDBcIixcbiAgICAgIFwiNTQ4XCIsXG4gICAgICBcIjU1NFwiLFxuICAgICAgXCI1NTZcIixcbiAgICAgIFwiNTYzXCIsXG4gICAgICBcIjU4N1wiLFxuICAgICAgXCI2MDFcIixcbiAgICAgIFwiNjM2XCIsXG4gICAgICBcIjk4OVwiLFxuICAgICAgXCI5OTBcIixcbiAgICAgIFwiOTkzXCIsXG4gICAgICBcIjk5NVwiLFxuICAgICAgXCIxNzE5XCIsXG4gICAgICBcIjE3MjBcIixcbiAgICAgIFwiMTcyM1wiLFxuICAgICAgXCIyMDQ5XCIsXG4gICAgICBcIjM2NTlcIixcbiAgICAgIFwiNDA0NVwiLFxuICAgICAgXCI1MDYwXCIsXG4gICAgICBcIjUwNjFcIixcbiAgICAgIFwiNjAwMFwiLFxuICAgICAgXCI2NTY2XCIsXG4gICAgICBcIjY2NjVcIixcbiAgICAgIFwiNjY2NlwiLFxuICAgICAgXCI2NjY3XCIsXG4gICAgICBcIjY2NjhcIixcbiAgICAgIFwiNjY2OVwiLFxuICAgICAgXCI2Njk3XCIsXG4gICAgICBcIjEwMDgwXCJcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmxMaXN0ID0gcmVzcG9uc2UudXJsTGlzdDtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHVybExpc3QubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9fbmFtZShyZXNwb25zZVVSTCwgXCJyZXNwb25zZVVSTFwiKTtcbiAgICBmdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMKHJlc3BvbnNlLCByZXF1ZXN0RnJhZ21lbnQpIHtcbiAgICAgIGlmICghcmVkaXJlY3RTdGF0dXMuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldChcImxvY2F0aW9uXCIpO1xuICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbiA/IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSkgOiBudWxsO1xuICAgICAgaWYgKGxvY2F0aW9uICYmICFsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuICAgIF9fbmFtZShyZXNwb25zZUxvY2F0aW9uVVJMLCBcInJlc3BvbnNlTG9jYXRpb25VUkxcIik7XG4gICAgZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0Mi51cmxMaXN0W3JlcXVlc3QyLnVybExpc3QubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIF9fbmFtZShyZXF1ZXN0Q3VycmVudFVSTCwgXCJyZXF1ZXN0Q3VycmVudFVSTFwiKTtcbiAgICBmdW5jdGlvbiByZXF1ZXN0QmFkUG9ydChyZXF1ZXN0Mikge1xuICAgICAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgaWYgKC9eaHR0cHM/Oi8udGVzdCh1cmwucHJvdG9jb2wpICYmIGJhZFBvcnRzLmluY2x1ZGVzKHVybC5wb3J0KSkge1xuICAgICAgICByZXR1cm4gXCJibG9ja2VkXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJhbGxvd2VkXCI7XG4gICAgfVxuICAgIF9fbmFtZShyZXF1ZXN0QmFkUG9ydCwgXCJyZXF1ZXN0QmFkUG9ydFwiKTtcbiAgICBmdW5jdGlvbiBpc0ZpbGVMaWtlKG9iamVjdCkge1xuICAgICAgaWYgKCFGaWxlKSB7XG4gICAgICAgIEZpbGUgPSByZXF1aXJlX2ZpbGUoKS5GaWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEZpbGUgfHwgb2JqZWN0ICYmICh0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIikgJiYgL14oRmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgICB9XG4gICAgX19uYW1lKGlzRmlsZUxpa2UsIFwiaXNGaWxlTGlrZVwiKTtcbiAgICBmdW5jdGlvbiBpc0Vycm9yTGlrZShvYmplY3QpIHtcbiAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoKChfYTMgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdC5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5uYW1lKSA9PT0gXCJFcnJvclwiIHx8ICgoX2IyID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIubmFtZSkgPT09IFwiRE9NRXhjZXB0aW9uXCIpO1xuICAgIH1cbiAgICBfX25hbWUoaXNFcnJvckxpa2UsIFwiaXNFcnJvckxpa2VcIik7XG4gICAgZnVuY3Rpb24gaXNWYWxpZFJlYXNvblBocmFzZShzdGF0dXNUZXh0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXR1c1RleHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKCEoYyA9PT0gOSB8fCBjID49IDMyICYmIGMgPD0gMTI2IHx8IGMgPj0gMTI4ICYmIGMgPD0gMjU1KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9fbmFtZShpc1ZhbGlkUmVhc29uUGhyYXNlLCBcImlzVmFsaWRSZWFzb25QaHJhc2VcIik7XG4gICAgZnVuY3Rpb24gaXNUb2tlbkNoYXIoYykge1xuICAgICAgcmV0dXJuICEoYyA+PSAxMjcgfHwgYyA8PSAzMiB8fCBjID09PSBcIihcIiB8fCBjID09PSBcIilcIiB8fCBjID09PSBcIjxcIiB8fCBjID09PSBcIj5cIiB8fCBjID09PSBcIkBcIiB8fCBjID09PSBcIixcIiB8fCBjID09PSBcIjtcIiB8fCBjID09PSBcIjpcIiB8fCBjID09PSBcIlxcXFxcIiB8fCBjID09PSAnXCInIHx8IGMgPT09IFwiL1wiIHx8IGMgPT09IFwiW1wiIHx8IGMgPT09IFwiXVwiIHx8IGMgPT09IFwiP1wiIHx8IGMgPT09IFwiPVwiIHx8IGMgPT09IFwie1wiIHx8IGMgPT09IFwifVwiKTtcbiAgICB9XG4gICAgX19uYW1lKGlzVG9rZW5DaGFyLCBcImlzVG9rZW5DaGFyXCIpO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRIVFRQVG9rZW4oY2hhcmFjdGVycykge1xuICAgICAgaWYgKCFjaGFyYWN0ZXJzIHx8IHR5cGVvZiBjaGFyYWN0ZXJzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcmFjdGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjID0gY2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA+IDEyNyB8fCAhaXNUb2tlbkNoYXIoYykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoaXNWYWxpZEhUVFBUb2tlbiwgXCJpc1ZhbGlkSFRUUFRva2VuXCIpO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJOYW1lKHBvdGVudGlhbFZhbHVlKSB7XG4gICAgICBpZiAocG90ZW50aWFsVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hhciBvZiBwb3RlbnRpYWxWYWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4oY2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoaXNWYWxpZEhlYWRlck5hbWUsIFwiaXNWYWxpZEhlYWRlck5hbWVcIik7XG4gICAgZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlKHBvdGVudGlhbFZhbHVlKSB7XG4gICAgICBpZiAocG90ZW50aWFsVmFsdWUuc3RhcnRzV2l0aChcIlx0XCIpIHx8IHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoXCIgXCIpIHx8IHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKFwiXHRcIikgfHwgcG90ZW50aWFsVmFsdWUuZW5kc1dpdGgoXCIgXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcyhcIlxcMFwiKSB8fCBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcyhcIlxcclwiKSB8fCBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKGlzVmFsaWRIZWFkZXJWYWx1ZSwgXCJpc1ZhbGlkSGVhZGVyVmFsdWVcIik7XG4gICAgZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0MiwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHBvbGljeSA9IFwiXCI7XG4gICAgICBpZiAocG9saWN5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJlcXVlc3QyLnJlZmVycmVyUG9saWN5ID0gcG9saWN5O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCwgXCJzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0XCIpO1xuICAgIGZ1bmN0aW9uIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjaygpIHtcbiAgICAgIHJldHVybiBcImFsbG93ZWRcIjtcbiAgICB9XG4gICAgX19uYW1lKGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjaywgXCJjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2tcIik7XG4gICAgZnVuY3Rpb24gY29yc0NoZWNrKCkge1xuICAgICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xuICAgIH1cbiAgICBfX25hbWUoY29yc0NoZWNrLCBcImNvcnNDaGVja1wiKTtcbiAgICBmdW5jdGlvbiBUQU9DaGVjaygpIHtcbiAgICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbiAgICB9XG4gICAgX19uYW1lKFRBT0NoZWNrLCBcIlRBT0NoZWNrXCIpO1xuICAgIGZ1bmN0aW9uIGFwcGVuZEZldGNoTWV0YWRhdGEoaHR0cFJlcXVlc3QpIHtcbiAgICAgIGxldCBoZWFkZXIgPSBudWxsO1xuICAgICAgaGVhZGVyID0gaHR0cFJlcXVlc3QubW9kZTtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LnNldChcInNlYy1mZXRjaC1tb2RlXCIsIGhlYWRlcik7XG4gICAgfVxuICAgIF9fbmFtZShhcHBlbmRGZXRjaE1ldGFkYXRhLCBcImFwcGVuZEZldGNoTWV0YWRhdGFcIik7XG4gICAgZnVuY3Rpb24gYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihyZXF1ZXN0Mikge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRPcmlnaW4gPSByZXF1ZXN0Mi5vcmlnaW47XG4gICAgICBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJjb3JzXCIgfHwgcmVxdWVzdDIubW9kZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICBpZiAoc2VyaWFsaXplZE9yaWdpbikge1xuICAgICAgICAgIHJlcXVlc3QyLmhlYWRlcnNMaXN0LmFwcGVuZChcIk9yaWdpblwiLCBzZXJpYWxpemVkT3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5tZXRob2QgIT09IFwiR0VUXCIgJiYgcmVxdWVzdDIubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICBzd2l0Y2ggKHJlcXVlc3QyLnJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgICAgY2FzZSBcIm5vLXJlZmVycmVyXCI6XG4gICAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpY3Qtb3JpZ2luXCI6XG4gICAgICAgICAgY2FzZSBcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIjpcbiAgICAgICAgICAgIGlmICgvXmh0dHBzOi8udGVzdChyZXF1ZXN0Mi5vcmlnaW4pICYmICEvXmh0dHBzOi8udGVzdChyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0MikpKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNhbWUtb3JpZ2luXCI6XG4gICAgICAgICAgICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdDIsIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKSkpIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJpYWxpemVkT3JpZ2luKSB7XG4gICAgICAgICAgcmVxdWVzdDIuaGVhZGVyc0xpc3QuYXBwZW5kKFwiT3JpZ2luXCIsIHNlcmlhbGl6ZWRPcmlnaW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLCBcImFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXJcIik7XG4gICAgZnVuY3Rpb24gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZTMubm93KCk7XG4gICAgfVxuICAgIF9fbmFtZShjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSwgXCJjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZVwiKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHRpbWluZ0luZm8pIHtcbiAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogKF9hMyA9IHRpbWluZ0luZm8uc3RhcnRUaW1lKSAhPSBudWxsID8gX2EzIDogMCxcbiAgICAgICAgcmVkaXJlY3RTdGFydFRpbWU6IDAsXG4gICAgICAgIHJlZGlyZWN0RW5kVGltZTogMCxcbiAgICAgICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiAoX2IyID0gdGltaW5nSW5mby5zdGFydFRpbWUpICE9IG51bGwgPyBfYjIgOiAwLFxuICAgICAgICBmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6IDAsXG4gICAgICAgIGZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lOiAwLFxuICAgICAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgICAgICBlbmRUaW1lOiAwLFxuICAgICAgICBlbmNvZGVkQm9keVNpemU6IDAsXG4gICAgICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICAgICAgZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sIFwiY3JlYXRlT3BhcXVlVGltaW5nSW5mb1wiKTtcbiAgICBmdW5jdGlvbiBtYWtlUG9saWN5Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfX25hbWUobWFrZVBvbGljeUNvbnRhaW5lciwgXCJtYWtlUG9saWN5Q29udGFpbmVyXCIpO1xuICAgIGZ1bmN0aW9uIGNsb25lUG9saWN5Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfX25hbWUoY2xvbmVQb2xpY3lDb250YWluZXIsIFwiY2xvbmVQb2xpY3lDb250YWluZXJcIik7XG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0Mikge1xuICAgICAgcmV0dXJuIFwibm8tcmVmZXJyZXJcIjtcbiAgICB9XG4gICAgX19uYW1lKGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsIFwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlclwiKTtcbiAgICBmdW5jdGlvbiBieXRlc01hdGNoKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgICAgIGlmIChjcnlwdG8yID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRNZXRhZGF0YSA9IHBhcnNlTWV0YWRhdGEobWV0YWRhdGFMaXN0KTtcbiAgICAgIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gXCJubyBtZXRhZGF0YVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gcGFyc2VkTWV0YWRhdGEuc29ydCgoYywgZCkgPT4gZC5hbGdvLmxvY2FsZUNvbXBhcmUoYy5hbGdvKSk7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvO1xuICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gaXRlbS5oYXNoO1xuICAgICAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGNyeXB0bzIuY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShieXRlcykuZGlnZXN0KFwiYmFzZTY0XCIpO1xuICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPT09IGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfX25hbWUoYnl0ZXNNYXRjaCwgXCJieXRlc01hdGNoXCIpO1xuICAgIHZhciBwYXJzZUhhc2hXaXRoT3B0aW9ucyA9IC8oKD88YWxnbz5zaGEyNTZ8c2hhMzg0fHNoYTUxMiktKD88aGFzaD5bQS16MC05Ky9dezF9Lio9ezEsMn0pKSggK1tcXHgyMS1cXHg3ZV0/KT8vaTtcbiAgICBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGxldCBlbXB0eTIgPSB0cnVlO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkSGFzaGVzID0gY3J5cHRvMi5nZXRIYXNoZXMoKTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbWV0YWRhdGEuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGVtcHR5MiA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXJzZWRUb2tlbiA9IHBhcnNlSGFzaFdpdGhPcHRpb25zLmV4ZWModG9rZW4pO1xuICAgICAgICBpZiAocGFyc2VkVG9rZW4gPT09IG51bGwgfHwgcGFyc2VkVG9rZW4uZ3JvdXBzID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnbztcbiAgICAgICAgaWYgKHN1cHBvcnRlZEhhc2hlcy5pbmNsdWRlcyhhbGdvcml0aG0udG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJzZWRUb2tlbi5ncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW1wdHkyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBcIm5vIG1ldGFkYXRhXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VNZXRhZGF0YSwgXCJwYXJzZU1ldGFkYXRhXCIpO1xuICAgIGZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTChyZXF1ZXN0Mikge1xuICAgIH1cbiAgICBfX25hbWUodHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLCBcInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTFwiKTtcbiAgICBmdW5jdGlvbiBzYW1lT3JpZ2luKEEsIEIpIHtcbiAgICAgIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShzYW1lT3JpZ2luLCBcInNhbWVPcmlnaW5cIik7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCkge1xuICAgICAgbGV0IHJlcztcbiAgICAgIGxldCByZWo7XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXMgPSByZXNvbHZlO1xuICAgICAgICByZWogPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfTtcbiAgICB9XG4gICAgX19uYW1lKGNyZWF0ZURlZmVycmVkUHJvbWlzZSwgXCJjcmVhdGVEZWZlcnJlZFByb21pc2VcIik7XG4gICAgZnVuY3Rpb24gaXNBYm9ydGVkKGZldGNoUGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIF9fbmFtZShpc0Fib3J0ZWQsIFwiaXNBYm9ydGVkXCIpO1xuICAgIGZ1bmN0aW9uIGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gXCJhYm9ydGVkXCIgfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gXCJ0ZXJtaW5hdGVkXCI7XG4gICAgfVxuICAgIF9fbmFtZShpc0NhbmNlbGxlZCwgXCJpc0NhbmNlbGxlZFwiKTtcbiAgICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgICByZXR1cm4gL14oREVMRVRFfEdFVHxIRUFEfE9QVElPTlN8UE9TVHxQVVQpJC9pLnRlc3QobWV0aG9kKSA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogbWV0aG9kO1xuICAgIH1cbiAgICBfX25hbWUobm9ybWFsaXplTWV0aG9kLCBcIm5vcm1hbGl6ZU1ldGhvZFwiKTtcbiAgICBmdW5jdGlvbiBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcodmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlXCIpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX19uYW1lKHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZywgXCJzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmdcIik7XG4gICAgdmFyIGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpO1xuICAgIGZ1bmN0aW9uIG1ha2VJdGVyYXRvcihpdGVyYXRvciwgbmFtZSkge1xuICAgICAgY29uc3QgaSA9IHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgJ25leHQnIGNhbGxlZCBvbiBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlICR7bmFtZX0gSXRlcmF0b3IuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IGAke25hbWV9IEl0ZXJhdG9yYFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihpLCBlc0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yoe30sIGkpO1xuICAgIH1cbiAgICBfX25hbWUobWFrZUl0ZXJhdG9yLCBcIm1ha2VJdGVyYXRvclwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBmdWxseVJlYWRCb2R5KGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGJvZHkuc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQoaXNVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGxlbmd0aCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGZpbGxlZFN0ZXBzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoYnl0ZXMpID0+IHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICBwcm9jZXNzQm9keShieXRlcyk7XG4gICAgICAgIH0pLCBcImZ1bGZpbGxlZFN0ZXBzXCIpO1xuICAgICAgICBmdWxmaWxsZWRTdGVwcyhCdWZmZXIuY29uY2F0KGNodW5rcywgbGVuZ3RoKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc0JvZHlFcnJvcihlcnIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZ1bGx5UmVhZEJvZHksIFwiZnVsbHlSZWFkQm9keVwiKTtcbiAgICB2YXIgaGFzT3duID0gT2JqZWN0Lmhhc093biB8fCAoKGRpY3QsIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpY3QsIGtleSkpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGlzQWJvcnRlZCxcbiAgICAgIGlzQ2FuY2VsbGVkLFxuICAgICAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICAgICAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICAgICAgdG9VU1ZTdHJpbmcsXG4gICAgICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gICAgICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgICAgIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gICAgICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICAgICAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gICAgICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICAgICAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgICAgIFRBT0NoZWNrLFxuICAgICAgY29yc0NoZWNrLFxuICAgICAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICAgICAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgICAgIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gICAgICBpc1ZhbGlkSFRUUFRva2VuLFxuICAgICAgcmVxdWVzdEJhZFBvcnQsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgICAgIHJlc3BvbnNlVVJMLFxuICAgICAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgICAgIGlzQmxvYkxpa2UsXG4gICAgICBpc0ZpbGVMaWtlLFxuICAgICAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgICAgIHNhbWVPcmlnaW4sXG4gICAgICBub3JtYWxpemVNZXRob2QsXG4gICAgICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gICAgICBtYWtlSXRlcmF0b3IsXG4gICAgICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgICAgIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgICAgIGhhc093bixcbiAgICAgIGlzRXJyb3JMaWtlLFxuICAgICAgZnVsbHlSZWFkQm9keSxcbiAgICAgIGJ5dGVzTWF0Y2hcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZm9ybWRhdGEuanNcbnZhciByZXF1aXJlX2Zvcm1kYXRhID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZm9ybWRhdGEuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgaXNCbG9iTGlrZSwgaXNGaWxlTGlrZSwgdG9VU1ZTdHJpbmcsIG1ha2VJdGVyYXRvciB9ID0gcmVxdWlyZV91dGlsMygpO1xuICAgIHZhciB7IGtTdGF0ZSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IEZpbGUsIEZpbGVMaWtlIH0gPSByZXF1aXJlX2ZpbGUoKTtcbiAgICB2YXIgeyB3ZWJpZGwgfSA9IHJlcXVpcmVfd2ViaWRsKCk7XG4gICAgdmFyIHsgQmxvYiB9ID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbiAgICB2YXIgX0Zvcm1EYXRhID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoZm9ybSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgZm9ybSAhPSBudWxsKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgICAgIHByZWZpeDogXCJGb3JtRGF0YSBjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgYXJndW1lbnQ6IFwiQXJndW1lbnQgMVwiLFxuICAgICAgICAgICAgdHlwZXM6IFtcIm51bGxcIl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tTdGF0ZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZCcgb24gJ0Zvcm1EYXRhJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYidcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKSA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KSA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdkZWxldGUnIG9uICdGb3JtRGF0YSc6IDEgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKTtcbiAgICAgICAgY29uc3QgbmV4dCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXNba1N0YXRlXSkge1xuICAgICAgICAgIGlmIChlbnRyeS5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgICBuZXh0LnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tTdGF0ZV0gPSBuZXh0O1xuICAgICAgfVxuICAgICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldCcgb24gJ0Zvcm1EYXRhJzogMSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlO1xuICAgICAgfVxuICAgICAgZ2V0QWxsKG5hbWUpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9Gb3JtRGF0YSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldEFsbCcgb24gJ0Zvcm1EYXRhJzogMSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdoYXMnIG9uICdGb3JtRGF0YSc6IDEgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKSAhPT0gLTE7XG4gICAgICB9XG4gICAgICBzZXQobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdzZXQnIG9uICdGb3JtRGF0YSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSkgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpO1xuICAgICAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyB0b1VTVlN0cmluZyhmaWxlbmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5MikgPT4gZW50cnkyLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXNba1N0YXRlXSA9IFtcbiAgICAgICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZSgwLCBpZHgpLFxuICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoaWR4ICsgMSkuZmlsdGVyKChlbnRyeTIpID0+IGVudHJ5Mi5uYW1lICE9PSBuYW1lKVxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1trU3RhdGVdLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgICBlbnRyaWVzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICAgICBtYWtlSXRlcmFibGUodGhpc1trU3RhdGVdLCBcImVudHJpZXNcIiksXG4gICAgICAgICAgXCJGb3JtRGF0YVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBrZXlzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICAgICBtYWtlSXRlcmFibGUodGhpc1trU3RhdGVdLCBcImtleXNcIiksXG4gICAgICAgICAgXCJGb3JtRGF0YVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfRm9ybURhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgICAgIG1ha2VJdGVyYWJsZSh0aGlzW2tTdGF0ZV0sIFwidmFsdWVzXCIpLFxuICAgICAgICAgIFwiRm9ybURhdGFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX0Zvcm1EYXRhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZm9yRWFjaCcgb24gJ0Zvcm1EYXRhJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwga2V5LCB0aGlzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBGb3JtRGF0YSA9IF9Gb3JtRGF0YTtcbiAgICBfX25hbWUoRm9ybURhdGEsIFwiRm9ybURhdGFcIik7XG4gICAgX19wdWJsaWNGaWVsZChGb3JtRGF0YSwgXCJuYW1lXCIsIFwiRm9ybURhdGFcIik7XG4gICAgRm9ybURhdGEucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBGb3JtRGF0YS5wcm90b3R5cGUuZW50cmllcztcbiAgICBmdW5jdGlvbiBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKSB7XG4gICAgICBuYW1lID0gQnVmZmVyLmZyb20obmFtZSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWlzRmlsZUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgPyBuZXcgRmlsZShbdmFsdWVdLCBcImJsb2JcIiwgeyB0eXBlOiB2YWx1ZS50eXBlIH0pIDogbmV3IEZpbGVMaWtlKHZhbHVlLCBcImJsb2JcIiwgeyB0eXBlOiB2YWx1ZS50eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlbmFtZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEZpbGUgPyBuZXcgRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgeyB0eXBlOiB2YWx1ZS50eXBlIH0pIDogbmV3IEZpbGVMaWtlKHZhbHVlLCBmaWxlbmFtZSwgeyB0eXBlOiB2YWx1ZS50eXBlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBfX25hbWUobWFrZUVudHJ5LCBcIm1ha2VFbnRyeVwiKTtcbiAgICBmdW5jdGlvbiogbWFrZUl0ZXJhYmxlKGVudHJpZXMsIHR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZW50cmllc1wiKSB7XG4gICAgICAgICAgeWllbGQgW25hbWUsIHZhbHVlXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInZhbHVlc1wiKSB7XG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUobWFrZUl0ZXJhYmxlLCBcIm1ha2VJdGVyYWJsZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7IEZvcm1EYXRhIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9ib2R5LmpzXG52YXIgcmVxdWlyZV9ib2R5ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgUmVhZGFibGVTdHJlYW1Gcm9tLCB0b1VTVlN0cmluZywgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZV91dGlsMygpO1xuICAgIHZhciB7IEZvcm1EYXRhIH0gPSByZXF1aXJlX2Zvcm1kYXRhKCk7XG4gICAgdmFyIHsga1N0YXRlIH0gPSByZXF1aXJlX3N5bWJvbHMyKCk7XG4gICAgdmFyIHsgd2ViaWRsIH0gPSByZXF1aXJlX3dlYmlkbCgpO1xuICAgIHZhciB7IEJsb2IgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgdmFyIHsga0JvZHlVc2VkIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgeyBOb3RTdXBwb3J0ZWRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBpc0Vycm9yZWQgfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBpc1VpbnQ4QXJyYXksIGlzQXJyYXlCdWZmZXIgfSA9IHJlcXVpcmUoXCJ1dGlsL3R5cGVzXCIpO1xuICAgIHZhciBSZWFkYWJsZVN0cmVhbTtcbiAgICBhc3luYyBmdW5jdGlvbiogYmxvYkdlbihibG9iKSB7XG4gICAgICB5aWVsZCogYmxvYi5zdHJlYW0oKTtcbiAgICB9XG4gICAgX19uYW1lKGJsb2JHZW4sIFwiYmxvYkdlblwiKTtcbiAgICBmdW5jdGlvbiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZShcInN0cmVhbS93ZWJcIikuUmVhZGFibGVTdHJlYW07XG4gICAgICB9XG4gICAgICBsZXQgc3RyZWFtMiA9IG51bGw7XG4gICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xuICAgICAgbGV0IGxlbmd0aCA9IG51bGw7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICBzb3VyY2UgPSBvYmplY3QudG9TdHJpbmcoKTtcbiAgICAgICAgY29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04XCI7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3Quc2xpY2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7XG4gICAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KG9iamVjdC5idWZmZXIuc2xpY2Uob2JqZWN0LmJ5dGVPZmZzZXQsIG9iamVjdC5ieXRlT2Zmc2V0ICsgb2JqZWN0LmJ5dGVMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNGb3JtRGF0YUxpa2Uob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBib3VuZGFyeSA9IFwiLS0tLWZvcm1kYXRhLXVuZGljaS1cIiArIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGFgO1xuICAgICAgICBjb25zdCBlc2NhcGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdHIpID0+IHN0ci5yZXBsYWNlKC9cXG4vZywgXCIlMEFcIikucmVwbGFjZSgvXFxyL2csIFwiJTBEXCIpLnJlcGxhY2UoL1wiL2csIFwiJTIyXCIpLCBcImVzY2FwZVwiKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplTGluZWZlZWRzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiXFxyXFxuXCIpLCBcIm5vcm1hbGl6ZUxpbmVmZWVkc1wiKTtcbiAgICAgICAgYWN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbiogKG9iamVjdDIpIHtcbiAgICAgICAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2Ygb2JqZWN0Mikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB5aWVsZCBlbmMuZW5jb2RlKFxuICAgICAgICAgICAgICAgIHByZWZpeCArIGA7IG5hbWU9XCIke2VzY2FwZShub3JtYWxpemVMaW5lZmVlZHMobmFtZSkpfVwiXFxyXG5cXHJcbiR7bm9ybWFsaXplTGluZWZlZWRzKHZhbHVlKX1cXHJcbmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIGVuYy5lbmNvZGUoXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgYDsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICsgKHZhbHVlLm5hbWUgPyBgOyBmaWxlbmFtZT1cIiR7ZXNjYXBlKHZhbHVlLm5hbWUpfVwiYCA6IFwiXCIpICsgYFxcclxuQ29udGVudC1UeXBlOiAke3ZhbHVlLnR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn1cXHJcblxcclxuYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB5aWVsZCogYmxvYkdlbih2YWx1ZSk7XG4gICAgICAgICAgICAgIHlpZWxkIGVuYy5lbmNvZGUoXCJcXHJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIGVuYy5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLWApO1xuICAgICAgICB9LCBcImFjdGlvblwiKTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBjb250ZW50VHlwZSA9IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9XCIgKyBib3VuZGFyeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGFjdGlvbiA9IGJsb2JHZW47XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0LnNpemU7XG4gICAgICAgIGlmIChvYmplY3QudHlwZSkge1xuICAgICAgICAgIGNvbnRlbnRUeXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtlZXBhbGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbDIuaXNEaXN0dXJiZWQob2JqZWN0KSB8fCBvYmplY3QubG9ja2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiUmVzcG9uc2UgYm9keSBvYmplY3Qgc2hvdWxkIG5vdCBiZSBkaXN0dXJiZWQgb3IgbG9ja2VkXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbTIgPSBvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSA/IG9iamVjdCA6IFJlYWRhYmxlU3RyZWFtRnJvbShvYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlID0gdG9VU1ZTdHJpbmcob2JqZWN0KTtcbiAgICAgICAgY29udGVudFR5cGUgPSBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgfHwgdXRpbDIuaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGxldCBpdGVyYXRvcjtcbiAgICAgICAgc3RyZWFtMiA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IGFjdGlvbihvYmplY3QpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaXNFcnJvcmVkKHN0cmVhbTIpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJlYW0yKSB7XG4gICAgICAgIHN0cmVhbTIgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNvdXJjZSkgOiBzb3VyY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0geyBzdHJlYW06IHN0cmVhbTIsIHNvdXJjZSwgbGVuZ3RoIH07XG4gICAgICByZXR1cm4gW2JvZHksIGNvbnRlbnRUeXBlXTtcbiAgICB9XG4gICAgX19uYW1lKGV4dHJhY3RCb2R5LCBcImV4dHJhY3RCb2R5XCIpO1xuICAgIGZ1bmN0aW9uIHNhZmVseUV4dHJhY3RCb2R5KG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgICAgIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKS5SZWFkYWJsZVN0cmVhbTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICBhc3NlcnQoIXV0aWwyLmlzRGlzdHVyYmVkKG9iamVjdCksIFwiZGlzdHVyYmVkXCIpO1xuICAgICAgICBhc3NlcnQoIW9iamVjdC5sb2NrZWQsIFwibG9ja2VkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dHJhY3RCb2R5KG9iamVjdCwga2VlcGFsaXZlKTtcbiAgICB9XG4gICAgX19uYW1lKHNhZmVseUV4dHJhY3RCb2R5LCBcInNhZmVseUV4dHJhY3RCb2R5XCIpO1xuICAgIGZ1bmN0aW9uIGNsb25lQm9keShib2R5KSB7XG4gICAgICBjb25zdCBbb3V0MSwgb3V0Ml0gPSBib2R5LnN0cmVhbS50ZWUoKTtcbiAgICAgIGJvZHkuc3RyZWFtID0gb3V0MTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogb3V0MixcbiAgICAgICAgbGVuZ3RoOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgc291cmNlOiBib2R5LnNvdXJjZVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGNsb25lQm9keSwgXCJjbG9uZUJvZHlcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVCb2R5KGJvZHkpIHtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIGlmIChpc1VpbnQ4QXJyYXkoYm9keSkpIHtcbiAgICAgICAgICB5aWVsZCBib2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbTIgPSBib2R5LnN0cmVhbTtcbiAgICAgICAgICBpZiAodXRpbDIuaXNEaXN0dXJiZWQoc3RyZWFtMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkaXN0dXJiZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJlYW0yLmxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtMltrQm9keVVzZWRdID0gdHJ1ZTtcbiAgICAgICAgICB5aWVsZCogc3RyZWFtMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY29uc3VtZUJvZHksIFwiY29uc3VtZUJvZHlcIik7XG4gICAgZnVuY3Rpb24gYm9keU1peGluTWV0aG9kcyhpbnN0YW5jZSkge1xuICAgICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgYXN5bmMgYmxvYigpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkge1xuICAgICAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2NodW5rXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoY2h1bmtzLCB7IHR5cGU6IHRoaXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgfHwgXCJcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXMuaGVhZGVycy5nZXQoXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5oZWFkZXJzLmhhcyhcImNvbnRlbnQtZW5jb2RpbmdcIik7XG4gICAgICAgICAgaWYgKCFlbmNvZGVkICYmIGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgVWludDhBcnJheShjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJvZHkodGhpc1trU3RhdGVdLmJvZHkpKSB7XG4gICAgICAgICAgICAgIGlmICghaXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJ1ZmZlcjIuc2V0KGNodW5rLCBvZmZzZXQyKTtcbiAgICAgICAgICAgICAgb2Zmc2V0MiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyMi5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkge1xuICAgICAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgYnVmZmVyLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdGV4dCgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJvZHkodGhpc1trU3RhdGVdLmJvZHkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXkgY2h1bmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gdGV4dERlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ICs9IHRleHREZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGpzb24oKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYXdhaXQgdGhpcy50ZXh0KCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBmb3JtRGF0YSgpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgICAgaWYgKC9tdWx0aXBhcnRcXC9mb3JtLWRhdGEvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoXCJtdWx0aXBhcnQvZm9ybS1kYXRhIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICgvYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWQvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7IGlnbm9yZUJPTTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRleHREZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dCArPSB0ZXh0RGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgICAgICAgICAgZW50cmllcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCksIHsgY2F1c2U6IGVyciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogYCR7aW5zdGFuY2UubmFtZX0uZm9ybURhdGFgLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJDb3VsZCBub3QgcGFyc2UgY29udGVudCBhcyBGb3JtRGF0YS5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgfVxuICAgIF9fbmFtZShib2R5TWl4aW5NZXRob2RzLCBcImJvZHlNaXhpbk1ldGhvZHNcIik7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICBib2R5OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMgfHwgIXRoaXNba1N0YXRlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHlVc2VkOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMgfHwgIXRoaXNba1N0YXRlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbDIuaXNEaXN0dXJiZWQodGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbWl4aW5Cb2R5KHByb3RvdHlwZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUucHJvdG90eXBlLCBib2R5TWl4aW5NZXRob2RzKHByb3RvdHlwZSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG90eXBlLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIF9fbmFtZShtaXhpbkJvZHksIFwibWl4aW5Cb2R5XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGV4dHJhY3RCb2R5LFxuICAgICAgc2FmZWx5RXh0cmFjdEJvZHksXG4gICAgICBjbG9uZUJvZHksXG4gICAgICBtaXhpbkJvZHlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9yZXF1ZXN0LmpzXG52YXIgcmVxdWlyZV9yZXF1ZXN0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9yZXF1ZXN0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7XG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgICAgIE5vdFN1cHBvcnRlZEVycm9yXG4gICAgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB0b2tlblJlZ0V4cCA9IC9eW1xcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dKyQvO1xuICAgIHZhciBoZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87XG4gICAgdmFyIGludmFsaWRQYXRoUmVnZXggPSAvW15cXHUwMDIxLVxcdTAwZmZdLztcbiAgICB2YXIga0hhbmRsZXIgPSBTeW1ib2woXCJoYW5kbGVyXCIpO1xuICAgIHZhciBjaGFubmVscyA9IHt9O1xuICAgIHZhciBleHRyYWN0Qm9keTtcbiAgICB2YXIgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpO1xuICAgIHZhciBub2RlTWFqb3IgPSBOdW1iZXIobm9kZVZlcnNpb25bMF0pO1xuICAgIHZhciBub2RlTWlub3IgPSBOdW1iZXIobm9kZVZlcnNpb25bMV0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKFwiZGlhZ25vc3RpY3NfY2hhbm5lbFwiKTtcbiAgICAgIGNoYW5uZWxzLmNyZWF0ZSA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6Y3JlYXRlXCIpO1xuICAgICAgY2hhbm5lbHMuYm9keVNlbnQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmJvZHlTZW50XCIpO1xuICAgICAgY2hhbm5lbHMuaGVhZGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6aGVhZGVyc1wiKTtcbiAgICAgIGNoYW5uZWxzLnRyYWlsZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6cmVxdWVzdDp0cmFpbGVyc1wiKTtcbiAgICAgIGNoYW5uZWxzLmVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6cmVxdWVzdDplcnJvclwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjaGFubmVscy5jcmVhdGUgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuYm9keVNlbnQgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuaGVhZGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH07XG4gICAgICBjaGFubmVscy50cmFpbGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH07XG4gICAgICBjaGFubmVscy5lcnJvciA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH07XG4gICAgfVxuICAgIHZhciBSZXF1ZXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Iob3JpZ2luLCB7XG4gICAgICAgIHBhdGg6IHBhdGg3LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeTIsXG4gICAgICAgIGlkZW1wb3RlbnQsXG4gICAgICAgIGJsb2NraW5nLFxuICAgICAgICB1cGdyYWRlLFxuICAgICAgICBoZWFkZXJzVGltZW91dCxcbiAgICAgICAgYm9keVRpbWVvdXQsXG4gICAgICAgIHRocm93T25FcnJvclxuICAgICAgfSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGg3ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwicGF0aCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGg3WzBdICE9PSBcIi9cIiAmJiAhKHBhdGg3LnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHBhdGg3LnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkgJiYgbWV0aG9kICE9PSBcIkNPTk5FQ1RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInBhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXguZXhlYyhwYXRoNykgIT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJlcXVlc3QgcGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuUmVnRXhwLmV4ZWMobWV0aG9kKSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgcmVxdWVzdCBtZXRob2RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZ3JhZGUgJiYgdHlwZW9mIHVwZ3JhZGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1cGdyYWRlIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoaGVhZGVyc1RpbWVvdXQpIHx8IGhlYWRlcnNUaW1lb3V0IDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhlYWRlcnNUaW1lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBib2R5VGltZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXQ7XG4gICAgICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dDtcbiAgICAgICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWU7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keS5sZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNGb3JtRGF0YUxpa2UoYm9keSkgfHwgdXRpbDIuaXNJdGVyYWJsZShib2R5KSB8fCB1dGlsMi5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZ3JhZGUgPSB1cGdyYWRlIHx8IG51bGw7XG4gICAgICAgIHRoaXMucGF0aCA9IHF1ZXJ5MiA/IHV0aWwyLmJ1aWxkVVJMKHBhdGg3LCBxdWVyeTIpIDogcGF0aDc7XG4gICAgICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ID09IG51bGwgPyBtZXRob2QgPT09IFwiSEVBRFwiIHx8IG1ldGhvZCA9PT0gXCJHRVRcIiA6IGlkZW1wb3RlbnQ7XG4gICAgICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZztcbiAgICAgICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFwiXCI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5czIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXMyW2ldO1xuICAgICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImhlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwyLmlzRm9ybURhdGFMaWtlKHRoaXMuYm9keSkpIHtcbiAgICAgICAgICBpZiAobm9kZU1ham9yIDwgMTYgfHwgbm9kZU1ham9yID09PSAxNiAmJiBub2RlTWlub3IgPCA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJGb3JtLURhdGEgYm9kaWVzIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBub2RlIHYxNi44IGFuZCBuZXdlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZXh0cmFjdEJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhY3RCb2R5ID0gcmVxdWlyZV9ib2R5KCkuZXh0cmFjdEJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFtib2R5U3RyZWFtLCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShib2R5KTtcbiAgICAgICAgICBpZiAodGhpcy5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtjb250ZW50VHlwZX1cXHJcbmA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHlTdHJlYW0uc3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzQmxvYkxpa2UoYm9keSkgJiYgdGhpcy5jb250ZW50VHlwZSA9PSBudWxsICYmIGJvZHkudHlwZSkge1xuICAgICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBib2R5LnR5cGU7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzICs9IGBjb250ZW50LXR5cGU6ICR7Ym9keS50eXBlfVxcclxuYDtcbiAgICAgICAgfVxuICAgICAgICB1dGlsMi52YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJuYW1lID0gdXRpbDIuZ2V0U2VydmVyTmFtZSh0aGlzLmhvc3QpO1xuICAgICAgICB0aGlzW2tIYW5kbGVyXSA9IGhhbmRsZXI7XG4gICAgICAgIGlmIChjaGFubmVscy5jcmVhdGUuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5jcmVhdGUucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uQm9keVNlbnQoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudChjaHVuayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uUmVxdWVzdFNlbnQoKSB7XG4gICAgICAgIGlmIChjaGFubmVscy5ib2R5U2VudC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLmJvZHlTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkNvbm5lY3QoYWJvcnQpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29ubmVjdChhYm9ydCk7XG4gICAgICB9XG4gICAgICBvbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZCk7XG4gICAgICAgIGlmIChjaGFubmVscy5oZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMuaGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzVGV4dCB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KTtcbiAgICAgIH1cbiAgICAgIG9uRGF0YShjaHVuaykge1xuICAgICAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZCk7XG4gICAgICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpO1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIG9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpO1xuICAgICAgfVxuICAgICAgb25Db21wbGV0ZSh0cmFpbGVycykge1xuICAgICAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZCk7XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMudHJhaWxlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHRyYWlsZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkNvbXBsZXRlKHRyYWlsZXJzKTtcbiAgICAgIH1cbiAgICAgIG9uRXJyb3IoZXJyb3IyKSB7XG4gICAgICAgIGlmIChjaGFubmVscy5lcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoZXJyb3IyKTtcbiAgICAgIH1cbiAgICAgIGFkZEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlcXVlc3QsIFwiUmVxdWVzdFwiKTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHJlcXVlc3QyLCBrZXksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5ob3N0ID09PSBudWxsICYmIGtleS5sZW5ndGggPT09IDQgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiaG9zdFwiKSB7XG4gICAgICAgIHJlcXVlc3QyLmhvc3QgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QyLmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiYga2V5Lmxlbmd0aCA9PT0gMTQgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC1sZW5ndGhcIikge1xuICAgICAgICByZXF1ZXN0Mi5jb250ZW50TGVuZ3RoID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHJlcXVlc3QyLmNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb250ZW50LWxlbmd0aCBoZWFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdDIuY29udGVudFR5cGUgPT09IG51bGwgJiYga2V5Lmxlbmd0aCA9PT0gMTIgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgJiYgaGVhZGVyQ2hhclJlZ2V4LmV4ZWModmFsKSA9PT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0Mi5jb250ZW50VHlwZSA9IHZhbDtcbiAgICAgICAgcmVxdWVzdDIuaGVhZGVycyArPSBgJHtrZXl9OiAke3ZhbH1cXHJcbmA7XG4gICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDE3ICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInRyYW5zZmVyLWVuY29kaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDEwICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBcImNvbm5lY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbm5lY3Rpb24gaGVhZGVyXCIpO1xuICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJrZWVwLWFsaXZlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZWVwLWFsaXZlIGhlYWRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gNyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJ1cGdyYWRlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCB1cGdyYWRlIGhlYWRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gNiAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJleHBlY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoXCJleHBlY3QgaGVhZGVyIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuUmVnRXhwLmV4ZWMoa2V5KSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhlYWRlciBrZXlcIik7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRlckNoYXJSZWdleC5leGVjKHZhbCkgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QyLmhlYWRlcnMgKz0gYCR7a2V5fTogJHt2YWx9XFxyXG5gO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocHJvY2Vzc0hlYWRlciwgXCJwcm9jZXNzSGVhZGVyXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFJlcXVlc3Q7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLmpzXG52YXIgcmVxdWlyZV9kaXNwYXRjaGVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgRXZlbnRFbWl0dGVyNCA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4gICAgdmFyIERpc3BhdGNoZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjQge1xuICAgICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNsb3NlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoRGlzcGF0Y2hlciwgXCJEaXNwYXRjaGVyXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLWJhc2UuanNcbnZhciByZXF1aXJlX2Rpc3BhdGNoZXJfYmFzZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXItYmFzZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmVfZGlzcGF0Y2hlcigpO1xuICAgIHZhciB7XG4gICAgICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgICAgIENsaWVudENsb3NlZEVycm9yLFxuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBrRGVzdHJveSwga0Nsb3NlLCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBrRGVzdHJveWVkID0gU3ltYm9sKFwiZGVzdHJveWVkXCIpO1xuICAgIHZhciBrQ2xvc2VkID0gU3ltYm9sKFwiY2xvc2VkXCIpO1xuICAgIHZhciBrT25EZXN0cm95ZWQgPSBTeW1ib2woXCJvbkRlc3Ryb3llZFwiKTtcbiAgICB2YXIga09uQ2xvc2VkID0gU3ltYm9sKFwib25DbG9zZWRcIik7XG4gICAgdmFyIERpc3BhdGNoZXJCYXNlID0gY2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzW2tEZXN0cm95ZWRdID0gZmFsc2U7XG4gICAgICAgIHRoaXNba09uRGVzdHJveWVkXSA9IFtdO1xuICAgICAgICB0aGlzW2tDbG9zZWRdID0gZmFsc2U7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXSA9IFtdO1xuICAgICAgfVxuICAgICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0Rlc3Ryb3llZF07XG4gICAgICB9XG4gICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trQ2xvc2VkXTtcbiAgICAgIH1cbiAgICAgIGNsb3NlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpLCBudWxsKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgICAgaWYgKHRoaXNba09uQ2xvc2VkXSkge1xuICAgICAgICAgICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tDbG9zZWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBvbkNsb3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uQ2xvc2VkXTtcbiAgICAgICAgICB0aGlzW2tPbkNsb3NlZF0gPSBudWxsO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcIm9uQ2xvc2VkXCIpO1xuICAgICAgICB0aGlzW2tDbG9zZV0oKS50aGVuKCgpID0+IHRoaXMuZGVzdHJveSgpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGVycjtcbiAgICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnIyID8gcmVqZWN0KGVycjIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgICAgICBpZiAodGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgZXJyID0gbmV3IENsaWVudERlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trRGVzdHJveWVkXSA9IHRydWU7XG4gICAgICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3Qgb25EZXN0cm95ZWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkRlc3Ryb3llZF07XG4gICAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJvbkRlc3Ryb3llZFwiKTtcbiAgICAgICAgdGhpc1trRGVzdHJveV0oZXJyKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkRlc3Ryb3llZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2gob3B0cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJvcHRzIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENsaWVudENsb3NlZEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25FcnJvciBtZXRob2RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKERpc3BhdGNoZXJCYXNlLCBcIkRpc3BhdGNoZXJCYXNlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IERpc3BhdGNoZXJCYXNlO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9yZWRpcmVjdC5qc1xudmFyIHJlcXVpcmVfcmVkaXJlY3QgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBFRSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4gICAgdmFyIHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzID0gWzMwMCwgMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuICAgIHZhciBrQm9keSA9IFN5bWJvbChcImJvZHlcIik7XG4gICAgdmFyIEJvZHlBc3luY0l0ZXJhYmxlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICB0aGlzW2tCb2R5XSA9IGJvZHk7XG4gICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGFzc2VydCghdGhpc1trQm9keVVzZWRdLCBcImRpc3R1cmJlZFwiKTtcbiAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZTtcbiAgICAgICAgeWllbGQqIHRoaXNba0JvZHldO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEJvZHlBc3luY0l0ZXJhYmxlLCBcIkJvZHlBc3luY0l0ZXJhYmxlXCIpO1xuICAgIHZhciBSZWRpcmVjdEhhbmRsZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbDIudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG9wdHMubWV0aG9kLCBvcHRzLnVwZ3JhZGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hYm9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH07XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3Rpb25zID0gbWF4UmVkaXJlY3Rpb25zO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgaWYgKHV0aWwyLmlzU3RyZWFtKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgICAgIGlmICh1dGlsMi5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmJvZHkub24oXCJkYXRhXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmJvZHkucmVhZGFibGVEaWRSZWFkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmJvZHlba0JvZHlVc2VkXSA9IGZhbHNlO1xuICAgICAgICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwodGhpcy5vcHRzLmJvZHksIFwiZGF0YVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuYm9keSAmJiB0eXBlb2YgdGhpcy5vcHRzLmJvZHkucGlwZVRvID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSBcInN0cmluZ1wiICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5vcHRzLmJvZHkpICYmIHV0aWwyLmlzSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkNvbm5lY3QoYWJvcnQpIHtcbiAgICAgICAgdGhpcy5hYm9ydCA9IGFib3J0O1xuICAgICAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KGFib3J0LCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KTtcbiAgICAgIH1cbiAgICAgIG9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpO1xuICAgICAgfVxuICAgICAgb25FcnJvcihlcnJvcjIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyb3IyKTtcbiAgICAgIH1cbiAgICAgIG9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbDIuaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpID8gbnVsbCA6IHBhcnNlTG9jYXRpb24oc3RhdHVzQ29kZSwgaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3JpZ2luKSB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5sb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHV0aWwyLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpO1xuICAgICAgICBjb25zdCBwYXRoNyA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbik7XG4gICAgICAgIHRoaXMub3B0cy5wYXRoID0gcGF0aDc7XG4gICAgICAgIHRoaXMub3B0cy5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMub3B0cy5tYXhSZWRpcmVjdGlvbnMgPSAwO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMzAzICYmIHRoaXMub3B0cy5tZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uQ29tcGxldGUodHJhaWxlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSh0cmFpbGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uQm9keVNlbnQoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVkaXJlY3RIYW5kbGVyLCBcIlJlZGlyZWN0SGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiBwYXJzZUxvY2F0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpIHtcbiAgICAgIGlmIChyZWRpcmVjdGFibGVTdGF0dXNDb2Rlcy5pbmRleE9mKHN0YXR1c0NvZGUpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGVhZGVyc1tpXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwibG9jYXRpb25cIikge1xuICAgICAgICAgIHJldHVybiBoZWFkZXJzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocGFyc2VMb2NhdGlvbiwgXCJwYXJzZUxvY2F0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXIsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgICAgIHJldHVybiBoZWFkZXIubGVuZ3RoID09PSA0ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwiaG9zdFwiIHx8IHJlbW92ZUNvbnRlbnQgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29udGVudC1cIikgPT09IDAgfHwgdW5rbm93bk9yaWdpbiAmJiBoZWFkZXIubGVuZ3RoID09PSAxMyAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImF1dGhvcml6YXRpb25cIiB8fCB1bmtub3duT3JpZ2luICYmIGhlYWRlci5sZW5ndGggPT09IDYgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb29raWVcIjtcbiAgICB9XG4gICAgX19uYW1lKHNob3VsZFJlbW92ZUhlYWRlciwgXCJzaG91bGRSZW1vdmVIZWFkZXJcIik7XG4gICAgZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyhoZWFkZXJzLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGlmICghc2hvdWxkUmVtb3ZlSGVhZGVyKGhlYWRlcnNbaV0sIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgICAgICByZXQucHVzaChoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihrZXksIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgICAgICByZXQucHVzaChrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQoaGVhZGVycyA9PSBudWxsLCBcImhlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBfX25hbWUoY2xlYW5SZXF1ZXN0SGVhZGVycywgXCJjbGVhblJlcXVlc3RIZWFkZXJzXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFJlZGlyZWN0SGFuZGxlcjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvY29ubmVjdC5qc1xudmFyIHJlcXVpcmVfY29ubmVjdCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvY29ubmVjdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbmV0MiA9IHJlcXVpcmUoXCJuZXRcIik7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yLCBDb25uZWN0VGltZW91dEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB0bHM7XG4gICAgZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IoeyBtYXhDYWNoZWRTZXNzaW9ucywgc29ja2V0UGF0aCwgdGltZW91dCwgLi4ub3B0cyB9KSB7XG4gICAgICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4Q2FjaGVkU2Vzc2lvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVyb1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHBhdGg6IHNvY2tldFBhdGgsIC4uLm9wdHMgfTtcbiAgICAgIGNvbnN0IHNlc3Npb25DYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMWU0IDogdGltZW91dDtcbiAgICAgIG1heENhY2hlZFNlc3Npb25zID0gbWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gY29ubmVjdCh7IGhvc3RuYW1lOiBob3N0bmFtZTMsIGhvc3QsIHByb3RvY29sLCBwb3J0LCBzZXJ2ZXJuYW1lLCBodHRwU29ja2V0IH0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIGlmIChwcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgICAgICAgIGlmICghdGxzKSB7XG4gICAgICAgICAgICB0bHMgPSByZXF1aXJlKFwidGxzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbDIuZ2V0U2VydmVyTmFtZShob3N0KSB8fCBudWxsO1xuICAgICAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBzZXJ2ZXJuYW1lIHx8IGhvc3RuYW1lMztcbiAgICAgICAgICBjb25zdCBzZXNzaW9uID0gc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KSB8fCBudWxsO1xuICAgICAgICAgIGFzc2VydChzZXNzaW9uS2V5KTtcbiAgICAgICAgICBzb2NrZXQgPSB0bHMuY29ubmVjdCh7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgICAgIHNvY2tldDogaHR0cFNvY2tldCxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQgfHwgNDQzLFxuICAgICAgICAgICAgaG9zdDogaG9zdG5hbWUzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc29ja2V0Lm9uKFwic2Vzc2lvblwiLCBmdW5jdGlvbihzZXNzaW9uMikge1xuICAgICAgICAgICAgaWYgKG1heENhY2hlZFNlc3Npb25zID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXNzaW9uQ2FjaGUuc2l6ZSA+PSBtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBvbGRlc3RLZXkgfSA9IHNlc3Npb25DYWNoZS5rZXlzKCkubmV4dCgpO1xuICAgICAgICAgICAgICBzZXNzaW9uQ2FjaGUuZGVsZXRlKG9sZGVzdEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIHNlc3Npb24yKTtcbiAgICAgICAgICB9KS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKHNlc3Npb25LZXkgJiYgZXJyLmNvZGUgIT09IFwiVU5EX0VSUl9JTkZPXCIpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbkNhY2hlLmRlbGV0ZShzZXNzaW9uS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoIWh0dHBTb2NrZXQsIFwiaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGVcIik7XG4gICAgICAgICAgc29ja2V0ID0gbmV0Mi5jb25uZWN0KHtcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBwb3J0OiBwb3J0IHx8IDgwLFxuICAgICAgICAgICAgaG9zdDogaG9zdG5hbWUzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuY2VsVGltZW91dCA9IHNldHVwVGltZW91dCgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0KHNvY2tldCksIHRpbWVvdXQpO1xuICAgICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0cnVlKS5vbmNlKHByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCJzZWN1cmVDb25uZWN0XCIgOiBcImNvbm5lY3RcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGNiKG51bGwsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgfSwgXCJjb25uZWN0XCIpO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRDb25uZWN0b3IsIFwiYnVpbGRDb25uZWN0b3JcIik7XG4gICAgZnVuY3Rpb24gc2V0dXBUaW1lb3V0KG9uQ29ubmVjdFRpbWVvdXQyLCB0aW1lb3V0KSB7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCBzMSA9IG51bGw7XG4gICAgICBsZXQgczIgPSBudWxsO1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgICAgICBzMiA9IHNldEltbWVkaWF0ZSgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0MigpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25Db25uZWN0VGltZW91dDIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgY2xlYXJJbW1lZGlhdGUoczEpO1xuICAgICAgICBjbGVhckltbWVkaWF0ZShzMik7XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoc2V0dXBUaW1lb3V0LCBcInNldHVwVGltZW91dFwiKTtcbiAgICBmdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0KHNvY2tldCkge1xuICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKCkpO1xuICAgIH1cbiAgICBfX25hbWUob25Db25uZWN0VGltZW91dCwgXCJvbkNvbm5lY3RUaW1lb3V0XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL3V0aWxzLmpzXG52YXIgcmVxdWlyZV91dGlscyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC91dGlscy5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5lbnVtVG9NYXAgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gZW51bVRvTWFwKG9iaikge1xuICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfX25hbWUoZW51bVRvTWFwLCBcImVudW1Ub01hcFwiKTtcbiAgICBleHBvcnRzLmVudW1Ub01hcCA9IGVudW1Ub01hcDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9jb25zdGFudHMuanNcbnZhciByZXF1aXJlX2NvbnN0YW50czIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IGV4cG9ydHMuSEVBREVSX1NUQVRFID0gZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUyA9IGV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTiA9IGV4cG9ydHMuSEVYID0gZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSID0gZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuTUFSSyA9IGV4cG9ydHMuQUxQSEFOVU0gPSBleHBvcnRzLk5VTSA9IGV4cG9ydHMuSEVYX01BUCA9IGV4cG9ydHMuTlVNX01BUCA9IGV4cG9ydHMuQUxQSEEgPSBleHBvcnRzLkZJTklTSCA9IGV4cG9ydHMuSF9NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBleHBvcnRzLk1FVEhPRFNfSUNFID0gZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBleHBvcnRzLk1FVEhPRFMgPSBleHBvcnRzLkxFTklFTlRfRkxBR1MgPSBleHBvcnRzLkZMQUdTID0gZXhwb3J0cy5UWVBFID0gZXhwb3J0cy5FUlJPUiA9IHZvaWQgMDtcbiAgICB2YXIgdXRpbHNfMSA9IHJlcXVpcmVfdXRpbHMoKTtcbiAgICB2YXIgRVJST1I7XG4gICAgKGZ1bmN0aW9uKEVSUk9SMikge1xuICAgICAgRVJST1IyW0VSUk9SMltcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5URVJOQUxcIl0gPSAxXSA9IFwiSU5URVJOQUxcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJTVFJJQ1RcIl0gPSAyXSA9IFwiU1RSSUNUXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiTEZfRVhQRUNURURcIl0gPSAzXSA9IFwiTEZfRVhQRUNURURcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCJdID0gNF0gPSBcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJDTE9TRURfQ09OTkVDVElPTlwiXSA9IDVdID0gXCJDTE9TRURfQ09OTkVDVElPTlwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfTUVUSE9EXCJdID0gNl0gPSBcIklOVkFMSURfTUVUSE9EXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9VUkxcIl0gPSA3XSA9IFwiSU5WQUxJRF9VUkxcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJJTlZBTElEX0NPTlNUQU5UXCJdID0gOF0gPSBcIklOVkFMSURfQ09OU1RBTlRcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJJTlZBTElEX1ZFUlNJT05cIl0gPSA5XSA9IFwiSU5WQUxJRF9WRVJTSU9OXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9IRUFERVJfVE9LRU5cIl0gPSAxMF0gPSBcIklOVkFMSURfSEVBREVSX1RPS0VOXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9DT05URU5UX0xFTkdUSFwiXSA9IDExXSA9IFwiSU5WQUxJRF9DT05URU5UX0xFTkdUSFwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIklOVkFMSURfQ0hVTktfU0laRVwiXSA9IDEyXSA9IFwiSU5WQUxJRF9DSFVOS19TSVpFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9TVEFUVVNcIl0gPSAxM10gPSBcIklOVkFMSURfU1RBVFVTXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9FT0ZfU1RBVEVcIl0gPSAxNF0gPSBcIklOVkFMSURfRU9GX1NUQVRFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDE1XSA9IFwiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIkNCX01FU1NBR0VfQkVHSU5cIl0gPSAxNl0gPSBcIkNCX01FU1NBR0VfQkVHSU5cIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJDQl9IRUFERVJTX0NPTVBMRVRFXCJdID0gMTddID0gXCJDQl9IRUFERVJTX0NPTVBMRVRFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiQ0JfTUVTU0FHRV9DT01QTEVURVwiXSA9IDE4XSA9IFwiQ0JfTUVTU0FHRV9DT01QTEVURVwiO1xuICAgICAgRVJST1IyW0VSUk9SMltcIkNCX0NIVU5LX0hFQURFUlwiXSA9IDE5XSA9IFwiQ0JfQ0hVTktfSEVBREVSXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiQ0JfQ0hVTktfQ09NUExFVEVcIl0gPSAyMF0gPSBcIkNCX0NIVU5LX0NPTVBMRVRFXCI7XG4gICAgICBFUlJPUjJbRVJST1IyW1wiUEFVU0VEXCJdID0gMjFdID0gXCJQQVVTRURcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJQQVVTRURfVVBHUkFERVwiXSA9IDIyXSA9IFwiUEFVU0VEX1VQR1JBREVcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJQQVVTRURfSDJfVVBHUkFERVwiXSA9IDIzXSA9IFwiUEFVU0VEX0gyX1VQR1JBREVcIjtcbiAgICAgIEVSUk9SMltFUlJPUjJbXCJVU0VSXCJdID0gMjRdID0gXCJVU0VSXCI7XG4gICAgfSkoRVJST1IgPSBleHBvcnRzLkVSUk9SIHx8IChleHBvcnRzLkVSUk9SID0ge30pKTtcbiAgICB2YXIgVFlQRTtcbiAgICAoZnVuY3Rpb24oVFlQRTIpIHtcbiAgICAgIFRZUEUyW1RZUEUyW1wiQk9USFwiXSA9IDBdID0gXCJCT1RIXCI7XG4gICAgICBUWVBFMltUWVBFMltcIlJFUVVFU1RcIl0gPSAxXSA9IFwiUkVRVUVTVFwiO1xuICAgICAgVFlQRTJbVFlQRTJbXCJSRVNQT05TRVwiXSA9IDJdID0gXCJSRVNQT05TRVwiO1xuICAgIH0pKFRZUEUgPSBleHBvcnRzLlRZUEUgfHwgKGV4cG9ydHMuVFlQRSA9IHt9KSk7XG4gICAgdmFyIEZMQUdTO1xuICAgIChmdW5jdGlvbihGTEFHUzIpIHtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSAxXSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiQ09OTkVDVElPTl9DTE9TRVwiXSA9IDJdID0gXCJDT05ORUNUSU9OX0NMT1NFXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gNF0gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgICAgRkxBR1MyW0ZMQUdTMltcIkNIVU5LRURcIl0gPSA4XSA9IFwiQ0hVTktFRFwiO1xuICAgICAgRkxBR1MyW0ZMQUdTMltcIlVQR1JBREVcIl0gPSAxNl0gPSBcIlVQR1JBREVcIjtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJDT05URU5UX0xFTkdUSFwiXSA9IDMyXSA9IFwiQ09OVEVOVF9MRU5HVEhcIjtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJTS0lQQk9EWVwiXSA9IDY0XSA9IFwiU0tJUEJPRFlcIjtcbiAgICAgIEZMQUdTMltGTEFHUzJbXCJUUkFJTElOR1wiXSA9IDEyOF0gPSBcIlRSQUlMSU5HXCI7XG4gICAgICBGTEFHUzJbRkxBR1MyW1wiVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSA1MTJdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIH0pKEZMQUdTID0gZXhwb3J0cy5GTEFHUyB8fCAoZXhwb3J0cy5GTEFHUyA9IHt9KSk7XG4gICAgdmFyIExFTklFTlRfRkxBR1M7XG4gICAgKGZ1bmN0aW9uKExFTklFTlRfRkxBR1MyKSB7XG4gICAgICBMRU5JRU5UX0ZMQUdTMltMRU5JRU5UX0ZMQUdTMltcIkhFQURFUlNcIl0gPSAxXSA9IFwiSEVBREVSU1wiO1xuICAgICAgTEVOSUVOVF9GTEFHUzJbTEVOSUVOVF9GTEFHUzJbXCJDSFVOS0VEX0xFTkdUSFwiXSA9IDJdID0gXCJDSFVOS0VEX0xFTkdUSFwiO1xuICAgICAgTEVOSUVOVF9GTEFHUzJbTEVOSUVOVF9GTEFHUzJbXCJLRUVQX0FMSVZFXCJdID0gNF0gPSBcIktFRVBfQUxJVkVcIjtcbiAgICB9KShMRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTIHx8IChleHBvcnRzLkxFTklFTlRfRkxBR1MgPSB7fSkpO1xuICAgIHZhciBNRVRIT0RTO1xuICAgIChmdW5jdGlvbihNRVRIT0RTMikge1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJERUxFVEVcIl0gPSAwXSA9IFwiREVMRVRFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkdFVFwiXSA9IDFdID0gXCJHRVRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiSEVBRFwiXSA9IDJdID0gXCJIRUFEXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlBPU1RcIl0gPSAzXSA9IFwiUE9TVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQVVRcIl0gPSA0XSA9IFwiUFVUXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkNPTk5FQ1RcIl0gPSA1XSA9IFwiQ09OTkVDVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJPUFRJT05TXCJdID0gNl0gPSBcIk9QVElPTlNcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiQ09QWVwiXSA9IDhdID0gXCJDT1BZXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkxPQ0tcIl0gPSA5XSA9IFwiTE9DS1wiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJNS0NPTFwiXSA9IDEwXSA9IFwiTUtDT0xcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTU9WRVwiXSA9IDExXSA9IFwiTU9WRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQUk9QRklORFwiXSA9IDEyXSA9IFwiUFJPUEZJTkRcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUFJPUFBBVENIXCJdID0gMTNdID0gXCJQUk9QUEFUQ0hcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiU0VBUkNIXCJdID0gMTRdID0gXCJTRUFSQ0hcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiVU5MT0NLXCJdID0gMTVdID0gXCJVTkxPQ0tcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiQklORFwiXSA9IDE2XSA9IFwiQklORFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJSRUJJTkRcIl0gPSAxN10gPSBcIlJFQklORFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJVTkJJTkRcIl0gPSAxOF0gPSBcIlVOQklORFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJBQ0xcIl0gPSAxOV0gPSBcIkFDTFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJSRVBPUlRcIl0gPSAyMF0gPSBcIlJFUE9SVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJNS0FDVElWSVRZXCJdID0gMjFdID0gXCJNS0FDVElWSVRZXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIkNIRUNLT1VUXCJdID0gMjJdID0gXCJDSEVDS09VVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJNRVJHRVwiXSA9IDIzXSA9IFwiTUVSR0VcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTS1TRUFSQ0hcIl0gPSAyNF0gPSBcIk0tU0VBUkNIXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIk5PVElGWVwiXSA9IDI1XSA9IFwiTk9USUZZXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlNVQlNDUklCRVwiXSA9IDI2XSA9IFwiU1VCU0NSSUJFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlVOU1VCU0NSSUJFXCJdID0gMjddID0gXCJVTlNVQlNDUklCRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQQVRDSFwiXSA9IDI4XSA9IFwiUEFUQ0hcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiUFVSR0VcIl0gPSAyOV0gPSBcIlBVUkdFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIk1LQ0FMRU5EQVJcIl0gPSAzMF0gPSBcIk1LQ0FMRU5EQVJcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiTElOS1wiXSA9IDMxXSA9IFwiTElOS1wiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJVTkxJTktcIl0gPSAzMl0gPSBcIlVOTElOS1wiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJTT1VSQ0VcIl0gPSAzM10gPSBcIlNPVVJDRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQUklcIl0gPSAzNF0gPSBcIlBSSVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJERVNDUklCRVwiXSA9IDM1XSA9IFwiREVTQ1JJQkVcIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiQU5OT1VOQ0VcIl0gPSAzNl0gPSBcIkFOTk9VTkNFXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlNFVFVQXCJdID0gMzddID0gXCJTRVRVUFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJQTEFZXCJdID0gMzhdID0gXCJQTEFZXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlBBVVNFXCJdID0gMzldID0gXCJQQVVTRVwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJURUFSRE9XTlwiXSA9IDQwXSA9IFwiVEVBUkRPV05cIjtcbiAgICAgIE1FVEhPRFMyW01FVEhPRFMyW1wiR0VUX1BBUkFNRVRFUlwiXSA9IDQxXSA9IFwiR0VUX1BBUkFNRVRFUlwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJTRVRfUEFSQU1FVEVSXCJdID0gNDJdID0gXCJTRVRfUEFSQU1FVEVSXCI7XG4gICAgICBNRVRIT0RTMltNRVRIT0RTMltcIlJFRElSRUNUXCJdID0gNDNdID0gXCJSRURJUkVDVFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJSRUNPUkRcIl0gPSA0NF0gPSBcIlJFQ09SRFwiO1xuICAgICAgTUVUSE9EUzJbTUVUSE9EUzJbXCJGTFVTSFwiXSA9IDQ1XSA9IFwiRkxVU0hcIjtcbiAgICB9KShNRVRIT0RTID0gZXhwb3J0cy5NRVRIT0RTIHx8IChleHBvcnRzLk1FVEhPRFMgPSB7fSkpO1xuICAgIGV4cG9ydHMuTUVUSE9EU19IVFRQID0gW1xuICAgICAgTUVUSE9EUy5ERUxFVEUsXG4gICAgICBNRVRIT0RTLkdFVCxcbiAgICAgIE1FVEhPRFMuSEVBRCxcbiAgICAgIE1FVEhPRFMuUE9TVCxcbiAgICAgIE1FVEhPRFMuUFVULFxuICAgICAgTUVUSE9EUy5DT05ORUNULFxuICAgICAgTUVUSE9EUy5PUFRJT05TLFxuICAgICAgTUVUSE9EUy5UUkFDRSxcbiAgICAgIE1FVEhPRFMuQ09QWSxcbiAgICAgIE1FVEhPRFMuTE9DSyxcbiAgICAgIE1FVEhPRFMuTUtDT0wsXG4gICAgICBNRVRIT0RTLk1PVkUsXG4gICAgICBNRVRIT0RTLlBST1BGSU5ELFxuICAgICAgTUVUSE9EUy5QUk9QUEFUQ0gsXG4gICAgICBNRVRIT0RTLlNFQVJDSCxcbiAgICAgIE1FVEhPRFMuVU5MT0NLLFxuICAgICAgTUVUSE9EUy5CSU5ELFxuICAgICAgTUVUSE9EUy5SRUJJTkQsXG4gICAgICBNRVRIT0RTLlVOQklORCxcbiAgICAgIE1FVEhPRFMuQUNMLFxuICAgICAgTUVUSE9EUy5SRVBPUlQsXG4gICAgICBNRVRIT0RTLk1LQUNUSVZJVFksXG4gICAgICBNRVRIT0RTLkNIRUNLT1VULFxuICAgICAgTUVUSE9EUy5NRVJHRSxcbiAgICAgIE1FVEhPRFNbXCJNLVNFQVJDSFwiXSxcbiAgICAgIE1FVEhPRFMuTk9USUZZLFxuICAgICAgTUVUSE9EUy5TVUJTQ1JJQkUsXG4gICAgICBNRVRIT0RTLlVOU1VCU0NSSUJFLFxuICAgICAgTUVUSE9EUy5QQVRDSCxcbiAgICAgIE1FVEhPRFMuUFVSR0UsXG4gICAgICBNRVRIT0RTLk1LQ0FMRU5EQVIsXG4gICAgICBNRVRIT0RTLkxJTkssXG4gICAgICBNRVRIT0RTLlVOTElOSyxcbiAgICAgIE1FVEhPRFMuUFJJLFxuICAgICAgTUVUSE9EUy5TT1VSQ0VcbiAgICBdO1xuICAgIGV4cG9ydHMuTUVUSE9EU19JQ0UgPSBbXG4gICAgICBNRVRIT0RTLlNPVVJDRVxuICAgIF07XG4gICAgZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBbXG4gICAgICBNRVRIT0RTLk9QVElPTlMsXG4gICAgICBNRVRIT0RTLkRFU0NSSUJFLFxuICAgICAgTUVUSE9EUy5BTk5PVU5DRSxcbiAgICAgIE1FVEhPRFMuU0VUVVAsXG4gICAgICBNRVRIT0RTLlBMQVksXG4gICAgICBNRVRIT0RTLlBBVVNFLFxuICAgICAgTUVUSE9EUy5URUFSRE9XTixcbiAgICAgIE1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICAgIE1FVEhPRFMuU0VUX1BBUkFNRVRFUixcbiAgICAgIE1FVEhPRFMuUkVESVJFQ1QsXG4gICAgICBNRVRIT0RTLlJFQ09SRCxcbiAgICAgIE1FVEhPRFMuRkxVU0gsXG4gICAgICBNRVRIT0RTLkdFVCxcbiAgICAgIE1FVEhPRFMuUE9TVFxuICAgIF07XG4gICAgZXhwb3J0cy5NRVRIT0RfTUFQID0gdXRpbHNfMS5lbnVtVG9NYXAoTUVUSE9EUyk7XG4gICAgZXhwb3J0cy5IX01FVEhPRF9NQVAgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhleHBvcnRzLk1FVEhPRF9NQVApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKC9eSC8udGVzdChrZXkpKSB7XG4gICAgICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQW2tleV0gPSBleHBvcnRzLk1FVEhPRF9NQVBba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgRklOSVNIO1xuICAgIChmdW5jdGlvbihGSU5JU0gyKSB7XG4gICAgICBGSU5JU0gyW0ZJTklTSDJbXCJTQUZFXCJdID0gMF0gPSBcIlNBRkVcIjtcbiAgICAgIEZJTklTSDJbRklOSVNIMltcIlNBRkVfV0lUSF9DQlwiXSA9IDFdID0gXCJTQUZFX1dJVEhfQ0JcIjtcbiAgICAgIEZJTklTSDJbRklOSVNIMltcIlVOU0FGRVwiXSA9IDJdID0gXCJVTlNBRkVcIjtcbiAgICB9KShGSU5JU0ggPSBleHBvcnRzLkZJTklTSCB8fCAoZXhwb3J0cy5GSU5JU0ggPSB7fSkpO1xuICAgIGV4cG9ydHMuQUxQSEEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gXCJBXCIuY2hhckNvZGVBdCgwKTsgaSA8PSBcIlpcIi5jaGFyQ29kZUF0KDApOyBpKyspIHtcbiAgICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcbiAgICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMikpO1xuICAgIH1cbiAgICBleHBvcnRzLk5VTV9NQVAgPSB7XG4gICAgICAwOiAwLFxuICAgICAgMTogMSxcbiAgICAgIDI6IDIsXG4gICAgICAzOiAzLFxuICAgICAgNDogNCxcbiAgICAgIDU6IDUsXG4gICAgICA2OiA2LFxuICAgICAgNzogNyxcbiAgICAgIDg6IDgsXG4gICAgICA5OiA5XG4gICAgfTtcbiAgICBleHBvcnRzLkhFWF9NQVAgPSB7XG4gICAgICAwOiAwLFxuICAgICAgMTogMSxcbiAgICAgIDI6IDIsXG4gICAgICAzOiAzLFxuICAgICAgNDogNCxcbiAgICAgIDU6IDUsXG4gICAgICA2OiA2LFxuICAgICAgNzogNyxcbiAgICAgIDg6IDgsXG4gICAgICA5OiA5LFxuICAgICAgQTogMTAsXG4gICAgICBCOiAxMSxcbiAgICAgIEM6IDEyLFxuICAgICAgRDogMTMsXG4gICAgICBFOiAxNCxcbiAgICAgIEY6IDE1LFxuICAgICAgYTogMTAsXG4gICAgICBiOiAxMSxcbiAgICAgIGM6IDEyLFxuICAgICAgZDogMTMsXG4gICAgICBlOiAxNCxcbiAgICAgIGY6IDE1XG4gICAgfTtcbiAgICBleHBvcnRzLk5VTSA9IFtcbiAgICAgIFwiMFwiLFxuICAgICAgXCIxXCIsXG4gICAgICBcIjJcIixcbiAgICAgIFwiM1wiLFxuICAgICAgXCI0XCIsXG4gICAgICBcIjVcIixcbiAgICAgIFwiNlwiLFxuICAgICAgXCI3XCIsXG4gICAgICBcIjhcIixcbiAgICAgIFwiOVwiXG4gICAgXTtcbiAgICBleHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5BTFBIQS5jb25jYXQoZXhwb3J0cy5OVU0pO1xuICAgIGV4cG9ydHMuTUFSSyA9IFtcIi1cIiwgXCJfXCIsIFwiLlwiLCBcIiFcIiwgXCJ+XCIsIFwiKlwiLCBcIidcIiwgXCIoXCIsIFwiKVwiXTtcbiAgICBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5BTFBIQU5VTS5jb25jYXQoZXhwb3J0cy5NQVJLKS5jb25jYXQoW1wiJVwiLCBcIjtcIiwgXCI6XCIsIFwiJlwiLCBcIj1cIiwgXCIrXCIsIFwiJFwiLCBcIixcIl0pO1xuICAgIGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSID0gW1xuICAgICAgXCIhXCIsXG4gICAgICAnXCInLFxuICAgICAgXCIkXCIsXG4gICAgICBcIiVcIixcbiAgICAgIFwiJlwiLFxuICAgICAgXCInXCIsXG4gICAgICBcIihcIixcbiAgICAgIFwiKVwiLFxuICAgICAgXCIqXCIsXG4gICAgICBcIitcIixcbiAgICAgIFwiLFwiLFxuICAgICAgXCItXCIsXG4gICAgICBcIi5cIixcbiAgICAgIFwiL1wiLFxuICAgICAgXCI6XCIsXG4gICAgICBcIjtcIixcbiAgICAgIFwiPFwiLFxuICAgICAgXCI9XCIsXG4gICAgICBcIj5cIixcbiAgICAgIFwiQFwiLFxuICAgICAgXCJbXCIsXG4gICAgICBcIlxcXFxcIixcbiAgICAgIFwiXVwiLFxuICAgICAgXCJeXCIsXG4gICAgICBcIl9cIixcbiAgICAgIFwiYFwiLFxuICAgICAgXCJ7XCIsXG4gICAgICBcInxcIixcbiAgICAgIFwifVwiLFxuICAgICAgXCJ+XCJcbiAgICBdLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbiAgICBleHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIuY29uY2F0KFtcIlx0XCIsIFwiXFxmXCJdKTtcbiAgICBmb3IgKGxldCBpID0gMTI4OyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBleHBvcnRzLlVSTF9DSEFSLnB1c2goaSk7XG4gICAgfVxuICAgIGV4cG9ydHMuSEVYID0gZXhwb3J0cy5OVU0uY29uY2F0KFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJlXCIsIFwiZlwiLCBcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiXSk7XG4gICAgZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBbXG4gICAgICBcIiFcIixcbiAgICAgIFwiI1wiLFxuICAgICAgXCIkXCIsXG4gICAgICBcIiVcIixcbiAgICAgIFwiJlwiLFxuICAgICAgXCInXCIsXG4gICAgICBcIipcIixcbiAgICAgIFwiK1wiLFxuICAgICAgXCItXCIsXG4gICAgICBcIi5cIixcbiAgICAgIFwiXlwiLFxuICAgICAgXCJfXCIsXG4gICAgICBcImBcIixcbiAgICAgIFwifFwiLFxuICAgICAgXCJ+XCJcbiAgICBdLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbiAgICBleHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4uY29uY2F0KFtcIiBcIl0pO1xuICAgIGV4cG9ydHMuSEVBREVSX0NIQVJTID0gW1wiXHRcIl07XG4gICAgZm9yIChsZXQgaSA9IDMyOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBpZiAoaSAhPT0gMTI3KSB7XG4gICAgICAgIGV4cG9ydHMuSEVBREVSX0NIQVJTLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTLmZpbHRlcigoYykgPT4gYyAhPT0gNDQpO1xuICAgIGV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLk5VTV9NQVA7XG4gICAgZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG4gICAgdmFyIEhFQURFUl9TVEFURTtcbiAgICAoZnVuY3Rpb24oSEVBREVSX1NUQVRFMikge1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiR0VORVJBTFwiXSA9IDBdID0gXCJHRU5FUkFMXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJDT05ORUNUSU9OXCJdID0gMV0gPSBcIkNPTk5FQ1RJT05cIjtcbiAgICAgIEhFQURFUl9TVEFURTJbSEVBREVSX1NUQVRFMltcIkNPTlRFTlRfTEVOR1RIXCJdID0gMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDNdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgICAgSEVBREVSX1NUQVRFMltIRUFERVJfU1RBVEUyW1wiVVBHUkFERVwiXSA9IDRdID0gXCJVUEdSQURFXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSA1XSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgICBIRUFERVJfU1RBVEUyW0hFQURFUl9TVEFURTJbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gNl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICAgIEhFQURFUl9TVEFURTJbSEVBREVSX1NUQVRFMltcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDddID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICAgIEhFQURFUl9TVEFURTJbSEVBREVSX1NUQVRFMltcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIl0gPSA4XSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwiO1xuICAgIH0pKEhFQURFUl9TVEFURSA9IGV4cG9ydHMuSEVBREVSX1NUQVRFIHx8IChleHBvcnRzLkhFQURFUl9TVEFURSA9IHt9KSk7XG4gICAgZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSB7XG4gICAgICBcImNvbm5lY3Rpb25cIjogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgICBcImNvbnRlbnQtbGVuZ3RoXCI6IEhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAgIFwicHJveHktY29ubmVjdGlvblwiOiBIRUFERVJfU1RBVEUuQ09OTkVDVElPTixcbiAgICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIjogSEVBREVSX1NUQVRFLlRSQU5TRkVSX0VOQ09ESU5HLFxuICAgICAgXCJ1cGdyYWRlXCI6IEhFQURFUl9TVEFURS5VUEdSQURFXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHAud2FzbS5qc1xudmFyIHJlcXVpcmVfbGxodHRwX3dhc20gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLndhc20uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gXCJBR0Z6YlFFQUFBQUJNQWhnQVg4QmYyQURmMzkvQVg5Z0JIOS9mMzhCZjJBQUFHQURmMzkvQUdBQmZ3QmdBbjkvQUdBR2YzOS9mMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFDQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXprNEF3TUVBQUFGQUFBQUFBQUFCUUVGQUFVRkJRQUFCZ0FBQUFZR0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBQUJBUWNBQUFVRkFBTUVCUUZ3QVE0T0JRTUJBQUlHQ0FGL0FVR0F1QVFMQi9VRUh3WnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFKR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUtHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQTFER3hzYUhSMGNGOWhiR3h2WXdBTUJtMWhiR3h2WXdBNkMyeHNhSFIwY0Y5bWNtVmxBQTBFWm5KbFpRQThEMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU9GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBUEZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FRRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJFV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFTRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBVERHeHNhSFIwY0Y5eVpYTmxkQUFVRG14c2FIUjBjRjlsZUdWamRYUmxBQlVVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZnMXNiR2gwZEhCZlptbHVhWE5vQUJjTWJHeG9kSFJ3WDNCaGRYTmxBQmdOYkd4b2RIUndYM0psYzNWdFpRQVpHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFhRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR3hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FjRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQjBVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhoRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWZFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFnR214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5b1pXRmtaWEp6QUNFaGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyTm9kVzVyWldSZmJHVnVaM1JvQUNJWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQURNSkV3RUFRUUVMRFFFQ0F3UUZDd1lITGlvb0pDWUt4cWdDT0FJQUN3Z0FFSWlBZ0lBQUN4a0FJQUFRdG9DQWdBQWFJQUFnQWpZQ05DQUFJQUU2QUNnTEhBQWdBQ0FBTHdFeUlBQXRBQzRnQUJDMWdJQ0FBQkNBZ0lDQUFBc3BBUUYvUVRnUXVvQ0FnQUFpQVJDMmdJQ0FBQm9nQVVHQWlJQ0FBRFlDTkNBQklBQTZBQ2dnQVFzS0FDQUFFTHlBZ0lBQUN3Y0FJQUF0QUNnTEJ3QWdBQzBBS2dzSEFDQUFMUUFyQ3djQUlBQXRBQ2tMQndBZ0FDOEJNZ3NIQUNBQUxRQXVDMFVCQkg4Z0FDZ0NHQ0VCSUFBdEFDMGhBaUFBTFFBb0lRTWdBQ2dDTkNFRUlBQVF0b0NBZ0FBYUlBQWdCRFlDTkNBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBc1JBQ0FBSUFFZ0FTQUNhaEMzZ0lDQUFBdEZBQ0FBUWdBM0FnQWdBRUV3YWtJQU53SUFJQUJCS0dwQ0FEY0NBQ0FBUVNCcVFnQTNBZ0FnQUVFWWFrSUFOd0lBSUFCQkVHcENBRGNDQUNBQVFRaHFRZ0EzQWdBTFp3RUJmMEVBSVFFQ1FDQUFLQUlNRFFBQ1FBSkFBa0FDUUNBQUxRQXZEZ01CQUFNQ0N5QUFLQUkwSWdGRkRRQWdBU2dDSENJQlJRMEFJQUFnQVJHQWdJQ0FBQUFpQVEwREMwRUFEd3NRdjRDQWdBQUFDeUFBUWYrUmdJQUFOZ0lRUVE0aEFRc2dBUXNlQUFKQUlBQW9BZ3dOQUNBQVFZU1VnSUFBTmdJUUlBQkJGVFlDREFzTEZnQUNRQ0FBS0FJTVFSVkhEUUFnQUVFQU5nSU1Dd3NXQUFKQUlBQW9BZ3hCRmtjTkFDQUFRUUEyQWd3TEN3Y0FJQUFvQWd3TEJ3QWdBQ2dDRUFzSkFDQUFJQUUyQWhBTEJ3QWdBQ2dDRkFzaUFBSkFJQUJCR2trTkFCQy9nSUNBQUFBTElBQkJBblJCeUp1QWdBQnFLQUlBQ3lJQUFrQWdBRUV1U1EwQUVMK0FnSUFBQUFzZ0FFRUNkRUd3bklDQUFHb29BZ0FMRmdBZ0FDQUFMUUF0UWY0QmNTQUJRUUJIY2pvQUxRc1pBQ0FBSUFBdEFDMUIvUUZ4SUFGQkFFZEJBWFJ5T2dBdEN5NEJBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWdBaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0JDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUVp5T2dJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSW9JZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BZ2dpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSFNpb0NBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDTENJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJTUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCM1pPQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0FqQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NFQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjT1FnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUkwSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWhRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ0hDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSVlJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjBvaUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BaUFpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDSkNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEZBUUYvQWtBQ1FDQUFMd0V3UVJSeFFSUkhEUUJCQVNFRElBQXRBQ2hCQVVZTkFTQUFMd0V5UWVVQVJpRUREQUVMSUFBdEFDbEJCVVloQXdzZ0FDQURPZ0F1UVFBTDhnRUJBMzlCQVNFREFrQWdBQzhCTUNJRVFRaHhEUUFnQUNrRElFSUFVaUVEQ3dKQUFrQWdBQzBBTGtVTkFFRUJJUVVnQUMwQUtVRUZSZzBCUVFFaEJTQUVRY0FBY1VVZ0EzRkJBVWNOQVF0QkFDRUZJQVJCd0FCeERRQkJBaUVGSUFSQkNIRU5BQUpBSUFSQmdBUnhSUTBBQWtBZ0FDMEFLRUVCUncwQUlBQXRBQzFCQ25FTkFFRUZEd3RCQkE4TEFrQWdCRUVnY1EwQUFrQWdBQzBBS0VFQlJnMEFJQUF2QVRJaUFFR2NmMnBCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQVFRUWhCU0FFUVlnRWNVR0FCRVlOQWlBRVFTaHhSUTBDQzBFQUR3dEJBRUVESUFBcEF5QlFHeUVGQ3lBRkMxMEJBbjlCQUNFQkFrQWdBQzBBS0VFQlJnMEFJQUF2QVRJaUFrR2NmMnBCNUFCSkRRQWdBa0hNQVVZTkFDQUNRYkFDUmcwQUlBQXZBVEFpQUVIQUFIRU5BRUVCSVFFZ0FFR0lCSEZCZ0FSR0RRQWdBRUVvY1VVaEFRc2dBUXVpQVFFRGZ3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFRElBQXZBVEFpQkVFQ2NVVU5BUXdDQzBFQUlRTWdBQzhCTUNJRVFRRnhSUTBCQzBFQklRTWdBQzBBS0VFQlJnMEFJQUF2QVRJaUJVR2NmMnBCNUFCSkRRQWdCVUhNQVVZTkFDQUZRYkFDUmcwQUlBUkJ3QUJ4RFFCQkFDRURJQVJCaUFSeFFZQUVSZzBBSUFSQktIRkJBRWNoQXdzZ0FFRUFPd0V3SUFCQkFEb0FMeUFEQzVRQkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRRWdBQzhCTUNJQ1FRSnhSUTBCREFJTFFRQWhBU0FBTHdFd0lnSkJBWEZGRFFFTFFRRWhBU0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUFRWngvYWtIa0FFa05BQ0FBUWN3QlJnMEFJQUJCc0FKR0RRQWdBa0hBQUhFTkFFRUFJUUVnQWtHSUJIRkJnQVJHRFFBZ0FrRW9jVUVBUnlFQkN5QUJDMDhBSUFCQkdHcENBRGNEQUNBQVFnQTNBd0FnQUVFd2FrSUFOd01BSUFCQktHcENBRGNEQUNBQVFTQnFRZ0EzQXdBZ0FFRVFha0lBTndNQUlBQkJDR3BDQURjREFDQUFRYndCTmdJY1FRQUxld0VCZndKQUlBQW9BZ3dpQXcwQUFrQWdBQ2dDQkVVTkFDQUFJQUUyQWdRTEFrQWdBQ0FCSUFJUXVJQ0FnQUFpQXcwQUlBQW9BZ3dQQ3lBQUlBTTJBaHhCQUNFRElBQW9BZ1FpQVVVTkFDQUFJQUVnQWlBQUtBSUlFWUdBZ0lBQUFDSUJSUTBBSUFBZ0FqWUNGQ0FBSUFFMkFnd2dBU0VEQ3lBREM5UE9BUU1jZndOK0JYOGpnSUNBZ0FCQkVHc2lBeVNBZ0lDQUFDQUJJUVFnQVNFRklBRWhCaUFCSVFjZ0FTRUlJQUVoQ1NBQklRb2dBU0VMSUFFaERDQUJJUTBnQVNFT0lBRWhEeUFCSVJBZ0FTRVJJQUVoRWlBQklSTWdBU0VVSUFFaEZTQUJJUllnQVNFWElBRWhHQ0FCSVJrZ0FTRWFJQUVoR3lBQklSd2dBU0VkQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUNnQ0hDSWVRWDlxRHJ3QnR3RUJ0Z0VDQXdRRkJnY0lDUW9MREEwT0R4REFBYjhCRVJJVHRRRVVGUllYR0JrYXZRRzhBUnNjSFI0ZklDRzBBYk1CSWlPeUFiRUJKQ1VtSnlncEtpc3NMUzR2TURFeU16UTFOamM0T1RxNEFUczhQVDQvUUVGQ1EwUkZSa2RJU1VwTFRFMU9UMUJSVWxOVVZWWlhXRmxhVzF4ZFhsOWdZV0pqWkdWbVoyaHBhbXRzYlc1dmNIRnljM1IxZG5kNGVYcDdmSDErZjRBQmdRR0NBWU1CaEFHRkFZWUJod0dJQVlrQmlnR0xBWXdCalFHT0FZOEJrQUdSQVpJQmt3R1VBWlVCbGdHWEFaZ0JtUUdhQVpzQm5BR2RBWjRCbndHZ0FhRUJvZ0dqQWFRQnBRR21BYWNCcUFHcEFhb0Jxd0dzQWEwQnJnR3ZBUUM1QVF0QkFDRWVESzhCQzBFUElSNE1yZ0VMUVE0aEhneXRBUXRCRUNFZURLd0JDMEVSSVI0TXF3RUxRUlFoSGd5cUFRdEJGU0VlREtrQkMwRVdJUjRNcUFFTFFSY2hIZ3luQVF0QkdDRWVES1lCQzBFSUlSNE1wUUVMUVJraEhneWtBUXRCR2lFZURLTUJDMEVUSVI0TW9nRUxRUkloSGd5aEFRdEJHeUVlREtBQkMwRWNJUjRNbndFTFFSMGhIZ3llQVF0QkhpRWVESjBCQzBHcUFTRWVESndCQzBHckFTRWVESnNCQzBFZ0lSNE1tZ0VMUVNFaEhneVpBUXRCSWlFZURKZ0JDMEVqSVI0TWx3RUxRU1FoSGd5V0FRdEJyUUVoSGd5VkFRdEJKU0VlREpRQkMwRXBJUjRNa3dFTFFRMGhIZ3lTQVF0QkppRWVESkVCQzBFbklSNE1rQUVMUVNnaEhneVBBUXRCTGlFZURJNEJDMEVxSVI0TWpRRUxRYTRCSVI0TWpBRUxRUXdoSGd5TEFRdEJMeUVlRElvQkMwRXJJUjRNaVFFTFFRc2hIZ3lJQVF0QkxDRWVESWNCQzBFdElSNE1oZ0VMUVFvaEhneUZBUXRCTVNFZURJUUJDMEV3SVI0TWd3RUxRUWtoSGd5Q0FRdEJIeUVlRElFQkMwRXlJUjRNZ0FFTFFUTWhIZ3gvQzBFMElSNE1mZ3RCTlNFZURIMExRVFloSGd4OEMwRTNJUjRNZXd0Qk9DRWVESG9MUVRraEhneDVDMEU2SVI0TWVBdEJyQUVoSGd4M0MwRTdJUjRNZGd0QlBDRWVESFVMUVQwaEhneDBDMEUrSVI0TWN3dEJQeUVlREhJTFFjQUFJUjRNY1F0QndRQWhIZ3h3QzBIQ0FDRWVERzhMUWNNQUlSNE1iZ3RCeEFBaEhneHRDMEVISVI0TWJBdEJ4UUFoSGd4ckMwRUdJUjRNYWd0QnhnQWhIZ3hwQzBFRklSNE1hQXRCeHdBaEhneG5DMEVFSVI0TVpndEJ5QUFoSGd4bEMwSEpBQ0VlREdRTFFjb0FJUjRNWXd0Qnl3QWhIZ3hpQzBFRElSNE1ZUXRCekFBaEhneGdDMEhOQUNFZURGOExRYzRBSVI0TVhndEIwQUFoSGd4ZEMwSFBBQ0VlREZ3TFFkRUFJUjRNV3d0QjBnQWhIZ3hhQzBFQ0lSNE1XUXRCMHdBaEhneFlDMEhVQUNFZURGY0xRZFVBSVI0TVZndEIxZ0FoSGd4VkMwSFhBQ0VlREZRTFFkZ0FJUjRNVXd0QjJRQWhIZ3hTQzBIYUFDRWVERkVMUWRzQUlSNE1VQXRCM0FBaEhneFBDMEhkQUNFZURFNExRZDRBSVI0TVRRdEIzd0FoSGd4TUMwSGdBQ0VlREVzTFFlRUFJUjRNU2d0QjRnQWhIZ3hKQzBIakFDRWVERWdMUWVRQUlSNE1Sd3RCNVFBaEhneEdDMEhtQUNFZURFVUxRZWNBSVI0TVJBdEI2QUFoSGd4REMwSHBBQ0VlREVJTFFlb0FJUjRNUVF0QjZ3QWhIZ3hBQzBIc0FDRWVERDhMUWUwQUlSNE1QZ3RCN2dBaEhndzlDMEh2QUNFZUREd0xRZkFBSVI0TU93dEI4UUFoSGd3NkMwSHlBQ0VlRERrTFFmTUFJUjRNT0F0QjlBQWhIZ3czQzBIMUFDRWVERFlMUWZZQUlSNE1OUXRCOXdBaEhndzBDMEg0QUNFZURETUxRZmtBSVI0TU1ndEIrZ0FoSGd3eEMwSDdBQ0VlRERBTFFmd0FJUjRNTHd0Qi9RQWhIZ3d1QzBIK0FDRWVEQzBMUWY4QUlSNE1MQXRCZ0FFaEhnd3JDMEdCQVNFZURDb0xRWUlCSVI0TUtRdEJnd0VoSGd3b0MwR0VBU0VlRENjTFFZVUJJUjRNSmd0QmhnRWhIZ3dsQzBHSEFTRWVEQ1FMUVlnQklSNE1Jd3RCaVFFaEhnd2lDMEdLQVNFZURDRUxRWXNCSVI0TUlBdEJqQUVoSGd3ZkMwR05BU0VlREI0TFFZNEJJUjRNSFF0Qmp3RWhIZ3djQzBHUUFTRWVEQnNMUVpFQklSNE1HZ3RCa2dFaEhnd1pDMEdUQVNFZURCZ0xRWlFCSVI0TUZ3dEJsUUVoSGd3V0MwR1dBU0VlREJVTFFaY0JJUjRNRkF0Qm1BRWhIZ3dUQzBHWkFTRWVEQklMUVowQklSNE1FUXRCbWdFaEhnd1FDMEVCSVI0TUR3dEJtd0VoSGd3T0MwR2NBU0VlREEwTFFaNEJJUjRNREF0Qm9BRWhIZ3dMQzBHZkFTRWVEQW9MUWFFQklSNE1DUXRCb2dFaEhnd0lDMEdqQVNFZURBY0xRYVFCSVI0TUJndEJwUUVoSGd3RkMwR21BU0VlREFRTFFhY0JJUjRNQXd0QnFBRWhIZ3dDQzBHcEFTRWVEQUVMUWE4QklSNExBMEFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdIZzZ3QVFBQkFnTUVCUVlIQ0FrS0N3d05EZzhRRVJJVEZCVVdGeGdhSEI0ZklDTWtKU1luS0NrcUxDMHVMekQ3QWpRMk9EazhQMEZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5WVjFsY1hWNWdZbU5rWldabmFHdHNiVzV2Y0hGeWMzUjFkbmQ0ZVhwN2ZIMStmNEFCZ1FHQ0FZTUJoQUdGQVlZQmh3R0lBWWtCaWdHTEFZd0JqUUdPQVk4QmtBR1JBWklCa3dHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0Fkb0I0QUhoQWVRQjhRRzlBcjBDQ3lBQklnZ2dBa2NOd2dGQnZBRWhIZ3lWQXdzZ0FTSWVJQUpIRGJFQlFhd0JJUjRNbEFNTElBRWlBU0FDUncxblFlSUFJUjRNa3dNTElBRWlBU0FDUncxZFFkb0FJUjRNa2dNTElBRWlBU0FDUncxV1FkVUFJUjRNa1FNTElBRWlBU0FDUncxU1FkTUFJUjRNa0FNTElBRWlBU0FDUncxUFFkRUFJUjRNandNTElBRWlBU0FDUncxTVFjOEFJUjRNamdNTElBRWlBU0FDUncwUVFRd2hIZ3lOQXdzZ0FTSUJJQUpIRFROQk9DRWVESXdEQ3lBQklnRWdBa2NOTDBFMUlSNE1pd01MSUFFaUFTQUNSdzBtUVRJaEhneUtBd3NnQVNJQklBSkhEU1JCTHlFZURJa0RDeUFCSWdFZ0FrY05IVUVrSVI0TWlBTUxJQUF0QUM1QkFVWU4vUUlNeHdFTElBQWdBU0lCSUFJUXRJQ0FnQUJCQVVjTnRBRU10UUVMSUFBZ0FTSUJJQUlRcllDQWdBQWlIZzIxQVNBQklRRU1zQUlMQWtBZ0FTSUJJQUpIRFFCQkJpRWVESVVEQ3lBQUlBRkJBV29pQVNBQ0VMQ0FnSUFBSWg0TnRnRWdBU0VCREE4TElBQkNBRGNESUVFVElSNE04d0lMSUFFaUhpQUNSdzBKUVE4aEhneUNBd3NDUUNBQklnRWdBa1lOQUNBQlFRRnFJUUZCRVNFZURQSUNDMEVISVI0TWdRTUxJQUJDQUNBQUtRTWdJaDhnQWlBQkloNXJyU0lnZlNJaElDRWdIMVliTndNZ0lCOGdJRllpSWtVTnN3RkJDQ0VlRElBREN3SkFJQUVpQVNBQ1JnMEFJQUJCaVlDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFVklSNE04QUlMUVFraEhnei9BZ3NnQVNFQklBQXBBeUJRRGJJQklBRWhBUXl0QWdzQ1FDQUJJZ0VnQWtjTkFFRUxJUjRNL2dJTElBQWdBVUVCYWlJQklBSVFyNENBZ0FBaUhnMnlBU0FCSVFFTXJRSUxBMEFDUUNBQkxRQUFRZkNkZ0lBQWFpMEFBQ0llUVFGR0RRQWdIa0VDUncyMEFTQUJRUUZxSVFFTUF3c2dBVUVCYWlJQklBSkhEUUFMUVF3aEhnejhBZ3NDUUNBQklnRWdBa2NOQUVFTklSNE0vQUlMQWtBQ1FDQUJMUUFBSWg1QmMyb09GQUcyQWJZQnRnRzJBYllCdGdHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCdGdHMkFiWUJ0Z0VBdEFFTElBRkJBV29oQVF5MEFRc2dBVUVCYWlFQkMwRVlJUjRNNmdJTEFrQWdBU0llSUFKSERRQkJEaUVlRFBvQ0MwSUFJUjhnSGlFQkFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FlTFFBQVFWQnFEamZJQWNjQkFBRUNBd1FGQmdlK0FyNEN2Z0srQXI0Q3ZnSytBZ2dKQ2dzTURiNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdJT0R4QVJFaE8rQWd0Q0FpRWZETWNCQzBJRElSOE14Z0VMUWdRaEh3ekZBUXRDQlNFZkRNUUJDMElHSVI4TXd3RUxRZ2NoSHd6Q0FRdENDQ0VmRE1FQkMwSUpJUjhNd0FFTFFnb2hId3kvQVF0Q0N5RWZETDRCQzBJTUlSOE12UUVMUWcwaEh3eThBUXRDRGlFZkRMc0JDMElQSVI4TXVnRUxRZ29oSHd5NUFRdENDeUVmRExnQkMwSU1JUjhNdHdFTFFnMGhId3kyQVF0Q0RpRWZETFVCQzBJUElSOE10QUVMUWdBaEh3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnSGkwQUFFRlFhZzQzeHdIR0FRQUJBZ01FQlFZSHlBSElBY2dCeUFISUFjZ0J5QUVJQ1FvTERBM0lBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQkRnOFFFUklUeUFFTFFnSWhId3pHQVF0Q0F5RWZETVVCQzBJRUlSOE14QUVMUWdVaEh3ekRBUXRDQmlFZkRNSUJDMElISVI4TXdRRUxRZ2doSHd6QUFRdENDU0VmREw4QkMwSUtJUjhNdmdFTFFnc2hId3k5QVF0Q0RDRWZETHdCQzBJTklSOE11d0VMUWc0aEh3eTZBUXRDRHlFZkRMa0JDMElLSVI4TXVBRUxRZ3NoSHd5M0FRdENEQ0VmRExZQkMwSU5JUjhNdFFFTFFnNGhId3kwQVF0Q0R5RWZETE1CQ3lBQVFnQWdBQ2tESUNJZklBSWdBU0llYTYwaUlIMGlJU0FoSUI5V0d6Y0RJQ0FmSUNCV0lpSkZEYlFCUVJFaEhnejNBZ3NDUUNBQklnRWdBa1lOQUNBQVFZbUFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJHeUVlRE9jQ0MwRVNJUjRNOWdJTElBQWdBU0llSUFJUXNvQ0FnQUJCZjJvT0JhWUJBS0lDQWJNQnRBRUxRUkloSGd6a0Fnc2dBRUVCT2dBdklCNGhBUXp5QWdzZ0FTSUJJQUpIRGJRQlFSWWhIZ3p5QWdzZ0FTSWNJQUpIRFJsQk9TRWVEUEVDQ3dKQUlBRWlBU0FDUncwQVFSb2hIZ3p4QWdzZ0FFRUFOZ0lFSUFCQmlvQ0FnQUEyQWdnZ0FDQUJJQUVRcW9DQWdBQWlIZzIyQVNBQklRRU11UUVMQWtBZ0FTSWVJQUpIRFFCQkd5RWVEUEFDQ3dKQUlCNHRBQUFpQVVFZ1J3MEFJQjVCQVdvaEFRd2FDeUFCUVFsSERiWUJJQjVCQVdvaEFRd1pDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBUXdVQzBFY0lSNE03Z0lMQWtBZ0FTSWVJQUpIRFFCQkhTRWVETzRDQ3dKQUlCNHRBQUFpQVVFSlJ3MEFJQjRoQVF6U0Fnc2dBVUVnUncyMUFTQWVJUUVNMFFJTEFrQWdBU0lCSUFKSERRQkJIaUVlRE8wQ0N5QUJMUUFBUVFwSERiZ0JJQUZCQVdvaEFReWdBZ3NnQVNJQklBSkhEYmdCUVNJaEhnenJBZ3NEUUFKQUlBRXRBQUFpSGtFZ1JnMEFBa0FnSGtGMmFnNEVBTDRCdmdFQXZBRUxJQUVoQVF6RUFRc2dBVUVCYWlJQklBSkhEUUFMUVNRaEhnenFBZ3RCSlNFZUlBRWlJeUFDUmczcEFpQUNJQ05ySUFBb0FnQWlKR29oSlNBaklTWWdKQ0VCQWtBRFFDQW1MUUFBSWlKQklISWdJaUFpUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZDZmdJQUFhaTBBQUVjTkFTQUJRUU5HRGRZQ0lBRkJBV29oQVNBbVFRRnFJaVlnQWtjTkFBc2dBQ0FsTmdJQURPb0NDeUFBUVFBMkFnQWdKaUVCRExzQkMwRW1JUjRnQVNJaklBSkdEZWdDSUFJZ0kyc2dBQ2dDQUNJa2FpRWxJQ01oSmlBa0lRRUNRQU5BSUNZdEFBQWlJa0VnY2lBaUlDSkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkI5SitBZ0FCcUxRQUFSdzBCSUFGQkNFWU52UUVnQVVFQmFpRUJJQ1pCQVdvaUppQUNSdzBBQ3lBQUlDVTJBZ0FNNlFJTElBQkJBRFlDQUNBbUlRRU11Z0VMUVNjaEhpQUJJaU1nQWtZTjV3SWdBaUFqYXlBQUtBSUFJaVJxSVNVZ0l5RW1JQ1FoQVFKQUEwQWdKaTBBQUNJaVFTQnlJQ0lnSWtHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVIUXBvQ0FBR290QUFCSERRRWdBVUVGUmcyOUFTQUJRUUZxSVFFZ0prRUJhaUltSUFKSERRQUxJQUFnSlRZQ0FBem9BZ3NnQUVFQU5nSUFJQ1loQVF5NUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBRUdBb29DQUFHb3RBQUFpSGtFQlJnMEFJQjVCQWtZTkNpQUJJUUVNd1FFTElBRkJBV29pQVNBQ1J3MEFDMEVqSVI0TTV3SUxRU01oSGd6bUFnc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0llUVNCR0RRQWdIa0YyYWc0RXZRRytBYjRCdlFHK0FRc2dBVUVCYWlJQklBSkhEUUFMUVNzaEhnem1BZ3RCS3lFZURPVUNDd05BQWtBZ0FTMEFBQ0llUVNCR0RRQWdIa0VKUncwREN5QUJRUUZxSWdFZ0FrY05BQXRCTHlFZURPUUNDd05BQWtBZ0FTMEFBQ0llUVNCR0RRQUNRQUpBSUI1QmRtb09CTDRCQVFHK0FRQUxJQjVCTEVZTnZ3RUxJQUVoQVF3RUN5QUJRUUZxSWdFZ0FrY05BQXRCTWlFZURPTUNDeUFCSVFFTXZ3RUxRVE1oSGlBQklpWWdBa1lONFFJZ0FpQW1heUFBS0FJQUlpTnFJU1FnSmlFaUlDTWhBUUpBQTBBZ0lpMEFBRUVnY2lBQlFZQ2tnSUFBYWkwQUFFY05BU0FCUVFaR0RkQUNJQUZCQVdvaEFTQWlRUUZxSWlJZ0FrY05BQXNnQUNBa05nSUFET0lDQ3lBQVFRQTJBZ0FnSWlFQkMwRXJJUjRNMEFJTEFrQWdBU0lkSUFKSERRQkJOQ0VlRE9BQ0N5QUFRWXFBZ0lBQU5nSUlJQUFnSFRZQ0JDQWRJUUVnQUMwQUxFRi9hZzRFcndHNUFic0J2UUhIQWdzZ0FVRUJhaUVCREs0QkN3SkFJQUVpQVNBQ1JnMEFBMEFDUUNBQkxRQUFJaDVCSUhJZ0hpQWVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTSWVRUWxHRFFBZ0hrRWdSZzBBQWtBQ1FBSkFBa0FnSGtHZGYyb09Fd0FEQXdNREF3TURBUU1EQXdNREF3TURBd0lEQ3lBQlFRRnFJUUZCSmlFZUROTUNDeUFCUVFGcUlRRkJKeUVlRE5JQ0N5QUJRUUZxSVFGQktDRWVETkVDQ3lBQklRRU1zZ0VMSUFGQkFXb2lBU0FDUncwQUMwRW9JUjRNM2dJTFFTZ2hIZ3pkQWdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFR0FvSUNBQUdvdEFBQkJBVVlOQUNBQklRRU10d0VMSUFGQkFXb2lBU0FDUncwQUMwRXdJUjRNM1FJTFFUQWhIZ3pjQWdzQ1FBTkFBa0FnQVMwQUFFRjNhZzRZQUFMQkFzRUN4d0xCQXNFQ3dRTEJBc0VDd1FMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDd1FMQkFzRUN3UUlBd1FJTElBRkJBV29pQVNBQ1J3MEFDMEUxSVI0TTNBSUxJQUZCQVdvaEFRdEJJU0VlRE1vQ0N5QUJJZ0VnQWtjTnVRRkJOeUVlRE5rQ0N3TkFBa0FnQVMwQUFFR1FwSUNBQUdvdEFBQkJBVVlOQUNBQklRRU1rQUlMSUFGQkFXb2lBU0FDUncwQUMwRTRJUjRNMkFJTElCd3RBQUFpSGtFZ1JnMmFBU0FlUVRwSERjWUNJQUFvQWdRaEFTQUFRUUEyQWdRZ0FDQUJJQndRcUlDQWdBQWlBUTIyQVNBY1FRRnFJUUVNdUFFTElBQWdBU0FDRUttQWdJQUFHZ3RCQ2lFZURNVUNDMEU2SVI0Z0FTSW1JQUpHRGRRQ0lBSWdKbXNnQUNnQ0FDSWphaUVrSUNZaEhDQWpJUUVDUUFOQUlCd3RBQUFpSWtFZ2NpQWlJQ0pCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCa0thQWdBQnFMUUFBUnczRUFpQUJRUVZHRFFFZ0FVRUJhaUVCSUJ4QkFXb2lIQ0FDUncwQUN5QUFJQ1EyQWdBTTFRSUxJQUJCQURZQ0FDQUFRUUU2QUN3Z0ppQWphMEVHYWlFQkRMNENDMEU3SVI0Z0FTSW1JQUpHRGRNQ0lBSWdKbXNnQUNnQ0FDSWphaUVrSUNZaEhDQWpJUUVDUUFOQUlCd3RBQUFpSWtFZ2NpQWlJQ0pCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCbHFhQWdBQnFMUUFBUnczREFpQUJRUWxHRFFFZ0FVRUJhaUVCSUJ4QkFXb2lIQ0FDUncwQUN5QUFJQ1EyQWdBTTFBSUxJQUJCQURZQ0FDQUFRUUk2QUN3Z0ppQWphMEVLYWlFQkRMMENDd0pBSUFFaUhDQUNSdzBBUVR3aEhnelRBZ3NDUUFKQUlCd3RBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWkovYWc0SEFNTUN3d0xEQXNNQ3d3SUJ3d0lMSUJ4QkFXb2hBVUV5SVI0TXd3SUxJQnhCQVdvaEFVRXpJUjRNd2dJTFFUMGhIaUFCSWlZZ0FrWU4wUUlnQWlBbWF5QUFLQUlBSWlOcUlTUWdKaUVjSUNNaEFRTkFJQnd0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQm9LYUFnQUJxTFFBQVJ3M0FBaUFCUVFGR0RiUUNJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETkVDQzBFK0lSNGdBU0ltSUFKR0RkQUNJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhIQ0FqSVFFQ1FBTkFJQnd0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQm9xYUFnQUJxTFFBQVJ3M0FBaUFCUVE1R0RRRWdBVUVCYWlFQklCeEJBV29pSENBQ1J3MEFDeUFBSUNRMkFnQU0wUUlMSUFCQkFEWUNBQ0FBUVFFNkFDd2dKaUFqYTBFUGFpRUJETG9DQzBFL0lSNGdBU0ltSUFKR0RjOENJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhIQ0FqSVFFQ1FBTkFJQnd0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQndLYUFnQUJxTFFBQVJ3Mi9BaUFCUVE5R0RRRWdBVUVCYWlFQklCeEJBV29pSENBQ1J3MEFDeUFBSUNRMkFnQU0wQUlMSUFCQkFEWUNBQ0FBUVFNNkFDd2dKaUFqYTBFUWFpRUJETGtDQzBIQUFDRWVJQUVpSmlBQ1JnM09BaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUndnSXlFQkFrQURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFkQ21nSUFBYWkwQUFFY052Z0lnQVVFRlJnMEJJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETThDQ3lBQVFRQTJBZ0FnQUVFRU9nQXNJQ1lnSTJ0QkJtb2hBUXk0QWdzQ1FDQUJJaHdnQWtjTkFFSEJBQ0VlRE00Q0N3SkFBa0FDUUFKQUlCd3RBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWjEvYWc0VEFNQUN3QUxBQXNBQ3dBTEFBc0FDd0FMQUFzQUN3QUxBQWdIQUFzQUN3QUlDQThBQ0N5QWNRUUZxSVFGQk5TRWVETUFDQ3lBY1FRRnFJUUZCTmlFZURMOENDeUFjUVFGcUlRRkJOeUVlREw0Q0N5QWNRUUZxSVFGQk9DRWVETDBDQ3dKQUlBRWlBU0FDUmcwQUlBQkJpNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUU1SVI0TXZRSUxRY0lBSVI0TXpBSUxJQUVpQVNBQ1J3MnZBVUhFQUNFZURNc0NDMEhGQUNFZUlBRWlKaUFDUmczS0FpQUNJQ1pySUFBb0FnQWlJMm9oSkNBbUlTSWdJeUVCQWtBRFFDQWlMUUFBSUFGQjFxYUFnQUJxTFFBQVJ3MjBBU0FCUVFGR0RRRWdBVUVCYWlFQklDSkJBV29pSWlBQ1J3MEFDeUFBSUNRMkFnQU15d0lMSUFCQkFEWUNBQ0FtSUNOclFRSnFJUUVNcndFTEFrQWdBU0lCSUFKSERRQkJ4d0FoSGd6S0Fnc2dBUzBBQUVFS1J3MnpBU0FCUVFGcUlRRU1yd0VMQWtBZ0FTSUJJQUpIRFFCQnlBQWhIZ3pKQWdzQ1FBSkFJQUV0QUFCQmRtb09CQUcwQWJRQkFMUUJDeUFCUVFGcUlRRkJQU0VlRExrQ0N5QUJRUUZxSVFFTXJnRUxBa0FnQVNJQklBSkhEUUJCeVFBaEhneklBZ3RCQUNFZUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdxN0Fib0JBQUVDQXdRRkJnZThBUXRCQWlFZURMb0JDMEVESVI0TXVRRUxRUVFoSGd5NEFRdEJCU0VlRExjQkMwRUdJUjRNdGdFTFFRY2hIZ3kxQVF0QkNDRWVETFFCQzBFSklSNE1zd0VMQWtBZ0FTSUJJQUpIRFFCQnlnQWhIZ3pIQWdzZ0FTMEFBRUV1UncyMEFTQUJRUUZxSVFFTWdBSUxBa0FnQVNJQklBSkhEUUJCeXdBaEhnekdBZ3RCQUNFZUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdxOUFid0JBQUVDQXdRRkJnZStBUXRCQWlFZURMd0JDMEVESVI0TXV3RUxRUVFoSGd5NkFRdEJCU0VlRExrQkMwRUdJUjRNdUFFTFFRY2hIZ3kzQVF0QkNDRWVETFlCQzBFSklSNE10UUVMUWN3QUlSNGdBU0ltSUFKR0RjUUNJQUlnSm1zZ0FDZ0NBQ0lqYWlFa0lDWWhBU0FqSVNJRFFDQUJMUUFBSUNKQjRxYUFnQUJxTFFBQVJ3MjRBU0FpUVFOR0RiY0JJQ0pCQVdvaElpQUJRUUZxSWdFZ0FrY05BQXNnQUNBa05nSUFETVFDQzBITkFDRWVJQUVpSmlBQ1JnM0RBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUUVnSXlFaUEwQWdBUzBBQUNBaVFlYW1nSUFBYWkwQUFFY050d0VnSWtFQ1JnMjVBU0FpUVFGcUlTSWdBVUVCYWlJQklBSkhEUUFMSUFBZ0pEWUNBQXpEQWd0QnpnQWhIaUFCSWlZZ0FrWU53Z0lnQWlBbWF5QUFLQUlBSWlOcUlTUWdKaUVCSUNNaElnTkFJQUV0QUFBZ0lrSHBwb0NBQUdvdEFBQkhEYllCSUNKQkEwWU51UUVnSWtFQmFpRWlJQUZCQVdvaUFTQUNSdzBBQ3lBQUlDUTJBZ0FNd2dJTEEwQUNRQ0FCTFFBQUloNUJJRVlOQUFKQUFrQUNRQ0FlUWJoL2FnNExBQUc2QWJvQnVnRzZBYm9CdWdHNkFib0JBcm9CQ3lBQlFRRnFJUUZCd2dBaEhneTFBZ3NnQVVFQmFpRUJRY01BSVI0TXRBSUxJQUZCQVdvaEFVSEVBQ0VlRExNQ0N5QUJRUUZxSWdFZ0FrY05BQXRCendBaEhnekJBZ3NDUUNBQklnRWdBa1lOQUNBQUlBRkJBV29pQVNBQ0VLV0FnSUFBR2lBQklRRkJCeUVlRExFQ0MwSFFBQ0VlRE1BQ0N3TkFBa0FnQVMwQUFFSHdwb0NBQUdvdEFBQWlIa0VCUmcwQUlCNUJmbW9PQTdrQnVnRzdBYndCQ3lBQlFRRnFJZ0VnQWtjTkFBdEIwUUFoSGd5L0Fnc0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRU1Bd3RCMGdBaEhneStBZ3NEUUFKQUlBRXRBQUJCOEtpQWdBQnFMUUFBSWg1QkFVWU5BQUpBSUI1QmZtb09CTHdCdlFHK0FRQy9BUXNnQVNFQlFjWUFJUjRNcndJTElBRkJBV29pQVNBQ1J3MEFDMEhUQUNFZURMMENDd0pBSUFFaUFTQUNSdzBBUWRRQUlSNE12UUlMQWtBZ0FTMEFBQ0llUVhacURocWtBYjhCdndHbUFiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiUUJ2d0cvQVFDOUFRc2dBVUVCYWlFQkMwRUdJUjRNcXdJTEEwQUNRQ0FCTFFBQVFmQ3FnSUFBYWkwQUFFRUJSZzBBSUFFaEFRejZBUXNnQVVFQmFpSUJJQUpIRFFBTFFkVUFJUjRNdWdJTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZFlBSVI0TXVRSUxBa0FnQVNJQklBSkhEUUJCMXdBaEhneTVBZ3NnQVVFQmFpRUJEQUVMQWtBZ0FTSUJJQUpIRFFCQjJBQWhIZ3k0QWdzZ0FVRUJhaUVCQzBFRUlSNE1wZ0lMQWtBZ0FTSWlJQUpIRFFCQjJRQWhIZ3kyQWdzZ0lpRUJBa0FDUUFKQUlDSXRBQUJCOEt5QWdBQnFMUUFBUVg5cURnZStBYjhCd0FFQStBRUJBc0VCQ3lBaVFRRnFJUUVNQ2dzZ0lrRUJhaUVCRExjQkMwRUFJUjRnQUVFQU5nSWNJQUJCOFk2QWdBQTJBaEFnQUVFSE5nSU1JQUFnSWtFQmFqWUNGQXkxQWdzQ1FBTkFBa0FnQVMwQUFFSHdySUNBQUdvdEFBQWlIa0VFUmcwQUFrQUNRQ0FlUVg5cURnZThBYjBCdmdIREFRQUVBY01CQ3lBQklRRkJ5UUFoSGd5b0Fnc2dBVUVCYWlFQlFjc0FJUjRNcHdJTElBRkJBV29pQVNBQ1J3MEFDMEhhQUNFZURMVUNDeUFCUVFGcUlRRU10UUVMQWtBZ0FTSWlJQUpIRFFCQjJ3QWhIZ3kwQWdzZ0lpMEFBRUV2UncyK0FTQWlRUUZxSVFFTUJnc0NRQ0FCSWlJZ0FrY05BRUhjQUNFZURMTUNDd0pBSUNJdEFBQWlBVUV2UncwQUlDSkJBV29oQVVITUFDRWVES01DQ3lBQlFYWnFJZ0ZCRmtzTnZRRkJBU0FCZEVHSmdJQUNjVVVOdlFFTWt3SUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJRYzBBSVI0TW9nSUxRZDBBSVI0TXNRSUxBa0FnQVNJaUlBSkhEUUJCM3dBaEhneXhBZ3NnSWlFQkFrQWdJaTBBQUVId3NJQ0FBR290QUFCQmYyb09BNUlDOEFFQXZnRUxRZEFBSVI0TW9BSUxBa0FnQVNJaUlBSkdEUUFEUUFKQUlDSXRBQUJCOEs2QWdBQnFMUUFBSWdGQkEwWU5BQUpBSUFGQmYyb09BcFFDQUw4QkN5QWlJUUZCemdBaEhneWlBZ3NnSWtFQmFpSWlJQUpIRFFBTFFkNEFJUjRNc0FJTFFkNEFJUjRNcndJTEFrQWdBU0lCSUFKR0RRQWdBRUdNZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWM4QUlSNE1ud0lMUWVBQUlSNE1yZ0lMQWtBZ0FTSUJJQUpIRFFCQjRRQWhIZ3l1QWdzZ0FFR01nSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJDMEVESVI0TW5BSUxBMEFnQVMwQUFFRWdSdzJNQWlBQlFRRnFJZ0VnQWtjTkFBdEI0Z0FoSGd5ckFnc0NRQ0FCSWdFZ0FrY05BRUhqQUNFZURLc0NDeUFCTFFBQVFTQkhEYmdCSUFGQkFXb2hBUXpVQVFzQ1FDQUJJZ2dnQWtjTkFFSGtBQ0VlREtvQ0N5QUlMUUFBUWN3QVJ3MjdBU0FJUVFGcUlRRkJFeUVlRExrQkMwSGxBQ0VlSUFFaUlpQUNSZzJvQWlBQ0lDSnJJQUFvQWdBaUptb2hJeUFpSVFnZ0ppRUJBMEFnQ0MwQUFDQUJRZkN5Z0lBQWFpMEFBRWNOdWdFZ0FVRUZSZzI0QVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJellDQUF5b0Fnc0NRQ0FCSWdnZ0FrY05BRUhtQUNFZURLZ0NDd0pBQWtBZ0NDMEFBRUc5ZjJvT0RBQzdBYnNCdXdHN0Fic0J1d0c3QWJzQnV3RzdBUUc3QVFzZ0NFRUJhaUVCUWRRQUlSNE1tQUlMSUFoQkFXb2hBVUhWQUNFZURKY0NDMEhuQUNFZUlBRWlJaUFDUmcybUFpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQWtBRFFDQUlMUUFBSUFGQjdiT0FnQUJxTFFBQVJ3MjVBU0FCUVFKR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1wd0lMSUFCQkFEWUNBQ0FpSUNaclFRTnFJUUZCRUNFZURMWUJDMEhvQUNFZUlBRWlJaUFDUmcybEFpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQWtBRFFDQUlMUUFBSUFGQjlyS0FnQUJxTFFBQVJ3MjRBU0FCUVFWR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1wZ0lMSUFCQkFEWUNBQ0FpSUNaclFRWnFJUUZCRmlFZURMVUJDMEhwQUNFZUlBRWlJaUFDUmcya0FpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQWtBRFFDQUlMUUFBSUFGQi9MS0FnQUJxTFFBQVJ3MjNBU0FCUVFOR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1wUUlMSUFCQkFEWUNBQ0FpSUNaclFRUnFJUUZCQlNFZURMUUJDd0pBSUFFaUNDQUNSdzBBUWVvQUlSNE1wQUlMSUFndEFBQkIyUUJIRGJVQklBaEJBV29oQVVFSUlSNE1zd0VMQWtBZ0FTSUlJQUpIRFFCQjZ3QWhIZ3lqQWdzQ1FBSkFJQWd0QUFCQnNuOXFEZ01BdGdFQnRnRUxJQWhCQVdvaEFVSFpBQ0VlREpNQ0N5QUlRUUZxSVFGQjJnQWhIZ3lTQWdzQ1FDQUJJZ2dnQWtjTkFFSHNBQ0VlREtJQ0N3SkFBa0FnQ0MwQUFFRzRmMm9PQ0FDMUFiVUJ0UUcxQWJVQnRRRUJ0UUVMSUFoQkFXb2hBVUhZQUNFZURKSUNDeUFJUVFGcUlRRkIyd0FoSGd5UkFndEI3UUFoSGlBQklpSWdBa1lOb0FJZ0FpQWlheUFBS0FJQUlpWnFJU01nSWlFSUlDWWhBUUpBQTBBZ0NDMEFBQ0FCUVlDemdJQUFhaTBBQUVjTnN3RWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FqTmdJQURLRUNDMEVBSVI0Z0FFRUFOZ0lBSUNJZ0ptdEJBMm9oQVF5d0FRdEI3Z0FoSGlBQklpSWdBa1lObndJZ0FpQWlheUFBS0FJQUlpWnFJU01nSWlFSUlDWWhBUUpBQTBBZ0NDMEFBQ0FCUVlPemdJQUFhaTBBQUVjTnNnRWdBVUVFUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FqTmdJQURLQUNDeUFBUVFBMkFnQWdJaUFtYTBFRmFpRUJRU01oSGd5dkFRc0NRQ0FCSWdnZ0FrY05BRUh2QUNFZURKOENDd0pBQWtBZ0NDMEFBRUcwZjJvT0NBQ3lBYklCc2dHeUFiSUJzZ0VCc2dFTElBaEJBV29oQVVIZEFDRWVESThDQ3lBSVFRRnFJUUZCM2dBaEhneU9BZ3NDUUNBQklnZ2dBa2NOQUVId0FDRWVESjRDQ3lBSUxRQUFRY1VBUncydkFTQUlRUUZxSVFFTTNnRUxRZkVBSVI0Z0FTSWlJQUpHRFp3Q0lBSWdJbXNnQUNnQ0FDSW1haUVqSUNJaENDQW1JUUVDUUFOQUlBZ3RBQUFnQVVHSXM0Q0FBR290QUFCSERhOEJJQUZCQTBZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSXpZQ0FBeWRBZ3NnQUVFQU5nSUFJQ0lnSm10QkJHb2hBVUV0SVI0TXJBRUxRZklBSVI0Z0FTSWlJQUpHRFpzQ0lBSWdJbXNnQUNnQ0FDSW1haUVqSUNJaENDQW1JUUVDUUFOQUlBZ3RBQUFnQVVIUXM0Q0FBR290QUFCSERhNEJJQUZCQ0VZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSXpZQ0FBeWNBZ3NnQUVFQU5nSUFJQ0lnSm10QkNXb2hBVUVwSVI0TXF3RUxBa0FnQVNJQklBSkhEUUJCOHdBaEhneWJBZ3RCQVNFZUlBRXRBQUJCM3dCSERhb0JJQUZCQVdvaEFRemNBUXRCOUFBaEhpQUJJaUlnQWtZTm1RSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFOQUlBZ3RBQUFnQVVHTXM0Q0FBR290QUFCSERhc0JJQUZCQVVZTjl3RWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1tUUlMQWtBZ0FTSWVJQUpIRFFCQjlRQWhIZ3laQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUVk2emdJQUFhaTBBQUVjTnF3RWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFmVUFJUjRNbVFJTElBQkJBRFlDQUNBZUlDSnJRUU5xSVFGQkFpRWVES2dCQ3dKQUlBRWlIaUFDUncwQVFmWUFJUjRNbUFJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVId3M0Q0FBR290QUFCSERhb0JJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFSDJBQ0VlREpnQ0N5QUFRUUEyQWdBZ0hpQWlhMEVDYWlFQlFSOGhIZ3luQVFzQ1FDQUJJaDRnQWtjTkFFSDNBQ0VlREpjQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQjhyT0FnQUJxTFFBQVJ3MnBBU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkI5d0FoSGd5WEFnc2dBRUVBTmdJQUlCNGdJbXRCQW1vaEFVRUpJUjRNcGdFTEFrQWdBU0lJSUFKSERRQkIrQUFoSGd5V0Fnc0NRQUpBSUFndEFBQkJ0MzlxRGdjQXFRR3BBYWtCcVFHcEFRR3BBUXNnQ0VFQmFpRUJRZVlBSVI0TWhnSUxJQWhCQVdvaEFVSG5BQ0VlRElVQ0N3SkFJQUVpSGlBQ1J3MEFRZmtBSVI0TWxRSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVR1JzNENBQUdvdEFBQkhEYWNCSUFGQkJVWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUg1QUNFZURKVUNDeUFBUVFBMkFnQWdIaUFpYTBFR2FpRUJRUmdoSGd5a0FRc0NRQ0FCSWg0Z0FrY05BRUg2QUNFZURKUUNDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkJsN09BZ0FCcUxRQUFSdzJtQVNBQlFRSkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCK2dBaEhneVVBZ3NnQUVFQU5nSUFJQjRnSW10QkEyb2hBVUVYSVI0TW93RUxBa0FnQVNJZUlBSkhEUUJCK3dBaEhneVRBZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRWnF6Z0lBQWFpMEFBRWNOcFFFZ0FVRUdSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUWZzQUlSNE1rd0lMSUFCQkFEWUNBQ0FlSUNKclFRZHFJUUZCRlNFZURLSUJDd0pBSUFFaUhpQUNSdzBBUWZ3QUlSNE1rZ0lMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUdoczRDQUFHb3RBQUJIRGFRQklBRkJCVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVIOEFDRWVESklDQ3lBQVFRQTJBZ0FnSGlBaWEwRUdhaUVCUVI0aEhneWhBUXNDUUNBQklnZ2dBa2NOQUVIOUFDRWVESkVDQ3lBSUxRQUFRY3dBUncyaUFTQUlRUUZxSVFGQkNpRWVES0FCQ3dKQUlBRWlDQ0FDUncwQVFmNEFJUjRNa0FJTEFrQUNRQ0FJTFFBQVFiOS9hZzRQQUtNQm93R2pBYU1Cb3dHakFhTUJvd0dqQWFNQm93R2pBYU1CQWFNQkN5QUlRUUZxSVFGQjdBQWhIZ3lBQWdzZ0NFRUJhaUVCUWUwQUlSNE0vd0VMQWtBZ0FTSUlJQUpIRFFCQi93QWhIZ3lQQWdzQ1FBSkFJQWd0QUFCQnYzOXFEZ01Bb2dFQm9nRUxJQWhCQVdvaEFVSHJBQ0VlRFA4QkN5QUlRUUZxSVFGQjdnQWhIZ3orQVFzQ1FDQUJJaDRnQWtjTkFFR0FBU0VlREk0Q0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQnA3T0FnQUJxTFFBQVJ3MmdBU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkJnQUVoSGd5T0Fnc2dBRUVBTmdJQUlCNGdJbXRCQW1vaEFVRUxJUjRNblFFTEFrQWdBU0lJSUFKSERRQkJnUUVoSGd5TkFnc0NRQUpBQWtBQ1FDQUlMUUFBUVZOcURpTUFvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBUUdpQWFJQm9nR2lBYUlCQXFJQm9nR2lBUU9pQVFzZ0NFRUJhaUVCUWVrQUlSNE0vd0VMSUFoQkFXb2hBVUhxQUNFZURQNEJDeUFJUVFGcUlRRkI3d0FoSGd6OUFRc2dDRUVCYWlFQlFmQUFJUjRNL0FFTEFrQWdBU0llSUFKSERRQkJnZ0VoSGd5TUFnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFhbXpnSUFBYWkwQUFFY05uZ0VnQVVFRVJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRWUlCSVI0TWpBSUxJQUJCQURZQ0FDQWVJQ0pyUVFWcUlRRkJHU0VlREpzQkN3SkFJQUVpSWlBQ1J3MEFRWU1CSVI0TWl3SUxJQUlnSW1zZ0FDZ0NBQ0ltYWlFZUlDSWhDQ0FtSVFFQ1FBTkFJQWd0QUFBZ0FVR3VzNENBQUdvdEFBQkhEWjBCSUFGQkJVWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0hqWUNBRUdEQVNFZURJc0NDeUFBUVFBMkFnQkJCaUVlSUNJZ0ptdEJCbW9oQVF5YUFRc0NRQ0FCSWg0Z0FrY05BRUdFQVNFZURJb0NDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkJ0TE9BZ0FCcUxRQUFSdzJjQVNBQlFRRkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCaEFFaEhneUtBZ3NnQUVFQU5nSUFJQjRnSW10QkFtb2hBVUVjSVI0TW1RRUxBa0FnQVNJZUlBSkhEUUJCaFFFaEhneUpBZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRYmF6Z0lBQWFpMEFBRWNObXdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUVlVQklSNE1pUUlMSUFCQkFEWUNBQ0FlSUNKclFRSnFJUUZCSnlFZURKZ0JDd0pBSUFFaUNDQUNSdzBBUVlZQklSNE1pQUlMQWtBQ1FDQUlMUUFBUWF4L2FnNENBQUdiQVFzZ0NFRUJhaUVCUWZRQUlSNE0rQUVMSUFoQkFXb2hBVUgxQUNFZURQY0JDd0pBSUFFaUhpQUNSdzBBUVljQklSNE1od0lMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUc0czRDQUFHb3RBQUJIRFprQklBRkJBVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVHSEFTRWVESWNDQ3lBQVFRQTJBZ0FnSGlBaWEwRUNhaUVCUVNZaEhneVdBUXNDUUNBQkloNGdBa2NOQUVHSUFTRWVESVlDQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCdXJPQWdBQnFMUUFBUncyWUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQmlBRWhIZ3lHQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJBbW9oQVVFRElSNE1sUUVMQWtBZ0FTSWVJQUpIRFFCQmlRRWhIZ3lGQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUWUyemdJQUFhaTBBQUVjTmx3RWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFZa0JJUjRNaFFJTElBQkJBRFlDQUNBZUlDSnJRUU5xSVFGQkRDRWVESlFCQ3dKQUlBRWlIaUFDUncwQVFZb0JJUjRNaEFJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHOHM0Q0FBR290QUFCSERaWUJJQUZCQTBZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFR0tBU0VlRElRQ0N5QUFRUUEyQWdBZ0hpQWlhMEVFYWlFQlFRMGhIZ3lUQVFzQ1FDQUJJZ2dnQWtjTkFFR0xBU0VlRElNQ0N3SkFBa0FnQ0MwQUFFRzZmMm9PQ3dDV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdFQmxnRUxJQWhCQVdvaEFVSDVBQ0VlRFBNQkN5QUlRUUZxSVFGQitnQWhIZ3p5QVFzQ1FDQUJJZ2dnQWtjTkFFR01BU0VlRElJQ0N5QUlMUUFBUWRBQVJ3MlRBU0FJUVFGcUlRRU14QUVMQWtBZ0FTSUlJQUpIRFFCQmpRRWhIZ3lCQWdzQ1FBSkFJQWd0QUFCQnQzOXFEZ2NCbEFHVUFaUUJsQUdVQVFDVUFRc2dDRUVCYWlFQlFmd0FJUjRNOFFFTElBaEJBV29oQVVFaUlSNE1rQUVMQWtBZ0FTSWVJQUpIRFFCQmpnRWhIZ3lBQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUWNDemdJQUFhaTBBQUVjTmtnRWdBVUVCUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFZNEJJUjRNZ0FJTElBQkJBRFlDQUNBZUlDSnJRUUpxSVFGQkhTRWVESThCQ3dKQUlBRWlDQ0FDUncwQVFZOEJJUjRNL3dFTEFrQUNRQ0FJTFFBQVFhNS9hZzREQUpJQkFaSUJDeUFJUVFGcUlRRkIvZ0FoSGd6dkFRc2dDRUVCYWlFQlFRUWhIZ3lPQVFzQ1FDQUJJZ2dnQWtjTkFFR1FBU0VlRFA0QkN3SkFBa0FDUUFKQUFrQWdDQzBBQUVHL2Yyb09GUUNVQVpRQmxBR1VBWlFCbEFHVUFaUUJsQUdVQVFHVUFaUUJBcFFCbEFFRGxBR1VBUVNVQVFzZ0NFRUJhaUVCUWZZQUlSNE04UUVMSUFoQkFXb2hBVUgzQUNFZURQQUJDeUFJUVFGcUlRRkIrQUFoSGd6dkFRc2dDRUVCYWlFQlFmMEFJUjRNN2dFTElBaEJBV29oQVVIL0FDRWVETzBCQ3dKQUlBUWdBa2NOQUVHUkFTRWVEUDBCQ3lBQ0lBUnJJQUFvQWdBaUhtb2hJaUFFSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCN2JPQWdBQnFMUUFBUncyUEFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQmtRRWhIZ3o5QVFzZ0FFRUFOZ0lBSUFRZ0htdEJBMm9oQVVFUklSNE1qQUVMQWtBZ0JTQUNSdzBBUVpJQklSNE0vQUVMSUFJZ0JXc2dBQ2dDQUNJZWFpRWlJQVVoQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhDczRDQUFHb3RBQUJIRFk0QklBRkJBa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHU0FTRWVEUHdCQ3lBQVFRQTJBZ0FnQlNBZWEwRURhaUVCUVN3aEhneUxBUXNDUUNBR0lBSkhEUUJCa3dFaEhnejdBUXNnQWlBR2F5QUFLQUlBSWg1cUlTSWdCaUVJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRY1d6Z0lBQWFpMEFBRWNOalFFZ0FVRUVSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUVpNQklSNE0rd0VMSUFCQkFEWUNBQ0FHSUI1clFRVnFJUUZCS3lFZURJb0JDd0pBSUFjZ0FrY05BRUdVQVNFZURQb0JDeUFDSUFkcklBQW9BZ0FpSG1vaElpQUhJUWdnSGlFQkFrQURRQ0FJTFFBQUlBRkJ5ck9BZ0FCcUxRQUFSdzJNQVNBQlFRSkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCbEFFaEhnejZBUXNnQUVFQU5nSUFJQWNnSG10QkEyb2hBVUVVSVI0TWlRRUxBa0FnQ0NBQ1J3MEFRWlVCSVI0TStRRUxBa0FDUUFKQUFrQWdDQzBBQUVHK2Yyb09Ed0FCQW80QmpnR09BWTRCamdHT0FZNEJqZ0dPQVk0QmpnRURqZ0VMSUFoQkFXb2hCRUdCQVNFZURPc0JDeUFJUVFGcUlRVkJnZ0VoSGd6cUFRc2dDRUVCYWlFR1FZTUJJUjRNNlFFTElBaEJBV29oQjBHRUFTRWVET2dCQ3dKQUlBZ2dBa2NOQUVHV0FTRWVEUGdCQ3lBSUxRQUFRY1VBUncySkFTQUlRUUZxSVFnTXV3RUxBa0FnQ1NBQ1J3MEFRWmNCSVI0TTl3RUxJQUlnQ1dzZ0FDZ0NBQ0llYWlFaUlBa2hDQ0FlSVFFQ1FBTkFJQWd0QUFBZ0FVSE5zNENBQUdvdEFBQkhEWWtCSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUdYQVNFZURQY0JDeUFBUVFBMkFnQWdDU0FlYTBFRGFpRUJRUTRoSGd5R0FRc0NRQ0FJSUFKSERRQkJtQUVoSGd6MkFRc2dDQzBBQUVIUUFFY05od0VnQ0VFQmFpRUJRU1VoSGd5RkFRc0NRQ0FLSUFKSERRQkJtUUVoSGd6MUFRc2dBaUFLYXlBQUtBSUFJaDVxSVNJZ0NpRUlJQjRoQVFKQUEwQWdDQzBBQUNBQlFkQ3pnSUFBYWkwQUFFY05od0VnQVVFSVJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBaU5nSUFRWmtCSVI0TTlRRUxJQUJCQURZQ0FDQUtJQjVyUVFscUlRRkJLaUVlRElRQkN3SkFJQWdnQWtjTkFFR2FBU0VlRFBRQkN3SkFBa0FnQ0MwQUFFR3JmMm9PQ3dDSEFZY0Jod0dIQVljQmh3R0hBWWNCaHdFQmh3RUxJQWhCQVdvaENFR0lBU0VlRE9RQkN5QUlRUUZxSVFwQmlRRWhIZ3pqQVFzQ1FDQUlJQUpIRFFCQm13RWhIZ3p6QVFzQ1FBSkFJQWd0QUFCQnYzOXFEaFFBaGdHR0FZWUJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQmhnR0dBWVlCQVlZQkN5QUlRUUZxSVFsQmh3RWhIZ3pqQVFzZ0NFRUJhaUVJUVlvQklSNE00Z0VMQWtBZ0N5QUNSdzBBUVp3QklSNE04Z0VMSUFJZ0Myc2dBQ2dDQUNJZWFpRWlJQXNoQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhaczRDQUFHb3RBQUJIRFlRQklBRkJBMFlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHY0FTRWVEUElCQ3lBQVFRQTJBZ0FnQ3lBZWEwRUVhaUVCUVNFaEhneUJBUXNDUUNBTUlBSkhEUUJCblFFaEhnenhBUXNnQWlBTWF5QUFLQUlBSWg1cUlTSWdEQ0VJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZDJ6Z0lBQWFpMEFBRWNOZ3dFZ0FVRUdSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUVowQklSNE04UUVMSUFCQkFEWUNBQ0FNSUI1clFRZHFJUUZCR2lFZURJQUJDd0pBSUFnZ0FrY05BRUdlQVNFZURQQUJDd0pBQWtBQ1FDQUlMUUFBUWJ0L2FnNFJBSVFCaEFHRUFZUUJoQUdFQVlRQmhBR0VBUUdFQVlRQmhBR0VBWVFCQW9RQkN5QUlRUUZxSVFoQml3RWhIZ3poQVFzZ0NFRUJhaUVMUVl3QklSNE00QUVMSUFoQkFXb2hERUdOQVNFZUROOEJDd0pBSUEwZ0FrY05BRUdmQVNFZURPOEJDeUFDSUExcklBQW9BZ0FpSG1vaElpQU5JUWdnSGlFQkFrQURRQ0FJTFFBQUlBRkI1TE9BZ0FCcUxRQUFSdzJCQVNBQlFRVkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCbndFaEhnenZBUXNnQUVFQU5nSUFJQTBnSG10QkJtb2hBVUVvSVI0TWZnc0NRQ0FPSUFKSERRQkJvQUVoSGd6dUFRc2dBaUFPYXlBQUtBSUFJaDVxSVNJZ0RpRUlJQjRoQVFKQUEwQWdDQzBBQUNBQlFlcXpnSUFBYWkwQUFFY05nQUVnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBaU5nSUFRYUFCSVI0TTdnRUxJQUJCQURZQ0FDQU9JQjVyUVFOcUlRRkJCeUVlREgwTEFrQWdDQ0FDUncwQVFhRUJJUjRNN1FFTEFrQUNRQ0FJTFFBQVFidC9hZzRPQUlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBUUdBQVFzZ0NFRUJhaUVOUVk4QklSNE0zUUVMSUFoQkFXb2hEa0dRQVNFZUROd0JDd0pBSUE4Z0FrY05BRUdpQVNFZURPd0JDeUFDSUE5cklBQW9BZ0FpSG1vaElpQVBJUWdnSGlFQkFrQURRQ0FJTFFBQUlBRkI3Yk9BZ0FCcUxRQUFSdzErSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUdpQVNFZURPd0JDeUFBUVFBMkFnQWdEeUFlYTBFRGFpRUJRUkloSGd4N0N3SkFJQkFnQWtjTkFFR2pBU0VlRE9zQkN5QUNJQkJySUFBb0FnQWlIbW9oSWlBUUlRZ2dIaUVCQWtBRFFDQUlMUUFBSUFGQjhMT0FnQUJxTFFBQVJ3MTlJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSWpZQ0FFR2pBU0VlRE9zQkN5QUFRUUEyQWdBZ0VDQWVhMEVDYWlFQlFTQWhIZ3g2Q3dKQUlCRWdBa2NOQUVHa0FTRWVET29CQ3lBQ0lCRnJJQUFvQWdBaUhtb2hJaUFSSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCOHJPQWdBQnFMUUFBUncxOElBRkJBVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHa0FTRWVET29CQ3lBQVFRQTJBZ0FnRVNBZWEwRUNhaUVCUVE4aEhneDVDd0pBSUFnZ0FrY05BRUdsQVNFZURPa0JDd0pBQWtBZ0NDMEFBRUczZjJvT0J3QjhmSHg4ZkFGOEN5QUlRUUZxSVJCQmt3RWhIZ3paQVFzZ0NFRUJhaUVSUVpRQklSNE0yQUVMQWtBZ0VpQUNSdzBBUWFZQklSNE02QUVMSUFJZ0Vtc2dBQ2dDQUNJZWFpRWlJQkloQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUgwczRDQUFHb3RBQUJIRFhvZ0FVRUhSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUWFZQklSNE02QUVMSUFCQkFEWUNBQ0FTSUI1clFRaHFJUUZCR3lFZURIY0xBa0FnQ0NBQ1J3MEFRYWNCSVI0TTV3RUxBa0FDUUFKQUlBZ3RBQUJCdm45cURoSUFlM3Q3ZTN0N2UzdDdBWHQ3ZTN0N2V3SjdDeUFJUVFGcUlROUJrZ0VoSGd6WUFRc2dDRUVCYWlFSVFaVUJJUjRNMXdFTElBaEJBV29oRWtHV0FTRWVETllCQ3dKQUlBZ2dBa2NOQUVHb0FTRWVET1lCQ3lBSUxRQUFRYzRBUncxM0lBaEJBV29oQ0F5cUFRc0NRQ0FJSUFKSERRQkJxUUVoSGd6bEFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBSUxRQUFRYjkvYWc0VkFBRUNBNFlCQkFVR2hnR0dBWVlCQndnSkNndUdBUXdORGcrR0FRc2dDRUVCYWlFQlFkWUFJUjRNNHdFTElBaEJBV29oQVVIWEFDRWVET0lCQ3lBSVFRRnFJUUZCM0FBaEhnemhBUXNnQ0VFQmFpRUJRZUFBSVI0TTRBRUxJQWhCQVdvaEFVSGhBQ0VlRE44QkN5QUlRUUZxSVFGQjVBQWhIZ3plQVFzZ0NFRUJhaUVCUWVVQUlSNE0zUUVMSUFoQkFXb2hBVUhvQUNFZUROd0JDeUFJUVFGcUlRRkI4UUFoSGd6YkFRc2dDRUVCYWlFQlFmSUFJUjRNMmdFTElBaEJBV29oQVVIekFDRWVETmtCQ3lBSVFRRnFJUUZCZ0FFaEhnellBUXNnQ0VFQmFpRUlRWVlCSVI0TTF3RUxJQWhCQVdvaENFR09BU0VlRE5ZQkN5QUlRUUZxSVFoQmtRRWhIZ3pWQVFzZ0NFRUJhaUVJUVpnQklSNE0xQUVMQWtBZ0ZDQUNSdzBBUWFzQklSNE01QUVMSUJSQkFXb2hFd3gzQ3dOQUFrQWdIaTBBQUVGMmFnNEVkd0FBZWdBTElCNUJBV29pSGlBQ1J3MEFDMEdzQVNFZURPSUJDd0pBSUJVZ0FrWU5BQ0FBUVkyQWdJQUFOZ0lJSUFBZ0ZUWUNCQ0FWSVFGQkFTRWVETklCQzBHdEFTRWVET0VCQ3dKQUlCVWdBa2NOQUVHdUFTRWVET0VCQ3dKQUFrQWdGUzBBQUVGMmFnNEVBYXNCcXdFQXF3RUxJQlZCQVdvaEZBeDRDeUFWUVFGcUlSTU1kQXNnQUNBVElBSVFwNENBZ0FBYUlCTWhBUXhGQ3dKQUlCVWdBa2NOQUVHdkFTRWVETjhCQ3dKQUFrQWdGUzBBQUVGMmFnNFhBWGw1QVhsNWVYbDVlWGw1ZVhsNWVYbDVlWGw1ZVFCNUN5QVZRUUZxSVJVTFFad0JJUjRNemdFTEFrQWdGaUFDUncwQVFiRUJJUjRNM2dFTElCWXRBQUJCSUVjTmR5QUFRUUE3QVRJZ0ZrRUJhaUVCUWFBQklSNE16UUVMSUFFaEpnSkFBMEFnSmlJVklBSkdEUUVnRlMwQUFFRlFha0gvQVhFaUhrRUtUdzJvQVFKQUlBQXZBVElpSWtHWk0wc05BQ0FBSUNKQkNtd2lJanNCTWlBZVFmLy9BM01nSWtIKy93TnhTUTBBSUJWQkFXb2hKaUFBSUNJZ0htb2lIanNCTWlBZVFmLy9BM0ZCNkFkSkRRRUxDMEVBSVI0Z0FFRUFOZ0ljSUFCQm5ZbUFnQUEyQWhBZ0FFRU5OZ0lNSUFBZ0ZVRUJhallDRkF6ZEFRdEJzQUVoSGd6Y0FRc0NRQ0FYSUFKSERRQkJzZ0VoSGd6Y0FRdEJBQ0VlQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FYTFFBQVFWQnFEZ3AvZmdBQkFnTUVCUVlIZ0FFTFFRSWhIZ3grQzBFRElSNE1mUXRCQkNFZURId0xRUVVoSGd4N0MwRUdJUjRNZWd0QkJ5RWVESGtMUVFnaEhneDRDMEVKSVI0TWR3c0NRQ0FZSUFKSERRQkJzd0VoSGd6YkFRc2dHQzBBQUVFdVJ3MTRJQmhCQVdvaEZ3eW1BUXNDUUNBWklBSkhEUUJCdEFFaEhnemFBUXRCQUNFZUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBWkxRQUFRVkJxRGdxQkFZQUJBQUVDQXdRRkJnZUNBUXRCQWlFZURJQUJDMEVESVI0TWZ3dEJCQ0VlREg0TFFRVWhIZ3g5QzBFR0lSNE1mQXRCQnlFZURIc0xRUWdoSGd4NkMwRUpJUjRNZVFzQ1FDQUlJQUpIRFFCQnRRRWhIZ3paQVFzZ0FpQUlheUFBS0FJQUlpSnFJU1lnQ0NFWklDSWhIZ05BSUJrdEFBQWdIa0g4czRDQUFHb3RBQUJIRFhzZ0hrRUVSZzIwQVNBZVFRRnFJUjRnR1VFQmFpSVpJQUpIRFFBTElBQWdKallDQUVHMUFTRWVETmdCQ3dKQUlCb2dBa2NOQUVHMkFTRWVETmdCQ3lBQ0lCcHJJQUFvQWdBaUhtb2hJaUFhSVFnZ0hpRUJBMEFnQ0MwQUFDQUJRWUcwZ0lBQWFpMEFBRWNOZXlBQlFRRkdEYllCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUWJZQklSNE0xd0VMQWtBZ0d5QUNSdzBBUWJjQklSNE0xd0VMSUFJZ0cyc2dBQ2dDQUNJWmFpRWlJQnNoQ0NBWklSNERRQ0FJTFFBQUlCNUJnN1NBZ0FCcUxRQUFSdzE2SUI1QkFrWU5mQ0FlUVFGcUlSNGdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUczQVNFZUROWUJDd0pBSUFnZ0FrY05BRUc0QVNFZUROWUJDd0pBQWtBZ0NDMEFBRUc3ZjJvT0VBQjdlM3Q3ZTN0N2UzdDdlM3Q3ZXdGN0N5QUlRUUZxSVJwQnBRRWhIZ3pHQVFzZ0NFRUJhaUViUWFZQklSNE14UUVMQWtBZ0NDQUNSdzBBUWJrQklSNE0xUUVMSUFndEFBQkJ5QUJIRFhnZ0NFRUJhaUVJREtJQkN3SkFJQWdnQWtjTkFFRzZBU0VlRE5RQkN5QUlMUUFBUWNnQVJnMmlBU0FBUVFFNkFDZ01tUUVMQTBBQ1FDQUlMUUFBUVhacURnUUFlbm9BZWdzZ0NFRUJhaUlJSUFKSERRQUxRYndCSVI0TTBnRUxJQUJCQURvQUx5QUFMUUF0UVFSeFJRM0lBUXNnQUVFQU9nQXZJQUVoQVF4NUN5QWVRUlZHRGFrQklBQkJBRFlDSENBQUlBRTJBaFFnQUVHcmpJQ0FBRFlDRUNBQVFSSTJBZ3hCQUNFZURNOEJDd0pBSUFBZ0hpQUNFSzJBZ0lBQUlnRU5BQ0FlSVFFTXhRRUxBa0FnQVVFVlJ3MEFJQUJCQXpZQ0hDQUFJQjQyQWhRZ0FFSFdrb0NBQURZQ0VDQUFRUlUyQWd4QkFDRWVETThCQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCcTR5QWdBQTJBaEFnQUVFU05nSU1RUUFoSGd6T0FRc2dIa0VWUmcybEFTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmlJeUFnQUEyQWhBZ0FFRVVOZ0lNUVFBaEhnek5BUXNnQUNnQ0JDRW1JQUJCQURZQ0JDQWVJQituYWlJaklRRWdBQ0FtSUI0Z0l5QWlHeUllRUs2QWdJQUFJaUpGRFhvZ0FFRUhOZ0ljSUFBZ0hqWUNGQ0FBSUNJMkFneEJBQ0VlRE13QkN5QUFJQUF2QVRCQmdBRnlPd0V3SUFFaEFRd3hDeUFlUVJWR0RhRUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEZpNENBQURZQ0VDQUFRUk0yQWd4QkFDRWVETW9CQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCaTR1QWdBQTJBaEFnQUVFQ05nSU1RUUFoSGd6SkFRc2dIa0U3UncwQklBRkJBV29oQVF0QkNDRWVETGNCQzBFQUlSNGdBRUVBTmdJY0lBQWdBVFlDRkNBQVFhT1FnSUFBTmdJUUlBQkJERFlDREF6R0FRdENBU0VmQ3lBZVFRRnFJUUVDUUNBQUtRTWdJaUJDLy8vLy8vLy8vLzhQVmcwQUlBQWdJRUlFaGlBZmhEY0RJQ0FCSVFFTWR3c2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFZbUpnSUFBTmdJUUlBQkJERFlDREVFQUlSNE14QUVMSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUdqa0lDQUFEWUNFQ0FBUVF3MkFneEJBQ0VlRE1NQkN5QUFLQUlFSVNZZ0FFRUFOZ0lFSUI0Z0g2ZHFJaU1oQVNBQUlDWWdIaUFqSUNJYkloNFFyb0NBZ0FBaUlrVU5iaUFBUVFVMkFod2dBQ0FlTmdJVUlBQWdJallDREVFQUlSNE13Z0VMSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUhkbElDQUFEWUNFQ0FBUVE4MkFneEJBQ0VlRE1FQkN5QUFJQjRnQWhDdGdJQ0FBQ0lCRFFFZ0hpRUJDMEVQSVI0TXJ3RUxBa0FnQVVFVlJ3MEFJQUJCQWpZQ0hDQUFJQjQyQWhRZ0FFSFdrb0NBQURZQ0VDQUFRUlUyQWd4QkFDRWVETDhCQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCcTR5QWdBQTJBaEFnQUVFU05nSU1RUUFoSGd5K0FRc2dBVUVCYWlFZUFrQWdBQzhCTUNJQlFZQUJjVVVOQUFKQUlBQWdIaUFDRUxDQWdJQUFJZ0VOQUNBZUlRRU1hd3NnQVVFVlJ3MlhBU0FBUVFVMkFod2dBQ0FlTmdJVUlBQkJ2cEtBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3krQVFzQ1FDQUJRYUFFY1VHZ0JFY05BQ0FBTFFBdFFRSnhEUUFnQUVFQU5nSWNJQUFnSGpZQ0ZDQUFRZXlQZ0lBQU5nSVFJQUJCQkRZQ0RFRUFJUjRNdmdFTElBQWdIaUFDRUxHQWdJQUFHaUFlSVFFQ1FBSkFBa0FDUUFKQUlBQWdIaUFDRUt5QWdJQUFEaFlDQVFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRREJBc2dBRUVCT2dBdUN5QUFJQUF2QVRCQndBQnlPd0V3SUI0aEFRdEJIU0VlREs4QkN5QUFRUlUyQWh3Z0FDQWVOZ0lVSUFCQjRaR0FnQUEyQWhBZ0FFRVZOZ0lNUVFBaEhneStBUXNnQUVFQU5nSWNJQUFnSGpZQ0ZDQUFRYkdMZ0lBQU5nSVFJQUJCRVRZQ0RFRUFJUjRNdlFFTElBQXRBQzFCQVhGRkRRRkJxZ0VoSGd5c0FRc0NRQ0FjSUFKR0RRQURRQUpBSUJ3dEFBQkJJRVlOQUNBY0lRRU1xQUVMSUJ4QkFXb2lIQ0FDUncwQUMwRVhJUjRNdkFFTFFSY2hIZ3k3QVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQ0FBSUFFZ0hCQ29nSUNBQUNJQlJRMlFBU0FBUVJnMkFod2dBQ0FCTmdJTUlBQWdIRUVCYWpZQ0ZFRUFJUjRNdWdFTElBQkJHVFlDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd5NUFRc2dIaUVCUVFFaElnSkFBa0FDUUFKQUFrQUNRQUpBSUFBdEFDeEJmbW9PQndZRkJRTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFaURBRUxRUVFoSWdzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FpY2pzQk1Bc2dIaUVCQzBFZ0lSNE1xUUVMSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUdCajRDQUFEWUNFQ0FBUVFzMkFneEJBQ0VlRExnQkN5QWVJUUZCQVNFaUFrQUNRQUpBQWtBQ1FDQUFMUUFzUVh0cURnUUNBQUVEQlF0QkFpRWlEQUVMUVFRaElnc2dBRUVCT2dBc0lBQWdBQzhCTUNBaWNqc0JNQXdCQ3lBQUlBQXZBVEJCQ0hJN0FUQUxJQjRoQVF0QnF3RWhIZ3ltQVFzZ0FDQUJJQUlRcTRDQWdBQWFEQnNMQWtBZ0FTSWVJQUpHRFFBZ0hpRUJBa0FDUUNBZUxRQUFRWFpxRGdRQmFtb0FhZ3NnSGtFQmFpRUJDMEVlSVI0TXBRRUxRY01BSVI0TXRBRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1JrWUNBQURZQ0VDQUFRUU0yQWd4QkFDRWVETE1CQ3dKQUlBRXRBQUJCRFVjTkFDQUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcW9DQWdBQWlIZzBBSUFGQkFXb2hBUXhwQ3lBQVFSNDJBaHdnQUNBZU5nSU1JQUFnQVVFQmFqWUNGRUVBSVI0TXN3RUxJQUVoQVNBQUxRQXRRUUZ4UlEydUFVR3RBU0VlREtJQkN3SkFJQUVpQVNBQ1J3MEFRUjhoSGd5eUFRc0NRQUpBQTBBQ1FDQUJMUUFBUVhacURnUUNBQUFEQUFzZ0FVRUJhaUlCSUFKSERRQUxRUjhoSGd5ekFRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtxQWdJQUFJaDROQUNBQklRRU1hQXNnQUVFZU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVETElCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFxb0NBZ0FBaUhnMEFJQUZCQVdvaEFReG5DeUFBUVI0MkFod2dBQ0FlTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUjRNc1FFTElCNUJMRWNOQVNBQlFRRnFJUjVCQVNFQkFrQUNRQUpBQWtBQ1FDQUFMUUFzUVh0cURnUURBUUlFQUFzZ0hpRUJEQVFMUVFJaEFRd0JDMEVFSVFFTElBQkJBVG9BTENBQUlBQXZBVEFnQVhJN0FUQWdIaUVCREFFTElBQWdBQzhCTUVFSWNqc0JNQ0FlSVFFTFFTNGhIZ3lmQVFzZ0FFRUFPZ0FzSUFFaEFRdEJLU0VlREowQkN5QUFRUUEyQWdBZ0l5QWthMEVKYWlFQlFRVWhIZ3lZQVFzZ0FFRUFOZ0lBSUNNZ0pHdEJCbW9oQVVFSElSNE1sd0VMSUFBZ0FDOEJNRUVnY2pzQk1DQUJJUUVNQWdzZ0FDZ0NCQ0VJSUFCQkFEWUNCQUpBSUFBZ0NDQUJFS3FBZ0lBQUlnZ05BQ0FCSVFFTW5RRUxJQUJCS2pZQ0hDQUFJQUUyQWhRZ0FDQUlOZ0lNUVFBaEhneXBBUXNnQUVFSU9nQXNJQUVoQVF0QkpTRWVESmNCQ3dKQUlBQXRBQ2hCQVVZTkFDQUJJUUVNQkFzZ0FDMEFMVUVJY1VVTmVDQUJJUUVNQXdzZ0FDMEFNRUVnY1ExNVFhNEJJUjRNbFFFTEFrQWdIU0FDUmcwQUFrQURRQUpBSUIwdEFBQkJVR29pQVVIL0FYRkJDa2tOQUNBZElRRkJLaUVlREpnQkN5QUFLUU1nSWg5Q21iUG16Sm16NXN3WlZnMEJJQUFnSDBJS2ZpSWZOd01nSUI4Z0FhMGlJRUovaFVLQWZvUldEUUVnQUNBZklDQkMvd0dEZkRjRElDQWRRUUZxSWgwZ0FrY05BQXRCTENFZURLWUJDeUFBS0FJRUlRZ2dBRUVBTmdJRUlBQWdDQ0FkUVFGcUlnRVFxb0NBZ0FBaUNBMTZJQUVoQVF5WkFRdEJMQ0VlREtRQkN3SkFJQUF2QVRBaUFVRUljVVVOQUNBQUxRQW9RUUZIRFFBZ0FDMEFMVUVJY1VVTmRRc2dBQ0FCUWZmN0EzRkJnQVJ5T3dFd0lCMGhBUXRCTENFZURKSUJDeUFBSUFBdkFUQkJFSEk3QVRBTWh3RUxJQUJCTmpZQ0hDQUFJQUUyQWd3Z0FDQWNRUUZxTmdJVVFRQWhIZ3lnQVFzZ0FTMEFBRUU2UncwQ0lBQW9BZ1FoSGlBQVFRQTJBZ1FnQUNBZUlBRVFxSUNBZ0FBaUhnMEJJQUZCQVdvaEFRdEJNU0VlREk0QkN5QUFRVFkyQWh3Z0FDQWVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSNE1uUUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdIam9DQUFEWUNFQ0FBUVFvMkFneEJBQ0VlREp3QkN5QUJRUUZxSVFFTElBQkJnQkk3QVNvZ0FDQUJJQUlRcFlDQWdBQWFJQUVoQVF0QnJBRWhIZ3lKQVFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS1NBZ0lBQUloNE5BQ0FCSVFFTVVBc2dBRUhFQURZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneVlBUXNnQUVFQU5nSWNJQUFnSWpZQ0ZDQUFRZVdZZ0lBQU5nSVFJQUJCQnpZQ0RDQUFRUUEyQWdCQkFDRWVESmNCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF4UEN5QUFRY1VBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURKWUJDMEVBSVI0Z0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWV1TmdJQUFOZ0lRSUFCQkNUWUNEQXlWQVF0QkFTRWVDeUFBSUI0NkFDc2dBVUVCYWlFQklBQXRBQ2xCSWtZTml3RU1UQXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYUtOZ0lBQU5nSVFJQUJCQ1RZQ0RFRUFJUjRNa2dFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIRmlvQ0FBRFlDRUNBQVFRazJBZ3hCQUNFZURKRUJDMEVCSVI0TElBQWdIam9BS2lBQlFRRnFJUUVNU2dzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJpTmdJQUFOZ0lRSUFCQkNUWUNERUVBSVI0TWpnRUxJQUJCQURZQ0FDQW1JQ05yUVFScUlRRUNRQ0FBTFFBcFFTTlBEUUFnQVNFQkRFb0xJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR3ZpWUNBQURZQ0VDQUFRUWcyQWd4QkFDRWVESTBCQ3lBQVFRQTJBZ0FMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnVadUFnQUEyQWhBZ0FFRUlOZ0lNRElzQkN5QUFRUUEyQWdBZ0ppQWphMEVEYWlFQkFrQWdBQzBBS1VFaFJ3MEFJQUVoQVF4SEN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjk0bUFnQUEyQWhBZ0FFRUlOZ0lNUVFBaEhneUtBUXNnQUVFQU5nSUFJQ1lnSTJ0QkJHb2hBUUpBSUFBdEFDa2lIa0ZkYWtFTFR3MEFJQUVoQVF4R0N3SkFJQjVCQmtzTkFFRUJJQjUwUWNvQWNVVU5BQ0FCSVFFTVJndEJBQ0VlSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhUaVlDQUFEWUNFQ0FBUVFnMkFnd01pUUVMSUFBb0FnUWhIaUFBUVFBMkFnUUNRQ0FBSUI0Z0FSQ2tnSUNBQUNJZURRQWdBU0VCREVZTElBQkIwQUEyQWh3Z0FDQUJOZ0lVSUFBZ0hqWUNERUVBSVI0TWlBRUxJQUFvQWdRaEhpQUFRUUEyQWdRQ1FDQUFJQjRnQVJDa2dJQ0FBQ0llRFFBZ0FTRUJERDhMSUFCQnhBQTJBaHdnQUNBQk5nSVVJQUFnSGpZQ0RFRUFJUjRNaHdFTElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkREOExJQUJCeFFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1oZ0VMSUFBb0FnUWhIaUFBUVFBMkFnUUNRQ0FBSUI0Z0FSQ2tnSUNBQUNJZURRQWdBU0VCREVNTElBQkIwQUEyQWh3Z0FDQUJOZ0lVSUFBZ0hqWUNERUVBSVI0TWhRRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2lpb0NBQURZQ0VDQUFRUWMyQWd4QkFDRWVESVFCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF3N0N5QUFRY1FBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURJTUJDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXc3Q3lBQVFjVUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlRElJQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFRdy9DeUFBUWRBQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESUVCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCdUlpQWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd5QUFRc2dIa0UvUncwQklBRkJBV29oQVF0QkJTRWVERzRMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjA0K0FnQUEyQWhBZ0FFRUhOZ0lNREgwTElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkREUUxJQUJCeEFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1mQXNnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLU0FnSUFBSWg0TkFDQUJJUUVNTkFzZ0FFSEZBRFlDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd4N0N5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFRdzRDeUFBUWRBQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESG9MSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0loQ2tnSUNBQUNJQkRRQWdJaUVCRERFTElBQkJ4QUEyQWh3Z0FDQWlOZ0lVSUFBZ0FUWUNERUVBSVI0TWVRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FpRUtTQWdJQUFJZ0VOQUNBaUlRRU1NUXNnQUVIRkFEWUNIQ0FBSUNJMkFoUWdBQ0FCTmdJTVFRQWhIZ3g0Q3lBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklDSVFwSUNBZ0FBaUFRMEFJQ0loQVF3MUN5QUFRZEFBTmdJY0lBQWdJallDRkNBQUlBRTJBZ3hCQUNFZURIY0xJQUJCQURZQ0hDQUFJQ0kyQWhRZ0FFSFFqSUNBQURZQ0VDQUFRUWMyQWd4QkFDRWVESFlMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhRaklDQUFEWUNFQ0FBUVFjMkFneEJBQ0VlREhVTFFRQWhIaUFBUVFBMkFod2dBQ0FpTmdJVUlBQkJ2NVNBZ0FBMkFoQWdBRUVITmdJTURIUUxJQUJCQURZQ0hDQUFJQ0kyQWhRZ0FFRy9sSUNBQURZQ0VDQUFRUWMyQWd4QkFDRWVESE1MSUFCQkFEWUNIQ0FBSUNJMkFoUWdBRUhVam9DQUFEWUNFQ0FBUVFjMkFneEJBQ0VlREhJTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIQms0Q0FBRFlDRUNBQVFRWTJBZ3hCQUNFZURIRUxJQUJCQURZQ0FDQWlJQ1pyUVFacUlRRkJKQ0VlQ3lBQUlCNDZBQ2tnQVNFQkRFNExJQUJCQURZQ0FBdEJBQ0VlSUFCQkFEWUNIQ0FBSUFnMkFoUWdBRUdrbElDQUFEWUNFQ0FBUVFZMkFnd01iUXNnQUNnQ0JDRVRJQUJCQURZQ0JDQUFJQk1nSGhDbWdJQ0FBQ0lURFFFZ0hrRUJhaUVUQzBHZEFTRWVERnNMSUFCQnFnRTJBaHdnQUNBVE5nSU1JQUFnSGtFQmFqWUNGRUVBSVI0TWFnc2dBQ2dDQkNFVUlBQkJBRFlDQkNBQUlCUWdIaENtZ0lDQUFDSVVEUUVnSGtFQmFpRVVDMEdhQVNFZURGZ0xJQUJCcXdFMkFod2dBQ0FVTmdJTUlBQWdIa0VCYWpZQ0ZFRUFJUjRNWndzZ0FFRUFOZ0ljSUFBZ0ZUWUNGQ0FBUWZPS2dJQUFOZ0lRSUFCQkRUWUNERUVBSVI0TVpnc2dBRUVBTmdJY0lBQWdGallDRkNBQVFjNk5nSUFBTmdJUUlBQkJDVFlDREVFQUlSNE1aUXRCQVNFZUN5QUFJQjQ2QUNzZ0YwRUJhaUVXREM0TElBQkJBRFlDSENBQUlCYzJBaFFnQUVHaWpZQ0FBRFlDRUNBQVFRazJBZ3hCQUNFZURHSUxJQUJCQURZQ0hDQUFJQmcyQWhRZ0FFSEZpb0NBQURZQ0VDQUFRUWsyQWd4QkFDRWVER0VMUVFFaEhnc2dBQ0FlT2dBcUlCbEJBV29oR0F3c0N5QUFRUUEyQWh3Z0FDQVpOZ0lVSUFCQnVJMkFnQUEyQWhBZ0FFRUpOZ0lNUVFBaEhneGVDeUFBUVFBMkFod2dBQ0FaTmdJVUlBQkJ1WnVBZ0FBMkFoQWdBRUVJTmdJTUlBQkJBRFlDQUVFQUlSNE1YUXNnQUVFQU5nSUFDMEVBSVI0Z0FFRUFOZ0ljSUFBZ0NEWUNGQ0FBUVl1VWdJQUFOZ0lRSUFCQkNEWUNEQXhiQ3lBQVFRSTZBQ2dnQUVFQU5nSUFJQnNnR1d0QkEyb2hHUXcyQ3lBQVFRSTZBQzhnQUNBSUlBSVFvNENBZ0FBaUhnMEJRYThCSVI0TVNRc2dBQzBBS0VGL2FnNENIaUFmQ3lBZVFSVkhEU2NnQUVHN0FUWUNIQ0FBSUFnMkFoUWdBRUdua29DQUFEWUNFQ0FBUVJVMkFneEJBQ0VlREZjTFFRQWhIZ3hHQzBFQ0lSNE1SUXRCRGlFZURFUUxRUkFoSGd4REMwRWNJUjRNUWd0QkZDRWVERUVMUVJZaEhneEFDMEVYSVI0TVB3dEJHU0VlREQ0TFFSb2hIZ3c5QzBFNklSNE1QQXRCSXlFZUREc0xRU1FoSGd3NkMwRXdJUjRNT1F0Qk95RWVERGdMUVR3aEhndzNDMEUrSVI0TU5ndEJQeUVlRERVTFFjQUFJUjRNTkF0QndRQWhIZ3d6QzBIRkFDRWVERElMUWNjQUlSNE1NUXRCeUFBaEhnd3dDMEhLQUNFZURDOExRZDhBSVI0TUxndEI0Z0FoSGd3dEMwSDdBQ0VlREN3TFFZVUJJUjRNS3d0Qmx3RWhIZ3dxQzBHWkFTRWVEQ2tMUWFrQklSNE1LQXRCcEFFaEhnd25DMEdiQVNFZURDWUxRWjRCSVI0TUpRdEJud0VoSGd3a0MwR2hBU0VlRENNTFFhSUJJUjRNSWd0QnB3RWhIZ3doQzBHb0FTRWVEQ0FMSUFCQkFEWUNIQ0FBSUFnMkFoUWdBRUhtaTRDQUFEWUNFQ0FBUVJBMkFneEJBQ0VlREM4TElBQkJBRFlDQkNBQUlCMGdIUkNxZ0lDQUFDSUJSUTBCSUFCQkxUWUNIQ0FBSUFFMkFnd2dBQ0FkUVFGcU5nSVVRUUFoSGd3dUN5QUFLQUlFSVFnZ0FFRUFOZ0lFQWtBZ0FDQUlJQUVRcW9DQWdBQWlDRVVOQUNBQVFTNDJBaHdnQUNBSU5nSU1JQUFnQVVFQmFqWUNGRUVBSVI0TUxnc2dBVUVCYWlFQkRCNExJQjFCQVdvaEFRd2VDeUFBUVFBMkFod2dBQ0FkTmdJVUlBQkJ1bytBZ0FBMkFoQWdBRUVFTmdJTVFRQWhIZ3dyQ3lBQVFTazJBaHdnQUNBQk5nSVVJQUFnQ0RZQ0RFRUFJUjRNS2dzZ0hFRUJhaUVCREI0TElBQkJDallDSENBQUlBRTJBaFFnQUVHUmtvQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFZURDZ0xJQUJCRURZQ0hDQUFJQUUyQWhRZ0FFRytrb0NBQURZQ0VDQUFRUlUyQWd4QkFDRWVEQ2NMSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUdJaklDQUFEWUNFQ0FBUVJRMkFneEJBQ0VlRENZTElBQkJCRFlDSENBQUlBRTJBaFFnQUVIV2tvQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFZURDVUxJQUJCQURZQ0FDQUlJQ0pyUVFWcUlSa0xRYU1CSVI0TUV3c2dBRUVBTmdJQUlDSWdKbXRCQW1vaEFVSGpBQ0VlREJJTElBQkJBRFlDQUNBQVFZRUVPd0VvSUJvZ0htdEJBbW9oQVF0QjB3QWhIZ3dRQ3lBQklRRUNRQ0FBTFFBcFFRVkhEUUJCMGdBaEhnd1FDMEhSQUNFZURBOExRUUFoSGlBQVFRQTJBaHdnQUVHNmpvQ0FBRFlDRUNBQVFRYzJBZ3dnQUNBaVFRRnFOZ0lVREI0TElBQkJBRFlDQUNBbUlDTnJRUUpxSVFGQk5DRWVEQTBMSUFFaEFRdEJMU0VlREFzTEFrQWdBU0lkSUFKR0RRQURRQUpBSUIwdEFBQkJnS0tBZ0FCcUxRQUFJZ0ZCQVVZTkFDQUJRUUpIRFFNZ0hVRUJhaUVCREFRTElCMUJBV29pSFNBQ1J3MEFDMEV4SVI0TUd3dEJNU0VlREJvTElBQkJBRG9BTENBZElRRU1BUXRCRENFZURBZ0xRUzhoSGd3SEN5QUJRUUZxSVFGQklpRWVEQVlMUVI4aEhnd0ZDeUFBUVFBMkFnQWdJeUFrYTBFRWFpRUJRUVloSGdzZ0FDQWVPZ0FzSUFFaEFVRU5JUjRNQXdzZ0FFRUFOZ0lBSUNZZ0kydEJCMm9oQVVFTElSNE1BZ3NnQUVFQU5nSUFDeUFBUVFBNkFDd2dIQ0VCUVFraEhnd0FDd3RCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVHNGtZQ0FBRFlDRUNBQVFRODJBZ3dNRGd0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFRzRrWUNBQURZQ0VDQUFRUTgyQWd3TURRdEJBQ0VlSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdXajRDQUFEWUNFQ0FBUVFzMkFnd01EQXRCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIeGlJQ0FBRFlDRUNBQVFRczJBZ3dNQ3d0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0lqWUNBQURZQ0VDQUFRUW8yQWd3TUNnc2dBRUVDTmdJY0lBQWdBVFlDRkNBQVFmQ1NnSUFBTmdJUUlBQkJGallDREVFQUlSNE1DUXRCQVNFZURBZ0xRY1lBSVI0Z0FTSUJJQUpHRFFjZ0EwRUlhaUFBSUFFZ0FrSFlwb0NBQUVFS0VMbUFnSUFBSUFNb0Fnd2hBU0FES0FJSURnTUJCd0lBQ3hDL2dJQ0FBQUFMSUFCQkFEWUNIQ0FBUVltVGdJQUFOZ0lRSUFCQkZ6WUNEQ0FBSUFGQkFXbzJBaFJCQUNFZURBVUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2VrNENBQURZQ0VDQUFRUWsyQWd4QkFDRWVEQVFMQWtBZ0FTSUJJQUpIRFFCQklTRWVEQVFMQWtBZ0FTMEFBRUVLUmcwQUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIdWpJQ0FBRFlDRUNBQVFRbzJBZ3hCQUNFZURBUUxJQUFvQWdRaENDQUFRUUEyQWdRZ0FDQUlJQUVRcW9DQWdBQWlDQTBCSUFGQkFXb2hBUXRCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIcWtJQ0FBRFlDRUNBQVFSazJBZ3dNQWdzZ0FFRWdOZ0ljSUFBZ0NEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFZURBRUxBa0FnQVNJQklBSkhEUUJCRkNFZURBRUxJQUJCaVlDQWdBQTJBZ2dnQUNBQk5nSUVRUk1oSGdzZ0EwRVFhaVNBZ0lDQUFDQWVDNjhCQVFKL0lBRW9BZ0FoQmdKQUFrQWdBaUFEUmcwQUlBUWdCbW9oQkNBR0lBTnFJQUpySVFjZ0FpQUdRWDl6SUFWcUlnWnFJUVVEUUFKQUlBSXRBQUFnQkMwQUFFWU5BRUVDSVFRTUF3c0NRQ0FHRFFCQkFDRUVJQVVoQWd3REN5QUdRWDlxSVFZZ0JFRUJhaUVFSUFKQkFXb2lBaUFEUncwQUN5QUhJUVlnQXlFQ0N5QUFRUUUyQWdBZ0FTQUdOZ0lBSUFBZ0FqWUNCQThMSUFGQkFEWUNBQ0FBSUFRMkFnQWdBQ0FDTmdJRUN3b0FJQUFRdTRDQWdBQUxsVGNCQzM4amdJQ0FnQUJCRUdzaUFTU0FnSUNBQUFKQVFRQW9BcUMwZ0lBQURRQkJBQkMrZ0lDQUFFR0F1SVNBQUdzaUFrSFpBRWtOQUVFQUlRTUNRRUVBS0FMZ3Q0Q0FBQ0lFRFFCQkFFSi9Od0xzdDRDQUFFRUFRb0NBaElDQWdNQUFOd0xrdDRDQUFFRUFJQUZCQ0dwQmNIRkIyS3JWcWdWeklnUTJBdUMzZ0lBQVFRQkJBRFlDOUxlQWdBQkJBRUVBTmdMRXQ0Q0FBQXRCQUNBQ05nTE10NENBQUVFQVFZQzRoSUFBTmdMSXQ0Q0FBRUVBUVlDNGhJQUFOZ0tZdElDQUFFRUFJQVEyQXF5MGdJQUFRUUJCZnpZQ3FMU0FnQUFEUUNBRFFjUzBnSUFBYWlBRFFiaTBnSUFBYWlJRU5nSUFJQVFnQTBHd3RJQ0FBR29pQlRZQ0FDQURRYnkwZ0lBQWFpQUZOZ0lBSUFOQnpMU0FnQUJxSUFOQndMU0FnQUJxSWdVMkFnQWdCU0FFTmdJQUlBTkIxTFNBZ0FCcUlBTkJ5TFNBZ0FCcUlnUTJBZ0FnQkNBRk5nSUFJQU5CMExTQWdBQnFJQVEyQWdBZ0EwRWdhaUlEUVlBQ1J3MEFDMEdBdUlTQUFFRjRRWUM0aElBQWEwRVBjVUVBUVlDNGhJQUFRUWhxUVE5eEd5SURhaUlFUVFScUlBSWdBMnRCU0dvaUEwRUJjallDQUVFQVFRQW9BdkMzZ0lBQU5nS2t0SUNBQUVFQUlBUTJBcUMwZ0lBQVFRQWdBellDbExTQWdBQWdBa0dBdUlTQUFHcEJUR3BCT0RZQ0FBc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSHNBVXNOQUFKQVFRQW9Bb2kwZ0lBQUlnWkJFQ0FBUVJOcVFYQnhJQUJCQzBrYklnSkJBM1lpQkhZaUEwRURjVVVOQUNBRFFRRnhJQVJ5UVFGeklnVkJBM1FpQUVHNHRJQ0FBR29vQWdBaUJFRUlhaUVEQWtBQ1FDQUVLQUlJSWdJZ0FFR3d0SUNBQUdvaUFFY05BRUVBSUFaQmZpQUZkM0UyQW9pMGdJQUFEQUVMSUFBZ0FqWUNDQ0FDSUFBMkFnd0xJQVFnQlVFRGRDSUZRUU55TmdJRUlBUWdCV3BCQkdvaUJDQUVLQUlBUVFGeU5nSUFEQXdMSUFKQkFDZ0NrTFNBZ0FBaUIwME5BUUpBSUFORkRRQUNRQUpBSUFNZ0JIUkJBaUFFZENJRFFRQWdBMnR5Y1NJRFFRQWdBMnR4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1vaUJVRURkQ0lBUWJpMGdJQUFhaWdDQUNJRUtBSUlJZ01nQUVHd3RJQ0FBR29pQUVjTkFFRUFJQVpCZmlBRmQzRWlCallDaUxTQWdBQU1BUXNnQUNBRE5nSUlJQU1nQURZQ0RBc2dCRUVJYWlFRElBUWdBa0VEY2pZQ0JDQUVJQVZCQTNRaUJXb2dCU0FDYXlJRk5nSUFJQVFnQW1vaUFDQUZRUUZ5TmdJRUFrQWdCMFVOQUNBSFFRTjJJZ2hCQTNSQnNMU0FnQUJxSVFKQkFDZ0NuTFNBZ0FBaEJBSkFBa0FnQmtFQklBaDBJZ2h4RFFCQkFDQUdJQWh5TmdLSXRJQ0FBQ0FDSVFnTUFRc2dBaWdDQ0NFSUN5QUlJQVEyQWd3Z0FpQUVOZ0lJSUFRZ0FqWUNEQ0FFSUFnMkFnZ0xRUUFnQURZQ25MU0FnQUJCQUNBRk5nS1F0SUNBQUF3TUMwRUFLQUtNdElDQUFDSUpSUTBCSUFsQkFDQUphM0ZCZjJvaUF5QURRUXgyUVJCeElnTjJJZ1JCQlhaQkNIRWlCU0FEY2lBRUlBVjJJZ05CQW5aQkJIRWlCSElnQXlBRWRpSURRUUYyUVFKeElnUnlJQU1nQkhZaUEwRUJka0VCY1NJRWNpQURJQVIyYWtFQ2RFRzR0b0NBQUdvb0FnQWlBQ2dDQkVGNGNTQUNheUVFSUFBaEJRSkFBMEFDUUNBRktBSVFJZ01OQUNBRlFSUnFLQUlBSWdORkRRSUxJQU1vQWdSQmVIRWdBbXNpQlNBRUlBVWdCRWtpQlJzaEJDQURJQUFnQlJzaEFDQURJUVVNQUFzTElBQW9BaGdoQ2dKQUlBQW9BZ3dpQ0NBQVJnMEFRUUFvQXBpMGdJQUFJQUFvQWdnaUEwc2FJQWdnQXpZQ0NDQURJQWcyQWd3TUN3c0NRQ0FBUVJScUlnVW9BZ0FpQXcwQUlBQW9BaEFpQTBVTkF5QUFRUkJxSVFVTEEwQWdCU0VMSUFNaUNFRVVhaUlGS0FJQUlnTU5BQ0FJUVJCcUlRVWdDQ2dDRUNJRERRQUxJQXRCQURZQ0FBd0tDMEYvSVFJZ0FFRy9mMHNOQUNBQVFSTnFJZ05CY0hFaEFrRUFLQUtNdElDQUFDSUhSUTBBUVFBaEN3SkFJQUpCZ0FKSkRRQkJIeUVMSUFKQi8vLy9CMHNOQUNBRFFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1FnQkVHQTRCOXFRUkIyUVFSeElnUjBJZ1VnQlVHQWdBOXFRUkIyUVFKeElnVjBRUTkySUFNZ0JISWdCWEpySWdOQkFYUWdBaUFEUVJWcWRrRUJjWEpCSEdvaEN3dEJBQ0FDYXlFRUFrQUNRQUpBQWtBZ0MwRUNkRUc0dG9DQUFHb29BZ0FpQlEwQVFRQWhBMEVBSVFnTUFRdEJBQ0VESUFKQkFFRVpJQXRCQVhacklBdEJIMFliZENFQVFRQWhDQU5BQWtBZ0JTZ0NCRUY0Y1NBQ2F5SUdJQVJQRFFBZ0JpRUVJQVVoQ0NBR0RRQkJBQ0VFSUFVaENDQUZJUU1NQXdzZ0F5QUZRUlJxS0FJQUlnWWdCaUFGSUFCQkhYWkJCSEZxUVJCcUtBSUFJZ1ZHR3lBRElBWWJJUU1nQUVFQmRDRUFJQVVOQUFzTEFrQWdBeUFJY2cwQVFRQWhDRUVDSUF0MElnTkJBQ0FEYTNJZ0IzRWlBMFVOQXlBRFFRQWdBMnR4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlGUVFWMlFRaHhJZ0FnQTNJZ0JTQUFkaUlEUVFKMlFRUnhJZ1Z5SUFNZ0JYWWlBMEVCZGtFQ2NTSUZjaUFESUFWMklnTkJBWFpCQVhFaUJYSWdBeUFGZG1wQkFuUkJ1TGFBZ0FCcUtBSUFJUU1MSUFORkRRRUxBMEFnQXlnQ0JFRjRjU0FDYXlJR0lBUkpJUUFDUUNBREtBSVFJZ1VOQUNBRFFSUnFLQUlBSVFVTElBWWdCQ0FBR3lFRUlBTWdDQ0FBR3lFSUlBVWhBeUFGRFFBTEN5QUlSUTBBSUFSQkFDZ0NrTFNBZ0FBZ0FtdFBEUUFnQ0NnQ0dDRUxBa0FnQ0NnQ0RDSUFJQWhHRFFCQkFDZ0NtTFNBZ0FBZ0NDZ0NDQ0lEU3hvZ0FDQUROZ0lJSUFNZ0FEWUNEQXdKQ3dKQUlBaEJGR29pQlNnQ0FDSUREUUFnQ0NnQ0VDSURSUTBESUFoQkVHb2hCUXNEUUNBRklRWWdBeUlBUVJScUlnVW9BZ0FpQXcwQUlBQkJFR29oQlNBQUtBSVFJZ01OQUFzZ0JrRUFOZ0lBREFnTEFrQkJBQ2dDa0xTQWdBQWlBeUFDU1EwQVFRQW9BcHkwZ0lBQUlRUUNRQUpBSUFNZ0Ftc2lCVUVRU1EwQUlBUWdBbW9pQUNBRlFRRnlOZ0lFUVFBZ0JUWUNrTFNBZ0FCQkFDQUFOZ0tjdElDQUFDQUVJQU5xSUFVMkFnQWdCQ0FDUVFOeU5nSUVEQUVMSUFRZ0EwRURjallDQkNBRElBUnFRUVJxSWdNZ0F5Z0NBRUVCY2pZQ0FFRUFRUUEyQXB5MGdJQUFRUUJCQURZQ2tMU0FnQUFMSUFSQkNHb2hBd3dLQ3dKQVFRQW9BcFMwZ0lBQUlnQWdBazBOQUVFQUtBS2d0SUNBQUNJRElBSnFJZ1FnQUNBQ2F5SUZRUUZ5TmdJRVFRQWdCVFlDbExTQWdBQkJBQ0FFTmdLZ3RJQ0FBQ0FESUFKQkEzSTJBZ1FnQTBFSWFpRUREQW9MQWtBQ1FFRUFLQUxndDRDQUFFVU5BRUVBS0FMb3Q0Q0FBQ0VFREFFTFFRQkNmemNDN0xlQWdBQkJBRUtBZ0lTQWdJREFBRGNDNUxlQWdBQkJBQ0FCUVF4cVFYQnhRZGlxMWFvRmN6WUM0TGVBZ0FCQkFFRUFOZ0wwdDRDQUFFRUFRUUEyQXNTM2dJQUFRWUNBQkNFRUMwRUFJUU1DUUNBRUlBSkJ4d0JxSWdkcUlnWkJBQ0FFYXlJTGNTSUlJQUpMRFFCQkFFRXdOZ0w0dDRDQUFBd0tDd0pBUVFBb0FzQzNnSUFBSWdORkRRQUNRRUVBS0FLNHQ0Q0FBQ0lFSUFocUlnVWdCRTBOQUNBRklBTk5EUUVMUVFBaEEwRUFRVEEyQXZpM2dJQUFEQW9MUVFBdEFNUzNnSUFBUVFSeERRUUNRQUpBQWtCQkFDZ0NvTFNBZ0FBaUJFVU5BRUhJdDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlBUkxEUU1MSUFNb0FnZ2lBdzBBQ3d0QkFCQytnSUNBQUNJQVFYOUdEUVVnQ0NFR0FrQkJBQ2dDNUxlQWdBQWlBMEYvYWlJRUlBQnhSUTBBSUFnZ0FHc2dCQ0FBYWtFQUlBTnJjV29oQmdzZ0JpQUNUUTBGSUFaQi92Ly8vd2RMRFFVQ1FFRUFLQUxBdDRDQUFDSURSUTBBUVFBb0FyaTNnSUFBSWdRZ0Jtb2lCU0FFVFEwR0lBVWdBMHNOQmdzZ0JoQytnSUNBQUNJRElBQkhEUUVNQndzZ0JpQUFheUFMY1NJR1FmNy8vLzhIU3cwRUlBWVF2b0NBZ0FBaUFDQURLQUlBSUFNb0FnUnFSZzBESUFBaEF3c0NRQ0FEUVg5R0RRQWdBa0hJQUdvZ0JrME5BQUpBSUFjZ0JtdEJBQ2dDNkxlQWdBQWlCR3BCQUNBRWEzRWlCRUgrLy8vL0IwME5BQ0FESVFBTUJ3c0NRQ0FFRUw2QWdJQUFRWDlHRFFBZ0JDQUdhaUVHSUFNaEFBd0hDMEVBSUFackVMNkFnSUFBR2d3RUN5QURJUUFnQTBGL1J3MEZEQU1MUVFBaENBd0hDMEVBSVFBTUJRc2dBRUYvUncwQ0MwRUFRUUFvQXNTM2dJQUFRUVJ5TmdMRXQ0Q0FBQXNnQ0VIKy8vLy9CMHNOQVNBSUVMNkFnSUFBSVFCQkFCQytnSUNBQUNFRElBQkJmMFlOQVNBRFFYOUdEUUVnQUNBRFR3MEJJQU1nQUdzaUJpQUNRVGhxVFEwQkMwRUFRUUFvQXJpM2dJQUFJQVpxSWdNMkFyaTNnSUFBQWtBZ0EwRUFLQUs4dDRDQUFFME5BRUVBSUFNMkFyeTNnSUFBQ3dKQUFrQUNRQUpBUVFBb0FxQzBnSUFBSWdSRkRRQkJ5TGVBZ0FBaEF3TkFJQUFnQXlnQ0FDSUZJQU1vQWdRaUNHcEdEUUlnQXlnQ0NDSUREUUFNQXdzTEFrQUNRRUVBS0FLWXRJQ0FBQ0lEUlEwQUlBQWdBMDhOQVF0QkFDQUFOZ0tZdElDQUFBdEJBQ0VEUVFBZ0JqWUN6TGVBZ0FCQkFDQUFOZ0xJdDRDQUFFRUFRWDgyQXFpMGdJQUFRUUJCQUNnQzRMZUFnQUEyQXF5MGdJQUFRUUJCQURZQzFMZUFnQUFEUUNBRFFjUzBnSUFBYWlBRFFiaTBnSUFBYWlJRU5nSUFJQVFnQTBHd3RJQ0FBR29pQlRZQ0FDQURRYnkwZ0lBQWFpQUZOZ0lBSUFOQnpMU0FnQUJxSUFOQndMU0FnQUJxSWdVMkFnQWdCU0FFTmdJQUlBTkIxTFNBZ0FCcUlBTkJ5TFNBZ0FCcUlnUTJBZ0FnQkNBRk5nSUFJQU5CMExTQWdBQnFJQVEyQWdBZ0EwRWdhaUlEUVlBQ1J3MEFDeUFBUVhnZ0FHdEJEM0ZCQUNBQVFRaHFRUTl4R3lJRGFpSUVJQVlnQTJ0QlNHb2lBMEVCY2pZQ0JFRUFRUUFvQXZDM2dJQUFOZ0trdElDQUFFRUFJQVEyQXFDMGdJQUFRUUFnQXpZQ2xMU0FnQUFnQmlBQWFrRk1ha0U0TmdJQURBSUxJQU10QUF4QkNIRU5BQ0FGSUFSTERRQWdBQ0FFVFEwQUlBUkJlQ0FFYTBFUGNVRUFJQVJCQ0dwQkQzRWJJZ1ZxSWdCQkFDZ0NsTFNBZ0FBZ0Jtb2lDeUFGYXlJRlFRRnlOZ0lFSUFNZ0NDQUdhallDQkVFQVFRQW9BdkMzZ0lBQU5nS2t0SUNBQUVFQUlBVTJBcFMwZ0lBQVFRQWdBRFlDb0xTQWdBQWdDeUFFYWtFRWFrRTROZ0lBREFFTEFrQWdBRUVBS0FLWXRJQ0FBQ0lMVHcwQVFRQWdBRFlDbUxTQWdBQWdBQ0VMQ3lBQUlBWnFJUWhCeUxlQWdBQWhBd0pBQWtBQ1FBSkFBa0FDUUFKQUEwQWdBeWdDQUNBSVJnMEJJQU1vQWdnaUF3MEFEQUlMQ3lBRExRQU1RUWh4UlEwQkMwSEl0NENBQUNFREEwQUNRQ0FES0FJQUlnVWdCRXNOQUNBRklBTW9BZ1JxSWdVZ0JFc05Bd3NnQXlnQ0NDRUREQUFMQ3lBRElBQTJBZ0FnQXlBREtBSUVJQVpxTmdJRUlBQkJlQ0FBYTBFUGNVRUFJQUJCQ0dwQkQzRWJhaUlHSUFKQkEzSTJBZ1FnQ0VGNElBaHJRUTl4UVFBZ0NFRUlha0VQY1J0cUlnZ2dCaUFDYWlJQ2F5RUZBa0FnQkNBSVJ3MEFRUUFnQWpZQ29MU0FnQUJCQUVFQUtBS1V0SUNBQUNBRmFpSUROZ0tVdElDQUFDQUNJQU5CQVhJMkFnUU1Bd3NDUUVFQUtBS2N0SUNBQUNBSVJ3MEFRUUFnQWpZQ25MU0FnQUJCQUVFQUtBS1F0SUNBQUNBRmFpSUROZ0tRdElDQUFDQUNJQU5CQVhJMkFnUWdBaUFEYWlBRE5nSUFEQU1MQWtBZ0NDZ0NCQ0lEUVFOeFFRRkhEUUFnQTBGNGNTRUhBa0FDUUNBRFFmOEJTdzBBSUFnb0FnZ2lCQ0FEUVFOMklndEJBM1JCc0xTQWdBQnFJZ0JHR2dKQUlBZ29BZ3dpQXlBRVJ3MEFRUUJCQUNnQ2lMU0FnQUJCZmlBTGQzRTJBb2kwZ0lBQURBSUxJQU1nQUVZYUlBTWdCRFlDQ0NBRUlBTTJBZ3dNQVFzZ0NDZ0NHQ0VKQWtBQ1FDQUlLQUlNSWdBZ0NFWU5BQ0FMSUFnb0FnZ2lBMHNhSUFBZ0F6WUNDQ0FESUFBMkFnd01BUXNDUUNBSVFSUnFJZ01vQWdBaUJBMEFJQWhCRUdvaUF5Z0NBQ0lFRFFCQkFDRUFEQUVMQTBBZ0F5RUxJQVFpQUVFVWFpSURLQUlBSWdRTkFDQUFRUkJxSVFNZ0FDZ0NFQ0lFRFFBTElBdEJBRFlDQUFzZ0NVVU5BQUpBQWtBZ0NDZ0NIQ0lFUVFKMFFiaTJnSUFBYWlJREtBSUFJQWhIRFFBZ0F5QUFOZ0lBSUFBTkFVRUFRUUFvQW95MGdJQUFRWDRnQkhkeE5nS010SUNBQUF3Q0N5QUpRUkJCRkNBSktBSVFJQWhHRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQWsyQWhnQ1FDQUlLQUlRSWdORkRRQWdBQ0FETmdJUUlBTWdBRFlDR0FzZ0NDZ0NGQ0lEUlEwQUlBQkJGR29nQXpZQ0FDQURJQUEyQWhnTElBY2dCV29oQlNBSUlBZHFJUWdMSUFnZ0NDZ0NCRUYrY1RZQ0JDQUNJQVZxSUFVMkFnQWdBaUFGUVFGeU5nSUVBa0FnQlVIL0FVc05BQ0FGUVFOMklnUkJBM1JCc0xTQWdBQnFJUU1DUUFKQVFRQW9Bb2kwZ0lBQUlnVkJBU0FFZENJRWNRMEFRUUFnQlNBRWNqWUNpTFNBZ0FBZ0F5RUVEQUVMSUFNb0FnZ2hCQXNnQkNBQ05nSU1JQU1nQWpZQ0NDQUNJQU0yQWd3Z0FpQUVOZ0lJREFNTFFSOGhBd0pBSUFWQi8vLy9CMHNOQUNBRlFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1FnQkVHQTRCOXFRUkIyUVFSeElnUjBJZ0FnQUVHQWdBOXFRUkIyUVFKeElnQjBRUTkySUFNZ0JISWdBSEpySWdOQkFYUWdCU0FEUVJWcWRrRUJjWEpCSEdvaEF3c2dBaUFETmdJY0lBSkNBRGNDRUNBRFFRSjBRYmkyZ0lBQWFpRUVBa0JCQUNnQ2pMU0FnQUFpQUVFQklBTjBJZ2h4RFFBZ0JDQUNOZ0lBUVFBZ0FDQUljallDakxTQWdBQWdBaUFFTmdJWUlBSWdBallDQ0NBQ0lBSTJBZ3dNQXdzZ0JVRUFRUmtnQTBFQmRtc2dBMEVmUmh0MElRTWdCQ2dDQUNFQUEwQWdBQ0lFS0FJRVFYaHhJQVZHRFFJZ0EwRWRkaUVBSUFOQkFYUWhBeUFFSUFCQkJIRnFRUkJxSWdnb0FnQWlBQTBBQ3lBSUlBSTJBZ0FnQWlBRU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFnc2dBRUY0SUFCclFROXhRUUFnQUVFSWFrRVBjUnNpQTJvaUN5QUdJQU5yUVVocUlnTkJBWEkyQWdRZ0NFRk1ha0U0TmdJQUlBUWdCVUUzSUFWclFROXhRUUFnQlVGSmFrRVBjUnRxUVVGcUlnZ2dDQ0FFUVJCcVNSc2lDRUVqTmdJRVFRQkJBQ2dDOExlQWdBQTJBcVMwZ0lBQVFRQWdDellDb0xTQWdBQkJBQ0FETmdLVXRJQ0FBQ0FJUVJCcVFRQXBBdEMzZ0lBQU53SUFJQWhCQUNrQ3lMZUFnQUEzQWdoQkFDQUlRUWhxTmdMUXQ0Q0FBRUVBSUFZMkFzeTNnSUFBUVFBZ0FEWUN5TGVBZ0FCQkFFRUFOZ0xVdDRDQUFDQUlRU1JxSVFNRFFDQURRUWMyQWdBZ0JTQURRUVJxSWdOTERRQUxJQWdnQkVZTkF5QUlJQWdvQWdSQmZuRTJBZ1FnQ0NBSUlBUnJJZ1kyQWdBZ0JDQUdRUUZ5TmdJRUFrQWdCa0gvQVVzTkFDQUdRUU4ySWdWQkEzUkJzTFNBZ0FCcUlRTUNRQUpBUVFBb0FvaTBnSUFBSWdCQkFTQUZkQ0lGY1EwQVFRQWdBQ0FGY2pZQ2lMU0FnQUFnQXlFRkRBRUxJQU1vQWdnaEJRc2dCU0FFTmdJTUlBTWdCRFlDQ0NBRUlBTTJBZ3dnQkNBRk5nSUlEQVFMUVI4aEF3SkFJQVpCLy8vL0Iwc05BQ0FHUVFoMklnTWdBMEdBL2o5cVFSQjJRUWh4SWdOMElnVWdCVUdBNEI5cVFSQjJRUVJ4SWdWMElnQWdBRUdBZ0E5cVFSQjJRUUp4SWdCMFFROTJJQU1nQlhJZ0FISnJJZ05CQVhRZ0JpQURRUlZxZGtFQmNYSkJIR29oQXdzZ0JFSUFOd0lRSUFSQkhHb2dBellDQUNBRFFRSjBRYmkyZ0lBQWFpRUZBa0JCQUNnQ2pMU0FnQUFpQUVFQklBTjBJZ2h4RFFBZ0JTQUVOZ0lBUVFBZ0FDQUljallDakxTQWdBQWdCRUVZYWlBRk5nSUFJQVFnQkRZQ0NDQUVJQVEyQWd3TUJBc2dCa0VBUVJrZ0EwRUJkbXNnQTBFZlJodDBJUU1nQlNnQ0FDRUFBMEFnQUNJRktBSUVRWGh4SUFaR0RRTWdBMEVkZGlFQUlBTkJBWFFoQXlBRklBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQVEyQWdBZ0JFRVlhaUFGTmdJQUlBUWdCRFlDRENBRUlBUTJBZ2dNQXdzZ0JDZ0NDQ0lESUFJMkFnd2dCQ0FDTmdJSUlBSkJBRFlDR0NBQ0lBUTJBZ3dnQWlBRE5nSUlDeUFHUVFocUlRTU1CUXNnQlNnQ0NDSURJQVEyQWd3Z0JTQUVOZ0lJSUFSQkdHcEJBRFlDQUNBRUlBVTJBZ3dnQkNBRE5nSUlDMEVBS0FLVXRJQ0FBQ0lESUFKTkRRQkJBQ2dDb0xTQWdBQWlCQ0FDYWlJRklBTWdBbXNpQTBFQmNqWUNCRUVBSUFNMkFwUzBnSUFBUVFBZ0JUWUNvTFNBZ0FBZ0JDQUNRUU55TmdJRUlBUkJDR29oQXd3REMwRUFJUU5CQUVFd05nTDR0NENBQUF3Q0N3SkFJQXRGRFFBQ1FBSkFJQWdnQ0NnQ0hDSUZRUUowUWJpMmdJQUFhaUlES0FJQVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUNBSFFYNGdCWGR4SWdjMkFveTBnSUFBREFJTElBdEJFRUVVSUFzb0FoQWdDRVliYWlBQU5nSUFJQUJGRFFFTElBQWdDellDR0FKQUlBZ29BaEFpQTBVTkFDQUFJQU0yQWhBZ0F5QUFOZ0lZQ3lBSVFSUnFLQUlBSWdORkRRQWdBRUVVYWlBRE5nSUFJQU1nQURZQ0dBc0NRQUpBSUFSQkQwc05BQ0FJSUFRZ0Ftb2lBMEVEY2pZQ0JDQURJQWhxUVFScUlnTWdBeWdDQUVFQmNqWUNBQXdCQ3lBSUlBSnFJZ0FnQkVFQmNqWUNCQ0FJSUFKQkEzSTJBZ1FnQUNBRWFpQUVOZ0lBQWtBZ0JFSC9BVXNOQUNBRVFRTjJJZ1JCQTNSQnNMU0FnQUJxSVFNQ1FBSkFRUUFvQW9pMGdJQUFJZ1ZCQVNBRWRDSUVjUTBBUVFBZ0JTQUVjallDaUxTQWdBQWdBeUVFREFFTElBTW9BZ2doQkFzZ0JDQUFOZ0lNSUFNZ0FEWUNDQ0FBSUFNMkFnd2dBQ0FFTmdJSURBRUxRUjhoQXdKQUlBUkIvLy8vQjBzTkFDQUVRUWgySWdNZ0EwR0EvajlxUVJCMlFRaHhJZ04wSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdJZ0FrR0FnQTlxUVJCMlFRSnhJZ0owUVE5MklBTWdCWElnQW5KcklnTkJBWFFnQkNBRFFSVnFka0VCY1hKQkhHb2hBd3NnQUNBRE5nSWNJQUJDQURjQ0VDQURRUUowUWJpMmdJQUFhaUVGQWtBZ0IwRUJJQU4wSWdKeERRQWdCU0FBTmdJQVFRQWdCeUFDY2pZQ2pMU0FnQUFnQUNBRk5nSVlJQUFnQURZQ0NDQUFJQUEyQWd3TUFRc2dCRUVBUVJrZ0EwRUJkbXNnQTBFZlJodDBJUU1nQlNnQ0FDRUNBa0FEUUNBQ0lnVW9BZ1JCZUhFZ0JFWU5BU0FEUVIxMklRSWdBMEVCZENFRElBVWdBa0VFY1dwQkVHb2lCaWdDQUNJQ0RRQUxJQVlnQURZQ0FDQUFJQVUyQWhnZ0FDQUFOZ0lNSUFBZ0FEWUNDQXdCQ3lBRktBSUlJZ01nQURZQ0RDQUZJQUEyQWdnZ0FFRUFOZ0lZSUFBZ0JUWUNEQ0FBSUFNMkFnZ0xJQWhCQ0dvaEF3d0JDd0pBSUFwRkRRQUNRQUpBSUFBZ0FDZ0NIQ0lGUVFKMFFiaTJnSUFBYWlJREtBSUFSdzBBSUFNZ0NEWUNBQ0FJRFFGQkFDQUpRWDRnQlhkeE5nS010SUNBQUF3Q0N5QUtRUkJCRkNBS0tBSVFJQUJHRzJvZ0NEWUNBQ0FJUlEwQkN5QUlJQW8yQWhnQ1FDQUFLQUlRSWdORkRRQWdDQ0FETmdJUUlBTWdDRFlDR0FzZ0FFRVVhaWdDQUNJRFJRMEFJQWhCRkdvZ0F6WUNBQ0FESUFnMkFoZ0xBa0FDUUNBRVFROUxEUUFnQUNBRUlBSnFJZ05CQTNJMkFnUWdBeUFBYWtFRWFpSURJQU1vQWdCQkFYSTJBZ0FNQVFzZ0FDQUNhaUlGSUFSQkFYSTJBZ1FnQUNBQ1FRTnlOZ0lFSUFVZ0JHb2dCRFlDQUFKQUlBZEZEUUFnQjBFRGRpSUlRUU4wUWJDMGdJQUFhaUVDUVFBb0FweTBnSUFBSVFNQ1FBSkFRUUVnQ0hRaUNDQUdjUTBBUVFBZ0NDQUdjallDaUxTQWdBQWdBaUVJREFFTElBSW9BZ2doQ0FzZ0NDQUROZ0lNSUFJZ0F6WUNDQ0FESUFJMkFnd2dBeUFJTmdJSUMwRUFJQVUyQXB5MGdJQUFRUUFnQkRZQ2tMU0FnQUFMSUFCQkNHb2hBd3NnQVVFUWFpU0FnSUNBQUNBREN3b0FJQUFRdllDQWdBQUw4QTBCQjM4Q1FDQUFSUTBBSUFCQmVHb2lBU0FBUVh4cUtBSUFJZ0pCZUhFaUFHb2hBd0pBSUFKQkFYRU5BQ0FDUVFOeFJRMEJJQUVnQVNnQ0FDSUNheUlCUVFBb0FwaTBnSUFBSWdSSkRRRWdBaUFBYWlFQUFrQkJBQ2dDbkxTQWdBQWdBVVlOQUFKQUlBSkIvd0ZMRFFBZ0FTZ0NDQ0lFSUFKQkEzWWlCVUVEZEVHd3RJQ0FBR29pQmtZYUFrQWdBU2dDRENJQ0lBUkhEUUJCQUVFQUtBS0l0SUNBQUVGK0lBVjNjVFlDaUxTQWdBQU1Bd3NnQWlBR1Job2dBaUFFTmdJSUlBUWdBallDREF3Q0N5QUJLQUlZSVFjQ1FBSkFJQUVvQWd3aUJpQUJSZzBBSUFRZ0FTZ0NDQ0lDU3hvZ0JpQUNOZ0lJSUFJZ0JqWUNEQXdCQ3dKQUlBRkJGR29pQWlnQ0FDSUVEUUFnQVVFUWFpSUNLQUlBSWdRTkFFRUFJUVlNQVFzRFFDQUNJUVVnQkNJR1FSUnFJZ0lvQWdBaUJBMEFJQVpCRUdvaEFpQUdLQUlRSWdRTkFBc2dCVUVBTmdJQUN5QUhSUTBCQWtBQ1FDQUJLQUljSWdSQkFuUkJ1TGFBZ0FCcUlnSW9BZ0FnQVVjTkFDQUNJQVkyQWdBZ0JnMEJRUUJCQUNnQ2pMU0FnQUJCZmlBRWQzRTJBb3kwZ0lBQURBTUxJQWRCRUVFVUlBY29BaEFnQVVZYmFpQUdOZ0lBSUFaRkRRSUxJQVlnQnpZQ0dBSkFJQUVvQWhBaUFrVU5BQ0FHSUFJMkFoQWdBaUFHTmdJWUN5QUJLQUlVSWdKRkRRRWdCa0VVYWlBQ05nSUFJQUlnQmpZQ0dBd0JDeUFES0FJRUlnSkJBM0ZCQTBjTkFDQURJQUpCZm5FMkFnUkJBQ0FBTmdLUXRJQ0FBQ0FCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFRHdzZ0F5QUJUUTBBSUFNb0FnUWlBa0VCY1VVTkFBSkFBa0FnQWtFQ2NRMEFBa0JCQUNnQ29MU0FnQUFnQTBjTkFFRUFJQUUyQXFDMGdJQUFRUUJCQUNnQ2xMU0FnQUFnQUdvaUFEWUNsTFNBZ0FBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbkxTQWdBQkhEUU5CQUVFQU5nS1F0SUNBQUVFQVFRQTJBcHkwZ0lBQUR3c0NRRUVBS0FLY3RJQ0FBQ0FEUncwQVFRQWdBVFlDbkxTQWdBQkJBRUVBS0FLUXRJQ0FBQ0FBYWlJQU5nS1F0SUNBQUNBQklBQkJBWEkyQWdRZ0FTQUFhaUFBTmdJQUR3c2dBa0Y0Y1NBQWFpRUFBa0FDUUNBQ1FmOEJTdzBBSUFNb0FnZ2lCQ0FDUVFOMklnVkJBM1JCc0xTQWdBQnFJZ1pHR2dKQUlBTW9BZ3dpQWlBRVJ3MEFRUUJCQUNnQ2lMU0FnQUJCZmlBRmQzRTJBb2kwZ0lBQURBSUxJQUlnQmtZYUlBSWdCRFlDQ0NBRUlBSTJBZ3dNQVFzZ0F5Z0NHQ0VIQWtBQ1FDQURLQUlNSWdZZ0EwWU5BRUVBS0FLWXRJQ0FBQ0FES0FJSUlnSkxHaUFHSUFJMkFnZ2dBaUFHTmdJTURBRUxBa0FnQTBFVWFpSUNLQUlBSWdRTkFDQURRUkJxSWdJb0FnQWlCQTBBUVFBaEJnd0JDd05BSUFJaEJTQUVJZ1pCRkdvaUFpZ0NBQ0lFRFFBZ0JrRVFhaUVDSUFZb0FoQWlCQTBBQ3lBRlFRQTJBZ0FMSUFkRkRRQUNRQUpBSUFNb0Fod2lCRUVDZEVHNHRvQ0FBR29pQWlnQ0FDQURSdzBBSUFJZ0JqWUNBQ0FHRFFGQkFFRUFLQUtNdElDQUFFRitJQVIzY1RZQ2pMU0FnQUFNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFZMkFnQWdCa1VOQVFzZ0JpQUhOZ0lZQWtBZ0F5Z0NFQ0lDUlEwQUlBWWdBallDRUNBQ0lBWTJBaGdMSUFNb0FoUWlBa1VOQUNBR1FSUnFJQUkyQWdBZ0FpQUdOZ0lZQ3lBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbkxTQWdBQkhEUUZCQUNBQU5nS1F0SUNBQUE4TElBTWdBa0YrY1RZQ0JDQUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVDd0pBSUFCQi93RkxEUUFnQUVFRGRpSUNRUU4wUWJDMGdJQUFhaUVBQWtBQ1FFRUFLQUtJdElDQUFDSUVRUUVnQW5RaUFuRU5BRUVBSUFRZ0FuSTJBb2kwZ0lBQUlBQWhBZ3dCQ3lBQUtBSUlJUUlMSUFJZ0FUWUNEQ0FBSUFFMkFnZ2dBU0FBTmdJTUlBRWdBallDQ0E4TFFSOGhBZ0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ0lnQWtHQS9qOXFRUkIyUVFoeElnSjBJZ1FnQkVHQTRCOXFRUkIyUVFSeElnUjBJZ1lnQmtHQWdBOXFRUkIyUVFKeElnWjBRUTkySUFJZ0JISWdCbkpySWdKQkFYUWdBQ0FDUVJWcWRrRUJjWEpCSEdvaEFnc2dBVUlBTndJUUlBRkJIR29nQWpZQ0FDQUNRUUowUWJpMmdJQUFhaUVFQWtBQ1FFRUFLQUtNdElDQUFDSUdRUUVnQW5RaUEzRU5BQ0FFSUFFMkFnQkJBQ0FHSUFOeU5nS010SUNBQUNBQlFSaHFJQVEyQWdBZ0FTQUJOZ0lJSUFFZ0FUWUNEQXdCQ3lBQVFRQkJHU0FDUVFGMmF5QUNRUjlHRzNRaEFpQUVLQUlBSVFZQ1FBTkFJQVlpQkNnQ0JFRjRjU0FBUmcwQklBSkJIWFloQmlBQ1FRRjBJUUlnQkNBR1FRUnhha0VRYWlJREtBSUFJZ1lOQUFzZ0F5QUJOZ0lBSUFGQkdHb2dCRFlDQUNBQklBRTJBZ3dnQVNBQk5nSUlEQUVMSUFRb0FnZ2lBQ0FCTmdJTUlBUWdBVFlDQ0NBQlFSaHFRUUEyQWdBZ0FTQUVOZ0lNSUFFZ0FEWUNDQXRCQUVFQUtBS290SUNBQUVGL2FpSUJRWDhnQVJzMkFxaTBnSUFBQ3d0T0FBSkFJQUFOQUQ4QVFSQjBEd3NDUUNBQVFmLy9BM0VOQUNBQVFYOU1EUUFDUUNBQVFSQjJRQUFpQUVGL1J3MEFRUUJCTURZQytMZUFnQUJCZnc4TElBQkJFSFFQQ3hDL2dJQ0FBQUFMQkFBQUFBc0xqaXdCQUVHQUNBdUdMQUVBQUFBQ0FBQUFBd0FBQUFRQUFBQUZBQUFBQmdBQUFBY0FBQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCeGRXVnllUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMkp2WkhrQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnYjNabGNtWnNiM2NBUTJoMWJtc2djMmw2WlNCdmRtVnlabXh2ZHdCU1pYTndiMjV6WlNCdmRtVnlabXh2ZHdCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1NGUlVVQzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1VsUlRVQzk0TG5nZ2NtVnhkV1Z6ZEFCRmVIQmxZM1JsWkNCVFQxVlNRMFVnYldWMGFHOWtJR1p2Y2lCSlEwVXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCbWNtRm5iV1Z1ZENCemRHRnlkQUJGZUhCbFkzUmxaQ0JrYjNRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5emRHRjBkWE1BU1c1MllXeHBaQ0J5WlhOd2IyNXpaU0J6ZEdGMGRYTUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2djR0Z5WVcxbGRHVnljd0JWYzJWeUlHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5b1pXRmtaWEpnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJKbFoybHVZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhObGNuWmxjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjJZV3gxWlNCamFHRnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlHWnBaV3hrSUdOb1lYSUFTVzUyWVd4cFpDQnRhVzV2Y2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnYldGcWIzSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJRU5TVEVZZ1lXWjBaWElnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FFVnRjSFI1SUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVRXbHpjMmx1WnlCbGVIQmxZM1JsWkNCRFVpQmhablJsY2lCb1pXRmtaWElnZG1Gc2RXVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQk1SaUJoWm5SbGNpQm9aV0ZrWlhJZ2RtRnNkV1VBU1c1MllXeHBaQ0JnVkhKaGJuTm1aWEl0Ulc1amIyUnBibWRnSUdobFlXUmxjaUIyWVd4MVpRQlFZWFZ6WldRZ1lua2diMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUJKYm5aaGJHbGtJRVZQUmlCemRHRjBaUUJ2Ymw5amFIVnVhMTlvWldGa1pYSWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWlaV2RwYmlCd1lYVnpaUUJ2Ymw5amFIVnVhMTlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxJSEJoZFhObEFGQmhkWE5sSUc5dUlFTlBUazVGUTFRdlZYQm5jbUZrWlFCUVlYVnpaU0J2YmlCUVVra3ZWWEJuY21Ga1pRQkZlSEJsWTNSbFpDQklWRlJRTHpJZ1EyOXVibVZqZEdsdmJpQlFjbVZtWVdObEFFVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJRzFsZEdodlpBQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyaGxZV1JsY2w5bWFXVnNaQUJRWVhWelpXUUFTVzUyWVd4cFpDQjNiM0prSUdWdVkyOTFiblJsY21Wa0FFbHVkbUZzYVdRZ2JXVjBhRzlrSUdWdVkyOTFiblJsY21Wa0FGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJOb1pXMWhBRkpsY1hWbGMzUWdhR0Z6SUdsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUFCTlMwRkRWRWxXU1ZSWkFFTlBVRmtBVGs5VVNVWlpBRkJNUVZrQVVGVlVBRU5JUlVOTFQxVlVBRkJQVTFRQVVrVlFUMUpVQUVoUVJWOUpUbFpCVEVsRVgwTlBUbE5VUVU1VUFFZEZWQUJJVUVWZlUxUlNTVU5VQUZKRlJFbFNSVU5VQUVOUFRrNUZRMVFBU0ZCRlgwbE9Wa0ZNU1VSZlUxUkJWRlZUQUU5UVZFbFBUbE1BVTBWVVgxQkJVa0ZOUlZSRlVnQkhSVlJmVUVGU1FVMUZWRVZTQUVoUVJWOVZVMFZTQUVoUVJWOURRbDlEU0ZWT1MxOUlSVUZFUlZJQVRVdERRVXhGVGtSQlVnQlRSVlJWVUFCVVJVRlNSRTlYVGdCSVVFVmZRMHhQVTBWRVgwTlBUazVGUTFSSlQwNEFTRkJGWDBsT1ZrRk1TVVJmVmtWU1UwbFBUZ0JJVUVWZlEwSmZUVVZUVTBGSFJWOUNSVWRKVGdCSVVFVmZTVTVXUVV4SlJGOUlSVUZFUlZKZlZFOUxSVTRBU0ZCRlgwbE9Wa0ZNU1VSZlZWSk1BRTFMUTA5TUFFRkRUQUJJVUVWZlNVNVVSVkpPUVV3QVNGQkZYMDlMQUZWT1RFbE9Td0JWVGt4UFEwc0FVRkpKQUVoUVJWOUpUbFpCVEVsRVgwTlBUbFJGVGxSZlRFVk9SMVJJQUVoUVJWOVZUa1ZZVUVWRFZFVkVYME5QVGxSRlRsUmZURVZPUjFSSUFFWk1WVk5JQUZCU1QxQlFRVlJEU0FCTkxWTkZRVkpEU0FCSVVFVmZTVTVXUVV4SlJGOVVVa0ZPVTBaRlVsOUZUa05QUkVsT1J3QkZlSEJsWTNSbFpDQkRVa3hHQUVoUVJWOUpUbFpCVEVsRVgwTklWVTVMWDFOSldrVUFUVTlXUlFCSVVFVmZRMEpmU0VWQlJFVlNVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlUxTkJSMFZmUTA5TlVFeEZWRVVBUkVWTVJWUkZBRWhRUlY5SlRsWkJURWxFWDBWUFJsOVRWRUZVUlFCUVFWVlRSUUJRVlZKSFJRQk5SVkpIUlFCSVVFVmZVRUZWVTBWRVgxVlFSMUpCUkVVQVNGQkZYMUJCVlZORlJGOUlNbDlWVUVkU1FVUkZBRk5QVlZKRFJRQkJUazVQVlU1RFJRQlVVa0ZEUlFCRVJWTkRVa2xDUlFCVlRsTlZRbE5EVWtsQ1JRQlNSVU5QVWtRQVNGQkZYMGxPVmtGTVNVUmZUVVZVU0U5RUFGQlNUMUJHU1U1RUFGVk9Ra2xPUkFCU1JVSkpUa1FBU0ZCRlgwTlNYMFZZVUVWRFZFVkVBRWhRUlY5TVJsOUZXRkJGUTFSRlJBQklVRVZmVUVGVlUwVkVBRWhGUVVRQVJYaHdaV04wWldRZ1NGUlVVQzhBM0FzQUFNOExBQURUQ2dBQW1RMEFBQkFNQUFCZEN3QUFYdzBBQUxVTEFBQzZDZ0FBY3dzQUFKd0xBQUQxQ3dBQWN3d0FBTzhLQUFEY0RBQUFSd3dBQUljTEFBQ1BEQUFBdlF3QUFDOExBQUNuREFBQXFRMEFBQVFOQUFBWERRQUFKZ3NBQUlrTkFBRFZEQUFBendvQUFMUU5BQUN1Q2dBQW9Rb0FBT2NLQUFBQ0N3QUFQUTBBQUpBS0FBRHNDd0FBeFFzQUFJb01BQUJ5RFFBQU5Bd0FBRUFNQUFEcUN3QUFoQTBBQUlJTkFBQjdEUUFBeXdzQUFMTUtBQUNGQ2dBQXBRb0FBUDRNQUFBK0RBQUFsUW9BQUU0TkFBQk1EUUFBT0F3QUFQZ01BQUJEQ3dBQTVRc0FBT01MQUFBdERRQUE4UXNBQUVNTkFBQTBEUUFBVGdzQUFKd0tBQUR5REFBQVZBc0FBQmdMQUFBS0N3QUEzZ29BQUZnTkFBQXVEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQmJHOXpaV1ZsY0MxaGJHbDJaUUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCWTJoMWJtdGxaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQUFBRUJBQUVCQUFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBQUFBQUFBQUFBQUFBQUFBQUFBQnlZVzV6Wm1WeUxXVnVZMjlrYVc1bmNHZHlZV1JsRFFvTkNnMEtVMDBOQ2cwS1ZGUlFMME5GTDFSVFVDOEFBQUFBQUFBQUFBQUFBQUFCQWdBQkF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFRSUFBUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQVFFRkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQUFRQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUlBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQk9UMVZPUTBWRlEwdFBWVlJPUlVOVVJWUkZRMUpKUWtWTVZWTklSVlJGUVVSVFJVRlNRMGhTUjBWRFZFbFdTVlJaVEVWT1JFRlNWa1ZQVkVsR1dWQlVTVTlPVTBOSVUwVkJXVk5VUVZSRFNFZEZUMUpFU1ZKRlExUlBVbFJTUTBoUVFWSkJUVVZVUlZKVlVrTkZRbE5EVWtsQ1JVRlNSRTlYVGtGRFJVbE9SRTVMUTB0VlFsTkRVa2xDUlVoVVZGQXZRVVJVVUM4PVwiO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cF9zaW1kLndhc20uanNcbnZhciByZXF1aXJlX2xsaHR0cF9zaW1kX3dhc20gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQud2FzbS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBcIkFHRnpiUUVBQUFBQk1BaGdBWDhCZjJBRGYzOS9BWDlnQkg5L2YzOEJmMkFBQUdBRGYzOS9BR0FCZndCZ0FuOS9BR0FHZjM5L2YzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUNBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBems0QXdNRUFBQUZBQUFBQUFBQUJRRUZBQVVGQlFBQUJnQUFBQVlHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQUFNRUJRRndBUTRPQlFNQkFBSUdDQUYvQVVHQXVBUUxCL1VFSHdadFpXMXZjbmtDQUF0ZmFXNXBkR2xoYkdsNlpRQUpHVjlmYVc1a2FYSmxZM1JmWm5WdVkzUnBiMjVmZEdGaWJHVUJBQXRzYkdoMGRIQmZhVzVwZEFBS0dHeHNhSFIwY0Y5emFHOTFiR1JmYTJWbGNGOWhiR2wyWlFBMURHeHNhSFIwY0Y5aGJHeHZZd0FNQm0xaGJHeHZZd0E2QzJ4c2FIUjBjRjltY21WbEFBMEVabkpsWlFBOEQyeHNhSFIwY0Y5blpYUmZkSGx3WlFBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dFlXcHZjZ0FQRld4c2FIUjBjRjluWlhSZmFIUjBjRjl0YVc1dmNnQVFFV3hzYUhSMGNGOW5aWFJmYldWMGFHOWtBQkVXYkd4b2RIUndYMmRsZEY5emRHRjBkWE5mWTI5a1pRQVNFbXhzYUhSMGNGOW5aWFJmZFhCbmNtRmtaUUFUREd4c2FIUjBjRjl5WlhObGRBQVVEbXhzYUhSMGNGOWxlR1ZqZFhSbEFCVVViR3hvZEhSd1gzTmxkSFJwYm1kelgybHVhWFFBRmcxc2JHaDBkSEJmWm1sdWFYTm9BQmNNYkd4b2RIUndYM0JoZFhObEFCZ05iR3hvZEhSd1gzSmxjM1Z0WlFBWkcyeHNhSFIwY0Y5eVpYTjFiV1ZmWVdaMFpYSmZkWEJuY21Ga1pRQWFFR3hzYUhSMGNGOW5aWFJmWlhKeWJtOEFHeGRzYkdoMGRIQmZaMlYwWDJWeWNtOXlYM0psWVhOdmJnQWNGMnhzYUhSMGNGOXpaWFJmWlhKeWIzSmZjbVZoYzI5dUFCMFViR3hvZEhSd1gyZGxkRjlsY25KdmNsOXdiM01BSGhGc2JHaDBkSEJmWlhKeWJtOWZibUZ0WlFBZkVteHNhSFIwY0Y5dFpYUm9iMlJmYm1GdFpRQWdHbXhzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlvWldGa1pYSnpBQ0VoYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDJOb2RXNXJaV1JmYkdWdVozUm9BQ0lZYkd4b2RIUndYMjFsYzNOaFoyVmZibVZsWkhOZlpXOW1BRE1KRXdFQVFRRUxEUUVDQXdRRkN3WUhMaW9vSkNZS3VLZ0NPQUlBQ3dnQUVJaUFnSUFBQ3hrQUlBQVF0b0NBZ0FBYUlBQWdBallDTkNBQUlBRTZBQ2dMSEFBZ0FDQUFMd0V5SUFBdEFDNGdBQkMxZ0lDQUFCQ0FnSUNBQUFzcEFRRi9RVGdRdW9DQWdBQWlBUkMyZ0lDQUFCb2dBVUdBaUlDQUFEWUNOQ0FCSUFBNkFDZ2dBUXNLQUNBQUVMeUFnSUFBQ3djQUlBQXRBQ2dMQndBZ0FDMEFLZ3NIQUNBQUxRQXJDd2NBSUFBdEFDa0xCd0FnQUM4Qk1nc0hBQ0FBTFFBdUMwVUJCSDhnQUNnQ0dDRUJJQUF0QUMwaEFpQUFMUUFvSVFNZ0FDZ0NOQ0VFSUFBUXRvQ0FnQUFhSUFBZ0JEWUNOQ0FBSUFNNkFDZ2dBQ0FDT2dBdElBQWdBVFlDR0FzUkFDQUFJQUVnQVNBQ2FoQzNnSUNBQUFzK0FRRjdJQUQ5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUFpQWYwTEFnQWdBRUV3YWtJQU53SUFJQUJCSUdvZ0FmMExBZ0FnQUVFUWFpQUIvUXNDQUF0bkFRRi9RUUFoQVFKQUlBQW9BZ3dOQUFKQUFrQUNRQUpBSUFBdEFDOE9Bd0VBQXdJTElBQW9BalFpQVVVTkFDQUJLQUljSWdGRkRRQWdBQ0FCRVlDQWdJQUFBQ0lCRFFNTFFRQVBDeEMvZ0lDQUFBQUxJQUJCLzVHQWdBQTJBaEJCRGlFQkN5QUJDeDRBQWtBZ0FDZ0NEQTBBSUFCQmhKU0FnQUEyQWhBZ0FFRVZOZ0lNQ3dzV0FBSkFJQUFvQWd4QkZVY05BQ0FBUVFBMkFnd0xDeFlBQWtBZ0FDZ0NERUVXUncwQUlBQkJBRFlDREFzTEJ3QWdBQ2dDREFzSEFDQUFLQUlRQ3drQUlBQWdBVFlDRUFzSEFDQUFLQUlVQ3lJQUFrQWdBRUVhU1EwQUVMK0FnSUFBQUFzZ0FFRUNkRUhJbTRDQUFHb29BZ0FMSWdBQ1FDQUFRUzVKRFFBUXY0Q0FnQUFBQ3lBQVFRSjBRYkNjZ0lBQWFpZ0NBQXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTExnRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDQUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJRUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCbkk2QWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0FpZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NDQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFkS0tnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUlzSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDTkNJRVJRMEFJQVFvQWd3aUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUhkazRDQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJMElnUkZEUUFnQkNnQ01DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqUWlCRVVOQUNBRUtBSVFJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQnc1Q0FnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NOQ0lFUlEwQUlBUW9BalFpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUkwSWdSRkRRQWdCQ2dDRkNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpRaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ05DSUVSUTBBSUFRb0FoZ2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIU2lJQ0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTBJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BalFpQkVVTkFDQUVLQUlrSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwVUJBWDhDUUFKQUlBQXZBVEJCRkhGQkZFY05BRUVCSVFNZ0FDMEFLRUVCUmcwQklBQXZBVEpCNVFCR0lRTU1BUXNnQUMwQUtVRUZSaUVEQ3lBQUlBTTZBQzVCQUF2eUFRRURmMEVCSVFNQ1FDQUFMd0V3SWdSQkNIRU5BQ0FBS1FNZ1FnQlNJUU1MQWtBQ1FDQUFMUUF1UlEwQVFRRWhCU0FBTFFBcFFRVkdEUUZCQVNFRklBUkJ3QUJ4UlNBRGNVRUJSdzBCQzBFQUlRVWdCRUhBQUhFTkFFRUNJUVVnQkVFSWNRMEFBa0FnQkVHQUJIRkZEUUFDUUNBQUxRQW9RUUZIRFFBZ0FDMEFMVUVLY1EwQVFRVVBDMEVFRHdzQ1FDQUVRU0J4RFFBQ1FDQUFMUUFvUVFGR0RRQWdBQzhCTWlJQVFaeC9ha0hrQUVrTkFDQUFRY3dCUmcwQUlBQkJzQUpHRFFCQkJDRUZJQVJCaUFSeFFZQUVSZzBDSUFSQktIRkZEUUlMUVFBUEMwRUFRUU1nQUNrRElGQWJJUVVMSUFVTFhRRUNmMEVBSVFFQ1FDQUFMUUFvUVFGR0RRQWdBQzhCTWlJQ1FaeC9ha0hrQUVrTkFDQUNRY3dCUmcwQUlBSkJzQUpHRFFBZ0FDOEJNQ0lBUWNBQWNRMEFRUUVoQVNBQVFZZ0VjVUdBQkVZTkFDQUFRU2h4UlNFQkN5QUJDNklCQVFOL0FrQUNRQUpBSUFBdEFDcEZEUUFnQUMwQUswVU5BRUVBSVFNZ0FDOEJNQ0lFUVFKeFJRMEJEQUlMUVFBaEF5QUFMd0V3SWdSQkFYRkZEUUVMUVFFaEF5QUFMUUFvUVFGR0RRQWdBQzhCTWlJRlFaeC9ha0hrQUVrTkFDQUZRY3dCUmcwQUlBVkJzQUpHRFFBZ0JFSEFBSEVOQUVFQUlRTWdCRUdJQkhGQmdBUkdEUUFnQkVFb2NVRUFSeUVEQ3lBQVFRQTdBVEFnQUVFQU9nQXZJQU1MbEFFQkFuOENRQUpBQWtBZ0FDMEFLa1VOQUNBQUxRQXJSUTBBUVFBaEFTQUFMd0V3SWdKQkFuRkZEUUVNQWd0QkFDRUJJQUF2QVRBaUFrRUJjVVVOQVF0QkFTRUJJQUF0QUNoQkFVWU5BQ0FBTHdFeUlnQkJuSDlxUWVRQVNRMEFJQUJCekFGR0RRQWdBRUd3QWtZTkFDQUNRY0FBY1EwQVFRQWhBU0FDUVlnRWNVR0FCRVlOQUNBQ1FTaHhRUUJISVFFTElBRUxTQUVCZXlBQVFSQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFJZ0g5Q3dNQUlBQWdBZjBMQXdBZ0FFRXdha0lBTndNQUlBQkJJR29nQWYwTEF3QWdBRUc4QVRZQ0hFRUFDM3NCQVg4Q1FDQUFLQUlNSWdNTkFBSkFJQUFvQWdSRkRRQWdBQ0FCTmdJRUN3SkFJQUFnQVNBQ0VMaUFnSUFBSWdNTkFDQUFLQUlNRHdzZ0FDQUROZ0ljUVFBaEF5QUFLQUlFSWdGRkRRQWdBQ0FCSUFJZ0FDZ0NDQkdCZ0lDQUFBQWlBVVVOQUNBQUlBSTJBaFFnQUNBQk5nSU1JQUVoQXdzZ0F3dlR6Z0VESEg4RGZnVi9JNENBZ0lBQVFSQnJJZ01rZ0lDQWdBQWdBU0VFSUFFaEJTQUJJUVlnQVNFSElBRWhDQ0FCSVFrZ0FTRUtJQUVoQ3lBQklRd2dBU0VOSUFFaERpQUJJUThnQVNFUUlBRWhFU0FCSVJJZ0FTRVRJQUVoRkNBQklSVWdBU0VXSUFFaEZ5QUJJUmdnQVNFWklBRWhHaUFCSVJzZ0FTRWNJQUVoSFFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0Fod2lIa0YvYWc2OEFiY0JBYllCQWdNRUJRWUhDQWtLQ3d3TkRnOFF3QUcvQVJFU0U3VUJGQlVXRnhnWkdyMEJ2QUViSEIwZUh5QWh0QUd6QVNJanNnR3hBU1FsSmljb0tTb3JMQzB1THpBeE1qTTBOVFkzT0RrNnVBRTdQRDArUDBCQlFrTkVSVVpIU0VsS1MweE5UazlRVVZKVFZGVldWMWhaV2x0Y1hWNWZZR0ZpWTJSbFptZG9hV3ByYkcxdWIzQnhjbk4wZFhaM2VIbDZlM3g5Zm4rQUFZRUJnZ0dEQVlRQmhRR0dBWWNCaUFHSkFZb0Jpd0dNQVkwQmpnR1BBWkFCa1FHU0FaTUJsQUdWQVpZQmx3R1lBWmtCbWdHYkFad0JuUUdlQVo4Qm9BR2hBYUlCb3dHa0FhVUJwZ0duQWFnQnFRR3FBYXNCckFHdEFhNEJyd0VBdVFFTFFRQWhIZ3l2QVF0QkR5RWVESzRCQzBFT0lSNE1yUUVMUVJBaEhneXNBUXRCRVNFZURLc0JDMEVVSVI0TXFnRUxRUlVoSGd5cEFRdEJGaUVlREtnQkMwRVhJUjRNcHdFTFFSZ2hIZ3ltQVF0QkNDRWVES1VCQzBFWklSNE1wQUVMUVJvaEhneWpBUXRCRXlFZURLSUJDMEVTSVI0TW9RRUxRUnNoSGd5Z0FRdEJIQ0VlREo4QkMwRWRJUjRNbmdFTFFSNGhIZ3lkQVF0QnFnRWhIZ3ljQVF0QnF3RWhIZ3liQVF0QklDRWVESm9CQzBFaElSNE1tUUVMUVNJaEhneVlBUXRCSXlFZURKY0JDMEVrSVI0TWxnRUxRYTBCSVI0TWxRRUxRU1VoSGd5VUFRdEJLU0VlREpNQkMwRU5JUjRNa2dFTFFTWWhIZ3lSQVF0Qkp5RWVESkFCQzBFb0lSNE1qd0VMUVM0aEhneU9BUXRCS2lFZURJMEJDMEd1QVNFZURJd0JDMEVNSVI0TWl3RUxRUzhoSGd5S0FRdEJLeUVlRElrQkMwRUxJUjRNaUFFTFFTd2hIZ3lIQVF0QkxTRWVESVlCQzBFS0lSNE1oUUVMUVRFaEhneUVBUXRCTUNFZURJTUJDMEVKSVI0TWdnRUxRUjhoSGd5QkFRdEJNaUVlRElBQkMwRXpJUjRNZnd0Qk5DRWVESDRMUVRVaEhneDlDMEUySVI0TWZBdEJOeUVlREhzTFFUZ2hIZ3g2QzBFNUlSNE1lUXRCT2lFZURIZ0xRYXdCSVI0TWR3dEJPeUVlREhZTFFUd2hIZ3gxQzBFOUlSNE1kQXRCUGlFZURITUxRVDhoSGd4eUMwSEFBQ0VlREhFTFFjRUFJUjRNY0F0QndnQWhIZ3h2QzBIREFDRWVERzRMUWNRQUlSNE1iUXRCQnlFZURHd0xRY1VBSVI0TWF3dEJCaUVlREdvTFFjWUFJUjRNYVF0QkJTRWVER2dMUWNjQUlSNE1ad3RCQkNFZURHWUxRY2dBSVI0TVpRdEJ5UUFoSGd4a0MwSEtBQ0VlREdNTFFjc0FJUjRNWWd0QkF5RWVER0VMUWN3QUlSNE1ZQXRCelFBaEhneGZDMEhPQUNFZURGNExRZEFBSVI0TVhRdEJ6d0FoSGd4Y0MwSFJBQ0VlREZzTFFkSUFJUjRNV2d0QkFpRWVERmtMUWRNQUlSNE1XQXRCMUFBaEhneFhDMEhWQUNFZURGWUxRZFlBSVI0TVZRdEIxd0FoSGd4VUMwSFlBQ0VlREZNTFFka0FJUjRNVWd0QjJnQWhIZ3hSQzBIYkFDRWVERkFMUWR3QUlSNE1Ud3RCM1FBaEhneE9DMEhlQUNFZURFMExRZDhBSVI0TVRBdEI0QUFoSGd4TEMwSGhBQ0VlREVvTFFlSUFJUjRNU1F0QjR3QWhIZ3hJQzBIa0FDRWVERWNMUWVVQUlSNE1SZ3RCNWdBaEhneEZDMEhuQUNFZURFUUxRZWdBSVI0TVF3dEI2UUFoSGd4Q0MwSHFBQ0VlREVFTFFlc0FJUjRNUUF0QjdBQWhIZ3cvQzBIdEFDRWVERDRMUWU0QUlSNE1QUXRCN3dBaEhndzhDMEh3QUNFZUREc0xRZkVBSVI0TU9ndEI4Z0FoSGd3NUMwSHpBQ0VlRERnTFFmUUFJUjRNTnd0QjlRQWhIZ3cyQzBIMkFDRWVERFVMUWZjQUlSNE1OQXRCK0FBaEhnd3pDMEg1QUNFZURESUxRZm9BSVI0TU1RdEIrd0FoSGd3d0MwSDhBQ0VlREM4TFFmMEFJUjRNTGd0Qi9nQWhIZ3d0QzBIL0FDRWVEQ3dMUVlBQklSNE1Ld3RCZ1FFaEhnd3FDMEdDQVNFZURDa0xRWU1CSVI0TUtBdEJoQUVoSGd3bkMwR0ZBU0VlRENZTFFZWUJJUjRNSlF0Qmh3RWhIZ3drQzBHSUFTRWVEQ01MUVlrQklSNE1JZ3RCaWdFaEhnd2hDMEdMQVNFZURDQUxRWXdCSVI0TUh3dEJqUUVoSGd3ZUMwR09BU0VlREIwTFFZOEJJUjRNSEF0QmtBRWhIZ3diQzBHUkFTRWVEQm9MUVpJQklSNE1HUXRCa3dFaEhnd1lDMEdVQVNFZURCY0xRWlVCSVI0TUZndEJsZ0VoSGd3VkMwR1hBU0VlREJRTFFaZ0JJUjRNRXd0Qm1RRWhIZ3dTQzBHZEFTRWVEQkVMUVpvQklSNE1FQXRCQVNFZURBOExRWnNCSVI0TURndEJuQUVoSGd3TkMwR2VBU0VlREF3TFFhQUJJUjRNQ3d0Qm53RWhIZ3dLQzBHaEFTRWVEQWtMUWFJQklSNE1DQXRCb3dFaEhnd0hDMEdrQVNFZURBWUxRYVVCSVI0TUJRdEJwZ0VoSGd3RUMwR25BU0VlREFNTFFhZ0JJUjRNQWd0QnFRRWhIZ3dCQzBHdkFTRWVDd05BQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQjRPc0FFQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR2h3ZUh5QWpKQ1VtSnlncEtpd3RMaTh3K3dJME5qZzVQRDlCUWtORVJVWkhTRWxLUzB4TlRrOVFVVkpUVlZkWlhGMWVZR0pqWkdWbVoyaHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHMEFiVUJ0Z0czQWJnQnVRRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSGFBZUFCNFFIa0FmRUJ2UUs5QWdzZ0FTSUlJQUpIRGNJQlFid0JJUjRNbFFNTElBRWlIaUFDUncyeEFVR3NBU0VlREpRREN5QUJJZ0VnQWtjTlowSGlBQ0VlREpNREN5QUJJZ0VnQWtjTlhVSGFBQ0VlREpJREN5QUJJZ0VnQWtjTlZrSFZBQ0VlREpFREN5QUJJZ0VnQWtjTlVrSFRBQ0VlREpBREN5QUJJZ0VnQWtjTlQwSFJBQ0VlREk4REN5QUJJZ0VnQWtjTlRFSFBBQ0VlREk0REN5QUJJZ0VnQWtjTkVFRU1JUjRNalFNTElBRWlBU0FDUncwelFUZ2hIZ3lNQXdzZ0FTSUJJQUpIRFM5Qk5TRWVESXNEQ3lBQklnRWdBa2NOSmtFeUlSNE1pZ01MSUFFaUFTQUNSdzBrUVM4aEhneUpBd3NnQVNJQklBSkhEUjFCSkNFZURJZ0RDeUFBTFFBdVFRRkdEZjBDRE1jQkN5QUFJQUVpQVNBQ0VMU0FnSUFBUVFGSERiUUJETFVCQ3lBQUlBRWlBU0FDRUsyQWdJQUFJaDROdFFFZ0FTRUJETEFDQ3dKQUlBRWlBU0FDUncwQVFRWWhIZ3lGQXdzZ0FDQUJRUUZxSWdFZ0FoQ3dnSUNBQUNJZURiWUJJQUVoQVF3UEN5QUFRZ0EzQXlCQkV5RWVEUE1DQ3lBQkloNGdBa2NOQ1VFUElSNE1nZ01MQWtBZ0FTSUJJQUpHRFFBZ0FVRUJhaUVCUVJFaEhnenlBZ3RCQnlFZURJRURDeUFBUWdBZ0FDa0RJQ0lmSUFJZ0FTSWVhNjBpSUgwaUlTQWhJQjlXR3pjRElDQWZJQ0JXSWlKRkRiTUJRUWdoSGd5QUF3c0NRQ0FCSWdFZ0FrWU5BQ0FBUVltQWdJQUFOZ0lJSUFBZ0FUWUNCQ0FCSVFGQkZTRWVEUEFDQzBFSklSNE0vd0lMSUFFaEFTQUFLUU1nVUEyeUFTQUJJUUVNclFJTEFrQWdBU0lCSUFKSERRQkJDeUVlRFA0Q0N5QUFJQUZCQVdvaUFTQUNFSytBZ0lBQUloNE5zZ0VnQVNFQkRLMENDd05BQWtBZ0FTMEFBRUh3bllDQUFHb3RBQUFpSGtFQlJnMEFJQjVCQWtjTnRBRWdBVUVCYWlFQkRBTUxJQUZCQVdvaUFTQUNSdzBBQzBFTUlSNE0vQUlMQWtBZ0FTSUJJQUpIRFFCQkRTRWVEUHdDQ3dKQUFrQWdBUzBBQUNJZVFYTnFEaFFCdGdHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCdGdHMkFiWUJ0Z0cyQWJZQnRnRzJBYllCQUxRQkN5QUJRUUZxSVFFTXRBRUxJQUZCQVdvaEFRdEJHQ0VlRE9vQ0N3SkFJQUVpSGlBQ1J3MEFRUTRoSGd6NkFndENBQ0VmSUI0aEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnSGkwQUFFRlFhZzQzeUFISEFRQUJBZ01FQlFZSHZnSytBcjRDdmdLK0FyNEN2Z0lJQ1FvTERBMitBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q0RnOFFFUklUdmdJTFFnSWhId3pIQVF0Q0F5RWZETVlCQzBJRUlSOE14UUVMUWdVaEh3ekVBUXRDQmlFZkRNTUJDMElISVI4TXdnRUxRZ2doSHd6QkFRdENDU0VmRE1BQkMwSUtJUjhNdndFTFFnc2hId3krQVF0Q0RDRWZETDBCQzBJTklSOE12QUVMUWc0aEh3eTdBUXRDRHlFZkRMb0JDMElLSVI4TXVRRUxRZ3NoSHd5NEFRdENEQ0VmRExjQkMwSU5JUjhNdGdFTFFnNGhId3kxQVF0Q0R5RWZETFFCQzBJQUlSOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUI0dEFBQkJVR29PTjhjQnhnRUFBUUlEQkFVR0I4Z0J5QUhJQWNnQnlBSElBY2dCQ0FrS0N3d055QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFjZ0J5QUhJQWNnQnlBSElBY2dCeUFISUFRNFBFQkVTRThnQkMwSUNJUjhNeGdFTFFnTWhId3pGQVF0Q0JDRWZETVFCQzBJRklSOE13d0VMUWdZaEh3ekNBUXRDQnlFZkRNRUJDMElJSVI4TXdBRUxRZ2toSHd5L0FRdENDaUVmREw0QkMwSUxJUjhNdlFFTFFnd2hId3k4QVF0Q0RTRWZETHNCQzBJT0lSOE11Z0VMUWc4aEh3eTVBUXRDQ2lFZkRMZ0JDMElMSVI4TXR3RUxRZ3doSHd5MkFRdENEU0VmRExVQkMwSU9JUjhNdEFFTFFnOGhId3l6QVFzZ0FFSUFJQUFwQXlBaUh5QUNJQUVpSG11dElpQjlJaUVnSVNBZlZoczNBeUFnSHlBZ1ZpSWlSUTIwQVVFUklSNE05d0lMQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRUnNoSGd6bkFndEJFaUVlRFBZQ0N5QUFJQUVpSGlBQ0VMS0FnSUFBUVg5cURnV21BUUNpQWdHekFiUUJDMEVTSVI0TTVBSUxJQUJCQVRvQUx5QWVJUUVNOGdJTElBRWlBU0FDUncyMEFVRVdJUjRNOGdJTElBRWlIQ0FDUncwWlFUa2hIZ3p4QWdzQ1FDQUJJZ0VnQWtjTkFFRWFJUjRNOFFJTElBQkJBRFlDQkNBQVFZcUFnSUFBTmdJSUlBQWdBU0FCRUtxQWdJQUFJaDROdGdFZ0FTRUJETGtCQ3dKQUlBRWlIaUFDUncwQVFSc2hIZ3p3QWdzQ1FDQWVMUUFBSWdGQklFY05BQ0FlUVFGcUlRRU1HZ3NnQVVFSlJ3MjJBU0FlUVFGcUlRRU1HUXNDUUNBQklnRWdBa1lOQUNBQlFRRnFJUUVNRkF0QkhDRWVETzRDQ3dKQUlBRWlIaUFDUncwQVFSMGhIZ3p1QWdzQ1FDQWVMUUFBSWdGQkNVY05BQ0FlSVFFTTBnSUxJQUZCSUVjTnRRRWdIaUVCRE5FQ0N3SkFJQUVpQVNBQ1J3MEFRUjRoSGd6dEFnc2dBUzBBQUVFS1J3MjRBU0FCUVFGcUlRRU1vQUlMSUFFaUFTQUNSdzI0QVVFaUlSNE02d0lMQTBBQ1FDQUJMUUFBSWg1QklFWU5BQUpBSUI1QmRtb09CQUMrQWI0QkFMd0JDeUFCSVFFTXhBRUxJQUZCQVdvaUFTQUNSdzBBQzBFa0lSNE02Z0lMUVNVaEhpQUJJaU1nQWtZTjZRSWdBaUFqYXlBQUtBSUFJaVJxSVNVZ0l5RW1JQ1FoQVFKQUEwQWdKaTBBQUNJaVFTQnlJQ0lnSWtHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVId240Q0FBR290QUFCSERRRWdBVUVEUmczV0FpQUJRUUZxSVFFZ0prRUJhaUltSUFKSERRQUxJQUFnSlRZQ0FBenFBZ3NnQUVFQU5nSUFJQ1loQVF5N0FRdEJKaUVlSUFFaUl5QUNSZzNvQWlBQ0lDTnJJQUFvQWdBaUpHb2hKU0FqSVNZZ0pDRUJBa0FEUUNBbUxRQUFJaUpCSUhJZ0lpQWlRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRZlNmZ0lBQWFpMEFBRWNOQVNBQlFRaEdEYjBCSUFGQkFXb2hBU0FtUVFGcUlpWWdBa2NOQUFzZ0FDQWxOZ0lBRE9rQ0N5QUFRUUEyQWdBZ0ppRUJETG9CQzBFbklSNGdBU0lqSUFKR0RlY0NJQUlnSTJzZ0FDZ0NBQ0lrYWlFbElDTWhKaUFrSVFFQ1FBTkFJQ1l0QUFBaUlrRWdjaUFpSUNKQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjBLYUFnQUJxTFFBQVJ3MEJJQUZCQlVZTnZRRWdBVUVCYWlFQklDWkJBV29pSmlBQ1J3MEFDeUFBSUNVMkFnQU02QUlMSUFCQkFEWUNBQ0FtSVFFTXVRRUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUJCZ0tLQWdBQnFMUUFBSWg1QkFVWU5BQ0FlUVFKR0RRb2dBU0VCRE1FQkN5QUJRUUZxSWdFZ0FrY05BQXRCSXlFZURPY0NDMEVqSVI0TTVnSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpSGtFZ1JnMEFJQjVCZG1vT0JMMEJ2Z0crQWIwQnZnRUxJQUZCQVdvaUFTQUNSdzBBQzBFcklSNE01Z0lMUVNzaEhnemxBZ3NEUUFKQUlBRXRBQUFpSGtFZ1JnMEFJQjVCQ1VjTkF3c2dBVUVCYWlJQklBSkhEUUFMUVM4aEhnemtBZ3NEUUFKQUlBRXRBQUFpSGtFZ1JnMEFBa0FDUUNBZVFYWnFEZ1MrQVFFQnZnRUFDeUFlUVN4R0RiOEJDeUFCSVFFTUJBc2dBVUVCYWlJQklBSkhEUUFMUVRJaEhnempBZ3NnQVNFQkRMOEJDMEV6SVI0Z0FTSW1JQUpHRGVFQ0lBSWdKbXNnQUNnQ0FDSWphaUVrSUNZaElpQWpJUUVDUUFOQUlDSXRBQUJCSUhJZ0FVR0FwSUNBQUdvdEFBQkhEUUVnQVVFR1JnM1FBaUFCUVFGcUlRRWdJa0VCYWlJaUlBSkhEUUFMSUFBZ0pEWUNBQXppQWdzZ0FFRUFOZ0lBSUNJaEFRdEJLeUVlRE5BQ0N3SkFJQUVpSFNBQ1J3MEFRVFFoSGd6Z0Fnc2dBRUdLZ0lDQUFEWUNDQ0FBSUIwMkFnUWdIU0VCSUFBdEFDeEJmMm9PQks4QnVRRzdBYjBCeHdJTElBRkJBV29oQVF5dUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0llUVNCeUlCNGdIa0cvZjJwQi93RnhRUnBKRzBIL0FYRWlIa0VKUmcwQUlCNUJJRVlOQUFKQUFrQUNRQUpBSUI1Qm5YOXFEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVNZaEhnelRBZ3NnQVVFQmFpRUJRU2NoSGd6U0Fnc2dBVUVCYWlFQlFTZ2hIZ3pSQWdzZ0FTRUJETElCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJLQ0VlRE40Q0MwRW9JUjRNM1FJTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnS0NBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETGNCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJNQ0VlRE4wQ0MwRXdJUjRNM0FJTEFrQURRQUpBSUFFdEFBQkJkMm9PR0FBQ3dRTEJBc2NDd1FMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDd1FMQkFzRUN3UUxCQXNFQ3dRTEJBc0VDQU1FQ0N5QUJRUUZxSWdFZ0FrY05BQXRCTlNFZUROd0NDeUFCUVFGcUlRRUxRU0VoSGd6S0Fnc2dBU0lCSUFKSERia0JRVGNoSGd6WkFnc0RRQUpBSUFFdEFBQkJrS1NBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJESkFDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJPQ0VlRE5nQ0N5QWNMUUFBSWg1QklFWU5tZ0VnSGtFNlJ3M0dBaUFBS0FJRUlRRWdBRUVBTmdJRUlBQWdBU0FjRUtpQWdJQUFJZ0VOdGdFZ0hFRUJhaUVCRExnQkN5QUFJQUVnQWhDcGdJQ0FBQm9MUVFvaEhnekZBZ3RCT2lFZUlBRWlKaUFDUmczVUFpQUNJQ1pySUFBb0FnQWlJMm9oSkNBbUlSd2dJeUVCQWtBRFFDQWNMUUFBSWlKQklISWdJaUFpUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUVpDbWdJQUFhaTBBQUVjTnhBSWdBVUVGUmcwQklBRkJBV29oQVNBY1FRRnFJaHdnQWtjTkFBc2dBQ0FrTmdJQUROVUNDeUFBUVFBMkFnQWdBRUVCT2dBc0lDWWdJMnRCQm1vaEFReStBZ3RCT3lFZUlBRWlKaUFDUmczVEFpQUNJQ1pySUFBb0FnQWlJMm9oSkNBbUlSd2dJeUVCQWtBRFFDQWNMUUFBSWlKQklISWdJaUFpUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUVphbWdJQUFhaTBBQUVjTnd3SWdBVUVKUmcwQklBRkJBV29oQVNBY1FRRnFJaHdnQWtjTkFBc2dBQ0FrTmdJQUROUUNDeUFBUVFBMkFnQWdBRUVDT2dBc0lDWWdJMnRCQ21vaEFReTlBZ3NDUUNBQklod2dBa2NOQUVFOElSNE0wd0lMQWtBQ1FDQWNMUUFBSWdGQklISWdBU0FCUWI5L2FrSC9BWEZCR2trYlFmOEJjVUdTZjJvT0J3RERBc01Dd3dMREFzTUNBY01DQ3lBY1FRRnFJUUZCTWlFZURNTUNDeUFjUVFGcUlRRkJNeUVlRE1JQ0MwRTlJUjRnQVNJbUlBSkdEZEVDSUFJZ0ptc2dBQ2dDQUNJamFpRWtJQ1loSENBaklRRURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFhQ21nSUFBYWkwQUFFY053QUlnQVVFQlJnMjBBaUFCUVFGcUlRRWdIRUVCYWlJY0lBSkhEUUFMSUFBZ0pEWUNBQXpSQWd0QlBpRWVJQUVpSmlBQ1JnM1FBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUndnSXlFQkFrQURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFhS21nSUFBYWkwQUFFY053QUlnQVVFT1JnMEJJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETkVDQ3lBQVFRQTJBZ0FnQUVFQk9nQXNJQ1lnSTJ0QkQyb2hBUXk2QWd0QlB5RWVJQUVpSmlBQ1JnM1BBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUndnSXlFQkFrQURRQ0FjTFFBQUlpSkJJSElnSWlBaVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFjQ21nSUFBYWkwQUFFY052d0lnQVVFUFJnMEJJQUZCQVdvaEFTQWNRUUZxSWh3Z0FrY05BQXNnQUNBa05nSUFETkFDQ3lBQVFRQTJBZ0FnQUVFRE9nQXNJQ1lnSTJ0QkVHb2hBUXk1QWd0QndBQWhIaUFCSWlZZ0FrWU56Z0lnQWlBbWF5QUFLQUlBSWlOcUlTUWdKaUVjSUNNaEFRSkFBMEFnSEMwQUFDSWlRU0J5SUNJZ0lrRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVSFFwb0NBQUdvdEFBQkhEYjRDSUFGQkJVWU5BU0FCUVFGcUlRRWdIRUVCYWlJY0lBSkhEUUFMSUFBZ0pEWUNBQXpQQWdzZ0FFRUFOZ0lBSUFCQkJEb0FMQ0FtSUNOclFRWnFJUUVNdUFJTEFrQWdBU0ljSUFKSERRQkJ3UUFoSGd6T0Fnc0NRQUpBQWtBQ1FDQWNMUUFBSWdGQklISWdBU0FCUWI5L2FrSC9BWEZCR2trYlFmOEJjVUdkZjJvT0V3REFBc0FDd0FMQUFzQUN3QUxBQXNBQ3dBTEFBc0FDd0FJQndBTEFBc0FDQWdQQUFnc2dIRUVCYWlFQlFUVWhIZ3pBQWdzZ0hFRUJhaUVCUVRZaEhneS9BZ3NnSEVFQmFpRUJRVGNoSGd5K0Fnc2dIRUVCYWlFQlFUZ2hIZ3k5QWdzQ1FDQUJJZ0VnQWtZTkFDQUFRWXVBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCT1NFZURMMENDMEhDQUNFZURNd0NDeUFCSWdFZ0FrY05yd0ZCeEFBaEhnekxBZ3RCeFFBaEhpQUJJaVlnQWtZTnlnSWdBaUFtYXlBQUtBSUFJaU5xSVNRZ0ppRWlJQ01oQVFKQUEwQWdJaTBBQUNBQlFkYW1nSUFBYWkwQUFFY050QUVnQVVFQlJnMEJJQUZCQVdvaEFTQWlRUUZxSWlJZ0FrY05BQXNnQUNBa05nSUFETXNDQ3lBQVFRQTJBZ0FnSmlBamEwRUNhaUVCREs4QkN3SkFJQUVpQVNBQ1J3MEFRY2NBSVI0TXlnSUxJQUV0QUFCQkNrY05zd0VnQVVFQmFpRUJESzhCQ3dKQUlBRWlBU0FDUncwQVFjZ0FJUjRNeVFJTEFrQUNRQ0FCTFFBQVFYWnFEZ1FCdEFHMEFRQzBBUXNnQVVFQmFpRUJRVDBoSGd5NUFnc2dBVUVCYWlFQkRLNEJDd0pBSUFFaUFTQUNSdzBBUWNrQUlSNE15QUlMUVFBaEhnSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUZRYWc0S3V3RzZBUUFCQWdNRUJRWUh2QUVMUVFJaEhneTZBUXRCQXlFZURMa0JDMEVFSVI0TXVBRUxRUVVoSGd5M0FRdEJCaUVlRExZQkMwRUhJUjRNdFFFTFFRZ2hIZ3kwQVF0QkNTRWVETE1CQ3dKQUlBRWlBU0FDUncwQVFjb0FJUjRNeHdJTElBRXRBQUJCTGtjTnRBRWdBVUVCYWlFQkRJQUNDd0pBSUFFaUFTQUNSdzBBUWNzQUlSNE14Z0lMUVFBaEhnSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUZRYWc0S3ZRRzhBUUFCQWdNRUJRWUh2Z0VMUVFJaEhneThBUXRCQXlFZURMc0JDMEVFSVI0TXVnRUxRUVVoSGd5NUFRdEJCaUVlRExnQkMwRUhJUjRNdHdFTFFRZ2hIZ3kyQVF0QkNTRWVETFVCQzBITUFDRWVJQUVpSmlBQ1JnM0VBaUFDSUNacklBQW9BZ0FpSTJvaEpDQW1JUUVnSXlFaUEwQWdBUzBBQUNBaVFlS21nSUFBYWkwQUFFY051QUVnSWtFRFJnMjNBU0FpUVFGcUlTSWdBVUVCYWlJQklBSkhEUUFMSUFBZ0pEWUNBQXpFQWd0QnpRQWhIaUFCSWlZZ0FrWU53d0lnQWlBbWF5QUFLQUlBSWlOcUlTUWdKaUVCSUNNaElnTkFJQUV0QUFBZ0lrSG1wb0NBQUdvdEFBQkhEYmNCSUNKQkFrWU51UUVnSWtFQmFpRWlJQUZCQVdvaUFTQUNSdzBBQ3lBQUlDUTJBZ0FNd3dJTFFjNEFJUjRnQVNJbUlBSkdEY0lDSUFJZ0ptc2dBQ2dDQUNJamFpRWtJQ1loQVNBaklTSURRQ0FCTFFBQUlDSkI2YWFBZ0FCcUxRQUFSdzIyQVNBaVFRTkdEYmtCSUNKQkFXb2hJaUFCUVFGcUlnRWdBa2NOQUFzZ0FDQWtOZ0lBRE1JQ0N3TkFBa0FnQVMwQUFDSWVRU0JHRFFBQ1FBSkFBa0FnSGtHNGYyb09Dd0FCdWdHNkFib0J1Z0c2QWJvQnVnRzZBUUs2QVFzZ0FVRUJhaUVCUWNJQUlSNE10UUlMSUFGQkFXb2hBVUhEQUNFZURMUUNDeUFCUVFGcUlRRkJ4QUFoSGd5ekFnc2dBVUVCYWlJQklBSkhEUUFMUWM4QUlSNE13UUlMQWtBZ0FTSUJJQUpHRFFBZ0FDQUJRUUZxSWdFZ0FoQ2xnSUNBQUJvZ0FTRUJRUWNoSGd5eEFndEIwQUFoSGd6QUFnc0RRQUpBSUFFdEFBQkI4S2FBZ0FCcUxRQUFJaDVCQVVZTkFDQWVRWDVxRGdPNUFib0J1d0c4QVFzZ0FVRUJhaUlCSUFKSERRQUxRZEVBSVI0TXZ3SUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQU1MUWRJQUlSNE12Z0lMQTBBQ1FDQUJMUUFBUWZDb2dJQUFhaTBBQUNJZVFRRkdEUUFDUUNBZVFYNXFEZ1M4QWIwQnZnRUF2d0VMSUFFaEFVSEdBQ0VlREs4Q0N5QUJRUUZxSWdFZ0FrY05BQXRCMHdBaEhneTlBZ3NDUUNBQklnRWdBa2NOQUVIVUFDRWVETDBDQ3dKQUlBRXRBQUFpSGtGMmFnNGFwQUcvQWI4QnBnRy9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3RzBBYjhCdndFQXZRRUxJQUZCQVdvaEFRdEJCaUVlREtzQ0N3TkFBa0FnQVMwQUFFSHdxb0NBQUdvdEFBQkJBVVlOQUNBQklRRU0rZ0VMSUFGQkFXb2lBU0FDUncwQUMwSFZBQ0VlRExvQ0N3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFRd0RDMEhXQUNFZURMa0NDd0pBSUFFaUFTQUNSdzBBUWRjQUlSNE11UUlMSUFGQkFXb2hBUXdCQ3dKQUlBRWlBU0FDUncwQVFkZ0FJUjRNdUFJTElBRkJBV29oQVF0QkJDRWVES1lDQ3dKQUlBRWlJaUFDUncwQVFka0FJUjRNdGdJTElDSWhBUUpBQWtBQ1FDQWlMUUFBUWZDc2dJQUFhaTBBQUVGL2FnNEh2Z0cvQWNBQkFQZ0JBUUxCQVFzZ0lrRUJhaUVCREFvTElDSkJBV29oQVF5M0FRdEJBQ0VlSUFCQkFEWUNIQ0FBUWZHT2dJQUFOZ0lRSUFCQkJ6WUNEQ0FBSUNKQkFXbzJBaFFNdFFJTEFrQURRQUpBSUFFdEFBQkI4S3lBZ0FCcUxRQUFJaDVCQkVZTkFBSkFBa0FnSGtGL2FnNEh2QUc5QWI0Qnd3RUFCQUhEQVFzZ0FTRUJRY2tBSVI0TXFBSUxJQUZCQVdvaEFVSExBQ0VlREtjQ0N5QUJRUUZxSWdFZ0FrY05BQXRCMmdBaEhneTFBZ3NnQVVFQmFpRUJETFVCQ3dKQUlBRWlJaUFDUncwQVFkc0FJUjRNdEFJTElDSXRBQUJCTDBjTnZnRWdJa0VCYWlFQkRBWUxBa0FnQVNJaUlBSkhEUUJCM0FBaEhneXpBZ3NDUUNBaUxRQUFJZ0ZCTDBjTkFDQWlRUUZxSVFGQnpBQWhIZ3lqQWdzZ0FVRjJhaUlCUVJaTERiMEJRUUVnQVhSQmlZQ0FBbkZGRGIwQkRKTUNDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBVUhOQUNFZURLSUNDMEhkQUNFZURMRUNDd0pBSUFFaUlpQUNSdzBBUWQ4QUlSNE1zUUlMSUNJaEFRSkFJQ0l0QUFCQjhMQ0FnQUJxTFFBQVFYOXFEZ09TQXZBQkFMNEJDMEhRQUNFZURLQUNDd0pBSUFFaUlpQUNSZzBBQTBBQ1FDQWlMUUFBUWZDdWdJQUFhaTBBQUNJQlFRTkdEUUFDUUNBQlFYOXFEZ0tVQWdDL0FRc2dJaUVCUWM0QUlSNE1vZ0lMSUNKQkFXb2lJaUFDUncwQUMwSGVBQ0VlRExBQ0MwSGVBQ0VlREs4Q0N3SkFJQUVpQVNBQ1JnMEFJQUJCaklDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVIUEFDRWVESjhDQzBIZ0FDRWVESzRDQ3dKQUlBRWlBU0FDUncwQVFlRUFJUjRNcmdJTElBQkJqSUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBUXRCQXlFZURKd0NDd05BSUFFdEFBQkJJRWNOakFJZ0FVRUJhaUlCSUFKSERRQUxRZUlBSVI0TXF3SUxBa0FnQVNJQklBSkhEUUJCNHdBaEhneXJBZ3NnQVMwQUFFRWdSdzI0QVNBQlFRRnFJUUVNMUFFTEFrQWdBU0lJSUFKSERRQkI1QUFoSGd5cUFnc2dDQzBBQUVITUFFY051d0VnQ0VFQmFpRUJRUk1oSGd5NUFRdEI1UUFoSGlBQklpSWdBa1lOcUFJZ0FpQWlheUFBS0FJQUlpWnFJU01nSWlFSUlDWWhBUU5BSUFndEFBQWdBVUh3c29DQUFHb3RBQUJIRGJvQklBRkJCVVlOdUFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ00yQWdBTXFBSUxBa0FnQVNJSUlBSkhEUUJCNWdBaEhneW9BZ3NDUUFKQUlBZ3RBQUJCdlg5cURnd0F1d0c3QWJzQnV3RzdBYnNCdXdHN0Fic0J1d0VCdXdFTElBaEJBV29oQVVIVUFDRWVESmdDQ3lBSVFRRnFJUUZCMVFBaEhneVhBZ3RCNXdBaEhpQUJJaUlnQWtZTnBnSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFKQUEwQWdDQzBBQUNBQlFlMnpnSUFBYWkwQUFFY051UUVnQVVFQ1JnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFES2NDQ3lBQVFRQTJBZ0FnSWlBbWEwRURhaUVCUVJBaEhneTJBUXRCNkFBaEhpQUJJaUlnQWtZTnBRSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFKQUEwQWdDQzBBQUNBQlFmYXlnSUFBYWkwQUFFY051QUVnQVVFRlJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFES1lDQ3lBQVFRQTJBZ0FnSWlBbWEwRUdhaUVCUVJZaEhneTFBUXRCNlFBaEhpQUJJaUlnQWtZTnBBSWdBaUFpYXlBQUtBSUFJaVpxSVNNZ0lpRUlJQ1loQVFKQUEwQWdDQzBBQUNBQlFmeXlnSUFBYWkwQUFFY050d0VnQVVFRFJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFES1VDQ3lBQVFRQTJBZ0FnSWlBbWEwRUVhaUVCUVFVaEhneTBBUXNDUUNBQklnZ2dBa2NOQUVIcUFDRWVES1FDQ3lBSUxRQUFRZGtBUncyMUFTQUlRUUZxSVFGQkNDRWVETE1CQ3dKQUlBRWlDQ0FDUncwQVFlc0FJUjRNb3dJTEFrQUNRQ0FJTFFBQVFiSi9hZzREQUxZQkFiWUJDeUFJUVFGcUlRRkIyUUFoSGd5VEFnc2dDRUVCYWlFQlFkb0FJUjRNa2dJTEFrQWdBU0lJSUFKSERRQkI3QUFoSGd5aUFnc0NRQUpBSUFndEFBQkJ1SDlxRGdnQXRRRzFBYlVCdFFHMUFiVUJBYlVCQ3lBSVFRRnFJUUZCMkFBaEhneVNBZ3NnQ0VFQmFpRUJRZHNBSVI0TWtRSUxRZTBBSVI0Z0FTSWlJQUpHRGFBQ0lBSWdJbXNnQUNnQ0FDSW1haUVqSUNJaENDQW1JUUVDUUFOQUlBZ3RBQUFnQVVHQXM0Q0FBR290QUFCSERiTUJJQUZCQWtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSXpZQ0FBeWhBZ3RCQUNFZUlBQkJBRFlDQUNBaUlDWnJRUU5xSVFFTXNBRUxRZTRBSVI0Z0FTSWlJQUpHRFo4Q0lBSWdJbXNnQUNnQ0FDSW1haUVqSUNJaENDQW1JUUVDUUFOQUlBZ3RBQUFnQVVHRHM0Q0FBR290QUFCSERiSUJJQUZCQkVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSXpZQ0FBeWdBZ3NnQUVFQU5nSUFJQ0lnSm10QkJXb2hBVUVqSVI0TXJ3RUxBa0FnQVNJSUlBSkhEUUJCN3dBaEhneWZBZ3NDUUFKQUlBZ3RBQUJCdEg5cURnZ0FzZ0d5QWJJQnNnR3lBYklCQWJJQkN5QUlRUUZxSVFGQjNRQWhIZ3lQQWdzZ0NFRUJhaUVCUWQ0QUlSNE1qZ0lMQWtBZ0FTSUlJQUpIRFFCQjhBQWhIZ3llQWdzZ0NDMEFBRUhGQUVjTnJ3RWdDRUVCYWlFQkRONEJDMEh4QUNFZUlBRWlJaUFDUmcyY0FpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQWtBRFFDQUlMUUFBSUFGQmlMT0FnQUJxTFFBQVJ3MnZBU0FCUVFOR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1uUUlMSUFCQkFEWUNBQ0FpSUNaclFRUnFJUUZCTFNFZURLd0JDMEh5QUNFZUlBRWlJaUFDUmcyYkFpQUNJQ0pySUFBb0FnQWlKbW9oSXlBaUlRZ2dKaUVCQWtBRFFDQUlMUUFBSUFGQjBMT0FnQUJxTFFBQVJ3MnVBU0FCUVFoR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNNMkFnQU1uQUlMSUFCQkFEWUNBQ0FpSUNaclFRbHFJUUZCS1NFZURLc0JDd0pBSUFFaUFTQUNSdzBBUWZNQUlSNE1td0lMUVFFaEhpQUJMUUFBUWQ4QVJ3MnFBU0FCUVFGcUlRRU0zQUVMUWZRQUlSNGdBU0lpSUFKR0Raa0NJQUlnSW1zZ0FDZ0NBQ0ltYWlFaklDSWhDQ0FtSVFFRFFDQUlMUUFBSUFGQmpMT0FnQUJxTFFBQVJ3MnJBU0FCUVFGR0RmY0JJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBak5nSUFESmtDQ3dKQUlBRWlIaUFDUncwQVFmVUFJUjRNbVFJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVHT3M0Q0FBR290QUFCSERhc0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFSDFBQ0VlREprQ0N5QUFRUUEyQWdBZ0hpQWlhMEVEYWlFQlFRSWhIZ3lvQVFzQ1FDQUJJaDRnQWtjTkFFSDJBQ0VlREpnQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQjhMT0FnQUJxTFFBQVJ3MnFBU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkI5Z0FoSGd5WUFnc2dBRUVBTmdJQUlCNGdJbXRCQW1vaEFVRWZJUjRNcHdFTEFrQWdBU0llSUFKSERRQkI5d0FoSGd5WEFnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFmS3pnSUFBYWkwQUFFY05xUUVnQVVFQlJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRZmNBSVI0TWx3SUxJQUJCQURZQ0FDQWVJQ0pyUVFKcUlRRkJDU0VlREtZQkN3SkFJQUVpQ0NBQ1J3MEFRZmdBSVI0TWxnSUxBa0FDUUNBSUxRQUFRYmQvYWc0SEFLa0JxUUdwQWFrQnFRRUJxUUVMSUFoQkFXb2hBVUhtQUNFZURJWUNDeUFJUVFGcUlRRkI1d0FoSGd5RkFnc0NRQ0FCSWg0Z0FrY05BRUg1QUNFZURKVUNDeUFDSUI1cklBQW9BZ0FpSW1vaEppQWVJUWdnSWlFQkFrQURRQ0FJTFFBQUlBRkJrYk9BZ0FCcUxRQUFSdzJuQVNBQlFRVkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDWTJBZ0JCK1FBaEhneVZBZ3NnQUVFQU5nSUFJQjRnSW10QkJtb2hBVUVZSVI0TXBBRUxBa0FnQVNJZUlBSkhEUUJCK2dBaEhneVVBZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRWmV6Z0lBQWFpMEFBRWNOcGdFZ0FVRUNSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUWZvQUlSNE1sQUlMSUFCQkFEWUNBQ0FlSUNKclFRTnFJUUZCRnlFZURLTUJDd0pBSUFFaUhpQUNSdzBBUWZzQUlSNE1rd0lMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUdhczRDQUFHb3RBQUJIRGFVQklBRkJCa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVIN0FDRWVESk1DQ3lBQVFRQTJBZ0FnSGlBaWEwRUhhaUVCUVJVaEhneWlBUXNDUUNBQkloNGdBa2NOQUVIOEFDRWVESklDQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCb2JPQWdBQnFMUUFBUncya0FTQUJRUVZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQi9BQWhIZ3lTQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJCbW9oQVVFZUlSNE1vUUVMQWtBZ0FTSUlJQUpIRFFCQi9RQWhIZ3lSQWdzZ0NDMEFBRUhNQUVjTm9nRWdDRUVCYWlFQlFRb2hIZ3lnQVFzQ1FDQUJJZ2dnQWtjTkFFSCtBQ0VlREpBQ0N3SkFBa0FnQ0MwQUFFRy9mMm9PRHdDakFhTUJvd0dqQWFNQm93R2pBYU1Cb3dHakFhTUJvd0dqQVFHakFRc2dDRUVCYWlFQlFld0FJUjRNZ0FJTElBaEJBV29oQVVIdEFDRWVEUDhCQ3dKQUlBRWlDQ0FDUncwQVFmOEFJUjRNandJTEFrQUNRQ0FJTFFBQVFiOS9hZzREQUtJQkFhSUJDeUFJUVFGcUlRRkI2d0FoSGd6L0FRc2dDRUVCYWlFQlFlNEFJUjRNL2dFTEFrQWdBU0llSUFKSERRQkJnQUVoSGd5T0Fnc2dBaUFlYXlBQUtBSUFJaUpxSVNZZ0hpRUlJQ0loQVFKQUEwQWdDQzBBQUNBQlFhZXpnSUFBYWkwQUFFY05vQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUlRUUZxSWdnZ0FrY05BQXNnQUNBbU5nSUFRWUFCSVI0TWpnSUxJQUJCQURZQ0FDQWVJQ0pyUVFKcUlRRkJDeUVlREowQkN3SkFJQUVpQ0NBQ1J3MEFRWUVCSVI0TWpRSUxBa0FDUUFKQUFrQWdDQzBBQUVGVGFnNGpBS0lCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0dpQWFJQm9nR2lBYUlCb2dHaUFhSUJvZ0VCb2dHaUFhSUJvZ0dpQVFLaUFhSUJvZ0VEb2dFTElBaEJBV29oQVVIcEFDRWVEUDhCQ3lBSVFRRnFJUUZCNmdBaEhneitBUXNnQ0VFQmFpRUJRZThBSVI0TS9RRUxJQWhCQVdvaEFVSHdBQ0VlRFB3QkN3SkFJQUVpSGlBQ1J3MEFRWUlCSVI0TWpBSUxJQUlnSG1zZ0FDZ0NBQ0lpYWlFbUlCNGhDQ0FpSVFFQ1FBTkFJQWd0QUFBZ0FVR3BzNENBQUdvdEFBQkhEWjRCSUFGQkJFWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0pqWUNBRUdDQVNFZURJd0NDeUFBUVFBMkFnQWdIaUFpYTBFRmFpRUJRUmtoSGd5YkFRc0NRQ0FCSWlJZ0FrY05BRUdEQVNFZURJc0NDeUFDSUNKcklBQW9BZ0FpSm1vaEhpQWlJUWdnSmlFQkFrQURRQ0FJTFFBQUlBRkJyck9BZ0FCcUxRQUFSdzJkQVNBQlFRVkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlCNDJBZ0JCZ3dFaEhneUxBZ3NnQUVFQU5nSUFRUVloSGlBaUlDWnJRUVpxSVFFTW1nRUxBa0FnQVNJZUlBSkhEUUJCaEFFaEhneUtBZ3NnQWlBZWF5QUFLQUlBSWlKcUlTWWdIaUVJSUNJaEFRSkFBMEFnQ0MwQUFDQUJRYlN6Z0lBQWFpMEFBRWNObkFFZ0FVRUJSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQW1OZ0lBUVlRQklSNE1pZ0lMSUFCQkFEWUNBQ0FlSUNKclFRSnFJUUZCSENFZURKa0JDd0pBSUFFaUhpQUNSdzBBUVlVQklSNE1pUUlMSUFJZ0htc2dBQ2dDQUNJaWFpRW1JQjRoQ0NBaUlRRUNRQU5BSUFndEFBQWdBVUcyczRDQUFHb3RBQUJIRFpzQklBRkJBVVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdKallDQUVHRkFTRWVESWtDQ3lBQVFRQTJBZ0FnSGlBaWEwRUNhaUVCUVNjaEhneVlBUXNDUUNBQklnZ2dBa2NOQUVHR0FTRWVESWdDQ3dKQUFrQWdDQzBBQUVHc2Yyb09BZ0FCbXdFTElBaEJBV29oQVVIMEFDRWVEUGdCQ3lBSVFRRnFJUUZCOVFBaEhnejNBUXNDUUNBQkloNGdBa2NOQUVHSEFTRWVESWNDQ3lBQ0lCNXJJQUFvQWdBaUltb2hKaUFlSVFnZ0lpRUJBa0FEUUNBSUxRQUFJQUZCdUxPQWdBQnFMUUFBUncyWkFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ1kyQWdCQmh3RWhIZ3lIQWdzZ0FFRUFOZ0lBSUI0Z0ltdEJBbW9oQVVFbUlSNE1sZ0VMQWtBZ0FTSWVJQUpIRFFCQmlBRWhIZ3lHQWdzZ0FpQWVheUFBS0FJQUlpSnFJU1lnSGlFSUlDSWhBUUpBQTBBZ0NDMEFBQ0FCUWJxemdJQUFhaTBBQUVjTm1BRWdBVUVCUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FtTmdJQVFZZ0JJUjRNaGdJTElBQkJBRFlDQUNBZUlDSnJRUUpxSVFGQkF5RWVESlVCQ3dKQUlBRWlIaUFDUncwQVFZa0JJUjRNaFFJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVIdHM0Q0FBR290QUFCSERaY0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFR0pBU0VlRElVQ0N5QUFRUUEyQWdBZ0hpQWlhMEVEYWlFQlFRd2hIZ3lVQVFzQ1FDQUJJaDRnQWtjTkFFR0tBU0VlRElRQ0N5QUNJQjVySUFBb0FnQWlJbW9oSmlBZUlRZ2dJaUVCQWtBRFFDQUlMUUFBSUFGQnZMT0FnQUJxTFFBQVJ3MldBU0FCUVFOR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNZMkFnQkJpZ0VoSGd5RUFnc2dBRUVBTmdJQUlCNGdJbXRCQkdvaEFVRU5JUjRNa3dFTEFrQWdBU0lJSUFKSERRQkJpd0VoSGd5REFnc0NRQUpBSUFndEFBQkJ1bjlxRGdzQWxnR1dBWllCbGdHV0FaWUJsZ0dXQVpZQkFaWUJDeUFJUVFGcUlRRkIrUUFoSGd6ekFRc2dDRUVCYWlFQlFmb0FJUjRNOGdFTEFrQWdBU0lJSUFKSERRQkJqQUVoSGd5Q0Fnc2dDQzBBQUVIUUFFY05rd0VnQ0VFQmFpRUJETVFCQ3dKQUlBRWlDQ0FDUncwQVFZMEJJUjRNZ1FJTEFrQUNRQ0FJTFFBQVFiZC9hZzRIQVpRQmxBR1VBWlFCbEFFQWxBRUxJQWhCQVdvaEFVSDhBQ0VlRFBFQkN5QUlRUUZxSVFGQklpRWVESkFCQ3dKQUlBRWlIaUFDUncwQVFZNEJJUjRNZ0FJTElBSWdIbXNnQUNnQ0FDSWlhaUVtSUI0aENDQWlJUUVDUUFOQUlBZ3RBQUFnQVVIQXM0Q0FBR290QUFCSERaSUJJQUZCQVVZTkFTQUJRUUZxSVFFZ0NFRUJhaUlJSUFKSERRQUxJQUFnSmpZQ0FFR09BU0VlRElBQ0N5QUFRUUEyQWdBZ0hpQWlhMEVDYWlFQlFSMGhIZ3lQQVFzQ1FDQUJJZ2dnQWtjTkFFR1BBU0VlRFA4QkN3SkFBa0FnQ0MwQUFFR3VmMm9PQXdDU0FRR1NBUXNnQ0VFQmFpRUJRZjRBSVI0TTd3RUxJQWhCQVdvaEFVRUVJUjRNamdFTEFrQWdBU0lJSUFKSERRQkJrQUVoSGd6K0FRc0NRQUpBQWtBQ1FBSkFJQWd0QUFCQnYzOXFEaFVBbEFHVUFaUUJsQUdVQVpRQmxBR1VBWlFCbEFFQmxBR1VBUUtVQVpRQkE1UUJsQUVFbEFFTElBaEJBV29oQVVIMkFDRWVEUEVCQ3lBSVFRRnFJUUZCOXdBaEhnendBUXNnQ0VFQmFpRUJRZmdBSVI0TTd3RUxJQWhCQVdvaEFVSDlBQ0VlRE80QkN5QUlRUUZxSVFGQi93QWhIZ3p0QVFzQ1FDQUVJQUpIRFFCQmtRRWhIZ3o5QVFzZ0FpQUVheUFBS0FJQUloNXFJU0lnQkNFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWUyemdJQUFhaTBBQUVjTmp3RWdBVUVDUmcwQklBRkJBV29oQVNBSVFRRnFJZ2dnQWtjTkFBc2dBQ0FpTmdJQVFaRUJJUjRNL1FFTElBQkJBRFlDQUNBRUlCNXJRUU5xSVFGQkVTRWVESXdCQ3dKQUlBVWdBa2NOQUVHU0FTRWVEUHdCQ3lBQ0lBVnJJQUFvQWdBaUhtb2hJaUFGSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCd3JPQWdBQnFMUUFBUncyT0FTQUJRUUpHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQmtnRWhIZ3o4QVFzZ0FFRUFOZ0lBSUFVZ0htdEJBMm9oQVVFc0lSNE1pd0VMQWtBZ0JpQUNSdzBBUVpNQklSNE0rd0VMSUFJZ0Jtc2dBQ2dDQUNJZWFpRWlJQVloQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhGczRDQUFHb3RBQUJIRFkwQklBRkJCRVlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHVEFTRWVEUHNCQ3lBQVFRQTJBZ0FnQmlBZWEwRUZhaUVCUVNzaEhneUtBUXNDUUNBSElBSkhEUUJCbEFFaEhnejZBUXNnQWlBSGF5QUFLQUlBSWg1cUlTSWdCeUVJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRY3F6Z0lBQWFpMEFBRWNOakFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUVpRQklSNE0rZ0VMSUFCQkFEWUNBQ0FISUI1clFRTnFJUUZCRkNFZURJa0JDd0pBSUFnZ0FrY05BRUdWQVNFZURQa0JDd0pBQWtBQ1FBSkFJQWd0QUFCQnZuOXFEZzhBQVFLT0FZNEJqZ0dPQVk0QmpnR09BWTRCamdHT0FZNEJBNDRCQ3lBSVFRRnFJUVJCZ1FFaEhnenJBUXNnQ0VFQmFpRUZRWUlCSVI0TTZnRUxJQWhCQVdvaEJrR0RBU0VlRE9rQkN5QUlRUUZxSVFkQmhBRWhIZ3pvQVFzQ1FDQUlJQUpIRFFCQmxnRWhIZ3o0QVFzZ0NDMEFBRUhGQUVjTmlRRWdDRUVCYWlFSURMc0JDd0pBSUFrZ0FrY05BRUdYQVNFZURQY0JDeUFDSUFscklBQW9BZ0FpSG1vaElpQUpJUWdnSGlFQkFrQURRQ0FJTFFBQUlBRkJ6Yk9BZ0FCcUxRQUFSdzJKQVNBQlFRSkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCbHdFaEhnejNBUXNnQUVFQU5nSUFJQWtnSG10QkEyb2hBVUVPSVI0TWhnRUxBa0FnQ0NBQ1J3MEFRWmdCSVI0TTlnRUxJQWd0QUFCQjBBQkhEWWNCSUFoQkFXb2hBVUVsSVI0TWhRRUxBa0FnQ2lBQ1J3MEFRWmtCSVI0TTlRRUxJQUlnQ21zZ0FDZ0NBQ0llYWlFaUlBb2hDQ0FlSVFFQ1FBTkFJQWd0QUFBZ0FVSFFzNENBQUdvdEFBQkhEWWNCSUFGQkNFWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUdaQVNFZURQVUJDeUFBUVFBMkFnQWdDaUFlYTBFSmFpRUJRU29oSGd5RUFRc0NRQ0FJSUFKSERRQkJtZ0VoSGd6MEFRc0NRQUpBSUFndEFBQkJxMzlxRGdzQWh3R0hBWWNCaHdHSEFZY0Jod0dIQVljQkFZY0JDeUFJUVFGcUlRaEJpQUVoSGd6a0FRc2dDRUVCYWlFS1FZa0JJUjRNNHdFTEFrQWdDQ0FDUncwQVFac0JJUjRNOHdFTEFrQUNRQ0FJTFFBQVFiOS9hZzRVQUlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVFHR0FRc2dDRUVCYWlFSlFZY0JJUjRNNHdFTElBaEJBV29oQ0VHS0FTRWVET0lCQ3dKQUlBc2dBa2NOQUVHY0FTRWVEUElCQ3lBQ0lBdHJJQUFvQWdBaUhtb2hJaUFMSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCMmJPQWdBQnFMUUFBUncyRUFTQUJRUU5HRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQm5BRWhIZ3p5QVFzZ0FFRUFOZ0lBSUFzZ0htdEJCR29oQVVFaElSNE1nUUVMQWtBZ0RDQUNSdzBBUVowQklSNE04UUVMSUFJZ0RHc2dBQ2dDQUNJZWFpRWlJQXdoQ0NBZUlRRUNRQU5BSUFndEFBQWdBVUhkczRDQUFHb3RBQUJIRFlNQklBRkJCa1lOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHZEFTRWVEUEVCQ3lBQVFRQTJBZ0FnRENBZWEwRUhhaUVCUVJvaEhneUFBUXNDUUNBSUlBSkhEUUJCbmdFaEhnendBUXNDUUFKQUFrQWdDQzBBQUVHN2Yyb09FUUNFQVlRQmhBR0VBWVFCaEFHRUFZUUJoQUVCaEFHRUFZUUJoQUdFQVFLRUFRc2dDRUVCYWlFSVFZc0JJUjRNNFFFTElBaEJBV29oQzBHTUFTRWVET0FCQ3lBSVFRRnFJUXhCalFFaEhnemZBUXNDUUNBTklBSkhEUUJCbndFaEhnenZBUXNnQWlBTmF5QUFLQUlBSWg1cUlTSWdEU0VJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZVN6Z0lBQWFpMEFBRWNOZ1FFZ0FVRUZSZzBCSUFGQkFXb2hBU0FJUVFGcUlnZ2dBa2NOQUFzZ0FDQWlOZ0lBUVo4QklSNE03d0VMSUFCQkFEWUNBQ0FOSUI1clFRWnFJUUZCS0NFZURINExBa0FnRGlBQ1J3MEFRYUFCSVI0TTdnRUxJQUlnRG1zZ0FDZ0NBQ0llYWlFaUlBNGhDQ0FlSVFFQ1FBTkFJQWd0QUFBZ0FVSHFzNENBQUdvdEFBQkhEWUFCSUFGQkFrWU5BU0FCUVFGcUlRRWdDRUVCYWlJSUlBSkhEUUFMSUFBZ0lqWUNBRUdnQVNFZURPNEJDeUFBUVFBMkFnQWdEaUFlYTBFRGFpRUJRUWNoSGd4OUN3SkFJQWdnQWtjTkFFR2hBU0VlRE8wQkN3SkFBa0FnQ0MwQUFFRzdmMm9PRGdDQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUVCZ0FFTElBaEJBV29oRFVHUEFTRWVETjBCQ3lBSVFRRnFJUTVCa0FFaEhnemNBUXNDUUNBUElBSkhEUUJCb2dFaEhnenNBUXNnQWlBUGF5QUFLQUlBSWg1cUlTSWdEeUVJSUI0aEFRSkFBMEFnQ0MwQUFDQUJRZTJ6Z0lBQWFpMEFBRWNOZmlBQlFRSkdEUUVnQVVFQmFpRUJJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCb2dFaEhnenNBUXNnQUVFQU5nSUFJQThnSG10QkEyb2hBVUVTSVI0TWV3c0NRQ0FRSUFKSERRQkJvd0VoSGd6ckFRc2dBaUFRYXlBQUtBSUFJaDVxSVNJZ0VDRUlJQjRoQVFKQUEwQWdDQzBBQUNBQlFmQ3pnSUFBYWkwQUFFY05mU0FCUVFGR0RRRWdBVUVCYWlFQklBaEJBV29pQ0NBQ1J3MEFDeUFBSUNJMkFnQkJvd0VoSGd6ckFRc2dBRUVBTmdJQUlCQWdIbXRCQW1vaEFVRWdJUjRNZWdzQ1FDQVJJQUpIRFFCQnBBRWhIZ3pxQVFzZ0FpQVJheUFBS0FJQUloNXFJU0lnRVNFSUlCNGhBUUpBQTBBZ0NDMEFBQ0FCUWZLemdJQUFhaTBBQUVjTmZDQUJRUUZHRFFFZ0FVRUJhaUVCSUFoQkFXb2lDQ0FDUncwQUN5QUFJQ0kyQWdCQnBBRWhIZ3pxQVFzZ0FFRUFOZ0lBSUJFZ0htdEJBbW9oQVVFUElSNE1lUXNDUUNBSUlBSkhEUUJCcFFFaEhnenBBUXNDUUFKQUlBZ3RBQUJCdDM5cURnY0FmSHg4Zkh3QmZBc2dDRUVCYWlFUVFaTUJJUjRNMlFFTElBaEJBV29oRVVHVUFTRWVETmdCQ3dKQUlCSWdBa2NOQUVHbUFTRWVET2dCQ3lBQ0lCSnJJQUFvQWdBaUhtb2hJaUFTSVFnZ0hpRUJBa0FEUUNBSUxRQUFJQUZCOUxPQWdBQnFMUUFBUncxNklBRkJCMFlOQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHbUFTRWVET2dCQ3lBQVFRQTJBZ0FnRWlBZWEwRUlhaUVCUVJzaEhneDNDd0pBSUFnZ0FrY05BRUduQVNFZURPY0JDd0pBQWtBQ1FDQUlMUUFBUWI1L2FnNFNBSHQ3ZTN0N2UzdDdld0Y3ZTN0N2Uzc0Nld3NnQ0VFQmFpRVBRWklCSVI0TTJBRUxJQWhCQVdvaENFR1ZBU0VlRE5jQkN5QUlRUUZxSVJKQmxnRWhIZ3pXQVFzQ1FDQUlJQUpIRFFCQnFBRWhIZ3ptQVFzZ0NDMEFBRUhPQUVjTmR5QUlRUUZxSVFnTXFnRUxBa0FnQ0NBQ1J3MEFRYWtCSVI0TTVRRUxBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0NDMEFBRUcvZjJvT0ZRQUJBZ09HQVFRRkJvWUJoZ0dHQVFjSUNRb0xoZ0VNRFE0UGhnRUxJQWhCQVdvaEFVSFdBQ0VlRE9NQkN5QUlRUUZxSVFGQjF3QWhIZ3ppQVFzZ0NFRUJhaUVCUWR3QUlSNE00UUVMSUFoQkFXb2hBVUhnQUNFZURPQUJDeUFJUVFGcUlRRkI0UUFoSGd6ZkFRc2dDRUVCYWlFQlFlUUFJUjRNM2dFTElBaEJBV29oQVVIbEFDRWVETjBCQ3lBSVFRRnFJUUZCNkFBaEhnemNBUXNnQ0VFQmFpRUJRZkVBSVI0TTJ3RUxJQWhCQVdvaEFVSHlBQ0VlRE5vQkN5QUlRUUZxSVFGQjh3QWhIZ3paQVFzZ0NFRUJhaUVCUVlBQklSNE0yQUVMSUFoQkFXb2hDRUdHQVNFZUROY0JDeUFJUVFGcUlRaEJqZ0VoSGd6V0FRc2dDRUVCYWlFSVFaRUJJUjRNMVFFTElBaEJBV29oQ0VHWUFTRWVETlFCQ3dKQUlCUWdBa2NOQUVHckFTRWVET1FCQ3lBVVFRRnFJUk1NZHdzRFFBSkFJQjR0QUFCQmRtb09CSGNBQUhvQUN5QWVRUUZxSWg0Z0FrY05BQXRCckFFaEhnemlBUXNDUUNBVklBSkdEUUFnQUVHTmdJQ0FBRFlDQ0NBQUlCVTJBZ1FnRlNFQlFRRWhIZ3pTQVF0QnJRRWhIZ3poQVFzQ1FDQVZJQUpIRFFCQnJnRWhIZ3poQVFzQ1FBSkFJQlV0QUFCQmRtb09CQUdyQWFzQkFLc0JDeUFWUVFGcUlSUU1lQXNnRlVFQmFpRVRESFFMSUFBZ0V5QUNFS2VBZ0lBQUdpQVRJUUVNUlFzQ1FDQVZJQUpIRFFCQnJ3RWhIZ3pmQVFzQ1FBSkFJQlV0QUFCQmRtb09Gd0Y1ZVFGNWVYbDVlWGw1ZVhsNWVYbDVlWGw1ZVhrQWVRc2dGVUVCYWlFVkMwR2NBU0VlRE00QkN3SkFJQllnQWtjTkFFR3hBU0VlRE40QkN5QVdMUUFBUVNCSERYY2dBRUVBT3dFeUlCWkJBV29oQVVHZ0FTRWVETTBCQ3lBQklTWUNRQU5BSUNZaUZTQUNSZzBCSUJVdEFBQkJVR3BCL3dGeEloNUJDazhOcUFFQ1FDQUFMd0V5SWlKQm1UTkxEUUFnQUNBaVFRcHNJaUk3QVRJZ0hrSC8vd056SUNKQi92OERjVWtOQUNBVlFRRnFJU1lnQUNBaUlCNXFJaDQ3QVRJZ0hrSC8vd054UWVnSFNRMEJDd3RCQUNFZUlBQkJBRFlDSENBQVFaMkpnSUFBTmdJUUlBQkJEVFlDRENBQUlCVkJBV28yQWhRTTNRRUxRYkFCSVI0TTNBRUxBa0FnRnlBQ1J3MEFRYklCSVI0TTNBRUxRUUFoSGdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnRnkwQUFFRlFhZzRLZjM0QUFRSURCQVVHQjRBQkMwRUNJUjRNZmd0QkF5RWVESDBMUVFRaEhneDhDMEVGSVI0TWV3dEJCaUVlREhvTFFRY2hIZ3g1QzBFSUlSNE1lQXRCQ1NFZURIY0xBa0FnR0NBQ1J3MEFRYk1CSVI0TTJ3RUxJQmd0QUFCQkxrY05lQ0FZUVFGcUlSY01wZ0VMQWtBZ0dTQUNSdzBBUWJRQklSNE0yZ0VMUVFBaEhnSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0dTMEFBRUZRYWc0S2dRR0FBUUFCQWdNRUJRWUhnZ0VMUVFJaEhneUFBUXRCQXlFZURIOExRUVFoSGd4K0MwRUZJUjRNZlF0QkJpRWVESHdMUVFjaEhneDdDMEVJSVI0TWVndEJDU0VlREhrTEFrQWdDQ0FDUncwQVFiVUJJUjRNMlFFTElBSWdDR3NnQUNnQ0FDSWlhaUVtSUFnaEdTQWlJUjREUUNBWkxRQUFJQjVCL0xPQWdBQnFMUUFBUncxN0lCNUJCRVlOdEFFZ0hrRUJhaUVlSUJsQkFXb2lHU0FDUncwQUN5QUFJQ1kyQWdCQnRRRWhIZ3pZQVFzQ1FDQWFJQUpIRFFCQnRnRWhIZ3pZQVFzZ0FpQWFheUFBS0FJQUloNXFJU0lnR2lFSUlCNGhBUU5BSUFndEFBQWdBVUdCdElDQUFHb3RBQUJIRFhzZ0FVRUJSZzIyQVNBQlFRRnFJUUVnQ0VFQmFpSUlJQUpIRFFBTElBQWdJallDQUVHMkFTRWVETmNCQ3dKQUlCc2dBa2NOQUVHM0FTRWVETmNCQ3lBQ0lCdHJJQUFvQWdBaUdXb2hJaUFiSVFnZ0dTRWVBMEFnQ0MwQUFDQWVRWU8wZ0lBQWFpMEFBRWNOZWlBZVFRSkdEWHdnSGtFQmFpRWVJQWhCQVdvaUNDQUNSdzBBQ3lBQUlDSTJBZ0JCdHdFaEhneldBUXNDUUNBSUlBSkhEUUJCdUFFaEhneldBUXNDUUFKQUlBZ3RBQUJCdTM5cURoQUFlM3Q3ZTN0N2UzdDdlM3Q3ZTNzQmV3c2dDRUVCYWlFYVFhVUJJUjRNeGdFTElBaEJBV29oRzBHbUFTRWVETVVCQ3dKQUlBZ2dBa2NOQUVHNUFTRWVETlVCQ3lBSUxRQUFRY2dBUncxNElBaEJBV29oQ0F5aUFRc0NRQ0FJSUFKSERRQkJ1Z0VoSGd6VUFRc2dDQzBBQUVISUFFWU5vZ0VnQUVFQk9nQW9ESmtCQ3dOQUFrQWdDQzBBQUVGMmFnNEVBSHA2QUhvTElBaEJBV29pQ0NBQ1J3MEFDMEc4QVNFZUROSUJDeUFBUVFBNkFDOGdBQzBBTFVFRWNVVU55QUVMSUFCQkFEb0FMeUFCSVFFTWVRc2dIa0VWUmcycEFTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnE0eUFnQUEyQWhBZ0FFRVNOZ0lNUVFBaEhnelBBUXNDUUNBQUlCNGdBaEN0Z0lDQUFDSUJEUUFnSGlFQkRNVUJDd0pBSUFGQkZVY05BQ0FBUVFNMkFod2dBQ0FlTmdJVUlBQkIxcEtBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3pQQVFzZ0FFRUFOZ0ljSUFBZ0hqWUNGQ0FBUWF1TWdJQUFOZ0lRSUFCQkVqWUNERUVBSVI0TXpnRUxJQjVCRlVZTnBRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFZaU1nSUFBTmdJUUlBQkJGRFlDREVFQUlSNE16UUVMSUFBb0FnUWhKaUFBUVFBMkFnUWdIaUFmcDJvaUl5RUJJQUFnSmlBZUlDTWdJaHNpSGhDdWdJQ0FBQ0lpUlExNklBQkJCellDSENBQUlCNDJBaFFnQUNBaU5nSU1RUUFoSGd6TUFRc2dBQ0FBTHdFd1FZQUJjanNCTUNBQklRRU1NUXNnSGtFVlJnMmhBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4WXVBZ0FBMkFoQWdBRUVUTmdJTVFRQWhIZ3pLQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVl1TGdJQUFOZ0lRSUFCQkFqWUNERUVBSVI0TXlRRUxJQjVCTzBjTkFTQUJRUUZxSVFFTFFRZ2hIZ3kzQVF0QkFDRWVJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2prSUNBQURZQ0VDQUFRUXcyQWd3TXhnRUxRZ0VoSHdzZ0hrRUJhaUVCQWtBZ0FDa0RJQ0lnUXYvLy8vLy8vLy8vRDFZTkFDQUFJQ0JDQklZZ0g0UTNBeUFnQVNFQkRIY0xJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0ppWUNBQURZQ0VDQUFRUXcyQWd4QkFDRWVETVFCQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCbzVDQWdBQTJBaEFnQUVFTU5nSU1RUUFoSGd6REFRc2dBQ2dDQkNFbUlBQkJBRFlDQkNBZUlCK25haUlqSVFFZ0FDQW1JQjRnSXlBaUd5SWVFSzZBZ0lBQUlpSkZEVzRnQUVFRk5nSWNJQUFnSGpZQ0ZDQUFJQ0kyQWd4QkFDRWVETUlCQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCM1pTQWdBQTJBaEFnQUVFUE5nSU1RUUFoSGd6QkFRc2dBQ0FlSUFJUXJZQ0FnQUFpQVEwQklCNGhBUXRCRHlFZURLOEJDd0pBSUFGQkZVY05BQ0FBUVFJMkFod2dBQ0FlTmdJVUlBQkIxcEtBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3kvQVFzZ0FFRUFOZ0ljSUFBZ0hqWUNGQ0FBUWF1TWdJQUFOZ0lRSUFCQkVqWUNERUVBSVI0TXZnRUxJQUZCQVdvaEhnSkFJQUF2QVRBaUFVR0FBWEZGRFFBQ1FDQUFJQjRnQWhDd2dJQ0FBQ0lCRFFBZ0hpRUJER3NMSUFGQkZVY05sd0VnQUVFRk5nSWNJQUFnSGpZQ0ZDQUFRYjZTZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUjRNdmdFTEFrQWdBVUdnQkhGQm9BUkhEUUFnQUMwQUxVRUNjUTBBSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUhzajRDQUFEWUNFQ0FBUVFRMkFneEJBQ0VlREw0QkN5QUFJQjRnQWhDeGdJQ0FBQm9nSGlFQkFrQUNRQUpBQWtBQ1FDQUFJQjRnQWhDc2dJQ0FBQTRXQWdFQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUF3UUxJQUJCQVRvQUxnc2dBQ0FBTHdFd1FjQUFjanNCTUNBZUlRRUxRUjBoSGd5dkFRc2dBRUVWTmdJY0lBQWdIallDRkNBQVFlR1JnSUFBTmdJUUlBQkJGVFlDREVFQUlSNE12Z0VMSUFCQkFEWUNIQ0FBSUI0MkFoUWdBRUd4aTRDQUFEWUNFQ0FBUVJFMkFneEJBQ0VlREwwQkN5QUFMUUF0UVFGeFJRMEJRYW9CSVI0TXJBRUxBa0FnSENBQ1JnMEFBMEFDUUNBY0xRQUFRU0JHRFFBZ0hDRUJES2dCQ3lBY1FRRnFJaHdnQWtjTkFBdEJGeUVlREx3QkMwRVhJUjRNdXdFTElBQW9BZ1FoQVNBQVFRQTJBZ1FnQUNBQklCd1FxSUNBZ0FBaUFVVU5rQUVnQUVFWU5nSWNJQUFnQVRZQ0RDQUFJQnhCQVdvMkFoUkJBQ0VlRExvQkN5QUFRUmsyQWh3Z0FDQUJOZ0lVSUFBZ0hqWUNERUVBSVI0TXVRRUxJQjRoQVVFQklTSUNRQUpBQWtBQ1FBSkFBa0FDUUNBQUxRQXNRWDVxRGdjR0JRVURBUUlBQlFzZ0FDQUFMd0V3UVFoeU93RXdEQU1MUVFJaElnd0JDMEVFSVNJTElBQkJBVG9BTENBQUlBQXZBVEFnSW5JN0FUQUxJQjRoQVF0QklDRWVES2tCQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCZ1krQWdBQTJBaEFnQUVFTE5nSU1RUUFoSGd5NEFRc2dIaUVCUVFFaElnSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBZ0FCQXdVTFFRSWhJZ3dCQzBFRUlTSUxJQUJCQVRvQUxDQUFJQUF2QVRBZ0luSTdBVEFNQVFzZ0FDQUFMd0V3UVFoeU93RXdDeUFlSVFFTFFhc0JJUjRNcGdFTElBQWdBU0FDRUt1QWdJQUFHZ3diQ3dKQUlBRWlIaUFDUmcwQUlCNGhBUUpBQWtBZ0hpMEFBRUYyYWc0RUFXcHFBR29MSUI1QkFXb2hBUXRCSGlFZURLVUJDMEhEQUNFZURMUUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJrWkdBZ0FBMkFoQWdBRUVETmdJTVFRQWhIZ3l6QVFzQ1FDQUJMUUFBUVExSERRQWdBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtxQWdJQUFJaDROQUNBQlFRRnFJUUVNYVFzZ0FFRWVOZ0ljSUFBZ0hqWUNEQ0FBSUFGQkFXbzJBaFJCQUNFZURMTUJDeUFCSVFFZ0FDMEFMVUVCY1VVTnJnRkJyUUVoSGd5aUFRc0NRQ0FCSWdFZ0FrY05BRUVmSVI0TXNnRUxBa0FDUUFOQUFrQWdBUzBBQUVGMmFnNEVBZ0FBQXdBTElBRkJBV29pQVNBQ1J3MEFDMEVmSVI0TXN3RUxJQUFvQWdRaEhpQUFRUUEyQWdRQ1FDQUFJQjRnQVJDcWdJQ0FBQ0llRFFBZ0FTRUJER2dMSUFCQkhqWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3l5QVFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS3FBZ0lBQUloNE5BQ0FCUVFGcUlRRU1ad3NnQUVFZU5nSWNJQUFnSGpZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VlRExFQkN5QWVRU3hIRFFFZ0FVRUJhaUVlUVFFaEFRSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQkFBTElCNGhBUXdFQzBFQ0lRRU1BUXRCQkNFQkN5QUFRUUU2QUN3Z0FDQUFMd0V3SUFGeU93RXdJQjRoQVF3QkN5QUFJQUF2QVRCQkNISTdBVEFnSGlFQkMwRXVJUjRNbndFTElBQkJBRG9BTENBQklRRUxRU2toSGd5ZEFRc2dBRUVBTmdJQUlDTWdKR3RCQ1dvaEFVRUZJUjRNbUFFTElBQkJBRFlDQUNBaklDUnJRUVpxSVFGQkJ5RWVESmNCQ3lBQUlBQXZBVEJCSUhJN0FUQWdBU0VCREFJTElBQW9BZ1FoQ0NBQVFRQTJBZ1FDUUNBQUlBZ2dBUkNxZ0lDQUFDSUlEUUFnQVNFQkRKMEJDeUFBUVNvMkFod2dBQ0FCTmdJVUlBQWdDRFlDREVFQUlSNE1xUUVMSUFCQkNEb0FMQ0FCSVFFTFFTVWhIZ3lYQVFzQ1FDQUFMUUFvUVFGR0RRQWdBU0VCREFRTElBQXRBQzFCQ0hGRkRYZ2dBU0VCREFNTElBQXRBREJCSUhFTmVVR3VBU0VlREpVQkN3SkFJQjBnQWtZTkFBSkFBMEFDUUNBZExRQUFRVkJxSWdGQi93RnhRUXBKRFFBZ0hTRUJRU29oSGd5WUFRc2dBQ2tESUNJZlFwbXo1c3lacytiTUdWWU5BU0FBSUI5Q0NuNGlIemNESUNBZklBR3RJaUJDZjRWQ2dINkVWZzBCSUFBZ0h5QWdRdjhCZzN3M0F5QWdIVUVCYWlJZElBSkhEUUFMUVN3aEhneW1BUXNnQUNnQ0JDRUlJQUJCQURZQ0JDQUFJQWdnSFVFQmFpSUJFS3FBZ0lBQUlnZ05laUFCSVFFTW1RRUxRU3doSGd5a0FRc0NRQ0FBTHdFd0lnRkJDSEZGRFFBZ0FDMEFLRUVCUncwQUlBQXRBQzFCQ0hGRkRYVUxJQUFnQVVIMyt3TnhRWUFFY2pzQk1DQWRJUUVMUVN3aEhneVNBUXNnQUNBQUx3RXdRUkJ5T3dFd0RJY0JDeUFBUVRZMkFod2dBQ0FCTmdJTUlBQWdIRUVCYWpZQ0ZFRUFJUjRNb0FFTElBRXRBQUJCT2tjTkFpQUFLQUlFSVI0Z0FFRUFOZ0lFSUFBZ0hpQUJFS2lBZ0lBQUloNE5BU0FCUVFGcUlRRUxRVEVoSGd5T0FRc2dBRUUyTmdJY0lBQWdIallDRENBQUlBRkJBV28yQWhSQkFDRWVESjBCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCaDQ2QWdBQTJBaEFnQUVFS05nSU1RUUFoSGd5Y0FRc2dBVUVCYWlFQkN5QUFRWUFTT3dFcUlBQWdBU0FDRUtXQWdJQUFHaUFCSVFFTFFhd0JJUjRNaVFFTElBQW9BZ1FoSGlBQVFRQTJBZ1FDUUNBQUlCNGdBUkNrZ0lDQUFDSWVEUUFnQVNFQkRGQUxJQUJCeEFBMkFod2dBQ0FCTmdJVUlBQWdIallDREVFQUlSNE1tQUVMSUFCQkFEWUNIQ0FBSUNJMkFoUWdBRUhsbUlDQUFEWUNFQ0FBUVFjMkFnd2dBRUVBTmdJQVFRQWhIZ3lYQVFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS1NBZ0lBQUloNE5BQ0FCSVFFTVR3c2dBRUhGQURZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneVdBUXRCQUNFZUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIcmpZQ0FBRFlDRUNBQVFRazJBZ3dNbFFFTFFRRWhIZ3NnQUNBZU9nQXJJQUZCQVdvaEFTQUFMUUFwUVNKR0RZc0JERXdMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdpallDQUFEWUNFQ0FBUVFrMkFneEJBQ0VlREpJQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnhZcUFnQUEyQWhBZ0FFRUpOZ0lNUVFBaEhneVJBUXRCQVNFZUN5QUFJQjQ2QUNvZ0FVRUJhaUVCREVvTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHNGpZQ0FBRFlDRUNBQVFRazJBZ3hCQUNFZURJNEJDeUFBUVFBMkFnQWdKaUFqYTBFRWFpRUJBa0FnQUMwQUtVRWpUdzBBSUFFaEFReEtDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJyNG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhIZ3lOQVFzZ0FFRUFOZ0lBQzBFQUlSNGdBRUVBTmdJY0lBQWdBVFlDRkNBQVFibWJnSUFBTmdJUUlBQkJDRFlDREF5TEFRc2dBRUVBTmdJQUlDWWdJMnRCQTJvaEFRSkFJQUF0QUNsQklVY05BQ0FCSVFFTVJ3c2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFmZUpnSUFBTmdJUUlBQkJDRFlDREVFQUlSNE1pZ0VMSUFCQkFEWUNBQ0FtSUNOclFRUnFJUUVDUUNBQUxRQXBJaDVCWFdwQkMwOE5BQ0FCSVFFTVJnc0NRQ0FlUVFaTERRQkJBU0FlZEVIS0FIRkZEUUFnQVNFQkRFWUxRUUFoSGlBQVFRQTJBaHdnQUNBQk5nSVVJQUJCMDRtQWdBQTJBaEFnQUVFSU5nSU1ESWtCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF4R0N5QUFRZEFBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURJZ0JDeUFBS0FJRUlSNGdBRUVBTmdJRUFrQWdBQ0FlSUFFUXBJQ0FnQUFpSGcwQUlBRWhBUXcvQ3lBQVFjUUFOZ0ljSUFBZ0FUWUNGQ0FBSUI0MkFneEJBQ0VlREljQkN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFRdy9DeUFBUWNVQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESVlCQ3lBQUtBSUVJUjRnQUVFQU5nSUVBa0FnQUNBZUlBRVFwSUNBZ0FBaUhnMEFJQUVoQVF4REN5QUFRZEFBTmdJY0lBQWdBVFlDRkNBQUlCNDJBZ3hCQUNFZURJVUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJvb3FBZ0FBMkFoQWdBRUVITmdJTVFRQWhIZ3lFQVFzZ0FDZ0NCQ0VlSUFCQkFEWUNCQUpBSUFBZ0hpQUJFS1NBZ0lBQUloNE5BQ0FCSVFFTU93c2dBRUhFQURZQ0hDQUFJQUUyQWhRZ0FDQWVOZ0lNUVFBaEhneURBUXNnQUNnQ0JDRWVJQUJCQURZQ0JBSkFJQUFnSGlBQkVLU0FnSUFBSWg0TkFDQUJJUUVNT3dzZ0FFSEZBRFlDSENBQUlBRTJBaFFnQUNBZU5nSU1RUUFoSGd5Q0FRc2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtTQWdJQUFJaDROQUNBQklRRU1Qd3NnQUVIUUFEWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3lCQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJpSWdJQUFOZ0lRSUFCQkJ6WUNERUVBSVI0TWdBRUxJQjVCUDBjTkFTQUJRUUZxSVFFTFFRVWhIZ3h1QzBFQUlSNGdBRUVBTmdJY0lBQWdBVFlDRkNBQVFkT1BnSUFBTmdJUUlBQkJCellDREF4OUN5QUFLQUlFSVI0Z0FFRUFOZ0lFQWtBZ0FDQWVJQUVRcElDQWdBQWlIZzBBSUFFaEFRdzBDeUFBUWNRQU5nSWNJQUFnQVRZQ0ZDQUFJQjQyQWd4QkFDRWVESHdMSUFBb0FnUWhIaUFBUVFBMkFnUUNRQ0FBSUI0Z0FSQ2tnSUNBQUNJZURRQWdBU0VCRERRTElBQkJ4UUEyQWh3Z0FDQUJOZ0lVSUFBZ0hqWUNERUVBSVI0TWV3c2dBQ2dDQkNFZUlBQkJBRFlDQkFKQUlBQWdIaUFCRUtTQWdJQUFJaDROQUNBQklRRU1PQXNnQUVIUUFEWUNIQ0FBSUFFMkFoUWdBQ0FlTmdJTVFRQWhIZ3g2Q3lBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklDSVFwSUNBZ0FBaUFRMEFJQ0loQVF3eEN5QUFRY1FBTmdJY0lBQWdJallDRkNBQUlBRTJBZ3hCQUNFZURIa0xJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnSWhDa2dJQ0FBQ0lCRFFBZ0lpRUJEREVMSUFCQnhRQTJBaHdnQUNBaU5nSVVJQUFnQVRZQ0RFRUFJUjRNZUFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQWlFS1NBZ0lBQUlnRU5BQ0FpSVFFTU5Rc2dBRUhRQURZQ0hDQUFJQ0kyQWhRZ0FDQUJOZ0lNUVFBaEhneDNDeUFBUVFBMkFod2dBQ0FpTmdJVUlBQkIwSXlBZ0FBMkFoQWdBRUVITmdJTVFRQWhIZ3gyQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCMEl5QWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd4MUMwRUFJUjRnQUVFQU5nSWNJQUFnSWpZQ0ZDQUFRYitVZ0lBQU5nSVFJQUJCQnpZQ0RBeDBDeUFBUVFBMkFod2dBQ0FpTmdJVUlBQkJ2NVNBZ0FBMkFoQWdBRUVITmdJTVFRQWhIZ3h6Q3lBQVFRQTJBaHdnQUNBaU5nSVVJQUJCMUk2QWdBQTJBaEFnQUVFSE5nSU1RUUFoSGd4eUN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQndaT0FnQUEyQWhBZ0FFRUdOZ0lNUVFBaEhneHhDeUFBUVFBMkFnQWdJaUFtYTBFR2FpRUJRU1FoSGdzZ0FDQWVPZ0FwSUFFaEFReE9DeUFBUVFBMkFnQUxRUUFoSGlBQVFRQTJBaHdnQUNBSU5nSVVJQUJCcEpTQWdBQTJBaEFnQUVFR05nSU1ERzBMSUFBb0FnUWhFeUFBUVFBMkFnUWdBQ0FUSUI0UXBvQ0FnQUFpRXcwQklCNUJBV29oRXd0Qm5RRWhIZ3hiQ3lBQVFhb0JOZ0ljSUFBZ0V6WUNEQ0FBSUI1QkFXbzJBaFJCQUNFZURHb0xJQUFvQWdRaEZDQUFRUUEyQWdRZ0FDQVVJQjRRcG9DQWdBQWlGQTBCSUI1QkFXb2hGQXRCbWdFaEhneFlDeUFBUWFzQk5nSWNJQUFnRkRZQ0RDQUFJQjVCQVdvMkFoUkJBQ0VlREdjTElBQkJBRFlDSENBQUlCVTJBaFFnQUVIemlvQ0FBRFlDRUNBQVFRMDJBZ3hCQUNFZURHWUxJQUJCQURZQ0hDQUFJQlkyQWhRZ0FFSE9qWUNBQURZQ0VDQUFRUWsyQWd4QkFDRWVER1VMUVFFaEhnc2dBQ0FlT2dBcklCZEJBV29oRmd3dUN5QUFRUUEyQWh3Z0FDQVhOZ0lVSUFCQm9vMkFnQUEyQWhBZ0FFRUpOZ0lNUVFBaEhneGlDeUFBUVFBMkFod2dBQ0FZTmdJVUlBQkJ4WXFBZ0FBMkFoQWdBRUVKTmdJTVFRQWhIZ3hoQzBFQklSNExJQUFnSGpvQUtpQVpRUUZxSVJnTUxBc2dBRUVBTmdJY0lBQWdHVFlDRkNBQVFiaU5nSUFBTmdJUUlBQkJDVFlDREVFQUlSNE1YZ3NnQUVFQU5nSWNJQUFnR1RZQ0ZDQUFRYm1iZ0lBQU5nSVFJQUJCQ0RZQ0RDQUFRUUEyQWdCQkFDRWVERjBMSUFCQkFEWUNBQXRCQUNFZUlBQkJBRFlDSENBQUlBZzJBaFFnQUVHTGxJQ0FBRFlDRUNBQVFRZzJBZ3dNV3dzZ0FFRUNPZ0FvSUFCQkFEWUNBQ0FiSUJsclFRTnFJUmtNTmdzZ0FFRUNPZ0F2SUFBZ0NDQUNFS09BZ0lBQUloNE5BVUd2QVNFZURFa0xJQUF0QUNoQmYyb09BaDRnSHdzZ0hrRVZSdzBuSUFCQnV3RTJBaHdnQUNBSU5nSVVJQUJCcDVLQWdBQTJBaEFnQUVFVk5nSU1RUUFoSGd4WEMwRUFJUjRNUmd0QkFpRWVERVVMUVE0aEhneEVDMEVRSVI0TVF3dEJIQ0VlREVJTFFSUWhIZ3hCQzBFV0lSNE1RQXRCRnlFZUREOExRUmtoSGd3K0MwRWFJUjRNUFF0Qk9pRWVERHdMUVNNaEhndzdDMEVrSVI0TU9ndEJNQ0VlRERrTFFUc2hIZ3c0QzBFOElSNE1Od3RCUGlFZUREWUxRVDhoSGd3MUMwSEFBQ0VlRERRTFFjRUFJUjRNTXd0QnhRQWhIZ3d5QzBISEFDRWVEREVMUWNnQUlSNE1NQXRCeWdBaEhnd3ZDMEhmQUNFZURDNExRZUlBSVI0TUxRdEIrd0FoSGd3c0MwR0ZBU0VlRENzTFFaY0JJUjRNS2d0Qm1RRWhIZ3dwQzBHcEFTRWVEQ2dMUWFRQklSNE1Kd3RCbXdFaEhnd21DMEdlQVNFZURDVUxRWjhCSVI0TUpBdEJvUUVoSGd3akMwR2lBU0VlRENJTFFhY0JJUjRNSVF0QnFBRWhIZ3dnQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCNW91QWdBQTJBaEFnQUVFUU5nSU1RUUFoSGd3dkN5QUFRUUEyQWdRZ0FDQWRJQjBRcW9DQWdBQWlBVVVOQVNBQVFTMDJBaHdnQUNBQk5nSU1JQUFnSFVFQmFqWUNGRUVBSVI0TUxnc2dBQ2dDQkNFSUlBQkJBRFlDQkFKQUlBQWdDQ0FCRUtxQWdJQUFJZ2hGRFFBZ0FFRXVOZ0ljSUFBZ0NEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFZURDNExJQUZCQVdvaEFRd2VDeUFkUVFGcUlRRU1IZ3NnQUVFQU5nSWNJQUFnSFRZQ0ZDQUFRYnFQZ0lBQU5nSVFJQUJCQkRZQ0RFRUFJUjRNS3dzZ0FFRXBOZ0ljSUFBZ0FUWUNGQ0FBSUFnMkFneEJBQ0VlRENvTElCeEJBV29oQVF3ZUN5QUFRUW8yQWh3Z0FDQUJOZ0lVSUFCQmtaS0FnQUEyQWhBZ0FFRVZOZ0lNUVFBaEhnd29DeUFBUVJBMkFod2dBQ0FCTmdJVUlBQkJ2cEtBZ0FBMkFoQWdBRUVWTmdJTVFRQWhIZ3duQ3lBQVFRQTJBaHdnQUNBZU5nSVVJQUJCaUl5QWdBQTJBaEFnQUVFVU5nSU1RUUFoSGd3bUN5QUFRUVEyQWh3Z0FDQUJOZ0lVSUFCQjFwS0FnQUEyQWhBZ0FFRVZOZ0lNUVFBaEhnd2xDeUFBUVFBMkFnQWdDQ0FpYTBFRmFpRVpDMEdqQVNFZURCTUxJQUJCQURZQ0FDQWlJQ1pyUVFKcUlRRkI0d0FoSGd3U0N5QUFRUUEyQWdBZ0FFR0JCRHNCS0NBYUlCNXJRUUpxSVFFTFFkTUFJUjRNRUFzZ0FTRUJBa0FnQUMwQUtVRUZSdzBBUWRJQUlSNE1FQXRCMFFBaEhnd1BDMEVBSVI0Z0FFRUFOZ0ljSUFCQnVvNkFnQUEyQWhBZ0FFRUhOZ0lNSUFBZ0lrRUJhallDRkF3ZUN5QUFRUUEyQWdBZ0ppQWphMEVDYWlFQlFUUWhIZ3dOQ3lBQklRRUxRUzBoSGd3TEN3SkFJQUVpSFNBQ1JnMEFBMEFDUUNBZExRQUFRWUNpZ0lBQWFpMEFBQ0lCUVFGR0RRQWdBVUVDUncwRElCMUJBV29oQVF3RUN5QWRRUUZxSWgwZ0FrY05BQXRCTVNFZURCc0xRVEVoSGd3YUN5QUFRUUE2QUN3Z0hTRUJEQUVMUVF3aEhnd0lDMEV2SVI0TUJ3c2dBVUVCYWlFQlFTSWhIZ3dHQzBFZklSNE1CUXNnQUVFQU5nSUFJQ01nSkd0QkJHb2hBVUVHSVI0TElBQWdIam9BTENBQklRRkJEU0VlREFNTElBQkJBRFlDQUNBbUlDTnJRUWRxSVFGQkN5RWVEQUlMSUFCQkFEWUNBQXNnQUVFQU9nQXNJQndoQVVFSklSNE1BQXNMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnVKR0FnQUEyQWhBZ0FFRVBOZ0lNREE0TFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1SkdBZ0FBMkFoQWdBRUVQTmdJTURBMExRUUFoSGlBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbG8rQWdBQTJBaEFnQUVFTE5nSU1EQXdMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhZaUFnQUEyQWhBZ0FFRUxOZ0lNREFzTFFRQWhIaUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJpSTJBZ0FBMkFoQWdBRUVLTmdJTURBb0xJQUJCQWpZQ0hDQUFJQUUyQWhRZ0FFSHdrb0NBQURZQ0VDQUFRUlkyQWd4QkFDRWVEQWtMUVFFaEhnd0lDMEhHQUNFZUlBRWlBU0FDUmcwSElBTkJDR29nQUNBQklBSkIyS2FBZ0FCQkNoQzVnSUNBQUNBREtBSU1JUUVnQXlnQ0NBNERBUWNDQUFzUXY0Q0FnQUFBQ3lBQVFRQTJBaHdnQUVHSms0Q0FBRFlDRUNBQVFSYzJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEhnd0ZDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJucE9BZ0FBMkFoQWdBRUVKTmdJTVFRQWhIZ3dFQ3dKQUlBRWlBU0FDUncwQVFTRWhIZ3dFQ3dKQUlBRXRBQUJCQ2tZTkFDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjdveUFnQUEyQWhBZ0FFRUtOZ0lNUVFBaEhnd0VDeUFBS0FJRUlRZ2dBRUVBTmdJRUlBQWdDQ0FCRUtxQWdJQUFJZ2dOQVNBQlFRRnFJUUVMUVFBaEhpQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjZwQ0FnQUEyQWhBZ0FFRVpOZ0lNREFJTElBQkJJRFlDSENBQUlBZzJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEhnd0JDd0pBSUFFaUFTQUNSdzBBUVJRaEhnd0JDeUFBUVltQWdJQUFOZ0lJSUFBZ0FUWUNCRUVUSVI0TElBTkJFR29rZ0lDQWdBQWdIZ3V2QVFFQ2Z5QUJLQUlBSVFZQ1FBSkFJQUlnQTBZTkFDQUVJQVpxSVFRZ0JpQURhaUFDYXlFSElBSWdCa0YvY3lBRmFpSUdhaUVGQTBBQ1FDQUNMUUFBSUFRdEFBQkdEUUJCQWlFRURBTUxBa0FnQmcwQVFRQWhCQ0FGSVFJTUF3c2dCa0YvYWlFR0lBUkJBV29oQkNBQ1FRRnFJZ0lnQTBjTkFBc2dCeUVHSUFNaEFnc2dBRUVCTmdJQUlBRWdCallDQUNBQUlBSTJBZ1FQQ3lBQlFRQTJBZ0FnQUNBRU5nSUFJQUFnQWpZQ0JBc0tBQ0FBRUx1QWdJQUFDNVUzQVF0L0k0Q0FnSUFBUVJCcklnRWtnSUNBZ0FBQ1FFRUFLQUtndElDQUFBMEFRUUFRdm9DQWdBQkJnTGlFZ0FCcklnSkIyUUJKRFFCQkFDRURBa0JCQUNnQzRMZUFnQUFpQkEwQVFRQkNmemNDN0xlQWdBQkJBRUtBZ0lTQWdJREFBRGNDNUxlQWdBQkJBQ0FCUVFocVFYQnhRZGlxMWFvRmN5SUVOZ0xndDRDQUFFRUFRUUEyQXZTM2dJQUFRUUJCQURZQ3hMZUFnQUFMUVFBZ0FqWUN6TGVBZ0FCQkFFR0F1SVNBQURZQ3lMZUFnQUJCQUVHQXVJU0FBRFlDbUxTQWdBQkJBQ0FFTmdLc3RJQ0FBRUVBUVg4MkFxaTBnSUFBQTBBZ0EwSEV0SUNBQUdvZ0EwRzR0SUNBQUdvaUJEWUNBQ0FFSUFOQnNMU0FnQUJxSWdVMkFnQWdBMEc4dElDQUFHb2dCVFlDQUNBRFFjeTBnSUFBYWlBRFFjQzBnSUFBYWlJRk5nSUFJQVVnQkRZQ0FDQURRZFMwZ0lBQWFpQURRY2kwZ0lBQWFpSUVOZ0lBSUFRZ0JUWUNBQ0FEUWRDMGdJQUFhaUFFTmdJQUlBTkJJR29pQTBHQUFrY05BQXRCZ0xpRWdBQkJlRUdBdUlTQUFHdEJEM0ZCQUVHQXVJU0FBRUVJYWtFUGNSc2lBMm9pQkVFRWFpQUNJQU5yUVVocUlnTkJBWEkyQWdCQkFFRUFLQUx3dDRDQUFEWUNwTFNBZ0FCQkFDQUVOZ0tndElDQUFFRUFJQU0yQXBTMGdJQUFJQUpCZ0xpRWdBQnFRVXhxUVRnMkFnQUxBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI3QUZMRFFBQ1FFRUFLQUtJdElDQUFDSUdRUkFnQUVFVGFrRndjU0FBUVF0Skd5SUNRUU4ySWdSMklnTkJBM0ZGRFFBZ0EwRUJjU0FFY2tFQmN5SUZRUU4wSWdCQnVMU0FnQUJxS0FJQUlnUkJDR29oQXdKQUFrQWdCQ2dDQ0NJQ0lBQkJzTFNBZ0FCcUlnQkhEUUJCQUNBR1FYNGdCWGR4TmdLSXRJQ0FBQXdCQ3lBQUlBSTJBZ2dnQWlBQU5nSU1DeUFFSUFWQkEzUWlCVUVEY2pZQ0JDQUVJQVZxUVFScUlnUWdCQ2dDQUVFQmNqWUNBQXdNQ3lBQ1FRQW9BcEMwZ0lBQUlnZE5EUUVDUUNBRFJRMEFBa0FDUUNBRElBUjBRUUlnQkhRaUEwRUFJQU5yY25FaUEwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQkVFRmRrRUljU0lGSUFOeUlBUWdCWFlpQTBFQ2RrRUVjU0lFY2lBRElBUjJJZ05CQVhaQkFuRWlCSElnQXlBRWRpSURRUUYyUVFGeElnUnlJQU1nQkhacUlnVkJBM1FpQUVHNHRJQ0FBR29vQWdBaUJDZ0NDQ0lESUFCQnNMU0FnQUJxSWdCSERRQkJBQ0FHUVg0Z0JYZHhJZ1kyQW9pMGdJQUFEQUVMSUFBZ0F6WUNDQ0FESUFBMkFnd0xJQVJCQ0dvaEF5QUVJQUpCQTNJMkFnUWdCQ0FGUVFOMElnVnFJQVVnQW1zaUJUWUNBQ0FFSUFKcUlnQWdCVUVCY2pZQ0JBSkFJQWRGRFFBZ0IwRURkaUlJUVFOMFFiQzBnSUFBYWlFQ1FRQW9BcHkwZ0lBQUlRUUNRQUpBSUFaQkFTQUlkQ0lJY1EwQVFRQWdCaUFJY2pZQ2lMU0FnQUFnQWlFSURBRUxJQUlvQWdnaENBc2dDQ0FFTmdJTUlBSWdCRFlDQ0NBRUlBSTJBZ3dnQkNBSU5nSUlDMEVBSUFBMkFweTBnSUFBUVFBZ0JUWUNrTFNBZ0FBTURBdEJBQ2dDakxTQWdBQWlDVVVOQVNBSlFRQWdDV3R4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1wQkFuUkJ1TGFBZ0FCcUtBSUFJZ0FvQWdSQmVIRWdBbXNoQkNBQUlRVUNRQU5BQWtBZ0JTZ0NFQ0lERFFBZ0JVRVVhaWdDQUNJRFJRMENDeUFES0FJRVFYaHhJQUpySWdVZ0JDQUZJQVJKSWdVYklRUWdBeUFBSUFVYklRQWdBeUVGREFBTEN5QUFLQUlZSVFvQ1FDQUFLQUlNSWdnZ0FFWU5BRUVBS0FLWXRJQ0FBQ0FBS0FJSUlnTkxHaUFJSUFNMkFnZ2dBeUFJTmdJTURBc0xBa0FnQUVFVWFpSUZLQUlBSWdNTkFDQUFLQUlRSWdORkRRTWdBRUVRYWlFRkN3TkFJQVVoQ3lBRElnaEJGR29pQlNnQ0FDSUREUUFnQ0VFUWFpRUZJQWdvQWhBaUF3MEFDeUFMUVFBMkFnQU1DZ3RCZnlFQ0lBQkJ2MzlMRFFBZ0FFRVRhaUlEUVhCeElRSkJBQ2dDakxTQWdBQWlCMFVOQUVFQUlRc0NRQ0FDUVlBQ1NRMEFRUjhoQ3lBQ1FmLy8vd2RMRFFBZ0EwRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBRElBUnlJQVZ5YXlJRFFRRjBJQUlnQTBFVmFuWkJBWEZ5UVJ4cUlRc0xRUUFnQW1zaEJBSkFBa0FDUUFKQUlBdEJBblJCdUxhQWdBQnFLQUlBSWdVTkFFRUFJUU5CQUNFSURBRUxRUUFoQXlBQ1FRQkJHU0FMUVFGMmF5QUxRUjlHRzNRaEFFRUFJUWdEUUFKQUlBVW9BZ1JCZUhFZ0Ftc2lCaUFFVHcwQUlBWWhCQ0FGSVFnZ0JnMEFRUUFoQkNBRklRZ2dCU0VEREFNTElBTWdCVUVVYWlnQ0FDSUdJQVlnQlNBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lGUmhzZ0F5QUdHeUVESUFCQkFYUWhBQ0FGRFFBTEN3SkFJQU1nQ0hJTkFFRUFJUWhCQWlBTGRDSURRUUFnQTJ0eUlBZHhJZ05GRFFNZ0EwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQlVFRmRrRUljU0lBSUFOeUlBVWdBSFlpQTBFQ2RrRUVjU0lGY2lBRElBVjJJZ05CQVhaQkFuRWlCWElnQXlBRmRpSURRUUYyUVFGeElnVnlJQU1nQlhacVFRSjBRYmkyZ0lBQWFpZ0NBQ0VEQ3lBRFJRMEJDd05BSUFNb0FnUkJlSEVnQW1zaUJpQUVTU0VBQWtBZ0F5Z0NFQ0lGRFFBZ0EwRVVhaWdDQUNFRkN5QUdJQVFnQUJzaEJDQURJQWdnQUJzaENDQUZJUU1nQlEwQUN3c2dDRVVOQUNBRVFRQW9BcEMwZ0lBQUlBSnJUdzBBSUFnb0FoZ2hDd0pBSUFnb0Fnd2lBQ0FJUmcwQVFRQW9BcGkwZ0lBQUlBZ29BZ2dpQTBzYUlBQWdBellDQ0NBRElBQTJBZ3dNQ1FzQ1FDQUlRUlJxSWdVb0FnQWlBdzBBSUFnb0FoQWlBMFVOQXlBSVFSQnFJUVVMQTBBZ0JTRUdJQU1pQUVFVWFpSUZLQUlBSWdNTkFDQUFRUkJxSVFVZ0FDZ0NFQ0lERFFBTElBWkJBRFlDQUF3SUN3SkFRUUFvQXBDMGdJQUFJZ01nQWtrTkFFRUFLQUtjdElDQUFDRUVBa0FDUUNBRElBSnJJZ1ZCRUVrTkFDQUVJQUpxSWdBZ0JVRUJjallDQkVFQUlBVTJBcEMwZ0lBQVFRQWdBRFlDbkxTQWdBQWdCQ0FEYWlBRk5nSUFJQVFnQWtFRGNqWUNCQXdCQ3lBRUlBTkJBM0kyQWdRZ0F5QUVha0VFYWlJRElBTW9BZ0JCQVhJMkFnQkJBRUVBTmdLY3RJQ0FBRUVBUVFBMkFwQzBnSUFBQ3lBRVFRaHFJUU1NQ2dzQ1FFRUFLQUtVdElDQUFDSUFJQUpORFFCQkFDZ0NvTFNBZ0FBaUF5QUNhaUlFSUFBZ0Ftc2lCVUVCY2pZQ0JFRUFJQVUyQXBTMGdJQUFRUUFnQkRZQ29MU0FnQUFnQXlBQ1FRTnlOZ0lFSUFOQkNHb2hBd3dLQ3dKQUFrQkJBQ2dDNExlQWdBQkZEUUJCQUNnQzZMZUFnQUFoQkF3QkMwRUFRbjgzQXV5M2dJQUFRUUJDZ0lDRWdJQ0F3QUEzQXVTM2dJQUFRUUFnQVVFTWFrRndjVUhZcXRXcUJYTTJBdUMzZ0lBQVFRQkJBRFlDOUxlQWdBQkJBRUVBTmdMRXQ0Q0FBRUdBZ0FRaEJBdEJBQ0VEQWtBZ0JDQUNRY2NBYWlJSGFpSUdRUUFnQkdzaUMzRWlDQ0FDU3cwQVFRQkJNRFlDK0xlQWdBQU1DZ3NDUUVFQUtBTEF0NENBQUNJRFJRMEFBa0JCQUNnQ3VMZUFnQUFpQkNBSWFpSUZJQVJORFFBZ0JTQURUUTBCQzBFQUlRTkJBRUV3TmdMNHQ0Q0FBQXdLQzBFQUxRREV0NENBQUVFRWNRMEVBa0FDUUFKQVFRQW9BcUMwZ0lBQUlnUkZEUUJCeUxlQWdBQWhBd05BQWtBZ0F5Z0NBQ0lGSUFSTERRQWdCU0FES0FJRWFpQUVTdzBEQ3lBREtBSUlJZ01OQUFzTFFRQVF2b0NBZ0FBaUFFRi9SZzBGSUFnaEJnSkFRUUFvQXVTM2dJQUFJZ05CZjJvaUJDQUFjVVVOQUNBSUlBQnJJQVFnQUdwQkFDQURhM0ZxSVFZTElBWWdBazBOQlNBR1FmNy8vLzhIU3cwRkFrQkJBQ2dDd0xlQWdBQWlBMFVOQUVFQUtBSzR0NENBQUNJRUlBWnFJZ1VnQkUwTkJpQUZJQU5MRFFZTElBWVF2b0NBZ0FBaUF5QUFSdzBCREFjTElBWWdBR3NnQzNFaUJrSCsvLy8vQjBzTkJDQUdFTDZBZ0lBQUlnQWdBeWdDQUNBREtBSUVha1lOQXlBQUlRTUxBa0FnQTBGL1JnMEFJQUpCeUFCcUlBWk5EUUFDUUNBSElBWnJRUUFvQXVpM2dJQUFJZ1JxUVFBZ0JHdHhJZ1JCL3YvLy93ZE5EUUFnQXlFQURBY0xBa0FnQkJDK2dJQ0FBRUYvUmcwQUlBUWdCbW9oQmlBRElRQU1Cd3RCQUNBR2F4QytnSUNBQUJvTUJBc2dBeUVBSUFOQmYwY05CUXdEQzBFQUlRZ01Cd3RCQUNFQURBVUxJQUJCZjBjTkFndEJBRUVBS0FMRXQ0Q0FBRUVFY2pZQ3hMZUFnQUFMSUFoQi92Ly8vd2RMRFFFZ0NCQytnSUNBQUNFQVFRQVF2b0NBZ0FBaEF5QUFRWDlHRFFFZ0EwRi9SZzBCSUFBZ0EwOE5BU0FESUFCcklnWWdBa0U0YWswTkFRdEJBRUVBS0FLNHQ0Q0FBQ0FHYWlJRE5nSzR0NENBQUFKQUlBTkJBQ2dDdkxlQWdBQk5EUUJCQUNBRE5nSzh0NENBQUFzQ1FBSkFBa0FDUUVFQUtBS2d0SUNBQUNJRVJRMEFRY2kzZ0lBQUlRTURRQ0FBSUFNb0FnQWlCU0FES0FJRUlnaHFSZzBDSUFNb0FnZ2lBdzBBREFNTEN3SkFBa0JCQUNnQ21MU0FnQUFpQTBVTkFDQUFJQU5QRFFFTFFRQWdBRFlDbUxTQWdBQUxRUUFoQTBFQUlBWTJBc3kzZ0lBQVFRQWdBRFlDeUxlQWdBQkJBRUYvTmdLb3RJQ0FBRUVBUVFBb0F1QzNnSUFBTmdLc3RJQ0FBRUVBUVFBMkF0UzNnSUFBQTBBZ0EwSEV0SUNBQUdvZ0EwRzR0SUNBQUdvaUJEWUNBQ0FFSUFOQnNMU0FnQUJxSWdVMkFnQWdBMEc4dElDQUFHb2dCVFlDQUNBRFFjeTBnSUFBYWlBRFFjQzBnSUFBYWlJRk5nSUFJQVVnQkRZQ0FDQURRZFMwZ0lBQWFpQURRY2kwZ0lBQWFpSUVOZ0lBSUFRZ0JUWUNBQ0FEUWRDMGdJQUFhaUFFTmdJQUlBTkJJR29pQTBHQUFrY05BQXNnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lCQ0FHSUFOclFVaHFJZ05CQVhJMkFnUkJBRUVBS0FMd3Q0Q0FBRFlDcExTQWdBQkJBQ0FFTmdLZ3RJQ0FBRUVBSUFNMkFwUzBnSUFBSUFZZ0FHcEJUR3BCT0RZQ0FBd0NDeUFETFFBTVFRaHhEUUFnQlNBRVN3MEFJQUFnQkUwTkFDQUVRWGdnQkd0QkQzRkJBQ0FFUVFocVFROXhHeUlGYWlJQVFRQW9BcFMwZ0lBQUlBWnFJZ3NnQldzaUJVRUJjallDQkNBRElBZ2dCbW8yQWdSQkFFRUFLQUx3dDRDQUFEWUNwTFNBZ0FCQkFDQUZOZ0tVdElDQUFFRUFJQUEyQXFDMGdJQUFJQXNnQkdwQkJHcEJPRFlDQUF3QkN3SkFJQUJCQUNnQ21MU0FnQUFpQzA4TkFFRUFJQUEyQXBpMGdJQUFJQUFoQ3dzZ0FDQUdhaUVJUWNpM2dJQUFJUU1DUUFKQUFrQUNRQUpBQWtBQ1FBTkFJQU1vQWdBZ0NFWU5BU0FES0FJSUlnTU5BQXdDQ3dzZ0F5MEFERUVJY1VVTkFRdEJ5TGVBZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlJRklBUkxEUU1MSUFNb0FnZ2hBd3dBQ3dzZ0F5QUFOZ0lBSUFNZ0F5Z0NCQ0FHYWpZQ0JDQUFRWGdnQUd0QkQzRkJBQ0FBUVFocVFROXhHMm9pQmlBQ1FRTnlOZ0lFSUFoQmVDQUlhMEVQY1VFQUlBaEJDR3BCRDNFYmFpSUlJQVlnQW1vaUFtc2hCUUpBSUFRZ0NFY05BRUVBSUFJMkFxQzBnSUFBUVFCQkFDZ0NsTFNBZ0FBZ0JXb2lBellDbExTQWdBQWdBaUFEUVFGeU5nSUVEQU1MQWtCQkFDZ0NuTFNBZ0FBZ0NFY05BRUVBSUFJMkFweTBnSUFBUVFCQkFDZ0NrTFNBZ0FBZ0JXb2lBellDa0xTQWdBQWdBaUFEUVFGeU5nSUVJQUlnQTJvZ0F6WUNBQXdEQ3dKQUlBZ29BZ1FpQTBFRGNVRUJSdzBBSUFOQmVIRWhCd0pBQWtBZ0EwSC9BVXNOQUNBSUtBSUlJZ1FnQTBFRGRpSUxRUU4wUWJDMGdJQUFhaUlBUmhvQ1FDQUlLQUlNSWdNZ0JFY05BRUVBUVFBb0FvaTBnSUFBUVg0Z0MzZHhOZ0tJdElDQUFBd0NDeUFESUFCR0dpQURJQVEyQWdnZ0JDQUROZ0lNREFFTElBZ29BaGdoQ1FKQUFrQWdDQ2dDRENJQUlBaEdEUUFnQ3lBSUtBSUlJZ05MR2lBQUlBTTJBZ2dnQXlBQU5nSU1EQUVMQWtBZ0NFRVVhaUlES0FJQUlnUU5BQ0FJUVJCcUlnTW9BZ0FpQkEwQVFRQWhBQXdCQ3dOQUlBTWhDeUFFSWdCQkZHb2lBeWdDQUNJRURRQWdBRUVRYWlFRElBQW9BaEFpQkEwQUN5QUxRUUEyQWdBTElBbEZEUUFDUUFKQUlBZ29BaHdpQkVFQ2RFRzR0b0NBQUdvaUF5Z0NBQ0FJUncwQUlBTWdBRFlDQUNBQURRRkJBRUVBS0FLTXRJQ0FBRUYrSUFSM2NUWUNqTFNBZ0FBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FJUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FKTmdJWUFrQWdDQ2dDRUNJRFJRMEFJQUFnQXpZQ0VDQURJQUEyQWhnTElBZ29BaFFpQTBVTkFDQUFRUlJxSUFNMkFnQWdBeUFBTmdJWUN5QUhJQVZxSVFVZ0NDQUhhaUVJQ3lBSUlBZ29BZ1JCZm5FMkFnUWdBaUFGYWlBRk5nSUFJQUlnQlVFQmNqWUNCQUpBSUFWQi93RkxEUUFnQlVFRGRpSUVRUU4wUWJDMGdJQUFhaUVEQWtBQ1FFRUFLQUtJdElDQUFDSUZRUUVnQkhRaUJIRU5BRUVBSUFVZ0JISTJBb2kwZ0lBQUlBTWhCQXdCQ3lBREtBSUlJUVFMSUFRZ0FqWUNEQ0FESUFJMkFnZ2dBaUFETmdJTUlBSWdCRFlDQ0F3REMwRWZJUU1DUUNBRlFmLy8vd2RMRFFBZ0JVRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBRElBUnlJQUJ5YXlJRFFRRjBJQVVnQTBFVmFuWkJBWEZ5UVJ4cUlRTUxJQUlnQXpZQ0hDQUNRZ0EzQWhBZ0EwRUNkRUc0dG9DQUFHb2hCQUpBUVFBb0FveTBnSUFBSWdCQkFTQURkQ0lJY1EwQUlBUWdBallDQUVFQUlBQWdDSEkyQW95MGdJQUFJQUlnQkRZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFNTElBVkJBRUVaSUFOQkFYWnJJQU5CSDBZYmRDRURJQVFvQWdBaEFBTkFJQUFpQkNnQ0JFRjRjU0FGUmcwQ0lBTkJIWFloQUNBRFFRRjBJUU1nQkNBQVFRUnhha0VRYWlJSUtBSUFJZ0FOQUFzZ0NDQUNOZ0lBSUFJZ0JEWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBSUxJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViSWdOcUlnc2dCaUFEYTBGSWFpSURRUUZ5TmdJRUlBaEJUR3BCT0RZQ0FDQUVJQVZCTnlBRmEwRVBjVUVBSUFWQlNXcEJEM0ViYWtGQmFpSUlJQWdnQkVFUWFra2JJZ2hCSXpZQ0JFRUFRUUFvQXZDM2dJQUFOZ0trdElDQUFFRUFJQXMyQXFDMGdJQUFRUUFnQXpZQ2xMU0FnQUFnQ0VFUWFrRUFLUUxRdDRDQUFEY0NBQ0FJUVFBcEFzaTNnSUFBTndJSVFRQWdDRUVJYWpZQzBMZUFnQUJCQUNBR05nTE10NENBQUVFQUlBQTJBc2kzZ0lBQVFRQkJBRFlDMUxlQWdBQWdDRUVrYWlFREEwQWdBMEVITmdJQUlBVWdBMEVFYWlJRFN3MEFDeUFJSUFSR0RRTWdDQ0FJS0FJRVFYNXhOZ0lFSUFnZ0NDQUVheUlHTmdJQUlBUWdCa0VCY2pZQ0JBSkFJQVpCL3dGTERRQWdCa0VEZGlJRlFRTjBRYkMwZ0lBQWFpRURBa0FDUUVFQUtBS0l0SUNBQUNJQVFRRWdCWFFpQlhFTkFFRUFJQUFnQlhJMkFvaTBnSUFBSUFNaEJRd0JDeUFES0FJSUlRVUxJQVVnQkRZQ0RDQURJQVEyQWdnZ0JDQUROZ0lNSUFRZ0JUWUNDQXdFQzBFZklRTUNRQ0FHUWYvLy93ZExEUUFnQmtFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUFJQUJCZ0lBUGFrRVFka0VDY1NJQWRFRVBkaUFESUFWeUlBQnlheUlEUVFGMElBWWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBUkNBRGNDRUNBRVFSeHFJQU0yQWdBZ0EwRUNkRUc0dG9DQUFHb2hCUUpBUVFBb0FveTBnSUFBSWdCQkFTQURkQ0lJY1EwQUlBVWdCRFlDQUVFQUlBQWdDSEkyQW95MGdJQUFJQVJCR0dvZ0JUWUNBQ0FFSUFRMkFnZ2dCQ0FFTmdJTURBUUxJQVpCQUVFWklBTkJBWFpySUFOQkgwWWJkQ0VESUFVb0FnQWhBQU5BSUFBaUJTZ0NCRUY0Y1NBR1JnMERJQU5CSFhZaEFDQURRUUYwSVFNZ0JTQUFRUVJ4YWtFUWFpSUlLQUlBSWdBTkFBc2dDQ0FFTmdJQUlBUkJHR29nQlRZQ0FDQUVJQVEyQWd3Z0JDQUVOZ0lJREFNTElBUW9BZ2dpQXlBQ05nSU1JQVFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUVOZ0lNSUFJZ0F6WUNDQXNnQmtFSWFpRUREQVVMSUFVb0FnZ2lBeUFFTmdJTUlBVWdCRFlDQ0NBRVFSaHFRUUEyQWdBZ0JDQUZOZ0lNSUFRZ0F6WUNDQXRCQUNnQ2xMU0FnQUFpQXlBQ1RRMEFRUUFvQXFDMGdJQUFJZ1FnQW1vaUJTQURJQUpySWdOQkFYSTJBZ1JCQUNBRE5nS1V0SUNBQUVFQUlBVTJBcUMwZ0lBQUlBUWdBa0VEY2pZQ0JDQUVRUWhxSVFNTUF3dEJBQ0VEUVFCQk1EWUMrTGVBZ0FBTUFnc0NRQ0FMUlEwQUFrQUNRQ0FJSUFnb0Fod2lCVUVDZEVHNHRvQ0FBR29pQXlnQ0FFY05BQ0FESUFBMkFnQWdBQTBCUVFBZ0IwRitJQVYzY1NJSE5nS010SUNBQUF3Q0N5QUxRUkJCRkNBTEtBSVFJQWhHRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQXMyQWhnQ1FDQUlLQUlRSWdORkRRQWdBQ0FETmdJUUlBTWdBRFlDR0FzZ0NFRVVhaWdDQUNJRFJRMEFJQUJCRkdvZ0F6WUNBQ0FESUFBMkFoZ0xBa0FDUUNBRVFROUxEUUFnQ0NBRUlBSnFJZ05CQTNJMkFnUWdBeUFJYWtFRWFpSURJQU1vQWdCQkFYSTJBZ0FNQVFzZ0NDQUNhaUlBSUFSQkFYSTJBZ1FnQ0NBQ1FRTnlOZ0lFSUFBZ0JHb2dCRFlDQUFKQUlBUkIvd0ZMRFFBZ0JFRURkaUlFUVFOMFFiQzBnSUFBYWlFREFrQUNRRUVBS0FLSXRJQ0FBQ0lGUVFFZ0JIUWlCSEVOQUVFQUlBVWdCSEkyQW9pMGdJQUFJQU1oQkF3QkN5QURLQUlJSVFRTElBUWdBRFlDRENBRElBQTJBZ2dnQUNBRE5nSU1JQUFnQkRZQ0NBd0JDMEVmSVFNQ1FDQUVRZi8vL3dkTERRQWdCRUVJZGlJRElBTkJnUDQvYWtFUWRrRUljU0lEZENJRklBVkJnT0FmYWtFUWRrRUVjU0lGZENJQ0lBSkJnSUFQYWtFUWRrRUNjU0lDZEVFUGRpQURJQVZ5SUFKeWF5SURRUUYwSUFRZ0EwRVZhblpCQVhGeVFSeHFJUU1MSUFBZ0F6WUNIQ0FBUWdBM0FoQWdBMEVDZEVHNHRvQ0FBR29oQlFKQUlBZEJBU0FEZENJQ2NRMEFJQVVnQURZQ0FFRUFJQWNnQW5JMkFveTBnSUFBSUFBZ0JUWUNHQ0FBSUFBMkFnZ2dBQ0FBTmdJTURBRUxJQVJCQUVFWklBTkJBWFpySUFOQkgwWWJkQ0VESUFVb0FnQWhBZ0pBQTBBZ0FpSUZLQUlFUVhoeElBUkdEUUVnQTBFZGRpRUNJQU5CQVhRaEF5QUZJQUpCQkhGcVFSQnFJZ1lvQWdBaUFnMEFDeUFHSUFBMkFnQWdBQ0FGTmdJWUlBQWdBRFlDRENBQUlBQTJBZ2dNQVFzZ0JTZ0NDQ0lESUFBMkFnd2dCU0FBTmdJSUlBQkJBRFlDR0NBQUlBVTJBZ3dnQUNBRE5nSUlDeUFJUVFocUlRTU1BUXNDUUNBS1JRMEFBa0FDUUNBQUlBQW9BaHdpQlVFQ2RFRzR0b0NBQUdvaUF5Z0NBRWNOQUNBRElBZzJBZ0FnQ0EwQlFRQWdDVUYrSUFWM2NUWUNqTFNBZ0FBTUFnc2dDa0VRUVJRZ0NpZ0NFQ0FBUmh0cUlBZzJBZ0FnQ0VVTkFRc2dDQ0FLTmdJWUFrQWdBQ2dDRUNJRFJRMEFJQWdnQXpZQ0VDQURJQWcyQWhnTElBQkJGR29vQWdBaUEwVU5BQ0FJUVJScUlBTTJBZ0FnQXlBSU5nSVlDd0pBQWtBZ0JFRVBTdzBBSUFBZ0JDQUNhaUlEUVFOeU5nSUVJQU1nQUdwQkJHb2lBeUFES0FJQVFRRnlOZ0lBREFFTElBQWdBbW9pQlNBRVFRRnlOZ0lFSUFBZ0FrRURjallDQkNBRklBUnFJQVEyQWdBQ1FDQUhSUTBBSUFkQkEzWWlDRUVEZEVHd3RJQ0FBR29oQWtFQUtBS2N0SUNBQUNFREFrQUNRRUVCSUFoMElnZ2dCbkVOQUVFQUlBZ2dCbkkyQW9pMGdJQUFJQUloQ0F3QkN5QUNLQUlJSVFnTElBZ2dBellDRENBQ0lBTTJBZ2dnQXlBQ05nSU1JQU1nQ0RZQ0NBdEJBQ0FGTmdLY3RJQ0FBRUVBSUFRMkFwQzBnSUFBQ3lBQVFRaHFJUU1MSUFGQkVHb2tnSUNBZ0FBZ0F3c0tBQ0FBRUwyQWdJQUFDL0FOQVFkL0FrQWdBRVVOQUNBQVFYaHFJZ0VnQUVGOGFpZ0NBQ0lDUVhoeElnQnFJUU1DUUNBQ1FRRnhEUUFnQWtFRGNVVU5BU0FCSUFFb0FnQWlBbXNpQVVFQUtBS1l0SUNBQUNJRVNRMEJJQUlnQUdvaEFBSkFRUUFvQXB5MGdJQUFJQUZHRFFBQ1FDQUNRZjhCU3cwQUlBRW9BZ2dpQkNBQ1FRTjJJZ1ZCQTNSQnNMU0FnQUJxSWdaR0dnSkFJQUVvQWd3aUFpQUVSdzBBUVFCQkFDZ0NpTFNBZ0FCQmZpQUZkM0UyQW9pMGdJQUFEQU1MSUFJZ0JrWWFJQUlnQkRZQ0NDQUVJQUkyQWd3TUFnc2dBU2dDR0NFSEFrQUNRQ0FCS0FJTUlnWWdBVVlOQUNBRUlBRW9BZ2dpQWtzYUlBWWdBallDQ0NBQ0lBWTJBZ3dNQVFzQ1FDQUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2lBaWdDQUNJRURRQkJBQ0VHREFFTEEwQWdBaUVGSUFRaUJrRVVhaUlDS0FJQUlnUU5BQ0FHUVJCcUlRSWdCaWdDRUNJRURRQUxJQVZCQURZQ0FBc2dCMFVOQVFKQUFrQWdBU2dDSENJRVFRSjBRYmkyZ0lBQWFpSUNLQUlBSUFGSERRQWdBaUFHTmdJQUlBWU5BVUVBUVFBb0FveTBnSUFBUVg0Z0JIZHhOZ0tNdElDQUFBd0RDeUFIUVJCQkZDQUhLQUlRSUFGR0cyb2dCallDQUNBR1JRMENDeUFHSUFjMkFoZ0NRQ0FCS0FJUUlnSkZEUUFnQmlBQ05nSVFJQUlnQmpZQ0dBc2dBU2dDRkNJQ1JRMEJJQVpCRkdvZ0FqWUNBQ0FDSUFZMkFoZ01BUXNnQXlnQ0JDSUNRUU54UVFOSERRQWdBeUFDUVg1eE5nSUVRUUFnQURZQ2tMU0FnQUFnQVNBQWFpQUFOZ0lBSUFFZ0FFRUJjallDQkE4TElBTWdBVTBOQUNBREtBSUVJZ0pCQVhGRkRRQUNRQUpBSUFKQkFuRU5BQUpBUVFBb0FxQzBnSUFBSUFOSERRQkJBQ0FCTmdLZ3RJQ0FBRUVBUVFBb0FwUzBnSUFBSUFCcUlnQTJBcFMwZ0lBQUlBRWdBRUVCY2pZQ0JDQUJRUUFvQXB5MGdJQUFSdzBEUVFCQkFEWUNrTFNBZ0FCQkFFRUFOZ0tjdElDQUFBOExBa0JCQUNnQ25MU0FnQUFnQTBjTkFFRUFJQUUyQXB5MGdJQUFRUUJCQUNnQ2tMU0FnQUFnQUdvaUFEWUNrTFNBZ0FBZ0FTQUFRUUZ5TmdJRUlBRWdBR29nQURZQ0FBOExJQUpCZUhFZ0FHb2hBQUpBQWtBZ0FrSC9BVXNOQUNBREtBSUlJZ1FnQWtFRGRpSUZRUU4wUWJDMGdJQUFhaUlHUmhvQ1FDQURLQUlNSWdJZ0JFY05BRUVBUVFBb0FvaTBnSUFBUVg0Z0JYZHhOZ0tJdElDQUFBd0NDeUFDSUFaR0dpQUNJQVEyQWdnZ0JDQUNOZ0lNREFFTElBTW9BaGdoQndKQUFrQWdBeWdDRENJR0lBTkdEUUJCQUNnQ21MU0FnQUFnQXlnQ0NDSUNTeG9nQmlBQ05nSUlJQUlnQmpZQ0RBd0JDd0pBSUFOQkZHb2lBaWdDQUNJRURRQWdBMEVRYWlJQ0tBSUFJZ1FOQUVFQUlRWU1BUXNEUUNBQ0lRVWdCQ0lHUVJScUlnSW9BZ0FpQkEwQUlBWkJFR29oQWlBR0tBSVFJZ1FOQUFzZ0JVRUFOZ0lBQ3lBSFJRMEFBa0FDUUNBREtBSWNJZ1JCQW5SQnVMYUFnQUJxSWdJb0FnQWdBMGNOQUNBQ0lBWTJBZ0FnQmcwQlFRQkJBQ2dDakxTQWdBQkJmaUFFZDNFMkFveTBnSUFBREFJTElBZEJFRUVVSUFjb0FoQWdBMFliYWlBR05nSUFJQVpGRFFFTElBWWdCellDR0FKQUlBTW9BaEFpQWtVTkFDQUdJQUkyQWhBZ0FpQUdOZ0lZQ3lBREtBSVVJZ0pGRFFBZ0JrRVVhaUFDTmdJQUlBSWdCallDR0FzZ0FTQUFhaUFBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRUUFvQXB5MGdJQUFSdzBCUVFBZ0FEWUNrTFNBZ0FBUEN5QURJQUpCZm5FMkFnUWdBU0FBYWlBQU5nSUFJQUVnQUVFQmNqWUNCQXNDUUNBQVFmOEJTdzBBSUFCQkEzWWlBa0VEZEVHd3RJQ0FBR29oQUFKQUFrQkJBQ2dDaUxTQWdBQWlCRUVCSUFKMElnSnhEUUJCQUNBRUlBSnlOZ0tJdElDQUFDQUFJUUlNQVFzZ0FDZ0NDQ0VDQ3lBQ0lBRTJBZ3dnQUNBQk5nSUlJQUVnQURZQ0RDQUJJQUkyQWdnUEMwRWZJUUlDUUNBQVFmLy8vd2RMRFFBZ0FFRUlkaUlDSUFKQmdQNC9ha0VRZGtFSWNTSUNkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lHSUFaQmdJQVBha0VRZGtFQ2NTSUdkRUVQZGlBQ0lBUnlJQVp5YXlJQ1FRRjBJQUFnQWtFVmFuWkJBWEZ5UVJ4cUlRSUxJQUZDQURjQ0VDQUJRUnhxSUFJMkFnQWdBa0VDZEVHNHRvQ0FBR29oQkFKQUFrQkJBQ2dDakxTQWdBQWlCa0VCSUFKMElnTnhEUUFnQkNBQk5nSUFRUUFnQmlBRGNqWUNqTFNBZ0FBZ0FVRVlhaUFFTmdJQUlBRWdBVFlDQ0NBQklBRTJBZ3dNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdCQ2dDQUNFR0FrQURRQ0FHSWdRb0FnUkJlSEVnQUVZTkFTQUNRUjEySVFZZ0FrRUJkQ0VDSUFRZ0JrRUVjV3BCRUdvaUF5Z0NBQ0lHRFFBTElBTWdBVFlDQUNBQlFSaHFJQVEyQWdBZ0FTQUJOZ0lNSUFFZ0FUWUNDQXdCQ3lBRUtBSUlJZ0FnQVRZQ0RDQUVJQUUyQWdnZ0FVRVlha0VBTmdJQUlBRWdCRFlDRENBQklBQTJBZ2dMUVFCQkFDZ0NxTFNBZ0FCQmYyb2lBVUYvSUFFYk5nS290SUNBQUFzTFRnQUNRQ0FBRFFBL0FFRVFkQThMQWtBZ0FFSC8vd054RFFBZ0FFRi9UQTBBQWtBZ0FFRVFka0FBSWdCQmYwY05BRUVBUVRBMkF2aTNnSUFBUVg4UEN5QUFRUkIwRHdzUXY0Q0FnQUFBQ3dRQUFBQUxDNDRzQVFCQmdBZ0xoaXdCQUFBQUFnQUFBQU1BQUFBRUFBQUFCUUFBQUFZQUFBQUhBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVsdWRtRnNhV1FnWTJoaGNpQnBiaUIxY213Z2NYVmxjbmtBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlpYjJSNUFFTnZiblJsYm5RdFRHVnVaM1JvSUc5MlpYSm1iRzkzQUVOb2RXNXJJSE5wZW1VZ2IzWmxjbVpzYjNjQVVtVnpjRzl1YzJVZ2IzWmxjbVpzYjNjQVNXNTJZV3hwWkNCdFpYUm9iMlFnWm05eUlFaFVWRkF2ZUM1NElISmxjWFZsYzNRQVNXNTJZV3hwWkNCdFpYUm9iMlFnWm05eUlGSlVVMUF2ZUM1NElISmxjWFZsYzNRQVJYaHdaV04wWldRZ1UwOVZVa05GSUcxbGRHaHZaQ0JtYjNJZ1NVTkZMM2d1ZUNCeVpYRjFaWE4wQUVsdWRtRnNhV1FnWTJoaGNpQnBiaUIxY213Z1puSmhaMjFsYm5RZ2MzUmhjblFBUlhod1pXTjBaV1FnWkc5MEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmMzUmhkSFZ6QUVsdWRtRnNhV1FnY21WemNHOXVjMlVnYzNSaGRIVnpBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSEJoY21GdFpYUmxjbk1BVlhObGNpQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZmFHVmhaR1Z5WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVnpjMkZuWlY5aVpXZHBibUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFWVzVsZUhCbFkzUmxaQ0JqYUdGeUlHbHVJSFZ5YkNCelpYSjJaWElBU1c1MllXeHBaQ0JvWldGa1pYSWdkbUZzZFdVZ1kyaGhjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQm1hV1ZzWkNCamFHRnlBRWx1ZG1Gc2FXUWdiV2x1YjNJZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUcxaGFtOXlJSFpsY25OcGIyNEFSWGh3WldOMFpXUWdjM0JoWTJVZ1lXWjBaWElnZG1WeWMybHZiZ0JGZUhCbFkzUmxaQ0JEVWt4R0lHRm1kR1Z5SUhabGNuTnBiMjRBU1c1MllXeHBaQ0JvWldGa1pYSWdkRzlyWlc0QVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MWNtd0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSnpJR2x1SUhWeWJBQlZibVY0Y0dWamRHVmtJSE4wWVhKMElHTm9ZWElnYVc0Z2RYSnNBRVJ2ZFdKc1pTQkFJR2x1SUhWeWJBQkZiWEIwZVNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCRGIyNTBaVzUwTFV4bGJtZDBhQUJFZFhCc2FXTmhkR1VnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J3WVhSb0FFTnZiblJsYm5RdFRHVnVaM1JvSUdOaGJpZDBJR0psSUhCeVpYTmxiblFnZDJsMGFDQlVjbUZ1YzJabGNpMUZibU52WkdsdVp3QkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QnphWHBsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYUdWaFpHVnlYM1poYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1ExSWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdURVlnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUVsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUNCb1pXRmtaWElnZG1Gc2RXVUFVR0YxYzJWa0lHSjVJRzl1WDJobFlXUmxjbk5mWTI5dGNHeGxkR1VBU1c1MllXeHBaQ0JGVDBZZ2MzUmhkR1VBYjI1ZlkyaDFibXRmYUdWaFpHVnlJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZbVZuYVc0Z2NHRjFjMlVBYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaU0J3WVhWelpRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVRVdEJRMVJKVmtsVVdRQkRUMUJaQUU1UFZFbEdXUUJRVEVGWkFGQlZWQUJEU0VWRFMwOVZWQUJRVDFOVUFGSkZVRTlTVkFCSVVFVmZTVTVXUVV4SlJGOURUMDVUVkVGT1ZBQkhSVlFBU0ZCRlgxTlVVa2xEVkFCU1JVUkpVa1ZEVkFCRFQwNU9SVU5VQUVoUVJWOUpUbFpCVEVsRVgxTlVRVlJWVXdCUFVGUkpUMDVUQUZORlZGOVFRVkpCVFVWVVJWSUFSMFZVWDFCQlVrRk5SVlJGVWdCSVVFVmZWVk5GVWdCSVVFVmZRMEpmUTBoVlRrdGZTRVZCUkVWU0FFMUxRMEZNUlU1RVFWSUFVMFZVVlZBQVZFVkJVa1JQVjA0QVNGQkZYME5NVDFORlJGOURUMDVPUlVOVVNVOU9BRWhRUlY5SlRsWkJURWxFWDFaRlVsTkpUMDRBU0ZCRlgwTkNYMDFGVTFOQlIwVmZRa1ZIU1U0QVNGQkZYMGxPVmtGTVNVUmZTRVZCUkVWU1gxUlBTMFZPQUVoUVJWOUpUbFpCVEVsRVgxVlNUQUJOUzBOUFRBQkJRMHdBU0ZCRlgwbE9WRVZTVGtGTUFFaFFSVjlQU3dCVlRreEpUa3NBVlU1TVQwTkxBRkJTU1FCSVVFVmZTVTVXUVV4SlJGOURUMDVVUlU1VVgweEZUa2RVU0FCSVVFVmZWVTVGV0ZCRlExUkZSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQkdURlZUU0FCUVVrOVFVRUZVUTBnQVRTMVRSVUZTUTBnQVNGQkZYMGxPVmtGTVNVUmZWRkpCVGxOR1JWSmZSVTVEVDBSSlRrY0FSWGh3WldOMFpXUWdRMUpNUmdCSVVFVmZTVTVXUVV4SlJGOURTRlZPUzE5VFNWcEZBRTFQVmtVQVNGQkZYME5DWDBoRlFVUkZVbE5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWTlRRVWRGWDBOUFRWQk1SVlJGQUVSRlRFVlVSUUJJVUVWZlNVNVdRVXhKUkY5RlQwWmZVMVJCVkVVQVVFRlZVMFVBVUZWU1IwVUFUVVZTUjBVQVNGQkZYMUJCVlZORlJGOVZVRWRTUVVSRkFFaFFSVjlRUVZWVFJVUmZTREpmVlZCSFVrRkVSUUJUVDFWU1EwVUFRVTVPVDFWT1EwVUFWRkpCUTBVQVJFVlRRMUpKUWtVQVZVNVRWVUpUUTFKSlFrVUFVa1ZEVDFKRUFFaFFSVjlKVGxaQlRFbEVYMDFGVkVoUFJBQlFVazlRUmtsT1JBQlZUa0pKVGtRQVVrVkNTVTVFQUVoUVJWOURVbDlGV0ZCRlExUkZSQUJJVUVWZlRFWmZSVmhRUlVOVVJVUUFTRkJGWDFCQlZWTkZSQUJJUlVGRUFFVjRjR1ZqZEdWa0lFaFVWRkF2QU53TEFBRFBDd0FBMHdvQUFKa05BQUFRREFBQVhRc0FBRjhOQUFDMUN3QUF1Z29BQUhNTEFBQ2NDd0FBOVFzQUFITU1BQUR2Q2dBQTNBd0FBRWNNQUFDSEN3QUFqd3dBQUwwTUFBQXZDd0FBcHd3QUFLa05BQUFFRFFBQUZ3MEFBQ1lMQUFDSkRRQUExUXdBQU04S0FBQzBEUUFBcmdvQUFLRUtBQURuQ2dBQUFnc0FBRDBOQUFDUUNnQUE3QXNBQU1VTEFBQ0tEQUFBY2cwQUFEUU1BQUJBREFBQTZnc0FBSVFOQUFDQ0RRQUFldzBBQU1zTEFBQ3pDZ0FBaFFvQUFLVUtBQUQrREFBQVBnd0FBSlVLQUFCT0RRQUFUQTBBQURnTUFBRDREQUFBUXdzQUFPVUxBQURqQ3dBQUxRMEFBUEVMQUFCRERRQUFOQTBBQUU0TEFBQ2NDZ0FBOGd3QUFGUUxBQUFZQ3dBQUNnc0FBTjRLQUFCWURRQUFMZ3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFXeHZjMlZsWlhBdFlXeHBkbVVBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRRUJBUUVCQVFFQkFRRUNBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVdOb2RXNXJaV1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBQUVCQVFFQkFBQUJBUUFCQVFBQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVpXTjBhVzl1Wlc1MExXeGxibWQwYUc5dWNtOTRlUzFqYjI1dVpXTjBhVzl1QUFBQUFBQUFBQUFBQUFBQUFBQUFjbUZ1YzJabGNpMWxibU52WkdsdVozQm5jbUZrWlEwS0RRb05DbE5ORFFvTkNsUlVVQzlEUlM5VVUxQXZBQUFBQUFBQUFBQUFBQUFBQVFJQUFRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUNBQUVEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFFQkJRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBQUFCQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFBRUFBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQkFBQUJBUUVCQVFFQkFRRUJBUUZCQVFFQkFRRUJBUUVCQVFFQUFRQUJnY0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBQUFBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFUazlWVGtORlJVTkxUMVZVVGtWRFZFVlVSVU5TU1VKRlRGVlRTRVZVUlVGRVUwVkJVa05JVWtkRlExUkpWa2xVV1V4RlRrUkJVbFpGVDFSSlJsbFFWRWxQVGxORFNGTkZRVmxUVkVGVVEwaEhSVTlTUkVsU1JVTlVUMUpVVWtOSVVFRlNRVTFGVkVWU1ZWSkRSVUpUUTFKSlFrVkJVa1JQVjA1QlEwVkpUa1JPUzBOTFZVSlRRMUpKUWtWSVZGUlFMMEZFVkZBdlwiO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2xpZW50LmpzXG52YXIgcmVxdWlyZV9jbGllbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jbGllbnQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIG5ldDIgPSByZXF1aXJlKFwibmV0XCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgUmVxdWVzdCA9IHJlcXVpcmVfcmVxdWVzdCgpO1xuICAgIHZhciBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmVfZGlzcGF0Y2hlcl9iYXNlKCk7XG4gICAgdmFyIFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmVfcmVkaXJlY3QoKTtcbiAgICB2YXIge1xuICAgICAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICAgICAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgICAgIEludmFsaWRBcmd1bWVudEVycm9yLFxuICAgICAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgICAgIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gICAgICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgICAgIFNvY2tldEVycm9yLFxuICAgICAgSW5mb3JtYXRpb25hbEVycm9yLFxuICAgICAgQm9keVRpbWVvdXRFcnJvcixcbiAgICAgIEhUVFBQYXJzZXJFcnJvclxuICAgIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBidWlsZENvbm5lY3RvciA9IHJlcXVpcmVfY29ubmVjdCgpO1xuICAgIHZhciB7XG4gICAgICBrVXJsLFxuICAgICAga1Jlc2V0LFxuICAgICAga1NlcnZlck5hbWUsXG4gICAgICBrQ2xpZW50LFxuICAgICAga0J1c3ksXG4gICAgICBrUGFyc2VyLFxuICAgICAga0Nvbm5lY3QsXG4gICAgICBrQmxvY2tpbmcsXG4gICAgICBrUmVzdW1pbmcsXG4gICAgICBrUnVubmluZyxcbiAgICAgIGtQZW5kaW5nLFxuICAgICAga1NpemUsXG4gICAgICBrV3JpdGluZyxcbiAgICAgIGtRdWV1ZSxcbiAgICAgIGtDb25uZWN0ZWQsXG4gICAgICBrQ29ubmVjdGluZyxcbiAgICAgIGtOZWVkRHJhaW4sXG4gICAgICBrTm9SZWYsXG4gICAgICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQsXG4gICAgICBrSG9zdEhlYWRlcixcbiAgICAgIGtQZW5kaW5nSWR4LFxuICAgICAga1J1bm5pbmdJZHgsXG4gICAgICBrRXJyb3IsXG4gICAgICBrUGlwZWxpbmluZyxcbiAgICAgIGtTb2NrZXQsXG4gICAgICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICAgICAga01heEhlYWRlcnNTaXplLFxuICAgICAga0tlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAgICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICAgIGtIZWFkZXJzVGltZW91dCxcbiAgICAgIGtCb2R5VGltZW91dCxcbiAgICAgIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICAgICAga0Nvbm5lY3RvcixcbiAgICAgIGtNYXhSZWRpcmVjdGlvbnMsXG4gICAgICBrTWF4UmVxdWVzdHMsXG4gICAgICBrQ291bnRlcixcbiAgICAgIGtDbG9zZSxcbiAgICAgIGtEZXN0cm95LFxuICAgICAga0Rpc3BhdGNoXG4gICAgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbChcImtDbG9zZWRSZXNvbHZlXCIpO1xuICAgIHZhciBjaGFubmVscyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKFwiZGlhZ25vc3RpY3NfY2hhbm5lbFwiKTtcbiAgICAgIGNoYW5uZWxzLnNlbmRIZWFkZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzXCIpO1xuICAgICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0XCIpO1xuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvclwiKTtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZCA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpjb25uZWN0ZWRcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH07XG4gICAgICBjaGFubmVscy5jb25uZWN0RXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9O1xuICAgICAgY2hhbm5lbHMuY29ubmVjdGVkID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfTtcbiAgICB9XG4gICAgdmFyIENsaWVudCA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAgICAgY29uc3RydWN0b3IodXJsLCB7XG4gICAgICAgIG1heEhlYWRlclNpemUsXG4gICAgICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgICAgICBzb2NrZXRUaW1lb3V0LFxuICAgICAgICByZXF1ZXN0VGltZW91dCxcbiAgICAgICAgY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIGJvZHlUaW1lb3V0LFxuICAgICAgICBpZGxlVGltZW91dCxcbiAgICAgICAga2VlcEFsaXZlLFxuICAgICAgICBrZWVwQWxpdmVUaW1lb3V0LFxuICAgICAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgICAgICBrZWVwQWxpdmVNYXhUaW1lb3V0LFxuICAgICAgICBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICBwaXBlbGluaW5nLFxuICAgICAgICB0bHMsXG4gICAgICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnMsXG4gICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QyLFxuICAgICAgICBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChrZWVwQWxpdmUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXRUaW1lb3V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBzb2NrZXRUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcmVxdWVzdFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkbGVUaW1lb3V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4S2VlcEFsaXZlVGltZW91dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbWF4S2VlcEFsaXZlVGltZW91dCwgdXNlIGtlZXBBbGl2ZU1heFRpbWVvdXQgaW5zdGVhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1heEhlYWRlclNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldFBhdGggIT0gbnVsbCAmJiB0eXBlb2Ygc29ja2V0UGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgc29ja2V0UGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShjb25uZWN0VGltZW91dCkgfHwgY29ubmVjdFRpbWVvdXQgPCAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY29ubmVjdFRpbWVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0KSB8fCBrZWVwQWxpdmVUaW1lb3V0IDw9IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZWVwQWxpdmVUaW1lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQga2VlcEFsaXZlTWF4VGltZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaGVhZGVyc1RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0MiAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0MiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25uZWN0MiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImNvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4UmVxdWVzdHNQZXJDbGllbnQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVxdWVzdHNQZXJDbGllbnQpIHx8IG1heFJlcXVlc3RzUGVyQ2xpZW50IDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29ubmVjdDIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbm5lY3QyID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4udGxzLFxuICAgICAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgICAgICAuLi5jb25uZWN0MlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba1VybF0gPSB1dGlsMi5wYXJzZU9yaWdpbih1cmwpO1xuICAgICAgICB0aGlzW2tDb25uZWN0b3JdID0gY29ubmVjdDI7XG4gICAgICAgIHRoaXNba1NvY2tldF0gPSBudWxsO1xuICAgICAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHBpcGVsaW5pbmcgIT0gbnVsbCA/IHBpcGVsaW5pbmcgOiAxO1xuICAgICAgICB0aGlzW2tNYXhIZWFkZXJzU2l6ZV0gPSBtYXhIZWFkZXJTaXplIHx8IDE2Mzg0O1xuICAgICAgICB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF0gPSBrZWVwQWxpdmVUaW1lb3V0ID09IG51bGwgPyA0ZTMgOiBrZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgICB0aGlzW2tLZWVwQWxpdmVNYXhUaW1lb3V0XSA9IGtlZXBBbGl2ZU1heFRpbWVvdXQgPT0gbnVsbCA/IDZlNSA6IGtlZXBBbGl2ZU1heFRpbWVvdXQ7XG4gICAgICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRdID0ga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCA9PSBudWxsID8gMWUzIDoga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDtcbiAgICAgICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XTtcbiAgICAgICAgdGhpc1trU2VydmVyTmFtZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tSZXN1bWluZ10gPSAwO1xuICAgICAgICB0aGlzW2tOZWVkRHJhaW5dID0gMDtcbiAgICAgICAgdGhpc1trSG9zdEhlYWRlcl0gPSBgaG9zdDogJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogXCJcIn1cXHJcbmA7XG4gICAgICAgIHRoaXNba0JvZHlUaW1lb3V0XSA9IGJvZHlUaW1lb3V0ICE9IG51bGwgPyBib2R5VGltZW91dCA6IDNlNDtcbiAgICAgICAgdGhpc1trSGVhZGVyc1RpbWVvdXRdID0gaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCA/IGhlYWRlcnNUaW1lb3V0IDogM2U0O1xuICAgICAgICB0aGlzW2tTdHJpY3RDb250ZW50TGVuZ3RoXSA9IHN0cmljdENvbnRlbnRMZW5ndGggPT0gbnVsbCA/IHRydWUgOiBzdHJpY3RDb250ZW50TGVuZ3RoO1xuICAgICAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zO1xuICAgICAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudDtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tRdWV1ZV0gPSBbXTtcbiAgICAgICAgdGhpc1trUnVubmluZ0lkeF0gPSAwO1xuICAgICAgICB0aGlzW2tQZW5kaW5nSWR4XSA9IDA7XG4gICAgICB9XG4gICAgICBnZXQgcGlwZWxpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddO1xuICAgICAgfVxuICAgICAgc2V0IHBpcGVsaW5pbmcodmFsdWUpIHtcbiAgICAgICAgdGhpc1trUGlwZWxpbmluZ10gPSB2YWx1ZTtcbiAgICAgICAgcmVzdW1lKHRoaXMsIHRydWUpO1xuICAgICAgfVxuICAgICAgZ2V0IFtrUGVuZGluZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF07XG4gICAgICB9XG4gICAgICBnZXQgW2tSdW5uaW5nXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1BlbmRpbmdJZHhdIC0gdGhpc1trUnVubmluZ0lkeF07XG4gICAgICB9XG4gICAgICBnZXQgW2tTaXplXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tSdW5uaW5nSWR4XTtcbiAgICAgIH1cbiAgICAgIGdldCBba0Nvbm5lY3RlZF0oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXNba1NvY2tldF0gJiYgIXRoaXNba0Nvbm5lY3RpbmddICYmICF0aGlzW2tTb2NrZXRdLmRlc3Ryb3llZDtcbiAgICAgIH1cbiAgICAgIGdldCBba0J1c3ldKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzW2tTb2NrZXRdO1xuICAgICAgICByZXR1cm4gc29ja2V0ICYmIChzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldFtrQmxvY2tpbmddKSB8fCB0aGlzW2tTaXplXSA+PSAodGhpc1trUGlwZWxpbmluZ10gfHwgMSkgfHwgdGhpc1trUGVuZGluZ10gPiAwO1xuICAgICAgfVxuICAgICAgW2tDb25uZWN0XShjYikge1xuICAgICAgICBjb25uZWN0KHRoaXMpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0XCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIFtrRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdIH0gPSBvcHRzO1xuICAgICAgICBpZiAobWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICAgICAgaGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIodGhpcywgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW4gPSBvcHRzLm9yaWdpbiB8fCB0aGlzW2tVcmxdLm9yaWdpbjtcbiAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBuZXcgUmVxdWVzdChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzW2tRdWV1ZV0ucHVzaChyZXF1ZXN0Mik7XG4gICAgICAgIGlmICh0aGlzW2tSZXN1bWluZ10pIHtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsMi5ib2R5TGVuZ3RoKHJlcXVlc3QyLmJvZHkpID09IG51bGwgJiYgdXRpbDIuaXNJdGVyYWJsZShyZXF1ZXN0Mi5ib2R5KSkge1xuICAgICAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDE7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VtZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgICAgICB0aGlzW2tOZWVkRHJhaW5dID0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXSA8IDI7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Nsb3NlXSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzW2tTaXplXSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KHJlc29sdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrRGVzdHJveV0oZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpc1trUXVldWVdLnNwbGljZSh0aGlzW2tQZW5kaW5nSWR4XSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdDIgPSByZXF1ZXN0c1tpXTtcbiAgICAgICAgICAgIGVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0MiwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tDbG9zZWRSZXNvbHZlXSkge1xuICAgICAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSgpO1xuICAgICAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgXCJjYWxsYmFja1wiKTtcbiAgICAgICAgICBpZiAoIXRoaXNba1NvY2tldF0pIHtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveSh0aGlzW2tTb2NrZXRdLm9uKFwiY2xvc2VcIiwgY2FsbGJhY2spLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bWUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKENsaWVudCwgXCJDbGllbnRcIik7XG4gICAgdmFyIGNvbnN0YW50cyA9IHJlcXVpcmVfY29uc3RhbnRzMigpO1xuICAgIHZhciBFTVBUWV9CVUYgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gbGF6eWxsaHR0cCgpIHtcbiAgICAgIGNvbnN0IGxsaHR0cFdhc21EYXRhID0gcHJvY2Vzcy5lbnYuSkVTVF9XT1JLRVJfSUQgPyByZXF1aXJlX2xsaHR0cF93YXNtKCkgOiB2b2lkIDA7XG4gICAgICBsZXQgbW9kMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vZDIgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKEJ1ZmZlci5mcm9tKHJlcXVpcmVfbGxodHRwX3NpbWRfd2FzbSgpLCBcImJhc2U2NFwiKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG1vZDIgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKEJ1ZmZlci5mcm9tKGxsaHR0cFdhc21EYXRhIHx8IHJlcXVpcmVfbGxodHRwX3dhc20oKSwgXCJiYXNlNjRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZDIsIHtcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgd2FzbV9vbl91cmw6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vblN0YXR1cyhjdXJyZW50QnVmZmVyUmVmLnNsaWNlKHN0YXJ0LCBlbmQpKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FzbV9vbl9tZXNzYWdlX2JlZ2luOiAocCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUJlZ2luKCkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25faGVhZGVyX2ZpZWxkOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKGN1cnJlbnRCdWZmZXJSZWYuc2xpY2Uoc3RhcnQsIGVuZCkpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXNtX29uX2hlYWRlcl92YWx1ZTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0cjtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJWYWx1ZShjdXJyZW50QnVmZmVyUmVmLnNsaWNlKHN0YXJ0LCBlbmQpKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgQm9vbGVhbih1cGdyYWRlKSwgQm9vbGVhbihzaG91bGRLZWVwQWxpdmUpKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkJvZHkoY3VycmVudEJ1ZmZlclJlZi5zbGljZShzdGFydCwgZW5kKSkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZTogKHApID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcCk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpIHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGxhenlsbGh0dHAsIFwibGF6eWxsaHR0cFwiKTtcbiAgICB2YXIgbGxodHRwSW5zdGFuY2UgPSBudWxsO1xuICAgIHZhciBsbGh0dHBQcm9taXNlID0gbGF6eWxsaHR0cCgpLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICB2YXIgY3VycmVudFBhcnNlciA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QnVmZmVyU2l6ZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRCdWZmZXJQdHIgPSBudWxsO1xuICAgIHZhciBUSU1FT1VUX0hFQURFUlMgPSAxO1xuICAgIHZhciBUSU1FT1VUX0JPRFkgPSAyO1xuICAgIHZhciBUSU1FT1VUX0lETEUgPSAzO1xuICAgIHZhciBQYXJzZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHNvY2tldCwgeyBleHBvcnRzOiBleHBvcnRzMiB9KSB7XG4gICAgICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0pICYmIGNsaWVudFtrTWF4SGVhZGVyc1NpemVdID4gMCk7XG4gICAgICAgIHRoaXMubGxodHRwID0gZXhwb3J0czI7XG4gICAgICAgIHRoaXMucHRyID0gdGhpcy5sbGh0dHAubGxodHRwX2FsbG9jKGNvbnN0YW50cy5UWVBFLlJFU1BPTlNFKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnVwZ3JhZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gW107XG4gICAgICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwO1xuICAgICAgICB0aGlzLmhlYWRlcnNNYXhTaXplID0gY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV07XG4gICAgICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzdW1lID0gdGhpcy5yZXN1bWUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IFwiXCI7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHRoaXMudGltZW91dFR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGltZW91dFZhbHVlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uUGFyc2VyVGltZW91dCwgdmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dC51bnJlZikge1xuICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5kZXN0cm95ZWQgfHwgIXRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKTtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbCk7XG4gICAgICAgIHRoaXMubGxodHRwLmxsaHR0cF9yZXN1bWUodGhpcy5wdHIpO1xuICAgICAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leGVjdXRlKHRoaXMuc29ja2V0LnJlYWQoKSB8fCBFTVBUWV9CVUYpO1xuICAgICAgICB0aGlzLnJlYWRNb3JlKCk7XG4gICAgICB9XG4gICAgICByZWFkTW9yZSgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnB0cikge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5zb2NrZXQucmVhZCgpO1xuICAgICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXhlY3V0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4ZWN1dGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbCk7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpO1xuICAgICAgICBhc3NlcnQoIXRoaXMucGF1c2VkKTtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQsIGxsaHR0cCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gY3VycmVudEJ1ZmZlclNpemUpIHtcbiAgICAgICAgICBpZiAoY3VycmVudEJ1ZmZlclB0cikge1xuICAgICAgICAgICAgbGxodHRwLmZyZWUoY3VycmVudEJ1ZmZlclB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNDA5NikgKiA0MDk2O1xuICAgICAgICAgIGN1cnJlbnRCdWZmZXJQdHIgPSBsbGh0dHAubWFsbG9jKGN1cnJlbnRCdWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgY3VycmVudEJ1ZmZlclB0ciwgY3VycmVudEJ1ZmZlclNpemUpLnNldChkYXRhKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmV0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gZGF0YTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJzZXIgPSB0aGlzO1xuICAgICAgICAgICAgcmV0ID0gbGxodHRwLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLCBjdXJyZW50QnVmZmVyUHRyLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJzZXIgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0cikgLSBjdXJyZW50QnVmZmVyUHRyO1xuICAgICAgICAgIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRURfVVBHUkFERSkge1xuICAgICAgICAgICAgdGhpcy5vblVwZ3JhZGUoZGF0YS5zbGljZShvZmZzZXQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgc29ja2V0LnVuc2hpZnQoZGF0YS5zbGljZShvZmZzZXQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gY29uc3RhbnRzLkVSUk9SLk9LKSB7XG4gICAgICAgICAgICBjb25zdCBwdHIgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9yZWFzb24odGhpcy5wdHIpO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHB0cikge1xuICAgICAgICAgICAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyKS5pbmRleE9mKDApO1xuICAgICAgICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obGxodHRwLm1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhUVFBQYXJzZXJFcnJvcihtZXNzYWdlLCBjb25zdGFudHMuRVJST1JbcmV0XSwgZGF0YS5zbGljZShvZmZzZXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5pc2goKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJzZXIgPSB0aGlzO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3kodGhpcy5zb2NrZXQsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKTtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbCk7XG4gICAgICAgIHRoaXMubGxodHRwLmxsaHR0cF9mcmVlKHRoaXMucHRyKTtcbiAgICAgICAgdGhpcy5wdHIgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9uU3RhdHVzKGJ1Zikge1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBidWYudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIG9uTWVzc2FnZUJlZ2luKCkge1xuICAgICAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzO1xuICAgICAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBpZiAoIXJlcXVlc3QyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkhlYWRlckZpZWxkKGJ1Zikge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAoKGxlbiAmIDEpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBvbkhlYWRlclZhbHVlKGJ1Zikge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKChsZW4gJiAxKSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1Zik7XG4gICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmhlYWRlcnNbbGVuIC0gMl07XG4gICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImtlZXAtYWxpdmVcIikge1xuICAgICAgICAgIHRoaXMua2VlcEFsaXZlICs9IGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDE0ICYmIGtleS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC1sZW5ndGhcIikge1xuICAgICAgICAgIHRoaXMuY29udGVudExlbmd0aCArPSBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgdHJhY2tIZWFkZXIobGVuKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzU2l6ZSA+PSB0aGlzLmhlYWRlcnNNYXhTaXplKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveSh0aGlzLnNvY2tldCwgbmV3IEhlYWRlcnNPdmVyZmxvd0Vycm9yKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvblVwZ3JhZGUoaGVhZCkge1xuICAgICAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzO1xuICAgICAgICBhc3NlcnQodXBncmFkZSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QyID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV07XG4gICAgICAgIGFzc2VydChyZXF1ZXN0Mik7XG4gICAgICAgIGFzc2VydCghc29ja2V0LmRlc3Ryb3llZCk7XG4gICAgICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSk7XG4gICAgICAgIGFzc2VydCghdGhpcy5wYXVzZWQpO1xuICAgICAgICBhc3NlcnQocmVxdWVzdDIudXBncmFkZSB8fCByZXF1ZXN0Mi5tZXRob2QgPT09IFwiQ09OTkVDVFwiKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBudWxsO1xuICAgICAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDA7XG4gICAgICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpO1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0gPSBudWxsO1xuICAgICAgICBzb2NrZXRba0NsaWVudF0gPSBudWxsO1xuICAgICAgICBzb2NrZXRba0Vycm9yXSA9IG51bGw7XG4gICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpLnJlbW92ZUxpc3RlbmVyKFwicmVhZGFibGVcIiwgb25Tb2NrZXRSZWFkYWJsZSkucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgb25Tb2NrZXRFbmQpLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGw7XG4gICAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsO1xuICAgICAgICBjbGllbnQuZW1pdChcImRpc2Nvbm5lY3RcIiwgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcihcInVwZ3JhZGVcIikpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcXVlc3QyLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bWUoY2xpZW50KTtcbiAgICAgIH1cbiAgICAgIG9uSGVhZGVyc0NvbXBsZXRlKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNUZXh0IH0gPSB0aGlzO1xuICAgICAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBpZiAoIXJlcXVlc3QyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCghdGhpcy51cGdyYWRlKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMuc3RhdHVzQ29kZSA8IDIwMCk7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAxMDApIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKFwiYmFkIHJlc3BvbnNlXCIsIHV0aWwyLmdldFNvY2tldEluZm8oc29ja2V0KSkpO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdDIudXBncmFkZSkge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoXCJiYWQgdXBncmFkZVwiLCB1dGlsMi5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfSEVBREVSUyk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gc2hvdWxkS2VlcEFsaXZlO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNDb2RlID49IDIwMCkge1xuICAgICAgICAgIGNvbnN0IGJvZHlUaW1lb3V0ID0gcmVxdWVzdDIuYm9keVRpbWVvdXQgIT0gbnVsbCA/IHJlcXVlc3QyLmJvZHlUaW1lb3V0IDogY2xpZW50W2tCb2R5VGltZW91dF07XG4gICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJDT05ORUNUXCIpIHtcbiAgICAgICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSk7XG4gICAgICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBncmFkZSkge1xuICAgICAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKTtcbiAgICAgICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0aGlzLmhlYWRlcnMubGVuZ3RoICUgMiA9PT0gMCk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhlYWRlcnNTaXplID0gMDtcbiAgICAgICAgaWYgKHNob3VsZEtlZXBBbGl2ZSAmJiBjbGllbnRba1BpcGVsaW5pbmddKSB7XG4gICAgICAgICAgY29uc3Qga2VlcEFsaXZlVGltZW91dCA9IHRoaXMua2VlcEFsaXZlID8gdXRpbDIucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGw7XG4gICAgICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICBrZWVwQWxpdmVUaW1lb3V0IC0gY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSxcbiAgICAgICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gdGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gY2xpZW50W2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF1c2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGF1c2UgPSByZXF1ZXN0Mi5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgdGhpcy5yZXN1bWUsIHN0YXR1c1RleHQpID09PSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIGVycik7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgYXNzZXJ0KHNvY2tldFtrUmVzZXRdKTtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2U7XG4gICAgICAgICAgcmVzdW1lKGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdXNlID8gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCA6IDA7XG4gICAgICB9XG4gICAgICBvbkJvZHkoYnVmKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QyID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV07XG4gICAgICAgIGFzc2VydChyZXF1ZXN0Mik7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLCBUSU1FT1VUX0JPRFkpO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAyMDApO1xuICAgICAgICB0aGlzLmJ5dGVzUmVhZCArPSBidWYubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5vbkRhdGEoYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIGVycik7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbk1lc3NhZ2VDb21wbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QyID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV07XG4gICAgICAgIGFzc2VydChyZXF1ZXN0Mik7XG4gICAgICAgIGFzc2VydChzdGF0dXNDb2RlID49IDEwMCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gXCJcIjtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgPSBcIlwiO1xuICAgICAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDA7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5tZXRob2QgIT09IFwiSEVBRFwiICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSk7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVxdWVzdDIub25Db21wbGV0ZShoZWFkZXJzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGw7XG4gICAgICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNsaWVudFtrUnVubmluZ10sIDApO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKFwicmVzZXRcIikpO1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcihcInJlc2V0XCIpKTtcbiAgICAgICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRDtcbiAgICAgICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoXCJyZXNldFwiKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PT0gMSkge1xuICAgICAgICAgIHNldEltbWVkaWF0ZShyZXN1bWUsIGNsaWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdW1lKGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShQYXJzZXIsIFwiUGFyc2VyXCIpO1xuICAgIGZ1bmN0aW9uIG9uUGFyc2VyVGltZW91dChwYXJzZXIpIHtcbiAgICAgIGNvbnN0IHsgc29ja2V0LCB0aW1lb3V0VHlwZSwgY2xpZW50IH0gPSBwYXJzZXI7XG4gICAgICBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICAgICAgYXNzZXJ0KCFwYXJzZXIucGF1c2VkLCBcImNhbm5vdCBiZSBwYXVzZWQgd2hpbGUgd2FpdGluZyBmb3IgaGVhZGVyc1wiKTtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSkge1xuICAgICAgICBpZiAoIXBhcnNlci5wYXVzZWQpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEJvZHlUaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSURMRSkge1xuICAgICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0pO1xuICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcihcInNvY2tldCBpZGxlIHRpbWVvdXRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUob25QYXJzZXJUaW1lb3V0LCBcIm9uUGFyc2VyVGltZW91dFwiKTtcbiAgICBmdW5jdGlvbiBvblNvY2tldFJlYWRhYmxlKCkge1xuICAgICAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpcztcbiAgICAgIHBhcnNlci5yZWFkTW9yZSgpO1xuICAgIH1cbiAgICBfX25hbWUob25Tb2NrZXRSZWFkYWJsZSwgXCJvblNvY2tldFJlYWRhYmxlXCIpO1xuICAgIGZ1bmN0aW9uIG9uU29ja2V0RXJyb3IoZXJyKSB7XG4gICAgICBjb25zdCB7IFtrUGFyc2VyXTogcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgYXNzZXJ0KGVyci5jb2RlICE9PSBcIkVSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSURcIik7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IFwiRUNPTk5SRVNFVFwiICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAgIHBhcnNlci5maW5pc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpc1trRXJyb3JdID0gZXJyO1xuICAgICAgb25FcnJvcih0aGlzW2tDbGllbnRdLCBlcnIpO1xuICAgIH1cbiAgICBfX25hbWUob25Tb2NrZXRFcnJvciwgXCJvblNvY2tldEVycm9yXCIpO1xuICAgIGZ1bmN0aW9uIG9uRXJyb3IoY2xpZW50LCBlcnIpIHtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID09PSAwICYmIGVyci5jb2RlICE9PSBcIlVORF9FUlJfSU5GT1wiICYmIGVyci5jb2RlICE9PSBcIlVORF9FUlJfU09DS0VUXCIpIHtcbiAgICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ0lkeF0gPT09IGNsaWVudFtrUnVubmluZ0lkeF0pO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QyID0gcmVxdWVzdHNbaV07XG4gICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGNsaWVudFtrU2l6ZV0gPT09IDApO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICAgIGZ1bmN0aW9uIG9uU29ja2V0RW5kKCkge1xuICAgICAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpcztcbiAgICAgIGlmIChwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgICBwYXJzZXIuZmluaXNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHV0aWwyLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKFwib3RoZXIgc2lkZSBjbG9zZWRcIiwgdXRpbDIuZ2V0U29ja2V0SW5mbyh0aGlzKSkpO1xuICAgIH1cbiAgICBfX25hbWUob25Tb2NrZXRFbmQsIFwib25Tb2NrZXRFbmRcIik7XG4gICAgZnVuY3Rpb24gb25Tb2NrZXRDbG9zZSgpIHtcbiAgICAgIGNvbnN0IHsgW2tDbGllbnRdOiBjbGllbnQgfSA9IHRoaXM7XG4gICAgICB0aGlzW2tQYXJzZXJdLmRlc3Ryb3koKTtcbiAgICAgIHRoaXNba1BhcnNlcl0gPSBudWxsO1xuICAgICAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcihcImNsb3NlZFwiLCB1dGlsMi5nZXRTb2NrZXRJbmZvKHRoaXMpKTtcbiAgICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGw7XG4gICAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdDIgPSByZXF1ZXN0c1tpXTtcbiAgICAgICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0MiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBlcnIuY29kZSAhPT0gXCJVTkRfRVJSX0lORk9cIikge1xuICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dO1xuICAgICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbDtcbiAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICB9XG4gICAgICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XTtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKTtcbiAgICAgIGNsaWVudC5lbWl0KFwiZGlzY29ubmVjdFwiLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpO1xuICAgICAgcmVzdW1lKGNsaWVudCk7XG4gICAgfVxuICAgIF9fbmFtZShvblNvY2tldENsb3NlLCBcIm9uU29ja2V0Q2xvc2VcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdChjbGllbnQpIHtcbiAgICAgIGFzc2VydCghY2xpZW50W2tDb25uZWN0aW5nXSk7XG4gICAgICBhc3NlcnQoIWNsaWVudFtrU29ja2V0XSk7XG4gICAgICBsZXQgeyBob3N0LCBob3N0bmFtZTogaG9zdG5hbWUzLCBwcm90b2NvbCwgcG9ydCB9ID0gY2xpZW50W2tVcmxdO1xuICAgICAgaWYgKGhvc3RuYW1lM1swXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaG9zdG5hbWUzLmluZGV4T2YoXCJdXCIpO1xuICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IGlwID0gaG9zdG5hbWUzLnN1YnN0cigxLCBpZHggLSAxKTtcbiAgICAgICAgYXNzZXJ0KG5ldDIuaXNJUChpcCkpO1xuICAgICAgICBob3N0bmFtZTMgPSBpcDtcbiAgICAgIH1cbiAgICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSB0cnVlO1xuICAgICAgaWYgKGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5wdWJsaXNoKHtcbiAgICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lMyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNsaWVudFtrQ29ubmVjdG9yXSh7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lMyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV1cbiAgICAgICAgICB9LCAoZXJyLCBzb2NrZXQyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzb2NrZXQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbGxodHRwSW5zdGFuY2UpIHtcbiAgICAgICAgICBsbGh0dHBJbnN0YW5jZSA9IGF3YWl0IGxsaHR0cFByb21pc2U7XG4gICAgICAgICAgbGxodHRwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlO1xuICAgICAgICBhc3NlcnQoc29ja2V0KTtcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0O1xuICAgICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlO1xuICAgICAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2U7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gZmFsc2U7XG4gICAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2U7XG4gICAgICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbDtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdID0gbmV3IFBhcnNlcihjbGllbnQsIHNvY2tldCwgbGxodHRwSW5zdGFuY2UpO1xuICAgICAgICBzb2NrZXRba0NsaWVudF0gPSBjbGllbnQ7XG4gICAgICAgIHNvY2tldFtrQ291bnRlcl0gPSAwO1xuICAgICAgICBzb2NrZXRba01heFJlcXVlc3RzXSA9IGNsaWVudFtrTWF4UmVxdWVzdHNdO1xuICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCBvblNvY2tldEVycm9yKS5vbihcInJlYWRhYmxlXCIsIG9uU29ja2V0UmVhZGFibGUpLm9uKFwiZW5kXCIsIG9uU29ja2V0RW5kKS5vbihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICBpZiAoY2hhbm5lbHMuY29ubmVjdGVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMuY29ubmVjdGVkLnB1Ymxpc2goe1xuICAgICAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICBob3N0bmFtZTogaG9zdG5hbWUzLFxuICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICAgICAgc29ja2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50LmVtaXQoXCJjb25uZWN0XCIsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lMyxcbiAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRFwiKSB7XG4gICAgICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApO1xuICAgICAgICAgIHdoaWxlIChjbGllbnRba1BlbmRpbmddID4gMCAmJiBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lID09PSBjbGllbnRba1NlcnZlck5hbWVdKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0MiA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF0rK107XG4gICAgICAgICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0MiwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25FcnJvcihjbGllbnQsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50LmVtaXQoXCJjb25uZWN0aW9uRXJyb3JcIiwgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc3VtZShjbGllbnQpO1xuICAgIH1cbiAgICBfX25hbWUoY29ubmVjdCwgXCJjb25uZWN0XCIpO1xuICAgIGZ1bmN0aW9uIGVtaXREcmFpbihjbGllbnQpIHtcbiAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDA7XG4gICAgICBjbGllbnQuZW1pdChcImRyYWluXCIsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pO1xuICAgIH1cbiAgICBfX25hbWUoZW1pdERyYWluLCBcImVtaXREcmFpblwiKTtcbiAgICBmdW5jdGlvbiByZXN1bWUoY2xpZW50LCBzeW5jKSB7XG4gICAgICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xpZW50W2tSZXN1bWluZ10gPSAyO1xuICAgICAgX3Jlc3VtZShjbGllbnQsIHN5bmMpO1xuICAgICAgY2xpZW50W2tSZXN1bWluZ10gPSAwO1xuICAgICAgaWYgKGNsaWVudFtrUnVubmluZ0lkeF0gPiAyNTYpIHtcbiAgICAgICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKDAsIGNsaWVudFtrUnVubmluZ0lkeF0pO1xuICAgICAgICBjbGllbnRba1BlbmRpbmdJZHhdIC09IGNsaWVudFtrUnVubmluZ0lkeF07XG4gICAgICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVzdW1lLCBcInJlc3VtZVwiKTtcbiAgICBmdW5jdGlvbiBfcmVzdW1lKGNsaWVudCwgc3luYykge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQuY2xvc2VkICYmICFjbGllbnRba1NpemVdKSB7XG4gICAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdO1xuICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnVucmVmKSB7XG4gICAgICAgICAgICAgIHNvY2tldC51bnJlZigpO1xuICAgICAgICAgICAgICBzb2NrZXRba05vUmVmXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzb2NrZXRba05vUmVmXSAmJiBzb2NrZXQucmVmKSB7XG4gICAgICAgICAgICBzb2NrZXQucmVmKCk7XG4gICAgICAgICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9JRExFKSB7XG4gICAgICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS5zZXRUaW1lb3V0KGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSwgVElNRU9VVF9JRExFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHNvY2tldFtrUGFyc2VyXS5zdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdDMgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXTtcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVyc1RpbWVvdXQgPSByZXF1ZXN0My5oZWFkZXJzVGltZW91dCAhPSBudWxsID8gcmVxdWVzdDMuaGVhZGVyc1RpbWVvdXQgOiBjbGllbnRba0hlYWRlcnNUaW1lb3V0XTtcbiAgICAgICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRba0J1c3ldKSB7XG4gICAgICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGllbnRba05lZWREcmFpbl0gPT09IDIpIHtcbiAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdERyYWluLCBjbGllbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0RHJhaW4oY2xpZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrUGVuZGluZ10gPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPj0gKGNsaWVudFtrUGlwZWxpbmluZ10gfHwgMSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdDIgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXTtcbiAgICAgICAgaWYgKGNsaWVudFtrVXJsXS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiBjbGllbnRba1NlcnZlck5hbWVdICE9PSByZXF1ZXN0Mi5zZXJ2ZXJuYW1lKSB7XG4gICAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFtrU2VydmVyTmFtZV0gPSByZXF1ZXN0Mi5zZXJ2ZXJuYW1lO1xuICAgICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnNlcnZlcm5hbWUgIT09IHJlcXVlc3QyLnNlcnZlcm5hbWUpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKFwic2VydmVybmFtZSBjaGFuZ2VkXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrQ29ubmVjdGluZ10pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICBjb25uZWN0KGNsaWVudCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5kZXN0cm95ZWQgfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgIXJlcXVlc3QyLmlkZW1wb3RlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIChyZXF1ZXN0Mi51cGdyYWRlIHx8IHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJDT05ORUNUXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbShyZXF1ZXN0Mi5ib2R5KSAmJiB1dGlsMi5ib2R5TGVuZ3RoKHJlcXVlc3QyLmJvZHkpID09PSAwKSB7XG4gICAgICAgICAgcmVxdWVzdDIuYm9keS5vbihcImRhdGFcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgIH0pLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0MiwgZXJyKTtcbiAgICAgICAgICB9KS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdDIuYm9keSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmICh1dGlsMi5pc1N0cmVhbShyZXF1ZXN0Mi5ib2R5KSB8fCB1dGlsMi5pc0FzeW5jSXRlcmFibGUocmVxdWVzdDIuYm9keSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVxdWVzdDIuYWJvcnRlZCAmJiB3cml0ZShjbGllbnQsIHJlcXVlc3QyKSkge1xuICAgICAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKF9yZXN1bWUsIFwiX3Jlc3VtZVwiKTtcbiAgICBmdW5jdGlvbiB3cml0ZShjbGllbnQsIHJlcXVlc3QyKSB7XG4gICAgICBjb25zdCB7IGJvZHksIG1ldGhvZCwgcGF0aDogcGF0aDcsIGhvc3QsIHVwZ3JhZGUsIGhlYWRlcnMsIGJsb2NraW5nIH0gPSByZXF1ZXN0MjtcbiAgICAgIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gbWV0aG9kID09PSBcIlBVVFwiIHx8IG1ldGhvZCA9PT0gXCJQT1NUXCIgfHwgbWV0aG9kID09PSBcIlBBVENIXCI7XG4gICAgICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9keS5yZWFkKDApO1xuICAgICAgfVxuICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsMi5ib2R5TGVuZ3RoKGJvZHkpO1xuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QyLmNvbnRlbnRMZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgY29udGVudExlbmd0aCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIuY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiByZXF1ZXN0Mi5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QyLm9uQ29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKHJlcXVlc3QyLmFib3J0ZWQgfHwgcmVxdWVzdDIuY29tcGxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoXCJhYm9ydGVkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdDIsIGVycik7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGllbnRba01heFJlcXVlc3RzXSAmJiBzb2NrZXRba0NvdW50ZXJdKysgPj0gY2xpZW50W2tNYXhSZXF1ZXN0c10pIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBoZWFkZXIgPSBgJHttZXRob2R9ICR7cGF0aDd9IEhUVFAvMS4xXFxyXG5gO1xuICAgICAgaWYgKHR5cGVvZiBob3N0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlciArPSBgaG9zdDogJHtob3N0fVxcclxuYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciArPSBjbGllbnRba0hvc3RIZWFkZXJdO1xuICAgICAgfVxuICAgICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXG51cGdyYWRlOiAke3VwZ3JhZGV9XFxyXG5gO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddKSB7XG4gICAgICAgIGhlYWRlciArPSBcImNvbm5lY3Rpb246IGtlZXAtYWxpdmVcXHJcXG5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciArPSBcImNvbm5lY3Rpb246IGNsb3NlXFxyXFxuXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBoZWFkZXIgKz0gaGVhZGVycztcbiAgICAgIH1cbiAgICAgIGlmIChjaGFubmVscy5zZW5kSGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICBjaGFubmVscy5zZW5kSGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogcmVxdWVzdDIsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0IH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxuXFxyXG5gLCBcImFzY2lpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBudWxsLCBcIm5vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKTtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0Mi5vblJlcXVlc3RTZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKHV0aWwyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsIFwiYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoXCIpO1xuICAgICAgICBzb2NrZXQuY29yaygpO1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXG5cXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgIHNvY2tldC53cml0ZShib2R5KTtcbiAgICAgICAgc29ja2V0LnVuY29yaygpO1xuICAgICAgICByZXF1ZXN0Mi5vbkJvZHlTZW50KGJvZHkpO1xuICAgICAgICByZXF1ZXN0Mi5vblJlcXVlc3RTZW50KCk7XG4gICAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB3cml0ZUl0ZXJhYmxlKHsgYm9keTogYm9keS5zdHJlYW0oKSwgY2xpZW50LCByZXF1ZXN0OiByZXF1ZXN0Miwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlQmxvYih7IGJvZHksIGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdDIsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB3cml0ZVN0cmVhbSh7IGJvZHksIGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdDIsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbDIuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgICB3cml0ZUl0ZXJhYmxlKHsgYm9keSwgY2xpZW50LCByZXF1ZXN0OiByZXF1ZXN0Miwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUod3JpdGUsIFwid3JpdGVcIik7XG4gICAgZnVuY3Rpb24gd3JpdGVTdHJlYW0oeyBib2R5LCBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgXCJzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkXCIpO1xuICAgICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQXN5bmNXcml0ZXIoeyBzb2NrZXQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSk7XG4gICAgICBjb25zdCBvbkRhdGEgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXNzZXJ0KCFmaW5pc2hlZCk7XG4gICAgICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspICYmIHRoaXMucGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3kodGhpcywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgXCJvbkRhdGFcIik7XG4gICAgICBjb25zdCBvbkRyYWluID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgYXNzZXJ0KCFmaW5pc2hlZCk7XG4gICAgICAgIGlmIChib2R5LnJlc3VtZSkge1xuICAgICAgICAgIGJvZHkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFwib25EcmFpblwiKTtcbiAgICAgIGNvbnN0IG9uQWJvcnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkZpbmlzaGVkKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpO1xuICAgICAgfSwgXCJvbkFib3J0XCIpO1xuICAgICAgY29uc3Qgb25GaW5pc2hlZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGFzc2VydChzb2NrZXQuZGVzdHJveWVkIHx8IHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKTtcbiAgICAgICAgc29ja2V0Lm9mZihcImRyYWluXCIsIG9uRHJhaW4pLm9mZihcImVycm9yXCIsIG9uRmluaXNoZWQpO1xuICAgICAgICBib2R5LnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uRmluaXNoZWQpLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25GaW5pc2hlZCkucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkFib3J0KTtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd3JpdGVyLmVuZCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICBlcnIgPSBlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLmRlc3Ryb3koZXJyKTtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09IFwiVU5EX0VSUl9JTkZPXCIgfHwgZXJyLm1lc3NhZ2UgIT09IFwicmVzZXRcIikpIHtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KGJvZHksIGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShib2R5KTtcbiAgICAgICAgfVxuICAgICAgfSwgXCJvbkZpbmlzaGVkXCIpO1xuICAgICAgYm9keS5vbihcImRhdGFcIiwgb25EYXRhKS5vbihcImVuZFwiLCBvbkZpbmlzaGVkKS5vbihcImVycm9yXCIsIG9uRmluaXNoZWQpLm9uKFwiY2xvc2VcIiwgb25BYm9ydCk7XG4gICAgICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICAgICAgYm9keS5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICAgIHNvY2tldC5vbihcImRyYWluXCIsIG9uRHJhaW4pLm9uKFwiZXJyb3JcIiwgb25GaW5pc2hlZCk7XG4gICAgfVxuICAgIF9fbmFtZSh3cml0ZVN0cmVhbSwgXCJ3cml0ZVN0cmVhbVwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUJsb2IoeyBib2R5LCBjbGllbnQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgXCJibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgc29ja2V0LmNvcmsoKTtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxuXFxyXG5gLCBcImFzY2lpXCIpO1xuICAgICAgICBzb2NrZXQud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgc29ja2V0LnVuY29yaygpO1xuICAgICAgICByZXF1ZXN0Mi5vbkJvZHlTZW50KGJ1ZmZlcik7XG4gICAgICAgIHJlcXVlc3QyLm9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bWUoY2xpZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHdyaXRlQmxvYiwgXCJ3cml0ZUJsb2JcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVJdGVyYWJsZSh7IGJvZHksIGNsaWVudCwgcmVxdWVzdDogcmVxdWVzdDIsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCBcIml0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtcbiAgICAgIGxldCBjYWxsYmFjayA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBvbkRyYWluKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUob25EcmFpbiwgXCJvbkRyYWluXCIpO1xuICAgICAgY29uc3Qgd2FpdEZvckRyYWluID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGFzc2VydChjYWxsYmFjayA9PT0gbnVsbCk7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgICB9XG4gICAgICB9KSwgXCJ3YWl0Rm9yRHJhaW5cIik7XG4gICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCBvbkRyYWluKS5vbihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLmVuZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHdyaXRlci5kZXN0cm95KGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzb2NrZXQub2ZmKFwiY2xvc2VcIiwgb25EcmFpbikub2ZmKFwiZHJhaW5cIiwgb25EcmFpbik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh3cml0ZUl0ZXJhYmxlLCBcIndyaXRlSXRlcmFibGVcIik7XG4gICAgdmFyIEFzeW5jV3JpdGVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoeyBzb2NrZXQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDI7XG4gICAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgICAgIHRoaXMuZXhwZWN0c1BheWxvYWQgPSBleHBlY3RzUGF5bG9hZDtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlO1xuICAgICAgfVxuICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQsIHJlcXVlc3Q6IHJlcXVlc3QyLCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspO1xuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9dHJhbnNmZXItZW5jb2Rpbmc6IGNodW5rZWRcXHJcbmAsIFwiYXNjaWlcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcblxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoYFxcclxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBsZW47XG4gICAgICAgIGNvbnN0IHJldCA9IHNvY2tldC53cml0ZShjaHVuayk7XG4gICAgICAgIHJlcXVlc3QyLm9uQm9keVNlbnQoY2h1bmspO1xuICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgZW5kKCkge1xuICAgICAgICBjb25zdCB7IHNvY2tldCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIsIHJlcXVlc3Q6IHJlcXVlc3QyIH0gPSB0aGlzO1xuICAgICAgICByZXF1ZXN0Mi5vblJlcXVlc3RTZW50KCk7XG4gICAgICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgICAgIGlmIChleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxuXFxyXG5gLCBcImFzY2lpXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxuYCwgXCJhc2NpaVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNvY2tldC53cml0ZShcIlxcclxcbjBcXHJcXG5cXHJcXG5cIiwgXCJhc2NpaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VtZShjbGllbnQpO1xuICAgICAgfVxuICAgICAgZGVzdHJveShlcnIpIHtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpcztcbiAgICAgICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPD0gMSwgXCJwaXBlbGluZSBzaG91bGQgb25seSBjb250YWluIHRoaXMgcmVxdWVzdFwiKTtcbiAgICAgICAgICB1dGlsMi5kZXN0cm95KHNvY2tldCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEFzeW5jV3JpdGVyLCBcIkFzeW5jV3JpdGVyXCIpO1xuICAgIGZ1bmN0aW9uIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QyLCBlcnIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QyLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYXNzZXJ0KHJlcXVlc3QyLmFib3J0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBjbGllbnQuZW1pdChcImVycm9yXCIsIGVycjIpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZXJyb3JSZXF1ZXN0LCBcImVycm9yUmVxdWVzdFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBDbGllbnQ7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9ub2RlL2ZpeGVkLXF1ZXVlLmpzXG52YXIgcmVxdWlyZV9maXhlZF9xdWV1ZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL25vZGUvZml4ZWQtcXVldWUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGtTaXplID0gMjA0ODtcbiAgICB2YXIga01hc2sgPSBrU2l6ZSAtIDE7XG4gICAgdmFyIEZpeGVkQ2lyY3VsYXJCdWZmZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ib3R0b20gPSAwO1xuICAgICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBBcnJheShrU2l6ZSk7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICAgICAgfVxuICAgICAgaXNGdWxsKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudG9wICsgMSAmIGtNYXNrKSA9PT0gdGhpcy5ib3R0b207XG4gICAgICB9XG4gICAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgdGhpcy5saXN0W3RoaXMudG9wXSA9IGRhdGE7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AgKyAxICYga01hc2s7XG4gICAgICB9XG4gICAgICBzaGlmdCgpIHtcbiAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLmxpc3RbdGhpcy5ib3R0b21dO1xuICAgICAgICBpZiAobmV4dEl0ZW0gPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmJvdHRvbSArIDEgJiBrTWFzaztcbiAgICAgICAgcmV0dXJuIG5leHRJdGVtO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEZpeGVkQ2lyY3VsYXJCdWZmZXIsIFwiRml4ZWRDaXJjdWxhckJ1ZmZlclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGNsYXNzIEZpeGVkUXVldWUge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gICAgICB9XG4gICAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHB1c2goZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkLmlzRnVsbCgpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZC5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgc2hpZnQoKSB7XG4gICAgICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0YWlsLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnRhaWwgPSB0YWlsLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgfSwgXCJGaXhlZFF1ZXVlXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1zdGF0cy5qc1xudmFyIHJlcXVpcmVfcG9vbF9zdGF0cyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wtc3RhdHMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHsga0ZyZWUsIGtDb25uZWN0ZWQsIGtQZW5kaW5nLCBrUXVldWVkLCBrUnVubmluZywga1NpemUgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBrUG9vbCA9IFN5bWJvbChcInBvb2xcIik7XG4gICAgdmFyIFBvb2xTdGF0cyA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBvb2wpIHtcbiAgICAgICAgdGhpc1trUG9vbF0gPSBwb29sO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tDb25uZWN0ZWRdO1xuICAgICAgfVxuICAgICAgZ2V0IGZyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQb29sXVtrRnJlZV07XG4gICAgICB9XG4gICAgICBnZXQgcGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tQZW5kaW5nXTtcbiAgICAgIH1cbiAgICAgIGdldCBxdWV1ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQb29sXVtrUXVldWVkXTtcbiAgICAgIH1cbiAgICAgIGdldCBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trUG9vbF1ba1J1bm5pbmddO1xuICAgICAgfVxuICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tQb29sXVtrU2l6ZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUG9vbFN0YXRzLCBcIlBvb2xTdGF0c1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBQb29sU3RhdHM7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLWJhc2UuanNcbnZhciByZXF1aXJlX3Bvb2xfYmFzZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wtYmFzZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlX2Rpc3BhdGNoZXJfYmFzZSgpO1xuICAgIHZhciBGaXhlZFF1ZXVlID0gcmVxdWlyZV9maXhlZF9xdWV1ZSgpO1xuICAgIHZhciB7IGtDb25uZWN0ZWQsIGtTaXplLCBrUnVubmluZywga1BlbmRpbmcsIGtRdWV1ZWQsIGtCdXN5LCBrRnJlZSwga1VybCwga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgUG9vbFN0YXRzID0gcmVxdWlyZV9wb29sX3N0YXRzKCk7XG4gICAgdmFyIGtDbGllbnRzID0gU3ltYm9sKFwiY2xpZW50c1wiKTtcbiAgICB2YXIga05lZWREcmFpbiA9IFN5bWJvbChcIm5lZWREcmFpblwiKTtcbiAgICB2YXIga1F1ZXVlID0gU3ltYm9sKFwicXVldWVcIik7XG4gICAgdmFyIGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKFwiY2xvc2VkIHJlc29sdmVcIik7XG4gICAgdmFyIGtPbkRyYWluID0gU3ltYm9sKFwib25EcmFpblwiKTtcbiAgICB2YXIga09uQ29ubmVjdCA9IFN5bWJvbChcIm9uQ29ubmVjdFwiKTtcbiAgICB2YXIga09uRGlzY29ubmVjdCA9IFN5bWJvbChcIm9uRGlzY29ubmVjdFwiKTtcbiAgICB2YXIga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKFwib25Db25uZWN0aW9uRXJyb3JcIik7XG4gICAgdmFyIGtHZXREaXNwYXRjaGVyID0gU3ltYm9sKFwiZ2V0IGRpc3BhdGNoZXJcIik7XG4gICAgdmFyIGtBZGRDbGllbnQgPSBTeW1ib2woXCJhZGQgY2xpZW50XCIpO1xuICAgIHZhciBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKFwicmVtb3ZlIGNsaWVudFwiKTtcbiAgICB2YXIga1N0YXRzID0gU3ltYm9sKFwic3RhdHNcIik7XG4gICAgdmFyIFBvb2xCYXNlID0gY2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1trUXVldWVdID0gbmV3IEZpeGVkUXVldWUoKTtcbiAgICAgICAgdGhpc1trQ2xpZW50c10gPSBbXTtcbiAgICAgICAgdGhpc1trUXVldWVkXSA9IDA7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzO1xuICAgICAgICB0aGlzW2tPbkRyYWluXSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gb25EcmFpbihvcmlnaW4sIHRhcmdldHMpIHtcbiAgICAgICAgICBjb25zdCBxdWV1ZSA9IHBvb2xba1F1ZXVlXTtcbiAgICAgICAgICBsZXQgbmVlZERyYWluID0gZmFsc2U7XG4gICAgICAgICAgd2hpbGUgKCFuZWVkRHJhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9vbFtrUXVldWVkXS0tO1xuICAgICAgICAgICAgbmVlZERyYWluID0gIXRoaXMuZGlzcGF0Y2goaXRlbS5vcHRzLCBpdGVtLmhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tOZWVkRHJhaW5dID0gbmVlZERyYWluO1xuICAgICAgICAgIGlmICghdGhpc1trTmVlZERyYWluXSAmJiBwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgICBwb29sW2tOZWVkRHJhaW5dID0gZmFsc2U7XG4gICAgICAgICAgICBwb29sLmVtaXQoXCJkcmFpblwiLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb29sW2tDbG9zZWRSZXNvbHZlXSAmJiBxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHBvb2xba0NsaWVudHNdLm1hcCgoYykgPT4gYy5jbG9zZSgpKSkudGhlbihwb29sW2tDbG9zZWRSZXNvbHZlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcIm9uRHJhaW5cIik7XG4gICAgICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICAgICAgcG9vbC5lbWl0KFwiY29ubmVjdFwiLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgICAgICBwb29sLmVtaXQoXCJkaXNjb25uZWN0XCIsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgICAgICBwb29sLmVtaXQoXCJjb25uZWN0aW9uRXJyb3JcIiwgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNba1N0YXRzXSA9IG5ldyBQb29sU3RhdHModGhpcyk7XG4gICAgICB9XG4gICAgICBnZXQgW2tCdXN5XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl07XG4gICAgICB9XG4gICAgICBnZXQgW2tDb25uZWN0ZWRdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKChjbGllbnQpID0+IGNsaWVudFtrQ29ubmVjdGVkXSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZ2V0IFtrRnJlZV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoKGNsaWVudCkgPT4gY2xpZW50W2tDb25uZWN0ZWRdICYmICFjbGllbnRba05lZWREcmFpbl0pLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGdldCBba1BlbmRpbmddKCkge1xuICAgICAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXTtcbiAgICAgICAgZm9yIChjb25zdCB7IFtrUGVuZGluZ106IHBlbmRpbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgICAgIHJldCArPSBwZW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBnZXQgW2tSdW5uaW5nXSgpIHtcbiAgICAgICAgbGV0IHJldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBba1J1bm5pbmddOiBydW5uaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgICAgICByZXQgKz0gcnVubmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgZ2V0IFtrU2l6ZV0oKSB7XG4gICAgICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgW2tTaXplXTogc2l6ZSB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICAgICAgcmV0ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRzXTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrQ2xvc2VdKCkge1xuICAgICAgICBpZiAodGhpc1trUXVldWVdLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoKGMpID0+IGMuY2xvc2UoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3luYyBba0Rlc3Ryb3ldKGVycikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKTtcbiAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoKGMpID0+IGMuZGVzdHJveShlcnIpKSk7XG4gICAgICB9XG4gICAgICBba0Rpc3BhdGNoXShvcHRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tHZXREaXNwYXRjaGVyXSgpO1xuICAgICAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgICAgICB0aGlzW2tOZWVkRHJhaW5dID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzW2tRdWV1ZV0ucHVzaCh7IG9wdHMsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgdGhpc1trUXVldWVkXSsrO1xuICAgICAgICB9IGVsc2UgaWYgKCFkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWU7XG4gICAgICAgICAgdGhpc1trTmVlZERyYWluXSA9ICF0aGlzW2tHZXREaXNwYXRjaGVyXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXTtcbiAgICAgIH1cbiAgICAgIFtrQWRkQ2xpZW50XShjbGllbnQpIHtcbiAgICAgICAgY2xpZW50Lm9uKFwiZHJhaW5cIiwgdGhpc1trT25EcmFpbl0pLm9uKFwiY29ubmVjdFwiLCB0aGlzW2tPbkNvbm5lY3RdKS5vbihcImRpc2Nvbm5lY3RcIiwgdGhpc1trT25EaXNjb25uZWN0XSkub24oXCJjb25uZWN0aW9uRXJyb3JcIiwgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKTtcbiAgICAgICAgdGhpc1trQ2xpZW50c10ucHVzaChjbGllbnQpO1xuICAgICAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgICAgICAgICAgdGhpc1trT25EcmFpbl0oY2xpZW50W2tVcmxdLCBbdGhpcywgY2xpZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBba1JlbW92ZUNsaWVudF0oY2xpZW50KSB7XG4gICAgICAgIGNsaWVudC5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZihjbGllbnQpO1xuICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW2tOZWVkRHJhaW5dID0gdGhpc1trQ2xpZW50c10uc29tZSgoZGlzcGF0Y2hlcikgPT4gIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiYgZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFBvb2xCYXNlLCBcIlBvb2xCYXNlXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIFBvb2xCYXNlLFxuICAgICAga0NsaWVudHMsXG4gICAgICBrTmVlZERyYWluLFxuICAgICAga0FkZENsaWVudCxcbiAgICAgIGtSZW1vdmVDbGllbnQsXG4gICAgICBrR2V0RGlzcGF0Y2hlclxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLmpzXG52YXIgcmVxdWlyZV9wb29sID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIge1xuICAgICAgUG9vbEJhc2UsXG4gICAgICBrQ2xpZW50cyxcbiAgICAgIGtOZWVkRHJhaW4sXG4gICAgICBrQWRkQ2xpZW50LFxuICAgICAga0dldERpc3BhdGNoZXJcbiAgICB9ID0gcmVxdWlyZV9wb29sX2Jhc2UoKTtcbiAgICB2YXIgQ2xpZW50ID0gcmVxdWlyZV9jbGllbnQoKTtcbiAgICB2YXIge1xuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsga1VybCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZV9jb25uZWN0KCk7XG4gICAgdmFyIGtPcHRpb25zID0gU3ltYm9sKFwib3B0aW9uc1wiKTtcbiAgICB2YXIga0Nvbm5lY3Rpb25zID0gU3ltYm9sKFwiY29ubmVjdGlvbnNcIik7XG4gICAgdmFyIGtGYWN0b3J5ID0gU3ltYm9sKFwiZmFjdG9yeVwiKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0RmFjdG9yeShvcmlnaW4sIG9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cyk7XG4gICAgfVxuICAgIF9fbmFtZShkZWZhdWx0RmFjdG9yeSwgXCJkZWZhdWx0RmFjdG9yeVwiKTtcbiAgICB2YXIgUG9vbCA9IGNsYXNzIGV4dGVuZHMgUG9vbEJhc2Uge1xuICAgICAgY29uc3RydWN0b3Iob3JpZ2luLCB7XG4gICAgICAgIGNvbm5lY3Rpb25zLFxuICAgICAgICBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksXG4gICAgICAgIGNvbm5lY3QsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICB0bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdGlvbnMpIHx8IGNvbm5lY3Rpb25zIDwgMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29ubmVjdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImNvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7XG4gICAgICAgICAgICAuLi50bHMsXG4gICAgICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgICAgIHNvY2tldFBhdGgsXG4gICAgICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCA9PSBudWxsID8gMWU0IDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgICAgICAuLi5jb25uZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trQ29ubmVjdGlvbnNdID0gY29ubmVjdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgdGhpc1trVXJsXSA9IHV0aWwyLnBhcnNlT3JpZ2luKG9yaWdpbik7XG4gICAgICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsMi5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfTtcbiAgICAgICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5O1xuICAgICAgfVxuICAgICAgW2tHZXREaXNwYXRjaGVyXSgpIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKChkaXNwYXRjaGVyMikgPT4gIWRpc3BhdGNoZXIyW2tOZWVkRHJhaW5dKTtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXNba0Nvbm5lY3Rpb25zXSB8fCB0aGlzW2tDbGllbnRzXS5sZW5ndGggPCB0aGlzW2tDb25uZWN0aW9uc10pIHtcbiAgICAgICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0odGhpc1trVXJsXSwgdGhpc1trT3B0aW9uc10pO1xuICAgICAgICAgIHRoaXNba0FkZENsaWVudF0oZGlzcGF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUG9vbCwgXCJQb29sXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFBvb2w7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9iYWxhbmNlZC1wb29sLmpzXG52YXIgcmVxdWlyZV9iYWxhbmNlZF9wb29sID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIge1xuICAgICAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvclxuICAgIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB7XG4gICAgICBQb29sQmFzZSxcbiAgICAgIGtDbGllbnRzLFxuICAgICAga05lZWREcmFpbixcbiAgICAgIGtBZGRDbGllbnQsXG4gICAgICBrUmVtb3ZlQ2xpZW50LFxuICAgICAga0dldERpc3BhdGNoZXJcbiAgICB9ID0gcmVxdWlyZV9wb29sX2Jhc2UoKTtcbiAgICB2YXIgUG9vbCA9IHJlcXVpcmVfcG9vbCgpO1xuICAgIHZhciB7IGtVcmwgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIGtGYWN0b3J5ID0gU3ltYm9sKFwiZmFjdG9yeVwiKTtcbiAgICB2YXIga09wdGlvbnMgPSBTeW1ib2woXCJvcHRpb25zXCIpO1xuICAgIHZhciBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKFwia0dyZWF0ZXN0Q29tbW9uRGl2aXNvclwiKTtcbiAgICB2YXIga0N1cnJlbnRXZWlnaHQgPSBTeW1ib2woXCJrQ3VycmVudFdlaWdodFwiKTtcbiAgICB2YXIga0luZGV4ID0gU3ltYm9sKFwia0luZGV4XCIpO1xuICAgIHZhciBrV2VpZ2h0ID0gU3ltYm9sKFwia1dlaWdodFwiKTtcbiAgICB2YXIga01heFdlaWdodFBlclNlcnZlciA9IFN5bWJvbChcImtNYXhXZWlnaHRQZXJTZXJ2ZXJcIik7XG4gICAgdmFyIGtFcnJvclBlbmFsdHkgPSBTeW1ib2woXCJrRXJyb3JQZW5hbHR5XCIpO1xuICAgIGZ1bmN0aW9uIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhLCBiKSB7XG4gICAgICBpZiAoYiA9PT0gMClcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICByZXR1cm4gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKTtcbiAgICB9XG4gICAgX19uYW1lKGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciwgXCJnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3JcIik7XG4gICAgZnVuY3Rpb24gZGVmYXVsdEZhY3Rvcnkob3JpZ2luLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKTtcbiAgICB9XG4gICAgX19uYW1lKGRlZmF1bHRGYWN0b3J5LCBcImRlZmF1bHRGYWN0b3J5XCIpO1xuICAgIHZhciBCYWxhbmNlZFBvb2wgPSBjbGFzcyBleHRlbmRzIFBvb2xCYXNlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHVwc3RyZWFtcyA9IFtdLCB7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgLi4ub3B0cyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1trT3B0aW9uc10gPSBvcHRzO1xuICAgICAgICB0aGlzW2tJbmRleF0gPSAtMTtcbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSAwO1xuICAgICAgICB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdID0gdGhpc1trT3B0aW9uc10ubWF4V2VpZ2h0UGVyU2VydmVyIHx8IDEwMDtcbiAgICAgICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgICAgICB1cHN0cmVhbXMgPSBbdXBzdHJlYW1zXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3Rvcnk7XG4gICAgICAgIGZvciAoY29uc3QgdXBzdHJlYW0gb2YgdXBzdHJlYW1zKSB7XG4gICAgICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIGFkZFVwc3RyZWFtKHVwc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpbjtcbiAgICAgICAgaWYgKHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wyKSA9PiBwb29sMltrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmIHBvb2wyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBwb29sMi5kZXN0cm95ZWQgIT09IHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpO1xuICAgICAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpO1xuICAgICAgICBwb29sLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWluKHRoaXNba01heFdlaWdodFBlclNlcnZlcl0sIHBvb2xba1dlaWdodF0gKyB0aGlzW2tFcnJvclBlbmFsdHldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvb2wub24oXCJjb25uZWN0aW9uRXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSk7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvb2wub24oXCJkaXNjb25uZWN0XCIsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyID0gYXJnc1syXTtcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBcIlVORF9FUlJfU09DS0VUXCIpIHtcbiAgICAgICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICAgICAgY2xpZW50W2tXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpIHtcbiAgICAgICAgdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXSA9IHRoaXNba0NsaWVudHNdLm1hcCgocCkgPT4gcFtrV2VpZ2h0XSkucmVkdWNlKGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciwgMCk7XG4gICAgICB9XG4gICAgICByZW1vdmVVcHN0cmVhbSh1cHN0cmVhbSkge1xuICAgICAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW47XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sMikgPT4gcG9vbDJba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJiBwb29sMi5jbG9zZWQgIT09IHRydWUgJiYgcG9vbDIuZGVzdHJveWVkICE9PSB0cnVlKTtcbiAgICAgICAgaWYgKHBvb2wpIHtcbiAgICAgICAgICB0aGlzW2tSZW1vdmVDbGllbnRdKHBvb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZ2V0IHVwc3RyZWFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcigoZGlzcGF0Y2hlcikgPT4gZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpLm1hcCgocCkgPT4gcFtrVXJsXS5vcmlnaW4pO1xuICAgICAgfVxuICAgICAgW2tHZXREaXNwYXRjaGVyXSgpIHtcbiAgICAgICAgaWYgKHRoaXNba0NsaWVudHNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKChkaXNwYXRjaGVyMikgPT4gIWRpc3BhdGNoZXIyW2tOZWVkRHJhaW5dICYmIGRpc3BhdGNoZXIyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyMi5kZXN0cm95ZWQgIT09IHRydWUpO1xuICAgICAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsQ2xpZW50c0J1c3kgPSB0aGlzW2tDbGllbnRzXS5tYXAoKHBvb2wpID0+IHBvb2xba05lZWREcmFpbl0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKTtcbiAgICAgICAgaWYgKGFsbENsaWVudHNCdXN5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KChwb29sKSA9PiAhcG9vbFtrTmVlZERyYWluXSk7XG4gICAgICAgIHdoaWxlIChjb3VudGVyKysgPCB0aGlzW2tDbGllbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgcG9vbCA9IHRoaXNba0NsaWVudHNdW3RoaXNba0luZGV4XV07XG4gICAgICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgICAgIG1heFdlaWdodEluZGV4ID0gdGhpc1trSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpc1trSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba0N1cnJlbnRXZWlnaHRdIC0gdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXTtcbiAgICAgICAgICAgIGlmICh0aGlzW2tDdXJyZW50V2VpZ2h0XSA8PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvb2xba1dlaWdodF0gPj0gdGhpc1trQ3VycmVudFdlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBwb29sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba0NsaWVudHNdW21heFdlaWdodEluZGV4XVtrV2VpZ2h0XTtcbiAgICAgICAgdGhpc1trSW5kZXhdID0gbWF4V2VpZ2h0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF07XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQmFsYW5jZWRQb29sLCBcIkJhbGFuY2VkUG9vbFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBCYWxhbmNlZFBvb2w7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzXG52YXIgcmVxdWlyZV9kaXNwYXRjaGVyX3dlYWtyZWYgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGtDb25uZWN0ZWQsIGtTaXplIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgQ29tcGF0V2Vha1JlZiA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlcmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVtrQ29ubmVjdGVkXSA9PT0gMCAmJiB0aGlzLnZhbHVlW2tTaXplXSA9PT0gMCA/IHZvaWQgMCA6IHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQ29tcGF0V2Vha1JlZiwgXCJDb21wYXRXZWFrUmVmXCIpO1xuICAgIHZhciBDb21wYXRGaW5hbGl6ZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihmaW5hbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XG4gICAgICB9XG4gICAgICByZWdpc3RlcihkaXNwYXRjaGVyLCBrZXkpIHtcbiAgICAgICAgZGlzcGF0Y2hlci5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmIChkaXNwYXRjaGVyW2tDb25uZWN0ZWRdID09PSAwICYmIGRpc3BhdGNoZXJba1NpemVdID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplcihrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQ29tcGF0RmluYWxpemVyLCBcIkNvbXBhdEZpbmFsaXplclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFdlYWtSZWY6IGdsb2JhbC5XZWFrUmVmIHx8IENvbXBhdFdlYWtSZWYsXG4gICAgICAgIEZpbmFsaXphdGlvblJlZ2lzdHJ5OiBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgfHwgQ29tcGF0RmluYWxpemVyXG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qc1xudmFyIHJlcXVpcmVfYWdlbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBrQ2xpZW50cywga1J1bm5pbmcsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZV9kaXNwYXRjaGVyX2Jhc2UoKTtcbiAgICB2YXIgUG9vbCA9IHJlcXVpcmVfcG9vbCgpO1xuICAgIHZhciBDbGllbnQgPSByZXF1aXJlX2NsaWVudCgpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZV9yZWRpcmVjdCgpO1xuICAgIHZhciB7IFdlYWtSZWY6IFdlYWtSZWYyLCBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZV9kaXNwYXRjaGVyX3dlYWtyZWYoKSgpO1xuICAgIHZhciBrT25Db25uZWN0ID0gU3ltYm9sKFwib25Db25uZWN0XCIpO1xuICAgIHZhciBrT25EaXNjb25uZWN0ID0gU3ltYm9sKFwib25EaXNjb25uZWN0XCIpO1xuICAgIHZhciBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woXCJvbkNvbm5lY3Rpb25FcnJvclwiKTtcbiAgICB2YXIga01heFJlZGlyZWN0aW9ucyA9IFN5bWJvbChcIm1heFJlZGlyZWN0aW9uc1wiKTtcbiAgICB2YXIga09uRHJhaW4gPSBTeW1ib2woXCJvbkRyYWluXCIpO1xuICAgIHZhciBrRmFjdG9yeSA9IFN5bWJvbChcImZhY3RvcnlcIik7XG4gICAgdmFyIGtGaW5hbGl6ZXIgPSBTeW1ib2woXCJmaW5hbGl6ZXJcIik7XG4gICAgdmFyIGtPcHRpb25zID0gU3ltYm9sKFwib3B0aW9uc1wiKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0RmFjdG9yeShvcmlnaW4sIG9wdHMpIHtcbiAgICAgIHJldHVybiBvcHRzICYmIG9wdHMuY29ubmVjdGlvbnMgPT09IDEgPyBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cykgOiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpO1xuICAgIH1cbiAgICBfX25hbWUoZGVmYXVsdEZhY3RvcnksIFwiZGVmYXVsdEZhY3RvcnlcIik7XG4gICAgdmFyIEFnZW50ID0gY2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICAgICBjb25zdHJ1Y3Rvcih7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgbWF4UmVkaXJlY3Rpb25zID0gMCwgY29ubmVjdCwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25uZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29ubmVjdCA9IHsgLi4uY29ubmVjdCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsMi5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfTtcbiAgICAgICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9ucztcbiAgICAgICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5O1xuICAgICAgICB0aGlzW2tDbGllbnRzXSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXNba0ZpbmFsaXplcl0gPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpO1xuICAgICAgICAgIGlmIChyZWYgIT09IHZvaWQgMCAmJiByZWYuZGVyZWYoKSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzW2tDbGllbnRzXS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhZ2VudCA9IHRoaXM7XG4gICAgICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgIGFnZW50LmVtaXQoXCJkcmFpblwiLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgIGFnZW50LmVtaXQoXCJjb25uZWN0XCIsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgICAgICBhZ2VudC5lbWl0KFwiZGlzY29ubmVjdFwiLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10sIGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgICAgIGFnZW50LmVtaXQoXCJjb25uZWN0aW9uRXJyb3JcIiwgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdLCBlcnIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZ2V0IFtrUnVubmluZ10oKSB7XG4gICAgICAgIGxldCByZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpO1xuICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIHJldCArPSBjbGllbnRba1J1bm5pbmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcikge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAob3B0cy5vcmlnaW4gJiYgKHR5cGVvZiBvcHRzLm9yaWdpbiA9PT0gXCJzdHJpbmdcIiB8fCBvcHRzLm9yaWdpbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgICBrZXkgPSBTdHJpbmcob3B0cy5vcmlnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm9wdHMub3JpZ2luIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIFVSTC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmID0gdGhpc1trQ2xpZW50c10uZ2V0KGtleSk7XG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsO1xuICAgICAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3B0cy5vcmlnaW4sIHRoaXNba09wdGlvbnNdKS5vbihcImRyYWluXCIsIHRoaXNba09uRHJhaW5dKS5vbihcImNvbm5lY3RcIiwgdGhpc1trT25Db25uZWN0XSkub24oXCJkaXNjb25uZWN0XCIsIHRoaXNba09uRGlzY29ubmVjdF0pLm9uKFwiY29ubmVjdGlvbkVycm9yXCIsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSk7XG4gICAgICAgICAgdGhpc1trQ2xpZW50c10uc2V0KGtleSwgbmV3IFdlYWtSZWYyKGRpc3BhdGNoZXIpKTtcbiAgICAgICAgICB0aGlzW2tGaW5hbGl6ZXJdLnJlZ2lzdGVyKGRpc3BhdGNoZXIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdIH0gPSBvcHRzO1xuICAgICAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgbWF4UmVkaXJlY3Rpb25zICE9PSAwKSB7XG4gICAgICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH07XG4gICAgICAgICAgaGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIodGhpcywgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrQ2xvc2VdKCkge1xuICAgICAgICBjb25zdCBjbG9zZVByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgY2xvc2VQcm9taXNlcy5wdXNoKGNsaWVudC5jbG9zZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcyk7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Rlc3Ryb3ldKGVycikge1xuICAgICAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKTtcbiAgICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChjbGllbnQuZGVzdHJveShlcnIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShBZ2VudCwgXCJBZ2VudFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBBZ2VudDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9yZWFkYWJsZS5qc1xudmFyIHJlcXVpcmVfcmVhZGFibGUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgdmFyIHsgUmVxdWVzdEFib3J0ZWRFcnJvciwgTm90U3VwcG9ydGVkRXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IFJlYWRhYmxlU3RyZWFtRnJvbSwgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgQmxvYjtcbiAgICB2YXIga0NvbnN1bWUgPSBTeW1ib2woXCJrQ29uc3VtZVwiKTtcbiAgICB2YXIga1JlYWRpbmcgPSBTeW1ib2woXCJrUmVhZGluZ1wiKTtcbiAgICB2YXIga0JvZHkgPSBTeW1ib2woXCJrQm9keVwiKTtcbiAgICB2YXIga0Fib3J0ID0gU3ltYm9sKFwiYWJvcnRcIik7XG4gICAgdmFyIGtDb250ZW50VHlwZSA9IFN5bWJvbChcImtDb250ZW50VHlwZVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlc3VtZSwgYWJvcnQsIGNvbnRlbnRUeXBlID0gXCJcIikge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICAgICAgcmVhZDogcmVzdW1lLFxuICAgICAgICAgIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzW2tBYm9ydF0gPSBhYm9ydDtcbiAgICAgICAgdGhpc1trQ29uc3VtZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tCb2R5XSA9IG51bGw7XG4gICAgICAgIHRoaXNba0NvbnRlbnRUeXBlXSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzW2tSZWFkaW5nXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZGVzdHJveShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXNba0Fib3J0XSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5kZXN0cm95KGVycik7XG4gICAgICB9XG4gICAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChldiA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldiA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIG9uKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChldiA9PT0gXCJkYXRhXCIgfHwgZXYgPT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgIHRoaXNba1JlYWRpbmddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIub24oZXYsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgYWRkTGlzdGVuZXIoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXYsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgb2ZmKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgLi4uYXJncyk7XG4gICAgICAgIGlmIChldiA9PT0gXCJkYXRhXCIgfHwgZXYgPT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgIHRoaXNba1JlYWRpbmddID0gdGhpcy5saXN0ZW5lckNvdW50KFwiZGF0YVwiKSA+IDAgfHwgdGhpcy5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIikgPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICByZW1vdmVMaXN0ZW5lcihldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXYsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgcHVzaChjaHVuaykge1xuICAgICAgICBpZiAodGhpc1trQ29uc3VtZV0gJiYgY2h1bmsgIT09IG51bGwgJiYgdGhpcy5yZWFkYWJsZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN1bWVQdXNoKHRoaXNba0NvbnN1bWVdLCBjaHVuayk7XG4gICAgICAgICAgcmV0dXJuIHRoaXNba1JlYWRpbmddID8gc3VwZXIucHVzaChjaHVuaykgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIHRleHQoKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lKHRoaXMsIFwidGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGpzb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lKHRoaXMsIFwianNvblwiKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGJsb2IoKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lKHRoaXMsIFwiYmxvYlwiKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGFycmF5QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gY29uc3VtZSh0aGlzLCBcImFycmF5QnVmZmVyXCIpO1xuICAgICAgfVxuICAgICAgYXN5bmMgZm9ybURhdGEoKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgZ2V0IGJvZHlVc2VkKCkge1xuICAgICAgICByZXR1cm4gdXRpbDIuaXNEaXN0dXJiZWQodGhpcyk7XG4gICAgICB9XG4gICAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKCF0aGlzW2tCb2R5XSkge1xuICAgICAgICAgIHRoaXNba0JvZHldID0gUmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpO1xuICAgICAgICAgIGlmICh0aGlzW2tDb25zdW1lXSkge1xuICAgICAgICAgICAgdGhpc1trQm9keV0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBhc3NlcnQodGhpc1trQm9keV0ubG9ja2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0JvZHldO1xuICAgICAgfVxuICAgICAgYXN5bmMgZHVtcChvcHRzKSB7XG4gICAgICAgIGxldCBsaW1pdCA9IG9wdHMgJiYgTnVtYmVyLmlzRmluaXRlKG9wdHMubGltaXQpID8gb3B0cy5saW1pdCA6IDI2MjE0NDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxpbWl0IC09IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgXCJCb2R5UmVhZGFibGVcIik7XG4gICAgZnVuY3Rpb24gaXNMb2NrZWQoc2VsZjIpIHtcbiAgICAgIHJldHVybiBzZWxmMltrQm9keV0gJiYgc2VsZjJba0JvZHldLmxvY2tlZCA9PT0gdHJ1ZSB8fCBzZWxmMltrQ29uc3VtZV07XG4gICAgfVxuICAgIF9fbmFtZShpc0xvY2tlZCwgXCJpc0xvY2tlZFwiKTtcbiAgICBmdW5jdGlvbiBpc1VudXNhYmxlKHNlbGYyKSB7XG4gICAgICByZXR1cm4gdXRpbDIuaXNEaXN0dXJiZWQoc2VsZjIpIHx8IGlzTG9ja2VkKHNlbGYyKTtcbiAgICB9XG4gICAgX19uYW1lKGlzVW51c2FibGUsIFwiaXNVbnVzYWJsZVwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lKHN0cmVhbTIsIHR5cGUpIHtcbiAgICAgIGlmIChpc1VudXNhYmxlKHN0cmVhbTIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bnVzYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydCghc3RyZWFtMltrQ29uc3VtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RyZWFtMltrQ29uc3VtZV0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdHJlYW06IHN0cmVhbTIsXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHN0cmVhbTIub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBlcnIpO1xuICAgICAgICB9KS5vbihcImNsb3NlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzW2tDb25zdW1lXS5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNvbnN1bWVTdGFydCwgc3RyZWFtMltrQ29uc3VtZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShjb25zdW1lLCBcImNvbnN1bWVcIik7XG4gICAgZnVuY3Rpb24gY29uc3VtZVN0YXJ0KGNvbnN1bWUyKSB7XG4gICAgICBpZiAoY29uc3VtZTIuYm9keSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IF9yZWFkYWJsZVN0YXRlOiBzdGF0ZSB9ID0gY29uc3VtZTIuc3RyZWFtO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBzdGF0ZS5idWZmZXIpIHtcbiAgICAgICAgY29uc3VtZVB1c2goY29uc3VtZTIsIGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3VtZTIuc3RyZWFtLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWUyLnN0cmVhbS5yZXN1bWUoKTtcbiAgICAgIHdoaWxlIChjb25zdW1lMi5zdHJlYW0ucmVhZCgpICE9IG51bGwpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGNvbnN1bWVTdGFydCwgXCJjb25zdW1lU3RhcnRcIik7XG4gICAgZnVuY3Rpb24gY29uc3VtZUVuZChjb25zdW1lMikge1xuICAgICAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW06IHN0cmVhbTIsIGxlbmd0aCB9ID0gY29uc3VtZTI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICByZXNvbHZlKHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoYm9keSkpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImpzb25cIikge1xuICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShCdWZmZXIuY29uY2F0KGJvZHkpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhcnJheUJ1ZmZlclwiKSB7XG4gICAgICAgICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBib2R5KSB7XG4gICAgICAgICAgICBkc3Quc2V0KGJ1ZiwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYmxvYlwiKSB7XG4gICAgICAgICAgaWYgKCFCbG9iKSB7XG4gICAgICAgICAgICBCbG9iID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CbG9iO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKG5ldyBCbG9iKGJvZHksIHsgdHlwZTogc3RyZWFtMltrQ29udGVudFR5cGVdIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdW1lRmluaXNoKGNvbnN1bWUyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdHJlYW0yLmRlc3Ryb3koZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGNvbnN1bWVFbmQsIFwiY29uc3VtZUVuZFwiKTtcbiAgICBmdW5jdGlvbiBjb25zdW1lUHVzaChjb25zdW1lMiwgY2h1bmspIHtcbiAgICAgIGNvbnN1bWUyLmxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICBjb25zdW1lMi5ib2R5LnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBfX25hbWUoY29uc3VtZVB1c2gsIFwiY29uc3VtZVB1c2hcIik7XG4gICAgZnVuY3Rpb24gY29uc3VtZUZpbmlzaChjb25zdW1lMiwgZXJyKSB7XG4gICAgICBpZiAoY29uc3VtZTIuYm9keSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnN1bWUyLnJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3VtZTIucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3VtZTIudHlwZSA9IG51bGw7XG4gICAgICBjb25zdW1lMi5zdHJlYW0gPSBudWxsO1xuICAgICAgY29uc3VtZTIucmVzb2x2ZSA9IG51bGw7XG4gICAgICBjb25zdW1lMi5yZWplY3QgPSBudWxsO1xuICAgICAgY29uc3VtZTIubGVuZ3RoID0gMDtcbiAgICAgIGNvbnN1bWUyLmJvZHkgPSBudWxsO1xuICAgIH1cbiAgICBfX25hbWUoY29uc3VtZUZpbmlzaCwgXCJjb25zdW1lRmluaXNoXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qc1xudmFyIHJlcXVpcmVfYWJvcnRfc2lnbmFsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgeyBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBrTGlzdGVuZXIgPSBTeW1ib2woXCJrTGlzdGVuZXJcIik7XG4gICAgdmFyIGtTaWduYWwgPSBTeW1ib2woXCJrU2lnbmFsXCIpO1xuICAgIGZ1bmN0aW9uIGFib3J0KHNlbGYyKSB7XG4gICAgICBpZiAoc2VsZjIuYWJvcnQpIHtcbiAgICAgICAgc2VsZjIuYWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYyLm9uRXJyb3IobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShhYm9ydCwgXCJhYm9ydFwiKTtcbiAgICBmdW5jdGlvbiBhZGRTaWduYWwoc2VsZjIsIHNpZ25hbCkge1xuICAgICAgc2VsZjJba1NpZ25hbF0gPSBudWxsO1xuICAgICAgc2VsZjJba0xpc3RlbmVyXSA9IG51bGw7XG4gICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnQoc2VsZjIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmMltrU2lnbmFsXSA9IHNpZ25hbDtcbiAgICAgIHNlbGYyW2tMaXN0ZW5lcl0gPSAoKSA9PiB7XG4gICAgICAgIGFib3J0KHNlbGYyKTtcbiAgICAgIH07XG4gICAgICBpZiAoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gc2VsZjJba1NpZ25hbF0pIHtcbiAgICAgICAgc2VsZjJba1NpZ25hbF0uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHNlbGYyW2tMaXN0ZW5lcl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZjJba1NpZ25hbF0uYWRkTGlzdGVuZXIoXCJhYm9ydFwiLCBzZWxmMltrTGlzdGVuZXJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGFkZFNpZ25hbCwgXCJhZGRTaWduYWxcIik7XG4gICAgZnVuY3Rpb24gcmVtb3ZlU2lnbmFsKHNlbGYyKSB7XG4gICAgICBpZiAoIXNlbGYyW2tTaWduYWxdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBzZWxmMltrU2lnbmFsXSkge1xuICAgICAgICBzZWxmMltrU2lnbmFsXS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgc2VsZjJba0xpc3RlbmVyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmMltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsIHNlbGYyW2tMaXN0ZW5lcl0pO1xuICAgICAgfVxuICAgICAgc2VsZjJba1NpZ25hbF0gPSBudWxsO1xuICAgICAgc2VsZjJba0xpc3RlbmVyXSA9IG51bGw7XG4gICAgfVxuICAgIF9fbmFtZShyZW1vdmVTaWduYWwsIFwicmVtb3ZlU2lnbmFsXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGFkZFNpZ25hbCxcbiAgICAgIHJlbW92ZVNpZ25hbFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanNcbnZhciByZXF1aXJlX2FwaV9yZXF1ZXN0ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBSZWFkYWJsZSA9IHJlcXVpcmVfcmVhZGFibGUoKTtcbiAgICB2YXIge1xuICAgICAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICAgICAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3JcbiAgICB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgQXN5bmNSZXNvdXJjZTogQXN5bmNSZXNvdXJjZTIgfSA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbiAgICB2YXIgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZV9hYm9ydF9zaWduYWwoKTtcbiAgICB2YXIgUmVxdWVzdEhhbmRsZXIyID0gY2xhc3MgZXh0ZW5kcyBBc3luY1Jlc291cmNlMiB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yIH0gPSBvcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInNpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJDT05ORUNUXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgbWV0aG9kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvbkluZm8gY2FsbGJhY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1cGVyKFwiVU5ESUNJX1JFUVVFU1RcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShib2R5Lm9uKFwiZXJyb3JcIiwgdXRpbDIubm9wKSwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGw7XG4gICAgICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy50cmFpbGVycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvcjtcbiAgICAgICAgaWYgKHV0aWwyLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgICAgYm9keS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpO1xuICAgICAgfVxuICAgICAgb25Db25uZWN0KGFib3J0LCBjb250ZXh0Mykge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDM7XG4gICAgICB9XG4gICAgICBvbkhlYWRlcnMoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgYWJvcnQsIGNvbnRleHQ6IGNvbnRleHQzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyczIgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVyczogaGVhZGVyczIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gdXRpbDIucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgUmVhZGFibGUocmVzdW1lLCBhYm9ydCwgY29udGVudFR5cGUpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXMgPSBib2R5O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoXG4gICAgICAgICAgICAgIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgdHJhaWxlcnM6IHRoaXMudHJhaWxlcnMsXG4gICAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dDNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25EYXRhKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgICAgb25Db21wbGV0ZSh0cmFpbGVycykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICB1dGlsMi5wYXJzZUhlYWRlcnModHJhaWxlcnMsIHRoaXMudHJhaWxlcnMpO1xuICAgICAgICByZXMucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzO1xuICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShyZXMsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFJlcXVlc3RIYW5kbGVyMiwgXCJSZXF1ZXN0SGFuZGxlclwiKTtcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2soeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfSkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNCB8fCAhY29udGVudFR5cGUpIHtcbiAgICAgICAgYm9keS5kdW1wKCk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogXCJcIn1gLCBzdGF0dXNDb2RlLCBoZWFkZXJzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBib2R5Lmpzb24oKTtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6IFwiXCJ9YCwgc3RhdHVzQ29kZSwgaGVhZGVycywgcGF5bG9hZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUuc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGJvZHkudGV4dCgpO1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogXCJcIn1gLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIH1cbiAgICAgIGJvZHkuZHVtcCgpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiBcIlwifWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKTtcbiAgICB9XG4gICAgX19uYW1lKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgXCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2tcIik7XG4gICAgZnVuY3Rpb24gcmVxdWVzdDIob3B0cywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVxdWVzdDIuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFJlcXVlc3RIYW5kbGVyMihvcHRzLCBjYWxsYmFjaykpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlcXVlc3QyLCBcInJlcXVlc3RcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWVzdDI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qc1xudmFyIHJlcXVpcmVfYXBpX3N0cmVhbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktc3RyZWFtLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7XG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgICAgIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICAgICAgUmVxdWVzdEFib3J0ZWRFcnJvclxuICAgIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBBc3luY1Jlc291cmNlOiBBc3luY1Jlc291cmNlMiB9ID0gcmVxdWlyZShcImFzeW5jX2hvb2tzXCIpO1xuICAgIHZhciB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlX2Fib3J0X3NpZ25hbCgpO1xuICAgIHZhciBTdHJlYW1IYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBBc3luY1Jlc291cmNlMiB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZhY3RvcnlcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiQ09OTkVDVFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1ldGhvZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25JbmZvIGNhbGxiYWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXBlcihcIlVORElDSV9TVFJFQU1cIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShib2R5Lm9uKFwiZXJyb3JcIiwgdXRpbDIubm9wKSwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGw7XG4gICAgICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFpbGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGw7XG4gICAgICAgIGlmICh1dGlsMi5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICAgIGJvZHkub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIG9uQ29ubmVjdChhYm9ydCwgY29udGV4dDMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ID0gYWJvcnQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQzO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSkge1xuICAgICAgICBjb25zdCB7IGZhY3RvcnksIG9wYXF1ZSwgY29udGV4dDogY29udGV4dDMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzMiA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSBcInJhd1wiID8gdXRpbDIucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbDIucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzOiBoZWFkZXJzMiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoZmFjdG9yeSwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dDNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzIHx8IHR5cGVvZiByZXMud3JpdGUgIT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVzLmVuZCAhPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZXMub24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcihcImV4cGVjdGVkIFdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5vbihcImRyYWluXCIsIHJlc3VtZSk7XG4gICAgICAgIGZpbmlzaGVkKHJlcywgeyByZWFkYWJsZTogZmFsc2UgfSwgKGVycikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlczogcmVzMiwgb3BhcXVlOiBvcGFxdWUyLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICAgIGlmIChlcnIgfHwgIXJlczIucmVhZGFibGUpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmVzMiwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciB8fCBudWxsLCB7IG9wYXF1ZTogb3BhcXVlMiwgdHJhaWxlcnMgfSk7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgbmVlZERyYWluID0gcmVzLndyaXRhYmxlTmVlZERyYWluICE9PSB2b2lkIDAgPyByZXMud3JpdGFibGVOZWVkRHJhaW4gOiByZXMuX3dyaXRhYmxlU3RhdGUgJiYgcmVzLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbjtcbiAgICAgICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG9uRGF0YShjaHVuaykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlcy53cml0ZShjaHVuayk7XG4gICAgICB9XG4gICAgICBvbkNvbXBsZXRlKHRyYWlsZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzO1xuICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsMi5wYXJzZUhlYWRlcnModHJhaWxlcnMpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgICB9XG4gICAgICBvbkVycm9yKGVycikge1xuICAgICAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIG9wYXF1ZSwgYm9keSB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBudWxsO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgdGhpcy5yZXMgPSBudWxsO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmVzLCBlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICAgIHV0aWwyLmRlc3Ryb3koYm9keSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFN0cmVhbUhhbmRsZXIsIFwiU3RyZWFtSGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiBzdHJlYW0yKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHN0cmVhbTIuY2FsbCh0aGlzLCBvcHRzLCBmYWN0b3J5LCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFN0cmVhbUhhbmRsZXIob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzdHJlYW0yLCBcInN0cmVhbVwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzdHJlYW0yO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qc1xudmFyIHJlcXVpcmVfYXBpX3BpcGVsaW5lID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIge1xuICAgICAgUmVhZGFibGUsXG4gICAgICBEdXBsZXgsXG4gICAgICBQYXNzVGhyb3VnaFxuICAgIH0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuICAgIHZhciB7XG4gICAgICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgICAgIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICAgICAgUmVxdWVzdEFib3J0ZWRFcnJvclxuICAgIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBBc3luY1Jlc291cmNlOiBBc3luY1Jlc291cmNlMiB9ID0gcmVxdWlyZShcImFzeW5jX2hvb2tzXCIpO1xuICAgIHZhciB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlX2Fib3J0X3NpZ25hbCgpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciBrUmVzdW1lID0gU3ltYm9sKFwicmVzdW1lXCIpO1xuICAgIHZhciBQaXBlbGluZVJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIFJlYWRhYmxlIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pO1xuICAgICAgICB0aGlzW2tSZXN1bWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIF9yZWFkKCkge1xuICAgICAgICBjb25zdCB7IFtrUmVzdW1lXTogcmVzdW1lIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmVzdW1lKSB7XG4gICAgICAgICAgdGhpc1trUmVzdW1lXSA9IG51bGw7XG4gICAgICAgICAgcmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9kZXN0cm95KGVyciwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcmVhZCgpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKFBpcGVsaW5lUmVxdWVzdCwgXCJQaXBlbGluZVJlcXVlc3RcIik7XG4gICAgdmFyIFBpcGVsaW5lUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlYWRhYmxlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlc3VtZSkge1xuICAgICAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pO1xuICAgICAgICB0aGlzW2tSZXN1bWVdID0gcmVzdW1lO1xuICAgICAgfVxuICAgICAgX3JlYWQoKSB7XG4gICAgICAgIHRoaXNba1Jlc3VtZV0oKTtcbiAgICAgIH1cbiAgICAgIF9kZXN0cm95KGVyciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShQaXBlbGluZVJlc3BvbnNlLCBcIlBpcGVsaW5lUmVzcG9uc2VcIik7XG4gICAgdmFyIFBpcGVsaW5lSGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgQXN5bmNSZXNvdXJjZTIge1xuICAgICAgY29uc3RydWN0b3Iob3B0cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhbmRsZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0cztcbiAgICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJDT05ORUNUXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb25JbmZvIGNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKFwiVU5ESUNJX1BJUEVMSU5FXCIpO1xuICAgICAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsO1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5yZXEgPSBuZXcgUGlwZWxpbmVSZXF1ZXN0KCkub24oXCJlcnJvclwiLCB1dGlsMi5ub3ApO1xuICAgICAgICB0aGlzLnJldCA9IG5ldyBEdXBsZXgoe1xuICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChib2R5ICYmIGJvZHkucmVzdW1lKSB7XG4gICAgICAgICAgICAgIGJvZHkucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHJlcS5wdXNoKGNodW5rLCBlbmNvZGluZykgfHwgcmVxLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVxW2tSZXN1bWVdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiAoZXJyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBib2R5LCByZXEsIHJlcywgcmV0LCBhYm9ydCB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZXJyICYmICFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0ICYmIGVycikge1xuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShib2R5LCBlcnIpO1xuICAgICAgICAgICAgdXRpbDIuZGVzdHJveShyZXEsIGVycik7XG4gICAgICAgICAgICB1dGlsMi5kZXN0cm95KHJlcywgZXJyKTtcbiAgICAgICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbihcInByZWZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXM7XG4gICAgICAgICAgcmVxLnB1c2gobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpO1xuICAgICAgfVxuICAgICAgb25Db25uZWN0KGFib3J0LCBjb250ZXh0Mykge1xuICAgICAgICBjb25zdCB7IHJldCwgcmVzIH0gPSB0aGlzO1xuICAgICAgICBhc3NlcnQoIXJlcywgXCJwaXBlbGluZSBjYW5ub3QgYmUgcmV0cmllZFwiKTtcbiAgICAgICAgaWYgKHJldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDM7XG4gICAgICB9XG4gICAgICBvbkhlYWRlcnMoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lKSB7XG4gICAgICAgIGNvbnN0IHsgb3BhcXVlLCBoYW5kbGVyLCBjb250ZXh0OiBjb250ZXh0MyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzID0gbmV3IFBpcGVsaW5lUmVzcG9uc2UocmVzdW1lKTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09IFwicmF3XCIgPyB1dGlsMi5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsMi5wYXJzZUhlYWRlcnMocmF3SGVhZGVycyk7XG4gICAgICAgICAgYm9keSA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGhhbmRsZXIsIG51bGwsIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgICAgYm9keTogdGhpcy5yZXMsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0M1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLnJlcy5vbihcImVycm9yXCIsIHV0aWwyLm5vcCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYm9keSB8fCB0eXBlb2YgYm9keS5vbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKFwiZXhwZWN0ZWQgUmVhZGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZXQsIGJvZHk6IGJvZHkyIH0gPSB0aGlzO1xuICAgICAgICAgIGlmICghcmV0LnB1c2goY2h1bmspICYmIGJvZHkyLnBhdXNlKSB7XG4gICAgICAgICAgICBib2R5Mi5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXM7XG4gICAgICAgICAgdXRpbDIuZGVzdHJveShyZXQsIGVycik7XG4gICAgICAgIH0pLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpcztcbiAgICAgICAgICByZXQucHVzaChudWxsKTtcbiAgICAgICAgfSkub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICAgIHV0aWwyLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgb25EYXRhKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgICAgb25Db21wbGV0ZSh0cmFpbGVycykge1xuICAgICAgICBjb25zdCB7IHJlcyB9ID0gdGhpcztcbiAgICAgICAgcmVzLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICBvbkVycm9yKGVycikge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdXRpbDIuZGVzdHJveShyZXQsIGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUGlwZWxpbmVIYW5kbGVyLCBcIlBpcGVsaW5lSGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiBwaXBlbGluZShvcHRzLCBoYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgYm9keTogcGlwZWxpbmVIYW5kbGVyLnJlcSB9LCBwaXBlbGluZUhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gcGlwZWxpbmVIYW5kbGVyLnJldDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKCkuZGVzdHJveShlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocGlwZWxpbmUsIFwicGlwZWxpbmVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcGlwZWxpbmU7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanNcbnZhciByZXF1aXJlX2FwaV91cGdyYWRlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS11cGdyYWRlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBBc3luY1Jlc291cmNlOiBBc3luY1Jlc291cmNlMiB9ID0gcmVxdWlyZShcImFzeW5jX2hvb2tzXCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZV9hYm9ydF9zaWduYWwoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgVXBncmFkZUhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIEFzeW5jUmVzb3VyY2UyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3B0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0cztcbiAgICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoXCJVTkRJQ0lfVVBHUkFERVwiKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmFib3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbCk7XG4gICAgICB9XG4gICAgICBvbkNvbm5lY3QoYWJvcnQsIGNvbnRleHQzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hYm9ydCA9IGFib3J0O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKCkge1xuICAgICAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoXCJiYWQgdXBncmFkZVwiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIG9uVXBncmFkZShzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0OiBjb250ZXh0MyB9ID0gdGhpcztcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHN0YXR1c0NvZGUsIDEwMSk7XG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJyYXdcIiA/IHV0aWwyLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwyLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKTtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dDNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvbkVycm9yKGVycikge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXM7XG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShVcGdyYWRlSGFuZGxlciwgXCJVcGdyYWRlSGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiB1cGdyYWRlKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHVwZ3JhZGUuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVwZ3JhZGVIYW5kbGVyID0gbmV3IFVwZ3JhZGVIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgICAgdXBncmFkZTogb3B0cy5wcm90b2NvbCB8fCBcIldlYnNvY2tldFwiXG4gICAgICAgIH0sIHVwZ3JhZGVIYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh1cGdyYWRlLCBcInVwZ3JhZGVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gdXBncmFkZTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktY29ubmVjdC5qc1xudmFyIHJlcXVpcmVfYXBpX2Nvbm5lY3QgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciB7IEFzeW5jUmVzb3VyY2U6IEFzeW5jUmVzb3VyY2UyIH0gPSByZXF1aXJlKFwiYXN5bmNfaG9va3NcIik7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlX2Fib3J0X3NpZ25hbCgpO1xuICAgIHZhciBDb25uZWN0SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgQXN5bmNSZXNvdXJjZTIge1xuICAgICAgY29uc3RydWN0b3Iob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzO1xuICAgICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInNpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcIlVORElDSV9DT05ORUNUXCIpO1xuICAgICAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsO1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuYWJvcnQgPSBudWxsO1xuICAgICAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIG9uQ29ubmVjdChhYm9ydCwgY29udGV4dDMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ID0gYWJvcnQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQzO1xuICAgICAgfVxuICAgICAgb25IZWFkZXJzKCkge1xuICAgICAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoXCJiYWQgY29ubmVjdFwiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIG9uVXBncmFkZShzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0OiBjb250ZXh0MyB9ID0gdGhpcztcbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSBcInJhd1wiID8gdXRpbDIucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbDIucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpO1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzO1xuICAgICAgICByZW1vdmVTaWduYWwodGhpcyk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQ29ubmVjdEhhbmRsZXIsIFwiQ29ubmVjdEhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gY29ubmVjdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IG5ldyBDb25uZWN0SGFuZGxlcihvcHRzLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6IFwiQ09OTkVDVFwiIH0sIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb25uZWN0LCBcImNvbm5lY3RcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29ubmVjdDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9pbmRleC5qc1xudmFyIHJlcXVpcmVfYXBpID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWlyZV9hcGlfcmVxdWVzdCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5zdHJlYW0gPSByZXF1aXJlX2FwaV9zdHJlYW0oKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlX2FwaV9waXBlbGluZSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy51cGdyYWRlID0gcmVxdWlyZV9hcGlfdXBncmFkZSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5jb25uZWN0ID0gcmVxdWlyZV9hcGlfY29ubmVjdCgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qc1xudmFyIHJlcXVpcmVfbW9ja19lcnJvcnMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlX2Vycm9ycygpO1xuICAgIHZhciBNb2NrTm90TWF0Y2hlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2NrTm90TWF0Y2hlZEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJNb2NrTm90TWF0Y2hlZEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJUaGUgcmVxdWVzdCBkb2VzIG5vdCBtYXRjaCBhbnkgcmVnaXN0ZXJlZCBtb2NrIGRpc3BhdGNoZXNcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE1vY2tOb3RNYXRjaGVkRXJyb3IsIFwiTW9ja05vdE1hdGNoZWRFcnJvclwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBNb2NrTm90TWF0Y2hlZEVycm9yXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1zeW1ib2xzLmpzXG52YXIgcmVxdWlyZV9tb2NrX3N5bWJvbHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBrQWdlbnQ6IFN5bWJvbChcImFnZW50XCIpLFxuICAgICAga09wdGlvbnM6IFN5bWJvbChcIm9wdGlvbnNcIiksXG4gICAgICBrRmFjdG9yeTogU3ltYm9sKFwiZmFjdG9yeVwiKSxcbiAgICAgIGtEaXNwYXRjaGVzOiBTeW1ib2woXCJkaXNwYXRjaGVzXCIpLFxuICAgICAga0Rpc3BhdGNoS2V5OiBTeW1ib2woXCJkaXNwYXRjaCBrZXlcIiksXG4gICAgICBrRGVmYXVsdEhlYWRlcnM6IFN5bWJvbChcImRlZmF1bHQgaGVhZGVyc1wiKSxcbiAgICAgIGtEZWZhdWx0VHJhaWxlcnM6IFN5bWJvbChcImRlZmF1bHQgdHJhaWxlcnNcIiksXG4gICAgICBrQ29udGVudExlbmd0aDogU3ltYm9sKFwiY29udGVudCBsZW5ndGhcIiksXG4gICAgICBrTW9ja0FnZW50OiBTeW1ib2woXCJtb2NrIGFnZW50XCIpLFxuICAgICAga01vY2tBZ2VudFNldDogU3ltYm9sKFwibW9jayBhZ2VudCBzZXRcIiksXG4gICAgICBrTW9ja0FnZW50R2V0OiBTeW1ib2woXCJtb2NrIGFnZW50IGdldFwiKSxcbiAgICAgIGtNb2NrRGlzcGF0Y2g6IFN5bWJvbChcIm1vY2sgZGlzcGF0Y2hcIiksXG4gICAgICBrQ2xvc2U6IFN5bWJvbChcImNsb3NlXCIpLFxuICAgICAga09yaWdpbmFsQ2xvc2U6IFN5bWJvbChcIm9yaWdpbmFsIGFnZW50IGNsb3NlXCIpLFxuICAgICAga09yaWdpbjogU3ltYm9sKFwib3JpZ2luXCIpLFxuICAgICAga0lzTW9ja0FjdGl2ZTogU3ltYm9sKFwiaXMgbW9jayBhY3RpdmVcIiksXG4gICAgICBrTmV0Q29ubmVjdDogU3ltYm9sKFwibmV0IGNvbm5lY3RcIiksXG4gICAgICBrR2V0TmV0Q29ubmVjdDogU3ltYm9sKFwiZ2V0IG5ldCBjb25uZWN0XCIpLFxuICAgICAga0Nvbm5lY3RlZDogU3ltYm9sKFwiY29ubmVjdGVkXCIpXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay11dGlscy5qc1xudmFyIHJlcXVpcmVfbW9ja191dGlscyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay11dGlscy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBNb2NrTm90TWF0Y2hlZEVycm9yIH0gPSByZXF1aXJlX21vY2tfZXJyb3JzKCk7XG4gICAgdmFyIHtcbiAgICAgIGtEaXNwYXRjaGVzLFxuICAgICAga01vY2tBZ2VudCxcbiAgICAgIGtPcmlnaW5hbERpc3BhdGNoLFxuICAgICAga09yaWdpbixcbiAgICAgIGtHZXROZXRDb25uZWN0XG4gICAgfSA9IHJlcXVpcmVfbW9ja19zeW1ib2xzKCk7XG4gICAgdmFyIHsgYnVpbGRVUkwsIG5vcCB9ID0gcmVxdWlyZV91dGlsMigpO1xuICAgIGZ1bmN0aW9uIG1hdGNoVmFsdWUobWF0Y2gsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIG1hdGNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnRlc3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtYXRjaCh2YWx1ZSkgPT09IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShtYXRjaFZhbHVlLCBcIm1hdGNoVmFsdWVcIik7XG4gICAgZnVuY3Rpb24gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhoZWFkZXJzKS5tYXAoKFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgX19uYW1lKGxvd2VyQ2FzZUVudHJpZXMsIFwibG93ZXJDYXNlRW50cmllc1wiKTtcbiAgICBmdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUoaGVhZGVycywga2V5KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaGVhZGVyc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBrZXkudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpW2tleS50b0xvY2FsZUxvd2VyQ2FzZSgpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGdldEhlYWRlckJ5TmFtZSwgXCJnZXRIZWFkZXJCeU5hbWVcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRIZWFkZXJzRnJvbUFycmF5KGhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGNsb25lMiA9IGhlYWRlcnMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjbG9uZTIubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgICAgIGVudHJpZXMucHVzaChbY2xvbmUyW2luZGV4XSwgY2xvbmUyW2luZGV4ICsgMV1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZEhlYWRlcnNGcm9tQXJyYXksIFwiYnVpbGRIZWFkZXJzRnJvbUFycmF5XCIpO1xuICAgIGZ1bmN0aW9uIG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gyLCBoZWFkZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaDIuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9ja0Rpc3BhdGNoMi5oZWFkZXJzKGhlYWRlcnMgPyBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpIDoge30pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2gyLmhlYWRlcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnMgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vY2tEaXNwYXRjaDIuaGVhZGVycyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaDIuaGVhZGVycykpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyVmFsdWUgPSBnZXRIZWFkZXJCeU5hbWUoaGVhZGVycywgbWF0Y2hIZWFkZXJOYW1lKTtcbiAgICAgICAgaWYgKCFtYXRjaFZhbHVlKG1hdGNoSGVhZGVyVmFsdWUsIGhlYWRlclZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9fbmFtZShtYXRjaEhlYWRlcnMsIFwibWF0Y2hIZWFkZXJzXCIpO1xuICAgIGZ1bmN0aW9uIHNhZmVVcmwocGF0aDcpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aDcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg3O1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aFNlZ21lbnRzID0gcGF0aDcuc3BsaXQoXCI/XCIpO1xuICAgICAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg3O1xuICAgICAgfVxuICAgICAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSk7XG4gICAgICBxcC5zb3J0KCk7XG4gICAgICByZXR1cm4gWy4uLnBhdGhTZWdtZW50cywgcXAudG9TdHJpbmcoKV0uam9pbihcIj9cIik7XG4gICAgfVxuICAgIF9fbmFtZShzYWZlVXJsLCBcInNhZmVVcmxcIik7XG4gICAgZnVuY3Rpb24gbWF0Y2hLZXkobW9ja0Rpc3BhdGNoMiwgeyBwYXRoOiBwYXRoNywgbWV0aG9kLCBib2R5LCBoZWFkZXJzIH0pIHtcbiAgICAgIGNvbnN0IHBhdGhNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoMi5wYXRoLCBwYXRoNyk7XG4gICAgICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoMi5tZXRob2QsIG1ldGhvZCk7XG4gICAgICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoMi5ib2R5ICE9PSBcInVuZGVmaW5lZFwiID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gyLmJvZHksIGJvZHkpIDogdHJ1ZTtcbiAgICAgIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gyLCBoZWFkZXJzKTtcbiAgICAgIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaDtcbiAgICB9XG4gICAgX19uYW1lKG1hdGNoS2V5LCBcIm1hdGNoS2V5XCIpO1xuICAgIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShkYXRhKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZ2V0UmVzcG9uc2VEYXRhLCBcImdldFJlc3BvbnNlRGF0YVwiKTtcbiAgICBmdW5jdGlvbiBnZXRNb2NrRGlzcGF0Y2gobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICAgICAgY29uc3QgYmFzZVBhdGggPSBrZXkucXVlcnkgPyBidWlsZFVSTChrZXkucGF0aCwga2V5LnF1ZXJ5KSA6IGtleS5wYXRoO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSBcInN0cmluZ1wiID8gc2FmZVVybChiYXNlUGF0aCkgOiBiYXNlUGF0aDtcbiAgICAgIGxldCBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgY29uc3VtZWQgfSkgPT4gIWNvbnN1bWVkKS5maWx0ZXIoKHsgcGF0aDogcGF0aDcgfSkgPT4gbWF0Y2hWYWx1ZShzYWZlVXJsKHBhdGg3KSwgcmVzb2x2ZWRQYXRoKSk7XG4gICAgICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApO1xuICAgICAgfVxuICAgICAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBtZXRob2QgfSkgPT4gbWF0Y2hWYWx1ZShtZXRob2QsIGtleS5tZXRob2QpKTtcbiAgICAgIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBtZXRob2QgJyR7a2V5Lm1ldGhvZH0nYCk7XG4gICAgICB9XG4gICAgICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IGJvZHkgfSkgPT4gdHlwZW9mIGJvZHkgIT09IFwidW5kZWZpbmVkXCIgPyBtYXRjaFZhbHVlKGJvZHksIGtleS5ib2R5KSA6IHRydWUpO1xuICAgICAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGJvZHkgJyR7a2V5LmJvZHl9J2ApO1xuICAgICAgfVxuICAgICAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigobW9ja0Rpc3BhdGNoMikgPT4gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaDIsIGtleS5oZWFkZXJzKSk7XG4gICAgICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgaGVhZGVycyAnJHt0eXBlb2Yga2V5LmhlYWRlcnMgPT09IFwib2JqZWN0XCIgPyBKU09OLnN0cmluZ2lmeShrZXkuaGVhZGVycykgOiBrZXkuaGVhZGVyc30nYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzWzBdO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0TW9ja0Rpc3BhdGNoLCBcImdldE1vY2tEaXNwYXRjaFwiKTtcbiAgICBmdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2gobW9ja0Rpc3BhdGNoZXMsIGtleSwgZGF0YSkge1xuICAgICAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfTtcbiAgICAgIGNvbnN0IHJlcGx5RGF0YSA9IHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIgPyB7IGNhbGxiYWNrOiBkYXRhIH0gOiB7IC4uLmRhdGEgfTtcbiAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfTtcbiAgICAgIG1vY2tEaXNwYXRjaGVzLnB1c2gobmV3TW9ja0Rpc3BhdGNoKTtcbiAgICAgIHJldHVybiBuZXdNb2NrRGlzcGF0Y2g7XG4gICAgfVxuICAgIF9fbmFtZShhZGRNb2NrRGlzcGF0Y2gsIFwiYWRkTW9ja0Rpc3BhdGNoXCIpO1xuICAgIGZ1bmN0aW9uIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gICAgICBjb25zdCBpbmRleCA9IG1vY2tEaXNwYXRjaGVzLmZpbmRJbmRleCgoZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgaWYgKCFkaXNwYXRjaC5jb25zdW1lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbW9ja0Rpc3BhdGNoZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGRlbGV0ZU1vY2tEaXNwYXRjaCwgXCJkZWxldGVNb2NrRGlzcGF0Y2hcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRLZXkob3B0cykge1xuICAgICAgY29uc3QgeyBwYXRoOiBwYXRoNywgbWV0aG9kLCBib2R5LCBoZWFkZXJzLCBxdWVyeTogcXVlcnkyIH0gPSBvcHRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogcGF0aDcsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5MlxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkS2V5LCBcImJ1aWxkS2V5XCIpO1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlS2V5VmFsdWVzKGRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGtleVZhbHVlUGFpcnMsIFtrZXksIHZhbHVlXSkgPT4gWy4uLmtleVZhbHVlUGFpcnMsIGtleSwgdmFsdWVdLCBbXSk7XG4gICAgfVxuICAgIF9fbmFtZShnZW5lcmF0ZUtleVZhbHVlcywgXCJnZW5lcmF0ZUtleVZhbHVlc1wiKTtcbiAgICBmdW5jdGlvbiBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpIHtcbiAgICAgIHN3aXRjaCAoc3RhdHVzQ29kZSkge1xuICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICByZXR1cm4gXCJDb250aW51ZVwiO1xuICAgICAgICBjYXNlIDEwMTpcbiAgICAgICAgICByZXR1cm4gXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCI7XG4gICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIHJldHVybiBcIlByb2Nlc3NpbmdcIjtcbiAgICAgICAgY2FzZSAxMDM6XG4gICAgICAgICAgcmV0dXJuIFwiRWFybHkgSGludHNcIjtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgcmV0dXJuIFwiT0tcIjtcbiAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgcmV0dXJuIFwiQ3JlYXRlZFwiO1xuICAgICAgICBjYXNlIDIwMjpcbiAgICAgICAgICByZXR1cm4gXCJBY2NlcHRlZFwiO1xuICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICByZXR1cm4gXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiO1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICByZXR1cm4gXCJObyBDb250ZW50XCI7XG4gICAgICAgIGNhc2UgMjA1OlxuICAgICAgICAgIHJldHVybiBcIlJlc2V0IENvbnRlbnRcIjtcbiAgICAgICAgY2FzZSAyMDY6XG4gICAgICAgICAgcmV0dXJuIFwiUGFydGlhbCBDb250ZW50XCI7XG4gICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIHJldHVybiBcIk11bHRpLVN0YXR1c1wiO1xuICAgICAgICBjYXNlIDIwODpcbiAgICAgICAgICByZXR1cm4gXCJBbHJlYWR5IFJlcG9ydGVkXCI7XG4gICAgICAgIGNhc2UgMjI2OlxuICAgICAgICAgIHJldHVybiBcIklNIFVzZWRcIjtcbiAgICAgICAgY2FzZSAzMDA6XG4gICAgICAgICAgcmV0dXJuIFwiTXVsdGlwbGUgQ2hvaWNlXCI7XG4gICAgICAgIGNhc2UgMzAxOlxuICAgICAgICAgIHJldHVybiBcIk1vdmVkIFBlcm1hbmVudGx5XCI7XG4gICAgICAgIGNhc2UgMzAyOlxuICAgICAgICAgIHJldHVybiBcIkZvdW5kXCI7XG4gICAgICAgIGNhc2UgMzAzOlxuICAgICAgICAgIHJldHVybiBcIlNlZSBPdGhlclwiO1xuICAgICAgICBjYXNlIDMwNDpcbiAgICAgICAgICByZXR1cm4gXCJOb3QgTW9kaWZpZWRcIjtcbiAgICAgICAgY2FzZSAzMDU6XG4gICAgICAgICAgcmV0dXJuIFwiVXNlIFByb3h5XCI7XG4gICAgICAgIGNhc2UgMzA2OlxuICAgICAgICAgIHJldHVybiBcInVudXNlZFwiO1xuICAgICAgICBjYXNlIDMwNzpcbiAgICAgICAgICByZXR1cm4gXCJUZW1wb3JhcnkgUmVkaXJlY3RcIjtcbiAgICAgICAgY2FzZSAzMDg6XG4gICAgICAgICAgcmV0dXJuIFwiUGVybWFuZW50IFJlZGlyZWN0XCI7XG4gICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgIHJldHVybiBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgIHJldHVybiBcIlVuYXV0aG9yaXplZFwiO1xuICAgICAgICBjYXNlIDQwMjpcbiAgICAgICAgICByZXR1cm4gXCJQYXltZW50IFJlcXVpcmVkXCI7XG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgIHJldHVybiBcIkZvcmJpZGRlblwiO1xuICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICByZXR1cm4gXCJOb3QgRm91bmRcIjtcbiAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgcmV0dXJuIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgICAgIGNhc2UgNDA2OlxuICAgICAgICAgIHJldHVybiBcIk5vdCBBY2NlcHRhYmxlXCI7XG4gICAgICAgIGNhc2UgNDA3OlxuICAgICAgICAgIHJldHVybiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCI7XG4gICAgICAgIGNhc2UgNDA4OlxuICAgICAgICAgIHJldHVybiBcIlJlcXVlc3QgVGltZW91dFwiO1xuICAgICAgICBjYXNlIDQwOTpcbiAgICAgICAgICByZXR1cm4gXCJDb25mbGljdFwiO1xuICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICByZXR1cm4gXCJHb25lXCI7XG4gICAgICAgIGNhc2UgNDExOlxuICAgICAgICAgIHJldHVybiBcIkxlbmd0aCBSZXF1aXJlZFwiO1xuICAgICAgICBjYXNlIDQxMjpcbiAgICAgICAgICByZXR1cm4gXCJQcmVjb25kaXRpb24gRmFpbGVkXCI7XG4gICAgICAgIGNhc2UgNDEzOlxuICAgICAgICAgIHJldHVybiBcIlBheWxvYWQgVG9vIExhcmdlXCI7XG4gICAgICAgIGNhc2UgNDE0OlxuICAgICAgICAgIHJldHVybiBcIlVSSSBUb28gTGFyZ2VcIjtcbiAgICAgICAgY2FzZSA0MTU6XG4gICAgICAgICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiO1xuICAgICAgICBjYXNlIDQxNjpcbiAgICAgICAgICByZXR1cm4gXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIjtcbiAgICAgICAgY2FzZSA0MTc6XG4gICAgICAgICAgcmV0dXJuIFwiRXhwZWN0YXRpb24gRmFpbGVkXCI7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgIHJldHVybiBcIkknbSBhIHRlYXBvdFwiO1xuICAgICAgICBjYXNlIDQyMTpcbiAgICAgICAgICByZXR1cm4gXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCI7XG4gICAgICAgIGNhc2UgNDIyOlxuICAgICAgICAgIHJldHVybiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCI7XG4gICAgICAgIGNhc2UgNDIzOlxuICAgICAgICAgIHJldHVybiBcIkxvY2tlZFwiO1xuICAgICAgICBjYXNlIDQyNDpcbiAgICAgICAgICByZXR1cm4gXCJGYWlsZWQgRGVwZW5kZW5jeVwiO1xuICAgICAgICBjYXNlIDQyNTpcbiAgICAgICAgICByZXR1cm4gXCJUb28gRWFybHlcIjtcbiAgICAgICAgY2FzZSA0MjY6XG4gICAgICAgICAgcmV0dXJuIFwiVXBncmFkZSBSZXF1aXJlZFwiO1xuICAgICAgICBjYXNlIDQyODpcbiAgICAgICAgICByZXR1cm4gXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIjtcbiAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgICAgcmV0dXJuIFwiVG9vIE1hbnkgUmVxdWVzdHNcIjtcbiAgICAgICAgY2FzZSA0MzE6XG4gICAgICAgICAgcmV0dXJuIFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiO1xuICAgICAgICBjYXNlIDQ1MTpcbiAgICAgICAgICByZXR1cm4gXCJVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29uc1wiO1xuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICByZXR1cm4gXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIjtcbiAgICAgICAgY2FzZSA1MDE6XG4gICAgICAgICAgcmV0dXJuIFwiTm90IEltcGxlbWVudGVkXCI7XG4gICAgICAgIGNhc2UgNTAyOlxuICAgICAgICAgIHJldHVybiBcIkJhZCBHYXRld2F5XCI7XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgIHJldHVybiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIjtcbiAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgcmV0dXJuIFwiR2F0ZXdheSBUaW1lb3V0XCI7XG4gICAgICAgIGNhc2UgNTA1OlxuICAgICAgICAgIHJldHVybiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCI7XG4gICAgICAgIGNhc2UgNTA2OlxuICAgICAgICAgIHJldHVybiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCI7XG4gICAgICAgIGNhc2UgNTA3OlxuICAgICAgICAgIHJldHVybiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCI7XG4gICAgICAgIGNhc2UgNTA4OlxuICAgICAgICAgIHJldHVybiBcIkxvb3AgRGV0ZWN0ZWRcIjtcbiAgICAgICAgY2FzZSA1MTA6XG4gICAgICAgICAgcmV0dXJuIFwiTm90IEV4dGVuZGVkXCI7XG4gICAgICAgIGNhc2UgNTExOlxuICAgICAgICAgIHJldHVybiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShnZXRTdGF0dXNUZXh0LCBcImdldFN0YXR1c1RleHRcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2UoYm9keSkge1xuICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBkYXRhIG9mIGJvZHkpIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycykudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0UmVzcG9uc2UsIFwiZ2V0UmVzcG9uc2VcIik7XG4gICAgZnVuY3Rpb24gbW9ja0Rpc3BhdGNoKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpO1xuICAgICAgY29uc3QgbW9ja0Rpc3BhdGNoMiA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KTtcbiAgICAgIG1vY2tEaXNwYXRjaDIudGltZXNJbnZva2VkKys7XG4gICAgICBpZiAobW9ja0Rpc3BhdGNoMi5kYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgIG1vY2tEaXNwYXRjaDIuZGF0YSA9IHsgLi4ubW9ja0Rpc3BhdGNoMi5kYXRhLCAuLi5tb2NrRGlzcGF0Y2gyLmRhdGEuY2FsbGJhY2sob3B0cykgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YTogeyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycywgZXJyb3I6IGVycm9yMiB9LCBkZWxheSwgcGVyc2lzdCB9ID0gbW9ja0Rpc3BhdGNoMjtcbiAgICAgIGNvbnN0IHsgdGltZXNJbnZva2VkLCB0aW1lcyB9ID0gbW9ja0Rpc3BhdGNoMjtcbiAgICAgIG1vY2tEaXNwYXRjaDIuY29uc3VtZWQgPSAhcGVyc2lzdCAmJiB0aW1lc0ludm9rZWQgPj0gdGltZXM7XG4gICAgICBtb2NrRGlzcGF0Y2gyLnBlbmRpbmcgPSB0aW1lc0ludm9rZWQgPCB0aW1lcztcbiAgICAgIGlmIChlcnJvcjIgIT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpO1xuICAgICAgICBoYW5kbGVyLm9uRXJyb3IoZXJyb3IyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiICYmIGRlbGF5ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlcGx5KG1vY2tEaXNwYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpID8gYnVpbGRIZWFkZXJzRnJvbUFycmF5KG9wdHMuaGVhZGVycykgOiBvcHRzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShcbiAgICAgICAgICB0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiID8gZGF0YSh7IC4uLm9wdHMsIGhlYWRlcnM6IG9wdHNIZWFkZXJzIH0pIDogZGF0YVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyhoZWFkZXJzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUcmFpbGVycyA9IGdlbmVyYXRlS2V5VmFsdWVzKHRyYWlsZXJzKTtcbiAgICAgICAgaGFuZGxlci5hYm9ydCA9IG5vcDtcbiAgICAgICAgaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgcmVzcG9uc2VIZWFkZXJzLCByZXN1bWUsIGdldFN0YXR1c1RleHQoc3RhdHVzQ29kZSkpO1xuICAgICAgICBoYW5kbGVyLm9uRGF0YShCdWZmZXIuZnJvbShyZXNwb25zZURhdGEpKTtcbiAgICAgICAgaGFuZGxlci5vbkNvbXBsZXRlKHJlc3BvbnNlVHJhaWxlcnMpO1xuICAgICAgICBkZWxldGVNb2NrRGlzcGF0Y2gobW9ja0Rpc3BhdGNoZXMsIGtleSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoaGFuZGxlUmVwbHksIFwiaGFuZGxlUmVwbHlcIik7XG4gICAgICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICB9XG4gICAgICBfX25hbWUocmVzdW1lLCBcInJlc3VtZVwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUobW9ja0Rpc3BhdGNoLCBcIm1vY2tEaXNwYXRjaFwiKTtcbiAgICBmdW5jdGlvbiBidWlsZE1vY2tEaXNwYXRjaCgpIHtcbiAgICAgIGNvbnN0IGFnZW50ID0gdGhpc1trTW9ja0FnZW50XTtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXNba09yaWdpbl07XG4gICAgICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChhZ2VudC5pc01vY2tBY3RpdmUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9ja0Rpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBuZXRDb25uZWN0ID0gYWdlbnRba0dldE5ldENvbm5lY3RdKCk7XG4gICAgICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yMi5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBkaXNhYmxlZClgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hlY2tOZXRDb25uZWN0KG5ldENvbm5lY3QsIG9yaWdpbikpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IyLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7b3JpZ2lufSB3YXMgbm90IGFsbG93ZWQgKG5ldC5jb25uZWN0IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIG9yaWdpbilgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sIFwiZGlzcGF0Y2hcIik7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZE1vY2tEaXNwYXRjaCwgXCJidWlsZE1vY2tEaXNwYXRjaFwiKTtcbiAgICBmdW5jdGlvbiBjaGVja05ldENvbm5lY3QobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9yaWdpbik7XG4gICAgICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX19uYW1lKGNoZWNrTmV0Q29ubmVjdCwgXCJjaGVja05ldENvbm5lY3RcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRNb2NrT3B0aW9ucyhvcHRzKSB7XG4gICAgICBpZiAob3B0cykge1xuICAgICAgICBjb25zdCB7IGFnZW50LCAuLi5tb2NrT3B0aW9ucyB9ID0gb3B0cztcbiAgICAgICAgcmV0dXJuIG1vY2tPcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYnVpbGRNb2NrT3B0aW9ucywgXCJidWlsZE1vY2tPcHRpb25zXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIGdldFJlc3BvbnNlRGF0YSxcbiAgICAgIGdldE1vY2tEaXNwYXRjaCxcbiAgICAgIGFkZE1vY2tEaXNwYXRjaCxcbiAgICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCxcbiAgICAgIGJ1aWxkS2V5LFxuICAgICAgZ2VuZXJhdGVLZXlWYWx1ZXMsXG4gICAgICBtYXRjaFZhbHVlLFxuICAgICAgZ2V0UmVzcG9uc2UsXG4gICAgICBnZXRTdGF0dXNUZXh0LFxuICAgICAgbW9ja0Rpc3BhdGNoLFxuICAgICAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gICAgICBjaGVja05ldENvbm5lY3QsXG4gICAgICBidWlsZE1vY2tPcHRpb25zLFxuICAgICAgZ2V0SGVhZGVyQnlOYW1lXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1pbnRlcmNlcHRvci5qc1xudmFyIHJlcXVpcmVfbW9ja19pbnRlcmNlcHRvciA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1pbnRlcmNlcHRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBnZXRSZXNwb25zZURhdGEsIGJ1aWxkS2V5LCBhZGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmVfbW9ja191dGlscygpO1xuICAgIHZhciB7XG4gICAgICBrRGlzcGF0Y2hlcyxcbiAgICAgIGtEaXNwYXRjaEtleSxcbiAgICAgIGtEZWZhdWx0SGVhZGVycyxcbiAgICAgIGtEZWZhdWx0VHJhaWxlcnMsXG4gICAgICBrQ29udGVudExlbmd0aCxcbiAgICAgIGtNb2NrRGlzcGF0Y2hcbiAgICB9ID0gcmVxdWlyZV9tb2NrX3N5bWJvbHMoKTtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgeyBidWlsZFVSTCB9ID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciBNb2NrU2NvcGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihtb2NrRGlzcGF0Y2gpIHtcbiAgICAgICAgdGhpc1trTW9ja0Rpc3BhdGNoXSA9IG1vY2tEaXNwYXRjaDtcbiAgICAgIH1cbiAgICAgIGRlbGF5KHdhaXRJbk1zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2FpdEluTXMgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIod2FpdEluTXMpIHx8IHdhaXRJbk1zIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trTW9ja0Rpc3BhdGNoXS5kZWxheSA9IHdhaXRJbk1zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHBlcnNpc3QoKSB7XG4gICAgICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGltZXMocmVwZWF0VGltZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZXBlYXRUaW1lcykgfHwgcmVwZWF0VGltZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInJlcGVhdFRpbWVzIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE1vY2tTY29wZSwgXCJNb2NrU2NvcGVcIik7XG4gICAgdmFyIE1vY2tJbnRlcmNlcHRvciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMsIG1vY2tEaXNwYXRjaGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm9wdHMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBvcHRzLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAob3B0cy5xdWVyeSkge1xuICAgICAgICAgICAgb3B0cy5wYXRoID0gYnVpbGRVUkwob3B0cy5wYXRoLCBvcHRzLnF1ZXJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChvcHRzLnBhdGgsIFwiZGF0YTovL1wiKTtcbiAgICAgICAgICAgIG9wdHMucGF0aCA9IHBhcnNlZFVSTC5wYXRobmFtZSArIHBhcnNlZFVSTC5zZWFyY2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trRGlzcGF0Y2hLZXldID0gYnVpbGRLZXkob3B0cyk7XG4gICAgICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gbW9ja0Rpc3BhdGNoZXM7XG4gICAgICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IHt9O1xuICAgICAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0ge307XG4gICAgICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpO1xuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpc1trQ29udGVudExlbmd0aF0gPyB7IFwiY29udGVudC1sZW5ndGhcIjogcmVzcG9uc2VEYXRhLmxlbmd0aCB9IDoge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgY29uc3QgdHJhaWxlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRUcmFpbGVyc10sIC4uLnJlc3BvbnNlT3B0aW9ucy50cmFpbGVycyB9O1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycyB9O1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzQ29kZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInN0YXR1c0NvZGUgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImRhdGEgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VPcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwicmVzcG9uc2VPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXBseShyZXBseURhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBseURhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWREYXRhID0gcmVwbHlEYXRhKG9wdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwicmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUyLCBkYXRhOiBkYXRhMiA9IFwiXCIsIHJlc3BvbnNlT3B0aW9uczogcmVzcG9uc2VPcHRpb25zMiA9IHt9IH0gPSByZXNvbHZlZERhdGE7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUyLCBkYXRhMiwgcmVzcG9uc2VPcHRpb25zMik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi50aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShzdGF0dXNDb2RlMiwgZGF0YTIsIHJlc3BvbnNlT3B0aW9uczIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sIFwid3JhcHBlZERlZmF1bHRzQ2FsbGJhY2tcIik7XG4gICAgICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoMiA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3N0YXR1c0NvZGUsIGRhdGEgPSBcIlwiLCByZXNwb25zZU9wdGlvbnMgPSB7fV0gPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkaXNwYXRjaERhdGEgPSB0aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIHJlcGx5V2l0aEVycm9yKGVycm9yMikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yMiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImVycm9yIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgeyBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdFJlcGx5SGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImhlYWRlcnMgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZGVmYXVsdFJlcGx5VHJhaWxlcnModHJhaWxlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFpbGVycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInRyYWlsZXJzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0gdHJhaWxlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmVwbHlDb250ZW50TGVuZ3RoKCkge1xuICAgICAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE1vY2tJbnRlcmNlcHRvciwgXCJNb2NrSW50ZXJjZXB0b3JcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1vY2tJbnRlcmNlcHRvciA9IE1vY2tJbnRlcmNlcHRvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuTW9ja1Njb3BlID0gTW9ja1Njb3BlO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWNsaWVudC5qc1xudmFyIHJlcXVpcmVfbW9ja19jbGllbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IHByb21pc2lmeTogcHJvbWlzaWZ5NCB9ID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgdmFyIENsaWVudCA9IHJlcXVpcmVfY2xpZW50KCk7XG4gICAgdmFyIHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmVfbW9ja191dGlscygpO1xuICAgIHZhciB7XG4gICAgICBrRGlzcGF0Y2hlcyxcbiAgICAgIGtNb2NrQWdlbnQsXG4gICAgICBrQ2xvc2UsXG4gICAgICBrT3JpZ2luYWxDbG9zZSxcbiAgICAgIGtPcmlnaW4sXG4gICAgICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAgICAgIGtDb25uZWN0ZWRcbiAgICB9ID0gcmVxdWlyZV9tb2NrX3N5bWJvbHMoKTtcbiAgICB2YXIgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmVfbW9ja19pbnRlcmNlcHRvcigpO1xuICAgIHZhciBTeW1ib2xzID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIE1vY2tDbGllbnQgPSBjbGFzcyBleHRlbmRzIENsaWVudCB7XG4gICAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3JpZ2luLCBvcHRzKTtcbiAgICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50O1xuICAgICAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luO1xuICAgICAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdO1xuICAgICAgICB0aGlzW2tDb25uZWN0ZWRdID0gMTtcbiAgICAgICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoO1xuICAgICAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV07XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdO1xuICAgICAgfVxuICAgICAgaW50ZXJjZXB0KG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pO1xuICAgICAgfVxuICAgICAgYXN5bmMgW2tDbG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHByb21pc2lmeTQodGhpc1trT3JpZ2luYWxDbG9zZV0pKCk7XG4gICAgICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwO1xuICAgICAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrQ2xpZW50LCBcIk1vY2tDbGllbnRcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gTW9ja0NsaWVudDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1wb29sLmpzXG52YXIgcmVxdWlyZV9tb2NrX3Bvb2wgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBwcm9taXNpZnk6IHByb21pc2lmeTQgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciBQb29sID0gcmVxdWlyZV9wb29sKCk7XG4gICAgdmFyIHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmVfbW9ja191dGlscygpO1xuICAgIHZhciB7XG4gICAgICBrRGlzcGF0Y2hlcyxcbiAgICAgIGtNb2NrQWdlbnQsXG4gICAgICBrQ2xvc2UsXG4gICAgICBrT3JpZ2luYWxDbG9zZSxcbiAgICAgIGtPcmlnaW4sXG4gICAgICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAgICAgIGtDb25uZWN0ZWRcbiAgICB9ID0gcmVxdWlyZV9tb2NrX3N5bWJvbHMoKTtcbiAgICB2YXIgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmVfbW9ja19pbnRlcmNlcHRvcigpO1xuICAgIHZhciBTeW1ib2xzID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIE1vY2tQb29sID0gY2xhc3MgZXh0ZW5kcyBQb29sIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgb3B0cykge1xuICAgICAgICBzdXBlcihvcmlnaW4sIG9wdHMpO1xuICAgICAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkFyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnQ7XG4gICAgICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW47XG4gICAgICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW107XG4gICAgICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxO1xuICAgICAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2g7XG4gICAgICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXTtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF07XG4gICAgICB9XG4gICAgICBpbnRlcmNlcHQob3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSk7XG4gICAgICB9XG4gICAgICBhc3luYyBba0Nsb3NlXSgpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5NCh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKTtcbiAgICAgICAgdGhpc1trQ29ubmVjdGVkXSA9IDA7XG4gICAgICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKE1vY2tQb29sLCBcIk1vY2tQb29sXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE1vY2tQb29sO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wbHVyYWxpemVyLmpzXG52YXIgcmVxdWlyZV9wbHVyYWxpemVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wbHVyYWxpemVyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBzaW5ndWxhcnMgPSB7XG4gICAgICBwcm9ub3VuOiBcIml0XCIsXG4gICAgICBpczogXCJpc1wiLFxuICAgICAgd2FzOiBcIndhc1wiLFxuICAgICAgdGhpczogXCJ0aGlzXCJcbiAgICB9O1xuICAgIHZhciBwbHVyYWxzID0ge1xuICAgICAgcHJvbm91bjogXCJ0aGV5XCIsXG4gICAgICBpczogXCJhcmVcIixcbiAgICAgIHdhczogXCJ3ZXJlXCIsXG4gICAgICB0aGlzOiBcInRoZXNlXCJcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoY2xhc3MgUGx1cmFsaXplciB7XG4gICAgICBjb25zdHJ1Y3RvcihzaW5ndWxhciwgcGx1cmFsKSB7XG4gICAgICAgIHRoaXMuc2luZ3VsYXIgPSBzaW5ndWxhcjtcbiAgICAgICAgdGhpcy5wbHVyYWwgPSBwbHVyYWw7XG4gICAgICB9XG4gICAgICBwbHVyYWxpemUoY291bnQyKSB7XG4gICAgICAgIGNvbnN0IG9uZSA9IGNvdW50MiA9PT0gMTtcbiAgICAgICAgY29uc3Qga2V5czIgPSBvbmUgPyBzaW5ndWxhcnMgOiBwbHVyYWxzO1xuICAgICAgICBjb25zdCBub3VuID0gb25lID8gdGhpcy5zaW5ndWxhciA6IHRoaXMucGx1cmFsO1xuICAgICAgICByZXR1cm4geyAuLi5rZXlzMiwgY291bnQ6IGNvdW50Miwgbm91biB9O1xuICAgICAgfVxuICAgIH0sIFwiUGx1cmFsaXplclwiKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGVuZGluZy1pbnRlcmNlcHRvcnMtZm9ybWF0dGVyLmpzXG52YXIgcmVxdWlyZV9wZW5kaW5nX2ludGVyY2VwdG9yc19mb3JtYXR0ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgdmFyIHsgQ29uc29sZSB9ID0gcmVxdWlyZShcImNvbnNvbGVcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShjbGFzcyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKHsgZGlzYWJsZUNvbG9ycyB9ID0ge30pIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIF9lbmMsIGNiKSB7XG4gICAgICAgICAgICBjYihudWxsLCBjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICAgICAgc3Rkb3V0OiB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICBpbnNwZWN0T3B0aW9uczoge1xuICAgICAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9ybWF0KHBlbmRpbmdJbnRlcmNlcHRvcnMpIHtcbiAgICAgICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICAgICAoeyBtZXRob2QsIHBhdGg6IHBhdGg3LCBkYXRhOiB7IHN0YXR1c0NvZGUgfSwgcGVyc2lzdCwgdGltZXMsIHRpbWVzSW52b2tlZCwgb3JpZ2luIH0pID0+ICh7XG4gICAgICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIE9yaWdpbjogb3JpZ2luLFxuICAgICAgICAgICAgUGF0aDogcGF0aDcsXG4gICAgICAgICAgICBcIlN0YXR1cyBjb2RlXCI6IHN0YXR1c0NvZGUsXG4gICAgICAgICAgICBQZXJzaXN0ZW50OiBwZXJzaXN0ID8gXCJcXHUyNzA1XCIgOiBcIlxcdTI3NENcIixcbiAgICAgICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgICAgICBSZW1haW5pbmc6IHBlcnNpc3QgPyBJbmZpbml0eSA6IHRpbWVzIC0gdGltZXNJbnZva2VkXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVhZCgpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSwgXCJQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzXG52YXIgcmVxdWlyZV9tb2NrX2FnZW50ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGtDbGllbnRzIH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgQWdlbnQgPSByZXF1aXJlX2FnZW50KCk7XG4gICAgdmFyIHtcbiAgICAgIGtBZ2VudCxcbiAgICAgIGtNb2NrQWdlbnRTZXQsXG4gICAgICBrTW9ja0FnZW50R2V0LFxuICAgICAga0Rpc3BhdGNoZXMsXG4gICAgICBrSXNNb2NrQWN0aXZlLFxuICAgICAga05ldENvbm5lY3QsXG4gICAgICBrR2V0TmV0Q29ubmVjdCxcbiAgICAgIGtPcHRpb25zLFxuICAgICAga0ZhY3RvcnlcbiAgICB9ID0gcmVxdWlyZV9tb2NrX3N5bWJvbHMoKTtcbiAgICB2YXIgTW9ja0NsaWVudCA9IHJlcXVpcmVfbW9ja19jbGllbnQoKTtcbiAgICB2YXIgTW9ja1Bvb2wgPSByZXF1aXJlX21vY2tfcG9vbCgpO1xuICAgIHZhciB7IG1hdGNoVmFsdWUsIGJ1aWxkTW9ja09wdGlvbnMgfSA9IHJlcXVpcmVfbW9ja191dGlscygpO1xuICAgIHZhciB7IEludmFsaWRBcmd1bWVudEVycm9yLCBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZV9lcnJvcnMoKTtcbiAgICB2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmVfZGlzcGF0Y2hlcigpO1xuICAgIHZhciBQbHVyYWxpemVyID0gcmVxdWlyZV9wbHVyYWxpemVyKCk7XG4gICAgdmFyIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlX3BlbmRpbmdfaW50ZXJjZXB0b3JzX2Zvcm1hdHRlcigpO1xuICAgIHZhciBGYWtlV2Vha1JlZiA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlcmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShGYWtlV2Vha1JlZiwgXCJGYWtlV2Vha1JlZlwiKTtcbiAgICB2YXIgTW9ja0FnZW50ID0gY2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWU7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuYWdlbnQgJiYgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkFyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnQgPSBvcHRzICYmIG9wdHMuYWdlbnQgPyBvcHRzLmFnZW50IDogbmV3IEFnZW50KG9wdHMpO1xuICAgICAgICB0aGlzW2tBZ2VudF0gPSBhZ2VudDtcbiAgICAgICAgdGhpc1trQ2xpZW50c10gPSBhZ2VudFtrQ2xpZW50c107XG4gICAgICAgIHRoaXNba09wdGlvbnNdID0gYnVpbGRNb2NrT3B0aW9ucyhvcHRzKTtcbiAgICAgIH1cbiAgICAgIGdldChvcmlnaW4pIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tNb2NrQWdlbnRHZXRdKG9yaWdpbik7XG4gICAgICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pO1xuICAgICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pO1xuICAgICAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpO1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpO1xuICAgICAgfVxuICAgICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZW5hYmxlTmV0Q29ubmVjdChtYXRjaGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gXCJmdW5jdGlvblwiIHx8IG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzW2tOZXRDb25uZWN0XSkpIHtcbiAgICAgICAgICAgIHRoaXNba05ldENvbm5lY3RdLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gW21hdGNoZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJVbnN1cHBvcnRlZCBtYXRjaGVyLiBNdXN0IGJlIG9uZSBvZiBTdHJpbmd8RnVuY3Rpb258UmVnRXhwLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzYWJsZU5ldENvbm5lY3QoKSB7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBnZXQgaXNNb2NrQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSXNNb2NrQWN0aXZlXTtcbiAgICAgIH1cbiAgICAgIFtrTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpIHtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uc2V0KG9yaWdpbiwgbmV3IEZha2VXZWFrUmVmKGRpc3BhdGNoZXIpKTtcbiAgICAgIH1cbiAgICAgIFtrRmFjdG9yeV0ob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IG1vY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFnZW50OiB0aGlzIH0sIHRoaXNba09wdGlvbnNdKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba09wdGlvbnNdICYmIHRoaXNba09wdGlvbnNdLmNvbm5lY3Rpb25zID09PSAxID8gbmV3IE1vY2tDbGllbnQob3JpZ2luLCBtb2NrT3B0aW9ucykgOiBuZXcgTW9ja1Bvb2wob3JpZ2luLCBtb2NrT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBba01vY2tBZ2VudEdldF0ob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChvcmlnaW4pO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZi5kZXJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKFwiaHR0cDovL2xvY2FsaG9zdDo5OTk5XCIpO1xuICAgICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKTtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXlNYXRjaGVyLCBub25FeHBsaWNpdFJlZl0gb2YgQXJyYXkuZnJvbSh0aGlzW2tDbGllbnRzXSkpIHtcbiAgICAgICAgICBjb25zdCBub25FeHBsaWNpdERpc3BhdGNoZXIgPSBub25FeHBsaWNpdFJlZi5kZXJlZigpO1xuICAgICAgICAgIGlmIChub25FeHBsaWNpdERpc3BhdGNoZXIgJiYgdHlwZW9mIGtleU1hdGNoZXIgIT09IFwic3RyaW5nXCIgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKTtcbiAgICAgICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXJba0Rpc3BhdGNoZXNdID0gbm9uRXhwbGljaXREaXNwYXRjaGVyW2tEaXNwYXRjaGVzXTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgW2tHZXROZXRDb25uZWN0XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba05ldENvbm5lY3RdO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0ludGVyY2VwdG9ycygpIHtcbiAgICAgICAgY29uc3QgbW9ja0FnZW50Q2xpZW50cyA9IHRoaXNba0NsaWVudHNdO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShtb2NrQWdlbnRDbGllbnRzLmVudHJpZXMoKSkuZmxhdE1hcCgoW29yaWdpbiwgc2NvcGVdKSA9PiBzY29wZS5kZXJlZigpW2tEaXNwYXRjaGVzXS5tYXAoKGRpc3BhdGNoKSA9PiAoeyAuLi5kaXNwYXRjaCwgb3JpZ2luIH0pKSkuZmlsdGVyKCh7IHBlbmRpbmcgfSkgPT4gcGVuZGluZyk7XG4gICAgICB9XG4gICAgICBhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMoeyBwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gbmV3IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIoKSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ0ludGVyY2VwdG9ycygpO1xuICAgICAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1cmFsaXplciA9IG5ldyBQbHVyYWxpemVyKFwiaW50ZXJjZXB0b3JcIiwgXCJpbnRlcmNlcHRvcnNcIikucGx1cmFsaXplKHBlbmRpbmcubGVuZ3RoKTtcbiAgICAgICAgdGhyb3cgbmV3IFVuZGljaUVycm9yKGBcbiR7cGx1cmFsaXplci5jb3VudH0gJHtwbHVyYWxpemVyLm5vdW59ICR7cGx1cmFsaXplci5pc30gcGVuZGluZzpcblxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1cbmAudHJpbSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShNb2NrQWdlbnQsIFwiTW9ja0FnZW50XCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE1vY2tBZ2VudDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Byb3h5LWFnZW50LmpzXG52YXIgcmVxdWlyZV9wcm94eV9hZ2VudCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Byb3h5LWFnZW50LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGtDbG9zZSwga0Rlc3Ryb3kgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBDbGllbnQgPSByZXF1aXJlX2FnZW50KCk7XG4gICAgdmFyIEFnZW50ID0gcmVxdWlyZV9hZ2VudCgpO1xuICAgIHZhciBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmVfZGlzcGF0Y2hlcl9iYXNlKCk7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZV9jb25uZWN0KCk7XG4gICAgdmFyIGtBZ2VudCA9IFN5bWJvbChcInByb3h5IGFnZW50XCIpO1xuICAgIHZhciBrQ2xpZW50ID0gU3ltYm9sKFwicHJveHkgY2xpZW50XCIpO1xuICAgIHZhciBrUHJveHlIZWFkZXJzID0gU3ltYm9sKFwicHJveHkgaGVhZGVyc1wiKTtcbiAgICB2YXIga1JlcXVlc3RUbHMgPSBTeW1ib2woXCJyZXF1ZXN0IHRscyBzZXR0aW5nc1wiKTtcbiAgICB2YXIga1Byb3h5VGxzID0gU3ltYm9sKFwicHJveHkgdGxzIHNldHRpbmdzXCIpO1xuICAgIHZhciBrQ29ubmVjdEVuZHBvaW50ID0gU3ltYm9sKFwiY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvblwiKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0UHJvdG9jb2xQb3J0KHByb3RvY29sKSB7XG4gICAgICByZXR1cm4gcHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyA0NDMgOiA4MDtcbiAgICB9XG4gICAgX19uYW1lKGRlZmF1bHRQcm90b2NvbFBvcnQsIFwiZGVmYXVsdFByb3RvY29sUG9ydFwiKTtcbiAgICB2YXIgUHJveHlBZ2VudCA9IGNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAgICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgb3B0cyA9IHsgdXJpOiBvcHRzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzLnVyaSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIlByb3h5IG9wdHMudXJpIGlzIG1hbmRhdG9yeVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2tSZXF1ZXN0VGxzXSA9IG9wdHMucmVxdWVzdFRscztcbiAgICAgICAgdGhpc1trUHJveHlUbHNdID0gb3B0cy5wcm94eVRscztcbiAgICAgICAgdGhpc1trUHJveHlIZWFkZXJzXSA9IHt9O1xuICAgICAgICBpZiAob3B0cy5hdXRoKSB7XG4gICAgICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVtcInByb3h5LWF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtvcHRzLmF1dGh9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgcG9ydCB9ID0gbmV3IFVSTChvcHRzLnVyaSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucHJveHlUbHMgfSk7XG4gICAgICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KTtcbiAgICAgICAgdGhpc1trQ2xpZW50XSA9IG5ldyBDbGllbnQoeyBvcmlnaW46IG9wdHMub3JpZ2luLCBjb25uZWN0IH0pO1xuICAgICAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQoe1xuICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgY29ubmVjdDogYXN5bmMgKG9wdHMyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3RlZEhvc3QgPSBvcHRzMi5ob3N0O1xuICAgICAgICAgICAgaWYgKCFvcHRzMi5wb3J0KSB7XG4gICAgICAgICAgICAgIHJlcXVlc3RlZEhvc3QgKz0gYDoke2RlZmF1bHRQcm90b2NvbFBvcnQob3B0czIucHJvdG9jb2wpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB7IHNvY2tldCwgc3RhdHVzQ29kZSB9ID0gYXdhaXQgdGhpc1trQ2xpZW50XS5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgICAgICBwYXRoOiByZXF1ZXN0ZWRIb3N0LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0czIuc2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnRoaXNba1Byb3h5SGVhZGVyc10sXG4gICAgICAgICAgICAgICAgICBob3N0OiBvcHRzMi5ob3N0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB9KS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoXCJQcm94eSByZXNwb25zZSAhPT0gMjAwIHdoZW4gSFRUUCBUdW5uZWxpbmdcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcHRzMi5wcm90b2NvbCAhPT0gXCJodHRwczpcIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBzZXJ2ZXJuYW1lO1xuICAgICAgICAgICAgICBpZiAodGhpc1trUmVxdWVzdFRsc10pIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lID0gdGhpc1trUmVxdWVzdFRsc10uc2VydmVybmFtZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lID0gb3B0czIuc2VydmVybmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0czIsIHNlcnZlcm5hbWUsIGh0dHBTb2NrZXQ6IHNvY2tldCB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2gob3B0cywgaGFuZGxlcikge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IG5ldyBVUkwob3B0cy5vcmlnaW4pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzMihvcHRzLmhlYWRlcnMpO1xuICAgICAgICB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgIGhvc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIFtrQ2xvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgdGhpc1trQ2xpZW50XS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgYXN5bmMgW2tEZXN0cm95XSgpIHtcbiAgICAgICAgYXdhaXQgdGhpc1trQWdlbnRdLmRlc3Ryb3koKTtcbiAgICAgICAgYXdhaXQgdGhpc1trQ2xpZW50XS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUHJveHlBZ2VudCwgXCJQcm94eUFnZW50XCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkSGVhZGVyczIoaGVhZGVycykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyc1BhaXIgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaGVhZGVyc1BhaXJbaGVhZGVyc1tpXV0gPSBoZWFkZXJzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyc1BhaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkSGVhZGVyczIsIFwiYnVpbGRIZWFkZXJzXCIpO1xuICAgIGZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQoaGVhZGVycykge1xuICAgICAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwicHJveHktYXV0aG9yaXphdGlvblwiKTtcbiAgICAgIGlmIChleGlzdFByb3h5QXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh0aHJvd0lmUHJveHlBdXRoSXNTZW50LCBcInRocm93SWZQcm94eUF1dGhJc1NlbnRcIik7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUHJveHlBZ2VudDtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2dsb2JhbC5qc1xudmFyIHJlcXVpcmVfZ2xvYmFsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZ2xvYmFsLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBnbG9iYWxEaXNwYXRjaGVyID0gU3ltYm9sLmZvcihcInVuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjFcIik7XG4gICAgdmFyIHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIEFnZW50ID0gcmVxdWlyZV9hZ2VudCgpO1xuICAgIGlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHZvaWQgMCkge1xuICAgICAgc2V0R2xvYmFsRGlzcGF0Y2hlcihuZXcgQWdlbnQoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbERpc3BhdGNoZXIoYWdlbnQpIHtcbiAgICAgIGlmICghYWdlbnQgfHwgdHlwZW9mIGFnZW50LmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnRcIik7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsRGlzcGF0Y2hlciwge1xuICAgICAgICB2YWx1ZTogYWdlbnQsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShzZXRHbG9iYWxEaXNwYXRjaGVyLCBcInNldEdsb2JhbERpc3BhdGNoZXJcIik7XG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0R2xvYmFsRGlzcGF0Y2hlciwgXCJnZXRHbG9iYWxEaXNwYXRjaGVyXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHNldEdsb2JhbERpc3BhdGNoZXIsXG4gICAgICBnZXRHbG9iYWxEaXNwYXRjaGVyXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2hlYWRlcnMuanNcbnZhciByZXF1aXJlX2hlYWRlcnMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9oZWFkZXJzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIHsga0d1YXJkIH0gPSByZXF1aXJlX3N5bWJvbHMyKCk7XG4gICAgdmFyIHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZV91dGlsMigpO1xuICAgIHZhciB7XG4gICAgICBtYWtlSXRlcmF0b3IsXG4gICAgICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgICAgIGlzVmFsaWRIZWFkZXJWYWx1ZVxuICAgIH0gPSByZXF1aXJlX3V0aWwzKCk7XG4gICAgdmFyIHsgd2ViaWRsIH0gPSByZXF1aXJlX3dlYmlkbCgpO1xuICAgIHZhciBrSGVhZGVyc01hcCA9IFN5bWJvbChcImhlYWRlcnMgbWFwXCIpO1xuICAgIHZhciBrSGVhZGVyc1NvcnRlZE1hcCA9IFN5bWJvbChcImhlYWRlcnMgbWFwIHNvcnRlZFwiKTtcbiAgICBmdW5jdGlvbiBoZWFkZXJWYWx1ZU5vcm1hbGl6ZShwb3RlbnRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHBvdGVudGlhbFZhbHVlLnJlcGxhY2UoXG4gICAgICAgIC9eW1xcclxcblxcdCBdK3xbXFxyXFxuXFx0IF0rJC9nLFxuICAgICAgICBcIlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfX25hbWUoaGVhZGVyVmFsdWVOb3JtYWxpemUsIFwiaGVhZGVyVmFsdWVOb3JtYWxpemVcIik7XG4gICAgZnVuY3Rpb24gZmlsbChoZWFkZXJzLCBvYmplY3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiBcIkhlYWRlcnMgY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZTogYGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQgJHtoZWFkZXIubGVuZ3RofS5gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycyBjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgIGFyZ3VtZW50OiBcIkFyZ3VtZW50IDFcIixcbiAgICAgICAgICB0eXBlczogW1wic2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XCIsIFwicmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XCJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZmlsbCwgXCJmaWxsXCIpO1xuICAgIHZhciBIZWFkZXJzTGlzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAgICAgaWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0W2tIZWFkZXJzTWFwXSk7XG4gICAgICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBpbml0W2tIZWFkZXJzU29ydGVkTWFwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdCk7XG4gICAgICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250YWlucyhuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5oYXMobmFtZSk7XG4gICAgICB9XG4gICAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpc1trSGVhZGVyc01hcF0uY2xlYXIoKTtcbiAgICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsO1xuICAgICAgfVxuICAgICAgYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbDtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXhpc3RzNCA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0czQpIHtcbiAgICAgICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobmFtZSwgYCR7ZXhpc3RzNH0sICR7dmFsdWV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KG5hbWUsIGAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsO1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbDtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmRlbGV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGdldChuYW1lKSB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EzID0gdGhpc1trSGVhZGVyc01hcF0uZ2V0KG5hbWUpKSAhPSBudWxsID8gX2EzIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5oYXMobmFtZSk7XG4gICAgICB9XG4gICAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0ua2V5cygpO1xuICAgICAgfVxuICAgICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0udmFsdWVzKCk7XG4gICAgICB9XG4gICAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZW50cmllcygpO1xuICAgICAgfVxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoSGVhZGVyc0xpc3QsIFwiSGVhZGVyc0xpc3RcIik7XG4gICAgdmFyIEhlYWRlcnMgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihpbml0ID0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNMaXN0XSA9IG5ldyBIZWFkZXJzTGlzdCgpO1xuICAgICAgICB0aGlzW2tHdWFyZF0gPSBcIm5vbmVcIjtcbiAgICAgICAgaWYgKGluaXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdChpbml0KTtcbiAgICAgICAgICBmaWxsKHRoaXMsIGluaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgICBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdIZWFkZXJzJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycy5hcHBlbmRcIixcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXIgbmFtZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgICAgICBwcmVmaXg6IFwiSGVhZGVycy5hcHBlbmRcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXIgdmFsdWVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2tHdWFyZF0gPT09IFwiaW1tdXRhYmxlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW1tdXRhYmxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNba0d1YXJkXSA9PT0gXCJyZXF1ZXN0LW5vLWNvcnNcIikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZGVsZXRlJyBvbiAnSGVhZGVycyc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgICAgIHByZWZpeDogXCJIZWFkZXJzLmRlbGV0ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlciBuYW1lXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trR3VhcmRdID09PSBcImltbXV0YWJsZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImltbXV0YWJsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09IFwicmVxdWVzdC1uby1jb3JzXCIpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmRlbGV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGdldChuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0JyBvbiAnSGVhZGVycyc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgICAgIHByZWZpeDogXCJIZWFkZXJzLmdldFwiLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlciBuYW1lXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnaGFzJyBvbiAnSGVhZGVycyc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgICAgIHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgICAgIHByZWZpeDogXCJIZWFkZXJzLmhhc1wiLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlciBuYW1lXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmNvbnRhaW5zKG5hbWUpO1xuICAgICAgfVxuICAgICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnc2V0JyBvbiAnSGVhZGVycyc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMuc2V0XCIsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyIG5hbWVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICAgICAgcHJlZml4OiBcIkhlYWRlcnMuc2V0XCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyIHZhbHVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1trR3VhcmRdID09PSBcImltbXV0YWJsZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImltbXV0YWJsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09IFwicmVxdWVzdC1uby1jb3JzXCIpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBnZXQgW2tIZWFkZXJzU29ydGVkTWFwXSgpIHtcbiAgICAgICAgdmFyIF9hMywgX2IyO1xuICAgICAgICAoX2IyID0gKF9hMyA9IHRoaXNba0hlYWRlcnNMaXN0XSlba0hlYWRlcnNTb3J0ZWRNYXBdKSAhPSBudWxsID8gX2IyIDogX2EzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG5ldyBNYXAoWy4uLnRoaXNba0hlYWRlcnNMaXN0XV0uc29ydCgoYSwgYikgPT4gYVswXSA8IGJbMF0gPyAtMSA6IDEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XVtrSGVhZGVyc1NvcnRlZE1hcF07XG4gICAgICB9XG4gICAgICBrZXlzKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpc1trSGVhZGVyc1NvcnRlZE1hcF0ua2V5cygpLCBcIkhlYWRlcnNcIik7XG4gICAgICB9XG4gICAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzW2tIZWFkZXJzU29ydGVkTWFwXS52YWx1ZXMoKSwgXCJIZWFkZXJzXCIpO1xuICAgICAgfVxuICAgICAgZW50cmllcygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLmVudHJpZXMoKSwgXCJIZWFkZXJzXCIpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdIZWFkZXJzJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdIZWFkZXJzJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgIGNhbGxiYWNrRm4uYXBwbHkodGhpc0FyZywgW3ZhbHVlLCBrZXksIHRoaXNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShIZWFkZXJzLCBcIkhlYWRlcnNcIik7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIHtcbiAgICAgIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICB2YWx1ZXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBlbnRyaWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgZm9yRWFjaDoga0VudW1lcmFibGVQcm9wZXJ0eVxuICAgIH0pO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0ID0gZnVuY3Rpb24oVikge1xuICAgICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKFZbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1tcInNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PlwiXShWKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbXCJyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cIl0oVik7XG4gICAgICB9XG4gICAgICB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICBwcmVmaXg6IFwiSGVhZGVycyBjb25zdHJ1Y3RvclwiLFxuICAgICAgICBhcmd1bWVudDogXCJBcmd1bWVudCAxXCIsXG4gICAgICAgIHR5cGVzOiBbXCJzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cIiwgXCJyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cIl1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgZmlsbCxcbiAgICAgIEhlYWRlcnMsXG4gICAgICBIZWFkZXJzTGlzdFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXNwb25zZS5qc1xudmFyIHJlcXVpcmVfcmVzcG9uc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXNwb25zZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBIZWFkZXJzLCBIZWFkZXJzTGlzdCwgZmlsbCB9ID0gcmVxdWlyZV9oZWFkZXJzKCk7XG4gICAgdmFyIHsgZXh0cmFjdEJvZHksIGNsb25lQm9keSwgbWl4aW5Cb2R5IH0gPSByZXF1aXJlX2JvZHkoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbDI7XG4gICAgdmFyIHtcbiAgICAgIHJlc3BvbnNlVVJMLFxuICAgICAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgICAgIGlzQ2FuY2VsbGVkLFxuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNCbG9iTGlrZSxcbiAgICAgIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgICAgIGlzRXJyb3JMaWtlXG4gICAgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIge1xuICAgICAgcmVkaXJlY3RTdGF0dXMsXG4gICAgICBudWxsQm9keVN0YXR1cyxcbiAgICAgIERPTUV4Y2VwdGlvblxuICAgIH0gPSByZXF1aXJlX2NvbnN0YW50cygpO1xuICAgIHZhciB7IGtTdGF0ZSwga0hlYWRlcnMsIGtHdWFyZCwga1JlYWxtIH0gPSByZXF1aXJlX3N5bWJvbHMyKCk7XG4gICAgdmFyIHsgd2ViaWRsIH0gPSByZXF1aXJlX3dlYmlkbCgpO1xuICAgIHZhciB7IEZvcm1EYXRhIH0gPSByZXF1aXJlX2Zvcm1kYXRhKCk7XG4gICAgdmFyIHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlX3N5bWJvbHMoKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgICB2YXIgeyB0eXBlcyB9ID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgdmFyIFJlYWRhYmxlU3RyZWFtID0gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSB8fCByZXF1aXJlKFwic3RyZWFtL3dlYlwiKS5SZWFkYWJsZVN0cmVhbTtcbiAgICB2YXIgUmVzcG9uc2UgPSBjbGFzcyB7XG4gICAgICBzdGF0aWMgZXJyb3IoKSB7XG4gICAgICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9O1xuICAgICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gbWFrZU5ldHdvcmtFcnJvcigpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXNwb25zZU9iamVjdFtrU3RhdGVdLmhlYWRlcnNMaXN0O1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IFwiaW1tdXRhYmxlXCI7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0O1xuICAgICAgfVxuICAgICAgc3RhdGljIGpzb24oZGF0YSwgaW5pdCA9IHt9KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2pzb24nIG9uICdSZXNwb25zZSc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCAwIHByZXNlbnQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcihcInV0Zi04XCIpLmVuY29kZShcbiAgICAgICAgICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcoZGF0YSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYm9keSA9IGV4dHJhY3RCb2R5KGJ5dGVzKTtcbiAgICAgICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKCk7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IFwicmVzcG9uc2VcIjtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtO1xuICAgICAgICBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2VPYmplY3QsIGluaXQsIHsgYm9keTogYm9keVswXSwgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyByZWRpcmVjdCh1cmwsIHN0YXR1cyA9IDMwMikge1xuICAgICAgICBjb25zdCByZWxldmFudFJlYWxtID0geyBzZXR0aW5nc09iamVjdDoge30gfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAncmVkaXJlY3QnIG9uICdSZXNwb25zZSc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKTtcbiAgICAgICAgc3RhdHVzID0gd2ViaWRsLmNvbnZlcnRlcnNbXCJ1bnNpZ25lZCBzaG9ydFwiXShzdGF0dXMpO1xuICAgICAgICBsZXQgcGFyc2VkVVJMO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tIFwiICsgdXJsKSwge1xuICAgICAgICAgICAgY2F1c2U6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVkaXJlY3RTdGF0dXMuaW5jbHVkZXMoc3RhdHVzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSBcImltbXV0YWJsZVwiO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG07XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFVSTC50b1N0cmluZygpO1xuICAgICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLmhlYWRlcnNMaXN0LmFwcGVuZChcImxvY2F0aW9uXCIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0O1xuICAgICAgfVxuICAgICAgY29uc3RydWN0b3IoYm9keSA9IG51bGwsIGluaXQgPSB7fSkge1xuICAgICAgICBpZiAoYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgIGJvZHkgPSB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdChib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpO1xuICAgICAgICB0aGlzW2tSZWFsbV0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9O1xuICAgICAgICB0aGlzW2tTdGF0ZV0gPSBtYWtlUmVzcG9uc2Uoe30pO1xuICAgICAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSBcInJlc3BvbnNlXCI7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSB0aGlzW2tTdGF0ZV0uaGVhZGVyc0xpc3Q7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV07XG4gICAgICAgIGxldCBib2R5V2l0aFR5cGUgPSBudWxsO1xuICAgICAgICBpZiAoYm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIHR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSk7XG4gICAgICAgICAgYm9keVdpdGhUeXBlID0geyBib2R5OiBleHRyYWN0ZWRCb2R5LCB0eXBlIH07XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS50eXBlO1xuICAgICAgfVxuICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVybCA9IHJlc3BvbnNlVVJMKHRoaXNba1N0YXRlXSk7XG4gICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICB1cmwuaGFzaCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZ2V0IHJlZGlyZWN0ZWQoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udXJsTGlzdC5sZW5ndGggPiAxO1xuICAgICAgfVxuICAgICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXM7XG4gICAgICB9XG4gICAgICBnZXQgb2soKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW2tTdGF0ZV0uc3RhdHVzIDw9IDI5OTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0dXNUZXh0KCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1RleHQ7XG4gICAgICB9XG4gICAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdO1xuICAgICAgfVxuICAgICAgY2xvbmUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8IHRoaXMuYm9keSAmJiB0aGlzLmJvZHkubG9ja2VkKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlJlc3BvbnNlLmNsb25lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkJvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzW2tTdGF0ZV0pO1xuICAgICAgICBjb25zdCBjbG9uZWRSZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpO1xuICAgICAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVzcG9uc2U7XG4gICAgICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSB0aGlzW2tSZWFsbV07XG4gICAgICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gY2xvbmVkUmVzcG9uc2UuaGVhZGVyc0xpc3Q7XG4gICAgICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gdGhpc1trSGVhZGVyc11ba0d1YXJkXTtcbiAgICAgICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dO1xuICAgICAgICByZXR1cm4gY2xvbmVkUmVzcG9uc2VPYmplY3Q7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoUmVzcG9uc2UsIFwiUmVzcG9uc2VcIik7XG4gICAgbWl4aW5Cb2R5KFJlc3BvbnNlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgICAgIHR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBvazoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIHJlZGlyZWN0ZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGNsb25lOiBrRW51bWVyYWJsZVByb3BlcnR5XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2xvbmVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgICAgIGNsb25lUmVzcG9uc2UocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSksXG4gICAgICAgICAgcmVzcG9uc2UudHlwZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyAuLi5yZXNwb25zZSwgYm9keTogbnVsbCB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgbmV3UmVzcG9uc2UuYm9keSA9IGNsb25lQm9keShyZXNwb25zZS5ib2R5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdSZXNwb25zZTtcbiAgICB9XG4gICAgX19uYW1lKGNsb25lUmVzcG9uc2UsIFwiY2xvbmVSZXNwb25zZVwiKTtcbiAgICBmdW5jdGlvbiBtYWtlUmVzcG9uc2UoaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIHJhbmdlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgICAgICByZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICAgICAgY2FjaGVTdGF0ZTogXCJcIixcbiAgICAgICAgc3RhdHVzVGV4dDogXCJcIixcbiAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3QgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdC5oZWFkZXJzTGlzdCkgOiBuZXcgSGVhZGVyc0xpc3QoKSxcbiAgICAgICAgdXJsTGlzdDogaW5pdC51cmxMaXN0ID8gWy4uLmluaXQudXJsTGlzdF0gOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VSZXNwb25zZSwgXCJtYWtlUmVzcG9uc2VcIik7XG4gICAgZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pIHtcbiAgICAgIGNvbnN0IGlzRXJyb3IyID0gaXNFcnJvckxpa2UocmVhc29uKTtcbiAgICAgIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgZXJyb3I6IGlzRXJyb3IyID8gcmVhc29uIDogbmV3IEVycm9yKHJlYXNvbiA/IFN0cmluZyhyZWFzb24pIDogcmVhc29uLCB7XG4gICAgICAgICAgY2F1c2U6IGlzRXJyb3IyID8gcmVhc29uIDogdm9pZCAwXG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydGVkOiByZWFzb24gJiYgcmVhc29uLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VOZXR3b3JrRXJyb3IsIFwibWFrZU5ldHdvcmtFcnJvclwiKTtcbiAgICBmdW5jdGlvbiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgLi4uc3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFByb3h5KHJlc3BvbnNlLCB7XG4gICAgICAgIGdldCh0YXJnZXQsIHApIHtcbiAgICAgICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodGFyZ2V0LCBwLCB2YWx1ZSkge1xuICAgICAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKTtcbiAgICAgICAgICB0YXJnZXRbcF0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShtYWtlRmlsdGVyZWRSZXNwb25zZSwgXCJtYWtlRmlsdGVyZWRSZXNwb25zZVwiKTtcbiAgICBmdW5jdGlvbiBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFwiYmFzaWNcIikge1xuICAgICAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgICAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvcnNcIikge1xuICAgICAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgICAgICB0eXBlOiBcImNvcnNcIixcbiAgICAgICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAgICAgdHlwZTogXCJvcGFxdWVcIixcbiAgICAgICAgICB1cmxMaXN0OiBPYmplY3QuZnJlZXplKFtdKSxcbiAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgc3RhdHVzVGV4dDogXCJcIixcbiAgICAgICAgICBib2R5OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9wYXF1ZXJlZGlyZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAgICAgdHlwZTogXCJvcGFxdWVyZWRpcmVjdFwiLFxuICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBcIlwiLFxuICAgICAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgICAgICBib2R5OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZpbHRlclJlc3BvbnNlLCBcImZpbHRlclJlc3BvbnNlXCIpO1xuICAgIGZ1bmN0aW9uIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcykge1xuICAgICAgYXNzZXJ0KGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSk7XG4gICAgICByZXR1cm4gaXNBYm9ydGVkKGZldGNoUGFyYW1zKSA/IG1ha2VOZXR3b3JrRXJyb3IobmV3IERPTUV4Y2VwdGlvbihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKSkgOiBtYWtlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlZC5yZWFzb24pO1xuICAgIH1cbiAgICBfX25hbWUobWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLCBcIm1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvclwiKTtcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2UsIGluaXQsIGJvZHkpIHtcbiAgICAgIGlmIChpbml0LnN0YXR1cyAhPT0gbnVsbCAmJiAoaW5pdC5zdGF0dXMgPCAyMDAgfHwgaW5pdC5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0YXR1c1RleHRcIiBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFJlYXNvblBocmFzZShTdHJpbmcoaW5pdC5zdGF0dXNUZXh0KSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNUZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJzdGF0dXNcIiBpbiBpbml0ICYmIGluaXQuc3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2Vba1N0YXRlXS5zdGF0dXMgPSBpbml0LnN0YXR1cztcbiAgICAgIH1cbiAgICAgIGlmIChcInN0YXR1c1RleHRcIiBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChcImhlYWRlcnNcIiBpbiBpbml0ICYmIGluaXQuaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgIGZpbGwocmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdCwgaW5pdC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIGlmIChudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlJlc3BvbnNlIGNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZVtrU3RhdGVdLmJvZHkgPSBib2R5LmJvZHk7XG4gICAgICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICAgICAgICByZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmFwcGVuZChcImNvbnRlbnQtdHlwZVwiLCBib2R5LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShpbml0aWFsaXplUmVzcG9uc2UsIFwiaW5pdGlhbGl6ZVJlc3BvbnNlXCIpO1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgICAgIFJlYWRhYmxlU3RyZWFtXG4gICAgKTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gICAgICBGb3JtRGF0YVxuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgICAgIFVSTFNlYXJjaFBhcmFtc1xuICAgICk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGlmICh0eXBlb2YgViA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoVik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSB8fCB0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHwgdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYpO1xuICAgICAgfVxuICAgICAgaWYgKFYgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEoVik7XG4gICAgICB9XG4gICAgICBpZiAoViBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKTtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0ID0gZnVuY3Rpb24oVikge1xuICAgICAgaWYgKFYgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0oVik7XG4gICAgICB9XG4gICAgICBpZiAoViA9PSBudWxsID8gdm9pZCAwIDogVltTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIFY7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdChWKTtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgICAgIHtcbiAgICAgICAga2V5OiBcInN0YXR1c1wiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzW1widW5zaWduZWQgc2hvcnRcIl0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMjAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwic3RhdHVzVGV4dFwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImhlYWRlcnNcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICAgICAgfVxuICAgIF0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIG1ha2VOZXR3b3JrRXJyb3IsXG4gICAgICBtYWtlUmVzcG9uc2UsXG4gICAgICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gICAgICBmaWx0ZXJSZXNwb25zZSxcbiAgICAgIFJlc3BvbnNlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3JlcXVlc3QuanNcbnZhciByZXF1aXJlX3JlcXVlc3QyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVxdWVzdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBleHRyYWN0Qm9keSwgbWl4aW5Cb2R5LCBjbG9uZUJvZHkgfSA9IHJlcXVpcmVfYm9keSgpO1xuICAgIHZhciB7IEhlYWRlcnMsIGZpbGw6IGZpbGxIZWFkZXJzLCBIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZV9oZWFkZXJzKCk7XG4gICAgdmFyIHsgRmluYWxpemF0aW9uUmVnaXN0cnkgfSA9IHJlcXVpcmVfZGlzcGF0Y2hlcl93ZWFrcmVmKCkoKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHtcbiAgICAgIGlzVmFsaWRIVFRQVG9rZW4sXG4gICAgICBzYW1lT3JpZ2luLFxuICAgICAgbm9ybWFsaXplTWV0aG9kXG4gICAgfSA9IHJlcXVpcmVfdXRpbDMoKTtcbiAgICB2YXIge1xuICAgICAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgICAgIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgICAgIHJlZmVycmVyUG9saWN5LFxuICAgICAgcmVxdWVzdFJlZGlyZWN0LFxuICAgICAgcmVxdWVzdE1vZGUsXG4gICAgICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0Q2FjaGVcbiAgICB9ID0gcmVxdWlyZV9jb25zdGFudHMoKTtcbiAgICB2YXIgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSB1dGlsMjtcbiAgICB2YXIgeyBrSGVhZGVycywga1NpZ25hbCwga1N0YXRlLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZV9zeW1ib2xzMigpO1xuICAgIHZhciB7IHdlYmlkbCB9ID0gcmVxdWlyZV93ZWJpZGwoKTtcbiAgICB2YXIgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmVfc3ltYm9scygpO1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciBUcmFuc2Zvcm1TdHJlYW07XG4gICAgdmFyIGtJbml0ID0gU3ltYm9sKFwiaW5pdFwiKTtcbiAgICB2YXIgcmVxdWVzdEZpbmFsaXplciA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBzaWduYWwsIGFib3J0IH0pID0+IHtcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgIH0pO1xuICAgIHZhciBSZXF1ZXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICAgIGlmIChpbnB1dCA9PT0ga0luaXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oaW5wdXQpO1xuICAgICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQoaW5pdCk7XG4gICAgICAgIHRoaXNba1JlYWxtXSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH07XG4gICAgICAgIGxldCByZXF1ZXN0MiA9IG51bGw7XG4gICAgICAgIGxldCBmYWxsYmFja01vZGUgPSBudWxsO1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LmJhc2VVcmw7XG4gICAgICAgIGxldCBzaWduYWwgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbGV0IHBhcnNlZFVSTDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCwgYmFzZVVybCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tIFwiICsgaW5wdXQsIHsgY2F1c2U6IGVyciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSB8fCBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVxdWVzdCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZnJvbSBhIFVSTCB0aGF0IGluY2x1ZGVzIGNyZWRlbnRpYWxzOiBcIiArIGlucHV0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0MiA9IG1ha2VSZXF1ZXN0KHsgdXJsTGlzdDogW3BhcnNlZFVSTF0gfSk7XG4gICAgICAgICAgZmFsbGJhY2tNb2RlID0gXCJjb3JzXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCk7XG4gICAgICAgICAgcmVxdWVzdDIgPSBpbnB1dFtrU3RhdGVdO1xuICAgICAgICAgIHNpZ25hbCA9IGlucHV0W2tTaWduYWxdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5vcmlnaW47XG4gICAgICAgIGxldCB3aW5kb3cyID0gXCJjbGllbnRcIjtcbiAgICAgICAgaWYgKCgoX2IyID0gKF9hMyA9IHJlcXVlc3QyLndpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5uYW1lKSA9PT0gXCJFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XCIgJiYgc2FtZU9yaWdpbihyZXF1ZXN0Mi53aW5kb3csIG9yaWdpbikpIHtcbiAgICAgICAgICB3aW5kb3cyID0gcmVxdWVzdDIud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LndpbmRvdyAhPT0gdm9pZCAwICYmIGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnd2luZG93JyBvcHRpb24gJyR7d2luZG93Mn0nIG11c3QgYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LndpbmRvdyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgd2luZG93MiA9IFwibm8td2luZG93XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdDIgPSBtYWtlUmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Mi5tZXRob2QsXG4gICAgICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QyLmhlYWRlcnNMaXN0LFxuICAgICAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QyLnVuc2FmZVJlcXVlc3QsXG4gICAgICAgICAgY2xpZW50OiB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3QsXG4gICAgICAgICAgd2luZG93OiB3aW5kb3cyLFxuICAgICAgICAgIHByaW9yaXR5OiByZXF1ZXN0Mi5wcmlvcml0eSxcbiAgICAgICAgICBvcmlnaW46IHJlcXVlc3QyLm9yaWdpbixcbiAgICAgICAgICByZWZlcnJlcjogcmVxdWVzdDIucmVmZXJyZXIsXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QyLnJlZmVycmVyUG9saWN5LFxuICAgICAgICAgIG1vZGU6IHJlcXVlc3QyLm1vZGUsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QyLmNyZWRlbnRpYWxzLFxuICAgICAgICAgIGNhY2hlOiByZXF1ZXN0Mi5jYWNoZSxcbiAgICAgICAgICByZWRpcmVjdDogcmVxdWVzdDIucmVkaXJlY3QsXG4gICAgICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0Mi5pbnRlZ3JpdHksXG4gICAgICAgICAga2VlcGFsaXZlOiByZXF1ZXN0Mi5rZWVwYWxpdmUsXG4gICAgICAgICAgcmVsb2FkTmF2aWdhdGlvbjogcmVxdWVzdDIucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgICAgICBoaXN0b3J5TmF2aWdhdGlvbjogcmVxdWVzdDIuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QyLnVybExpc3RdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5tb2RlID09PSBcIm5hdmlnYXRlXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3QyLm1vZGUgPSBcInNhbWUtb3JpZ2luXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QyLnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICByZXF1ZXN0Mi5oaXN0b3J5TmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHJlcXVlc3QyLm9yaWdpbiA9IFwiY2xpZW50XCI7XG4gICAgICAgICAgcmVxdWVzdDIucmVmZXJyZXIgPSBcImNsaWVudFwiO1xuICAgICAgICAgIHJlcXVlc3QyLnJlZmVycmVyUG9saWN5ID0gXCJcIjtcbiAgICAgICAgICByZXF1ZXN0Mi51cmwgPSByZXF1ZXN0Mi51cmxMaXN0W3JlcXVlc3QyLnVybExpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcmVxdWVzdDIudXJsTGlzdCA9IFtyZXF1ZXN0Mi51cmxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LnJlZmVycmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCByZWZlcnJlciA9IGluaXQucmVmZXJyZXI7XG4gICAgICAgICAgaWYgKHJlZmVycmVyID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlciA9IFwibm8tcmVmZXJyZXJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFJlZmVycmVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkUmVmZXJyZXIgPSBuZXcgVVJMKHJlZmVycmVyLCBiYXNlVXJsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWZlcnJlciBcIiR7cmVmZXJyZXJ9XCIgaXMgbm90IGEgdmFsaWQgVVJMLmAsIHsgY2F1c2U6IGVyciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QyLnJlZmVycmVyID0gcGFyc2VkUmVmZXJyZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LnJlZmVycmVyUG9saWN5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3k7XG4gICAgICAgICAgaWYgKCFyZWZlcnJlclBvbGljeS5pbmNsdWRlcyhyZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogVGhlIHByb3ZpZGVkIHZhbHVlICcke3JlcXVlc3QyLnJlZmVycmVyUG9saWN5fScgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIFJlZmVycmVyUG9saWN5LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RlO1xuICAgICAgICBpZiAoaW5pdC5tb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBtb2RlID0gaW5pdC5tb2RlO1xuICAgICAgICAgIGlmICghcmVxdWVzdE1vZGUuaW5jbHVkZXMobW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogVGhlIHByb3ZpZGVkIHZhbHVlICcke3JlcXVlc3QyLm1vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgUmVxdWVzdE1vZGUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZSA9IGZhbGxiYWNrTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSA9PT0gXCJuYXZpZ2F0ZVwiKSB7XG4gICAgICAgICAgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBcIlJlcXVlc3QgY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiaW52YWxpZCByZXF1ZXN0IG1vZGUgbmF2aWdhdGUuXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVxdWVzdDIubW9kZSA9IG1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQuY3JlZGVudGlhbHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlcXVlc3QyLmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFscztcbiAgICAgICAgICBpZiAoIXJlcXVlc3RDcmVkZW50aWFscy5pbmNsdWRlcyhyZXF1ZXN0Mi5jcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogVGhlIHByb3ZpZGVkIHZhbHVlICcke3JlcXVlc3QyLmNyZWRlbnRpYWxzfScgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIFJlcXVlc3RDcmVkZW50aWFscy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5jYWNoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVxdWVzdDIuY2FjaGUgPSBpbml0LmNhY2hlO1xuICAgICAgICAgIGlmICghcmVxdWVzdENhY2hlLmluY2x1ZGVzKHJlcXVlc3QyLmNhY2hlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiBUaGUgcHJvdmlkZWQgdmFsdWUgJyR7cmVxdWVzdDIuY2FjaGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgUmVxdWVzdENhY2hlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5jYWNoZSA9PT0gXCJvbmx5LWlmLWNhY2hlZFwiICYmIHJlcXVlc3QyLm1vZGUgIT09IFwic2FtZS1vcmlnaW5cIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIidvbmx5LWlmLWNhY2hlZCcgY2FuIGJlIHNldCBvbmx5IHdpdGggJ3NhbWUtb3JpZ2luJyBtb2RlXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0LnJlZGlyZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXF1ZXN0Mi5yZWRpcmVjdCA9IGluaXQucmVkaXJlY3Q7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0UmVkaXJlY3QuaW5jbHVkZXMocmVxdWVzdDIucmVkaXJlY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IFRoZSBwcm92aWRlZCB2YWx1ZSAnJHtyZXF1ZXN0Mi5yZWRpcmVjdH0nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBSZXF1ZXN0UmVkaXJlY3QuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQuaW50ZWdyaXR5ICE9PSB2b2lkIDAgJiYgaW5pdC5pbnRlZ3JpdHkgIT0gbnVsbCkge1xuICAgICAgICAgIHJlcXVlc3QyLmludGVncml0eSA9IFN0cmluZyhpbml0LmludGVncml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXQua2VlcGFsaXZlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXF1ZXN0Mi5rZWVwYWxpdmUgPSBCb29sZWFuKGluaXQua2VlcGFsaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5tZXRob2QgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZDtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4oaW5pdC5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYCcke2luaXQubWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JiaWRkZW5NZXRob2RzLmluZGV4T2YobWV0aG9kLnRvVXBwZXJDYXNlKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKGAnJHtpbml0Lm1ldGhvZH0nIEhUVFAgbWV0aG9kIGlzIHVuc3VwcG9ydGVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXRob2QgPSBub3JtYWxpemVNZXRob2QoaW5pdC5tZXRob2QpO1xuICAgICAgICAgIHJlcXVlc3QyLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdC5zaWduYWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHNpZ25hbCA9IGluaXQuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba1N0YXRlXSA9IHJlcXVlc3QyO1xuICAgICAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpc1trU2lnbmFsXSA9IGFjLnNpZ25hbDtcbiAgICAgICAgdGhpc1trU2lnbmFsXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dO1xuICAgICAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXNpZ25hbCB8fCB0eXBlb2Ygc2lnbmFsLmFib3J0ZWQgIT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFjLmFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gYWMuYWJvcnQoc2lnbmFsLnJlYXNvbiksIFwiYWJvcnRcIik7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICByZXF1ZXN0RmluYWxpemVyLnJlZ2lzdGVyKHRoaXMsIHsgc2lnbmFsLCBhYm9ydCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycygpO1xuICAgICAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVxdWVzdDIuaGVhZGVyc0xpc3Q7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSBcInJlcXVlc3RcIjtcbiAgICAgICAgdGhpc1trSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba1JlYWxtXTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwibm8tY29yc1wiKSB7XG4gICAgICAgICAgaWYgKCFjb3JzU2FmZUxpc3RlZE1ldGhvZHMuaW5jbHVkZXMocmVxdWVzdDIubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYCcke3JlcXVlc3QyLm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSBcInJlcXVlc3Qtbm8tY29yc1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpbml0KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXNba0hlYWRlcnNdKTtcbiAgICAgICAgICBpZiAoaW5pdC5oZWFkZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0uY2xlYXIoKTtcbiAgICAgICAgICBpZiAoaGVhZGVycy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkhlYWRlcnNcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgdGhpc1trSGVhZGVyc10uYXBwZW5kKGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbEhlYWRlcnModGhpc1trSGVhZGVyc10sIGhlYWRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dEJvZHkgPSBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dFtrU3RhdGVdLmJvZHkgOiBudWxsO1xuICAgICAgICBpZiAoKGluaXQuYm9keSAhPT0gdm9pZCAwICYmIGluaXQuYm9keSAhPSBudWxsIHx8IGlucHV0Qm9keSAhPSBudWxsKSAmJiAocmVxdWVzdDIubWV0aG9kID09PSBcIkdFVFwiIHx8IHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJIRUFEXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXRCb2R5ID0gbnVsbDtcbiAgICAgICAgaWYgKGluaXQuYm9keSAhPT0gdm9pZCAwICYmIGluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KFxuICAgICAgICAgICAgaW5pdC5ib2R5LFxuICAgICAgICAgICAgcmVxdWVzdDIua2VlcGFsaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbml0Qm9keSA9IGV4dHJhY3RlZEJvZHk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzW2tIZWFkZXJzXS5oYXMoXCJjb250ZW50LXR5cGVcIikpIHtcbiAgICAgICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZChcImNvbnRlbnQtdHlwZVwiLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0T3JJbml0Qm9keSA9IGluaXRCb2R5ICE9IG51bGwgPyBpbml0Qm9keSA6IGlucHV0Qm9keTtcbiAgICAgICAgaWYgKGlucHV0T3JJbml0Qm9keSAhPSBudWxsICYmIGlucHV0T3JJbml0Qm9keS5zb3VyY2UgPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Mi5tb2RlICE9PSBcInNhbWUtb3JpZ2luXCIgJiYgcmVxdWVzdDIubW9kZSAhPT0gXCJjb3JzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICdJZiByZXF1ZXN0IGlzIG1hZGUgZnJvbSBSZWFkYWJsZVN0cmVhbSwgbW9kZSBzaG91bGQgYmUgXCJzYW1lLW9yaWdpblwiIG9yIFwiY29yc1wiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdDIudXNlQ09SU1ByZWZsaWdodEZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaW5hbEJvZHkgPSBpbnB1dE9ySW5pdEJvZHk7XG4gICAgICAgIGlmIChpbml0Qm9keSA9PSBudWxsICYmIGlucHV0Qm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHV0aWwyLmlzRGlzdHVyYmVkKGlucHV0Qm9keS5zdHJlYW0pIHx8IGlucHV0Qm9keS5zdHJlYW0ubG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBcIkNhbm5vdCBjb25zdHJ1Y3QgYSBSZXF1ZXN0IHdpdGggYSBSZXF1ZXN0IG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFUcmFuc2Zvcm1TdHJlYW0pIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpLlRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaWRlbnRpdHlUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgICAgICAgaW5wdXRCb2R5LnN0cmVhbS5waXBlVGhyb3VnaChpZGVudGl0eVRyYW5zZm9ybSk7XG4gICAgICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICAgICAgc291cmNlOiBpbnB1dEJvZHkuc291cmNlLFxuICAgICAgICAgICAgbGVuZ3RoOiBpbnB1dEJvZHkubGVuZ3RoLFxuICAgICAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trU3RhdGVdLmJvZHkgPSBmaW5hbEJvZHk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubWV0aG9kO1xuICAgICAgfVxuICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnVybC50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdO1xuICAgICAgfVxuICAgICAgZ2V0IGRlc3RpbmF0aW9uKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uZGVzdGluYXRpb247XG4gICAgICB9XG4gICAgICBnZXQgcmVmZXJyZXIoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gXCJuby1yZWZlcnJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gXCJjbGllbnRcIikge1xuICAgICAgICAgIHJldHVybiBcImFib3V0OmNsaWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGdldCByZWZlcnJlclBvbGljeSgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyUG9saWN5O1xuICAgICAgfVxuICAgICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5tb2RlO1xuICAgICAgfVxuICAgICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNyZWRlbnRpYWxzO1xuICAgICAgfVxuICAgICAgZ2V0IGNhY2hlKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY2FjaGU7XG4gICAgICB9XG4gICAgICBnZXQgcmVkaXJlY3QoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWRpcmVjdDtcbiAgICAgIH1cbiAgICAgIGdldCBpbnRlZ3JpdHkoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNba1N0YXRlXS5pbnRlZ3JpdHk7XG4gICAgICB9XG4gICAgICBnZXQga2VlcGFsaXZlKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ua2VlcGFsaXZlO1xuICAgICAgfVxuICAgICAgZ2V0IGlzUmVsb2FkTmF2aWdhdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlbG9hZE5hdmlnYXRpb247XG4gICAgICB9XG4gICAgICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU3RhdGVdLmhpc3RvcnlOYXZpZ2F0aW9uO1xuICAgICAgfVxuICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1trU2lnbmFsXTtcbiAgICAgIH1cbiAgICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8ICgoX2EzID0gdGhpcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmxvY2tlZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidW51c2FibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvbmVkUmVxdWVzdCA9IGNsb25lUmVxdWVzdCh0aGlzW2tTdGF0ZV0pO1xuICAgICAgICBjb25zdCBjbG9uZWRSZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3Qoa0luaXQpO1xuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tTdGF0ZV0gPSBjbG9uZWRSZXF1ZXN0O1xuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tSZWFsbV0gPSB0aGlzW2tSZWFsbV07XG4gICAgICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IGNsb25lZFJlcXVlc3QuaGVhZGVyc0xpc3Q7XG4gICAgICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdO1xuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXTtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgYWMuYWJvcnQodGhpcy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tTaWduYWxdID0gYWMuc2lnbmFsO1xuICAgICAgICByZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fbmFtZShSZXF1ZXN0LCBcIlJlcXVlc3RcIik7XG4gICAgbWl4aW5Cb2R5KFJlcXVlc3QpO1xuICAgIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KGluaXQpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QyID0ge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGxvY2FsVVJMc09ubHk6IGZhbHNlLFxuICAgICAgICB1bnNhZmVSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgY2xpZW50OiBudWxsLFxuICAgICAgICByZXNlcnZlZENsaWVudDogbnVsbCxcbiAgICAgICAgcmVwbGFjZXNDbGllbnRJZDogXCJcIixcbiAgICAgICAgd2luZG93OiBcImNsaWVudFwiLFxuICAgICAgICBrZWVwYWxpdmU6IGZhbHNlLFxuICAgICAgICBzZXJ2aWNlV29ya2VyczogXCJhbGxcIixcbiAgICAgICAgaW5pdGlhdG9yOiBcIlwiLFxuICAgICAgICBkZXN0aW5hdGlvbjogXCJcIixcbiAgICAgICAgcHJpb3JpdHk6IG51bGwsXG4gICAgICAgIG9yaWdpbjogXCJjbGllbnRcIixcbiAgICAgICAgcG9saWN5Q29udGFpbmVyOiBcImNsaWVudFwiLFxuICAgICAgICByZWZlcnJlcjogXCJjbGllbnRcIixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IFwiXCIsXG4gICAgICAgIG1vZGU6IFwibm8tY29yc1wiLFxuICAgICAgICB1c2VDT1JTUHJlZmxpZ2h0RmxhZzogZmFsc2UsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIHVzZUNyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgY2FjaGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgICAgaW50ZWdyaXR5OiBcIlwiLFxuICAgICAgICBjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6IFwiXCIsXG4gICAgICAgIHBhcnNlck1ldGFkYXRhOiBcIlwiLFxuICAgICAgICByZWxvYWROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgaGlzdG9yeU5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICB1c2VyQWN0aXZhdGlvbjogZmFsc2UsXG4gICAgICAgIHRhaW50ZWRPcmlnaW46IGZhbHNlLFxuICAgICAgICByZWRpcmVjdENvdW50OiAwLFxuICAgICAgICByZXNwb25zZVRhaW50aW5nOiBcImJhc2ljXCIsXG4gICAgICAgIHByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHRpbWluZ0FsbG93RmFpbGVkOiBmYWxzZSxcbiAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3QgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdC5oZWFkZXJzTGlzdCkgOiBuZXcgSGVhZGVyc0xpc3QoKVxuICAgICAgfTtcbiAgICAgIHJlcXVlc3QyLnVybCA9IHJlcXVlc3QyLnVybExpc3RbMF07XG4gICAgICByZXR1cm4gcmVxdWVzdDI7XG4gICAgfVxuICAgIF9fbmFtZShtYWtlUmVxdWVzdCwgXCJtYWtlUmVxdWVzdFwiKTtcbiAgICBmdW5jdGlvbiBjbG9uZVJlcXVlc3QocmVxdWVzdDIpIHtcbiAgICAgIGNvbnN0IG5ld1JlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IC4uLnJlcXVlc3QyLCBib2R5OiBudWxsIH0pO1xuICAgICAgaWYgKHJlcXVlc3QyLmJvZHkgIT0gbnVsbCkge1xuICAgICAgICBuZXdSZXF1ZXN0LmJvZHkgPSBjbG9uZUJvZHkocmVxdWVzdDIuYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UmVxdWVzdDtcbiAgICB9XG4gICAgX19uYW1lKGNsb25lUmVxdWVzdCwgXCJjbG9uZVJlcXVlc3RcIik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgICAgIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gICAgICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgICAgIGNsb25lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICAgICAgc2lnbmFsOiBrRW51bWVyYWJsZVByb3BlcnR5XG4gICAgfSk7XG4gICAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gICAgICBSZXF1ZXN0XG4gICAgKTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKFYpIHtcbiAgICAgIGlmICh0eXBlb2YgViA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpO1xuICAgICAgfVxuICAgICAgaWYgKFYgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0KFYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKTtcbiAgICB9O1xuICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgICAgIEFib3J0U2lnbmFsXG4gICAgKTtcbiAgICB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIm1ldGhvZFwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJoZWFkZXJzXCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJib2R5XCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJyZWZlcnJlclwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgICAgICBhbGxvd2VkVmFsdWVzOiBbXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBcIm5vLXJlZmVycmVyXCIsXG4gICAgICAgICAgXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLFxuICAgICAgICAgIFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICBcIm9yaWdpblwiLFxuICAgICAgICAgIFwic3RyaWN0LW9yaWdpblwiLFxuICAgICAgICAgIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICAgICAgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICAgICAgXCJ1bnNhZmUtdXJsXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIm1vZGVcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcbiAgICAgICAgICBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgICAgXCJjb3JzXCIsXG4gICAgICAgICAgXCJuby1jb3JzXCIsXG4gICAgICAgICAgXCJuYXZpZ2F0ZVwiLFxuICAgICAgICAgIFwid2Vic29ja2V0XCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImNyZWRlbnRpYWxzXCIsXG4gICAgICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgICAgICBhbGxvd2VkVmFsdWVzOiBbXG4gICAgICAgICAgXCJvbWl0XCIsXG4gICAgICAgICAgXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICAgIFwiaW5jbHVkZVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJjYWNoZVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogW1xuICAgICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICAgIFwibm8tc3RvcmVcIixcbiAgICAgICAgICBcInJlbG9hZFwiLFxuICAgICAgICAgIFwibm8tY2FjaGVcIixcbiAgICAgICAgICBcImZvcmNlLWNhY2hlXCIsXG4gICAgICAgICAgXCJvbmx5LWlmLWNhY2hlZFwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJyZWRpcmVjdFwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogW1xuICAgICAgICAgIFwiZm9sbG93XCIsXG4gICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgIFwibWFudWFsXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImludGVncml0eVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcImtlZXBhbGl2ZVwiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW5cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJzaWduYWxcIixcbiAgICAgICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICB7IHN0cmljdDogZmFsc2UgfVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIndpbmRvd1wiLFxuICAgICAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICAgICAgfVxuICAgIF0pO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsgUmVxdWVzdCwgbWFrZVJlcXVlc3QgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91bmRpY2lANS4xMC4wL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2RhdGFVUkwuanNcbnZhciByZXF1aXJlX2RhdGFVUkwgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICAgIHZhciB7IGF0b2I6IGF0b2IyIH0gPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuICAgIHZhciBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgZnVuY3Rpb24gZGF0YVVSTFByb2Nlc3NvcihkYXRhVVJMKSB7XG4gICAgICBhc3NlcnQoZGF0YVVSTC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKTtcbiAgICAgIGxldCBpbnB1dCA9IFVSTFNlcmlhbGl6ZXIoZGF0YVVSTCwgdHJ1ZSk7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDUpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH07XG4gICAgICBsZXQgbWltZVR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gXCIsXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1pbWVUeXBlTGVuZ3RoID0gbWltZVR5cGUubGVuZ3RoO1xuICAgICAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC9eKFxcdTAwMjApK3woXFx1MDAyMCkrJC9nLCBcIlwiKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFpbHVyZVwiO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgIGNvbnN0IGVuY29kZWRCb2R5ID0gaW5wdXQuc2xpY2UobWltZVR5cGVMZW5ndGggKyAxKTtcbiAgICAgIGxldCBib2R5ID0gc3RyaW5nUGVyY2VudERlY29kZShlbmNvZGVkQm9keSk7XG4gICAgICBpZiAoLzsoXFx1MDAyMCl7MCx9YmFzZTY0JC9pLnRlc3QobWltZVR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBkZWNvZGVVUklDb21wb25lbnQobmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKGJvZHkpKTtcbiAgICAgICAgYm9keSA9IGZvcmdpdmluZ0Jhc2U2NChzdHJpbmdCb2R5KTtcbiAgICAgICAgaWYgKGJvZHkgPT09IFwiZmFpbHVyZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZmFpbHVyZVwiO1xuICAgICAgICB9XG4gICAgICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTYpO1xuICAgICAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLyhcXHUwMDIwKSskLywgXCJcIik7XG4gICAgICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoXCI7XCIpKSB7XG4gICAgICAgIG1pbWVUeXBlID0gXCJ0ZXh0L3BsYWluXCIgKyBtaW1lVHlwZTtcbiAgICAgIH1cbiAgICAgIGxldCBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpO1xuICAgICAgaWYgKG1pbWVUeXBlUmVjb3JkID09PSBcImZhaWx1cmVcIikge1xuICAgICAgICBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUoXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtaW1lVHlwZTogbWltZVR5cGVSZWNvcmQsIGJvZHkgfTtcbiAgICB9XG4gICAgX19uYW1lKGRhdGFVUkxQcm9jZXNzb3IsIFwiZGF0YVVSTFByb2Nlc3NvclwiKTtcbiAgICBmdW5jdGlvbiBVUkxTZXJpYWxpemVyKHVybCwgZXhjbHVkZUZyYWdtZW50ID0gZmFsc2UpIHtcbiAgICAgIGxldCBvdXRwdXQgPSB1cmwucHJvdG9jb2w7XG4gICAgICBpZiAodXJsLmhvc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXRwdXQgKz0gXCIvL1wiO1xuICAgICAgICBpZiAodXJsLnVzZXJuYW1lLmxlbmd0aCA+IDAgfHwgdXJsLnBhc3N3b3JkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvdXRwdXQgKz0gdXJsLnVzZXJuYW1lO1xuICAgICAgICAgIGlmICh1cmwucGFzc3dvcmQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IFwiOlwiICsgdXJsLnBhc3N3b3JkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQgKz0gXCJAXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IGRlY29kZVVSSUNvbXBvbmVudCh1cmwuaG9zdCk7XG4gICAgICAgIGlmICh1cmwucG9ydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3V0cHV0ICs9IFwiOlwiICsgdXJsLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaG9zdC5sZW5ndGggPT09IDAgJiYgdXJsLnBhdGhuYW1lLmxlbmd0aCA+IDEgJiYgdXJsLmhyZWYuc2xpY2UodXJsLnByb3RvY29sLmxlbmd0aCArIDEpWzBdID09PSBcIi5cIikge1xuICAgICAgICBvdXRwdXQgKz0gXCIvLlwiO1xuICAgICAgfVxuICAgICAgb3V0cHV0ICs9IHVybC5wYXRobmFtZTtcbiAgICAgIGlmICh1cmwuc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0cHV0ICs9IHVybC5zZWFyY2g7XG4gICAgICB9XG4gICAgICBpZiAoZXhjbHVkZUZyYWdtZW50ID09PSBmYWxzZSAmJiB1cmwuaGFzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dHB1dCArPSB1cmwuaGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIF9fbmFtZShVUkxTZXJpYWxpemVyLCBcIlVSTFNlcmlhbGl6ZXJcIik7XG4gICAgZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGggJiYgY29uZGl0aW9uKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXTtcbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLCBcImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNcIik7XG4gICAgZnVuY3Rpb24gc3RyaW5nUGVyY2VudERlY29kZShpbnB1dCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShpbnB1dCk7XG4gICAgICByZXR1cm4gcGVyY2VudERlY29kZShieXRlcyk7XG4gICAgfVxuICAgIF9fbmFtZShzdHJpbmdQZXJjZW50RGVjb2RlLCBcInN0cmluZ1BlcmNlbnREZWNvZGVcIik7XG4gICAgZnVuY3Rpb24gcGVyY2VudERlY29kZShpbnB1dCkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBpbnB1dFtpXTtcbiAgICAgICAgaWYgKGJ5dGUgIT09IDM3KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYnl0ZSA9PT0gMzcgJiYgIS9eWzAtOUEtRmEtZl17Mn0kL2kudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2kgKyAxXSwgaW5wdXRbaSArIDJdKSkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgzNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV4dFR3b0J5dGVzID0gU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpICsgMV0sIGlucHV0W2kgKyAyXSk7XG4gICAgICAgICAgY29uc3QgYnl0ZVBvaW50ID0gTnVtYmVyLnBhcnNlSW50KG5leHRUd29CeXRlcywgMTYpO1xuICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVQb2ludCk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKG91dHB1dCk7XG4gICAgfVxuICAgIF9fbmFtZShwZXJjZW50RGVjb2RlLCBcInBlcmNlbnREZWNvZGVcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VNSU1FVHlwZShpbnB1dCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC50cmltKCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfTtcbiAgICAgIGNvbnN0IHR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gXCIvXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKTtcbiAgICAgIGlmICh0eXBlLmxlbmd0aCA9PT0gMCB8fCAhL15bISMkJSYnKistLl5ffH5BLXowLTldKyQvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFpbHVyZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcImZhaWx1cmVcIjtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSBcIjtcIixcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApO1xuICAgICAgc3VidHlwZSA9IHN1YnR5cGUudHJpbSgpO1xuICAgICAgaWYgKHN1YnR5cGUubGVuZ3RoID09PSAwIHx8ICEvXlshIyQlJicqKy0uXl98fkEtejAtOV0rJC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICByZXR1cm4gXCJmYWlsdXJlXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW1lVHlwZSA9IHtcbiAgICAgICAgdHlwZTogdHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBzdWJ0eXBlOiBzdWJ0eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHBhcmFtZXRlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgICAoY2hhcikgPT4gLyhcXHUwMDBBfFxcdTAwMER8XFx1MDAwOXxcXHUwMDIwKS8udGVzdChjaGFyKSxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBsZXQgcGFyYW1ldGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IFwiO1wiICYmIGNoYXIgIT09IFwiPVwiLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09IFwiO1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1ldGVyVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKSB7XG4gICAgICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKGlucHV0LCBwb3NpdGlvbik7XG4gICAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSBcIjtcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSBcIjtcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIHBhcmFtZXRlclZhbHVlID0gcGFyYW1ldGVyVmFsdWUudHJpbSgpO1xuICAgICAgICAgIGlmIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVyTmFtZS5sZW5ndGggIT09IDAgJiYgL15bISMkJSYnKistLl5ffH5BLXowLTldKyQvLnRlc3QocGFyYW1ldGVyTmFtZSkgJiYgIS9eKFxcdTAwMDl8XFx4ezAwMjB9LVxceHswMDdFfXxcXHh7MDA4MH0tXFx4ezAwRkZ9KSskLy50ZXN0KHBhcmFtZXRlclZhbHVlKSAmJiAhbWltZVR5cGUucGFyYW1ldGVycy5oYXMocGFyYW1ldGVyTmFtZSkpIHtcbiAgICAgICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldChwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlTUlNRVR5cGUsIFwicGFyc2VNSU1FVHlwZVwiKTtcbiAgICBmdW5jdGlvbiBmb3JnaXZpbmdCYXNlNjQoZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvW1xcdTAwMDlcXHUwMDBBXFx1MDAwQ1xcdTAwMERcXHUwMDIwXS9nLCBcIlwiKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvPT89JC8sIFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEubGVuZ3RoICUgNCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJmYWlsdXJlXCI7XG4gICAgICB9XG4gICAgICBpZiAoL1teKy8wLTlBLVphLXpdLy50ZXN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBcImZhaWx1cmVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IyKGRhdGEpO1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGJ5dGUgPSAwOyBieXRlIDwgYmluYXJ5Lmxlbmd0aDsgYnl0ZSsrKSB7XG4gICAgICAgIGJ5dGVzW2J5dGVdID0gYmluYXJ5LmNoYXJDb2RlQXQoYnl0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIF9fbmFtZShmb3JnaXZpbmdCYXNlNjQsIFwiZm9yZ2l2aW5nQmFzZTY0XCIpO1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCBleHRyYWN0VmFsdWUpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvbjtcbiAgICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKTtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKys7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09IFwiXFxcXFwiLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdW90ZU9yQmFja3NsYXNoID0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dO1xuICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbisrO1xuICAgICAgICBpZiAocXVvdGVPckJhY2tzbGFzaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBcIlxcXFxcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl07XG4gICAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1wiJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChleHRyYWN0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKHBvc2l0aW9uU3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgX19uYW1lKGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcsIFwiY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZ1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBkYXRhVVJMUHJvY2Vzc29yLFxuICAgICAgVVJMU2VyaWFsaXplcixcbiAgICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsXG4gICAgICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICAgICAgcGFyc2VNSU1FVHlwZSxcbiAgICAgIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmdcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaW5kZXguanNcbnZhciByZXF1aXJlX2ZldGNoID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VuZGljaUA1LjEwLjAvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHtcbiAgICAgIFJlc3BvbnNlLFxuICAgICAgbWFrZU5ldHdvcmtFcnJvcixcbiAgICAgIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgICAgIGZpbHRlclJlc3BvbnNlLFxuICAgICAgbWFrZVJlc3BvbnNlXG4gICAgfSA9IHJlcXVpcmVfcmVzcG9uc2UoKTtcbiAgICB2YXIgeyBIZWFkZXJzIH0gPSByZXF1aXJlX2hlYWRlcnMoKTtcbiAgICB2YXIgeyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZV9yZXF1ZXN0MigpO1xuICAgIHZhciB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG4gICAgdmFyIHtcbiAgICAgIGJ5dGVzTWF0Y2gsXG4gICAgICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICAgICAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gICAgICByZXF1ZXN0QmFkUG9ydCxcbiAgICAgIFRBT0NoZWNrLFxuICAgICAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgICAgIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgICAgIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gICAgICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gICAgICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICAgICAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgICAgIGNvcnNDaGVjayxcbiAgICAgIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgICAgIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gICAgICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgICAgIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgICAgIGlzQmxvYkxpa2UsXG4gICAgICBzYW1lT3JpZ2luLFxuICAgICAgaXNDYW5jZWxsZWQsXG4gICAgICBpc0Fib3J0ZWQsXG4gICAgICBpc0Vycm9yTGlrZSxcbiAgICAgIGZ1bGx5UmVhZEJvZHlcbiAgICB9ID0gcmVxdWlyZV91dGlsMygpO1xuICAgIHZhciB7IGtTdGF0ZSwga0hlYWRlcnMsIGtHdWFyZCwga1JlYWxtIH0gPSByZXF1aXJlX3N5bWJvbHMyKCk7XG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIHsgc2FmZWx5RXh0cmFjdEJvZHksIGV4dHJhY3RCb2R5IH0gPSByZXF1aXJlX2JvZHkoKTtcbiAgICB2YXIge1xuICAgICAgcmVkaXJlY3RTdGF0dXMsXG4gICAgICBudWxsQm9keVN0YXR1cyxcbiAgICAgIHNhZmVNZXRob2RzLFxuICAgICAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gICAgICBzdWJyZXNvdXJjZSxcbiAgICAgIERPTUV4Y2VwdGlvblxuICAgIH0gPSByZXF1aXJlX2NvbnN0YW50cygpO1xuICAgIHZhciB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZV9zeW1ib2xzKCk7XG4gICAgdmFyIEVFID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbiAgICB2YXIgeyBSZWFkYWJsZSwgcGlwZWxpbmUgfSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4gICAgdmFyIHsgaXNFcnJvcmVkLCBpc1JlYWRhYmxlIH0gPSByZXF1aXJlX3V0aWwyKCk7XG4gICAgdmFyIHsgZGF0YVVSTFByb2Nlc3NvciB9ID0gcmVxdWlyZV9kYXRhVVJMKCk7XG4gICAgdmFyIHsgVHJhbnNmb3JtU3RyZWFtIH0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKTtcbiAgICB2YXIgcmVzb2x2ZU9iamVjdFVSTDtcbiAgICB2YXIgUmVhZGFibGVTdHJlYW07XG4gICAgdmFyIG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgbm9kZU1ham9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzBdKTtcbiAgICB2YXIgbm9kZU1pbm9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzFdKTtcbiAgICB2YXIgRmV0Y2ggPSBjbGFzcyBleHRlbmRzIEVFIHtcbiAgICAgIGNvbnN0cnVjdG9yKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5kdW1wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcIm9uZ29pbmdcIjtcbiAgICAgIH1cbiAgICAgIHRlcm1pbmF0ZShyZWFzb24pIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwib25nb2luZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcInRlcm1pbmF0ZWRcIjtcbiAgICAgICAgKF9hMyA9IHRoaXMuY29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5kZXN0cm95KHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdChcInRlcm1pbmF0ZWRcIiwgcmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJvbmdvaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiYWJvcnRlZFwiO1xuICAgICAgICAoX2EzID0gdGhpcy5jb25uZWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmRlc3Ryb3kocmVhc29uKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidGVybWluYXRlZFwiLCByZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgX19uYW1lKEZldGNoLCBcIkZldGNoXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoMihpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdmZXRjaCcgb24gJ1dpbmRvdyc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICBsZXQgcmVxdWVzdE9iamVjdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHAucmVqZWN0KGUpO1xuICAgICAgICByZXR1cm4gcC5wcm9taXNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxdWVzdDIgPSByZXF1ZXN0T2JqZWN0W2tTdGF0ZV07XG4gICAgICBpZiAocmVxdWVzdE9iamVjdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QyLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHAucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdsb2JhbE9iamVjdCA9IHJlcXVlc3QyLmNsaWVudC5nbG9iYWxPYmplY3Q7XG4gICAgICBpZiAoKChfYTMgPSBnbG9iYWxPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5uYW1lKSA9PT0gXCJTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGVcIikge1xuICAgICAgICByZXF1ZXN0Mi5zZXJ2aWNlV29ya2VycyA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3BvbnNlT2JqZWN0ID0gbnVsbDtcbiAgICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSBudWxsO1xuICAgICAgbGV0IGxvY2FsbHlBYm9ydGVkID0gZmFsc2U7XG4gICAgICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gICAgICByZXF1ZXN0T2JqZWN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBsb2NhbGx5QWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0MiwgcmVzcG9uc2VPYmplY3QpO1xuICAgICAgICAgIGlmIChjb250cm9sbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgY29uc3QgaGFuZGxlRmV0Y2hEb25lID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocmVzcG9uc2UpID0+IGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCBcImZldGNoXCIpLCBcImhhbmRsZUZldGNoRG9uZVwiKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChsb2NhbGx5QWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdDIsIHJlc3BvbnNlT2JqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHAucmVqZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKFwiZmV0Y2ggZmFpbGVkXCIpLCB7IGNhdXNlOiByZXNwb25zZS5lcnJvciB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKCk7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0gPSByZXNwb25zZTtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG07XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVzcG9uc2UuaGVhZGVyc0xpc3Q7XG4gICAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gXCJpbW11dGFibGVcIjtcbiAgICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtO1xuICAgICAgICBwLnJlc29sdmUocmVzcG9uc2VPYmplY3QpO1xuICAgICAgfSwgXCJwcm9jZXNzUmVzcG9uc2VcIik7XG4gICAgICBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0MixcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5OiBoYW5kbGVGZXRjaERvbmUsXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICAgICAgZGlzcGF0Y2hlcjogdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcC5wcm9taXNlO1xuICAgIH1cbiAgICBfX25hbWUoZmV0Y2gyLCBcImZldGNoXCIpO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCBpbml0aWF0b3JUeXBlID0gXCJvdGhlclwiKSB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIiAmJiByZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKChfYTMgPSByZXNwb25zZS51cmxMaXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JpZ2luYWxVUkwgPSByZXNwb25zZS51cmxMaXN0WzBdO1xuICAgICAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvO1xuICAgICAgbGV0IGNhY2hlU3RhdGUgPSByZXNwb25zZS5jYWNoZVN0YXRlO1xuICAgICAgaWYgKCEvXmh0dHBzPzovLnRlc3Qob3JpZ2luYWxVUkwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1pbmdJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGltaW5nSW5mby50aW1pbmdBbGxvd1Bhc3NlZCkge1xuICAgICAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICAgICAgc3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgY2FjaGVTdGF0ZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXNwb25zZS50aW1pbmdJbmZvLmVuZFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSgpO1xuICAgICAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm87XG4gICAgICBtYXJrUmVzb3VyY2VUaW1pbmcoXG4gICAgICAgIHRpbWluZ0luZm8sXG4gICAgICAgIG9yaWdpbmFsVVJMLFxuICAgICAgICBpbml0aWF0b3JUeXBlLFxuICAgICAgICBnbG9iYWxUaGlzLFxuICAgICAgICBjYWNoZVN0YXRlXG4gICAgICApO1xuICAgIH1cbiAgICBfX25hbWUoZmluYWxpemVBbmRSZXBvcnRUaW1pbmcsIFwiZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcIik7XG4gICAgZnVuY3Rpb24gbWFya1Jlc291cmNlVGltaW5nKHRpbWluZ0luZm8sIG9yaWdpbmFsVVJMLCBpbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzMiwgY2FjaGVTdGF0ZSkge1xuICAgICAgaWYgKG5vZGVNYWpvciA+PSAxOCAmJiBub2RlTWlub3IgPj0gMikge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrUmVzb3VyY2VUaW1pbmcodGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMyLCBjYWNoZVN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1hcmtSZXNvdXJjZVRpbWluZywgXCJtYXJrUmVzb3VyY2VUaW1pbmdcIik7XG4gICAgZnVuY3Rpb24gYWJvcnRGZXRjaChwLCByZXF1ZXN0MiwgcmVzcG9uc2VPYmplY3QpIHtcbiAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgIGNvbnN0IGVycm9yMiA9IG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIik7XG4gICAgICBwLnJlamVjdChlcnJvcjIpO1xuICAgICAgaWYgKHJlcXVlc3QyLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKChfYTMgPSByZXF1ZXN0Mi5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnN0cmVhbSkpIHtcbiAgICAgICAgcmVxdWVzdDIuYm9keS5zdHJlYW0uY2FuY2VsKGVycm9yMikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJFUlJfSU5WQUxJRF9TVEFURVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2VPYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV07XG4gICAgICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUoKF9iMiA9IHJlc3BvbnNlLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuc3RyZWFtKSkge1xuICAgICAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IyKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVSUl9JTlZBTElEX1NUQVRFXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGFib3J0RmV0Y2gsIFwiYWJvcnRGZXRjaFwiKTtcbiAgICBmdW5jdGlvbiBmZXRjaGluZyh7XG4gICAgICByZXF1ZXN0OiByZXF1ZXN0MixcbiAgICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgICAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gICAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gICAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICAgIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgICAgIGRpc3BhdGNoZXJcbiAgICB9KSB7XG4gICAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgICAgIGxldCB0YXNrRGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2U7XG4gICAgICBpZiAocmVxdWVzdDIuY2xpZW50ICE9IG51bGwpIHtcbiAgICAgICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdDIuY2xpZW50Lmdsb2JhbE9iamVjdDtcbiAgICAgICAgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgPSByZXF1ZXN0Mi5jbGllbnQuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW5UaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpO1xuICAgICAgY29uc3QgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgICBzdGFydFRpbWU6IGN1cnJlblRpbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBGZXRjaChkaXNwYXRjaGVyKSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdDIsXG4gICAgICAgIHRpbWluZ0luZm8sXG4gICAgICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgICAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgICAgICB0YXNrRGVzdGluYXRpb24sXG4gICAgICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gICAgICB9O1xuICAgICAgYXNzZXJ0KCFyZXF1ZXN0Mi5ib2R5IHx8IHJlcXVlc3QyLmJvZHkuc3RyZWFtKTtcbiAgICAgIGlmIChyZXF1ZXN0Mi53aW5kb3cgPT09IFwiY2xpZW50XCIpIHtcbiAgICAgICAgcmVxdWVzdDIud2luZG93ID0gKChfYyA9IChfYjIgPSAoX2EzID0gcmVxdWVzdDIuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmdsb2JhbE9iamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm5hbWUpID09PSBcIldpbmRvd1wiID8gcmVxdWVzdDIuY2xpZW50IDogXCJuby13aW5kb3dcIjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5vcmlnaW4gPT09IFwiY2xpZW50XCIpIHtcbiAgICAgICAgcmVxdWVzdDIub3JpZ2luID0gKF9kID0gcmVxdWVzdDIuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Qub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QyLnBvbGljeUNvbnRhaW5lciA9PT0gXCJjbGllbnRcIikge1xuICAgICAgICBpZiAocmVxdWVzdDIuY2xpZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXF1ZXN0Mi5wb2xpY3lDb250YWluZXIgPSBjbG9uZVBvbGljeUNvbnRhaW5lcihcbiAgICAgICAgICAgIHJlcXVlc3QyLmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3QyLnBvbGljeUNvbnRhaW5lciA9IG1ha2VQb2xpY3lDb250YWluZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZXF1ZXN0Mi5oZWFkZXJzTGlzdC5oYXMoXCJhY2NlcHRcIikpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBcIiovKlwiO1xuICAgICAgICByZXF1ZXN0Mi5oZWFkZXJzTGlzdC5hcHBlbmQoXCJhY2NlcHRcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXF1ZXN0Mi5oZWFkZXJzTGlzdC5oYXMoXCJhY2NlcHQtbGFuZ3VhZ2VcIikpIHtcbiAgICAgICAgcmVxdWVzdDIuaGVhZGVyc0xpc3QuYXBwZW5kKFwiYWNjZXB0LWxhbmd1YWdlXCIsIFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgICAgfVxuICAgICAgaWYgKHN1YnJlc291cmNlLmluY2x1ZGVzKHJlcXVlc3QyLmRlc3RpbmF0aW9uKSkge1xuICAgICAgfVxuICAgICAgbWFpbkZldGNoKGZldGNoUGFyYW1zKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyO1xuICAgIH1cbiAgICBfX25hbWUoZmV0Y2hpbmcsIFwiZmV0Y2hpbmdcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFpbkZldGNoKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0O1xuICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgIGlmIChyZXF1ZXN0Mi5sb2NhbFVSTHNPbmx5ICYmICEvXihhYm91dHxibG9ifGRhdGEpOi8udGVzdChyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0MikucHJvdG9jb2wpKSB7XG4gICAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcihcImxvY2FsIFVSTHMgb25seVwiKTtcbiAgICAgIH1cbiAgICAgIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTChyZXF1ZXN0Mik7XG4gICAgICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdDIpID09PSBcImJsb2NrZWRcIikge1xuICAgICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoXCJiYWQgcG9ydFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSA9PT0gXCJcIikge1xuICAgICAgICByZXF1ZXN0Mi5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QyLnBvbGljeUNvbnRhaW5lci5yZWZlcnJlclBvbGljeTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5yZWZlcnJlciAhPT0gXCJuby1yZWZlcnJlclwiKSB7XG4gICAgICAgIHJlcXVlc3QyLnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0Mik7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0Mik7XG4gICAgICAgICAgaWYgKHNhbWVPcmlnaW4oY3VycmVudFVSTCwgcmVxdWVzdDIudXJsKSAmJiByZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcImJhc2ljXCIgfHwgY3VycmVudFVSTC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiIHx8IChyZXF1ZXN0Mi5tb2RlID09PSBcIm5hdmlnYXRlXCIgfHwgcmVxdWVzdDIubW9kZSA9PT0gXCJ3ZWJzb2NrZXRcIikpIHtcbiAgICAgICAgICAgIHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPSBcImJhc2ljXCI7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVxdWVzdDIubW9kZSA9PT0gXCJzYW1lLW9yaWdpblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcXVlc3QyLm1vZGUgPT09IFwibm8tY29yc1wiKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdDIucmVkaXJlY3QgIT09IFwiZm9sbG93XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3JlZGlyZWN0IG1vZGUgY2Fubm90IGJlIFwiZm9sbG93XCIgZm9yIFwibm8tY29yc1wiIHJlcXVlc3QnXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID0gXCJvcGFxdWVcIjtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghL15odHRwcz86Ly50ZXN0KHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QyKS5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPSBcImNvcnNcIjtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgaHR0cEZldGNoKGZldGNoUGFyYW1zKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJiAhcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgICAgICBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJjb3JzXCIpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJiYXNpY1wiKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgXCJiYXNpY1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcImNvcnNcIikge1xuICAgICAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsIFwiY29yc1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcIm9wYXF1ZVwiKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgXCJvcGFxdWVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGludGVybmFsUmVzcG9uc2UgPSByZXNwb25zZS5zdGF0dXMgPT09IDAgPyByZXNwb25zZSA6IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2U7XG4gICAgICBpZiAoaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QucHVzaCguLi5yZXF1ZXN0Mi51cmxMaXN0KTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVxdWVzdDIudGltaW5nQWxsb3dGYWlsZWQpIHtcbiAgICAgICAgcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwib3BhcXVlXCIgJiYgaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNiAmJiBpbnRlcm5hbFJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkICYmICFyZXF1ZXN0Mi5oZWFkZXJzLmhhcyhcInJhbmdlXCIpKSB7XG4gICAgICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDAgJiYgKHJlcXVlc3QyLm1ldGhvZCA9PT0gXCJIRUFEXCIgfHwgcmVxdWVzdDIubWV0aG9kID09PSBcIkNPTk5FQ1RcIiB8fCBudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cykpKSB7XG4gICAgICAgIGludGVybmFsUmVzcG9uc2UuYm9keSA9IG51bGw7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIuaW50ZWdyaXR5KSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChyZWFzb24pID0+IGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCBtYWtlTmV0d29ya0Vycm9yKHJlYXNvbikpLCBcInByb2Nlc3NCb2R5RXJyb3JcIik7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcIm9wYXF1ZVwiIHx8IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzQm9keSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFieXRlc01hdGNoKGJ5dGVzLCByZXF1ZXN0Mi5pbnRlZ3JpdHkpKSB7XG4gICAgICAgICAgICBwcm9jZXNzQm9keUVycm9yKFwiaW50ZWdyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZS5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkoYnl0ZXMpWzBdO1xuICAgICAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIH0sIFwicHJvY2Vzc0JvZHlcIik7XG4gICAgICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1haW5GZXRjaCwgXCJtYWluRmV0Y2hcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpIHtcbiAgICAgIGNvbnN0IHsgcmVxdWVzdDogcmVxdWVzdDIgfSA9IGZldGNoUGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcm90b2NvbDogc2NoZW1lLFxuICAgICAgICBwYXRobmFtZTogcGF0aDdcbiAgICAgIH0gPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0Mik7XG4gICAgICBzd2l0Y2ggKHNjaGVtZSkge1xuICAgICAgICBjYXNlIFwiYWJvdXQ6XCI6IHtcbiAgICAgICAgICBpZiAocGF0aDcgPT09IFwiYmxhbmtcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1ha2VSZXNwb25zZSh7XG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICAgICAgICBbXCJjb250ZW50LXR5cGVcIiwgXCJ0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOFwiXVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3AudXJsTGlzdCA9IFtuZXcgVVJMKFwiYWJvdXQ6YmxhbmtcIildO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiaW52YWxpZCBwYXRoIGNhbGxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmxvYjpcIjoge1xuICAgICAgICAgIHJlc29sdmVPYmplY3RVUkwgPSByZXNvbHZlT2JqZWN0VVJMIHx8IHJlcXVpcmUoXCJidWZmZXJcIikucmVzb2x2ZU9iamVjdFVSTDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgICAgIGlmIChjdXJyZW50VVJMLnNlYXJjaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJsb2IgPSByZXNvbHZlT2JqZWN0VVJMKGN1cnJlbnRVUkwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgaWYgKHJlcXVlc3QyLm1ldGhvZCAhPT0gXCJHRVRcIiB8fCAhaXNCbG9iTGlrZShibG9iKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXCJpbnZhbGlkIG1ldGhvZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyBzdGF0dXNUZXh0OiBcIk9LXCIsIHVybExpc3Q6IFtjdXJyZW50VVJMXSB9KTtcbiAgICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoXCJjb250ZW50LWxlbmd0aFwiLCBgJHtibG9iLnNpemV9YCk7XG4gICAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KFwiY29udGVudC10eXBlXCIsIGJsb2IudHlwZSk7XG4gICAgICAgICAgcmVzcG9uc2UuYm9keSA9IGV4dHJhY3RCb2R5KGJsb2IpWzBdO1xuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0Mik7XG4gICAgICAgICAgY29uc3QgZGF0YVVSTFN0cnVjdCA9IGRhdGFVUkxQcm9jZXNzb3IoY3VycmVudFVSTCk7XG4gICAgICAgICAgaWYgKGRhdGFVUkxTdHJ1Y3QgPT09IFwiZmFpbHVyZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcImZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgbWltZVR5cGUgfSA9IGRhdGFVUkxTdHJ1Y3Q7XG4gICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gYCR7bWltZVR5cGUudHlwZX0vJHttaW1lVHlwZS5zdWJ0eXBlfWA7XG4gICAgICAgICAgY29uc3QgY29udGVudFR5cGVQYXJhbXMgPSBbXTtcbiAgICAgICAgICBpZiAobWltZVR5cGUucGFyYW1ldGVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgKz0gXCI7XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1pbWVUeXBlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlUGFyYW1zLnB1c2goYCR7a2V5fT0ke3ZhbHVlfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudFR5cGVQYXJhbXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZW50VHlwZSArPSBjb250ZW50VHlwZVBhcmFtcy5qb2luKFwiLFwiKTtcbiAgICAgICAgICByZXR1cm4gbWFrZVJlc3BvbnNlKHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgICAgIFtcImNvbnRlbnQtdHlwZVwiLCBjb250ZW50VHlwZV1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBib2R5OiBleHRyYWN0Qm9keShkYXRhVVJMU3RydWN0LmJvZHkpWzBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbGU6XCI6IHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcIm5vdCBpbXBsZW1lbnRlZC4uLiB5ZXQuLi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpLmNhdGNoKChlcnIpID0+IG1ha2VOZXR3b3JrRXJyb3IoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwidW5rbm93biBzY2hlbWVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNjaGVtZUZldGNoLCBcInNjaGVtZUZldGNoXCIpO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlO1xuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUgIT0gbnVsbCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lKHJlc3BvbnNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaW5hbGl6ZVJlc3BvbnNlLCBcImZpbmFsaXplUmVzcG9uc2VcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHJlc3BvbnNlLnVybExpc3QgPSBbZmV0Y2hQYXJhbXMucmVxdWVzdC51cmxMaXN0WzBdXTtcbiAgICAgICAgcmVzcG9uc2UudGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgICAgIHN0YXJ0VGltZTogZmV0Y2hQYXJhbXMudGltaW5nSW5mby5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5XCIpO1xuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9LCBcImlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtXCIpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZm9ybTogaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0sXG4gICAgICAgICAgZmx1c2g6IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtOiByZXNwb25zZS5ib2R5LnN0cmVhbS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1TdHJlYW0pIH07XG4gICAgICB9XG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwcm9jZXNzQm9keSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG51bGxPckJ5dGVzKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keShyZXNwb25zZSwgbnVsbE9yQnl0ZXMpLCBcInByb2Nlc3NCb2R5XCIpO1xuICAgICAgICBjb25zdCBwcm9jZXNzQm9keUVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZmFpbHVyZSkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkocmVzcG9uc2UsIGZhaWx1cmUpLCBcInByb2Nlc3NCb2R5RXJyb3JcIik7XG4gICAgICAgIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBwcm9jZXNzQm9keShudWxsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgZnVsbHlSZWFkQm9keShyZXNwb25zZS5ib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZldGNoRmluYWxlLCBcImZldGNoRmluYWxlXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGh0dHBGZXRjaChmZXRjaFBhcmFtcykge1xuICAgICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0O1xuICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgIGxldCBhY3R1YWxSZXNwb25zZSA9IG51bGw7XG4gICAgICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mbztcbiAgICAgIGlmIChyZXF1ZXN0Mi5zZXJ2aWNlV29ya2VycyA9PT0gXCJhbGxcIikge1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi5yZWRpcmVjdCA9PT0gXCJmb2xsb3dcIikge1xuICAgICAgICAgIHJlcXVlc3QyLnNlcnZpY2VXb3JrZXJzID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKGZldGNoUGFyYW1zKTtcbiAgICAgICAgaWYgKHJlcXVlc3QyLnJlc3BvbnNlVGFpbnRpbmcgPT09IFwiY29yc1wiICYmIGNvcnNDaGVjayhyZXF1ZXN0MiwgcmVzcG9uc2UpID09PSBcImZhaWx1cmVcIikge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiY29ycyBmYWlsdXJlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUQU9DaGVjayhyZXF1ZXN0MiwgcmVzcG9uc2UpID09PSBcImZhaWx1cmVcIikge1xuICAgICAgICAgIHJlcXVlc3QyLnRpbWluZ0FsbG93RmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChyZXF1ZXN0Mi5yZXNwb25zZVRhaW50aW5nID09PSBcIm9wYXF1ZVwiIHx8IHJlc3BvbnNlLnR5cGUgPT09IFwib3BhcXVlXCIpICYmIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayhcbiAgICAgICAgcmVxdWVzdDIub3JpZ2luLFxuICAgICAgICByZXF1ZXN0Mi5jbGllbnQsXG4gICAgICAgIHJlcXVlc3QyLmRlc3RpbmF0aW9uLFxuICAgICAgICBhY3R1YWxSZXNwb25zZVxuICAgICAgKSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXCJibG9ja2VkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHJlcXVlc3QyLnJlZGlyZWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoXCJ1bmV4cGVjdGVkIHJlZGlyZWN0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3QyLnJlZGlyZWN0ID09PSBcIm1hbnVhbFwiKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhY3R1YWxSZXNwb25zZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Mi5yZWRpcmVjdCA9PT0gXCJmb2xsb3dcIikge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cFJlZGlyZWN0RmV0Y2goZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mbztcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgX19uYW1lKGh0dHBGZXRjaCwgXCJodHRwRmV0Y2hcIik7XG4gICAgYXN5bmMgZnVuY3Rpb24gaHR0cFJlZGlyZWN0RmV0Y2goZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCByZXF1ZXN0MiA9IGZldGNoUGFyYW1zLnJlcXVlc3Q7XG4gICAgICBjb25zdCBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UgPyByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlIDogcmVzcG9uc2U7XG4gICAgICBsZXQgbG9jYXRpb25VUkw7XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhdGlvblVSTCA9IHJlc3BvbnNlTG9jYXRpb25VUkwoXG4gICAgICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICAgICAgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpLmhhc2hcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKCEvXmh0dHBzPzovLnRlc3QobG9jYXRpb25VUkwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwiVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIucmVkaXJlY3RDb3VudCA9PT0gMjApIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXCJyZWRpcmVjdCBjb3VudCBleGNlZWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QyLnJlZGlyZWN0Q291bnQgKz0gMTtcbiAgICAgIGlmIChyZXF1ZXN0Mi5tb2RlID09PSBcImNvcnNcIiAmJiAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpICYmICFzYW1lT3JpZ2luKHJlcXVlc3QyLCBsb2NhdGlvblVSTCkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJjb3JzXCIgJiYgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSkge1xuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAnVVJMIGNhbm5vdCBjb250YWluIGNyZWRlbnRpYWxzIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzICE9PSAzMDMgJiYgcmVxdWVzdDIuYm9keSAhPSBudWxsICYmIHJlcXVlc3QyLmJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChbMzAxLCAzMDJdLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykgJiYgcmVxdWVzdDIubWV0aG9kID09PSBcIlBPU1RcIiB8fCBhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJiAhW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyhyZXF1ZXN0Mi5tZXRob2QpKSB7XG4gICAgICAgIHJlcXVlc3QyLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIHJlcXVlc3QyLmJvZHkgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgcmVxdWVzdEJvZHlIZWFkZXIpIHtcbiAgICAgICAgICByZXF1ZXN0Mi5oZWFkZXJzTGlzdC5kZWxldGUoaGVhZGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0Mi5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0KHJlcXVlc3QyLmJvZHkuc291cmNlKTtcbiAgICAgICAgcmVxdWVzdDIuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KHJlcXVlc3QyLmJvZHkuc291cmNlKVswXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvO1xuICAgICAgdGltaW5nSW5mby5yZWRpcmVjdEVuZFRpbWUgPSB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KTtcbiAgICAgIGlmICh0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID09PSAwKSB7XG4gICAgICAgIHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPSB0aW1pbmdJbmZvLnN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QyLnVybExpc3QucHVzaChsb2NhdGlvblVSTCk7XG4gICAgICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0KHJlcXVlc3QyLCBhY3R1YWxSZXNwb25zZSk7XG4gICAgICByZXR1cm4gbWFpbkZldGNoKGZldGNoUGFyYW1zLCB0cnVlKTtcbiAgICB9XG4gICAgX19uYW1lKGh0dHBSZWRpcmVjdEZldGNoLCBcImh0dHBSZWRpcmVjdEZldGNoXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKGZldGNoUGFyYW1zLCBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggPSBmYWxzZSwgaXNOZXdDb25uZWN0aW9uRmV0Y2ggPSBmYWxzZSkge1xuICAgICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0O1xuICAgICAgbGV0IGh0dHBGZXRjaFBhcmFtcyA9IG51bGw7XG4gICAgICBsZXQgaHR0cFJlcXVlc3QgPSBudWxsO1xuICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgIGNvbnN0IGh0dHBDYWNoZSA9IG51bGw7XG4gICAgICBjb25zdCByZXZhbGlkYXRpbmdGbGFnID0gZmFsc2U7XG4gICAgICBpZiAocmVxdWVzdDIud2luZG93ID09PSBcIm5vLXdpbmRvd1wiICYmIHJlcXVlc3QyLnJlZGlyZWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaHR0cEZldGNoUGFyYW1zID0gZmV0Y2hQYXJhbXM7XG4gICAgICAgIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodHRwUmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHJlcXVlc3QyKTtcbiAgICAgICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9O1xuICAgICAgICBodHRwRmV0Y2hQYXJhbXMucmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID0gcmVxdWVzdDIuY3JlZGVudGlhbHMgPT09IFwiaW5jbHVkZVwiIHx8IHJlcXVlc3QyLmNyZWRlbnRpYWxzID09PSBcInNhbWUtb3JpZ2luXCIgJiYgcmVxdWVzdDIucmVzcG9uc2VUYWludGluZyA9PT0gXCJiYXNpY1wiO1xuICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGw7XG4gICAgICBsZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiYgW1wiUE9TVFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhodHRwUmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IFwiMFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBTdHJpbmcoY29udGVudExlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwiY29udGVudC1sZW5ndGhcIiwgY29udGVudExlbmd0aEhlYWRlclZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgaHR0cFJlcXVlc3Qua2VlcGFsaXZlKSB7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwicmVmZXJlclwiLCBodHRwUmVxdWVzdC5yZWZlcnJlci5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIoaHR0cFJlcXVlc3QpO1xuICAgICAgYXBwZW5kRmV0Y2hNZXRhZGF0YShodHRwUmVxdWVzdCk7XG4gICAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcInVzZXItYWdlbnRcIikpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwidXNlci1hZ2VudFwiLCBcInVuZGljaVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gXCJkZWZhdWx0XCIgJiYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcImlmLW1vZGlmaWVkLXNpbmNlXCIpIHx8IGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcImlmLW5vbmUtbWF0Y2hcIikgfHwgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwiaWYtdW5tb2RpZmllZC1zaW5jZVwiKSB8fCBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJpZi1tYXRjaFwiKSB8fCBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJpZi1yYW5nZVwiKSkpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09IFwibm8tY2FjaGVcIiAmJiAhaHR0cFJlcXVlc3QucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gJiYgIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcImNhY2hlLWNvbnRyb2xcIikpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwiY2FjaGUtY29udHJvbFwiLCBcIm1heC1hZ2U9MFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gXCJuby1zdG9yZVwiIHx8IGh0dHBSZXF1ZXN0LmNhY2hlID09PSBcInJlbG9hZFwiKSB7XG4gICAgICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwicHJhZ21hXCIpKSB7XG4gICAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwicHJhZ21hXCIsIFwibm8tY2FjaGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5oYXMoXCJjYWNoZS1jb250cm9sXCIpKSB7XG4gICAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwiY2FjaGUtY29udHJvbFwiLCBcIm5vLWNhY2hlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwicmFuZ2VcIikpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKFwiYWNjZXB0LWVuY29kaW5nXCIsIFwiaWRlbnRpdHlcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmhhcyhcImFjY2VwdC1lbmNvZGluZ1wiKSkge1xuICAgICAgICBpZiAoL15odHRwczovLnRlc3QocmVxdWVzdEN1cnJlbnRVUkwoaHR0cFJlcXVlc3QpLnByb3RvY29sKSkge1xuICAgICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1lbmNvZGluZ1wiLCBcImJyLCBnemlwLCBkZWZsYXRlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1lbmNvZGluZ1wiLCBcImd6aXAsIGRlZmxhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlQ3JlZGVudGlhbHMpIHtcbiAgICAgIH1cbiAgICAgIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICBodHRwUmVxdWVzdC5jYWNoZSA9IFwibm8tc3RvcmVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChodHRwUmVxdWVzdC5tb2RlICE9PSBcIm5vLXN0b3JlXCIgJiYgaHR0cFJlcXVlc3QubW9kZSAhPT0gXCJyZWxvYWRcIikge1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGh0dHBSZXF1ZXN0Lm1vZGUgPT09IFwib25seS1pZi1jYWNoZWRcIikge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwib25seSBpZiBjYWNoZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9yd2FyZFJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtGZXRjaChcbiAgICAgICAgICBodHRwRmV0Y2hQYXJhbXMsXG4gICAgICAgICAgaW5jbHVkZUNyZWRlbnRpYWxzLFxuICAgICAgICAgIGlzTmV3Q29ubmVjdGlvbkZldGNoXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2FmZU1ldGhvZHMuaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKSAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzIDw9IDM5OSkge1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXZhbGlkYXRpbmdGbGFnICYmIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBmb3J3YXJkUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLnVybExpc3QgPSBbLi4uaHR0cFJlcXVlc3QudXJsTGlzdF07XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuaGFzKFwicmFuZ2VcIikpIHtcbiAgICAgICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UucmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHM7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDcpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QyLndpbmRvdyA9PT0gXCJuby13aW5kb3dcIikge1xuICAgICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKFwicHJveHkgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjEgJiYgIWlzTmV3Q29ubmVjdGlvbkZldGNoICYmIChyZXF1ZXN0Mi5ib2R5ID09IG51bGwgfHwgcmVxdWVzdDIuYm9keS5zb3VyY2UgIT0gbnVsbCkpIHtcbiAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goXG4gICAgICAgICAgZmV0Y2hQYXJhbXMsXG4gICAgICAgICAgaXNBdXRoZW50aWNhdGlvbkZldGNoLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0F1dGhlbnRpY2F0aW9uRmV0Y2gpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgX19uYW1lKGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoLCBcImh0dHBOZXR3b3JrT3JDYWNoZUZldGNoXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrRmV0Y2goZmV0Y2hQYXJhbXMsIGluY2x1ZGVDcmVkZW50aWFscyA9IGZhbHNlLCBmb3JjZU5ld0Nvbm5lY3Rpb24gPSBmYWxzZSkge1xuICAgICAgYXNzZXJ0KCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3llZCk7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gPSB7XG4gICAgICAgIGFib3J0OiBudWxsLFxuICAgICAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgICBkZXN0cm95KGVycikge1xuICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgKF9hMyA9IHRoaXMuYWJvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbCh0aGlzLCBlcnIgIT0gbnVsbCA/IGVyciA6IG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2hQYXJhbXMucmVxdWVzdDtcbiAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mbztcbiAgICAgIGNvbnN0IGh0dHBDYWNoZSA9IG51bGw7XG4gICAgICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdDIuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gXCJ5ZXNcIiA6IFwibm9cIjtcbiAgICAgIGlmIChyZXF1ZXN0Mi5tb2RlID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgfVxuICAgICAgbGV0IHJlcXVlc3RCb2R5ID0gbnVsbDtcbiAgICAgIGlmIChyZXF1ZXN0Mi5ib2R5ID09IG51bGwgJiYgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKSk7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QyLmJvZHkgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbiogKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIGJ5dGVzO1xuICAgICAgICAgIChfYTMgPSBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGZldGNoUGFyYW1zLCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfSwgXCJwcm9jZXNzQm9keUNodW5rXCIpO1xuICAgICAgICBjb25zdCBwcm9jZXNzRW5kT2ZCb2R5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcInByb2Nlc3NFbmRPZkJvZHlcIik7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlKSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFwicHJvY2Vzc0JvZHlFcnJvclwiKTtcbiAgICAgICAgcmVxdWVzdEJvZHkgPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QyLmJvZHkuc3RyZWFtKSB7XG4gICAgICAgICAgICAgIHlpZWxkKiBwcm9jZXNzQm9keUNodW5rKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NFbmRPZkJvZHkoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCB9ID0gYXdhaXQgZGlzcGF0Y2goeyBib2R5OiByZXF1ZXN0Qm9keSB9KTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBib2R5W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQgPSAoKSA9PiBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVsbEFsZ29yaXRobSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSgpO1xuICAgICAgfSwgXCJwdWxsQWxnb3JpdGhtXCIpO1xuICAgICAgY29uc3QgY2FuY2VsQWxnb3JpdGhtID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH0sIFwiY2FuY2VsQWxnb3JpdGhtXCIpO1xuICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpLlJlYWRhYmxlU3RyZWFtO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyZWFtMiA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICAgICAge1xuICAgICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHB1bGxBbGdvcml0aG0oY29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgaGlnaFdhdGVyTWFyazogMCB9XG4gICAgICApO1xuICAgICAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtOiBzdHJlYW0yIH07XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKFwidGVybWluYXRlZFwiLCBvbkFib3J0ZWQpO1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZXMgPSBkb25lID8gdm9pZCAwIDogdmFsdWU7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCAmJiAhdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUpIHtcbiAgICAgICAgICAgICAgYnl0ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBieXRlcyA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmICghL0NvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWQvLnRlc3QoZXJyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxpemVSZXNwb25zZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1pbmdJbmZvLmRlY29kZWRCb2R5U2l6ZSArPSAoX2EzID0gYnl0ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGJ5dGVzLmJ5dGVMZW5ndGgpICE9IG51bGwgPyBfYTMgOiAwO1xuICAgICAgICAgIGlmIChpc0Vycm9yTGlrZShieXRlcykpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICAgICAgICBpZiAoaXNFcnJvcmVkKHN0cmVhbTIpKSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5kZXNpcmVkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIG9uQWJvcnRlZChyZWFzb24pIHtcbiAgICAgICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICByZXNwb25zZS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0yKSkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgICAgICBuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0yKSkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKG5ldyBUeXBlRXJyb3IoXCJ0ZXJtaW5hdGVkXCIsIHtcbiAgICAgICAgICAgICAgY2F1c2U6IGlzRXJyb3JMaWtlKHJlYXNvbikgPyByZWFzb24gOiB2b2lkIDBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShvbkFib3J0ZWQsIFwib25BYm9ydGVkXCIpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gZGlzcGF0Y2goeyBib2R5IH0pIHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdDIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kaXNwYXRjaGVyLmRpc3BhdGNoKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhdGg6IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsXG4gICAgICAgICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QyLm1ldGhvZCxcbiAgICAgICAgICAgIGJvZHk6IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlci5pc01vY2tBY3RpdmUgPyByZXF1ZXN0Mi5ib2R5ICYmIHJlcXVlc3QyLmJvZHkuc291cmNlIDogYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnM6IFsuLi5yZXF1ZXN0Mi5oZWFkZXJzTGlzdF0uZmxhdCgpLFxuICAgICAgICAgICAgbWF4UmVkaXJlY3Rpb25zOiAwLFxuICAgICAgICAgICAgYm9keVRpbWVvdXQ6IDNlNSxcbiAgICAgICAgICAgIGhlYWRlcnNUaW1lb3V0OiAzZTVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgICBhYm9ydDogbnVsbCxcbiAgICAgICAgICAgIG9uQ29ubmVjdChhYm9ydCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oXCJ0ZXJtaW5hdGVkXCIsIGFib3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0ID0gY29ubmVjdGlvbi5hYm9ydCA9IGFib3J0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25IZWFkZXJzKHN0YXR1cywgaGVhZGVyc0xpc3QsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBjb2RpbmdzID0gW107XG4gICAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnNMaXN0Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyc0xpc3RbbiArIDBdLnRvU3RyaW5nKFwibGF0aW4xXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNMaXN0W24gKyAxXS50b1N0cmluZyhcImxhdGluMVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC1lbmNvZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBjb2RpbmdzID0gdmFsLnNwbGl0KFwiLFwiKS5tYXAoKHgpID0+IHgudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBcImxvY2F0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVhZDogcmVzdW1lIH0pO1xuICAgICAgICAgICAgICBjb25zdCBkZWNvZGVycyA9IFtdO1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdDIubWV0aG9kICE9PSBcIkhFQURcIiAmJiByZXF1ZXN0Mi5tZXRob2QgIT09IFwiQ09OTkVDVFwiICYmICFudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpICYmICEocmVxdWVzdDIucmVkaXJlY3QgPT09IFwiZm9sbG93XCIgJiYgbG9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2Rpbmcgb2YgY29kaW5ncykge1xuICAgICAgICAgICAgICAgICAgaWYgKC8oeC0pP2d6aXAvLnRlc3QoY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlR3VuemlwKCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvKHgtKT9kZWZsYXRlLy50ZXN0KGNvZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUluZmxhdGUoKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gXCJiclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnNMaXN0OiBoZWFkZXJzW2tIZWFkZXJzTGlzdF0sXG4gICAgICAgICAgICAgICAgYm9keTogZGVjb2RlcnMubGVuZ3RoID8gcGlwZWxpbmUodGhpcy5ib2R5LCAuLi5kZWNvZGVycywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0pIDogdGhpcy5ib2R5Lm9uKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGNodW5rO1xuICAgICAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSArPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnB1c2goYnl0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoXCJ0ZXJtaW5hdGVkXCIsIHRoaXMuYWJvcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yMikge1xuICAgICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKFwidGVybWluYXRlZFwiLCB0aGlzLmFib3J0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAoX2EzID0gdGhpcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmRlc3Ryb3koZXJyb3IyKTtcbiAgICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyb3IyKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShkaXNwYXRjaCwgXCJkaXNwYXRjaFwiKTtcbiAgICB9XG4gICAgX19uYW1lKGh0dHBOZXR3b3JrRmV0Y2gsIFwiaHR0cE5ldHdvcmtGZXRjaFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmZXRjaDI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzXG52YXIgcmVxdWlyZV91bmRpY2kgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdW5kaWNpQDUuMTAuMC9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBDbGllbnQgPSByZXF1aXJlX2NsaWVudCgpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZV9kaXNwYXRjaGVyKCk7XG4gICAgdmFyIGVycm9ycyA9IHJlcXVpcmVfZXJyb3JzKCk7XG4gICAgdmFyIFBvb2wgPSByZXF1aXJlX3Bvb2woKTtcbiAgICB2YXIgQmFsYW5jZWRQb29sID0gcmVxdWlyZV9iYWxhbmNlZF9wb29sKCk7XG4gICAgdmFyIEFnZW50ID0gcmVxdWlyZV9hZ2VudCgpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmVfdXRpbDIoKTtcbiAgICB2YXIgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzO1xuICAgIHZhciBhcGkgPSByZXF1aXJlX2FwaSgpO1xuICAgIHZhciBidWlsZENvbm5lY3RvciA9IHJlcXVpcmVfY29ubmVjdCgpO1xuICAgIHZhciBNb2NrQ2xpZW50ID0gcmVxdWlyZV9tb2NrX2NsaWVudCgpO1xuICAgIHZhciBNb2NrQWdlbnQgPSByZXF1aXJlX21vY2tfYWdlbnQoKTtcbiAgICB2YXIgTW9ja1Bvb2wgPSByZXF1aXJlX21vY2tfcG9vbCgpO1xuICAgIHZhciBtb2NrRXJyb3JzID0gcmVxdWlyZV9tb2NrX2Vycm9ycygpO1xuICAgIHZhciBQcm94eUFnZW50ID0gcmVxdWlyZV9wcm94eV9hZ2VudCgpO1xuICAgIHZhciB7IGdldEdsb2JhbERpc3BhdGNoZXIsIHNldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmVfZ2xvYmFsKCk7XG4gICAgdmFyIG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgbm9kZU1ham9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzBdKTtcbiAgICB2YXIgbm9kZU1pbm9yID0gTnVtYmVyKG5vZGVWZXJzaW9uWzFdKTtcbiAgICBPYmplY3QuYXNzaWduKERpc3BhdGNoZXIucHJvdG90eXBlLCBhcGkpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Qb29sID0gUG9vbDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5BZ2VudCA9IEFnZW50O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudDtcbiAgICBtb2R1bGUyLmV4cG9ydHMuYnVpbGRDb25uZWN0b3IgPSBidWlsZENvbm5lY3RvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZXJyb3JzID0gZXJyb3JzO1xuICAgIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKGZuKSB7XG4gICAgICByZXR1cm4gKHVybCwgb3B0cywgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGhhbmRsZXIgPSBvcHRzO1xuICAgICAgICAgIG9wdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHVybCAhPT0gXCJvYmplY3RcIiAmJiAhKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHVybFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMucGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3B0cy5wYXRoXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcGF0aDcgPSBvcHRzLnBhdGg7XG4gICAgICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHBhdGg3ID0gYC8ke3BhdGg3fWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVybCA9IG5ldyBVUkwodXRpbDIucGFyc2VPcmlnaW4odXJsKS5vcmlnaW4gKyBwYXRoNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiA/IHVybCA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cmwgPSB1dGlsMi5wYXJzZVVSTCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWdlbnQsIGRpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyKCkgfSA9IG9wdHM7XG4gICAgICAgIGlmIChhZ2VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG9wdHMuYWdlbnQuIERpZCB5b3UgbWVhbiBvcHRzLmNsaWVudD9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAob3B0cy5ib2R5ID8gXCJQVVRcIiA6IFwiR0VUXCIpXG4gICAgICAgIH0sIGhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VEaXNwYXRjaGVyLCBcIm1ha2VEaXNwYXRjaGVyXCIpO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5zZXRHbG9iYWxEaXNwYXRjaGVyID0gc2V0R2xvYmFsRGlzcGF0Y2hlcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMuZ2V0R2xvYmFsRGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXI7XG4gICAgaWYgKG5vZGVNYWpvciA+IDE2IHx8IG5vZGVNYWpvciA9PT0gMTYgJiYgbm9kZU1pbm9yID49IDgpIHtcbiAgICAgIGxldCBmZXRjaEltcGwgPSBudWxsO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLmZldGNoID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbiBmZXRjaDIocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFmZXRjaEltcGwpIHtcbiAgICAgICAgICBmZXRjaEltcGwgPSByZXF1aXJlX2ZldGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uZGlzcGF0Y2hlciB8fCBnZXRHbG9iYWxEaXNwYXRjaGVyKCk7XG4gICAgICAgIHJldHVybiBmZXRjaEltcGwuYXBwbHkoZGlzcGF0Y2hlciwgYXJndW1lbnRzKTtcbiAgICAgIH0sIFwiZmV0Y2hcIik7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmVfaGVhZGVycygpLkhlYWRlcnM7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlX3Jlc3BvbnNlKCkuUmVzcG9uc2U7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMuUmVxdWVzdCA9IHJlcXVpcmVfcmVxdWVzdDIoKS5SZXF1ZXN0O1xuICAgICAgbW9kdWxlMi5leHBvcnRzLkZvcm1EYXRhID0gcmVxdWlyZV9mb3JtZGF0YSgpLkZvcm1EYXRhO1xuICAgICAgbW9kdWxlMi5leHBvcnRzLkZpbGUgPSByZXF1aXJlX2ZpbGUoKS5GaWxlO1xuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMucmVxdWVzdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5yZXF1ZXN0KTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuc3RyZWFtID0gbWFrZURpc3BhdGNoZXIoYXBpLnN0cmVhbSk7XG4gICAgbW9kdWxlMi5leHBvcnRzLnBpcGVsaW5lID0gbWFrZURpc3BhdGNoZXIoYXBpLnBpcGVsaW5lKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuY29ubmVjdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5jb25uZWN0KTtcbiAgICBtb2R1bGUyLmV4cG9ydHMudXBncmFkZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS51cGdyYWRlKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnQ7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2w7XG4gICAgbW9kdWxlMi5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudDtcbiAgICBtb2R1bGUyLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnM7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZG90ZW52QDE2LjAuMS9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzXG52YXIgcmVxdWlyZV9tYWluMiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kb3RlbnZAMTYuMC4xL25vZGVfbW9kdWxlcy9kb3RlbnYvbGliL21haW4uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGZzMTEgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgdmFyIHBhdGg3ID0gcmVxdWlyZShcInBhdGhcIik7XG4gICAgdmFyIG9zMyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICB2YXIgTElORSA9IC8oPzpefF4pXFxzKig/OmV4cG9ydFxccyspPyhbXFx3Li1dKykoPzpcXHMqPVxccyo/fDpcXHMrPykoXFxzKicoPzpcXFxcJ3xbXiddKSonfFxccypcIig/OlxcXFxcInxbXlwiXSkqXCJ8XFxzKmAoPzpcXFxcYHxbXmBdKSpgfFteI1xcclxcbl0rKT9cXHMqKD86Iy4qKT8oPzokfCQpL21nO1xuICAgIGZ1bmN0aW9uIHBhcnNlMihzcmMpIHtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgICBsaW5lcyA9IGxpbmVzLnJlcGxhY2UoL1xcclxcbj8vbWcsIFwiXFxuXCIpO1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IExJTkUuZXhlYyhsaW5lcykpICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV07XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdIHx8IFwiXCI7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICBjb25zdCBtYXliZVF1b3RlID0gdmFsdWVbMF07XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLCBcIiQyXCIpO1xuICAgICAgICBpZiAobWF5YmVRdW90ZSA9PT0gJ1wiJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywgXCJcXG5cIik7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcci9nLCBcIlxcclwiKTtcbiAgICAgICAgfVxuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgX19uYW1lKHBhcnNlMiwgXCJwYXJzZVwiKTtcbiAgICBmdW5jdGlvbiBfbG9nKG1lc3NhZ2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbZG90ZW52XVtERUJVR10gJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICBfX25hbWUoX2xvZywgXCJfbG9nXCIpO1xuICAgIGZ1bmN0aW9uIF9yZXNvbHZlSG9tZShlbnZQYXRoKSB7XG4gICAgICByZXR1cm4gZW52UGF0aFswXSA9PT0gXCJ+XCIgPyBwYXRoNy5qb2luKG9zMy5ob21lZGlyKCksIGVudlBhdGguc2xpY2UoMSkpIDogZW52UGF0aDtcbiAgICB9XG4gICAgX19uYW1lKF9yZXNvbHZlSG9tZSwgXCJfcmVzb2x2ZUhvbWVcIik7XG4gICAgZnVuY3Rpb24gY29uZmlnMihvcHRpb25zKSB7XG4gICAgICBsZXQgZG90ZW52UGF0aCA9IHBhdGg3LnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgXCIuZW52XCIpO1xuICAgICAgbGV0IGVuY29kaW5nID0gXCJ1dGY4XCI7XG4gICAgICBjb25zdCBkZWJ1ZzEzID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpO1xuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSk7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBkb3RlbnZQYXRoID0gX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gRG90ZW52TW9kdWxlLnBhcnNlKGZzMTEucmVhZEZpbGVTeW5jKGRvdGVudlBhdGgsIHsgZW5jb2RpbmcgfSkpO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJzZWQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsIGtleSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52W2tleV0gPSBwYXJzZWRba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52W2tleV0gPSBwYXJzZWRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1ZzEzKSB7XG4gICAgICAgICAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9sb2coYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIFxcYHByb2Nlc3MuZW52XFxgIGFuZCBXQVMgb3ZlcndyaXR0ZW5gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbG9nKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBcXGBwcm9jZXNzLmVudlxcYCBhbmQgd2FzIE5PVCBvdmVyd3JpdHRlbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgcGFyc2VkIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkZWJ1ZzEzKSB7XG4gICAgICAgICAgX2xvZyhgRmFpbGVkIHRvIGxvYWQgJHtkb3RlbnZQYXRofSAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlcnJvcjogZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY29uZmlnMiwgXCJjb25maWdcIik7XG4gICAgdmFyIERvdGVudk1vZHVsZSA9IHtcbiAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgIHBhcnNlOiBwYXJzZTJcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cy5jb25maWcgPSBEb3RlbnZNb2R1bGUuY29uZmlnO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5wYXJzZSA9IERvdGVudk1vZHVsZS5wYXJzZTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBEb3RlbnZNb2R1bGU7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXJnQDUuMC4yL25vZGVfbW9kdWxlcy9hcmcvaW5kZXguanNcbnZhciByZXF1aXJlX2FyZyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcmdANS4wLjIvbm9kZV9tb2R1bGVzL2FyZy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgZmxhZ1N5bWJvbCA9IFN5bWJvbChcImFyZyBmbGFnXCIpO1xuICAgIHZhciBBcmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQXJnRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFyZ0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX25hbWUoQXJnRXJyb3IsIFwiQXJnRXJyb3JcIik7XG4gICAgZnVuY3Rpb24gYXJnMihvcHRzLCB7XG4gICAgICBhcmd2ID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpLFxuICAgICAgcGVybWlzc2l2ZSA9IGZhbHNlLFxuICAgICAgc3RvcEF0UG9zaXRpb25hbCA9IGZhbHNlXG4gICAgfSA9IHt9KSB7XG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFyZ0Vycm9yKFxuICAgICAgICAgIFwiYXJndW1lbnQgc3BlY2lmaWNhdGlvbiBvYmplY3QgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICBcIkFSR19DT05GSUdfTk9fU1BFQ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB7IF86IFtdIH07XG4gICAgICBjb25zdCBhbGlhc2VzID0ge307XG4gICAgICBjb25zdCBoYW5kbGVycyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0cykpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICBcImFyZ3VtZW50IGtleSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIsXG4gICAgICAgICAgICBcIkFSR19DT05GSUdfRU1QVFlfS0VZXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlbMF0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFyZ0Vycm9yKFxuICAgICAgICAgICAgYGFyZ3VtZW50IGtleSBtdXN0IHN0YXJ0IHdpdGggJy0nIGJ1dCBmb3VuZDogJyR7a2V5fSdgLFxuICAgICAgICAgICAgXCJBUkdfQ09ORklHX05PTk9QVF9LRVlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICBgYXJndW1lbnQga2V5IG11c3QgaGF2ZSBhIG5hbWU7IHNpbmd1bGFyICctJyBrZXlzIGFyZSBub3QgYWxsb3dlZDogJHtrZXl9YCxcbiAgICAgICAgICAgIFwiQVJHX0NPTkZJR19OT05BTUVfS0VZXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0c1trZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYWxpYXNlc1trZXldID0gb3B0c1trZXldO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb3B0c1trZXldO1xuICAgICAgICBsZXQgaXNGbGFnID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpICYmIHR5cGUubGVuZ3RoID09PSAxICYmIHR5cGVvZiB0eXBlWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBbZm5dID0gdHlwZTtcbiAgICAgICAgICB0eXBlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgodmFsdWUsIG5hbWUsIHByZXYgPSBbXSkgPT4ge1xuICAgICAgICAgICAgcHJldi5wdXNoKGZuKHZhbHVlLCBuYW1lLCBwcmV2W3ByZXYubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgIH0sIFwidHlwZVwiKTtcbiAgICAgICAgICBpc0ZsYWcgPSBmbiA9PT0gQm9vbGVhbiB8fCBmbltmbGFnU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaXNGbGFnID0gdHlwZSA9PT0gQm9vbGVhbiB8fCB0eXBlW2ZsYWdTeW1ib2xdID09PSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICAgIGB0eXBlIG1pc3Npbmcgb3Igbm90IGEgZnVuY3Rpb24gb3IgdmFsaWQgYXJyYXkgdHlwZTogJHtrZXl9YCxcbiAgICAgICAgICAgIFwiQVJHX0NPTkZJR19WQURfVFlQRVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5WzFdICE9PSBcIi1cIiAmJiBrZXkubGVuZ3RoID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICAgIGBzaG9ydCBhcmd1bWVudCBrZXlzICh3aXRoIGEgc2luZ2xlIGh5cGhlbikgbXVzdCBoYXZlIG9ubHkgb25lIGNoYXJhY3RlcjogJHtrZXl9YCxcbiAgICAgICAgICAgIFwiQVJHX0NPTkZJR19TSE9SVE9QVF9UT09MT05HXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJzW2tleV0gPSBbdHlwZSwgaXNGbGFnXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmd2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdob2xlQXJnID0gYXJndltpXTtcbiAgICAgICAgaWYgKHN0b3BBdFBvc2l0aW9uYWwgJiYgcmVzdWx0Ll8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdC5fID0gcmVzdWx0Ll8uY29uY2F0KGFyZ3Yuc2xpY2UoaSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aG9sZUFyZyA9PT0gXCItLVwiKSB7XG4gICAgICAgICAgcmVzdWx0Ll8gPSByZXN1bHQuXy5jb25jYXQoYXJndi5zbGljZShpICsgMSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aG9sZUFyZy5sZW5ndGggPiAxICYmIHdob2xlQXJnWzBdID09PSBcIi1cIikge1xuICAgICAgICAgIGNvbnN0IHNlcGFyYXRlZEFyZ3VtZW50cyA9IHdob2xlQXJnWzFdID09PSBcIi1cIiB8fCB3aG9sZUFyZy5sZW5ndGggPT09IDIgPyBbd2hvbGVBcmddIDogd2hvbGVBcmcuc2xpY2UoMSkuc3BsaXQoXCJcIikubWFwKChhKSA9PiBgLSR7YX1gKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlcGFyYXRlZEFyZ3VtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXJnMyA9IHNlcGFyYXRlZEFyZ3VtZW50c1tqXTtcbiAgICAgICAgICAgIGNvbnN0IFtvcmlnaW5hbEFyZ05hbWUsIGFyZ1N0cl0gPSBhcmczWzFdID09PSBcIi1cIiA/IGFyZzMuc3BsaXQoLz0oLiopLywgMikgOiBbYXJnMywgdm9pZCAwXTtcbiAgICAgICAgICAgIGxldCBhcmdOYW1lID0gb3JpZ2luYWxBcmdOYW1lO1xuICAgICAgICAgICAgd2hpbGUgKGFyZ05hbWUgaW4gYWxpYXNlcykge1xuICAgICAgICAgICAgICBhcmdOYW1lID0gYWxpYXNlc1thcmdOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGFyZ05hbWUgaW4gaGFuZGxlcnMpKSB7XG4gICAgICAgICAgICAgIGlmIChwZXJtaXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Ll8ucHVzaChhcmczKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJnRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgdW5rbm93biBvciB1bmV4cGVjdGVkIG9wdGlvbjogJHtvcmlnaW5hbEFyZ05hbWV9YCxcbiAgICAgICAgICAgICAgICAgIFwiQVJHX1VOS05PV05fT1BUSU9OXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbdHlwZSwgaXNGbGFnXSA9IGhhbmRsZXJzW2FyZ05hbWVdO1xuICAgICAgICAgICAgaWYgKCFpc0ZsYWcgJiYgaiArIDEgPCBzZXBhcmF0ZWRBcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICAgICAgICBgb3B0aW9uIHJlcXVpcmVzIGFyZ3VtZW50IChidXQgd2FzIGZvbGxvd2VkIGJ5IGFub3RoZXIgc2hvcnQgYXJndW1lbnQpOiAke29yaWdpbmFsQXJnTmFtZX1gLFxuICAgICAgICAgICAgICAgIFwiQVJHX01JU1NJTkdfUkVRVUlSRURfU0hPUlRBUkdcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmxhZykge1xuICAgICAgICAgICAgICByZXN1bHRbYXJnTmFtZV0gPSB0eXBlKHRydWUsIGFyZ05hbWUsIHJlc3VsdFthcmdOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ1N0ciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd2Lmxlbmd0aCA8IGkgKyAyIHx8IGFyZ3ZbaSArIDFdLmxlbmd0aCA+IDEgJiYgYXJndltpICsgMV1bMF0gPT09IFwiLVwiICYmICEoYXJndltpICsgMV0ubWF0Y2goL14tP1xcZCooXFwuKD89XFxkKSk/XFxkKiQvKSAmJiAodHlwZSA9PT0gTnVtYmVyIHx8IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZSA9PT0gQmlnSW50KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbmRlZCA9IG9yaWdpbmFsQXJnTmFtZSA9PT0gYXJnTmFtZSA/IFwiXCIgOiBgIChhbGlhcyBmb3IgJHthcmdOYW1lfSlgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmdFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBvcHRpb24gcmVxdWlyZXMgYXJndW1lbnQ6ICR7b3JpZ2luYWxBcmdOYW1lfSR7ZXh0ZW5kZWR9YCxcbiAgICAgICAgICAgICAgICAgIFwiQVJHX01JU1NJTkdfUkVRVUlSRURfTE9OR0FSR1wiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRbYXJnTmFtZV0gPSB0eXBlKGFyZ3ZbaSArIDFdLCBhcmdOYW1lLCByZXN1bHRbYXJnTmFtZV0pO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHRbYXJnTmFtZV0gPSB0eXBlKGFyZ1N0ciwgYXJnTmFtZSwgcmVzdWx0W2FyZ05hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll8ucHVzaCh3aG9sZUFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShhcmcyLCBcImFyZ1wiKTtcbiAgICBhcmcyLmZsYWcgPSAoZm4pID0+IHtcbiAgICAgIGZuW2ZsYWdTeW1ib2xdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIGFyZzIuQ09VTlQgPSBhcmcyLmZsYWcoKHYsIG5hbWUsIGV4aXN0aW5nQ291bnQpID0+IChleGlzdGluZ0NvdW50IHx8IDApICsgMSk7XG4gICAgYXJnMi5BcmdFcnJvciA9IEFyZ0Vycm9yO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGFyZzI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWluLWluZGVudEAxLjAuMS9ub2RlX21vZHVsZXMvbWluLWluZGVudC9pbmRleC5qc1xudmFyIHJlcXVpcmVfbWluX2luZGVudCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW4taW5kZW50QDEuMC4xL25vZGVfbW9kdWxlcy9taW4taW5kZW50L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eWyBcXHRdKig/PVxcUykvZ20pO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaC5yZWR1Y2UoKHIsIGEpID0+IE1hdGgubWluKHIsIGEubGVuZ3RoKSwgSW5maW5pdHkpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyaXAtaW5kZW50QDMuMC4wL25vZGVfbW9kdWxlcy9zdHJpcC1pbmRlbnQvaW5kZXguanNcbnZhciByZXF1aXJlX3N0cmlwX2luZGVudCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpcC1pbmRlbnRAMy4wLjAvbm9kZV9tb2R1bGVzL3N0cmlwLWluZGVudC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbWluSW5kZW50ID0gcmVxdWlyZV9taW5faW5kZW50KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gKHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgaW5kZW50NCA9IG1pbkluZGVudChzdHJpbmcpO1xuICAgICAgaWYgKGluZGVudDQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXlsgXFxcXHRdeyR7aW5kZW50NH19YCwgXCJnbVwiKTtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleCwgXCJcIik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wbHVyYWxpemVAOC4wLjAvbm9kZV9tb2R1bGVzL3BsdXJhbGl6ZS9wbHVyYWxpemUuanNcbnZhciByZXF1aXJlX3BsdXJhbGl6ZSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wbHVyYWxpemVAOC4wLjAvbm9kZV9tb2R1bGVzL3BsdXJhbGl6ZS9wbHVyYWxpemUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgKGZ1bmN0aW9uKHJvb3QsIHBsdXJhbGl6ZTIpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBsdXJhbGl6ZTIoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGZhbHNlKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcGx1cmFsaXplMigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QucGx1cmFsaXplID0gcGx1cmFsaXplMigpO1xuICAgICAgfVxuICAgIH0pKGV4cG9ydHMsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBsdXJhbFJ1bGVzID0gW107XG4gICAgICB2YXIgc2luZ3VsYXJSdWxlcyA9IFtdO1xuICAgICAgdmFyIHVuY291bnRhYmxlcyA9IHt9O1xuICAgICAgdmFyIGlycmVndWxhclBsdXJhbHMgPSB7fTtcbiAgICAgIHZhciBpcnJlZ3VsYXJTaW5nbGVzID0ge307XG4gICAgICBmdW5jdGlvbiBzYW5pdGl6ZVJ1bGUocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHJ1bGUgKyBcIiRcIiwgXCJpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgICAgfVxuICAgICAgX19uYW1lKHNhbml0aXplUnVsZSwgXCJzYW5pdGl6ZVJ1bGVcIik7XG4gICAgICBmdW5jdGlvbiByZXN0b3JlQ2FzZSh3b3JkLCB0b2tlbikge1xuICAgICAgICBpZiAod29yZCA9PT0gdG9rZW4pXG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICBpZiAod29yZCA9PT0gd29yZC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgIHJldHVybiB0b2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAod29yZCA9PT0gd29yZC50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgIHJldHVybiB0b2tlbi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAod29yZFswXSA9PT0gd29yZFswXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdG9rZW4uc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBfX25hbWUocmVzdG9yZUNhc2UsIFwicmVzdG9yZUNhc2VcIik7XG4gICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdHIsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXCQoXFxkezEsMn0pL2csIGZ1bmN0aW9uKG1hdGNoLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShpbnRlcnBvbGF0ZSwgXCJpbnRlcnBvbGF0ZVwiKTtcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2Uod29yZCwgcnVsZSkge1xuICAgICAgICByZXR1cm4gd29yZC5yZXBsYWNlKHJ1bGVbMF0sIGZ1bmN0aW9uKG1hdGNoLCBpbmRleCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBpbnRlcnBvbGF0ZShydWxlWzFdLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3RvcmVDYXNlKHdvcmRbaW5kZXggLSAxXSwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3RvcmVDYXNlKG1hdGNoLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShyZXBsYWNlLCBcInJlcGxhY2VcIik7XG4gICAgICBmdW5jdGlvbiBzYW5pdGl6ZVdvcmQodG9rZW4sIHdvcmQsIHJ1bGVzKSB7XG4gICAgICAgIGlmICghdG9rZW4ubGVuZ3RoIHx8IHVuY291bnRhYmxlcy5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICByZXR1cm4gd29yZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2xlbl07XG4gICAgICAgICAgaWYgKHJ1bGVbMF0udGVzdCh3b3JkKSlcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlKHdvcmQsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkO1xuICAgICAgfVxuICAgICAgX19uYW1lKHNhbml0aXplV29yZCwgXCJzYW5pdGl6ZVdvcmRcIik7XG4gICAgICBmdW5jdGlvbiByZXBsYWNlV29yZChyZXBsYWNlTWFwLCBrZWVwTWFwLCBydWxlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoa2VlcE1hcC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0b3JlQ2FzZSh3b3JkLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXBsYWNlTWFwLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3RvcmVDYXNlKHdvcmQsIHJlcGxhY2VNYXBbdG9rZW5dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNhbml0aXplV29yZCh0b2tlbiwgd29yZCwgcnVsZXMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX19uYW1lKHJlcGxhY2VXb3JkLCBcInJlcGxhY2VXb3JkXCIpO1xuICAgICAgZnVuY3Rpb24gY2hlY2tXb3JkKHJlcGxhY2VNYXAsIGtlZXBNYXAsIHJ1bGVzLCBib29sKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChrZWVwTWFwLmhhc093blByb3BlcnR5KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChyZXBsYWNlTWFwLmhhc093blByb3BlcnR5KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gc2FuaXRpemVXb3JkKHRva2VuLCB0b2tlbiwgcnVsZXMpID09PSB0b2tlbjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjaGVja1dvcmQsIFwiY2hlY2tXb3JkXCIpO1xuICAgICAgZnVuY3Rpb24gcGx1cmFsaXplMih3b3JkLCBjb3VudDIsIGluY2x1c2l2ZSkge1xuICAgICAgICB2YXIgcGx1cmFsaXplZCA9IGNvdW50MiA9PT0gMSA/IHBsdXJhbGl6ZTIuc2luZ3VsYXIod29yZCkgOiBwbHVyYWxpemUyLnBsdXJhbCh3b3JkKTtcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdmUgPyBjb3VudDIgKyBcIiBcIiA6IFwiXCIpICsgcGx1cmFsaXplZDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShwbHVyYWxpemUyLCBcInBsdXJhbGl6ZVwiKTtcbiAgICAgIHBsdXJhbGl6ZTIucGx1cmFsID0gcmVwbGFjZVdvcmQoXG4gICAgICAgIGlycmVndWxhclNpbmdsZXMsXG4gICAgICAgIGlycmVndWxhclBsdXJhbHMsXG4gICAgICAgIHBsdXJhbFJ1bGVzXG4gICAgICApO1xuICAgICAgcGx1cmFsaXplMi5pc1BsdXJhbCA9IGNoZWNrV29yZChcbiAgICAgICAgaXJyZWd1bGFyU2luZ2xlcyxcbiAgICAgICAgaXJyZWd1bGFyUGx1cmFscyxcbiAgICAgICAgcGx1cmFsUnVsZXNcbiAgICAgICk7XG4gICAgICBwbHVyYWxpemUyLnNpbmd1bGFyID0gcmVwbGFjZVdvcmQoXG4gICAgICAgIGlycmVndWxhclBsdXJhbHMsXG4gICAgICAgIGlycmVndWxhclNpbmdsZXMsXG4gICAgICAgIHNpbmd1bGFyUnVsZXNcbiAgICAgICk7XG4gICAgICBwbHVyYWxpemUyLmlzU2luZ3VsYXIgPSBjaGVja1dvcmQoXG4gICAgICAgIGlycmVndWxhclBsdXJhbHMsXG4gICAgICAgIGlycmVndWxhclNpbmdsZXMsXG4gICAgICAgIHNpbmd1bGFyUnVsZXNcbiAgICAgICk7XG4gICAgICBwbHVyYWxpemUyLmFkZFBsdXJhbFJ1bGUgPSBmdW5jdGlvbihydWxlLCByZXBsYWNlbWVudCkge1xuICAgICAgICBwbHVyYWxSdWxlcy5wdXNoKFtzYW5pdGl6ZVJ1bGUocnVsZSksIHJlcGxhY2VtZW50XSk7XG4gICAgICB9O1xuICAgICAgcGx1cmFsaXplMi5hZGRTaW5ndWxhclJ1bGUgPSBmdW5jdGlvbihydWxlLCByZXBsYWNlbWVudCkge1xuICAgICAgICBzaW5ndWxhclJ1bGVzLnB1c2goW3Nhbml0aXplUnVsZShydWxlKSwgcmVwbGFjZW1lbnRdKTtcbiAgICAgIH07XG4gICAgICBwbHVyYWxpemUyLmFkZFVuY291bnRhYmxlUnVsZSA9IGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3b3JkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdW5jb3VudGFibGVzW3dvcmQudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwbHVyYWxpemUyLmFkZFBsdXJhbFJ1bGUod29yZCwgXCIkMFwiKTtcbiAgICAgICAgcGx1cmFsaXplMi5hZGRTaW5ndWxhclJ1bGUod29yZCwgXCIkMFwiKTtcbiAgICAgIH07XG4gICAgICBwbHVyYWxpemUyLmFkZElycmVndWxhclJ1bGUgPSBmdW5jdGlvbihzaW5nbGUsIHBsdXJhbCkge1xuICAgICAgICBwbHVyYWwgPSBwbHVyYWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc2luZ2xlID0gc2luZ2xlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlycmVndWxhclNpbmdsZXNbc2luZ2xlXSA9IHBsdXJhbDtcbiAgICAgICAgaXJyZWd1bGFyUGx1cmFsc1twbHVyYWxdID0gc2luZ2xlO1xuICAgICAgfTtcbiAgICAgIFtcbiAgICAgICAgW1wiSVwiLCBcIndlXCJdLFxuICAgICAgICBbXCJtZVwiLCBcInVzXCJdLFxuICAgICAgICBbXCJoZVwiLCBcInRoZXlcIl0sXG4gICAgICAgIFtcInNoZVwiLCBcInRoZXlcIl0sXG4gICAgICAgIFtcInRoZW1cIiwgXCJ0aGVtXCJdLFxuICAgICAgICBbXCJteXNlbGZcIiwgXCJvdXJzZWx2ZXNcIl0sXG4gICAgICAgIFtcInlvdXJzZWxmXCIsIFwieW91cnNlbHZlc1wiXSxcbiAgICAgICAgW1wiaXRzZWxmXCIsIFwidGhlbXNlbHZlc1wiXSxcbiAgICAgICAgW1wiaGVyc2VsZlwiLCBcInRoZW1zZWx2ZXNcIl0sXG4gICAgICAgIFtcImhpbXNlbGZcIiwgXCJ0aGVtc2VsdmVzXCJdLFxuICAgICAgICBbXCJ0aGVtc2VsZlwiLCBcInRoZW1zZWx2ZXNcIl0sXG4gICAgICAgIFtcImlzXCIsIFwiYXJlXCJdLFxuICAgICAgICBbXCJ3YXNcIiwgXCJ3ZXJlXCJdLFxuICAgICAgICBbXCJoYXNcIiwgXCJoYXZlXCJdLFxuICAgICAgICBbXCJ0aGlzXCIsIFwidGhlc2VcIl0sXG4gICAgICAgIFtcInRoYXRcIiwgXCJ0aG9zZVwiXSxcbiAgICAgICAgW1wiZWNob1wiLCBcImVjaG9lc1wiXSxcbiAgICAgICAgW1wiZGluZ29cIiwgXCJkaW5nb2VzXCJdLFxuICAgICAgICBbXCJ2b2xjYW5vXCIsIFwidm9sY2Fub2VzXCJdLFxuICAgICAgICBbXCJ0b3JuYWRvXCIsIFwidG9ybmFkb2VzXCJdLFxuICAgICAgICBbXCJ0b3JwZWRvXCIsIFwidG9ycGVkb2VzXCJdLFxuICAgICAgICBbXCJnZW51c1wiLCBcImdlbmVyYVwiXSxcbiAgICAgICAgW1widmlzY3VzXCIsIFwidmlzY2VyYVwiXSxcbiAgICAgICAgW1wic3RpZ21hXCIsIFwic3RpZ21hdGFcIl0sXG4gICAgICAgIFtcInN0b21hXCIsIFwic3RvbWF0YVwiXSxcbiAgICAgICAgW1wiZG9nbWFcIiwgXCJkb2dtYXRhXCJdLFxuICAgICAgICBbXCJsZW1tYVwiLCBcImxlbW1hdGFcIl0sXG4gICAgICAgIFtcInNjaGVtYVwiLCBcInNjaGVtYXRhXCJdLFxuICAgICAgICBbXCJhbmF0aGVtYVwiLCBcImFuYXRoZW1hdGFcIl0sXG4gICAgICAgIFtcIm94XCIsIFwib3hlblwiXSxcbiAgICAgICAgW1wiYXhlXCIsIFwiYXhlc1wiXSxcbiAgICAgICAgW1wiZGllXCIsIFwiZGljZVwiXSxcbiAgICAgICAgW1wieWVzXCIsIFwieWVzZXNcIl0sXG4gICAgICAgIFtcImZvb3RcIiwgXCJmZWV0XCJdLFxuICAgICAgICBbXCJlYXZlXCIsIFwiZWF2ZXNcIl0sXG4gICAgICAgIFtcImdvb3NlXCIsIFwiZ2Vlc2VcIl0sXG4gICAgICAgIFtcInRvb3RoXCIsIFwidGVldGhcIl0sXG4gICAgICAgIFtcInF1aXpcIiwgXCJxdWl6emVzXCJdLFxuICAgICAgICBbXCJodW1hblwiLCBcImh1bWFuc1wiXSxcbiAgICAgICAgW1wicHJvb2ZcIiwgXCJwcm9vZnNcIl0sXG4gICAgICAgIFtcImNhcnZlXCIsIFwiY2FydmVzXCJdLFxuICAgICAgICBbXCJ2YWx2ZVwiLCBcInZhbHZlc1wiXSxcbiAgICAgICAgW1wibG9vZXlcIiwgXCJsb29pZXNcIl0sXG4gICAgICAgIFtcInRoaWVmXCIsIFwidGhpZXZlc1wiXSxcbiAgICAgICAgW1wiZ3Jvb3ZlXCIsIFwiZ3Jvb3Zlc1wiXSxcbiAgICAgICAgW1wicGlja2F4ZVwiLCBcInBpY2theGVzXCJdLFxuICAgICAgICBbXCJwYXNzZXJieVwiLCBcInBhc3NlcnNieVwiXVxuICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbGl6ZTIuYWRkSXJyZWd1bGFyUnVsZShydWxlWzBdLCBydWxlWzFdKTtcbiAgICAgIH0pO1xuICAgICAgW1xuICAgICAgICBbL3M/JC9pLCBcInNcIl0sXG4gICAgICAgIFsvW15cXHUwMDAwLVxcdTAwN0ZdJC9pLCBcIiQwXCJdLFxuICAgICAgICBbLyhbXmFlaW91XWVzZSkkL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKGF4fHRlc3QpaXMkL2ksIFwiJDFlc1wiXSxcbiAgICAgICAgWy8oYWxpYXN8W15hb3VddXN8dFtsbV1hc3xnYXN8cmlzKSQvaSwgXCIkMWVzXCJdLFxuICAgICAgICBbLyhlW21uXXUpcz8kL2ksIFwiJDFzXCJdLFxuICAgICAgICBbLyhbXmxdaWFzfFthZWlvdV1sYXN8W2VqenJdYXN8W2l1XWFtKSQvaSwgXCIkMVwiXSxcbiAgICAgICAgWy8oYWx1bW58c3lsbGFifHZpcnxyYWRpfG51Y2xlfGZ1bmd8Y2FjdHxzdGltdWx8dGVybWlufGJhY2lsbHxmb2N8dXRlcnxsb2N8c3RyYXQpKD86dXN8aSkkL2ksIFwiJDFpXCJdLFxuICAgICAgICBbLyhhbHVtbnxhbGd8dmVydGVicikoPzphfGFlKSQvaSwgXCIkMWFlXCJdLFxuICAgICAgICBbLyhzZXJhcGh8Y2hlcnViKSg/OmltKT8kL2ksIFwiJDFpbVwiXSxcbiAgICAgICAgWy8oaGVyfGF0fGdyKW8kL2ksIFwiJDFvZXNcIl0sXG4gICAgICAgIFsvKGFnZW5kfGFkZGVuZHxtaWxsZW5uaXxkYXR8ZXh0cmVtfGJhY3Rlcml8ZGVzaWRlcmF0fHN0cmF0fGNhbmRlbGFicnxlcnJhdHxvdnxzeW1wb3NpfGN1cnJpY3VsfGF1dG9tYXR8cXVvcikoPzphfHVtKSQvaSwgXCIkMWFcIl0sXG4gICAgICAgIFsvKGFwaGVsaXxoeXBlcmJhdHxwZXJpaGVsaXxhc3luZGV0fG5vdW1lbnxwaGVub21lbnxjcml0ZXJpfG9yZ2FufHByb2xlZ29tZW58aGVkcnxhdXRvbWF0KSg/OmF8b24pJC9pLCBcIiQxYVwiXSxcbiAgICAgICAgWy9zaXMkL2ksIFwic2VzXCJdLFxuICAgICAgICBbLyg/Oihrbml8d2l8bGkpZmV8KGFyfGx8ZWF8ZW98b2F8aG9vKWYpJC9pLCBcIiQxJDJ2ZXNcIl0sXG4gICAgICAgIFsvKFteYWVpb3V5XXxxdSl5JC9pLCBcIiQxaWVzXCJdLFxuICAgICAgICBbLyhbXmNoXVtpZW9dW2xuXSlleSQvaSwgXCIkMWllc1wiXSxcbiAgICAgICAgWy8oeHxjaHxzc3xzaHx6eikkL2ksIFwiJDFlc1wiXSxcbiAgICAgICAgWy8obWF0cnxjb2R8bXVyfHNpbHx2ZXJ0fGluZHxhcHBlbmQpKD86aXh8ZXgpJC9pLCBcIiQxaWNlc1wiXSxcbiAgICAgICAgWy9cXGIoKD86dGl0KT9tfGwpKD86aWNlfG91c2UpJC9pLCBcIiQxaWNlXCJdLFxuICAgICAgICBbLyhwZSkoPzpyc29ufG9wbGUpJC9pLCBcIiQxb3BsZVwiXSxcbiAgICAgICAgWy8oY2hpbGQpKD86cmVuKT8kL2ksIFwiJDFyZW5cIl0sXG4gICAgICAgIFsvZWF1eCQvaSwgXCIkMFwiXSxcbiAgICAgICAgWy9tW2FlXW4kL2ksIFwibWVuXCJdLFxuICAgICAgICBbXCJ0aG91XCIsIFwieW91XCJdXG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsaXplMi5hZGRQbHVyYWxSdWxlKHJ1bGVbMF0sIHJ1bGVbMV0pO1xuICAgICAgfSk7XG4gICAgICBbXG4gICAgICAgIFsvcyQvaSwgXCJcIl0sXG4gICAgICAgIFsvKHNzKSQvaSwgXCIkMVwiXSxcbiAgICAgICAgWy8od2l8a25pfCg/OmFmdGVyfGhhbGZ8aGlnaHxsb3d8bWlkfG5vbnxuaWdodHxbXlxcd118XilsaSl2ZXMkL2ksIFwiJDFmZVwiXSxcbiAgICAgICAgWy8oYXJ8KD86d298W2FlXSlsfFtlb11bYW9dKXZlcyQvaSwgXCIkMWZcIl0sXG4gICAgICAgIFsvaWVzJC9pLCBcInlcIl0sXG4gICAgICAgIFsvXFxiKFtwbF18em9tYnwoPzpuZWNrfGNyb3NzKT90fGNvbGx8ZmFlcnxmb29kfGdlbnxnb29ufGdyb3VwfGxhc3N8dGFsa3xnb2FsfGN1dClpZXMkL2ksIFwiJDFpZVwiXSxcbiAgICAgICAgWy9cXGIobW9ufHNtaWwpaWVzJC9pLCBcIiQxZXlcIl0sXG4gICAgICAgIFsvXFxiKCg/OnRpdCk/bXxsKWljZSQvaSwgXCIkMW91c2VcIl0sXG4gICAgICAgIFsvKHNlcmFwaHxjaGVydWIpaW0kL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKHh8Y2h8c3N8c2h8enp8dHRvfGdvfGNob3xhbGlhc3xbXmFvdV11c3x0W2xtXWFzfGdhc3woPzpoZXJ8YXR8Z3Ipb3xbYWVpb3VdcmlzKSg/OmVzKT8kL2ksIFwiJDFcIl0sXG4gICAgICAgIFsvKGFuYWx5fGRpYWdub3xwYXJlbnRoZXxwcm9nbm98c3lub3B8dGhlfGVtcGhhfGNyaXxuZSkoPzpzaXN8c2VzKSQvaSwgXCIkMXNpc1wiXSxcbiAgICAgICAgWy8obW92aWV8dHdlbHZlfGFidXNlfGVbbW5ddSlzJC9pLCBcIiQxXCJdLFxuICAgICAgICBbLyh0ZXN0KSg/OmlzfGVzKSQvaSwgXCIkMWlzXCJdLFxuICAgICAgICBbLyhhbHVtbnxzeWxsYWJ8dmlyfHJhZGl8bnVjbGV8ZnVuZ3xjYWN0fHN0aW11bHx0ZXJtaW58YmFjaWxsfGZvY3x1dGVyfGxvY3xzdHJhdCkoPzp1c3xpKSQvaSwgXCIkMXVzXCJdLFxuICAgICAgICBbLyhhZ2VuZHxhZGRlbmR8bWlsbGVubml8ZGF0fGV4dHJlbXxiYWN0ZXJpfGRlc2lkZXJhdHxzdHJhdHxjYW5kZWxhYnJ8ZXJyYXR8b3Z8c3ltcG9zaXxjdXJyaWN1bHxxdW9yKWEkL2ksIFwiJDF1bVwiXSxcbiAgICAgICAgWy8oYXBoZWxpfGh5cGVyYmF0fHBlcmloZWxpfGFzeW5kZXR8bm91bWVufHBoZW5vbWVufGNyaXRlcml8b3JnYW58cHJvbGVnb21lbnxoZWRyfGF1dG9tYXQpYSQvaSwgXCIkMW9uXCJdLFxuICAgICAgICBbLyhhbHVtbnxhbGd8dmVydGVicilhZSQvaSwgXCIkMWFcIl0sXG4gICAgICAgIFsvKGNvZHxtdXJ8c2lsfHZlcnR8aW5kKWljZXMkL2ksIFwiJDFleFwiXSxcbiAgICAgICAgWy8obWF0cnxhcHBlbmQpaWNlcyQvaSwgXCIkMWl4XCJdLFxuICAgICAgICBbLyhwZSkocnNvbnxvcGxlKSQvaSwgXCIkMXJzb25cIl0sXG4gICAgICAgIFsvKGNoaWxkKXJlbiQvaSwgXCIkMVwiXSxcbiAgICAgICAgWy8oZWF1KXg/JC9pLCBcIiQxXCJdLFxuICAgICAgICBbL21lbiQvaSwgXCJtYW5cIl1cbiAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWxpemUyLmFkZFNpbmd1bGFyUnVsZShydWxlWzBdLCBydWxlWzFdKTtcbiAgICAgIH0pO1xuICAgICAgW1xuICAgICAgICBcImFkdWx0aG9vZFwiLFxuICAgICAgICBcImFkdmljZVwiLFxuICAgICAgICBcImFnZW5kYVwiLFxuICAgICAgICBcImFpZFwiLFxuICAgICAgICBcImFpcmNyYWZ0XCIsXG4gICAgICAgIFwiYWxjb2hvbFwiLFxuICAgICAgICBcImFtbW9cIixcbiAgICAgICAgXCJhbmFseXRpY3NcIixcbiAgICAgICAgXCJhbmltZVwiLFxuICAgICAgICBcImF0aGxldGljc1wiLFxuICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgIFwiYmlzb25cIixcbiAgICAgICAgXCJibG9vZFwiLFxuICAgICAgICBcImJyZWFtXCIsXG4gICAgICAgIFwiYnVmZmFsb1wiLFxuICAgICAgICBcImJ1dHRlclwiLFxuICAgICAgICBcImNhcnBcIixcbiAgICAgICAgXCJjYXNoXCIsXG4gICAgICAgIFwiY2hhc3Npc1wiLFxuICAgICAgICBcImNoZXNzXCIsXG4gICAgICAgIFwiY2xvdGhpbmdcIixcbiAgICAgICAgXCJjb2RcIixcbiAgICAgICAgXCJjb21tZXJjZVwiLFxuICAgICAgICBcImNvb3BlcmF0aW9uXCIsXG4gICAgICAgIFwiY29ycHNcIixcbiAgICAgICAgXCJkZWJyaXNcIixcbiAgICAgICAgXCJkaWFiZXRlc1wiLFxuICAgICAgICBcImRpZ2VzdGlvblwiLFxuICAgICAgICBcImVsa1wiLFxuICAgICAgICBcImVuZXJneVwiLFxuICAgICAgICBcImVxdWlwbWVudFwiLFxuICAgICAgICBcImV4Y3JldGlvblwiLFxuICAgICAgICBcImV4cGVydGlzZVwiLFxuICAgICAgICBcImZpcm13YXJlXCIsXG4gICAgICAgIFwiZmxvdW5kZXJcIixcbiAgICAgICAgXCJmdW5cIixcbiAgICAgICAgXCJnYWxsb3dzXCIsXG4gICAgICAgIFwiZ2FyYmFnZVwiLFxuICAgICAgICBcImdyYWZmaXRpXCIsXG4gICAgICAgIFwiaGFyZHdhcmVcIixcbiAgICAgICAgXCJoZWFkcXVhcnRlcnNcIixcbiAgICAgICAgXCJoZWFsdGhcIixcbiAgICAgICAgXCJoZXJwZXNcIixcbiAgICAgICAgXCJoaWdoamlua3NcIixcbiAgICAgICAgXCJob21ld29ya1wiLFxuICAgICAgICBcImhvdXNld29ya1wiLFxuICAgICAgICBcImluZm9ybWF0aW9uXCIsXG4gICAgICAgIFwiamVhbnNcIixcbiAgICAgICAgXCJqdXN0aWNlXCIsXG4gICAgICAgIFwia3Vkb3NcIixcbiAgICAgICAgXCJsYWJvdXJcIixcbiAgICAgICAgXCJsaXRlcmF0dXJlXCIsXG4gICAgICAgIFwibWFjaGluZXJ5XCIsXG4gICAgICAgIFwibWFja2VyZWxcIixcbiAgICAgICAgXCJtYWlsXCIsXG4gICAgICAgIFwibWVkaWFcIixcbiAgICAgICAgXCJtZXdzXCIsXG4gICAgICAgIFwibW9vc2VcIixcbiAgICAgICAgXCJtdXNpY1wiLFxuICAgICAgICBcIm11ZFwiLFxuICAgICAgICBcIm1hbmdhXCIsXG4gICAgICAgIFwibmV3c1wiLFxuICAgICAgICBcIm9ubHlcIixcbiAgICAgICAgXCJwZXJzb25uZWxcIixcbiAgICAgICAgXCJwaWtlXCIsXG4gICAgICAgIFwicGxhbmt0b25cIixcbiAgICAgICAgXCJwbGllcnNcIixcbiAgICAgICAgXCJwb2xpY2VcIixcbiAgICAgICAgXCJwb2xsdXRpb25cIixcbiAgICAgICAgXCJwcmVtaXNlc1wiLFxuICAgICAgICBcInJhaW5cIixcbiAgICAgICAgXCJyZXNlYXJjaFwiLFxuICAgICAgICBcInJpY2VcIixcbiAgICAgICAgXCJzYWxtb25cIixcbiAgICAgICAgXCJzY2lzc29yc1wiLFxuICAgICAgICBcInNlcmllc1wiLFxuICAgICAgICBcInNld2FnZVwiLFxuICAgICAgICBcInNoYW1ibGVzXCIsXG4gICAgICAgIFwic2hyaW1wXCIsXG4gICAgICAgIFwic29mdHdhcmVcIixcbiAgICAgICAgXCJzcGVjaWVzXCIsXG4gICAgICAgIFwic3RhZmZcIixcbiAgICAgICAgXCJzd2luZVwiLFxuICAgICAgICBcInRlbm5pc1wiLFxuICAgICAgICBcInRyYWZmaWNcIixcbiAgICAgICAgXCJ0cmFuc3BvcnRhdGlvblwiLFxuICAgICAgICBcInRyb3V0XCIsXG4gICAgICAgIFwidHVuYVwiLFxuICAgICAgICBcIndlYWx0aFwiLFxuICAgICAgICBcIndlbGZhcmVcIixcbiAgICAgICAgXCJ3aGl0aW5nXCIsXG4gICAgICAgIFwid2lsZGViZWVzdFwiLFxuICAgICAgICBcIndpbGRsaWZlXCIsXG4gICAgICAgIFwieW91XCIsXG4gICAgICAgIC9wb2tbZcOpXW1vbiQvaSxcbiAgICAgICAgL1teYWVpb3VdZXNlJC9pLFxuICAgICAgICAvZGVlciQvaSxcbiAgICAgICAgL2Zpc2gkL2ksXG4gICAgICAgIC9tZWFzbGVzJC9pLFxuICAgICAgICAvb1tpdV1zJC9pLFxuICAgICAgICAvcG94JC9pLFxuICAgICAgICAvc2hlZXAkL2lcbiAgICAgIF0uZm9yRWFjaChwbHVyYWxpemUyLmFkZFVuY291bnRhYmxlUnVsZSk7XG4gICAgICByZXR1cm4gcGx1cmFsaXplMjtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1yZWdleHBAMi4xLjAvbm9kZV9tb2R1bGVzL2lzLXJlZ2V4cC9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfcmVnZXhwID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLXJlZ2V4cEAyLjEuMC9ub2RlX21vZHVsZXMvaXMtcmVnZXhwL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChpbnB1dCkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcy1vYmpAMi4wLjAvbm9kZV9tb2R1bGVzL2lzLW9iai9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfb2JqID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLW9iakAyLjAuMC9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHNAMy4wLjIvbm9kZV9tb2R1bGVzL2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzL2xpYi9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGliID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzQDMuMC4yL25vZGVfbW9kdWxlcy9nZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9scy9saWIvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuZGVmYXVsdCA9IChvYmplY3QpID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KS5maWx0ZXIoKGtleVN5bWJvbCkgPT4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwga2V5U3ltYm9sKSk7XG4gIH1cbn0pO1xuXG4vLyBwYWNrYWdlLmpzb25cbnZhciByZXF1aXJlX3BhY2thZ2UyID0gX19jb21tb25KUyh7XG4gIFwicGFja2FnZS5qc29uXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIG5hbWU6IFwiQHByaXNtYS9jbGllbnRcIixcbiAgICAgIHZlcnNpb246IFwiNC4zLjFcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlByaXNtYSBDbGllbnQgaXMgYW4gYXV0by1nZW5lcmF0ZWQsIHR5cGUtc2FmZSBhbmQgbW9kZXJuIEphdmFTY3JpcHQvVHlwZVNjcmlwdCBPUk0gZm9yIE5vZGUuanMgdGhhdCdzIHRhaWxvcmVkIHRvIHlvdXIgZGF0YS4gU3VwcG9ydHMgTXlTUUwsIFBvc3RncmVTUUwsIE1hcmlhREIsIFNRTGl0ZSBkYXRhYmFzZXMuXCIsXG4gICAgICBrZXl3b3JkczogW1xuICAgICAgICBcIm9ybVwiLFxuICAgICAgICBcInByaXNtYTJcIixcbiAgICAgICAgXCJwcmlzbWFcIixcbiAgICAgICAgXCJjbGllbnRcIixcbiAgICAgICAgXCJxdWVyeVwiLFxuICAgICAgICBcImRhdGFiYXNlXCIsXG4gICAgICAgIFwic3FsXCIsXG4gICAgICAgIFwicG9zdGdyZXNcIixcbiAgICAgICAgXCJwb3N0Z3Jlc3FsXCIsXG4gICAgICAgIFwibXlzcWxcIixcbiAgICAgICAgXCJzcWxpdGVcIixcbiAgICAgICAgXCJtYXJpYWRiXCIsXG4gICAgICAgIFwibXNzcWxcIixcbiAgICAgICAgXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgIFwicXVlcnktYnVpbGRlclwiXG4gICAgICBdLFxuICAgICAgbWFpbjogXCJpbmRleC5qc1wiLFxuICAgICAgYnJvd3NlcjogXCJpbmRleC1icm93c2VyLmpzXCIsXG4gICAgICB0eXBlczogXCJpbmRleC5kLnRzXCIsXG4gICAgICBsaWNlbnNlOiBcIkFwYWNoZS0yLjBcIixcbiAgICAgIGVuZ2luZXM6IHtcbiAgICAgICAgbm9kZTogXCI+PTE0LjE3XCJcbiAgICAgIH0sXG4gICAgICBob21lcGFnZTogXCJodHRwczovL3d3dy5wcmlzbWEuaW9cIixcbiAgICAgIHJlcG9zaXRvcnk6IHtcbiAgICAgICAgdHlwZTogXCJnaXRcIixcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hLmdpdFwiLFxuICAgICAgICBkaXJlY3Rvcnk6IFwicGFja2FnZXMvY2xpZW50XCJcbiAgICAgIH0sXG4gICAgICBhdXRob3I6IFwiVGltIFN1Y2hhbmVrIDxzdWNoYW5la0BwcmlzbWEuaW8+XCIsXG4gICAgICBidWdzOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc1wiLFxuICAgICAgc2NyaXB0czoge1xuICAgICAgICBkZXY6IFwiREVWPXRydWUgbm9kZSAtciBlc2J1aWxkLXJlZ2lzdGVyIGhlbHBlcnMvYnVpbGQudHNcIixcbiAgICAgICAgYnVpbGQ6IFwibm9kZSAtciBlc2J1aWxkLXJlZ2lzdGVyIGhlbHBlcnMvYnVpbGQudHNcIixcbiAgICAgICAgdGVzdDogXCJqZXN0IC0tdmVyYm9zZVwiLFxuICAgICAgICBcInRlc3Q6ZnVuY3Rpb25hbFwiOiBcIm5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL2Z1bmN0aW9uYWwtdGVzdC9ydW4tdGVzdHMudHNcIixcbiAgICAgICAgXCJ0ZXN0Om1lbW9yeVwiOiBcIm5vZGUgLXIgZXNidWlsZC1yZWdpc3RlciBoZWxwZXJzL21lbW9yeS10ZXN0cy50c1wiLFxuICAgICAgICBcInRlc3Q6ZnVuY3Rpb25hbDpjb2RlXCI6IFwibm9kZSAtciBlc2J1aWxkLXJlZ2lzdGVyIGhlbHBlcnMvZnVuY3Rpb25hbC10ZXN0L3J1bi10ZXN0cy50cyAtLW5vLXR5cGVzXCIsXG4gICAgICAgIFwidGVzdDpmdW5jdGlvbmFsOnR5cGVzXCI6IFwibm9kZSAtciBlc2J1aWxkLXJlZ2lzdGVyIGhlbHBlcnMvZnVuY3Rpb25hbC10ZXN0L3J1bi10ZXN0cy50cyAtLXR5cGVzLW9ubHlcIixcbiAgICAgICAgXCJ0ZXN0LW5vdHlwZXNcIjogXCJqZXN0IC0tdmVyYm9zZSAtLXRlc3RQYXRoSWdub3JlUGF0dGVybnMgc3JjL19fdGVzdHNfXy90eXBlcy90eXBlcy50ZXN0LnRzXCIsXG4gICAgICAgIGdlbmVyYXRlOiBcIm5vZGUgc2NyaXB0cy9wb3N0aW5zdGFsbC5qc1wiLFxuICAgICAgICBwb3N0aW5zdGFsbDogXCJub2RlIHNjcmlwdHMvcG9zdGluc3RhbGwuanNcIixcbiAgICAgICAgcHJlcHVibGlzaE9ubHk6IFwicG5wbSBydW4gYnVpbGRcIixcbiAgICAgICAgXCJuZXctdGVzdFwiOiBcIk5PREVfT1BUSU9OUz0nLXIgdHMtbm9kZS9yZWdpc3RlcicgeW8gLi9oZWxwZXJzL2dlbmVyYXRvci10ZXN0L2luZGV4LnRzXCJcbiAgICAgIH0sXG4gICAgICBmaWxlczogW1xuICAgICAgICBcIlJFQURNRS5tZFwiLFxuICAgICAgICBcInJ1bnRpbWVcIixcbiAgICAgICAgXCJzY3JpcHRzXCIsXG4gICAgICAgIFwiZ2VuZXJhdG9yLWJ1aWxkXCIsXG4gICAgICAgIFwiZWRnZS5qc1wiLFxuICAgICAgICBcImVkZ2UuZC50c1wiLFxuICAgICAgICBcImluZGV4LmpzXCIsXG4gICAgICAgIFwiaW5kZXguZC50c1wiLFxuICAgICAgICBcImluZGV4LWJyb3dzZXIuanNcIlxuICAgICAgXSxcbiAgICAgIGRldkRlcGVuZGVuY2llczoge1xuICAgICAgICBcIkBmYWtlci1qcy9mYWtlclwiOiBcIjcuNC4wXCIsXG4gICAgICAgIFwiQGplc3QvdGVzdC1zZXF1ZW5jZXJcIjogXCIyOC4xLjNcIixcbiAgICAgICAgXCJAbWljcm9zb2Z0L2FwaS1leHRyYWN0b3JcIjogXCI3LjI5LjVcIixcbiAgICAgICAgXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjogXCIxLjEuMFwiLFxuICAgICAgICBcIkBvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3NcIjogXCIxLjUuMFwiLFxuICAgICAgICBcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiOiBcIjAuMzEuMFwiLFxuICAgICAgICBcIkBvcGVudGVsZW1ldHJ5L3Jlc291cmNlc1wiOiBcIjEuNS4wXCIsXG4gICAgICAgIFwiQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2VcIjogXCIxLjUuMFwiLFxuICAgICAgICBcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCI6IFwiMS41LjBcIixcbiAgICAgICAgXCJAcHJpc21hL2RlYnVnXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHByaXNtYS9lbmdpbmUtY29yZVwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvZW5naW5lc1wiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvZmV0Y2gtZW5naW5lXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHByaXNtYS9nZW5lcmF0b3ItaGVscGVyXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHByaXNtYS9nZXQtcGxhdGZvcm1cIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgICAgICAgXCJAcHJpc21hL2luc3RydW1lbnRhdGlvblwiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICAgICAgICBcIkBwcmlzbWEvaW50ZXJuYWxzXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHByaXNtYS9taWdyYXRlXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gICAgICAgIFwiQHN3Yy1ub2RlL3JlZ2lzdGVyXCI6IFwiMS41LjFcIixcbiAgICAgICAgXCJAc3djL2NvcmVcIjogXCIxLjIuMjQyXCIsXG4gICAgICAgIFwiQHN3Yy9qZXN0XCI6IFwiMC4yLjIyXCIsXG4gICAgICAgIFwiQHRpbXN1Y2hhbmVrL2NvcHlcIjogXCIxLjQuNVwiLFxuICAgICAgICBcIkB0eXBlcy9kZWJ1Z1wiOiBcIjQuMS43XCIsXG4gICAgICAgIFwiQHR5cGVzL2plc3RcIjogXCIyOC4xLjdcIixcbiAgICAgICAgXCJAdHlwZXMvanMtbGV2ZW5zaHRlaW5cIjogXCIxLjEuMVwiLFxuICAgICAgICBcIkB0eXBlcy9tc3NxbFwiOiBcIjguMS4xXCIsXG4gICAgICAgIFwiQHR5cGVzL25vZGVcIjogXCIxNC4xOC4yNlwiLFxuICAgICAgICBcIkB0eXBlcy9wZ1wiOiBcIjguNi41XCIsXG4gICAgICAgIFwiQHR5cGVzL3llb21hbi1nZW5lcmF0b3JcIjogXCI1LjIuMTFcIixcbiAgICAgICAgYXJnOiBcIjUuMC4yXCIsXG4gICAgICAgIGJlbmNobWFyazogXCIyLjEuNFwiLFxuICAgICAgICBjaGFsazogXCI0LjEuMlwiLFxuICAgICAgICBjdWlkOiBcIjIuMS44XCIsXG4gICAgICAgIFwiZGVjaW1hbC5qc1wiOiBcIjEwLjQuMFwiLFxuICAgICAgICBlc2J1aWxkOiBcIjAuMTUuNVwiLFxuICAgICAgICBleGVjYTogXCI1LjEuMVwiLFxuICAgICAgICBcImV4cGVjdC10eXBlXCI6IFwiMC4xMy4wXCIsXG4gICAgICAgIFwiZmxhdC1tYXAtcG9seWZpbGxcIjogXCIwLjMuOFwiLFxuICAgICAgICBcImZzLWV4dHJhXCI6IFwiMTAuMS4wXCIsXG4gICAgICAgIFwiZnMtbW9ua2V5XCI6IFwiMS4wLjNcIixcbiAgICAgICAgXCJnZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9sc1wiOiBcIjMuMC4yXCIsXG4gICAgICAgIGdsb2JieTogXCIxMS4xLjBcIixcbiAgICAgICAgXCJpbmRlbnQtc3RyaW5nXCI6IFwiNC4wLjBcIixcbiAgICAgICAgXCJpcy1vYmpcIjogXCIyLjAuMFwiLFxuICAgICAgICBcImlzLXJlZ2V4cFwiOiBcIjIuMS4wXCIsXG4gICAgICAgIGplc3Q6IFwiMjguMS4zXCIsXG4gICAgICAgIFwiamVzdC1qdW5pdFwiOiBcIjE0LjAuMFwiLFxuICAgICAgICBcImplc3Qtc25hcHNob3RcIjogXCIyOC4xLjNcIixcbiAgICAgICAgXCJqcy1sZXZlbnNodGVpblwiOiBcIjEuMS42XCIsXG4gICAgICAgIGtsb25hOiBcIjIuMC41XCIsXG4gICAgICAgIFwibHotc3RyaW5nXCI6IFwiMS40LjRcIixcbiAgICAgICAgXCJtYWtlLWRpclwiOiBcIjMuMS4wXCIsXG4gICAgICAgIG1hcmlhZGI6IFwiMy4wLjFcIixcbiAgICAgICAgbWVtZnM6IFwiMy40LjdcIixcbiAgICAgICAgbXNzcWw6IFwiOS4wLjFcIixcbiAgICAgICAgcGc6IFwiOC44LjBcIixcbiAgICAgICAgXCJwa2ctdXBcIjogXCIzLjEuMFwiLFxuICAgICAgICBwbHVyYWxpemU6IFwiOC4wLjBcIixcbiAgICAgICAgXCJyZXBsYWNlLXN0cmluZ1wiOiBcIjMuMS4wXCIsXG4gICAgICAgIHJlc29sdmU6IFwiMS4yMi4xXCIsXG4gICAgICAgIHJpbXJhZjogXCIzLjAuMlwiLFxuICAgICAgICBcInNpbXBsZS1zdGF0aXN0aWNzXCI6IFwiNy43LjZcIixcbiAgICAgICAgXCJzb3J0LWtleXNcIjogXCI0LjIuMFwiLFxuICAgICAgICBcInNvdXJjZS1tYXAtc3VwcG9ydFwiOiBcIjAuNS4yMVwiLFxuICAgICAgICBcInNxbC10ZW1wbGF0ZS10YWdcIjogXCI1LjAuM1wiLFxuICAgICAgICBcInN0YWNrdHJhY2UtcGFyc2VyXCI6IFwiMC4xLjEwXCIsXG4gICAgICAgIFwic3RyaXAtYW5zaVwiOiBcIjYuMC4xXCIsXG4gICAgICAgIFwic3RyaXAtaW5kZW50XCI6IFwiMy4wLjBcIixcbiAgICAgICAgXCJ0cy1qZXN0XCI6IFwiMjguMC44XCIsXG4gICAgICAgIFwidHMtbm9kZVwiOiBcIjEwLjkuMVwiLFxuICAgICAgICB0c2Q6IFwiMC4yMS4wXCIsXG4gICAgICAgIHR5cGVzY3JpcHQ6IFwiNC44LjJcIixcbiAgICAgICAgXCJ5ZW9tYW4tZ2VuZXJhdG9yXCI6IFwiNS43LjBcIixcbiAgICAgICAgeW86IFwiNC4zLjBcIlxuICAgICAgfSxcbiAgICAgIHBlZXJEZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgcHJpc21hOiBcIipcIlxuICAgICAgfSxcbiAgICAgIHBlZXJEZXBlbmRlbmNpZXNNZXRhOiB7XG4gICAgICAgIHByaXNtYToge1xuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgXCJAcHJpc21hL2VuZ2luZXMtdmVyc2lvblwiOiBcIjQuMy4wLTMyLmM4NzVlNDM2MDBkZmUwNDI0NTJlMGI4NjhmN2E0OGI4MTdiOTY0MGJcIlxuICAgICAgfSxcbiAgICAgIHNpZGVFZmZlY3RzOiBmYWxzZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvcnVudGltZS9pbmRleC50c1xudmFyIHJ1bnRpbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnVudGltZV9leHBvcnRzLCB7XG4gIERNTUY6ICgpID0+IERNTUYsXG4gIERNTUZDbGFzczogKCkgPT4gRE1NRkhlbHBlcixcbiAgRGVidWc6ICgpID0+IERlYnVnLFxuICBEZWNpbWFsOiAoKSA9PiBkZWNpbWFsX2RlZmF1bHQsXG4gIEVuZ2luZTogKCkgPT4gRW5naW5lLFxuICBNZXRyaWNzQ2xpZW50OiAoKSA9PiBNZXRyaWNzQ2xpZW50LFxuICBOb3RGb3VuZEVycm9yOiAoKSA9PiBOb3RGb3VuZEVycm9yMixcbiAgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcjogKCkgPT4gUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcixcbiAgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3I6ICgpID0+IFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcjogKCkgPT4gUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsXG4gIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcjogKCkgPT4gUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLFxuICBTcWw6ICgpID0+IFNxbCxcbiAgZGVjb21wcmVzc0Zyb21CYXNlNjQ6ICgpID0+IGRlY29tcHJlc3NGcm9tQmFzZTY0MixcbiAgZW1wdHk6ICgpID0+IGVtcHR5LFxuICBmaW5kU3luYzogKCkgPT4gZmluZFN5bmMsXG4gIGdldFByaXNtYUNsaWVudDogKCkgPT4gZ2V0UHJpc21hQ2xpZW50LFxuICBqb2luOiAoKSA9PiBqb2luLFxuICBtYWtlRG9jdW1lbnQ6ICgpID0+IG1ha2VEb2N1bWVudCxcbiAgbWFrZVN0cmljdEVudW06ICgpID0+IG1ha2VTdHJpY3RFbnVtLFxuICBvYmplY3RFbnVtVmFsdWVzOiAoKSA9PiBvYmplY3RFbnVtVmFsdWVzLFxuICByYXc6ICgpID0+IHJhdyxcbiAgc3FsdGFnOiAoKSA9PiBzcWwsXG4gIHRyYW5zZm9ybURvY3VtZW50OiAoKSA9PiB0cmFuc2Zvcm1Eb2N1bWVudCxcbiAgdW5wYWNrOiAoKSA9PiB1bnBhY2ssXG4gIHdhcm5FbnZDb25mbGljdHM6ICgpID0+IHdhcm5FbnZDb25mbGljdHNcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocnVudGltZV9leHBvcnRzKTtcbnZhciBselN0cmluZyA9IF9fdG9FU00ocmVxdWlyZV9sel9zdHJpbmcoKSk7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbWV0cmljcy9NZXRyaWNzQ2xpZW50LnRzXG52YXIgTWV0cmljc0NsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW5naW5lKSB7XG4gICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICB9XG4gIHByb21ldGhldXMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9lbmdpbmUubWV0cmljcyh7IGZvcm1hdDogXCJwcm9tZXRoZXVzXCIsIC4uLm9wdGlvbnMgfSk7XG4gIH1cbiAganNvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZ2luZS5tZXRyaWNzKHsgZm9ybWF0OiBcImpzb25cIiwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufTtcbl9fbmFtZShNZXRyaWNzQ2xpZW50LCBcIk1ldHJpY3NDbGllbnRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2FwcGx5TWl4aW5zLnRzXG5mdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvciwgY29uc3RydWN0b3JzKSB7XG4gIHZhciBfYTM7XG4gIGZvciAoY29uc3QgYmFzZUN0b3Igb2YgY29uc3RydWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2VDdG9yLnByb3RvdHlwZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlLFxuICAgICAgICBuYW1lLFxuICAgICAgICAoX2EzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlQ3Rvci5wcm90b3R5cGUsIG5hbWUpKSAhPSBudWxsID8gX2EzIDogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5fX25hbWUoYXBwbHlNaXhpbnMsIFwiYXBwbHlNaXhpbnNcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2NvbW1vbi50c1xudmFyIGltcG9ydF9jaGFsayA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWNpbWFsLmpzQDEwLjQuMC9ub2RlX21vZHVsZXMvZGVjaW1hbC5qcy9kZWNpbWFsLm1qc1xudmFyIEVYUF9MSU1JVCA9IDllMTU7XG52YXIgTUFYX0RJR0lUUyA9IDFlOTtcbnZhciBOVU1FUkFMUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xudmFyIExOMTAgPSBcIjIuMzAyNTg1MDkyOTk0MDQ1Njg0MDE3OTkxNDU0Njg0MzY0MjA3NjAxMTAxNDg4NjI4NzcyOTc2MDMzMzI3OTAwOTY3NTcyNjA5Njc3MzUyNDgwMjM1OTk3MjA1MDg5NTk4Mjk4MzQxOTY3Nzg0MDQyMjg2MjQ4NjMzNDA5NTI1NDY1MDgyODA2NzU2NjY2Mjg3MzY5MDk4NzgxNjg5NDgyOTA3MjA4MzI1NTU0NjgwODQzNzk5ODk0ODI2MjMzMTk4NTI4MzkzNTA1MzA4OTY1Mzc3NzMyNjI4ODQ2MTYzMzY2MjIyMjg3Njk4MjE5ODg2NzQ2NTQzNjY3NDc0NDA0MjQzMjc0MzY1MTU1MDQ4OTM0MzE0OTM5MzkxNDc5NjE5NDA0NDAwMjIyMTA1MTAxNzE0MTc0ODAwMzY4ODA4NDAxMjY0NzA4MDY4NTU2Nzc0MzIxNjIyODM1NTIyMDExNDgwNDY2MzcxNTY1OTEyMTM3MzQ1MDc0Nzg1Njk0NzY4MzQ2MzYxNjc5MjEwMTgwNjQ0NTA3MDY0ODAwMDI3NzUwMjY4NDkxNjc0NjU1MDU4Njg1NjkzNTY3MzQyMDY3MDU4MTEzNjQyOTIyNDU1NDQwNTc1ODkyNTcyNDIwODI0MTMxNDY5NTY4OTAxNjc1ODk0MDI1Njc3NjMxMTM1NjkxOTI5MjAzMzM3NjU4NzE0MTY2MDIzMDEwNTcwMzA4OTYzNDU3MjA3NTQ0MDM3MDg0NzQ2OTk0MDE2ODI2OTI4MjgwODQ4MTE4NDI4OTMxNDg0ODUyNDk0ODY0NDg3MTkyNzgwOTY3NjI3MTI3NTc3NTM5NzAyNzY2ODYwNTk1MjQ5NjcxNjY3NDE4MzQ4NTcwNDQyMjUwNzE5Nzk2NTAwNDcxNDk1MTA1MDQ5MjIxNDc3NjU2NzYzNjkzODY2Mjk3Njk3OTUyMjExMDcxODI2NDU0OTczNDc3MjY2MjQyNTcwOTQyOTMyMjU4Mjc5ODUwMjU4NTUwOTc4NTI2NTM4MzIwNzYwNjcyNjMxNzE2NDMwOTUwNTk5NTA4NzgwNzUyMzcxMDMzMzEwMTE5Nzg1NzU0NzMzMTU0MTQyMTgwODQyNzU0Mzg2MzU5MTc3ODExNzA1NDMwOTgyNzQ4MjM4NTA0NTY0ODAxOTA5NTYxMDI5OTI5MTgyNDMxODIzNzUyNTM1NzcwOTc1MDUzOTU2NTE4NzY5NzUxMDM3NDk3MDg4ODY5MjE4MDIwNTE4OTMzOTUwNzIzODUzOTIwNTE0NDYzNDE5NzI2NTI4NzI4Njk2NTExMDg2MjU3MTQ5MjE5ODg0OTk3ODc0ODg3Mzc3MTM0NTY4NjIwOTE2NzA1OFwiO1xudmFyIFBJID0gXCIzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODlcIjtcbnZhciBERUZBVUxUUyA9IHtcbiAgcHJlY2lzaW9uOiAyMCxcbiAgcm91bmRpbmc6IDQsXG4gIG1vZHVsbzogMSxcbiAgdG9FeHBOZWc6IC03LFxuICB0b0V4cFBvczogMjEsXG4gIG1pbkU6IC1FWFBfTElNSVQsXG4gIG1heEU6IEVYUF9MSU1JVCxcbiAgY3J5cHRvOiBmYWxzZVxufTtcbnZhciBpbmV4YWN0O1xudmFyIHF1YWRyYW50O1xudmFyIGV4dGVybmFsID0gdHJ1ZTtcbnZhciBkZWNpbWFsRXJyb3IgPSBcIltEZWNpbWFsRXJyb3JdIFwiO1xudmFyIGludmFsaWRBcmd1bWVudCA9IGRlY2ltYWxFcnJvciArIFwiSW52YWxpZCBhcmd1bWVudDogXCI7XG52YXIgcHJlY2lzaW9uTGltaXRFeGNlZWRlZCA9IGRlY2ltYWxFcnJvciArIFwiUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkXCI7XG52YXIgY3J5cHRvVW5hdmFpbGFibGUgPSBkZWNpbWFsRXJyb3IgKyBcImNyeXB0byB1bmF2YWlsYWJsZVwiO1xudmFyIHRhZyA9IFwiW29iamVjdCBEZWNpbWFsXVwiO1xudmFyIG1hdGhmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aHBvdyA9IE1hdGgucG93O1xudmFyIGlzQmluYXJ5ID0gL14wYihbMDFdKyhcXC5bMDFdKik/fFxcLlswMV0rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaTtcbnZhciBpc09jdGFsID0gL14wbyhbMC03XSsoXFwuWzAtN10qKT98XFwuWzAtN10rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNEZWNpbWFsID0gL14oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pO1xudmFyIEJBU0UgPSAxZTc7XG52YXIgTE9HX0JBU0UgPSA3O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIExOMTBfUFJFQ0lTSU9OID0gTE4xMC5sZW5ndGggLSAxO1xudmFyIFBJX1BSRUNJU0lPTiA9IFBJLmxlbmd0aCAtIDE7XG52YXIgUCA9IHsgdG9TdHJpbmdUYWc6IHRhZyB9O1xuUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgaWYgKHgucyA8IDApXG4gICAgeC5zID0gMTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xufTtcblAuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xufTtcblAuY2xhbXBlZFRvID0gUC5jbGFtcCA9IGZ1bmN0aW9uKG1pbjIsIG1heDIpIHtcbiAgdmFyIGssIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgbWluMiA9IG5ldyBDdG9yKG1pbjIpO1xuICBtYXgyID0gbmV3IEN0b3IobWF4Mik7XG4gIGlmICghbWluMi5zIHx8ICFtYXgyLnMpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmIChtaW4yLmd0KG1heDIpKVxuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG1heDIpO1xuICBrID0geC5jbXAobWluMik7XG4gIHJldHVybiBrIDwgMCA/IG1pbjIgOiB4LmNtcChtYXgyKSA+IDAgPyBtYXgyIDogbmV3IEN0b3IoeCk7XG59O1xuUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBpLCBqLCB4ZEwsIHlkTCwgeCA9IHRoaXMsIHhkID0geC5kLCB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsIHhzID0geC5zLCB5cyA9IHkucztcbiAgaWYgKCF4ZCB8fCAheWQpIHtcbiAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgfVxuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSlcbiAgICByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcbiAgaWYgKHhzICE9PSB5cylcbiAgICByZXR1cm4geHM7XG4gIGlmICh4LmUgIT09IHkuZSlcbiAgICByZXR1cm4geC5lID4geS5lIF4geHMgPCAwID8gMSA6IC0xO1xuICB4ZEwgPSB4ZC5sZW5ndGg7XG4gIHlkTCA9IHlkLmxlbmd0aDtcbiAgZm9yIChpID0gMCwgaiA9IHhkTCA8IHlkTCA/IHhkTCA6IHlkTDsgaSA8IGo7ICsraSkge1xuICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pXG4gICAgICByZXR1cm4geGRbaV0gPiB5ZFtpXSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4geGRMID09PSB5ZEwgPyAwIDogeGRMID4geWRMIF4geHMgPCAwID8gMSA6IC0xO1xufTtcblAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguZClcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKCF4LmRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gMyA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAuY3ViZVJvb3QgPSBQLmNicnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzID0geC5zICogbWF0aHBvdyh4LnMgKiB4LCAxIC8gMyk7XG4gIGlmICghcyB8fCBNYXRoLmFicyhzKSA9PSAxIC8gMCkge1xuICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xuICAgIGUgPSB4LmU7XG4gICAgaWYgKHMgPSAoZSAtIG4ubGVuZ3RoICsgMSkgJSAzKVxuICAgICAgbiArPSBzID09IDEgfHwgcyA9PSAtMiA/IFwiMFwiIDogXCIwMFwiO1xuICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgICByLnMgPSB4LnM7XG4gIH0gZWxzZSB7XG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSByO1xuICAgIHQzID0gdC50aW1lcyh0KS50aW1lcyh0KTtcbiAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcbiAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHcsIGQgPSB0aGlzLmQsIG4gPSBOYU47XG4gIGlmIChkKSB7XG4gICAgdyA9IGQubGVuZ3RoIC0gMTtcbiAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xuICAgIHcgPSBkW3ddO1xuICAgIGlmICh3KVxuICAgICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKVxuICAgICAgICBuLS07XG4gICAgaWYgKG4gPCAwKVxuICAgICAgbiA9IDA7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XG59O1xuUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24oeSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZmluYWxpc2UoZGl2aWRlKHgsIG5ldyBDdG9yKHkpLCAwLCAxLCAxKSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xufTtcblAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID09PSAwO1xufTtcblAuZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcbn07XG5QLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcbn07XG5QLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBrID0gdGhpcy5jbXAoeSk7XG4gIHJldHVybiBrID09IDEgfHwgayA9PT0gMDtcbn07XG5QLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIG4sIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIG9uZSA9IG5ldyBDdG9yKDEpO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5zID8gMSAvIDAgOiBOYU4pO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gb25lO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMyKSB7XG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcbiAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxNjtcbiAgICBuID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gIH1cbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKG4pLCBuZXcgQ3RvcigxKSwgdHJ1ZSk7XG4gIHZhciBjb3NoMl94LCBpID0gaywgZDggPSBuZXcgQ3Rvcig4KTtcbiAgZm9yICg7IGktLTsgKSB7XG4gICAgY29zaDJfeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZSh4LCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMpIHtcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgICB2YXIgc2luaDJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gICAgZm9yICg7IGstLTsgKSB7XG4gICAgICBzaW5oMl94ID0geC50aW1lcyh4KTtcbiAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luaDJfeC50aW1lcyhkMTYudGltZXMoc2luaDJfeCkucGx1cyhkMjApKSkpO1xuICAgIH1cbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5zKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA3O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgcmV0dXJuIGRpdmlkZSh4LnNpbmgoKSwgeC5jb3NoKCksIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSk7XG59O1xuUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmUGksIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgayA9IHguYWJzKCkuY21wKDEpLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIHJldHVybiBrID09PSAwID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApIDogbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5hc2luKCk7XG4gIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGhhbGZQaS5taW51cyh4KTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljQ29zaW5lID0gUC5hY29zaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICh4Lmx0ZSgxKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5lcSgxKSA/IDAgOiBOYU4pO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC5sbigpO1xufTtcblAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAyICogTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICB4ID0geC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKHgpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgubG4oKTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljVGFuZ2VudCA9IFAuYXRhbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgd3ByLCB4c2QsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmUgPj0gMClcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5hYnMoKS5lcSgxKSA/IHgucyAvIDAgOiB4LmlzWmVybygpID8geCA6IE5hTik7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgeHNkID0geC5zZCgpO1xuICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xuICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHhzZCAtIHguZTtcbiAgeCA9IGRpdmlkZSh4LnBsdXMoMSksIG5ldyBDdG9yKDEpLm1pbnVzKHgpLCB3cHIgKyBwciwgMSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHgubG4oKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC50aW1lcygwLjUpO1xufTtcblAuaW52ZXJzZVNpbmUgPSBQLmFzaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhbGZQaSwgaywgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgayA9IHguYWJzKCkuY21wKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgaGFsZlBpLnMgPSB4LnM7XG4gICAgICByZXR1cm4gaGFsZlBpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmRpdihuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LnRpbWVzKDIpO1xufTtcblAuaW52ZXJzZVRhbmdlbnQgPSBQLmF0YW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGksIGosIGssIG4sIHB4LCB0LCByLCB3cHIsIHgyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICBpZiAoIXgucylcbiAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgIGlmIChwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XG4gICAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgIHIucyA9IHgucztcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICB9IGVsc2UgaWYgKHguYWJzKCkuZXEoMSkgJiYgcHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcbiAgICByLnMgPSB4LnM7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSBwciArIDEwO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcbiAgZm9yIChpID0gazsgaTsgLS1pKVxuICAgIHggPSB4LmRpdih4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoMSkpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBqID0gTWF0aC5jZWlsKHdwciAvIExPR19CQVNFKTtcbiAgbiA9IDE7XG4gIHgyID0geC50aW1lcyh4KTtcbiAgciA9IG5ldyBDdG9yKHgpO1xuICBweCA9IHg7XG4gIGZvciAoOyBpICE9PSAtMTsgKSB7XG4gICAgcHggPSBweC50aW1lcyh4Mik7XG4gICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xuICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgIHIgPSB0LnBsdXMocHguZGl2KG4gKz0gMikpO1xuICAgIGlmIChyLmRbal0gIT09IHZvaWQgMClcbiAgICAgIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTsgKVxuICAgICAgICA7XG4gIH1cbiAgaWYgKGspXG4gICAgciA9IHIudGltZXMoMiA8PCBrIC0gMSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG59O1xuUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQ7XG59O1xuUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XG59O1xuUC5pc05hTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucztcbn07XG5QLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPCAwO1xufTtcblAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucyA+IDA7XG59O1xuUC5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcbn07XG5QLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcbn07XG5QLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XG59O1xuUC5sb2dhcml0aG0gPSBQLmxvZyA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLCBhcmcyID0gdGhpcywgQ3RvciA9IGFyZzIuY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZywgZ3VhcmQgPSA1O1xuICBpZiAoYmFzZSA9PSBudWxsKSB7XG4gICAgYmFzZSA9IG5ldyBDdG9yKDEwKTtcbiAgICBpc0Jhc2UxMCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IG5ldyBDdG9yKGJhc2UpO1xuICAgIGQgPSBiYXNlLmQ7XG4gICAgaWYgKGJhc2UucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYmFzZS5lcSgxKSlcbiAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgIGlzQmFzZTEwID0gYmFzZS5lcSgxMCk7XG4gIH1cbiAgZCA9IGFyZzIuZDtcbiAgaWYgKGFyZzIucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYXJnMi5lcSgxKSkge1xuICAgIHJldHVybiBuZXcgQ3RvcihkICYmICFkWzBdID8gLTEgLyAwIDogYXJnMi5zICE9IDEgPyBOYU4gOiBkID8gMCA6IDEgLyAwKTtcbiAgfVxuICBpZiAoaXNCYXNlMTApIHtcbiAgICBpZiAoZC5sZW5ndGggPiAxKSB7XG4gICAgICBpbmYgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGsgPSBkWzBdOyBrICUgMTAgPT09IDA7IClcbiAgICAgICAgayAvPSAxMDtcbiAgICAgIGluZiA9IGsgIT09IDE7XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHNkID0gcHIgKyBndWFyZDtcbiAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcyLCBzZCk7XG4gIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XG4gIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgPSBwciwgcm0pKSB7XG4gICAgZG8ge1xuICAgICAgc2QgKz0gMTA7XG4gICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZzIsIHNkKTtcbiAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XG4gICAgICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcbiAgICAgIGlmICghaW5mKSB7XG4gICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShrICsgMSwgayArIDE1KSArIDEgPT0gMWUxNCkge1xuICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrICs9IDEwLCBybSkpO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG59O1xuUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24oeSkge1xuICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeSA9IG5ldyBDdG9yKHkpO1xuICBpZiAoIXguZCB8fCAheS5kKSB7XG4gICAgaWYgKCF4LnMgfHwgIXkucylcbiAgICAgIHkgPSBuZXcgQ3RvcihOYU4pO1xuICAgIGVsc2UgaWYgKHguZClcbiAgICAgIHkucyA9IC15LnM7XG4gICAgZWxzZVxuICAgICAgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xuICAgIHJldHVybiB5O1xuICB9XG4gIGlmICh4LnMgIT0geS5zKSB7XG4gICAgeS5zID0gLXkucztcbiAgICByZXR1cm4geC5wbHVzKHkpO1xuICB9XG4gIHhkID0geC5kO1xuICB5ZCA9IHkuZDtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xuICAgIGlmICh5ZFswXSlcbiAgICAgIHkucyA9IC15LnM7XG4gICAgZWxzZSBpZiAoeGRbMF0pXG4gICAgICB5ID0gbmV3IEN0b3IoeCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgfVxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xuICB4ZCA9IHhkLnNsaWNlKCk7XG4gIGsgPSB4ZSAtIGU7XG4gIGlmIChrKSB7XG4gICAgeExUeSA9IGsgPCAwO1xuICAgIGlmICh4TFR5KSB7XG4gICAgICBkID0geGQ7XG4gICAgICBrID0gLWs7XG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSB5ZDtcbiAgICAgIGUgPSB4ZTtcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcbiAgICB9XG4gICAgaSA9IE1hdGgubWF4KE1hdGguY2VpbChwciAvIExPR19CQVNFKSwgbGVuKSArIDI7XG4gICAgaWYgKGsgPiBpKSB7XG4gICAgICBrID0gaTtcbiAgICAgIGQubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZC5yZXZlcnNlKCk7XG4gICAgZm9yIChpID0gazsgaS0tOyApXG4gICAgICBkLnB1c2goMCk7XG4gICAgZC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgaSA9IHhkLmxlbmd0aDtcbiAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgeExUeSA9IGkgPCBsZW47XG4gICAgaWYgKHhMVHkpXG4gICAgICBsZW4gPSBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHhkW2ldICE9IHlkW2ldKSB7XG4gICAgICAgIHhMVHkgPSB4ZFtpXSA8IHlkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgayA9IDA7XG4gIH1cbiAgaWYgKHhMVHkpIHtcbiAgICBkID0geGQ7XG4gICAgeGQgPSB5ZDtcbiAgICB5ZCA9IGQ7XG4gICAgeS5zID0gLXkucztcbiAgfVxuICBsZW4gPSB4ZC5sZW5ndGg7XG4gIGZvciAoaSA9IHlkLmxlbmd0aCAtIGxlbjsgaSA+IDA7IC0taSlcbiAgICB4ZFtsZW4rK10gPSAwO1xuICBmb3IgKGkgPSB5ZC5sZW5ndGg7IGkgPiBrOyApIHtcbiAgICBpZiAoeGRbLS1pXSA8IHlkW2ldKSB7XG4gICAgICBmb3IgKGogPSBpOyBqICYmIHhkWy0tal0gPT09IDA7IClcbiAgICAgICAgeGRbal0gPSBCQVNFIC0gMTtcbiAgICAgIC0teGRbal07XG4gICAgICB4ZFtpXSArPSBCQVNFO1xuICAgIH1cbiAgICB4ZFtpXSAtPSB5ZFtpXTtcbiAgfVxuICBmb3IgKDsgeGRbLS1sZW5dID09PSAwOyApXG4gICAgeGQucG9wKCk7XG4gIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSlcbiAgICAtLWU7XG4gIGlmICgheGRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcbiAgeS5kID0geGQ7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG59O1xuUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHEsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeSA9IG5ldyBDdG9yKHkpO1xuICBpZiAoIXguZCB8fCAheS5zIHx8IHkuZCAmJiAheS5kWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoIXkuZCB8fCB4LmQgJiYgIXguZFswXSkge1xuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGlmIChDdG9yLm1vZHVsbyA9PSA5KSB7XG4gICAgcSA9IGRpdmlkZSh4LCB5LmFicygpLCAwLCAzLCAxKTtcbiAgICBxLnMgKj0geS5zO1xuICB9IGVsc2Uge1xuICAgIHEgPSBkaXZpZGUoeCwgeSwgMCwgQ3Rvci5tb2R1bG8sIDEpO1xuICB9XG4gIHEgPSBxLnRpbWVzKHkpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB4Lm1pbnVzKHEpO1xufTtcblAubmF0dXJhbEV4cG9uZW50aWFsID0gUC5leHAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5hdHVyYWxFeHBvbmVudGlhbCh0aGlzKTtcbn07XG5QLm5hdHVyYWxMb2dhcml0aG0gPSBQLmxuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xufTtcblAubmVnYXRlZCA9IFAubmVnID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIHgucyA9IC14LnM7XG4gIHJldHVybiBmaW5hbGlzZSh4KTtcbn07XG5QLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGNhcnJ5LCBkLCBlLCBpLCBrLCBsZW4sIHByLCBybSwgeGQsIHlkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xuICAgIGlmICgheC5zIHx8ICF5LnMpXG4gICAgICB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICBlbHNlIGlmICgheC5kKVxuICAgICAgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgPT09IHkucyA/IHggOiBOYU4pO1xuICAgIHJldHVybiB5O1xuICB9XG4gIGlmICh4LnMgIT0geS5zKSB7XG4gICAgeS5zID0gLXkucztcbiAgICByZXR1cm4geC5taW51cyh5KTtcbiAgfVxuICB4ZCA9IHguZDtcbiAgeWQgPSB5LmQ7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcbiAgICBpZiAoIXlkWzBdKVxuICAgICAgeSA9IG5ldyBDdG9yKHgpO1xuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xuICB9XG4gIGsgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGQgPSB4ZC5zbGljZSgpO1xuICBpID0gayAtIGU7XG4gIGlmIChpKSB7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBkID0geGQ7XG4gICAgICBpID0gLWk7XG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSB5ZDtcbiAgICAgIGUgPSBrO1xuICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgIH1cbiAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xuICAgIGxlbiA9IGsgPiBsZW4gPyBrICsgMSA6IGxlbiArIDE7XG4gICAgaWYgKGkgPiBsZW4pIHtcbiAgICAgIGkgPSBsZW47XG4gICAgICBkLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGQucmV2ZXJzZSgpO1xuICAgIGZvciAoOyBpLS07IClcbiAgICAgIGQucHVzaCgwKTtcbiAgICBkLnJldmVyc2UoKTtcbiAgfVxuICBsZW4gPSB4ZC5sZW5ndGg7XG4gIGkgPSB5ZC5sZW5ndGg7XG4gIGlmIChsZW4gLSBpIDwgMCkge1xuICAgIGkgPSBsZW47XG4gICAgZCA9IHlkO1xuICAgIHlkID0geGQ7XG4gICAgeGQgPSBkO1xuICB9XG4gIGZvciAoY2FycnkgPSAwOyBpOyApIHtcbiAgICBjYXJyeSA9ICh4ZFstLWldID0geGRbaV0gKyB5ZFtpXSArIGNhcnJ5KSAvIEJBU0UgfCAwO1xuICAgIHhkW2ldICU9IEJBU0U7XG4gIH1cbiAgaWYgKGNhcnJ5KSB7XG4gICAgeGQudW5zaGlmdChjYXJyeSk7XG4gICAgKytlO1xuICB9XG4gIGZvciAobGVuID0geGQubGVuZ3RoOyB4ZFstLWxlbl0gPT0gMDsgKVxuICAgIHhkLnBvcCgpO1xuICB5LmQgPSB4ZDtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbn07XG5QLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbih6KSB7XG4gIHZhciBrLCB4ID0gdGhpcztcbiAgaWYgKHogIT09IHZvaWQgMCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwKVxuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHopO1xuICBpZiAoeC5kKSB7XG4gICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xuICAgIGlmICh6ICYmIHguZSArIDEgPiBrKVxuICAgICAgayA9IHguZSArIDE7XG4gIH0gZWxzZSB7XG4gICAgayA9IE5hTjtcbiAgfVxuICByZXR1cm4gaztcbn07XG5QLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XG59O1xuUC5zaW5lID0gUC5zaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSBzaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA+IDIgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG0sIG4sIHNkLCByLCByZXAsIHQsIHggPSB0aGlzLCBkID0geC5kLCBlID0geC5lLCBzID0geC5zLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHMgIT09IDEgfHwgIWQgfHwgIWRbMF0pIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoIXMgfHwgcyA8IDAgJiYgKCFkIHx8IGRbMF0pID8gTmFOIDogZCA/IHggOiAxIC8gMCk7XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgcyA9IE1hdGguc3FydCgreCk7XG4gIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xuICAgIG4gPSBkaWdpdHNUb1N0cmluZyhkKTtcbiAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApXG4gICAgICBuICs9IFwiMFwiO1xuICAgIHMgPSBNYXRoLnNxcnQobik7XG4gICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xuICAgIGlmIChzID09IDEgLyAwKSB7XG4gICAgICBuID0gXCI1ZVwiICsgZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKFwiZVwiKSArIDEpICsgZTtcbiAgICB9XG4gICAgciA9IG5ldyBDdG9yKG4pO1xuICB9IGVsc2Uge1xuICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xuICB9XG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gcjtcbiAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcbiAgICAgIGlmIChuID09IFwiOTk5OVwiIHx8ICFyZXAgJiYgbiA9PSBcIjQ5OTlcIikge1xuICAgICAgICBpZiAoIXJlcCkge1xuICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcbiAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xuICAgICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2QgKz0gNDtcbiAgICAgICAgcmVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09IFwiNVwiKSB7XG4gICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XG59O1xuUC50YW5nZW50ID0gUC50YW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAxMDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LnNpbigpO1xuICB4LnMgPSAxO1xuICB4ID0gZGl2aWRlKHgsIG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKSwgcHIgKyAxMCwgMCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gNCA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGNhcnJ5LCBlLCBpLCBrLCByLCByTCwgdCwgeGRMLCB5ZEwsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgeGQgPSB4LmQsIHlkID0gKHkgPSBuZXcgQ3Rvcih5KSkuZDtcbiAgeS5zICo9IHgucztcbiAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xuICAgIHJldHVybiBuZXcgQ3RvcigheS5zIHx8IHhkICYmICF4ZFswXSAmJiAheWQgfHwgeWQgJiYgIXlkWzBdICYmICF4ZCA/IE5hTiA6ICF4ZCB8fCAheWQgPyB5LnMgLyAwIDogeS5zICogMCk7XG4gIH1cbiAgZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZEwgPSB4ZC5sZW5ndGg7XG4gIHlkTCA9IHlkLmxlbmd0aDtcbiAgaWYgKHhkTCA8IHlkTCkge1xuICAgIHIgPSB4ZDtcbiAgICB4ZCA9IHlkO1xuICAgIHlkID0gcjtcbiAgICByTCA9IHhkTDtcbiAgICB4ZEwgPSB5ZEw7XG4gICAgeWRMID0gckw7XG4gIH1cbiAgciA9IFtdO1xuICByTCA9IHhkTCArIHlkTDtcbiAgZm9yIChpID0gckw7IGktLTsgKVxuICAgIHIucHVzaCgwKTtcbiAgZm9yIChpID0geWRMOyAtLWkgPj0gMDsgKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoayA9IHhkTCArIGk7IGsgPiBpOyApIHtcbiAgICAgIHQgPSByW2tdICsgeWRbaV0gKiB4ZFtrIC0gaSAtIDFdICsgY2Fycnk7XG4gICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XG4gICAgICBjYXJyeSA9IHQgLyBCQVNFIHwgMDtcbiAgICB9XG4gICAgcltrXSA9IChyW2tdICsgY2FycnkpICUgQkFTRSB8IDA7XG4gIH1cbiAgZm9yICg7ICFyWy0tckxdOyApXG4gICAgci5wb3AoKTtcbiAgaWYgKGNhcnJ5KVxuICAgICsrZTtcbiAgZWxzZVxuICAgIHIuc2hpZnQoKTtcbiAgeS5kID0gcjtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQociwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKSA6IHk7XG59O1xuUC50b0JpbmFyeSA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMiwgc2QsIHJtKTtcbn07XG5QLnRvRGVjaW1hbFBsYWNlcyA9IFAudG9EUCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB4ID0gbmV3IEN0b3IoeCk7XG4gIGlmIChkcCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB4O1xuICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBlbHNlXG4gICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIHJldHVybiBmaW5hbGlzZSh4LCBkcCArIHguZSArIDEsIHJtKTtcbn07XG5QLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHN0ciwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoZHAgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyAxLCBybSk7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSwgZHAgKyAxKTtcbiAgfVxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50b0ZpeGVkID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gIHZhciBzdHIsIHksIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB5ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgeC5lICsgMSwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvRnJhY3Rpb24gPSBmdW5jdGlvbihtYXhEKSB7XG4gIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBrLCBuLCBuMCwgbjEsIHByLCBxLCByLCB4ID0gdGhpcywgeGQgPSB4LmQsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXhkKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgbjEgPSBkMCA9IG5ldyBDdG9yKDEpO1xuICBkMSA9IG4wID0gbmV3IEN0b3IoMCk7XG4gIGQgPSBuZXcgQ3RvcihkMSk7XG4gIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcbiAgayA9IGUgJSBMT0dfQkFTRTtcbiAgZC5kWzBdID0gbWF0aHBvdygxMCwgayA8IDAgPyBMT0dfQkFTRSArIGsgOiBrKTtcbiAgaWYgKG1heEQgPT0gbnVsbCkge1xuICAgIG1heEQgPSBlID4gMCA/IGQgOiBuMTtcbiAgfSBlbHNlIHtcbiAgICBuID0gbmV3IEN0b3IobWF4RCk7XG4gICAgaWYgKCFuLmlzSW50KCkgfHwgbi5sdChuMSkpXG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBuKTtcbiAgICBtYXhEID0gbi5ndChkKSA/IGUgPiAwID8gZCA6IG4xIDogbjtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgQ3Rvci5wcmVjaXNpb24gPSBlID0geGQubGVuZ3RoICogTE9HX0JBU0UgKiAyO1xuICBmb3IgKDsgOyApIHtcbiAgICBxID0gZGl2aWRlKG4sIGQsIDAsIDEsIDEpO1xuICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XG4gICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKVxuICAgICAgYnJlYWs7XG4gICAgZDAgPSBkMTtcbiAgICBkMSA9IGQyO1xuICAgIGQyID0gbjE7XG4gICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIpKTtcbiAgICBuMCA9IGQyO1xuICAgIGQyID0gZDtcbiAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyKSk7XG4gICAgbiA9IGQyO1xuICB9XG4gIGQyID0gZGl2aWRlKG1heEQubWludXMoZDApLCBkMSwgMCwgMSwgMSk7XG4gIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xuICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcbiAgbjAucyA9IG4xLnMgPSB4LnM7XG4gIHIgPSBkaXZpZGUobjEsIGQxLCBlLCAxKS5taW51cyh4KS5hYnMoKS5jbXAoZGl2aWRlKG4wLCBkMCwgZSwgMSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHI7XG59O1xuUC50b0hleGFkZWNpbWFsID0gUC50b0hleCA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMTYsIHNkLCBybSk7XG59O1xuUC50b05lYXJlc3QgPSBmdW5jdGlvbih5LCBybSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB4ID0gbmV3IEN0b3IoeCk7XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICBpZiAoIXguZClcbiAgICAgIHJldHVybiB4O1xuICAgIHkgPSBuZXcgQ3RvcigxKTtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH0gZWxzZSB7XG4gICAgeSA9IG5ldyBDdG9yKHkpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSB7XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIH1cbiAgICBpZiAoIXguZClcbiAgICAgIHJldHVybiB5LnMgPyB4IDogeTtcbiAgICBpZiAoIXkuZCkge1xuICAgICAgaWYgKHkucylcbiAgICAgICAgeS5zID0geC5zO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9XG4gIGlmICh5LmRbMF0pIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHggPSBkaXZpZGUoeCwgeSwgMCwgcm0sIDEpLnRpbWVzKHkpO1xuICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICBmaW5hbGlzZSh4KTtcbiAgfSBlbHNlIHtcbiAgICB5LnMgPSB4LnM7XG4gICAgeCA9IHk7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuUC50b051bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gK3RoaXM7XG59O1xuUC50b09jdGFsID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xufTtcblAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24oeSkge1xuICB2YXIgZSwgaywgcHIsIHIsIHJtLCBzLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHluID0gKyh5ID0gbmV3IEN0b3IoeSkpO1xuICBpZiAoIXguZCB8fCAheS5kIHx8ICF4LmRbMF0gfHwgIXkuZFswXSlcbiAgICByZXR1cm4gbmV3IEN0b3IobWF0aHBvdygreCwgeW4pKTtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoeC5lcSgxKSlcbiAgICByZXR1cm4geDtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoeS5lcSgxKSlcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIGlmIChlID49IHkuZC5sZW5ndGggLSAxICYmIChrID0geW4gPCAwID8gLXluIDogeW4pIDw9IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcbiAgICByZXR1cm4geS5zIDwgMCA/IG5ldyBDdG9yKDEpLmRpdihyKSA6IGZpbmFsaXNlKHIsIHByLCBybSk7XG4gIH1cbiAgcyA9IHgucztcbiAgaWYgKHMgPCAwKSB7XG4gICAgaWYgKGUgPCB5LmQubGVuZ3RoIC0gMSlcbiAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgIGlmICgoeS5kW2VdICYgMSkgPT0gMClcbiAgICAgIHMgPSAxO1xuICAgIGlmICh4LmUgPT0gMCAmJiB4LmRbMF0gPT0gMSAmJiB4LmQubGVuZ3RoID09IDEpIHtcbiAgICAgIHgucyA9IHM7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH1cbiAgayA9IG1hdGhwb3coK3gsIHluKTtcbiAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaykgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coXCIwLlwiICsgZGlnaXRzVG9TdHJpbmcoeC5kKSkgLyBNYXRoLkxOMTAgKyB4LmUgKyAxKSkgOiBuZXcgQ3RvcihrICsgXCJcIikuZTtcbiAgaWYgKGUgPiBDdG9yLm1heEUgKyAxIHx8IGUgPCBDdG9yLm1pbkUgLSAxKVxuICAgIHJldHVybiBuZXcgQ3RvcihlID4gMCA/IHMgLyAwIDogMCk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIEN0b3Iucm91bmRpbmcgPSB4LnMgPSAxO1xuICBrID0gTWF0aC5taW4oMTIsIChlICsgXCJcIikubGVuZ3RoKTtcbiAgciA9IG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgcHIgKyBrKSksIHByKTtcbiAgaWYgKHIuZCkge1xuICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDUsIDEpO1xuICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgcHIsIHJtKSkge1xuICAgICAgZSA9IHByICsgMTA7XG4gICAgICByID0gZmluYWxpc2UobmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBlICsgaykpLCBlKSwgZSArIDUsIDEpO1xuICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKHByICsgMSwgcHIgKyAxNSkgKyAxID09IDFlMTQpIHtcbiAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHIucyA9IHM7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcbn07XG5QLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHZhciBzdHIsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvU2lnbmlmaWNhbnREaWdpdHMgPSBQLnRvU0QgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcbiAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XG59O1xuUC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAxKTtcbn07XG5QLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XG4gIHJldHVybiB4LmlzTmVnKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5mdW5jdGlvbiBkaWdpdHNUb1N0cmluZyhkKSB7XG4gIHZhciBpLCBrLCB3cywgaW5kZXhPZkxhc3RXb3JkID0gZC5sZW5ndGggLSAxLCBzdHIgPSBcIlwiLCB3ID0gZFswXTtcbiAgaWYgKGluZGV4T2ZMYXN0V29yZCA+IDApIHtcbiAgICBzdHIgKz0gdztcbiAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXhPZkxhc3RXb3JkOyBpKyspIHtcbiAgICAgIHdzID0gZFtpXSArIFwiXCI7XG4gICAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XG4gICAgICBpZiAoaylcbiAgICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgICBzdHIgKz0gd3M7XG4gICAgfVxuICAgIHcgPSBkW2ldO1xuICAgIHdzID0gdyArIFwiXCI7XG4gICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgIGlmIChrKVxuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSBpZiAodyA9PT0gMCkge1xuICAgIHJldHVybiBcIjBcIjtcbiAgfVxuICBmb3IgKDsgdyAlIDEwID09PSAwOyApXG4gICAgdyAvPSAxMDtcbiAgcmV0dXJuIHN0ciArIHc7XG59XG5fX25hbWUoZGlnaXRzVG9TdHJpbmcsIFwiZGlnaXRzVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBjaGVja0ludDMyKGksIG1pbjIsIG1heDIpIHtcbiAgaWYgKGkgIT09IH5+aSB8fCBpIDwgbWluMiB8fCBpID4gbWF4Mikge1xuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIGkpO1xuICB9XG59XG5fX25hbWUoY2hlY2tJbnQzMiwgXCJjaGVja0ludDMyXCIpO1xuZnVuY3Rpb24gY2hlY2tSb3VuZGluZ0RpZ2l0cyhkLCBpLCBybSwgcmVwZWF0aW5nKSB7XG4gIHZhciBkaSwgaywgciwgcmQ7XG4gIGZvciAoayA9IGRbMF07IGsgPj0gMTA7IGsgLz0gMTApXG4gICAgLS1pO1xuICBpZiAoLS1pIDwgMCkge1xuICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgZGkgPSAwO1xuICB9IGVsc2Uge1xuICAgIGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XG4gICAgaSAlPSBMT0dfQkFTRTtcbiAgfVxuICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcbiAgcmQgPSBkW2RpXSAlIGsgfCAwO1xuICBpZiAocmVwZWF0aW5nID09IG51bGwpIHtcbiAgICBpZiAoaSA8IDMpIHtcbiAgICAgIGlmIChpID09IDApXG4gICAgICAgIHJkID0gcmQgLyAxMDAgfCAwO1xuICAgICAgZWxzZSBpZiAoaSA9PSAxKVxuICAgICAgICByZCA9IHJkIC8gMTAgfCAwO1xuICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNWU0IHx8IHJkID09IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAocm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDIpIC0gMSB8fCAocmQgPT0gayAvIDIgfHwgcmQgPT0gMCkgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaSA8IDQpIHtcbiAgICAgIGlmIChpID09IDApXG4gICAgICAgIHJkID0gcmQgLyAxZTMgfCAwO1xuICAgICAgZWxzZSBpZiAoaSA9PSAxKVxuICAgICAgICByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMilcbiAgICAgICAgcmQgPSByZCAvIDEwIHwgMDtcbiAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCArIDEgPT0gayB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmIChkW2RpICsgMV0gLyBrIC8gMWUzIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDMpIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5fX25hbWUoY2hlY2tSb3VuZGluZ0RpZ2l0cywgXCJjaGVja1JvdW5kaW5nRGlnaXRzXCIpO1xuZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcbiAgdmFyIGosIGFyciA9IFswXSwgYXJyTCwgaSA9IDAsIHN0ckwgPSBzdHIubGVuZ3RoO1xuICBmb3IgKDsgaSA8IHN0ckw7ICkge1xuICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgKVxuICAgICAgYXJyW2FyckxdICo9IGJhc2VJbjtcbiAgICBhcnJbMF0gKz0gTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xuICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xuICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGFycltqICsgMV0gPSAwO1xuICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xuICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG59XG5fX25hbWUoY29udmVydEJhc2UsIFwiY29udmVydEJhc2VcIik7XG5mdW5jdGlvbiBjb3NpbmUoQ3RvciwgeCkge1xuICB2YXIgaywgbGVuLCB5O1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4geDtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMyKSB7XG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcbiAgICB5ID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxNjtcbiAgICB5ID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gKz0gaztcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKHkpLCBuZXcgQ3RvcigxKSk7XG4gIGZvciAodmFyIGkgPSBrOyBpLS07ICkge1xuICAgIHZhciBjb3MyeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IGNvczJ4LnRpbWVzKGNvczJ4KS5taW51cyhjb3MyeCkudGltZXMoOCkucGx1cygxKTtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiAtPSBrO1xuICByZXR1cm4geDtcbn1cbl9fbmFtZShjb3NpbmUsIFwiY29zaW5lXCIpO1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBtdWx0aXBseUludGVnZXIoeCwgaywgYmFzZSkge1xuICAgIHZhciB0ZW1wLCBjYXJyeSA9IDAsIGkgPSB4Lmxlbmd0aDtcbiAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTsgKSB7XG4gICAgICB0ZW1wID0geFtpXSAqIGsgKyBjYXJyeTtcbiAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZSB8IDA7XG4gICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5KVxuICAgICAgeC51bnNoaWZ0KGNhcnJ5KTtcbiAgICByZXR1cm4geDtcbiAgfVxuICBfX25hbWUobXVsdGlwbHlJbnRlZ2VyLCBcIm11bHRpcGx5SW50ZWdlclwiKTtcbiAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcbiAgICB2YXIgaSwgcjtcbiAgICBpZiAoYUwgIT0gYkwpIHtcbiAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xuICAgICAgICAgIHIgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBfX25hbWUoY29tcGFyZSwgXCJjb21wYXJlXCIpO1xuICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgYUwtLTsgKSB7XG4gICAgICBhW2FMXSAtPSBpO1xuICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcbiAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xuICAgIH1cbiAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyApXG4gICAgICBhLnNoaWZ0KCk7XG4gIH1cbiAgX19uYW1lKHN1YnRyYWN0LCBcInN1YnRyYWN0XCIpO1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xuICAgIHZhciBjbXAsIGUsIGksIGssIGxvZ0Jhc2UsIG1vcmUsIHByb2QsIHByb2RMLCBxLCBxZCwgcmVtLCByZW1MLCByZW0wLCBzZCwgdCwgeGksIHhMLCB5ZDAsIHlMLCB5eiwgQ3RvciA9IHguY29uc3RydWN0b3IsIHNpZ24yID0geC5zID09IHkucyA/IDEgOiAtMSwgeGQgPSB4LmQsIHlkID0geS5kO1xuICAgIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcbiAgICAgIHJldHVybiBuZXcgQ3RvcihcbiAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4ZCA/IHlkICYmIHhkWzBdID09IHlkWzBdIDogIXlkKSA/IE5hTiA6IHhkICYmIHhkWzBdID09IDAgfHwgIXlkID8gc2lnbjIgKiAwIDogc2lnbjIgLyAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYmFzZSkge1xuICAgICAgbG9nQmFzZSA9IDE7XG4gICAgICBlID0geC5lIC0geS5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gQkFTRTtcbiAgICAgIGxvZ0Jhc2UgPSBMT0dfQkFTRTtcbiAgICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gbG9nQmFzZSkgLSBtYXRoZmxvb3IoeS5lIC8gbG9nQmFzZSk7XG4gICAgfVxuICAgIHlMID0geWQubGVuZ3RoO1xuICAgIHhMID0geGQubGVuZ3RoO1xuICAgIHEgPSBuZXcgQ3RvcihzaWduMik7XG4gICAgcWQgPSBxLmQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyB5ZFtpXSA9PSAoeGRbaV0gfHwgMCk7IGkrKylcbiAgICAgIDtcbiAgICBpZiAoeWRbaV0gPiAoeGRbaV0gfHwgMCkpXG4gICAgICBlLS07XG4gICAgaWYgKHByID09IG51bGwpIHtcbiAgICAgIHNkID0gcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICB9IGVsc2UgaWYgKGRwKSB7XG4gICAgICBzZCA9IHByICsgKHguZSAtIHkuZSkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZCA9IHByO1xuICAgIH1cbiAgICBpZiAoc2QgPCAwKSB7XG4gICAgICBxZC5wdXNoKDEpO1xuICAgICAgbW9yZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XG4gICAgICBpID0gMDtcbiAgICAgIGlmICh5TCA9PSAxKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICB5ZCA9IHlkWzBdO1xuICAgICAgICBzZCsrO1xuICAgICAgICBmb3IgKDsgKGkgPCB4TCB8fCBrKSAmJiBzZC0tOyBpKyspIHtcbiAgICAgICAgICB0ID0gayAqIGJhc2UgKyAoeGRbaV0gfHwgMCk7XG4gICAgICAgICAgcWRbaV0gPSB0IC8geWQgfCAwO1xuICAgICAgICAgIGsgPSB0ICUgeWQgfCAwO1xuICAgICAgICB9XG4gICAgICAgIG1vcmUgPSBrIHx8IGkgPCB4TDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBiYXNlIC8gKHlkWzBdICsgMSkgfCAwO1xuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICB5ZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xuICAgICAgICAgIHlMID0geWQubGVuZ3RoO1xuICAgICAgICAgIHhMID0geGQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHhpID0geUw7XG4gICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7IClcbiAgICAgICAgICByZW1bcmVtTCsrXSA9IDA7XG4gICAgICAgIHl6ID0geWQuc2xpY2UoKTtcbiAgICAgICAgeXoudW5zaGlmdCgwKTtcbiAgICAgICAgeWQwID0geWRbMF07XG4gICAgICAgIGlmICh5ZFsxXSA+PSBiYXNlIC8gMilcbiAgICAgICAgICArK3lkMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWQsIHJlbSwgeUwsIHJlbUwpO1xuICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICByZW0wID0gcmVtWzBdO1xuICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpXG4gICAgICAgICAgICAgIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XG4gICAgICAgICAgICBrID0gcmVtMCAvIHlkMCB8IDA7XG4gICAgICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgICAgaWYgKGsgPj0gYmFzZSlcbiAgICAgICAgICAgICAgICBrID0gYmFzZSAtIDE7XG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKTtcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHlkLCBwcm9kTCwgYmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChrID09IDApXG4gICAgICAgICAgICAgICAgY21wID0gayA9IDE7XG4gICAgICAgICAgICAgIHByb2QgPSB5ZC5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpXG4gICAgICAgICAgICAgIHByb2QudW5zaGlmdCgwKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICAgICAgaWYgKGNtcCA8IDEpIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHlkLCByZW1MLCBiYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIHJlbSA9IFswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcWRbaSsrXSA9IGs7XG4gICAgICAgICAgaWYgKGNtcCAmJiByZW1bMF0pIHtcbiAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGRbeGldIHx8IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IFt4ZFt4aV1dO1xuICAgICAgICAgICAgcmVtTCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPT0gdm9pZCAwKSAmJiBzZC0tKTtcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPT0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKCFxZFswXSlcbiAgICAgICAgcWQuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGxvZ0Jhc2UgPT0gMSkge1xuICAgICAgcS5lID0gZTtcbiAgICAgIGluZXhhY3QgPSBtb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAxLCBrID0gcWRbMF07IGsgPj0gMTA7IGsgLz0gMTApXG4gICAgICAgIGkrKztcbiAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XG4gICAgICBmaW5hbGlzZShxLCBkcCA/IHByICsgcS5lICsgMSA6IHByLCBybSwgbW9yZSk7XG4gICAgfVxuICAgIHJldHVybiBxO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xuICB2YXIgZGlnaXRzLCBpLCBqLCBrLCByZCwgcm91bmRVcCwgdywgeGQsIHhkaSwgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIG91dDpcbiAgICBpZiAoc2QgIT0gbnVsbCkge1xuICAgICAgeGQgPSB4LmQ7XG4gICAgICBpZiAoIXhkKVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIGZvciAoZGlnaXRzID0gMSwgayA9IHhkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICBkaWdpdHMrKztcbiAgICAgIGkgPSBzZCAtIGRpZ2l0cztcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBpICs9IExPR19CQVNFO1xuICAgICAgICBqID0gc2Q7XG4gICAgICAgIHcgPSB4ZFt4ZGkgPSAwXTtcbiAgICAgICAgcmQgPSB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XG4gICAgICAgIGsgPSB4ZC5sZW5ndGg7XG4gICAgICAgIGlmICh4ZGkgPj0gaykge1xuICAgICAgICAgIGlmIChpc1RydW5jYXRlZCkge1xuICAgICAgICAgICAgZm9yICg7IGsrKyA8PSB4ZGk7IClcbiAgICAgICAgICAgICAgeGQucHVzaCgwKTtcbiAgICAgICAgICAgIHcgPSByZCA9IDA7XG4gICAgICAgICAgICBkaWdpdHMgPSAxO1xuICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBvdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgPSBrID0geGRbeGRpXTtcbiAgICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApXG4gICAgICAgICAgICBkaWdpdHMrKztcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkaWdpdHM7XG4gICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc1RydW5jYXRlZCA9IGlzVHJ1bmNhdGVkIHx8IHNkIDwgMCB8fCB4ZFt4ZGkgKyAxXSAhPT0gdm9pZCAwIHx8IChqIDwgMCA/IHcgOiB3ICUgbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpKTtcbiAgICAgIHJvdW5kVXAgPSBybSA8IDQgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKSA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IGlzVHJ1bmNhdGVkIHx8IHJtID09IDYgJiYgKGkgPiAwID8gaiA+IDAgPyB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgOiAwIDogeGRbeGRpIC0gMV0pICUgMTAgJiAxIHx8IHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgIGlmIChzZCA8IDEgfHwgIXhkWzBdKSB7XG4gICAgICAgIHhkLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgICAgc2QgLT0geC5lICsgMTtcbiAgICAgICAgICB4ZFswXSA9IG1hdGhwb3coMTAsIChMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0UpO1xuICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhkWzBdID0geC5lID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgeGQubGVuZ3RoID0geGRpO1xuICAgICAgICBrID0gMTtcbiAgICAgICAgeGRpLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xuICAgICAgICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcbiAgICAgICAgeGRbeGRpXSA9IGogPiAwID8gKHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSAlIG1hdGhwb3coMTAsIGopIHwgMCkgKiBrIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgIGlmICh4ZGkgPT0gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhkWzBdOyBqID49IDEwOyBqIC89IDEwKVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqID0geGRbMF0gKz0gaztcbiAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApXG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIGlmIChpICE9IGspIHtcbiAgICAgICAgICAgICAgeC5lKys7XG4gICAgICAgICAgICAgIGlmICh4ZFswXSA9PSBCQVNFKVxuICAgICAgICAgICAgICAgIHhkWzBdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ZFt4ZGldICs9IGs7XG4gICAgICAgICAgICBpZiAoeGRbeGRpXSAhPSBCQVNFKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHhkW3hkaS0tXSA9IDA7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IHhkLmxlbmd0aDsgeGRbLS1pXSA9PT0gMDsgKVxuICAgICAgICB4ZC5wb3AoKTtcbiAgICB9XG4gIGlmIChleHRlcm5hbCkge1xuICAgIGlmICh4LmUgPiBDdG9yLm1heEUpIHtcbiAgICAgIHguZCA9IG51bGw7XG4gICAgICB4LmUgPSBOYU47XG4gICAgfSBlbHNlIGlmICh4LmUgPCBDdG9yLm1pbkUpIHtcbiAgICAgIHguZSA9IDA7XG4gICAgICB4LmQgPSBbMF07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKGZpbmFsaXNlLCBcImZpbmFsaXNlXCIpO1xuZnVuY3Rpb24gZmluaXRlVG9TdHJpbmcoeCwgaXNFeHAsIHNkKSB7XG4gIGlmICgheC5pc0Zpbml0ZSgpKVxuICAgIHJldHVybiBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgdmFyIGssIGUgPSB4LmUsIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGlmIChpc0V4cCkge1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKSArIGdldFplcm9TdHJpbmcoayk7XG4gICAgfSBlbHNlIGlmIChsZW4gPiAxKSB7XG4gICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHN0ciA9IHN0ciArICh4LmUgPCAwID8gXCJlXCIgOiBcImUrXCIpICsgeC5lO1xuICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgc3RyID0gXCIwLlwiICsgZ2V0WmVyb1N0cmluZygtZSAtIDEpICsgc3RyO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApXG4gICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgfSBlbHNlIGlmIChlID49IGxlbikge1xuICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGUgKyAxIC0gbGVuKTtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGUgLSAxKSA+IDApXG4gICAgICBzdHIgPSBzdHIgKyBcIi5cIiArIGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKChrID0gZSArIDEpIDwgbGVuKVxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGspICsgXCIuXCIgKyBzdHIuc2xpY2Uoayk7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xuICAgICAgaWYgKGUgKyAxID09PSBsZW4pXG4gICAgICAgIHN0ciArPSBcIi5cIjtcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuX19uYW1lKGZpbml0ZVRvU3RyaW5nLCBcImZpbml0ZVRvU3RyaW5nXCIpO1xuZnVuY3Rpb24gZ2V0QmFzZTEwRXhwb25lbnQoZGlnaXRzLCBlKSB7XG4gIHZhciB3ID0gZGlnaXRzWzBdO1xuICBmb3IgKGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApXG4gICAgZSsrO1xuICByZXR1cm4gZTtcbn1cbl9fbmFtZShnZXRCYXNlMTBFeHBvbmVudCwgXCJnZXRCYXNlMTBFeHBvbmVudFwiKTtcbmZ1bmN0aW9uIGdldExuMTAoQ3Rvciwgc2QsIHByKSB7XG4gIGlmIChzZCA+IExOMTBfUFJFQ0lTSU9OKSB7XG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgIGlmIChwcilcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKExOMTApLCBzZCwgMSwgdHJ1ZSk7XG59XG5fX25hbWUoZ2V0TG4xMCwgXCJnZXRMbjEwXCIpO1xuZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XG4gIGlmIChzZCA+IFBJX1BSRUNJU0lPTilcbiAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcbn1cbl9fbmFtZShnZXRQaSwgXCJnZXRQaVwiKTtcbmZ1bmN0aW9uIGdldFByZWNpc2lvbihkaWdpdHMpIHtcbiAgdmFyIHcgPSBkaWdpdHMubGVuZ3RoIC0gMSwgbGVuID0gdyAqIExPR19CQVNFICsgMTtcbiAgdyA9IGRpZ2l0c1t3XTtcbiAgaWYgKHcpIHtcbiAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApXG4gICAgICBsZW4tLTtcbiAgICBmb3IgKHcgPSBkaWdpdHNbMF07IHcgPj0gMTA7IHcgLz0gMTApXG4gICAgICBsZW4rKztcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuX19uYW1lKGdldFByZWNpc2lvbiwgXCJnZXRQcmVjaXNpb25cIik7XG5mdW5jdGlvbiBnZXRaZXJvU3RyaW5nKGspIHtcbiAgdmFyIHpzID0gXCJcIjtcbiAgZm9yICg7IGstLTsgKVxuICAgIHpzICs9IFwiMFwiO1xuICByZXR1cm4genM7XG59XG5fX25hbWUoZ2V0WmVyb1N0cmluZywgXCJnZXRaZXJvU3RyaW5nXCIpO1xuZnVuY3Rpb24gaW50UG93KEN0b3IsIHgsIG4sIHByKSB7XG4gIHZhciBpc1RydW5jYXRlZCwgciA9IG5ldyBDdG9yKDEpLCBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UgKyA0KTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yICg7IDsgKSB7XG4gICAgaWYgKG4gJSAyKSB7XG4gICAgICByID0gci50aW1lcyh4KTtcbiAgICAgIGlmICh0cnVuY2F0ZShyLmQsIGspKVxuICAgICAgICBpc1RydW5jYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIG4gPSBtYXRoZmxvb3IobiAvIDIpO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBuID0gci5kLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaXNUcnVuY2F0ZWQgJiYgci5kW25dID09PSAwKVxuICAgICAgICArK3IuZFtuXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB4ID0geC50aW1lcyh4KTtcbiAgICB0cnVuY2F0ZSh4LmQsIGspO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHI7XG59XG5fX25hbWUoaW50UG93LCBcImludFBvd1wiKTtcbmZ1bmN0aW9uIGlzT2RkKG4pIHtcbiAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xufVxuX19uYW1lKGlzT2RkLCBcImlzT2RkXCIpO1xuZnVuY3Rpb24gbWF4T3JNaW4oQ3RvciwgYXJncywgbHRndCkge1xuICB2YXIgeSwgeCA9IG5ldyBDdG9yKGFyZ3NbMF0pLCBpID0gMDtcbiAgZm9yICg7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcbiAgICB5ID0gbmV3IEN0b3IoYXJnc1tpXSk7XG4gICAgaWYgKCF5LnMpIHtcbiAgICAgIHggPSB5O1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh4W2x0Z3RdKHkpKSB7XG4gICAgICB4ID0geTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5fX25hbWUobWF4T3JNaW4sIFwibWF4T3JNaW5cIik7XG5mdW5jdGlvbiBuYXR1cmFsRXhwb25lbnRpYWwoeCwgc2QpIHtcbiAgdmFyIGRlbm9taW5hdG9yLCBndWFyZCwgaiwgcG93Miwgc3VtMywgdCwgd3ByLCByZXAgPSAwLCBpID0gMCwgayA9IDAsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBybSA9IEN0b3Iucm91bmRpbmcsIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIGlmICgheC5kIHx8ICF4LmRbMF0gfHwgeC5lID4gMTcpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5kID8gIXguZFswXSA/IDEgOiB4LnMgPCAwID8gMCA6IDEgLyAwIDogeC5zID8geC5zIDwgMCA/IDAgOiB4IDogMCAvIDApO1xuICB9XG4gIGlmIChzZCA9PSBudWxsKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB3cHIgPSBwcjtcbiAgfSBlbHNlIHtcbiAgICB3cHIgPSBzZDtcbiAgfVxuICB0ID0gbmV3IEN0b3IoMC4wMzEyNSk7XG4gIHdoaWxlICh4LmUgPiAtMikge1xuICAgIHggPSB4LnRpbWVzKHQpO1xuICAgIGsgKz0gNTtcbiAgfVxuICBndWFyZCA9IE1hdGgubG9nKG1hdGhwb3coMiwgaykpIC8gTWF0aC5MTjEwICogMiArIDUgfCAwO1xuICB3cHIgKz0gZ3VhcmQ7XG4gIGRlbm9taW5hdG9yID0gcG93MiA9IHN1bTMgPSBuZXcgQ3RvcigxKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XG4gIGZvciAoOyA7ICkge1xuICAgIHBvdzIgPSBmaW5hbGlzZShwb3cyLnRpbWVzKHgpLCB3cHIsIDEpO1xuICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcbiAgICB0ID0gc3VtMy5wbHVzKGRpdmlkZShwb3cyLCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtMy5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICBqID0gaztcbiAgICAgIHdoaWxlIChqLS0pXG4gICAgICAgIHN1bTMgPSBmaW5hbGlzZShzdW0zLnRpbWVzKHN1bTMpLCB3cHIsIDEpO1xuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcCA8IDMgJiYgY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0zLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IDEwO1xuICAgICAgICAgIGRlbm9taW5hdG9yID0gcG93MiA9IHQgPSBuZXcgQ3RvcigxKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICByZXArKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtMywgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICAgIHJldHVybiBzdW0zO1xuICAgICAgfVxuICAgIH1cbiAgICBzdW0zID0gdDtcbiAgfVxufVxuX19uYW1lKG5hdHVyYWxFeHBvbmVudGlhbCwgXCJuYXR1cmFsRXhwb25lbnRpYWxcIik7XG5mdW5jdGlvbiBuYXR1cmFsTG9nYXJpdGhtKHksIHNkKSB7XG4gIHZhciBjLCBjMCwgZGVub21pbmF0b3IsIGUsIG51bWVyYXRvciwgcmVwLCBzdW0zLCB0LCB3cHIsIHgxLCB4MiwgbiA9IDEsIGd1YXJkID0gMTAsIHggPSB5LCB4ZCA9IHguZCwgQ3RvciA9IHguY29uc3RydWN0b3IsIHJtID0gQ3Rvci5yb3VuZGluZywgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgaWYgKHgucyA8IDAgfHwgIXhkIHx8ICF4ZFswXSB8fCAheC5lICYmIHhkWzBdID09IDEgJiYgeGQubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoeGQgJiYgIXhkWzBdID8gLTEgLyAwIDogeC5zICE9IDEgPyBOYU4gOiB4ZCA/IDAgOiB4KTtcbiAgfVxuICBpZiAoc2QgPT0gbnVsbCkge1xuICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgd3ByID0gcHI7XG4gIH0gZWxzZSB7XG4gICAgd3ByID0gc2Q7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XG4gIGMgPSBkaWdpdHNUb1N0cmluZyh4ZCk7XG4gIGMwID0gYy5jaGFyQXQoMCk7XG4gIGlmIChNYXRoLmFicyhlID0geC5lKSA8IDE1ZTE0KSB7XG4gICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XG4gICAgICB4ID0geC50aW1lcyh5KTtcbiAgICAgIGMgPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xuICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcbiAgICAgIG4rKztcbiAgICB9XG4gICAgZSA9IHguZTtcbiAgICBpZiAoYzAgPiAxKSB7XG4gICAgICB4ID0gbmV3IEN0b3IoXCIwLlwiICsgYyk7XG4gICAgICBlKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBuZXcgQ3RvcihjMCArIFwiLlwiICsgYy5zbGljZSgxKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHQgPSBnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgXCJcIik7XG4gICAgeCA9IG5hdHVyYWxMb2dhcml0aG0obmV3IEN0b3IoYzAgKyBcIi5cIiArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgIHJldHVybiBzZCA9PSBudWxsID8gZmluYWxpc2UoeCwgcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpIDogeDtcbiAgfVxuICB4MSA9IHg7XG4gIHN1bTMgPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcbiAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xuICBkZW5vbWluYXRvciA9IDM7XG4gIGZvciAoOyA7ICkge1xuICAgIG51bWVyYXRvciA9IGZpbmFsaXNlKG51bWVyYXRvci50aW1lcyh4MiksIHdwciwgMSk7XG4gICAgdCA9IHN1bTMucGx1cyhkaXZpZGUobnVtZXJhdG9yLCBuZXcgQ3RvcihkZW5vbWluYXRvciksIHdwciwgMSkpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bTMuZCkuc2xpY2UoMCwgd3ByKSkge1xuICAgICAgc3VtMyA9IHN1bTMudGltZXMoMik7XG4gICAgICBpZiAoZSAhPT0gMClcbiAgICAgICAgc3VtMyA9IHN1bTMucGx1cyhnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgXCJcIikpO1xuICAgICAgc3VtMyA9IGRpdmlkZShzdW0zLCBuZXcgQ3RvcihuKSwgd3ByLCAxKTtcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHN1bTMuZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XG4gICAgICAgICAgdCA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeDEubWludXMoMSksIHgxLnBsdXMoMSksIHdwciwgMSk7XG4gICAgICAgICAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xuICAgICAgICAgIGRlbm9taW5hdG9yID0gcmVwID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtMywgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICAgIHJldHVybiBzdW0zO1xuICAgICAgfVxuICAgIH1cbiAgICBzdW0zID0gdDtcbiAgICBkZW5vbWluYXRvciArPSAyO1xuICB9XG59XG5fX25hbWUobmF0dXJhbExvZ2FyaXRobSwgXCJuYXR1cmFsTG9nYXJpdGhtXCIpO1xuZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xuICByZXR1cm4gU3RyaW5nKHgucyAqIHgucyAvIDApO1xufVxuX19uYW1lKG5vbkZpbml0ZVRvU3RyaW5nLCBcIm5vbkZpbml0ZVRvU3RyaW5nXCIpO1xuZnVuY3Rpb24gcGFyc2VEZWNpbWFsKHgsIHN0cikge1xuICB2YXIgZSwgaSwgbGVuO1xuICBpZiAoKGUgPSBzdHIuaW5kZXhPZihcIi5cIikpID4gLTEpXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcbiAgICBpZiAoZSA8IDApXG4gICAgICBlID0gaTtcbiAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICBlID0gc3RyLmxlbmd0aDtcbiAgfVxuICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKylcbiAgICA7XG4gIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbilcbiAgICA7XG4gIHN0ciA9IHN0ci5zbGljZShpLCBsZW4pO1xuICBpZiAoc3RyKSB7XG4gICAgbGVuIC09IGk7XG4gICAgeC5lID0gZSA9IGUgLSBpIC0gMTtcbiAgICB4LmQgPSBbXTtcbiAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xuICAgIGlmIChlIDwgMClcbiAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChpKVxuICAgICAgICB4LmQucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcbiAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOyApXG4gICAgICAgIHguZC5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xuICAgICAgc3RyID0gc3RyLnNsaWNlKGkpO1xuICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaSAtPSBsZW47XG4gICAgfVxuICAgIGZvciAoOyBpLS07IClcbiAgICAgIHN0ciArPSBcIjBcIjtcbiAgICB4LmQucHVzaCgrc3RyKTtcbiAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgIGlmICh4LmUgPiB4LmNvbnN0cnVjdG9yLm1heEUpIHtcbiAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcbiAgICAgICAgeC5lID0gMDtcbiAgICAgICAgeC5kID0gWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB4LmUgPSAwO1xuICAgIHguZCA9IFswXTtcbiAgfVxuICByZXR1cm4geDtcbn1cbl9fbmFtZShwYXJzZURlY2ltYWwsIFwicGFyc2VEZWNpbWFsXCIpO1xuZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcbiAgdmFyIGJhc2UsIEN0b3IsIGRpdmlzb3IsIGksIGlzRmxvYXQsIGxlbiwgcCwgeGQsIHhlO1xuICBpZiAoc3RyLmluZGV4T2YoXCJfXCIpID4gLTEpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCBcIiQxXCIpO1xuICAgIGlmIChpc0RlY2ltYWwudGVzdChzdHIpKVxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCBzdHIpO1xuICB9IGVsc2UgaWYgKHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCJOYU5cIikge1xuICAgIGlmICghK3N0cilcbiAgICAgIHgucyA9IE5hTjtcbiAgICB4LmUgPSBOYU47XG4gICAgeC5kID0gbnVsbDtcbiAgICByZXR1cm4geDtcbiAgfVxuICBpZiAoaXNIZXgudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDE2O1xuICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkge1xuICAgIGJhc2UgPSAyO1xuICB9IGVsc2UgaWYgKGlzT2N0YWwudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcbiAgfVxuICBpID0gc3RyLnNlYXJjaCgvcC9pKTtcbiAgaWYgKGkgPiAwKSB7XG4gICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMiwgaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xuICB9XG4gIGkgPSBzdHIuaW5kZXhPZihcIi5cIik7XG4gIGlzRmxvYXQgPSBpID49IDA7XG4gIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNGbG9hdCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGkgPSBsZW4gLSBpO1xuICAgIGRpdmlzb3IgPSBpbnRQb3coQ3RvciwgbmV3IEN0b3IoYmFzZSksIGksIGkgKiAyKTtcbiAgfVxuICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XG4gIHhlID0geGQubGVuZ3RoIC0gMTtcbiAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpXG4gICAgeGQucG9wKCk7XG4gIGlmIChpIDwgMClcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5zICogMCk7XG4gIHguZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCB4ZSk7XG4gIHguZCA9IHhkO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBpZiAoaXNGbG9hdClcbiAgICB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xuICBpZiAocClcbiAgICB4ID0geC50aW1lcyhNYXRoLmFicyhwKSA8IDU0ID8gbWF0aHBvdygyLCBwKSA6IERlY2ltYWwucG93KDIsIHApKTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4geDtcbn1cbl9fbmFtZShwYXJzZU90aGVyLCBcInBhcnNlT3RoZXJcIik7XG5mdW5jdGlvbiBzaW5lKEN0b3IsIHgpIHtcbiAgdmFyIGssIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzKSB7XG4gICAgcmV0dXJuIHguaXNaZXJvKCkgPyB4IDogdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICB9XG4gIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcbiAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gIHggPSB4LnRpbWVzKDEgLyB0aW55UG93KDUsIGspKTtcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcbiAgdmFyIHNpbjJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gIGZvciAoOyBrLS07ICkge1xuICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW4yX3gudGltZXMoZDE2LnRpbWVzKHNpbjJfeCkubWludXMoZDIwKSkpKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbl9fbmFtZShzaW5lLCBcInNpbmVcIik7XG5mdW5jdGlvbiB0YXlsb3JTZXJpZXMoQ3RvciwgbiwgeCwgeSwgaXNIeXBlcmJvbGljKSB7XG4gIHZhciBqLCB0LCB1LCB4MiwgaSA9IDEsIHByID0gQ3Rvci5wcmVjaXNpb24sIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHgyID0geC50aW1lcyh4KTtcbiAgdSA9IG5ldyBDdG9yKHkpO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gZGl2aWRlKHUudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XG4gICAgeSA9IGRpdmlkZSh0LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xuICAgIHQgPSB1LnBsdXMoeSk7XG4gICAgaWYgKHQuZFtrXSAhPT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07IClcbiAgICAgICAgO1xuICAgICAgaWYgKGogPT0gLTEpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBqID0gdTtcbiAgICB1ID0geTtcbiAgICB5ID0gdDtcbiAgICB0ID0gajtcbiAgICBpKys7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICB0LmQubGVuZ3RoID0gayArIDE7XG4gIHJldHVybiB0O1xufVxuX19uYW1lKHRheWxvclNlcmllcywgXCJ0YXlsb3JTZXJpZXNcIik7XG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcbiAgdmFyIG4gPSBiO1xuICB3aGlsZSAoLS1lKVxuICAgIG4gKj0gYjtcbiAgcmV0dXJuIG47XG59XG5fX25hbWUodGlueVBvdywgXCJ0aW55UG93XCIpO1xuZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XG4gIHZhciB0LCBpc05lZyA9IHgucyA8IDAsIHBpID0gZ2V0UGkoQ3RvciwgQ3Rvci5wcmVjaXNpb24sIDEpLCBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xuICB4ID0geC5hYnMoKTtcbiAgaWYgKHgubHRlKGhhbGZQaSkpIHtcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gNCA6IDE7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdCA9IHguZGl2VG9JbnQocGkpO1xuICBpZiAodC5pc1plcm8oKSkge1xuICAgIHF1YWRyYW50ID0gaXNOZWcgPyAzIDogMjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geC5taW51cyh0LnRpbWVzKHBpKSk7XG4gICAgaWYgKHgubHRlKGhhbGZQaSkpIHtcbiAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDIgOiAzIDogaXNOZWcgPyA0IDogMTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBxdWFkcmFudCA9IGlzT2RkKHQpID8gaXNOZWcgPyAxIDogNCA6IGlzTmVnID8gMyA6IDI7XG4gIH1cbiAgcmV0dXJuIHgubWludXMocGkpLmFicygpO1xufVxuX19uYW1lKHRvTGVzc1RoYW5IYWxmUGksIFwidG9MZXNzVGhhbkhhbGZQaVwiKTtcbmZ1bmN0aW9uIHRvU3RyaW5nQmluYXJ5KHgsIGJhc2VPdXQsIHNkLCBybSkge1xuICB2YXIgYmFzZSwgZSwgaSwgaywgbGVuLCByb3VuZFVwLCBzdHIsIHhkLCB5LCBDdG9yID0geC5jb25zdHJ1Y3RvciwgaXNFeHAgPSBzZCAhPT0gdm9pZCAwO1xuICBpZiAoaXNFeHApIHtcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgfSBlbHNlIHtcbiAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgfVxuICBpZiAoIXguaXNGaW5pdGUoKSkge1xuICAgIHN0ciA9IG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xuICAgIGkgPSBzdHIuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGlzRXhwKSB7XG4gICAgICBiYXNlID0gMjtcbiAgICAgIGlmIChiYXNlT3V0ID09IDE2KSB7XG4gICAgICAgIHNkID0gc2QgKiA0IC0gMztcbiAgICAgIH0gZWxzZSBpZiAoYmFzZU91dCA9PSA4KSB7XG4gICAgICAgIHNkID0gc2QgKiAzIC0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9IGJhc2VPdXQ7XG4gICAgfVxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICAgIHkgPSBuZXcgQ3RvcigxKTtcbiAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xuICAgICAgeS5kID0gY29udmVydEJhc2UoZmluaXRlVG9TdHJpbmcoeSksIDEwLCBiYXNlKTtcbiAgICAgIHkuZSA9IHkuZC5sZW5ndGg7XG4gICAgfVxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCAxMCwgYmFzZSk7XG4gICAgZSA9IGxlbiA9IHhkLmxlbmd0aDtcbiAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7IClcbiAgICAgIHhkLnBvcCgpO1xuICAgIGlmICgheGRbMF0pIHtcbiAgICAgIHN0ciA9IGlzRXhwID8gXCIwcCswXCIgOiBcIjBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIGUtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBuZXcgQ3Rvcih4KTtcbiAgICAgICAgeC5kID0geGQ7XG4gICAgICAgIHguZSA9IGU7XG4gICAgICAgIHggPSBkaXZpZGUoeCwgeSwgc2QsIHJtLCAwLCBiYXNlKTtcbiAgICAgICAgeGQgPSB4LmQ7XG4gICAgICAgIGUgPSB4LmU7XG4gICAgICAgIHJvdW5kVXAgPSBpbmV4YWN0O1xuICAgICAgfVxuICAgICAgaSA9IHhkW3NkXTtcbiAgICAgIGsgPSBiYXNlIC8gMjtcbiAgICAgIHJvdW5kVXAgPSByb3VuZFVwIHx8IHhkW3NkICsgMV0gIT09IHZvaWQgMDtcbiAgICAgIHJvdW5kVXAgPSBybSA8IDQgPyAoaSAhPT0gdm9pZCAwIHx8IHJvdW5kVXApICYmIChybSA9PT0gMCB8fCBybSA9PT0gKHgucyA8IDAgPyAzIDogMikpIDogaSA+IGsgfHwgaSA9PT0gayAmJiAocm0gPT09IDQgfHwgcm91bmRVcCB8fCBybSA9PT0gNiAmJiB4ZFtzZCAtIDFdICYgMSB8fCBybSA9PT0gKHgucyA8IDAgPyA4IDogNykpO1xuICAgICAgeGQubGVuZ3RoID0gc2Q7XG4gICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICBmb3IgKDsgKyt4ZFstLXNkXSA+IGJhc2UgLSAxOyApIHtcbiAgICAgICAgICB4ZFtzZF0gPSAwO1xuICAgICAgICAgIGlmICghc2QpIHtcbiAgICAgICAgICAgICsrZTtcbiAgICAgICAgICAgIHhkLnVuc2hpZnQoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbilcbiAgICAgICAgO1xuICAgICAgZm9yIChpID0gMCwgc3RyID0gXCJcIjsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcbiAgICAgIGlmIChpc0V4cCkge1xuICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgIGlmIChiYXNlT3V0ID09IDE2IHx8IGJhc2VPdXQgPT0gOCkge1xuICAgICAgICAgICAgaSA9IGJhc2VPdXQgPT0gMTYgPyA0IDogMztcbiAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKVxuICAgICAgICAgICAgICBzdHIgKz0gXCIwXCI7XG4gICAgICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgYmFzZU91dCk7XG4gICAgICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbilcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgZm9yIChpID0gMSwgc3RyID0gXCIxLlwiOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgIHN0ciArPSBOVU1FUkFMUy5jaGFyQXQoeGRbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHN0ciArIChlIDwgMCA/IFwicFwiIDogXCJwK1wiKSArIGU7XG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgICAgIGZvciAoOyArK2U7IClcbiAgICAgICAgICBzdHIgPSBcIjBcIiArIHN0cjtcbiAgICAgICAgc3RyID0gXCIwLlwiICsgc3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCsrZSA+IGxlbilcbiAgICAgICAgICBmb3IgKGUgLT0gbGVuOyBlLS07IClcbiAgICAgICAgICAgIHN0ciArPSBcIjBcIjtcbiAgICAgICAgZWxzZSBpZiAoZSA8IGxlbilcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyBcIi5cIiArIHN0ci5zbGljZShlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gKGJhc2VPdXQgPT0gMTYgPyBcIjB4XCIgOiBiYXNlT3V0ID09IDIgPyBcIjBiXCIgOiBiYXNlT3V0ID09IDggPyBcIjBvXCIgOiBcIlwiKSArIHN0cjtcbiAgfVxuICByZXR1cm4geC5zIDwgMCA/IFwiLVwiICsgc3RyIDogc3RyO1xufVxuX19uYW1lKHRvU3RyaW5nQmluYXJ5LCBcInRvU3RyaW5nQmluYXJ5XCIpO1xuZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcbiAgaWYgKGFyci5sZW5ndGggPiBsZW4pIHtcbiAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5fX25hbWUodHJ1bmNhdGUsIFwidHJ1bmNhdGVcIik7XG5mdW5jdGlvbiBhYnMoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWJzKCk7XG59XG5fX25hbWUoYWJzLCBcImFic1wiKTtcbmZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvcygpO1xufVxuX19uYW1lKGFjb3MsIFwiYWNvc1wiKTtcbmZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XG59XG5fX25hbWUoYWNvc2gsIFwiYWNvc2hcIik7XG5mdW5jdGlvbiBhZGQoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcbn1cbl9fbmFtZShhZGQsIFwiYWRkXCIpO1xuZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XG59XG5fX25hbWUoYXNpbiwgXCJhc2luXCIpO1xuZnVuY3Rpb24gYXNpbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcbn1cbl9fbmFtZShhc2luaCwgXCJhc2luaFwiKTtcbmZ1bmN0aW9uIGF0YW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbigpO1xufVxuX19uYW1lKGF0YW4sIFwiYXRhblwiKTtcbmZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW5oKCk7XG59XG5fX25hbWUoYXRhbmgsIFwiYXRhbmhcIik7XG5mdW5jdGlvbiBhdGFuMih5LCB4KSB7XG4gIHkgPSBuZXcgdGhpcyh5KTtcbiAgeCA9IG5ldyB0aGlzKHgpO1xuICB2YXIgciwgcHIgPSB0aGlzLnByZWNpc2lvbiwgcm0gPSB0aGlzLnJvdW5kaW5nLCB3cHIgPSBwciArIDQ7XG4gIGlmICgheS5zIHx8ICF4LnMpIHtcbiAgICByID0gbmV3IHRoaXMoTmFOKTtcbiAgfSBlbHNlIGlmICgheS5kICYmICF4LmQpIHtcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcbiAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoIXkuZCB8fCB4LmlzWmVybygpKSB7XG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoeC5zIDwgMCkge1xuICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xuICAgIHRoaXMucm91bmRpbmcgPSAxO1xuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XG4gICAgdGhpcy5yb3VuZGluZyA9IHJtO1xuICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcbiAgfSBlbHNlIHtcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbl9fbmFtZShhdGFuMiwgXCJhdGFuMlwiKTtcbmZ1bmN0aW9uIGNicnQoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY2JydCgpO1xufVxuX19uYW1lKGNicnQsIFwiY2JydFwiKTtcbmZ1bmN0aW9uIGNlaWwoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcbn1cbl9fbmFtZShjZWlsLCBcImNlaWxcIik7XG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4yLCBtYXgyKSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jbGFtcChtaW4yLCBtYXgyKTtcbn1cbl9fbmFtZShjbGFtcCwgXCJjbGFtcFwiKTtcbmZ1bmN0aW9uIGNvbmZpZyhvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBFcnJvcihkZWNpbWFsRXJyb3IgKyBcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgdmFyIGksIHAsIHYsIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLCBwcyA9IFtcbiAgICBcInByZWNpc2lvblwiLFxuICAgIDEsXG4gICAgTUFYX0RJR0lUUyxcbiAgICBcInJvdW5kaW5nXCIsXG4gICAgMCxcbiAgICA4LFxuICAgIFwidG9FeHBOZWdcIixcbiAgICAtRVhQX0xJTUlULFxuICAgIDAsXG4gICAgXCJ0b0V4cFBvc1wiLFxuICAgIDAsXG4gICAgRVhQX0xJTUlULFxuICAgIFwibWF4RVwiLFxuICAgIDAsXG4gICAgRVhQX0xJTUlULFxuICAgIFwibWluRVwiLFxuICAgIC1FWFBfTElNSVQsXG4gICAgMCxcbiAgICBcIm1vZHVsb1wiLFxuICAgIDAsXG4gICAgOVxuICBdO1xuICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBpZiAocCA9IHBzW2ldLCB1c2VEZWZhdWx0cylcbiAgICAgIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChtYXRoZmxvb3IodikgPT09IHYgJiYgdiA+PSBwc1tpICsgMV0gJiYgdiA8PSBwc1tpICsgMl0pXG4gICAgICAgIHRoaXNbcF0gPSB2O1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgXCI6IFwiICsgdik7XG4gICAgfVxuICB9XG4gIGlmIChwID0gXCJjcnlwdG9cIiwgdXNlRGVmYXVsdHMpXG4gICAgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xuICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZSB8fCB2ID09PSAwIHx8IHYgPT09IDEpIHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9IFwidW5kZWZpbmVkXCIgJiYgY3J5cHRvICYmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgICAgICB0aGlzW3BdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArIFwiOiBcIiArIHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbl9fbmFtZShjb25maWcsIFwiY29uZmlnXCIpO1xuZnVuY3Rpb24gY29zKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xufVxuX19uYW1lKGNvcywgXCJjb3NcIik7XG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcbn1cbl9fbmFtZShjb3NoLCBcImNvc2hcIik7XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgdmFyIGksIHAsIHBzO1xuICBmdW5jdGlvbiBEZWNpbWFsMih2KSB7XG4gICAgdmFyIGUsIGkyLCB0LCB4ID0gdGhpcztcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgRGVjaW1hbDIpKVxuICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMih2KTtcbiAgICB4LmNvbnN0cnVjdG9yID0gRGVjaW1hbDI7XG4gICAgaWYgKGlzRGVjaW1hbEluc3RhbmNlKHYpKSB7XG4gICAgICB4LnMgPSB2LnM7XG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgICAgaWYgKCF2LmQgfHwgdi5lID4gRGVjaW1hbDIubWF4RSkge1xuICAgICAgICAgIHguZSA9IE5hTjtcbiAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IERlY2ltYWwyLm1pbkUpIHtcbiAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4LmUgPSB2LmU7XG4gICAgICAgICAgeC5kID0gdi5kLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHguZSA9IHYuZTtcbiAgICAgICAgeC5kID0gdi5kID8gdi5kLnNsaWNlKCkgOiB2LmQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgPSB0eXBlb2YgdjtcbiAgICBpZiAodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gLTEgOiAxO1xuICAgICAgICB4LmUgPSAwO1xuICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gLXY7XG4gICAgICAgIHgucyA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC5zID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh2ID09PSB+fnYgJiYgdiA8IDFlNykge1xuICAgICAgICBmb3IgKGUgPSAwLCBpMiA9IHY7IGkyID49IDEwOyBpMiAvPSAxMClcbiAgICAgICAgICBlKys7XG4gICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgIGlmIChlID4gRGVjaW1hbDIubWF4RSkge1xuICAgICAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGUgPCBEZWNpbWFsMi5taW5FKSB7XG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgIHguZCA9IFt2XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHYgKiAwICE9PSAwKSB7XG4gICAgICAgIGlmICghdilcbiAgICAgICAgICB4LnMgPSBOYU47XG4gICAgICAgIHguZSA9IE5hTjtcbiAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCB2LnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XG4gICAgfVxuICAgIGlmICgoaTIgPSB2LmNoYXJDb2RlQXQoMCkpID09PSA0NSkge1xuICAgICAgdiA9IHYuc2xpY2UoMSk7XG4gICAgICB4LnMgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGkyID09PSA0MylcbiAgICAgICAgdiA9IHYuc2xpY2UoMSk7XG4gICAgICB4LnMgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWNpbWFsLnRlc3QodikgPyBwYXJzZURlY2ltYWwoeCwgdikgOiBwYXJzZU90aGVyKHgsIHYpO1xuICB9XG4gIF9fbmFtZShEZWNpbWFsMiwgXCJEZWNpbWFsXCIpO1xuICBEZWNpbWFsMi5wcm90b3R5cGUgPSBQO1xuICBEZWNpbWFsMi5ST1VORF9VUCA9IDA7XG4gIERlY2ltYWwyLlJPVU5EX0RPV04gPSAxO1xuICBEZWNpbWFsMi5ST1VORF9DRUlMID0gMjtcbiAgRGVjaW1hbDIuUk9VTkRfRkxPT1IgPSAzO1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX1VQID0gNDtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9ET1dOID0gNTtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9FVkVOID0gNjtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9DRUlMID0gNztcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XG4gIERlY2ltYWwyLkVVQ0xJRCA9IDk7XG4gIERlY2ltYWwyLmNvbmZpZyA9IERlY2ltYWwyLnNldCA9IGNvbmZpZztcbiAgRGVjaW1hbDIuY2xvbmUgPSBjbG9uZTtcbiAgRGVjaW1hbDIuaXNEZWNpbWFsID0gaXNEZWNpbWFsSW5zdGFuY2U7XG4gIERlY2ltYWwyLmFicyA9IGFicztcbiAgRGVjaW1hbDIuYWNvcyA9IGFjb3M7XG4gIERlY2ltYWwyLmFjb3NoID0gYWNvc2g7XG4gIERlY2ltYWwyLmFkZCA9IGFkZDtcbiAgRGVjaW1hbDIuYXNpbiA9IGFzaW47XG4gIERlY2ltYWwyLmFzaW5oID0gYXNpbmg7XG4gIERlY2ltYWwyLmF0YW4gPSBhdGFuO1xuICBEZWNpbWFsMi5hdGFuaCA9IGF0YW5oO1xuICBEZWNpbWFsMi5hdGFuMiA9IGF0YW4yO1xuICBEZWNpbWFsMi5jYnJ0ID0gY2JydDtcbiAgRGVjaW1hbDIuY2VpbCA9IGNlaWw7XG4gIERlY2ltYWwyLmNsYW1wID0gY2xhbXA7XG4gIERlY2ltYWwyLmNvcyA9IGNvcztcbiAgRGVjaW1hbDIuY29zaCA9IGNvc2g7XG4gIERlY2ltYWwyLmRpdiA9IGRpdjtcbiAgRGVjaW1hbDIuZXhwID0gZXhwO1xuICBEZWNpbWFsMi5mbG9vciA9IGZsb29yO1xuICBEZWNpbWFsMi5oeXBvdCA9IGh5cG90O1xuICBEZWNpbWFsMi5sbiA9IGxuO1xuICBEZWNpbWFsMi5sb2cgPSBsb2c7XG4gIERlY2ltYWwyLmxvZzEwID0gbG9nMTA7XG4gIERlY2ltYWwyLmxvZzIgPSBsb2cyO1xuICBEZWNpbWFsMi5tYXggPSBtYXg7XG4gIERlY2ltYWwyLm1pbiA9IG1pbjtcbiAgRGVjaW1hbDIubW9kID0gbW9kO1xuICBEZWNpbWFsMi5tdWwgPSBtdWw7XG4gIERlY2ltYWwyLnBvdyA9IHBvdztcbiAgRGVjaW1hbDIucmFuZG9tID0gcmFuZG9tO1xuICBEZWNpbWFsMi5yb3VuZCA9IHJvdW5kO1xuICBEZWNpbWFsMi5zaWduID0gc2lnbjtcbiAgRGVjaW1hbDIuc2luID0gc2luO1xuICBEZWNpbWFsMi5zaW5oID0gc2luaDtcbiAgRGVjaW1hbDIuc3FydCA9IHNxcnQ7XG4gIERlY2ltYWwyLnN1YiA9IHN1YjtcbiAgRGVjaW1hbDIuc3VtID0gc3VtO1xuICBEZWNpbWFsMi50YW4gPSB0YW47XG4gIERlY2ltYWwyLnRhbmggPSB0YW5oO1xuICBEZWNpbWFsMi50cnVuYyA9IHRydW5jO1xuICBpZiAob2JqID09PSB2b2lkIDApXG4gICAgb2JqID0ge307XG4gIGlmIChvYmopIHtcbiAgICBpZiAob2JqLmRlZmF1bHRzICE9PSB0cnVlKSB7XG4gICAgICBwcyA9IFtcInByZWNpc2lvblwiLCBcInJvdW5kaW5nXCIsIFwidG9FeHBOZWdcIiwgXCJ0b0V4cFBvc1wiLCBcIm1heEVcIiwgXCJtaW5FXCIsIFwibW9kdWxvXCIsIFwiY3J5cHRvXCJdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBzLmxlbmd0aDsgKVxuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwID0gcHNbaSsrXSkpXG4gICAgICAgICAgb2JqW3BdID0gdGhpc1twXTtcbiAgICB9XG4gIH1cbiAgRGVjaW1hbDIuY29uZmlnKG9iaik7XG4gIHJldHVybiBEZWNpbWFsMjtcbn1cbl9fbmFtZShjbG9uZSwgXCJjbG9uZVwiKTtcbmZ1bmN0aW9uIGRpdih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5kaXYoeSk7XG59XG5fX25hbWUoZGl2LCBcImRpdlwiKTtcbmZ1bmN0aW9uIGV4cCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcbn1cbl9fbmFtZShleHAsIFwiZXhwXCIpO1xuZnVuY3Rpb24gZmxvb3IoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAzKTtcbn1cbl9fbmFtZShmbG9vciwgXCJmbG9vclwiKTtcbmZ1bmN0aW9uIGh5cG90KCkge1xuICB2YXIgaSwgbiwgdCA9IG5ldyB0aGlzKDApO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgbiA9IG5ldyB0aGlzKGFyZ3VtZW50c1tpKytdKTtcbiAgICBpZiAoIW4uZCkge1xuICAgICAgaWYgKG4ucykge1xuICAgICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygxIC8gMCk7XG4gICAgICB9XG4gICAgICB0ID0gbjtcbiAgICB9IGVsc2UgaWYgKHQuZCkge1xuICAgICAgdCA9IHQucGx1cyhuLnRpbWVzKG4pKTtcbiAgICB9XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gdC5zcXJ0KCk7XG59XG5fX25hbWUoaHlwb3QsIFwiaHlwb3RcIik7XG5mdW5jdGlvbiBpc0RlY2ltYWxJbnN0YW5jZShvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERlY2ltYWwgfHwgb2JqICYmIG9iai50b1N0cmluZ1RhZyA9PT0gdGFnIHx8IGZhbHNlO1xufVxuX19uYW1lKGlzRGVjaW1hbEluc3RhbmNlLCBcImlzRGVjaW1hbEluc3RhbmNlXCIpO1xuZnVuY3Rpb24gbG4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG4oKTtcbn1cbl9fbmFtZShsbiwgXCJsblwiKTtcbmZ1bmN0aW9uIGxvZyh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coeSk7XG59XG5fX25hbWUobG9nLCBcImxvZ1wiKTtcbmZ1bmN0aW9uIGxvZzIoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDIpO1xufVxuX19uYW1lKGxvZzIsIFwibG9nMlwiKTtcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygxMCk7XG59XG5fX25hbWUobG9nMTAsIFwibG9nMTBcIik7XG5mdW5jdGlvbiBtYXgoKSB7XG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIFwibHRcIik7XG59XG5fX25hbWUobWF4LCBcIm1heFwiKTtcbmZ1bmN0aW9uIG1pbigpIHtcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgXCJndFwiKTtcbn1cbl9fbmFtZShtaW4sIFwibWluXCIpO1xuZnVuY3Rpb24gbW9kKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm1vZCh5KTtcbn1cbl9fbmFtZShtb2QsIFwibW9kXCIpO1xuZnVuY3Rpb24gbXVsKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm11bCh5KTtcbn1cbl9fbmFtZShtdWwsIFwibXVsXCIpO1xuZnVuY3Rpb24gcG93KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcbn1cbl9fbmFtZShwb3csIFwicG93XCIpO1xuZnVuY3Rpb24gcmFuZG9tKHNkKSB7XG4gIHZhciBkLCBlLCBrLCBuLCBpID0gMCwgciA9IG5ldyB0aGlzKDEpLCByZCA9IFtdO1xuICBpZiAoc2QgPT09IHZvaWQgMClcbiAgICBzZCA9IHRoaXMucHJlY2lzaW9uO1xuICBlbHNlXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gIGsgPSBNYXRoLmNlaWwoc2QgLyBMT0dfQkFTRSk7XG4gIGlmICghdGhpcy5jcnlwdG8pIHtcbiAgICBmb3IgKDsgaSA8IGs7IClcbiAgICAgIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcbiAgfSBlbHNlIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgZCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGspKTtcbiAgICBmb3IgKDsgaSA8IGs7ICkge1xuICAgICAgbiA9IGRbaV07XG4gICAgICBpZiAobiA+PSA0MjllNykge1xuICAgICAgICBkW2ldID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmRbaSsrXSA9IG4gJSAxZTc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xuICAgIGQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA0KTtcbiAgICBmb3IgKDsgaSA8IGs7ICkge1xuICAgICAgbiA9IGRbaV0gKyAoZFtpICsgMV0gPDwgOCkgKyAoZFtpICsgMl0gPDwgMTYpICsgKChkW2kgKyAzXSAmIDEyNykgPDwgMjQpO1xuICAgICAgaWYgKG4gPj0gMjE0ZTcpIHtcbiAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLmNvcHkoZCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZC5wdXNoKG4gJSAxZTcpO1xuICAgICAgICBpICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBrIC8gNDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XG4gIH1cbiAgayA9IHJkWy0taV07XG4gIHNkICU9IExPR19CQVNFO1xuICBpZiAoayAmJiBzZCkge1xuICAgIG4gPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIHNkKTtcbiAgICByZFtpXSA9IChrIC8gbiB8IDApICogbjtcbiAgfVxuICBmb3IgKDsgcmRbaV0gPT09IDA7IGktLSlcbiAgICByZC5wb3AoKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgZSA9IDA7XG4gICAgcmQgPSBbMF07XG4gIH0gZWxzZSB7XG4gICAgZSA9IC0xO1xuICAgIGZvciAoOyByZFswXSA9PT0gMDsgZSAtPSBMT0dfQkFTRSlcbiAgICAgIHJkLnNoaWZ0KCk7XG4gICAgZm9yIChrID0gMSwgbiA9IHJkWzBdOyBuID49IDEwOyBuIC89IDEwKVxuICAgICAgaysrO1xuICAgIGlmIChrIDwgTE9HX0JBU0UpXG4gICAgICBlIC09IExPR19CQVNFIC0gaztcbiAgfVxuICByLmUgPSBlO1xuICByLmQgPSByZDtcbiAgcmV0dXJuIHI7XG59XG5fX25hbWUocmFuZG9tLCBcInJhbmRvbVwiKTtcbmZ1bmN0aW9uIHJvdW5kKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgdGhpcy5yb3VuZGluZyk7XG59XG5fX25hbWUocm91bmQsIFwicm91bmRcIik7XG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgeCA9IG5ldyB0aGlzKHgpO1xuICByZXR1cm4geC5kID8geC5kWzBdID8geC5zIDogMCAqIHgucyA6IHgucyB8fCBOYU47XG59XG5fX25hbWUoc2lnbiwgXCJzaWduXCIpO1xuZnVuY3Rpb24gc2luKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbigpO1xufVxuX19uYW1lKHNpbiwgXCJzaW5cIik7XG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbmgoKTtcbn1cbl9fbmFtZShzaW5oLCBcInNpbmhcIik7XG5mdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcbn1cbl9fbmFtZShzcXJ0LCBcInNxcnRcIik7XG5mdW5jdGlvbiBzdWIoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc3ViKHkpO1xufVxuX19uYW1lKHN1YiwgXCJzdWJcIik7XG5mdW5jdGlvbiBzdW0oKSB7XG4gIHZhciBpID0gMCwgYXJncyA9IGFyZ3VtZW50cywgeCA9IG5ldyB0aGlzKGFyZ3NbaV0pO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBmb3IgKDsgeC5zICYmICsraSA8IGFyZ3MubGVuZ3RoOyApXG4gICAgeCA9IHgucGx1cyhhcmdzW2ldKTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UoeCwgdGhpcy5wcmVjaXNpb24sIHRoaXMucm91bmRpbmcpO1xufVxuX19uYW1lKHN1bSwgXCJzdW1cIik7XG5mdW5jdGlvbiB0YW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkudGFuKCk7XG59XG5fX25hbWUodGFuLCBcInRhblwiKTtcbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkudGFuaCgpO1xufVxuX19uYW1lKHRhbmgsIFwidGFuaFwiKTtcbmZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMSk7XG59XG5fX25hbWUodHJ1bmMsIFwidHJ1bmNcIik7XG5QW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0gPSBQLnRvU3RyaW5nO1xuUFtTeW1ib2wudG9TdHJpbmdUYWddID0gXCJEZWNpbWFsXCI7XG52YXIgRGVjaW1hbCA9IFAuY29uc3RydWN0b3IgPSBjbG9uZShERUZBVUxUUyk7XG5MTjEwID0gbmV3IERlY2ltYWwoTE4xMCk7XG5QSSA9IG5ldyBEZWNpbWFsKFBJKTtcbnZhciBkZWNpbWFsX2RlZmF1bHQgPSBEZWNpbWFsO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9jb21tb24udHNcbnZhciBpbXBvcnRfaW5kZW50X3N0cmluZyA9IF9fdG9FU00ocmVxdWlyZV9pbmRlbnRfc3RyaW5nKCkpO1xudmFyIGltcG9ydF9qc19sZXZlbnNodGVpbiA9IF9fdG9FU00ocmVxdWlyZV9qc19sZXZlbnNodGVpbigpKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9GaWVsZFJlZi50c1xudmFyIEZpZWxkUmVmSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxOYW1lLCBuYW1lLCBmaWVsZFR5cGUsIGlzTGlzdCkge1xuICAgIHRoaXMubW9kZWxOYW1lID0gbW9kZWxOYW1lO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlTmFtZSA9IGZpZWxkVHlwZTtcbiAgICB0aGlzLmlzTGlzdCA9IGlzTGlzdDtcbiAgfVxuICBfdG9HcmFwaFFMSW5wdXRUeXBlKCkge1xuICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuaXNMaXN0ID8gYExpc3Qke3RoaXMudHlwZU5hbWV9YCA6IHRoaXMudHlwZU5hbWU7XG4gICAgcmV0dXJuIGAke3ByZWZpeH1GaWVsZFJlZklucHV0PCR7dGhpcy5tb2RlbE5hbWV9PmA7XG4gIH1cbn07XG5fX25hbWUoRmllbGRSZWZJbXBsLCBcIkZpZWxkUmVmSW1wbFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvb2JqZWN0LWVudW1zLnRzXG52YXIgb2JqZWN0RW51bU5hbWVzID0gW1wiSnNvbk51bGxWYWx1ZUlucHV0XCIsIFwiTnVsbGFibGVKc29uTnVsbFZhbHVlSW5wdXRcIiwgXCJKc29uTnVsbFZhbHVlRmlsdGVyXCJdO1xudmFyIHNlY3JldCA9IFN5bWJvbCgpO1xudmFyIHJlcHJlc2VudGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIE9iamVjdEVudW1WYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJnMikge1xuICAgIGlmIChhcmcyID09PSBzZWNyZXQpIHtcbiAgICAgIHJlcHJlc2VudGF0aW9ucy5zZXQodGhpcywgYFByaXNtYS4ke3RoaXMuX2dldE5hbWUoKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwcmVzZW50YXRpb25zLnNldCh0aGlzLCBgbmV3IFByaXNtYS4ke3RoaXMuX2dldE5hbWVzcGFjZSgpfS4ke3RoaXMuX2dldE5hbWUoKX0oKWApO1xuICAgIH1cbiAgfVxuICBfZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiByZXByZXNlbnRhdGlvbnMuZ2V0KHRoaXMpO1xuICB9XG59O1xuX19uYW1lKE9iamVjdEVudW1WYWx1ZSwgXCJPYmplY3RFbnVtVmFsdWVcIik7XG52YXIgTnVsbFR5cGVzRW51bVZhbHVlID0gY2xhc3MgZXh0ZW5kcyBPYmplY3RFbnVtVmFsdWUge1xuICBfZ2V0TmFtZXNwYWNlKCkge1xuICAgIHJldHVybiBcIk51bGxUeXBlc1wiO1xuICB9XG59O1xuX19uYW1lKE51bGxUeXBlc0VudW1WYWx1ZSwgXCJOdWxsVHlwZXNFbnVtVmFsdWVcIik7XG52YXIgRGJOdWxsID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xufTtcbl9fbmFtZShEYk51bGwsIFwiRGJOdWxsXCIpO1xudmFyIEpzb25OdWxsID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xufTtcbl9fbmFtZShKc29uTnVsbCwgXCJKc29uTnVsbFwiKTtcbnZhciBBbnlOdWxsID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xufTtcbl9fbmFtZShBbnlOdWxsLCBcIkFueU51bGxcIik7XG52YXIgb2JqZWN0RW51bVZhbHVlcyA9IHtcbiAgY2xhc3Nlczoge1xuICAgIERiTnVsbCxcbiAgICBKc29uTnVsbCxcbiAgICBBbnlOdWxsXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIERiTnVsbDogbmV3IERiTnVsbChzZWNyZXQpLFxuICAgIEpzb25OdWxsOiBuZXcgSnNvbk51bGwoc2VjcmV0KSxcbiAgICBBbnlOdWxsOiBuZXcgQW55TnVsbChzZWNyZXQpXG4gIH1cbn07XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2RlY2ltYWxKc0xpa2UudHNcbmZ1bmN0aW9uIGlzRGVjaW1hbEpzTGlrZSh2YWx1ZSkge1xuICBpZiAoRGVjaW1hbC5pc0RlY2ltYWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUucyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsdWUuZSA9PT0gXCJudW1iZXJcIiAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmQpO1xufVxuX19uYW1lKGlzRGVjaW1hbEpzTGlrZSwgXCJpc0RlY2ltYWxKc0xpa2VcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlEZWNpbWFsSnNMaWtlKHZhbHVlKSB7XG4gIGlmIChEZWNpbWFsLmlzRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxuICBjb25zdCB0bXBEZWNpbWFsID0gbmV3IERlY2ltYWwoMCk7XG4gIHRtcERlY2ltYWwuZCA9IHZhbHVlLmQ7XG4gIHRtcERlY2ltYWwuZSA9IHZhbHVlLmU7XG4gIHRtcERlY2ltYWwucyA9IHZhbHVlLnM7XG4gIHJldHVybiBTdHJpbmcodG1wRGVjaW1hbCk7XG59XG5fX25hbWUoc3RyaW5naWZ5RGVjaW1hbEpzTGlrZSwgXCJzdHJpbmdpZnlEZWNpbWFsSnNMaWtlXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9jb21tb24udHNcbnZhciBrZXlCeSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGNvbGxlY3Rpb24sIHByb3ApID0+IHtcbiAgY29uc3QgYWNjID0ge307XG4gIGZvciAoY29uc3Qgb2JqIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBjb25zdCBrZXkgPSBvYmpbcHJvcF07XG4gICAgYWNjW2tleV0gPSBvYmo7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn0sIFwia2V5QnlcIik7XG52YXIgU2NhbGFyVHlwZVRhYmxlID0ge1xuICBTdHJpbmc6IHRydWUsXG4gIEludDogdHJ1ZSxcbiAgRmxvYXQ6IHRydWUsXG4gIEJvb2xlYW46IHRydWUsXG4gIExvbmc6IHRydWUsXG4gIERhdGVUaW1lOiB0cnVlLFxuICBJRDogdHJ1ZSxcbiAgVVVJRDogdHJ1ZSxcbiAgSnNvbjogdHJ1ZSxcbiAgQnl0ZXM6IHRydWUsXG4gIERlY2ltYWw6IHRydWUsXG4gIEJpZ0ludDogdHJ1ZVxufTtcbnZhciBKU1R5cGVUb0dyYXBoUUxUeXBlID0ge1xuICBzdHJpbmc6IFwiU3RyaW5nXCIsXG4gIGJvb2xlYW46IFwiQm9vbGVhblwiLFxuICBvYmplY3Q6IFwiSnNvblwiLFxuICBzeW1ib2w6IFwiU3ltYm9sXCJcbn07XG5mdW5jdGlvbiBzdHJpbmdpZnlHcmFwaFFMVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHJldHVybiB0eXBlLm5hbWU7XG59XG5fX25hbWUoc3RyaW5naWZ5R3JhcGhRTFR5cGUsIFwic3RyaW5naWZ5R3JhcGhRTFR5cGVcIik7XG5mdW5jdGlvbiB3cmFwV2l0aExpc3Qoc3RyLCBpc0xpc3QpIHtcbiAgaWYgKGlzTGlzdCkge1xuICAgIHJldHVybiBgTGlzdDwke3N0cn0+YDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuX19uYW1lKHdyYXBXaXRoTGlzdCwgXCJ3cmFwV2l0aExpc3RcIik7XG52YXIgUkZDXzMzMzlfUkVHRVggPSAvXihcXGR7NH0tKDBbMS05XXwxWzAxMl0pLSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVQoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pOihbMC01XVswLTldfDYwKSkoXFwuXFxkezEsfSk/KChbWl0pfChbK3wtXShbMDFdWzAtOV18MlswLTNdKTpbMC01XVswLTldKSkkLztcbnZhciBVVUlEX1JFR0VYID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaTtcbmZ1bmN0aW9uIGdldEdyYXBoUUxUeXBlKHZhbHVlLCBpbnB1dFR5cGUpIHtcbiAgY29uc3QgcG90ZW50aWFsVHlwZSA9IGlucHV0VHlwZSA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUeXBlLnR5cGU7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEJpZ0ludF1cIikge1xuICAgIHJldHVybiBcIkJpZ0ludFwiO1xuICB9XG4gIGlmIChkZWNpbWFsX2RlZmF1bHQuaXNEZWNpbWFsKHZhbHVlKSkge1xuICAgIHJldHVybiBcIkRlY2ltYWxcIjtcbiAgfVxuICBpZiAocG90ZW50aWFsVHlwZSA9PT0gXCJEZWNpbWFsXCIgJiYgaXNEZWNpbWFsSnNMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBcIkRlY2ltYWxcIjtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBcIkJ5dGVzXCI7XG4gIH1cbiAgaWYgKGlzVmFsaWRFbnVtVmFsdWUodmFsdWUsIGlucHV0VHlwZSkpIHtcbiAgICByZXR1cm4gcG90ZW50aWFsVHlwZS5uYW1lO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdEVudW1WYWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5fZ2V0TmFtZSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpZWxkUmVmSW1wbCkge1xuICAgIHJldHVybiB2YWx1ZS5fdG9HcmFwaFFMSW5wdXRUeXBlKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgbGV0IHNjYWxhclR5cGVzID0gdmFsdWUucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IGdldEdyYXBoUUxUeXBlKHZhbCwgaW5wdXRUeXBlKTtcbiAgICAgIGlmICghYWNjLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGFjYy5wdXNoKHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgaWYgKHNjYWxhclR5cGVzLmluY2x1ZGVzKFwiRmxvYXRcIikgJiYgc2NhbGFyVHlwZXMuaW5jbHVkZXMoXCJJbnRcIikpIHtcbiAgICAgIHNjYWxhclR5cGVzID0gW1wiRmxvYXRcIl07XG4gICAgfVxuICAgIHJldHVybiBgTGlzdDwke3NjYWxhclR5cGVzLmpvaW4oXCIgfCBcIil9PmA7XG4gIH1cbiAgY29uc3QganNUeXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAoanNUeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKE1hdGgudHJ1bmModmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiSW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIkZsb2F0XCI7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIikge1xuICAgIHJldHVybiBcIkRhdGVUaW1lXCI7XG4gIH1cbiAgaWYgKGpzVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChVVUlEX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJVVUlEXCI7XG4gICAgfVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGRhdGUudG9TdHJpbmcoKSA9PT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgcmV0dXJuIFwiU3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChSRkNfMzMzOV9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFwiRGF0ZVRpbWVcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEpTVHlwZVRvR3JhcGhRTFR5cGVbanNUeXBlXTtcbn1cbl9fbmFtZShnZXRHcmFwaFFMVHlwZSwgXCJnZXRHcmFwaFFMVHlwZVwiKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbnVtVmFsdWUodmFsdWUsIGlucHV0VHlwZSkge1xuICB2YXIgX2EzO1xuICBjb25zdCBlbnVtVHlwZSA9IGlucHV0VHlwZSA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUeXBlLnR5cGU7XG4gIGlmICghaXNTY2hlbWFFbnVtKGVudW1UeXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGlucHV0VHlwZSA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUeXBlLm5hbWVzcGFjZSkgPT09IFwicHJpc21hXCIgJiYgb2JqZWN0RW51bU5hbWVzLmluY2x1ZGVzKGVudW1UeXBlLm5hbWUpKSB7XG4gICAgY29uc3QgbmFtZSA9IChfYTMgPSB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubmFtZTtcbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgb2JqZWN0RW51bVZhbHVlcy5pbnN0YW5jZXNbbmFtZV0gPT09IHZhbHVlICYmIGVudW1UeXBlLnZhbHVlcy5pbmNsdWRlcyhuYW1lKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIGVudW1UeXBlLnZhbHVlcy5pbmNsdWRlcyh2YWx1ZSk7XG59XG5fX25hbWUoaXNWYWxpZEVudW1WYWx1ZSwgXCJpc1ZhbGlkRW51bVZhbHVlXCIpO1xuZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbihzdHIsIHBvc3NpYmlsaXRpZXMpIHtcbiAgY29uc3QgYmVzdE1hdGNoID0gcG9zc2liaWxpdGllcy5yZWR1Y2UoXG4gICAgKGFjYywgY3VycikgPT4ge1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSAoMCwgaW1wb3J0X2pzX2xldmVuc2h0ZWluLmRlZmF1bHQpKHN0ciwgY3Vycik7XG4gICAgICBpZiAoZGlzdGFuY2UgPCBhY2MuZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBzdHI6IGN1cnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7XG4gICAgICBkaXN0YW5jZTogTWF0aC5taW4oTWF0aC5mbG9vcihzdHIubGVuZ3RoKSAqIDEuMSwgLi4ucG9zc2liaWxpdGllcy5tYXAoKHApID0+IHAubGVuZ3RoICogMykpLFxuICAgICAgc3RyOiBudWxsXG4gICAgfVxuICApO1xuICByZXR1cm4gYmVzdE1hdGNoLnN0cjtcbn1cbl9fbmFtZShnZXRTdWdnZXN0aW9uLCBcImdldFN1Z2dlc3Rpb25cIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlJbnB1dFR5cGUoaW5wdXQsIGdyZWVuS2V5cyA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKGlucHV0LnZhbHVlcykge1xuICAgIHJldHVybiBgZW51bSAke2lucHV0Lm5hbWV9IHtcbiR7KDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nLmRlZmF1bHQpKGlucHV0LnZhbHVlcy5qb2luKFwiLCBcIiksIDIpfVxufWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYm9keSA9ICgwLCBpbXBvcnRfaW5kZW50X3N0cmluZy5kZWZhdWx0KShcbiAgICAgIGlucHV0LmZpZWxkcy5tYXAoKGFyZzIpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7YXJnMi5uYW1lfWA7XG4gICAgICAgIGNvbnN0IHN0ciA9IGAke2dyZWVuS2V5cyA/IGltcG9ydF9jaGFsay5kZWZhdWx0LmdyZWVuKGtleSkgOiBrZXl9JHthcmcyLmlzUmVxdWlyZWQgPyBcIlwiIDogXCI/XCJ9OiAke2ltcG9ydF9jaGFsay5kZWZhdWx0LndoaXRlKFxuICAgICAgICAgIGFyZzIuaW5wdXRUeXBlcy5tYXAoKGFyZ1R5cGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwV2l0aExpc3QoXG4gICAgICAgICAgICAgIGFyZ0lzSW5wdXRUeXBlKGFyZ1R5cGUudHlwZSkgPyBhcmdUeXBlLnR5cGUubmFtZSA6IHN0cmluZ2lmeUdyYXBoUUxUeXBlKGFyZ1R5cGUudHlwZSksXG4gICAgICAgICAgICAgIGFyZ1R5cGUuaXNMaXN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLmpvaW4oXCIgfCBcIilcbiAgICAgICAgKX1gO1xuICAgICAgICBpZiAoIWFyZzIuaXNSZXF1aXJlZCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRfY2hhbGsuZGVmYXVsdC5kaW0oc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfSkuam9pbihcIlxcblwiKSxcbiAgICAgIDJcbiAgICApO1xuICAgIHJldHVybiBgJHtpbXBvcnRfY2hhbGsuZGVmYXVsdC5kaW0oXCJ0eXBlXCIpfSAke2ltcG9ydF9jaGFsay5kZWZhdWx0LmJvbGQuZGltKGlucHV0Lm5hbWUpfSAke2ltcG9ydF9jaGFsay5kZWZhdWx0LmRpbShcIntcIil9XG4ke2JvZHl9XG4ke2ltcG9ydF9jaGFsay5kZWZhdWx0LmRpbShcIn1cIil9YDtcbiAgfVxufVxuX19uYW1lKHN0cmluZ2lmeUlucHV0VHlwZSwgXCJzdHJpbmdpZnlJbnB1dFR5cGVcIik7XG5mdW5jdGlvbiBhcmdJc0lucHV0VHlwZShhcmcyKSB7XG4gIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbl9fbmFtZShhcmdJc0lucHV0VHlwZSwgXCJhcmdJc0lucHV0VHlwZVwiKTtcbmZ1bmN0aW9uIGdldElucHV0VHlwZU5hbWUoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpbnB1dCA9PT0gXCJOdWxsXCIpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5uYW1lO1xufVxuX19uYW1lKGdldElucHV0VHlwZU5hbWUsIFwiZ2V0SW5wdXRUeXBlTmFtZVwiKTtcbmZ1bmN0aW9uIGdldE91dHB1dFR5cGVOYW1lKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0Lm5hbWU7XG59XG5fX25hbWUoZ2V0T3V0cHV0VHlwZU5hbWUsIFwiZ2V0T3V0cHV0VHlwZU5hbWVcIik7XG5mdW5jdGlvbiBpbnB1dFR5cGVUb0pzb24oaW5wdXQsIGlzUmVxdWlyZWQsIG5hbWVPbmx5ID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpbnB1dCA9PT0gXCJOdWxsXCIpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGlmIChpbnB1dC52YWx1ZXMpIHtcbiAgICByZXR1cm4gaW5wdXQudmFsdWVzLmpvaW4oXCIgfCBcIik7XG4gIH1cbiAgY29uc3QgaW5wdXRUeXBlID0gaW5wdXQ7XG4gIGNvbnN0IHNob3dEZWVwVHlwZSA9IGlzUmVxdWlyZWQgJiYgaW5wdXRUeXBlLmZpZWxkcy5ldmVyeShcbiAgICAoYXJnMikgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIHJldHVybiBhcmcyLmlucHV0VHlwZXNbMF0ubG9jYXRpb24gPT09IFwiaW5wdXRPYmplY3RUeXBlc1wiIHx8ICgoX2EzID0gYXJnMi5pbnB1dFR5cGVzWzFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmxvY2F0aW9uKSA9PT0gXCJpbnB1dE9iamVjdFR5cGVzXCI7XG4gICAgfVxuICApO1xuICBpZiAobmFtZU9ubHkpIHtcbiAgICByZXR1cm4gZ2V0SW5wdXRUeXBlTmFtZShpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGlucHV0VHlwZS5maWVsZHMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBpZiAoIXNob3dEZWVwVHlwZSAmJiAhY3Vyci5pc1JlcXVpcmVkKSB7XG4gICAgICBzdHIgPSBjdXJyLmlucHV0VHlwZXMubWFwKChhcmdUeXBlKSA9PiBnZXRJbnB1dFR5cGVOYW1lKGFyZ1R5cGUudHlwZSkpLmpvaW4oXCIgfCBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN1cnIuaW5wdXRUeXBlcy5tYXAoKGFyZ0lucHV0VHlwZSkgPT4gaW5wdXRUeXBlVG9Kc29uKGFyZ0lucHV0VHlwZS50eXBlLCBjdXJyLmlzUmVxdWlyZWQsIHRydWUpKS5qb2luKFwiIHwgXCIpO1xuICAgIH1cbiAgICBhY2NbY3Vyci5uYW1lICsgKGN1cnIuaXNSZXF1aXJlZCA/IFwiXCIgOiBcIj9cIildID0gc3RyO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbl9fbmFtZShpbnB1dFR5cGVUb0pzb24sIFwiaW5wdXRUeXBlVG9Kc29uXCIpO1xuZnVuY3Rpb24gdW5pb25CeShhcnIxLCBhcnIyLCBpdGVyYXRlZSkge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycjEpIHtcbiAgICBtYXBbaXRlcmF0ZWUoZWxlbWVudCldID0gZWxlbWVudDtcbiAgfVxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXJyMikge1xuICAgIGNvbnN0IGtleSA9IGl0ZXJhdGVlKGVsZW1lbnQpO1xuICAgIGlmICghbWFwW2tleV0pIHtcbiAgICAgIG1hcFtrZXldID0gZWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwKTtcbn1cbl9fbmFtZSh1bmlvbkJ5LCBcInVuaW9uQnlcIik7XG5mdW5jdGlvbiBsb3dlckNhc2UobmFtZSkge1xuICByZXR1cm4gbmFtZS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuX19uYW1lKGxvd2VyQ2FzZSwgXCJsb3dlckNhc2VcIik7XG5mdW5jdGlvbiBpc0dyb3VwQnlPdXRwdXROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZW5kc1dpdGgoXCJHcm91cEJ5T3V0cHV0VHlwZVwiKTtcbn1cbl9fbmFtZShpc0dyb3VwQnlPdXRwdXROYW1lLCBcImlzR3JvdXBCeU91dHB1dE5hbWVcIik7XG5mdW5jdGlvbiBpc1NjaGVtYUVudW0odHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS5uYW1lID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkodHlwZS52YWx1ZXMpO1xufVxuX19uYW1lKGlzU2NoZW1hRW51bSwgXCJpc1NjaGVtYUVudW1cIik7XG5cbi8vIHNyYy9ydW50aW1lL2RtbWYudHNcbnZhciBETU1GRGF0YW1vZGVsSGVscGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGRhdGFtb2RlbCB9KSB7XG4gICAgdGhpcy5kYXRhbW9kZWwgPSBkYXRhbW9kZWw7XG4gICAgdGhpcy5kYXRhbW9kZWxFbnVtTWFwID0gdGhpcy5nZXREYXRhbW9kZWxFbnVtTWFwKCk7XG4gICAgdGhpcy5tb2RlbE1hcCA9IHRoaXMuZ2V0TW9kZWxNYXAoKTtcbiAgICB0aGlzLnR5cGVNYXAgPSB0aGlzLmdldFR5cGVNYXAoKTtcbiAgICB0aGlzLnR5cGVBbmRNb2RlbE1hcCA9IHRoaXMuZ2V0VHlwZU1vZGVsTWFwKCk7XG4gIH1cbiAgZ2V0RGF0YW1vZGVsRW51bU1hcCgpIHtcbiAgICByZXR1cm4ga2V5QnkodGhpcy5kYXRhbW9kZWwuZW51bXMsIFwibmFtZVwiKTtcbiAgfVxuICBnZXRNb2RlbE1hcCgpIHtcbiAgICByZXR1cm4geyAuLi5rZXlCeSh0aGlzLmRhdGFtb2RlbC5tb2RlbHMsIFwibmFtZVwiKSB9O1xuICB9XG4gIGdldFR5cGVNYXAoKSB7XG4gICAgcmV0dXJuIHsgLi4ua2V5QnkodGhpcy5kYXRhbW9kZWwudHlwZXMsIFwibmFtZVwiKSB9O1xuICB9XG4gIGdldFR5cGVNb2RlbE1hcCgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmdldFR5cGVNYXAoKSwgLi4udGhpcy5nZXRNb2RlbE1hcCgpIH07XG4gIH1cbn07XG5fX25hbWUoRE1NRkRhdGFtb2RlbEhlbHBlciwgXCJETU1GRGF0YW1vZGVsSGVscGVyXCIpO1xudmFyIERNTUZNYXBwaW5nc0hlbHBlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBtYXBwaW5ncyB9KSB7XG4gICAgdGhpcy5tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMubWFwcGluZ3NNYXAgPSB0aGlzLmdldE1hcHBpbmdzTWFwKCk7XG4gIH1cbiAgZ2V0TWFwcGluZ3NNYXAoKSB7XG4gICAgcmV0dXJuIGtleUJ5KHRoaXMubWFwcGluZ3MubW9kZWxPcGVyYXRpb25zLCBcIm1vZGVsXCIpO1xuICB9XG59O1xuX19uYW1lKERNTUZNYXBwaW5nc0hlbHBlciwgXCJETU1GTWFwcGluZ3NIZWxwZXJcIik7XG52YXIgRE1NRlNjaGVtYUhlbHBlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBzY2hlbWEgfSkge1xuICAgIHRoaXMub3V0cHV0VHlwZVRvTWVyZ2VkT3V0cHV0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG91dHB1dFR5cGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm91dHB1dFR5cGUsXG4gICAgICAgIGZpZWxkczogb3V0cHV0VHlwZS5maWVsZHNcbiAgICAgIH07XG4gICAgfSwgXCJvdXRwdXRUeXBlVG9NZXJnZWRPdXRwdXRUeXBlXCIpO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuZW51bU1hcCA9IHRoaXMuZ2V0RW51bU1hcCgpO1xuICAgIHRoaXMucXVlcnlUeXBlID0gdGhpcy5nZXRRdWVyeVR5cGUoKTtcbiAgICB0aGlzLm11dGF0aW9uVHlwZSA9IHRoaXMuZ2V0TXV0YXRpb25UeXBlKCk7XG4gICAgdGhpcy5vdXRwdXRUeXBlcyA9IHRoaXMuZ2V0T3V0cHV0VHlwZXMoKTtcbiAgICB0aGlzLm91dHB1dFR5cGVNYXAgPSB0aGlzLmdldE1lcmdlZE91dHB1dFR5cGVNYXAoKTtcbiAgICB0aGlzLnJlc29sdmVPdXRwdXRUeXBlcygpO1xuICAgIHRoaXMuaW5wdXRPYmplY3RUeXBlcyA9IHRoaXMuc2NoZW1hLmlucHV0T2JqZWN0VHlwZXM7XG4gICAgdGhpcy5pbnB1dFR5cGVNYXAgPSB0aGlzLmdldElucHV0VHlwZU1hcCgpO1xuICAgIHRoaXMucmVzb2x2ZUlucHV0VHlwZXMoKTtcbiAgICB0aGlzLnJlc29sdmVGaWVsZEFyZ3VtZW50VHlwZXMoKTtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9IHRoaXMub3V0cHV0VHlwZU1hcC5RdWVyeTtcbiAgICB0aGlzLm11dGF0aW9uVHlwZSA9IHRoaXMub3V0cHV0VHlwZU1hcC5NdXRhdGlvbjtcbiAgICB0aGlzLnJvb3RGaWVsZE1hcCA9IHRoaXMuZ2V0Um9vdEZpZWxkTWFwKCk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkRNTUZDbGFzc1wiO1xuICB9XG4gIHJlc29sdmVPdXRwdXRUeXBlcygpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5vdXRwdXRUeXBlcy5tb2RlbCkge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcykge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkLm91dHB1dFR5cGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhU2NhbGFyVHlwZVRhYmxlW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0pIHtcbiAgICAgICAgICBmaWVsZC5vdXRwdXRUeXBlLnR5cGUgPSB0aGlzLm91dHB1dFR5cGVNYXBbZmllbGQub3V0cHV0VHlwZS50eXBlXSB8fCB0aGlzLm91dHB1dFR5cGVNYXBbZmllbGQub3V0cHV0VHlwZS50eXBlXSB8fCB0aGlzLmVudW1NYXBbZmllbGQub3V0cHV0VHlwZS50eXBlXSB8fCBmaWVsZC5vdXRwdXRUeXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHR5cGUuZmllbGRNYXAgPSBrZXlCeSh0eXBlLmZpZWxkcywgXCJuYW1lXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5vdXRwdXRUeXBlcy5wcmlzbWEpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5vdXRwdXRUeXBlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgIVNjYWxhclR5cGVUYWJsZVtmaWVsZC5vdXRwdXRUeXBlLnR5cGVdKSB7XG4gICAgICAgICAgZmllbGQub3V0cHV0VHlwZS50eXBlID0gdGhpcy5vdXRwdXRUeXBlTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgdGhpcy5vdXRwdXRUeXBlTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgdGhpcy5lbnVtTWFwW2ZpZWxkLm91dHB1dFR5cGUudHlwZV0gfHwgZmllbGQub3V0cHV0VHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eXBlLmZpZWxkTWFwID0ga2V5QnkodHlwZS5maWVsZHMsIFwibmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUlucHV0VHlwZXMoKSB7XG4gICAgY29uc3QgaW5wdXRUeXBlcyA9IHRoaXMuaW5wdXRPYmplY3RUeXBlcy5wcmlzbWE7XG4gICAgaWYgKHRoaXMuaW5wdXRPYmplY3RUeXBlcy5tb2RlbCkge1xuICAgICAgaW5wdXRUeXBlcy5wdXNoKC4uLnRoaXMuaW5wdXRPYmplY3RUeXBlcy5tb2RlbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBpbnB1dFR5cGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRJbnB1dFR5cGUgb2YgZmllbGQuaW5wdXRUeXBlcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGZpZWxkSW5wdXRUeXBlLnR5cGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIgJiYgIVNjYWxhclR5cGVUYWJsZVtmaWVsZFR5cGVdICYmICh0aGlzLmlucHV0VHlwZU1hcFtmaWVsZFR5cGVdIHx8IHRoaXMuZW51bU1hcFtmaWVsZFR5cGVdKSkge1xuICAgICAgICAgICAgZmllbGRJbnB1dFR5cGUudHlwZSA9IHRoaXMuaW5wdXRUeXBlTWFwW2ZpZWxkVHlwZV0gfHwgdGhpcy5lbnVtTWFwW2ZpZWxkVHlwZV0gfHwgZmllbGRUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZS5maWVsZE1hcCA9IGtleUJ5KHR5cGUuZmllbGRzLCBcIm5hbWVcIik7XG4gICAgfVxuICB9XG4gIHJlc29sdmVGaWVsZEFyZ3VtZW50VHlwZXMoKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMub3V0cHV0VHlwZXMucHJpc21hKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXJnMiBvZiBmaWVsZC5hcmdzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBhcmdJbnB1dFR5cGUgb2YgYXJnMi5pbnB1dFR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdUeXBlID0gYXJnSW5wdXRUeXBlLnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ1R5cGUgPT09IFwic3RyaW5nXCIgJiYgIVNjYWxhclR5cGVUYWJsZVthcmdUeXBlXSkge1xuICAgICAgICAgICAgICBhcmdJbnB1dFR5cGUudHlwZSA9IHRoaXMuaW5wdXRUeXBlTWFwW2FyZ1R5cGVdIHx8IHRoaXMuZW51bU1hcFthcmdUeXBlXSB8fCBhcmdUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5vdXRwdXRUeXBlcy5tb2RlbCkge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZzIgb2YgZmllbGQuYXJncykge1xuICAgICAgICAgIGZvciAoY29uc3QgYXJnSW5wdXRUeXBlIG9mIGFyZzIuaW5wdXRUeXBlcykge1xuICAgICAgICAgICAgY29uc3QgYXJnVHlwZSA9IGFyZ0lucHV0VHlwZS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdUeXBlID09PSBcInN0cmluZ1wiICYmICFTY2FsYXJUeXBlVGFibGVbYXJnVHlwZV0pIHtcbiAgICAgICAgICAgICAgYXJnSW5wdXRUeXBlLnR5cGUgPSB0aGlzLmlucHV0VHlwZU1hcFthcmdUeXBlXSB8fCB0aGlzLmVudW1NYXBbYXJnVHlwZV0gfHwgYXJnSW5wdXRUeXBlLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFF1ZXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWEub3V0cHV0T2JqZWN0VHlwZXMucHJpc21hLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gXCJRdWVyeVwiKTtcbiAgfVxuICBnZXRNdXRhdGlvblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hLm91dHB1dE9iamVjdFR5cGVzLnByaXNtYS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IFwiTXV0YXRpb25cIik7XG4gIH1cbiAgZ2V0T3V0cHV0VHlwZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGVsOiB0aGlzLnNjaGVtYS5vdXRwdXRPYmplY3RUeXBlcy5tb2RlbC5tYXAodGhpcy5vdXRwdXRUeXBlVG9NZXJnZWRPdXRwdXRUeXBlKSxcbiAgICAgIHByaXNtYTogdGhpcy5zY2hlbWEub3V0cHV0T2JqZWN0VHlwZXMucHJpc21hLm1hcCh0aGlzLm91dHB1dFR5cGVUb01lcmdlZE91dHB1dFR5cGUpXG4gICAgfTtcbiAgfVxuICBnZXRFbnVtTWFwKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5rZXlCeSh0aGlzLnNjaGVtYS5lbnVtVHlwZXMucHJpc21hLCBcIm5hbWVcIiksXG4gICAgICAuLi50aGlzLnNjaGVtYS5lbnVtVHlwZXMubW9kZWwgPyBrZXlCeSh0aGlzLnNjaGVtYS5lbnVtVHlwZXMubW9kZWwsIFwibmFtZVwiKSA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgaGFzRW51bUluTmFtZXNwYWNlKGVudW1OYW1lLCBuYW1lc3BhY2UpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiAoKF9hMyA9IHRoaXMuc2NoZW1hLmVudW1UeXBlc1tuYW1lc3BhY2VdKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmZpbmQoKHNjaGVtYUVudW0pID0+IHNjaGVtYUVudW0ubmFtZSA9PT0gZW51bU5hbWUpKSAhPT0gdm9pZCAwO1xuICB9XG4gIGdldE1lcmdlZE91dHB1dFR5cGVNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmtleUJ5KHRoaXMub3V0cHV0VHlwZXMubW9kZWwsIFwibmFtZVwiKSxcbiAgICAgIC4uLmtleUJ5KHRoaXMub3V0cHV0VHlwZXMucHJpc21hLCBcIm5hbWVcIilcbiAgICB9O1xuICB9XG4gIGdldElucHV0VHlwZU1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5zY2hlbWEuaW5wdXRPYmplY3RUeXBlcy5tb2RlbCA/IGtleUJ5KHRoaXMuc2NoZW1hLmlucHV0T2JqZWN0VHlwZXMubW9kZWwsIFwibmFtZVwiKSA6IHZvaWQgMCxcbiAgICAgIC4uLmtleUJ5KHRoaXMuc2NoZW1hLmlucHV0T2JqZWN0VHlwZXMucHJpc21hLCBcIm5hbWVcIilcbiAgICB9O1xuICB9XG4gIGdldFJvb3RGaWVsZE1hcCgpIHtcbiAgICByZXR1cm4geyAuLi5rZXlCeSh0aGlzLnF1ZXJ5VHlwZS5maWVsZHMsIFwibmFtZVwiKSwgLi4ua2V5QnkodGhpcy5tdXRhdGlvblR5cGUuZmllbGRzLCBcIm5hbWVcIikgfTtcbiAgfVxufTtcbl9fbmFtZShETU1GU2NoZW1hSGVscGVyLCBcIkRNTUZTY2hlbWFIZWxwZXJcIik7XG52YXIgQmFzZURNTUZIZWxwZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRtbWYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLCBuZXcgRE1NRkRhdGFtb2RlbEhlbHBlcihkbW1mKSwgbmV3IERNTUZNYXBwaW5nc0hlbHBlcihkbW1mKSk7XG4gIH1cbn07XG5fX25hbWUoQmFzZURNTUZIZWxwZXIsIFwiQmFzZURNTUZIZWxwZXJcIik7XG5hcHBseU1peGlucyhCYXNlRE1NRkhlbHBlciwgW0RNTUZEYXRhbW9kZWxIZWxwZXIsIERNTUZNYXBwaW5nc0hlbHBlcl0pO1xudmFyIERNTUZIZWxwZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRtbWYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLCBuZXcgQmFzZURNTUZIZWxwZXIoZG1tZiksIG5ldyBETU1GU2NoZW1hSGVscGVyKGRtbWYpKTtcbiAgfVxufTtcbl9fbmFtZShETU1GSGVscGVyLCBcIkRNTUZIZWxwZXJcIik7XG5hcHBseU1peGlucyhETU1GSGVscGVyLCBbQmFzZURNTUZIZWxwZXIsIERNTUZTY2hlbWFIZWxwZXJdKTtcblxuLy8gLi4vZ2VuZXJhdG9yLWhlbHBlci9zcmMvZG1tZi50c1xudmFyIERNTUY7XG4oKERNTUYyKSA9PiB7XG4gIGxldCBNb2RlbEFjdGlvbjtcbiAgKChNb2RlbEFjdGlvbjIpID0+IHtcbiAgICBNb2RlbEFjdGlvbjJbXCJmaW5kVW5pcXVlXCJdID0gXCJmaW5kVW5pcXVlXCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiZmluZEZpcnN0XCJdID0gXCJmaW5kRmlyc3RcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJmaW5kTWFueVwiXSA9IFwiZmluZE1hbnlcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJjcmVhdGVcIl0gPSBcImNyZWF0ZVwiO1xuICAgIE1vZGVsQWN0aW9uMltcImNyZWF0ZU1hbnlcIl0gPSBcImNyZWF0ZU1hbnlcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJ1cGRhdGVcIl0gPSBcInVwZGF0ZVwiO1xuICAgIE1vZGVsQWN0aW9uMltcInVwZGF0ZU1hbnlcIl0gPSBcInVwZGF0ZU1hbnlcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJ1cHNlcnRcIl0gPSBcInVwc2VydFwiO1xuICAgIE1vZGVsQWN0aW9uMltcImRlbGV0ZVwiXSA9IFwiZGVsZXRlXCI7XG4gICAgTW9kZWxBY3Rpb24yW1wiZGVsZXRlTWFueVwiXSA9IFwiZGVsZXRlTWFueVwiO1xuICAgIE1vZGVsQWN0aW9uMltcImdyb3VwQnlcIl0gPSBcImdyb3VwQnlcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJjb3VudFwiXSA9IFwiY291bnRcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJhZ2dyZWdhdGVcIl0gPSBcImFnZ3JlZ2F0ZVwiO1xuICAgIE1vZGVsQWN0aW9uMltcImZpbmRSYXdcIl0gPSBcImZpbmRSYXdcIjtcbiAgICBNb2RlbEFjdGlvbjJbXCJhZ2dyZWdhdGVSYXdcIl0gPSBcImFnZ3JlZ2F0ZVJhd1wiO1xuICB9KShNb2RlbEFjdGlvbiA9IERNTUYyLk1vZGVsQWN0aW9uIHx8IChETU1GMi5Nb2RlbEFjdGlvbiA9IHt9KSk7XG59KShETU1GIHx8IChETU1GID0ge30pKTtcblxuLy8gLi4vZGVidWcvc3JjL2luZGV4LnRzXG52YXIgaW1wb3J0X2RlYnVnID0gX190b0VTTShyZXF1aXJlX3NyYygpKTtcbnZhciBNQVhfTE9HUyA9IDEwMDtcbnZhciBkZWJ1Z0FyZ3NIaXN0b3J5ID0gW107XG52YXIgX2EsIF9iO1xuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAoKF9hID0gcHJvY2Vzcy5zdGRlcnIpID09IG51bGwgPyB2b2lkIDAgOiBfYS53cml0ZSkgIT09IFwiZnVuY3Rpb25cIikge1xuICBpbXBvcnRfZGVidWcuZGVmYXVsdC5sb2cgPSAoX2IgPSBjb25zb2xlLmRlYnVnKSAhPSBudWxsID8gX2IgOiBjb25zb2xlLmxvZztcbn1cbmZ1bmN0aW9uIGRlYnVnQ2FsbChuYW1lc3BhY2UpIHtcbiAgY29uc3QgZGVidWdOYW1lc3BhY2UgPSAoMCwgaW1wb3J0X2RlYnVnLmRlZmF1bHQpKG5hbWVzcGFjZSk7XG4gIGNvbnN0IGNhbGwgPSBPYmplY3QuYXNzaWduKCguLi5hcmdzKSA9PiB7XG4gICAgZGVidWdOYW1lc3BhY2UubG9nID0gY2FsbC5sb2c7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBkZWJ1Z0FyZ3NIaXN0b3J5LnB1c2goW25hbWVzcGFjZSwgLi4uYXJnc10pO1xuICAgIH1cbiAgICBpZiAoZGVidWdBcmdzSGlzdG9yeS5sZW5ndGggPiBNQVhfTE9HUykge1xuICAgICAgZGVidWdBcmdzSGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZGVidWdOYW1lc3BhY2UoXCJcIiwgLi4uYXJncyk7XG4gIH0sIGRlYnVnTmFtZXNwYWNlKTtcbiAgcmV0dXJuIGNhbGw7XG59XG5fX25hbWUoZGVidWdDYWxsLCBcImRlYnVnQ2FsbFwiKTtcbnZhciBEZWJ1ZyA9IE9iamVjdC5hc3NpZ24oZGVidWdDYWxsLCBpbXBvcnRfZGVidWcuZGVmYXVsdCk7XG5mdW5jdGlvbiBnZXRMb2dzKG51bUNoYXJzID0gNzUwMCkge1xuICBjb25zdCBvdXRwdXQgPSBkZWJ1Z0FyZ3NIaXN0b3J5Lm1hcChcbiAgICAoYykgPT4gYy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgICB9KS5qb2luKFwiIFwiKVxuICApLmpvaW4oXCJcXG5cIik7XG4gIGlmIChvdXRwdXQubGVuZ3RoIDwgbnVtQ2hhcnMpIHtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBvdXRwdXQuc2xpY2UoLW51bUNoYXJzKTtcbn1cbl9fbmFtZShnZXRMb2dzLCBcImdldExvZ3NcIik7XG52YXIgc3JjX2RlZmF1bHQgPSBEZWJ1ZztcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2dsb2JhbFRoaXMuanNcbnZhciBfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMS4xLjBcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9pbnRlcm5hbC9zZW12ZXIuanNcbnZhciByZSA9IC9eKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKC0oLispKT8kLztcbmZ1bmN0aW9uIF9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrKG93blZlcnNpb24pIHtcbiAgdmFyIGFjY2VwdGVkVmVyc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbb3duVmVyc2lvbl0pO1xuICB2YXIgcmVqZWN0ZWRWZXJzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHZhciBteVZlcnNpb25NYXRjaCA9IG93blZlcnNpb24ubWF0Y2gocmUpO1xuICBpZiAoIW15VmVyc2lvbk1hdGNoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbiAgdmFyIG93blZlcnNpb25QYXJzZWQgPSB7XG4gICAgbWFqb3I6ICtteVZlcnNpb25NYXRjaFsxXSxcbiAgICBtaW5vcjogK215VmVyc2lvbk1hdGNoWzJdLFxuICAgIHBhdGNoOiArbXlWZXJzaW9uTWF0Y2hbM10sXG4gICAgcHJlcmVsZWFzZTogbXlWZXJzaW9uTWF0Y2hbNF1cbiAgfTtcbiAgaWYgKG93blZlcnNpb25QYXJzZWQucHJlcmVsZWFzZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gaXNFeGFjdG1hdGNoKGdsb2JhbFZlcnNpb24pIHtcbiAgICAgIHJldHVybiBnbG9iYWxWZXJzaW9uID09PSBvd25WZXJzaW9uO1xuICAgIH0sIFwiaXNFeGFjdG1hdGNoXCIpO1xuICB9XG4gIGZ1bmN0aW9uIF9yZWplY3Qodikge1xuICAgIHJlamVjdGVkVmVyc2lvbnMuYWRkKHYpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfX25hbWUoX3JlamVjdCwgXCJfcmVqZWN0XCIpO1xuICBmdW5jdGlvbiBfYWNjZXB0KHYpIHtcbiAgICBhY2NlcHRlZFZlcnNpb25zLmFkZCh2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfX25hbWUoX2FjY2VwdCwgXCJfYWNjZXB0XCIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBpc0NvbXBhdGlibGUyKGdsb2JhbFZlcnNpb24pIHtcbiAgICBpZiAoYWNjZXB0ZWRWZXJzaW9ucy5oYXMoZ2xvYmFsVmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVqZWN0ZWRWZXJzaW9ucy5oYXMoZ2xvYmFsVmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsb2JhbFZlcnNpb25NYXRjaCA9IGdsb2JhbFZlcnNpb24ubWF0Y2gocmUpO1xuICAgIGlmICghZ2xvYmFsVmVyc2lvbk1hdGNoKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgdmFyIGdsb2JhbFZlcnNpb25QYXJzZWQgPSB7XG4gICAgICBtYWpvcjogK2dsb2JhbFZlcnNpb25NYXRjaFsxXSxcbiAgICAgIG1pbm9yOiArZ2xvYmFsVmVyc2lvbk1hdGNoWzJdLFxuICAgICAgcGF0Y2g6ICtnbG9iYWxWZXJzaW9uTWF0Y2hbM10sXG4gICAgICBwcmVyZWxlYXNlOiBnbG9iYWxWZXJzaW9uTWF0Y2hbNF1cbiAgICB9O1xuICAgIGlmIChnbG9iYWxWZXJzaW9uUGFyc2VkLnByZXJlbGVhc2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChvd25WZXJzaW9uUGFyc2VkLm1ham9yICE9PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1ham9yKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKG93blZlcnNpb25QYXJzZWQubWFqb3IgPT09IDApIHtcbiAgICAgIGlmIChvd25WZXJzaW9uUGFyc2VkLm1pbm9yID09PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1pbm9yICYmIG93blZlcnNpb25QYXJzZWQucGF0Y2ggPD0gZ2xvYmFsVmVyc2lvblBhcnNlZC5wYXRjaCkge1xuICAgICAgICByZXR1cm4gX2FjY2VwdChnbG9iYWxWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVqZWN0KGdsb2JhbFZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAob3duVmVyc2lvblBhcnNlZC5taW5vciA8PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1pbm9yKSB7XG4gICAgICByZXR1cm4gX2FjY2VwdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gIH0sIFwiaXNDb21wYXRpYmxlXCIpO1xufVxuX19uYW1lKF9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrLCBcIl9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrXCIpO1xudmFyIGlzQ29tcGF0aWJsZSA9IF9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrKFZFUlNJT04pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2ludGVybmFsL2dsb2JhbC11dGlscy5qc1xudmFyIG1ham9yID0gVkVSU0lPTi5zcGxpdChcIi5cIilbMF07XG52YXIgR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWSA9IFN5bWJvbC5mb3IoXCJvcGVudGVsZW1ldHJ5LmpzLmFwaS5cIiArIG1ham9yKTtcbnZhciBfZ2xvYmFsID0gX2dsb2JhbFRoaXM7XG5mdW5jdGlvbiByZWdpc3Rlckdsb2JhbCh0eXBlLCBpbnN0YW5jZSwgZGlhZzMsIGFsbG93T3ZlcnJpZGUpIHtcbiAgdmFyIF9hMztcbiAgaWYgKGFsbG93T3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgIGFsbG93T3ZlcnJpZGUgPSBmYWxzZTtcbiAgfVxuICB2YXIgYXBpID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXSA9IChfYTMgPSBfZ2xvYmFsW0dMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVldKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IHtcbiAgICB2ZXJzaW9uOiBWRVJTSU9OXG4gIH07XG4gIGlmICghYWxsb3dPdmVycmlkZSAmJiBhcGlbdHlwZV0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiQG9wZW50ZWxlbWV0cnkvYXBpOiBBdHRlbXB0ZWQgZHVwbGljYXRlIHJlZ2lzdHJhdGlvbiBvZiBBUEk6IFwiICsgdHlwZSk7XG4gICAgZGlhZzMuZXJyb3IoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFwaS52ZXJzaW9uICE9PSBWRVJTSU9OKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkBvcGVudGVsZW1ldHJ5L2FwaTogQWxsIEFQSSByZWdpc3RyYXRpb24gdmVyc2lvbnMgbXVzdCBtYXRjaFwiKTtcbiAgICBkaWFnMy5lcnJvcihlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhcGlbdHlwZV0gPSBpbnN0YW5jZTtcbiAgZGlhZzMuZGVidWcoXCJAb3BlbnRlbGVtZXRyeS9hcGk6IFJlZ2lzdGVyZWQgYSBnbG9iYWwgZm9yIFwiICsgdHlwZSArIFwiIHZcIiArIFZFUlNJT04gKyBcIi5cIik7XG4gIHJldHVybiB0cnVlO1xufVxuX19uYW1lKHJlZ2lzdGVyR2xvYmFsLCBcInJlZ2lzdGVyR2xvYmFsXCIpO1xuZnVuY3Rpb24gZ2V0R2xvYmFsKHR5cGUpIHtcbiAgdmFyIF9hMywgX2IyO1xuICB2YXIgZ2xvYmFsVmVyc2lvbiA9IChfYTMgPSBfZ2xvYmFsW0dMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVldKSA9PT0gbnVsbCB8fCBfYTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMy52ZXJzaW9uO1xuICBpZiAoIWdsb2JhbFZlcnNpb24gfHwgIWlzQ29tcGF0aWJsZShnbG9iYWxWZXJzaW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gKF9iMiA9IF9nbG9iYWxbR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWV0pID09PSBudWxsIHx8IF9iMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IyW3R5cGVdO1xufVxuX19uYW1lKGdldEdsb2JhbCwgXCJnZXRHbG9iYWxcIik7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyR2xvYmFsKHR5cGUsIGRpYWczKSB7XG4gIGRpYWczLmRlYnVnKFwiQG9wZW50ZWxlbWV0cnkvYXBpOiBVbnJlZ2lzdGVyaW5nIGEgZ2xvYmFsIGZvciBcIiArIHR5cGUgKyBcIiB2XCIgKyBWRVJTSU9OICsgXCIuXCIpO1xuICB2YXIgYXBpID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXTtcbiAgaWYgKGFwaSkge1xuICAgIGRlbGV0ZSBhcGlbdHlwZV07XG4gIH1cbn1cbl9fbmFtZSh1bnJlZ2lzdGVyR2xvYmFsLCBcInVucmVnaXN0ZXJHbG9iYWxcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vZGlhZy9Db21wb25lbnRMb2dnZXIuanNcbnZhciBEaWFnQ29tcG9uZW50TG9nZ2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIERpYWdDb21wb25lbnRMb2dnZXIyKHByb3BzKSB7XG4gICAgdGhpcy5fbmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlIHx8IFwiRGlhZ0NvbXBvbmVudExvZ2dlclwiO1xuICB9XG4gIF9fbmFtZShEaWFnQ29tcG9uZW50TG9nZ2VyMiwgXCJEaWFnQ29tcG9uZW50TG9nZ2VyXCIpO1xuICBEaWFnQ29tcG9uZW50TG9nZ2VyMi5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBsb2dQcm94eShcImRlYnVnXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gIH07XG4gIERpYWdDb21wb25lbnRMb2dnZXIyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ1Byb3h5KFwiZXJyb3JcIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgfTtcbiAgRGlhZ0NvbXBvbmVudExvZ2dlcjIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBsb2dQcm94eShcImluZm9cIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgfTtcbiAgRGlhZ0NvbXBvbmVudExvZ2dlcjIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBsb2dQcm94eShcIndhcm5cIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgfTtcbiAgRGlhZ0NvbXBvbmVudExvZ2dlcjIucHJvdG90eXBlLnZlcmJvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBsb2dQcm94eShcInZlcmJvc2VcIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgfTtcbiAgcmV0dXJuIERpYWdDb21wb25lbnRMb2dnZXIyO1xufSgpO1xuZnVuY3Rpb24gbG9nUHJveHkoZnVuY05hbWUsIG5hbWVzcGFjZSwgYXJncykge1xuICB2YXIgbG9nZ2VyMiA9IGdldEdsb2JhbChcImRpYWdcIik7XG4gIGlmICghbG9nZ2VyMikge1xuICAgIHJldHVybjtcbiAgfVxuICBhcmdzLnVuc2hpZnQobmFtZXNwYWNlKTtcbiAgcmV0dXJuIGxvZ2dlcjJbZnVuY05hbWVdLmFwcGx5KGxvZ2dlcjIsIGFyZ3MpO1xufVxuX19uYW1lKGxvZ1Byb3h5LCBcImxvZ1Byb3h5XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvdHlwZXMuanNcbnZhciBEaWFnTG9nTGV2ZWw7XG4oZnVuY3Rpb24oRGlhZ0xvZ0xldmVsMikge1xuICBEaWFnTG9nTGV2ZWwyW0RpYWdMb2dMZXZlbDJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiRVJST1JcIl0gPSAzMF0gPSBcIkVSUk9SXCI7XG4gIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIldBUk5cIl0gPSA1MF0gPSBcIldBUk5cIjtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiSU5GT1wiXSA9IDYwXSA9IFwiSU5GT1wiO1xuICBEaWFnTG9nTGV2ZWwyW0RpYWdMb2dMZXZlbDJbXCJERUJVR1wiXSA9IDcwXSA9IFwiREVCVUdcIjtcbiAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiVkVSQk9TRVwiXSA9IDgwXSA9IFwiVkVSQk9TRVwiO1xuICBEaWFnTG9nTGV2ZWwyW0RpYWdMb2dMZXZlbDJbXCJBTExcIl0gPSA5OTk5XSA9IFwiQUxMXCI7XG59KShEaWFnTG9nTGV2ZWwgfHwgKERpYWdMb2dMZXZlbCA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vZGlhZy9pbnRlcm5hbC9sb2dMZXZlbExvZ2dlci5qc1xuZnVuY3Rpb24gY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyKG1heExldmVsLCBsb2dnZXIyKSB7XG4gIGlmIChtYXhMZXZlbCA8IERpYWdMb2dMZXZlbC5OT05FKSB7XG4gICAgbWF4TGV2ZWwgPSBEaWFnTG9nTGV2ZWwuTk9ORTtcbiAgfSBlbHNlIGlmIChtYXhMZXZlbCA+IERpYWdMb2dMZXZlbC5BTEwpIHtcbiAgICBtYXhMZXZlbCA9IERpYWdMb2dMZXZlbC5BTEw7XG4gIH1cbiAgbG9nZ2VyMiA9IGxvZ2dlcjIgfHwge307XG4gIGZ1bmN0aW9uIF9maWx0ZXJGdW5jKGZ1bmNOYW1lLCB0aGVMZXZlbCkge1xuICAgIHZhciB0aGVGdW5jID0gbG9nZ2VyMltmdW5jTmFtZV07XG4gICAgaWYgKHR5cGVvZiB0aGVGdW5jID09PSBcImZ1bmN0aW9uXCIgJiYgbWF4TGV2ZWwgPj0gdGhlTGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGVGdW5jLmJpbmQobG9nZ2VyMik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB9O1xuICB9XG4gIF9fbmFtZShfZmlsdGVyRnVuYywgXCJfZmlsdGVyRnVuY1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlcnJvcjogX2ZpbHRlckZ1bmMoXCJlcnJvclwiLCBEaWFnTG9nTGV2ZWwuRVJST1IpLFxuICAgIHdhcm46IF9maWx0ZXJGdW5jKFwid2FyblwiLCBEaWFnTG9nTGV2ZWwuV0FSTiksXG4gICAgaW5mbzogX2ZpbHRlckZ1bmMoXCJpbmZvXCIsIERpYWdMb2dMZXZlbC5JTkZPKSxcbiAgICBkZWJ1ZzogX2ZpbHRlckZ1bmMoXCJkZWJ1Z1wiLCBEaWFnTG9nTGV2ZWwuREVCVUcpLFxuICAgIHZlcmJvc2U6IF9maWx0ZXJGdW5jKFwidmVyYm9zZVwiLCBEaWFnTG9nTGV2ZWwuVkVSQk9TRSlcbiAgfTtcbn1cbl9fbmFtZShjcmVhdGVMb2dMZXZlbERpYWdMb2dnZXIsIFwiY3JlYXRlTG9nTGV2ZWxEaWFnTG9nZ2VyXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2FwaS9kaWFnLmpzXG52YXIgQVBJX05BTUUgPSBcImRpYWdcIjtcbnZhciBEaWFnQVBJID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIERpYWdBUEkyKCkge1xuICAgIGZ1bmN0aW9uIF9sb2dQcm94eShmdW5jTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nZ2VyMiA9IGdldEdsb2JhbChcImRpYWdcIik7XG4gICAgICAgIGlmICghbG9nZ2VyMilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBsb2dnZXIyW2Z1bmNOYW1lXS5hcHBseShsb2dnZXIyLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShfbG9nUHJveHksIFwiX2xvZ1Byb3h5XCIpO1xuICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgc2VsZjIuc2V0TG9nZ2VyID0gZnVuY3Rpb24obG9nZ2VyMiwgbG9nTGV2ZWwpIHtcbiAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgIGlmIChsb2dMZXZlbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxvZ0xldmVsID0gRGlhZ0xvZ0xldmVsLklORk87XG4gICAgICB9XG4gICAgICBpZiAobG9nZ2VyMiA9PT0gc2VsZjIpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgZGlhZyBhcyB0aGUgbG9nZ2VyIGZvciBpdHNlbGYuIFBsZWFzZSB1c2UgYSBEaWFnTG9nZ2VyIGltcGxlbWVudGF0aW9uIGxpa2UgQ29uc29sZURpYWdMb2dnZXIgb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHNlbGYyLmVycm9yKChfYTMgPSBlcnIuc3RhY2spICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogZXJyLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2xkTG9nZ2VyID0gZ2V0R2xvYmFsKFwiZGlhZ1wiKTtcbiAgICAgIHZhciBuZXdMb2dnZXIgPSBjcmVhdGVMb2dMZXZlbERpYWdMb2dnZXIobG9nTGV2ZWwsIGxvZ2dlcjIpO1xuICAgICAgaWYgKG9sZExvZ2dlcikge1xuICAgICAgICB2YXIgc3RhY2sgPSAoX2IyID0gbmV3IEVycm9yKCkuc3RhY2spICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogXCI8ZmFpbGVkIHRvIGdlbmVyYXRlIHN0YWNrdHJhY2U+XCI7XG4gICAgICAgIG9sZExvZ2dlci53YXJuKFwiQ3VycmVudCBsb2dnZXIgd2lsbCBiZSBvdmVyd3JpdHRlbiBmcm9tIFwiICsgc3RhY2spO1xuICAgICAgICBuZXdMb2dnZXIud2FybihcIkN1cnJlbnQgbG9nZ2VyIHdpbGwgb3ZlcndyaXRlIG9uZSBhbHJlYWR5IHJlZ2lzdGVyZWQgZnJvbSBcIiArIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWdpc3Rlckdsb2JhbChcImRpYWdcIiwgbmV3TG9nZ2VyLCBzZWxmMiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBzZWxmMi5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FLCBzZWxmMik7XG4gICAgfTtcbiAgICBzZWxmMi5jcmVhdGVDb21wb25lbnRMb2dnZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IERpYWdDb21wb25lbnRMb2dnZXIob3B0aW9ucyk7XG4gICAgfTtcbiAgICBzZWxmMi52ZXJib3NlID0gX2xvZ1Byb3h5KFwidmVyYm9zZVwiKTtcbiAgICBzZWxmMi5kZWJ1ZyA9IF9sb2dQcm94eShcImRlYnVnXCIpO1xuICAgIHNlbGYyLmluZm8gPSBfbG9nUHJveHkoXCJpbmZvXCIpO1xuICAgIHNlbGYyLndhcm4gPSBfbG9nUHJveHkoXCJ3YXJuXCIpO1xuICAgIHNlbGYyLmVycm9yID0gX2xvZ1Byb3h5KFwiZXJyb3JcIik7XG4gIH1cbiAgX19uYW1lKERpYWdBUEkyLCBcIkRpYWdBUElcIik7XG4gIERpYWdBUEkyLmluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgRGlhZ0FQSTIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICB9O1xuICByZXR1cm4gRGlhZ0FQSTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS9pbnRlcm5hbC9iYWdnYWdlLWltcGwuanNcbnZhciBCYWdnYWdlSW1wbCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBCYWdnYWdlSW1wbDIoZW50cmllcykge1xuICAgIHRoaXMuX2VudHJpZXMgPSBlbnRyaWVzID8gbmV3IE1hcChlbnRyaWVzKSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgX19uYW1lKEJhZ2dhZ2VJbXBsMiwgXCJCYWdnYWdlSW1wbFwiKTtcbiAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5nZXRFbnRyeSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuX2VudHJpZXMuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KTtcbiAgfTtcbiAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5nZXRBbGxFbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fZW50cmllcy5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbihfYTMpIHtcbiAgICAgIHZhciBrID0gX2EzWzBdLCB2ID0gX2EzWzFdO1xuICAgICAgcmV0dXJuIFtrLCB2XTtcbiAgICB9KTtcbiAgfTtcbiAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5zZXRFbnRyeSA9IGZ1bmN0aW9uKGtleSwgZW50cnkpIHtcbiAgICB2YXIgbmV3QmFnZ2FnZSA9IG5ldyBCYWdnYWdlSW1wbDIodGhpcy5fZW50cmllcyk7XG4gICAgbmV3QmFnZ2FnZS5fZW50cmllcy5zZXQoa2V5LCBlbnRyeSk7XG4gICAgcmV0dXJuIG5ld0JhZ2dhZ2U7XG4gIH07XG4gIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUucmVtb3ZlRW50cnkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgbmV3QmFnZ2FnZSA9IG5ldyBCYWdnYWdlSW1wbDIodGhpcy5fZW50cmllcyk7XG4gICAgbmV3QmFnZ2FnZS5fZW50cmllcy5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gbmV3QmFnZ2FnZTtcbiAgfTtcbiAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5yZW1vdmVFbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXMyID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGtleXMyW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBuZXdCYWdnYWdlID0gbmV3IEJhZ2dhZ2VJbXBsMih0aGlzLl9lbnRyaWVzKTtcbiAgICBmb3IgKHZhciBfYTMgPSAwLCBrZXlzXzEgPSBrZXlzMjsgX2EzIDwga2V5c18xLmxlbmd0aDsgX2EzKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzXzFbX2EzXTtcbiAgICAgIG5ld0JhZ2dhZ2UuX2VudHJpZXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdCYWdnYWdlO1xuICB9O1xuICBCYWdnYWdlSW1wbDIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBCYWdnYWdlSW1wbDIoKTtcbiAgfTtcbiAgcmV0dXJuIEJhZ2dhZ2VJbXBsMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9iYWdnYWdlL2ludGVybmFsL3N5bWJvbC5qc1xudmFyIGJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sID0gU3ltYm9sKFwiQmFnZ2FnZUVudHJ5TWV0YWRhdGFcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS91dGlscy5qc1xudmFyIGRpYWcgPSBEaWFnQVBJLmluc3RhbmNlKCk7XG5mdW5jdGlvbiBjcmVhdGVCYWdnYWdlKGVudHJpZXMpIHtcbiAgaWYgKGVudHJpZXMgPT09IHZvaWQgMCkge1xuICAgIGVudHJpZXMgPSB7fTtcbiAgfVxuICByZXR1cm4gbmV3IEJhZ2dhZ2VJbXBsKG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZW50cmllcykpKTtcbn1cbl9fbmFtZShjcmVhdGVCYWdnYWdlLCBcImNyZWF0ZUJhZ2dhZ2VcIik7XG5mdW5jdGlvbiBiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgZGlhZy5lcnJvcihcIkNhbm5vdCBjcmVhdGUgYmFnZ2FnZSBtZXRhZGF0YSBmcm9tIHVua25vd24gdHlwZTogXCIgKyB0eXBlb2Ygc3RyKTtcbiAgICBzdHIgPSBcIlwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgX19UWVBFX186IGJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xufVxuX19uYW1lKGJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZywgXCJiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmdcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vZGlhZy9jb25zb2xlTG9nZ2VyLmpzXG52YXIgY29uc29sZU1hcCA9IFtcbiAgeyBuOiBcImVycm9yXCIsIGM6IFwiZXJyb3JcIiB9LFxuICB7IG46IFwid2FyblwiLCBjOiBcIndhcm5cIiB9LFxuICB7IG46IFwiaW5mb1wiLCBjOiBcImluZm9cIiB9LFxuICB7IG46IFwiZGVidWdcIiwgYzogXCJkZWJ1Z1wiIH0sXG4gIHsgbjogXCJ2ZXJib3NlXCIsIGM6IFwidHJhY2VcIiB9XG5dO1xudmFyIERpYWdDb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIERpYWdDb25zb2xlTG9nZ2VyMigpIHtcbiAgICBmdW5jdGlvbiBfY29uc29sZUZ1bmMoZnVuY05hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgICB2YXIgdGhlRnVuYyA9IGNvbnNvbGVbZnVuY05hbWVdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlRnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGVGdW5jID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdGhlRnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlRnVuYy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShfY29uc29sZUZ1bmMsIFwiX2NvbnNvbGVGdW5jXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc29sZU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tjb25zb2xlTWFwW2ldLm5dID0gX2NvbnNvbGVGdW5jKGNvbnNvbGVNYXBbaV0uYyk7XG4gICAgfVxuICB9XG4gIF9fbmFtZShEaWFnQ29uc29sZUxvZ2dlcjIsIFwiRGlhZ0NvbnNvbGVMb2dnZXJcIik7XG4gIHJldHVybiBEaWFnQ29uc29sZUxvZ2dlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcHJvcGFnYXRpb24vVGV4dE1hcFByb3BhZ2F0b3IuanNcbnZhciBkZWZhdWx0VGV4dE1hcEdldHRlciA9IHtcbiAgZ2V0OiBmdW5jdGlvbihjYXJyaWVyLCBrZXkpIHtcbiAgICBpZiAoY2FycmllciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gY2FycmllcltrZXldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbihjYXJyaWVyKSB7XG4gICAgaWYgKGNhcnJpZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY2Fycmllcik7XG4gIH1cbn07XG52YXIgZGVmYXVsdFRleHRNYXBTZXR0ZXIgPSB7XG4gIHNldDogZnVuY3Rpb24oY2Fycmllciwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChjYXJyaWVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FycmllcltrZXldID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vY29udGV4dC9jb250ZXh0LmpzXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0S2V5KGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBTeW1ib2wuZm9yKGRlc2NyaXB0aW9uKTtcbn1cbl9fbmFtZShjcmVhdGVDb250ZXh0S2V5LCBcImNyZWF0ZUNvbnRleHRLZXlcIik7XG52YXIgQmFzZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmFzZUNvbnRleHQyKHBhcmVudENvbnRleHQpIHtcbiAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgIHNlbGYyLl9jdXJyZW50Q29udGV4dCA9IHBhcmVudENvbnRleHQgPyBuZXcgTWFwKHBhcmVudENvbnRleHQpIDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzZWxmMi5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHNlbGYyLl9jdXJyZW50Q29udGV4dC5nZXQoa2V5KTtcbiAgICB9O1xuICAgIHNlbGYyLnNldFZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGNvbnRleHQzID0gbmV3IEJhc2VDb250ZXh0MihzZWxmMi5fY3VycmVudENvbnRleHQpO1xuICAgICAgY29udGV4dDMuX2N1cnJlbnRDb250ZXh0LnNldChrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250ZXh0MztcbiAgICB9O1xuICAgIHNlbGYyLmRlbGV0ZVZhbHVlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY29udGV4dDMgPSBuZXcgQmFzZUNvbnRleHQyKHNlbGYyLl9jdXJyZW50Q29udGV4dCk7XG4gICAgICBjb250ZXh0My5fY3VycmVudENvbnRleHQuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gY29udGV4dDM7XG4gICAgfTtcbiAgfVxuICBfX25hbWUoQmFzZUNvbnRleHQyLCBcIkJhc2VDb250ZXh0XCIpO1xuICByZXR1cm4gQmFzZUNvbnRleHQyO1xufSgpO1xudmFyIFJPT1RfQ09OVEVYVCA9IG5ldyBCYXNlQ29udGV4dCgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2NvbnRleHQvTm9vcENvbnRleHRNYW5hZ2VyLmpzXG52YXIgX19zcHJlYWRBcnJheSA9IGZ1bmN0aW9uKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgcmV0dXJuIHRvO1xufTtcbnZhciBOb29wQ29udGV4dE1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTm9vcENvbnRleHRNYW5hZ2VyMigpIHtcbiAgfVxuICBfX25hbWUoTm9vcENvbnRleHRNYW5hZ2VyMiwgXCJOb29wQ29udGV4dE1hbmFnZXJcIik7XG4gIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBST09UX0NPTlRFWFQ7XG4gIH07XG4gIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLndpdGggPSBmdW5jdGlvbihfY29udGV4dCwgZm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uY2FsbC5hcHBseShmbiwgX19zcHJlYWRBcnJheShbdGhpc0FyZ10sIGFyZ3MpKTtcbiAgfTtcbiAgTm9vcENvbnRleHRNYW5hZ2VyMi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKF9jb250ZXh0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICBOb29wQ29udGV4dE1hbmFnZXIyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9vcENvbnRleHRNYW5hZ2VyMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4gTm9vcENvbnRleHRNYW5hZ2VyMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvY29udGV4dC5qc1xudmFyIF9fc3ByZWFkQXJyYXkyID0gZnVuY3Rpb24odG8sIGZyb20pIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgdG9bal0gPSBmcm9tW2ldO1xuICByZXR1cm4gdG87XG59O1xudmFyIEFQSV9OQU1FMiA9IFwiY29udGV4dFwiO1xudmFyIE5PT1BfQ09OVEVYVF9NQU5BR0VSID0gbmV3IE5vb3BDb250ZXh0TWFuYWdlcigpO1xudmFyIENvbnRleHRBUEkgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQ29udGV4dEFQSTIoKSB7XG4gIH1cbiAgX19uYW1lKENvbnRleHRBUEkyLCBcIkNvbnRleHRBUElcIik7XG4gIENvbnRleHRBUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgQ29udGV4dEFQSTIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUuc2V0R2xvYmFsQ29udGV4dE1hbmFnZXIgPSBmdW5jdGlvbihjb250ZXh0TWFuYWdlcikge1xuICAgIHJldHVybiByZWdpc3Rlckdsb2JhbChBUElfTkFNRTIsIGNvbnRleHRNYW5hZ2VyLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYWN0aXZlKCk7XG4gIH07XG4gIENvbnRleHRBUEkyLnByb3RvdHlwZS53aXRoID0gZnVuY3Rpb24oY29udGV4dDMsIGZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIF9hMztcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKF9hMyA9IHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkpLndpdGguYXBwbHkoX2EzLCBfX3NwcmVhZEFycmF5MihbY29udGV4dDMsIGZuLCB0aGlzQXJnXSwgYXJncykpO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGNvbnRleHQzLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dE1hbmFnZXIoKS5iaW5kKGNvbnRleHQzLCB0YXJnZXQpO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUuX2dldENvbnRleHRNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbChBUElfTkFNRTIpIHx8IE5PT1BfQ09OVEVYVF9NQU5BR0VSO1xuICB9O1xuICBDb250ZXh0QVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuZGlzYWJsZSgpO1xuICAgIHVucmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUyLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICB9O1xuICByZXR1cm4gQ29udGV4dEFQSTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvdHJhY2VfZmxhZ3MuanNcbnZhciBUcmFjZUZsYWdzO1xuKGZ1bmN0aW9uKFRyYWNlRmxhZ3MyKSB7XG4gIFRyYWNlRmxhZ3MyW1RyYWNlRmxhZ3MyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFRyYWNlRmxhZ3MyW1RyYWNlRmxhZ3MyW1wiU0FNUExFRFwiXSA9IDFdID0gXCJTQU1QTEVEXCI7XG59KShUcmFjZUZsYWdzIHx8IChUcmFjZUZsYWdzID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9pbnZhbGlkLXNwYW4tY29uc3RhbnRzLmpzXG52YXIgSU5WQUxJRF9TUEFOSUQgPSBcIjAwMDAwMDAwMDAwMDAwMDBcIjtcbnZhciBJTlZBTElEX1RSQUNFSUQgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG52YXIgSU5WQUxJRF9TUEFOX0NPTlRFWFQgPSB7XG4gIHRyYWNlSWQ6IElOVkFMSURfVFJBQ0VJRCxcbiAgc3BhbklkOiBJTlZBTElEX1NQQU5JRCxcbiAgdHJhY2VGbGFnczogVHJhY2VGbGFncy5OT05FXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vblJlY29yZGluZ1NwYW4uanNcbnZhciBOb25SZWNvcmRpbmdTcGFuID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE5vblJlY29yZGluZ1NwYW4yKF9zcGFuQ29udGV4dCkge1xuICAgIGlmIChfc3BhbkNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgX3NwYW5Db250ZXh0ID0gSU5WQUxJRF9TUEFOX0NPTlRFWFQ7XG4gICAgfVxuICAgIHRoaXMuX3NwYW5Db250ZXh0ID0gX3NwYW5Db250ZXh0O1xuICB9XG4gIF9fbmFtZShOb25SZWNvcmRpbmdTcGFuMiwgXCJOb25SZWNvcmRpbmdTcGFuXCIpO1xuICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUuc3BhbkNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhbkNvbnRleHQ7XG4gIH07XG4gIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihfa2V5LCBfdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihfYXR0cmlidXRlcykge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihfbmFtZSwgX2F0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uKF9zdGF0dXMpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnVwZGF0ZU5hbWUgPSBmdW5jdGlvbihfbmFtZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oX2VuZFRpbWUpIHtcbiAgfTtcbiAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUucmVjb3JkRXhjZXB0aW9uID0gZnVuY3Rpb24oX2V4Y2VwdGlvbiwgX3RpbWUpIHtcbiAgfTtcbiAgcmV0dXJuIE5vblJlY29yZGluZ1NwYW4yO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL2NvbnRleHQtdXRpbHMuanNcbnZhciBTUEFOX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoXCJPcGVuVGVsZW1ldHJ5IENvbnRleHQgS2V5IFNQQU5cIik7XG5mdW5jdGlvbiBnZXRTcGFuKGNvbnRleHQzKSB7XG4gIHJldHVybiBjb250ZXh0My5nZXRWYWx1ZShTUEFOX0tFWSkgfHwgdm9pZCAwO1xufVxuX19uYW1lKGdldFNwYW4sIFwiZ2V0U3BhblwiKTtcbmZ1bmN0aW9uIHNldFNwYW4oY29udGV4dDMsIHNwYW4pIHtcbiAgcmV0dXJuIGNvbnRleHQzLnNldFZhbHVlKFNQQU5fS0VZLCBzcGFuKTtcbn1cbl9fbmFtZShzZXRTcGFuLCBcInNldFNwYW5cIik7XG5mdW5jdGlvbiBkZWxldGVTcGFuKGNvbnRleHQzKSB7XG4gIHJldHVybiBjb250ZXh0My5kZWxldGVWYWx1ZShTUEFOX0tFWSk7XG59XG5fX25hbWUoZGVsZXRlU3BhbiwgXCJkZWxldGVTcGFuXCIpO1xuZnVuY3Rpb24gc2V0U3BhbkNvbnRleHQoY29udGV4dDMsIHNwYW5Db250ZXh0KSB7XG4gIHJldHVybiBzZXRTcGFuKGNvbnRleHQzLCBuZXcgTm9uUmVjb3JkaW5nU3BhbihzcGFuQ29udGV4dCkpO1xufVxuX19uYW1lKHNldFNwYW5Db250ZXh0LCBcInNldFNwYW5Db250ZXh0XCIpO1xuZnVuY3Rpb24gZ2V0U3BhbkNvbnRleHQoY29udGV4dDMpIHtcbiAgdmFyIF9hMztcbiAgcmV0dXJuIChfYTMgPSBnZXRTcGFuKGNvbnRleHQzKSkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMuc3BhbkNvbnRleHQoKTtcbn1cbl9fbmFtZShnZXRTcGFuQ29udGV4dCwgXCJnZXRTcGFuQ29udGV4dFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9zcGFuY29udGV4dC11dGlscy5qc1xudmFyIFZBTElEX1RSQUNFSURfUkVHRVggPSAvXihbMC05YS1mXXszMn0pJC9pO1xudmFyIFZBTElEX1NQQU5JRF9SRUdFWCA9IC9eWzAtOWEtZl17MTZ9JC9pO1xuZnVuY3Rpb24gaXNWYWxpZFRyYWNlSWQodHJhY2VJZCkge1xuICByZXR1cm4gVkFMSURfVFJBQ0VJRF9SRUdFWC50ZXN0KHRyYWNlSWQpICYmIHRyYWNlSWQgIT09IElOVkFMSURfVFJBQ0VJRDtcbn1cbl9fbmFtZShpc1ZhbGlkVHJhY2VJZCwgXCJpc1ZhbGlkVHJhY2VJZFwiKTtcbmZ1bmN0aW9uIGlzVmFsaWRTcGFuSWQoc3BhbklkKSB7XG4gIHJldHVybiBWQUxJRF9TUEFOSURfUkVHRVgudGVzdChzcGFuSWQpICYmIHNwYW5JZCAhPT0gSU5WQUxJRF9TUEFOSUQ7XG59XG5fX25hbWUoaXNWYWxpZFNwYW5JZCwgXCJpc1ZhbGlkU3BhbklkXCIpO1xuZnVuY3Rpb24gaXNTcGFuQ29udGV4dFZhbGlkKHNwYW5Db250ZXh0KSB7XG4gIHJldHVybiBpc1ZhbGlkVHJhY2VJZChzcGFuQ29udGV4dC50cmFjZUlkKSAmJiBpc1ZhbGlkU3BhbklkKHNwYW5Db250ZXh0LnNwYW5JZCk7XG59XG5fX25hbWUoaXNTcGFuQ29udGV4dFZhbGlkLCBcImlzU3BhbkNvbnRleHRWYWxpZFwiKTtcbmZ1bmN0aW9uIHdyYXBTcGFuQ29udGV4dChzcGFuQ29udGV4dCkge1xuICByZXR1cm4gbmV3IE5vblJlY29yZGluZ1NwYW4oc3BhbkNvbnRleHQpO1xufVxuX19uYW1lKHdyYXBTcGFuQ29udGV4dCwgXCJ3cmFwU3BhbkNvbnRleHRcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvTm9vcFRyYWNlci5qc1xudmFyIGNvbnRleHQgPSBDb250ZXh0QVBJLmdldEluc3RhbmNlKCk7XG52YXIgTm9vcFRyYWNlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBOb29wVHJhY2VyMigpIHtcbiAgfVxuICBfX25hbWUoTm9vcFRyYWNlcjIsIFwiTm9vcFRyYWNlclwiKTtcbiAgTm9vcFRyYWNlcjIucHJvdG90eXBlLnN0YXJ0U3BhbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQzKSB7XG4gICAgdmFyIHJvb3QgPSBCb29sZWFuKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb290KTtcbiAgICBpZiAocm9vdCkge1xuICAgICAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKCk7XG4gICAgfVxuICAgIHZhciBwYXJlbnRGcm9tQ29udGV4dCA9IGNvbnRleHQzICYmIGdldFNwYW5Db250ZXh0KGNvbnRleHQzKTtcbiAgICBpZiAoaXNTcGFuQ29udGV4dChwYXJlbnRGcm9tQ29udGV4dCkgJiYgaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudEZyb21Db250ZXh0KSkge1xuICAgICAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKHBhcmVudEZyb21Db250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKCk7XG4gICAgfVxuICB9O1xuICBOb29wVHJhY2VyMi5wcm90b3R5cGUuc3RhcnRBY3RpdmVTcGFuID0gZnVuY3Rpb24obmFtZSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBvcHRzO1xuICAgIHZhciBjdHg7XG4gICAgdmFyIGZuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgZm4gPSBhcmcyO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgb3B0cyA9IGFyZzI7XG4gICAgICBmbiA9IGFyZzM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMgPSBhcmcyO1xuICAgICAgY3R4ID0gYXJnMztcbiAgICAgIGZuID0gYXJnNDtcbiAgICB9XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSBjdHggIT09IG51bGwgJiYgY3R4ICE9PSB2b2lkIDAgPyBjdHggOiBjb250ZXh0LmFjdGl2ZSgpO1xuICAgIHZhciBzcGFuID0gdGhpcy5zdGFydFNwYW4obmFtZSwgb3B0cywgcGFyZW50Q29udGV4dCk7XG4gICAgdmFyIGNvbnRleHRXaXRoU3BhblNldCA9IHNldFNwYW4ocGFyZW50Q29udGV4dCwgc3Bhbik7XG4gICAgcmV0dXJuIGNvbnRleHQud2l0aChjb250ZXh0V2l0aFNwYW5TZXQsIGZuLCB2b2lkIDAsIHNwYW4pO1xuICB9O1xuICByZXR1cm4gTm9vcFRyYWNlcjI7XG59KCk7XG5mdW5jdGlvbiBpc1NwYW5Db250ZXh0KHNwYW5Db250ZXh0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3BhbkNvbnRleHQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHNwYW5Db250ZXh0W1wic3BhbklkXCJdID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzcGFuQ29udGV4dFtcInRyYWNlSWRcIl0gPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNwYW5Db250ZXh0W1widHJhY2VGbGFnc1wiXSA9PT0gXCJudW1iZXJcIjtcbn1cbl9fbmFtZShpc1NwYW5Db250ZXh0LCBcImlzU3BhbkNvbnRleHRcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvUHJveHlUcmFjZXIuanNcbnZhciBOT09QX1RSQUNFUiA9IG5ldyBOb29wVHJhY2VyKCk7XG52YXIgUHJveHlUcmFjZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUHJveHlUcmFjZXIyKF9wcm92aWRlciwgbmFtZSwgdmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMuX3Byb3ZpZGVyID0gX3Byb3ZpZGVyO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIF9fbmFtZShQcm94eVRyYWNlcjIsIFwiUHJveHlUcmFjZXJcIik7XG4gIFByb3h5VHJhY2VyMi5wcm90b3R5cGUuc3RhcnRTcGFuID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgY29udGV4dDMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VHJhY2VyKCkuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQzKTtcbiAgfTtcbiAgUHJveHlUcmFjZXIyLnByb3RvdHlwZS5zdGFydEFjdGl2ZVNwYW4gPSBmdW5jdGlvbihfbmFtZSwgX29wdGlvbnMsIF9jb250ZXh0LCBfZm4pIHtcbiAgICB2YXIgdHJhY2VyID0gdGhpcy5fZ2V0VHJhY2VyKCk7XG4gICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodHJhY2VyLnN0YXJ0QWN0aXZlU3BhbiwgdHJhY2VyLCBhcmd1bWVudHMpO1xuICB9O1xuICBQcm94eVRyYWNlcjIucHJvdG90eXBlLl9nZXRUcmFjZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZTtcbiAgICB9XG4gICAgdmFyIHRyYWNlciA9IHRoaXMuX3Byb3ZpZGVyLmdldERlbGVnYXRlVHJhY2VyKHRoaXMubmFtZSwgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmICghdHJhY2VyKSB7XG4gICAgICByZXR1cm4gTk9PUF9UUkFDRVI7XG4gICAgfVxuICAgIHRoaXMuX2RlbGVnYXRlID0gdHJhY2VyO1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZTtcbiAgfTtcbiAgcmV0dXJuIFByb3h5VHJhY2VyMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9Ob29wVHJhY2VyUHJvdmlkZXIuanNcbnZhciBOb29wVHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTm9vcFRyYWNlclByb3ZpZGVyMigpIHtcbiAgfVxuICBfX25hbWUoTm9vcFRyYWNlclByb3ZpZGVyMiwgXCJOb29wVHJhY2VyUHJvdmlkZXJcIik7XG4gIE5vb3BUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldFRyYWNlciA9IGZ1bmN0aW9uKF9uYW1lLCBfdmVyc2lvbiwgX29wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE5vb3BUcmFjZXIoKTtcbiAgfTtcbiAgcmV0dXJuIE5vb3BUcmFjZXJQcm92aWRlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvUHJveHlUcmFjZXJQcm92aWRlci5qc1xudmFyIE5PT1BfVFJBQ0VSX1BST1ZJREVSID0gbmV3IE5vb3BUcmFjZXJQcm92aWRlcigpO1xudmFyIFByb3h5VHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUHJveHlUcmFjZXJQcm92aWRlcjIoKSB7XG4gIH1cbiAgX19uYW1lKFByb3h5VHJhY2VyUHJvdmlkZXIyLCBcIlByb3h5VHJhY2VyUHJvdmlkZXJcIik7XG4gIFByb3h5VHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXRUcmFjZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hMztcbiAgICByZXR1cm4gKF9hMyA9IHRoaXMuZ2V0RGVsZWdhdGVUcmFjZXIobmFtZSwgdmVyc2lvbiwgb3B0aW9ucykpICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogbmV3IFByb3h5VHJhY2VyKHRoaXMsIG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpO1xuICB9O1xuICBQcm94eVRyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuZ2V0RGVsZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EzO1xuICAgIHJldHVybiAoX2EzID0gdGhpcy5fZGVsZWdhdGUpICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogTk9PUF9UUkFDRVJfUFJPVklERVI7XG4gIH07XG4gIFByb3h5VHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5zZXREZWxlZ2F0ZSA9IGZ1bmN0aW9uKGRlbGVnYXRlKSB7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgfTtcbiAgUHJveHlUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldERlbGVnYXRlVHJhY2VyID0gZnVuY3Rpb24obmFtZSwgdmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLl9kZWxlZ2F0ZSkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMuZ2V0VHJhY2VyKG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gUHJveHlUcmFjZXJQcm92aWRlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvU2FtcGxpbmdSZXN1bHQuanNcbnZhciBTYW1wbGluZ0RlY2lzaW9uO1xuKGZ1bmN0aW9uKFNhbXBsaW5nRGVjaXNpb24zKSB7XG4gIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiTk9UX1JFQ09SRFwiXSA9IDBdID0gXCJOT1RfUkVDT1JEXCI7XG4gIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiUkVDT1JEXCJdID0gMV0gPSBcIlJFQ09SRFwiO1xuICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIlJFQ09SRF9BTkRfU0FNUExFRFwiXSA9IDJdID0gXCJSRUNPUkRfQU5EX1NBTVBMRURcIjtcbn0pKFNhbXBsaW5nRGVjaXNpb24gfHwgKFNhbXBsaW5nRGVjaXNpb24gPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3NwYW5fa2luZC5qc1xudmFyIFNwYW5LaW5kO1xuKGZ1bmN0aW9uKFNwYW5LaW5kMikge1xuICBTcGFuS2luZDJbU3BhbktpbmQyW1wiSU5URVJOQUxcIl0gPSAwXSA9IFwiSU5URVJOQUxcIjtcbiAgU3BhbktpbmQyW1NwYW5LaW5kMltcIlNFUlZFUlwiXSA9IDFdID0gXCJTRVJWRVJcIjtcbiAgU3BhbktpbmQyW1NwYW5LaW5kMltcIkNMSUVOVFwiXSA9IDJdID0gXCJDTElFTlRcIjtcbiAgU3BhbktpbmQyW1NwYW5LaW5kMltcIlBST0RVQ0VSXCJdID0gM10gPSBcIlBST0RVQ0VSXCI7XG4gIFNwYW5LaW5kMltTcGFuS2luZDJbXCJDT05TVU1FUlwiXSA9IDRdID0gXCJDT05TVU1FUlwiO1xufSkoU3BhbktpbmQgfHwgKFNwYW5LaW5kID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9zdGF0dXMuanNcbnZhciBTcGFuU3RhdHVzQ29kZTtcbihmdW5jdGlvbihTcGFuU3RhdHVzQ29kZTIpIHtcbiAgU3BhblN0YXR1c0NvZGUyW1NwYW5TdGF0dXNDb2RlMltcIlVOU0VUXCJdID0gMF0gPSBcIlVOU0VUXCI7XG4gIFNwYW5TdGF0dXNDb2RlMltTcGFuU3RhdHVzQ29kZTJbXCJPS1wiXSA9IDFdID0gXCJPS1wiO1xuICBTcGFuU3RhdHVzQ29kZTJbU3BhblN0YXR1c0NvZGUyW1wiRVJST1JcIl0gPSAyXSA9IFwiRVJST1JcIjtcbn0pKFNwYW5TdGF0dXNDb2RlIHx8IChTcGFuU3RhdHVzQ29kZSA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW50ZXJuYWwvdHJhY2VzdGF0ZS12YWxpZGF0b3JzLmpzXG52YXIgVkFMSURfS0VZX0NIQVJfUkFOR0UgPSBcIltfMC05YS16LSovXVwiO1xudmFyIFZBTElEX0tFWSA9IFwiW2Etel1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFICsgXCJ7MCwyNTV9XCI7XG52YXIgVkFMSURfVkVORE9SX0tFWSA9IFwiW2EtejAtOV1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFICsgXCJ7MCwyNDB9QFthLXpdXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRSArIFwiezAsMTN9XCI7XG52YXIgVkFMSURfS0VZX1JFR0VYID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIFZBTElEX0tFWSArIFwifFwiICsgVkFMSURfVkVORE9SX0tFWSArIFwiKSRcIik7XG52YXIgVkFMSURfVkFMVUVfQkFTRV9SRUdFWCA9IC9eWyAtfl17MCwyNTV9WyEtfl0kLztcbnZhciBJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYID0gLyx8PS87XG5mdW5jdGlvbiB2YWxpZGF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIFZBTElEX0tFWV9SRUdFWC50ZXN0KGtleSk7XG59XG5fX25hbWUodmFsaWRhdGVLZXksIFwidmFsaWRhdGVLZXlcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBWQUxJRF9WQUxVRV9CQVNFX1JFR0VYLnRlc3QodmFsdWUpICYmICFJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuX19uYW1lKHZhbGlkYXRlVmFsdWUsIFwidmFsaWRhdGVWYWx1ZVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9pbnRlcm5hbC90cmFjZXN0YXRlLWltcGwuanNcbnZhciBNQVhfVFJBQ0VfU1RBVEVfSVRFTVMgPSAzMjtcbnZhciBNQVhfVFJBQ0VfU1RBVEVfTEVOID0gNTEyO1xudmFyIExJU1RfTUVNQkVSU19TRVBBUkFUT1IgPSBcIixcIjtcbnZhciBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIgPSBcIj1cIjtcbnZhciBUcmFjZVN0YXRlSW1wbCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmFjZVN0YXRlSW1wbDIocmF3VHJhY2VTdGF0ZSkge1xuICAgIHRoaXMuX2ludGVybmFsU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChyYXdUcmFjZVN0YXRlKVxuICAgICAgdGhpcy5fcGFyc2UocmF3VHJhY2VTdGF0ZSk7XG4gIH1cbiAgX19uYW1lKFRyYWNlU3RhdGVJbXBsMiwgXCJUcmFjZVN0YXRlSW1wbFwiKTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHRyYWNlU3RhdGUgPSB0aGlzLl9jbG9uZSgpO1xuICAgIGlmICh0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgfTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiB0cmFjZVN0YXRlO1xuICB9O1xuICBUcmFjZVN0YXRlSW1wbDIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlLmdldChrZXkpO1xuICB9O1xuICBUcmFjZVN0YXRlSW1wbDIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuX2tleXMoKS5yZWR1Y2UoZnVuY3Rpb24oYWdnLCBrZXkpIHtcbiAgICAgIGFnZy5wdXNoKGtleSArIExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUiArIF90aGlzLmdldChrZXkpKTtcbiAgICAgIHJldHVybiBhZ2c7XG4gICAgfSwgW10pLmpvaW4oTElTVF9NRU1CRVJTX1NFUEFSQVRPUik7XG4gIH07XG4gIFRyYWNlU3RhdGVJbXBsMi5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24ocmF3VHJhY2VTdGF0ZSkge1xuICAgIGlmIChyYXdUcmFjZVN0YXRlLmxlbmd0aCA+IE1BWF9UUkFDRV9TVEFURV9MRU4pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IHJhd1RyYWNlU3RhdGUuc3BsaXQoTElTVF9NRU1CRVJTX1NFUEFSQVRPUikucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbihhZ2csIHBhcnQpIHtcbiAgICAgIHZhciBsaXN0TWVtYmVyID0gcGFydC50cmltKCk7XG4gICAgICB2YXIgaSA9IGxpc3RNZW1iZXIuaW5kZXhPZihMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIHZhciBrZXkgPSBsaXN0TWVtYmVyLnNsaWNlKDAsIGkpO1xuICAgICAgICB2YXIgdmFsdWUgPSBsaXN0TWVtYmVyLnNsaWNlKGkgKyAxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgIGlmICh2YWxpZGF0ZUtleShrZXkpICYmIHZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgYWdnLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFnZztcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBpZiAodGhpcy5faW50ZXJuYWxTdGF0ZS5zaXplID4gTUFYX1RSQUNFX1NUQVRFX0lURU1TKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUuZW50cmllcygpKS5yZXZlcnNlKCkuc2xpY2UoMCwgTUFYX1RSQUNFX1NUQVRFX0lURU1TKSk7XG4gICAgfVxuICB9O1xuICBUcmFjZVN0YXRlSW1wbDIucHJvdG90eXBlLl9rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5faW50ZXJuYWxTdGF0ZS5rZXlzKCkpLnJldmVyc2UoKTtcbiAgfTtcbiAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhY2VTdGF0ZSA9IG5ldyBUcmFjZVN0YXRlSW1wbDIoKTtcbiAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcCh0aGlzLl9pbnRlcm5hbFN0YXRlKTtcbiAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgfTtcbiAgcmV0dXJuIFRyYWNlU3RhdGVJbXBsMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvdHJhY2UuanNcbnZhciBBUElfTkFNRTMgPSBcInRyYWNlXCI7XG52YXIgVHJhY2VBUEkgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVHJhY2VBUEkyKCkge1xuICAgIHRoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXIgPSBuZXcgUHJveHlUcmFjZXJQcm92aWRlcigpO1xuICAgIHRoaXMud3JhcFNwYW5Db250ZXh0ID0gd3JhcFNwYW5Db250ZXh0O1xuICAgIHRoaXMuaXNTcGFuQ29udGV4dFZhbGlkID0gaXNTcGFuQ29udGV4dFZhbGlkO1xuICAgIHRoaXMuZGVsZXRlU3BhbiA9IGRlbGV0ZVNwYW47XG4gICAgdGhpcy5nZXRTcGFuID0gZ2V0U3BhbjtcbiAgICB0aGlzLmdldFNwYW5Db250ZXh0ID0gZ2V0U3BhbkNvbnRleHQ7XG4gICAgdGhpcy5zZXRTcGFuID0gc2V0U3BhbjtcbiAgICB0aGlzLnNldFNwYW5Db250ZXh0ID0gc2V0U3BhbkNvbnRleHQ7XG4gIH1cbiAgX19uYW1lKFRyYWNlQVBJMiwgXCJUcmFjZUFQSVwiKTtcbiAgVHJhY2VBUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgVHJhY2VBUEkyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfTtcbiAgVHJhY2VBUEkyLnByb3RvdHlwZS5zZXRHbG9iYWxUcmFjZXJQcm92aWRlciA9IGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gICAgdmFyIHN1Y2Nlc3MgPSByZWdpc3Rlckdsb2JhbChBUElfTkFNRTMsIHRoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXIsIERpYWdBUEkuaW5zdGFuY2UoKSk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXIuc2V0RGVsZWdhdGUocHJvdmlkZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfTtcbiAgVHJhY2VBUEkyLnByb3RvdHlwZS5nZXRUcmFjZXJQcm92aWRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWwoQVBJX05BTUUzKSB8fCB0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyO1xuICB9O1xuICBUcmFjZUFQSTIucHJvdG90eXBlLmdldFRyYWNlciA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUcmFjZXJQcm92aWRlcigpLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uKTtcbiAgfTtcbiAgVHJhY2VBUEkyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgdW5yZWdpc3Rlckdsb2JhbChBUElfTkFNRTMsIERpYWdBUEkuaW5zdGFuY2UoKSk7XG4gICAgdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlciA9IG5ldyBQcm94eVRyYWNlclByb3ZpZGVyKCk7XG4gIH07XG4gIHJldHVybiBUcmFjZUFQSTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcHJvcGFnYXRpb24vTm9vcFRleHRNYXBQcm9wYWdhdG9yLmpzXG52YXIgTm9vcFRleHRNYXBQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE5vb3BUZXh0TWFwUHJvcGFnYXRvcjIoKSB7XG4gIH1cbiAgX19uYW1lKE5vb3BUZXh0TWFwUHJvcGFnYXRvcjIsIFwiTm9vcFRleHRNYXBQcm9wYWdhdG9yXCIpO1xuICBOb29wVGV4dE1hcFByb3BhZ2F0b3IyLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbihfY29udGV4dCwgX2NhcnJpZXIpIHtcbiAgfTtcbiAgTm9vcFRleHRNYXBQcm9wYWdhdG9yMi5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGNvbnRleHQzLCBfY2Fycmllcikge1xuICAgIHJldHVybiBjb250ZXh0MztcbiAgfTtcbiAgTm9vcFRleHRNYXBQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuICByZXR1cm4gTm9vcFRleHRNYXBQcm9wYWdhdG9yMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9iYWdnYWdlL2NvbnRleHQtaGVscGVycy5qc1xudmFyIEJBR0dBR0VfS0VZID0gY3JlYXRlQ29udGV4dEtleShcIk9wZW5UZWxlbWV0cnkgQmFnZ2FnZSBLZXlcIik7XG5mdW5jdGlvbiBnZXRCYWdnYWdlKGNvbnRleHQzKSB7XG4gIHJldHVybiBjb250ZXh0My5nZXRWYWx1ZShCQUdHQUdFX0tFWSkgfHwgdm9pZCAwO1xufVxuX19uYW1lKGdldEJhZ2dhZ2UsIFwiZ2V0QmFnZ2FnZVwiKTtcbmZ1bmN0aW9uIHNldEJhZ2dhZ2UoY29udGV4dDMsIGJhZ2dhZ2UpIHtcbiAgcmV0dXJuIGNvbnRleHQzLnNldFZhbHVlKEJBR0dBR0VfS0VZLCBiYWdnYWdlKTtcbn1cbl9fbmFtZShzZXRCYWdnYWdlLCBcInNldEJhZ2dhZ2VcIik7XG5mdW5jdGlvbiBkZWxldGVCYWdnYWdlKGNvbnRleHQzKSB7XG4gIHJldHVybiBjb250ZXh0My5kZWxldGVWYWx1ZShCQUdHQUdFX0tFWSk7XG59XG5fX25hbWUoZGVsZXRlQmFnZ2FnZSwgXCJkZWxldGVCYWdnYWdlXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2FwaS9wcm9wYWdhdGlvbi5qc1xudmFyIEFQSV9OQU1FNCA9IFwicHJvcGFnYXRpb25cIjtcbnZhciBOT09QX1RFWFRfTUFQX1BST1BBR0FUT1IgPSBuZXcgTm9vcFRleHRNYXBQcm9wYWdhdG9yKCk7XG52YXIgUHJvcGFnYXRpb25BUEkgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUHJvcGFnYXRpb25BUEkyKCkge1xuICAgIHRoaXMuY3JlYXRlQmFnZ2FnZSA9IGNyZWF0ZUJhZ2dhZ2U7XG4gICAgdGhpcy5nZXRCYWdnYWdlID0gZ2V0QmFnZ2FnZTtcbiAgICB0aGlzLnNldEJhZ2dhZ2UgPSBzZXRCYWdnYWdlO1xuICAgIHRoaXMuZGVsZXRlQmFnZ2FnZSA9IGRlbGV0ZUJhZ2dhZ2U7XG4gIH1cbiAgX19uYW1lKFByb3BhZ2F0aW9uQVBJMiwgXCJQcm9wYWdhdGlvbkFQSVwiKTtcbiAgUHJvcGFnYXRpb25BUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgUHJvcGFnYXRpb25BUEkyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfTtcbiAgUHJvcGFnYXRpb25BUEkyLnByb3RvdHlwZS5zZXRHbG9iYWxQcm9wYWdhdG9yID0gZnVuY3Rpb24ocHJvcGFnYXRvcikge1xuICAgIHJldHVybiByZWdpc3Rlckdsb2JhbChBUElfTkFNRTQsIHByb3BhZ2F0b3IsIERpYWdBUEkuaW5zdGFuY2UoKSk7XG4gIH07XG4gIFByb3BhZ2F0aW9uQVBJMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIGlmIChzZXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgc2V0dGVyID0gZGVmYXVsdFRleHRNYXBTZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRHbG9iYWxQcm9wYWdhdG9yKCkuaW5qZWN0KGNvbnRleHQzLCBjYXJyaWVyLCBzZXR0ZXIpO1xuICB9O1xuICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MywgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgaWYgKGdldHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBnZXR0ZXIgPSBkZWZhdWx0VGV4dE1hcEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldEdsb2JhbFByb3BhZ2F0b3IoKS5leHRyYWN0KGNvbnRleHQzLCBjYXJyaWVyLCBnZXR0ZXIpO1xuICB9O1xuICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRHbG9iYWxQcm9wYWdhdG9yKCkuZmllbGRzKCk7XG4gIH07XG4gIFByb3BhZ2F0aW9uQVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHVucmVnaXN0ZXJHbG9iYWwoQVBJX05BTUU0LCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICB9O1xuICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLl9nZXRHbG9iYWxQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbChBUElfTkFNRTQpIHx8IE5PT1BfVEVYVF9NQVBfUFJPUEFHQVRPUjtcbiAgfTtcbiAgcmV0dXJuIFByb3BhZ2F0aW9uQVBJMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9pbmRleC5qc1xudmFyIGNvbnRleHQyID0gQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpO1xudmFyIHRyYWNlID0gVHJhY2VBUEkuZ2V0SW5zdGFuY2UoKTtcbnZhciBwcm9wYWdhdGlvbiA9IFByb3BhZ2F0aW9uQVBJLmdldEluc3RhbmNlKCk7XG52YXIgZGlhZzIgPSBEaWFnQVBJLmluc3RhbmNlKCk7XG5cbi8vIC4uL2VuZ2luZXMvc3JjL2luZGV4LnRzXG52YXIgaW1wb3J0X2VuZ2luZXNfdmVyc2lvbiA9IF9fdG9FU00ocmVxdWlyZV9lbmdpbmVzX3ZlcnNpb24oKSk7XG5cbi8vIC4uL2dldC1wbGF0Zm9ybS9zcmMvZ2V0Tm9kZUFQSU5hbWUudHNcbnZhciBOT0RFX0FQSV9RVUVSWV9FTkdJTkVfVVJMX0JBU0UgPSBcImxpYnF1ZXJ5X2VuZ2luZVwiO1xuZnVuY3Rpb24gZ2V0Tm9kZUFQSU5hbWUocGxhdGZvcm0zLCB0eXBlKSB7XG4gIGNvbnN0IGlzVXJsID0gdHlwZSA9PT0gXCJ1cmxcIjtcbiAgaWYgKHBsYXRmb3JtMy5pbmNsdWRlcyhcIndpbmRvd3NcIikpIHtcbiAgICByZXR1cm4gaXNVcmwgPyBgcXVlcnlfZW5naW5lLmRsbC5ub2RlYCA6IGBxdWVyeV9lbmdpbmUtJHtwbGF0Zm9ybTN9LmRsbC5ub2RlYDtcbiAgfSBlbHNlIGlmIChwbGF0Zm9ybTMuaW5jbHVkZXMoXCJkYXJ3aW5cIikpIHtcbiAgICByZXR1cm4gaXNVcmwgPyBgJHtOT0RFX0FQSV9RVUVSWV9FTkdJTkVfVVJMX0JBU0V9LmR5bGliLm5vZGVgIDogYCR7Tk9ERV9BUElfUVVFUllfRU5HSU5FX1VSTF9CQVNFfS0ke3BsYXRmb3JtM30uZHlsaWIubm9kZWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzVXJsID8gYCR7Tk9ERV9BUElfUVVFUllfRU5HSU5FX1VSTF9CQVNFfS5zby5ub2RlYCA6IGAke05PREVfQVBJX1FVRVJZX0VOR0lORV9VUkxfQkFTRX0tJHtwbGF0Zm9ybTN9LnNvLm5vZGVgO1xuICB9XG59XG5fX25hbWUoZ2V0Tm9kZUFQSU5hbWUsIFwiZ2V0Tm9kZUFQSU5hbWVcIik7XG5cbi8vIC4uL2dldC1wbGF0Zm9ybS9zcmMvZ2V0UGxhdGZvcm0udHNcbnZhciBpbXBvcnRfY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xudmFyIGltcG9ydF9mcyA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfb3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJvc1wiKSk7XG52YXIgaW1wb3J0X3V0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbnZhciByZWFkRmlsZSA9ICgwLCBpbXBvcnRfdXRpbC5wcm9taXNpZnkpKGltcG9ydF9mcy5kZWZhdWx0LnJlYWRGaWxlKTtcbnZhciBleGlzdHMgPSAoMCwgaW1wb3J0X3V0aWwucHJvbWlzaWZ5KShpbXBvcnRfZnMuZGVmYXVsdC5leGlzdHMpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0b3MoKSB7XG4gIGNvbnN0IHBsYXRmb3JtMyA9IGltcG9ydF9vcy5kZWZhdWx0LnBsYXRmb3JtKCk7XG4gIGNvbnN0IGFyY2gyID0gcHJvY2Vzcy5hcmNoO1xuICBpZiAocGxhdGZvcm0zID09PSBcImZyZWVic2RcIikge1xuICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBncmFjZWZ1bEV4ZWMoYGZyZWVic2QtdmVyc2lvbmApO1xuICAgIGlmICh2ZXJzaW9uICYmIHZlcnNpb24udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL14oXFxkKylcXC4/LztcbiAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyh2ZXJzaW9uKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBsYXRmb3JtOiBcImZyZWVic2RcIixcbiAgICAgICAgICBkaXN0cm86IGBmcmVlYnNkJHttYXRjaFsxXX1gLFxuICAgICAgICAgIGFyY2g6IGFyY2gyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwbGF0Zm9ybTMgIT09IFwibGludXhcIikge1xuICAgIHJldHVybiB7XG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm0zLFxuICAgICAgYXJjaDogYXJjaDJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcGxhdGZvcm06IFwibGludXhcIixcbiAgICBsaWJzc2w6IGF3YWl0IGdldE9wZW5TU0xWZXJzaW9uKCksXG4gICAgZGlzdHJvOiBhd2FpdCByZXNvbHZlRGlzdHJvKCksXG4gICAgYXJjaDogYXJjaDJcbiAgfTtcbn1cbl9fbmFtZShnZXRvcywgXCJnZXRvc1wiKTtcbmZ1bmN0aW9uIHBhcnNlRGlzdHJvKGlucHV0KSB7XG4gIGNvbnN0IGlkUmVnZXggPSAvXklEPVwiPyhbXlwiXFxuXSopXCI/JC9pbTtcbiAgY29uc3QgaWRMaWtlUmVnZXggPSAvXklEX0xJS0U9XCI/KFteXCJcXG5dKilcIj8kL2ltO1xuICBjb25zdCBpZE1hdGNoID0gaWRSZWdleC5leGVjKGlucHV0KTtcbiAgY29uc3QgaWQgPSBpZE1hdGNoICYmIGlkTWF0Y2hbMV0gJiYgaWRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gIGNvbnN0IGlkTGlrZU1hdGNoID0gaWRMaWtlUmVnZXguZXhlYyhpbnB1dCk7XG4gIGNvbnN0IGlkTGlrZSA9IGlkTGlrZU1hdGNoICYmIGlkTGlrZU1hdGNoWzFdICYmIGlkTGlrZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgfHwgXCJcIjtcbiAgaWYgKGlkID09PSBcInJhc3BiaWFuXCIpIHtcbiAgICByZXR1cm4gXCJhcm1cIjtcbiAgfVxuICBpZiAoaWQgPT09IFwibml4b3NcIikge1xuICAgIHJldHVybiBcIm5peG9zXCI7XG4gIH1cbiAgaWYgKGlkTGlrZS5pbmNsdWRlcyhcImNlbnRvc1wiKSB8fCBpZExpa2UuaW5jbHVkZXMoXCJmZWRvcmFcIikgfHwgaWRMaWtlLmluY2x1ZGVzKFwicmhlbFwiKSB8fCBpZCA9PT0gXCJmZWRvcmFcIikge1xuICAgIHJldHVybiBcInJoZWxcIjtcbiAgfVxuICBpZiAoaWRMaWtlLmluY2x1ZGVzKFwiZGViaWFuXCIpIHx8IGlkTGlrZS5pbmNsdWRlcyhcInVidW50dVwiKSB8fCBpZCA9PT0gXCJkZWJpYW5cIikge1xuICAgIHJldHVybiBcImRlYmlhblwiO1xuICB9XG4gIHJldHVybjtcbn1cbl9fbmFtZShwYXJzZURpc3RybywgXCJwYXJzZURpc3Ryb1wiKTtcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEaXN0cm8oKSB7XG4gIGNvbnN0IG9zUmVsZWFzZUZpbGUgPSBcIi9ldGMvb3MtcmVsZWFzZVwiO1xuICBjb25zdCBhbHBpbmVSZWxlYXNlRmlsZSA9IFwiL2V0Yy9hbHBpbmUtcmVsZWFzZVwiO1xuICBpZiAoYXdhaXQgZXhpc3RzKGFscGluZVJlbGVhc2VGaWxlKSkge1xuICAgIHJldHVybiBcIm11c2xcIjtcbiAgfSBlbHNlIGlmIChhd2FpdCBleGlzdHMob3NSZWxlYXNlRmlsZSkpIHtcbiAgICByZXR1cm4gcGFyc2VEaXN0cm8oYXdhaXQgcmVhZEZpbGUob3NSZWxlYXNlRmlsZSwgXCJ1dGYtOFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5fX25hbWUocmVzb2x2ZURpc3RybywgXCJyZXNvbHZlRGlzdHJvXCIpO1xuZnVuY3Rpb24gcGFyc2VPcGVuU1NMVmVyc2lvbihpbnB1dCkge1xuICBjb25zdCBtYXRjaCA9IC9eT3BlblNTTFxccyhcXGQrXFwuXFxkKylcXC5cXGQrLy5leGVjKGlucHV0KTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoWzFdICsgXCIueFwiO1xuICB9XG4gIHJldHVybjtcbn1cbl9fbmFtZShwYXJzZU9wZW5TU0xWZXJzaW9uLCBcInBhcnNlT3BlblNTTFZlcnNpb25cIik7XG5hc3luYyBmdW5jdGlvbiBnZXRPcGVuU1NMVmVyc2lvbigpIHtcbiAgY29uc3QgW3ZlcnNpb24sIGxzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBncmFjZWZ1bEV4ZWMoYG9wZW5zc2wgdmVyc2lvbiAtdmApLFxuICAgIGdyYWNlZnVsRXhlYyhgXG4gICAgICBscyAtbCAvbGliNjQgfCBncmVwIHNzbDtcbiAgICAgIGxzIC1sIC91c3IvbGliNjQgfCBncmVwIHNzbDtcbiAgICBgKVxuICBdKTtcbiAgaWYgKHZlcnNpb24pIHtcbiAgICBjb25zdCB2ID0gcGFyc2VPcGVuU1NMVmVyc2lvbih2ZXJzaW9uKTtcbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG4gIGlmIChscykge1xuICAgIGNvbnN0IG1hdGNoID0gL2xpYnNzbFxcLnNvXFwuKFxcZCtcXC5cXGQrKVxcLlxcZCsvLmV4ZWMobHMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoWzFdICsgXCIueFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuX19uYW1lKGdldE9wZW5TU0xWZXJzaW9uLCBcImdldE9wZW5TU0xWZXJzaW9uXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ3JhY2VmdWxFeGVjKGNtZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0cnkge1xuICAgICAgKDAsIGltcG9ydF9jaGlsZF9wcm9jZXNzLmV4ZWMpKGNtZCwgKGVyciwgc3Rkb3V0KSA9PiB7XG4gICAgICAgIHJlc29sdmUoU3RyaW5nKHN0ZG91dCkpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSk7XG59XG5fX25hbWUoZ3JhY2VmdWxFeGVjLCBcImdyYWNlZnVsRXhlY1wiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBjb25zdCB7IHBsYXRmb3JtOiBwbGF0Zm9ybTMsIGxpYnNzbCwgZGlzdHJvLCBhcmNoOiBhcmNoMiB9ID0gYXdhaXQgZ2V0b3MoKTtcbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJkYXJ3aW5cIiAmJiBhcmNoMiA9PT0gXCJhcm02NFwiKSB7XG4gICAgcmV0dXJuIFwiZGFyd2luLWFybTY0XCI7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJkYXJ3aW5cIikge1xuICAgIHJldHVybiBcImRhcndpblwiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwid2luMzJcIikge1xuICAgIHJldHVybiBcIndpbmRvd3NcIjtcbiAgfVxuICBpZiAocGxhdGZvcm0zID09PSBcImZyZWVic2RcIikge1xuICAgIHJldHVybiBkaXN0cm87XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJvcGVuYnNkXCIpIHtcbiAgICByZXR1cm4gXCJvcGVuYnNkXCI7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJuZXRic2RcIikge1xuICAgIHJldHVybiBcIm5ldGJzZFwiO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibGludXhcIiAmJiBhcmNoMiA9PT0gXCJhcm02NFwiKSB7XG4gICAgcmV0dXJuIGBsaW51eC1hcm02NC1vcGVuc3NsLSR7bGlic3NsfWA7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJsaW51eFwiICYmIGFyY2gyID09PSBcImFybVwiKSB7XG4gICAgcmV0dXJuIGBsaW51eC1hcm0tb3BlbnNzbC0ke2xpYnNzbH1gO1xuICB9XG4gIGlmIChwbGF0Zm9ybTMgPT09IFwibGludXhcIiAmJiBkaXN0cm8gPT09IFwibml4b3NcIikge1xuICAgIHJldHVybiBcImxpbnV4LW5peG9zXCI7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJsaW51eFwiICYmIGRpc3RybyA9PT0gXCJtdXNsXCIpIHtcbiAgICByZXR1cm4gXCJsaW51eC1tdXNsXCI7XG4gIH1cbiAgaWYgKHBsYXRmb3JtMyA9PT0gXCJsaW51eFwiICYmIGRpc3RybyAmJiBsaWJzc2wpIHtcbiAgICByZXR1cm4gZGlzdHJvICsgXCItb3BlbnNzbC1cIiArIGxpYnNzbDtcbiAgfVxuICBpZiAobGlic3NsKSB7XG4gICAgcmV0dXJuIFwiZGViaWFuLW9wZW5zc2wtXCIgKyBsaWJzc2w7XG4gIH1cbiAgaWYgKGRpc3Rybykge1xuICAgIHJldHVybiBkaXN0cm8gKyBcIi1vcGVuc3NsLTEuMS54XCI7XG4gIH1cbiAgcmV0dXJuIFwiZGViaWFuLW9wZW5zc2wtMS4xLnhcIjtcbn1cbl9fbmFtZShnZXRQbGF0Zm9ybSwgXCJnZXRQbGF0Zm9ybVwiKTtcblxuLy8gLi4vZ2V0LXBsYXRmb3JtL3NyYy9pc05vZGVBUElTdXBwb3J0ZWQudHNcbnZhciBpbXBvcnRfZnMyID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xuYXN5bmMgZnVuY3Rpb24gaXNOb2RlQVBJU3VwcG9ydGVkKCkge1xuICBjb25zdCBjdXN0b21MaWJyYXJ5UGF0aCA9IHByb2Nlc3MuZW52LlBSSVNNQV9RVUVSWV9FTkdJTkVfTElCUkFSWTtcbiAgY29uc3QgY3VzdG9tTGlicmFyeUV4aXN0cyA9IGN1c3RvbUxpYnJhcnlQYXRoICYmIGltcG9ydF9mczIuZGVmYXVsdC5leGlzdHNTeW5jKGN1c3RvbUxpYnJhcnlQYXRoKTtcbiAgY29uc3Qgb3MzID0gYXdhaXQgZ2V0b3MoKTtcbiAgaWYgKCFjdXN0b21MaWJyYXJ5RXhpc3RzICYmIChvczMuYXJjaCA9PT0gXCJ4MzJcIiB8fCBvczMuYXJjaCA9PT0gXCJpYTMyXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBkZWZhdWx0IHF1ZXJ5IGVuZ2luZSB0eXBlIChOb2RlLUFQSSwgXCJsaWJyYXJ5XCIpIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciAzMmJpdCBOb2RlLiBQbGVhc2Ugc2V0IFxcYGVuZ2luZVR5cGUgPSBcImJpbmFyeVwiXFxgIGluIHRoZSBcImdlbmVyYXRvclwiIGJsb2NrIG9mIHlvdXIgXCJzY2hlbWEucHJpc21hXCIgZmlsZSAob3IgdXNlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgXCJQUklTTUFfQ0xJRU5UX0VOR0lORV9UWVBFPWJpbmFyeVwiIGFuZC9vciBcIlBSSVNNQV9DTElfUVVFUllfRU5HSU5FX1RZUEU9YmluYXJ5XCIuKWBcbiAgICApO1xuICB9XG59XG5fX25hbWUoaXNOb2RlQVBJU3VwcG9ydGVkLCBcImlzTm9kZUFQSVN1cHBvcnRlZFwiKTtcblxuLy8gLi4vZ2V0LXBsYXRmb3JtL3NyYy9wbGF0Zm9ybXMudHNcbnZhciBwbGF0Zm9ybXMgPSBbXG4gIFwiZGFyd2luXCIsXG4gIFwiZGFyd2luLWFybTY0XCIsXG4gIFwiZGViaWFuLW9wZW5zc2wtMS4wLnhcIixcbiAgXCJkZWJpYW4tb3BlbnNzbC0xLjEueFwiLFxuICBcImRlYmlhbi1vcGVuc3NsLTMuMC54XCIsXG4gIFwicmhlbC1vcGVuc3NsLTEuMC54XCIsXG4gIFwicmhlbC1vcGVuc3NsLTEuMS54XCIsXG4gIFwicmhlbC1vcGVuc3NsLTMuMC54XCIsXG4gIFwibGludXgtYXJtNjQtb3BlbnNzbC0xLjEueFwiLFxuICBcImxpbnV4LWFybTY0LW9wZW5zc2wtMS4wLnhcIixcbiAgXCJsaW51eC1hcm02NC1vcGVuc3NsLTMuMC54XCIsXG4gIFwibGludXgtYXJtLW9wZW5zc2wtMS4xLnhcIixcbiAgXCJsaW51eC1hcm0tb3BlbnNzbC0xLjAueFwiLFxuICBcImxpbnV4LWFybS1vcGVuc3NsLTMuMC54XCIsXG4gIFwibGludXgtbXVzbFwiLFxuICBcImxpbnV4LW5peG9zXCIsXG4gIFwid2luZG93c1wiLFxuICBcImZyZWVic2QxMVwiLFxuICBcImZyZWVic2QxMlwiLFxuICBcImZyZWVic2QxM1wiLFxuICBcIm9wZW5ic2RcIixcbiAgXCJuZXRic2RcIixcbiAgXCJhcm1cIlxuXTtcblxuLy8gLi4vZW5naW5lcy9zcmMvaW5kZXgudHNcbnZhciBpbXBvcnRfcGF0aCA9IF9fdG9FU00ocmVxdWlyZShcInBhdGhcIikpO1xudmFyIGltcG9ydF9lbmdpbmVzX3ZlcnNpb24yID0gX190b0VTTShyZXF1aXJlX2VuZ2luZXNfdmVyc2lvbigpKTtcbnZhciBkZWJ1ZzIgPSBzcmNfZGVmYXVsdChcInByaXNtYTplbmdpbmVzXCIpO1xuZnVuY3Rpb24gZ2V0RW5naW5lc1BhdGgoKSB7XG4gIHJldHVybiBpbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL1wiKTtcbn1cbl9fbmFtZShnZXRFbmdpbmVzUGF0aCwgXCJnZXRFbmdpbmVzUGF0aFwiKTtcbnZhciBERUZBVUxUX0NMSV9RVUVSWV9FTkdJTkVfQklOQVJZX1RZUEUgPSBcImxpYnF1ZXJ5LWVuZ2luZVwiIC8qIGxpYnF1ZXJ5RW5naW5lICovO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtZGFyd2luXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1kYXJ3aW5cIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3ByaXNtYS1mbXQtZGFyd2luXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtZGFyd2luLWFybTY0XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1kYXJ3aW4tYXJtNjRcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3ByaXNtYS1mbXQtZGFyd2luLWFybTY0XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtZGViaWFuLW9wZW5zc2wtMS4wLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2ludHJvc3BlY3Rpb24tZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LWRlYmlhbi1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtZGViaWFuLW9wZW5zc2wtMS4xLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2ludHJvc3BlY3Rpb24tZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LWRlYmlhbi1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtZGViaWFuLW9wZW5zc2wtMy4wLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2ludHJvc3BlY3Rpb24tZW5naW5lLWRlYmlhbi1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9wcmlzbWEtZm10LWRlYmlhbi1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtcmhlbC1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1yaGVsLW9wZW5zc2wtMS4wLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3ByaXNtYS1mbXQtcmhlbC1vcGVuc3NsLTEuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtcmhlbC1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1yaGVsLW9wZW5zc2wtMS4xLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3ByaXNtYS1mbXQtcmhlbC1vcGVuc3NsLTEuMS54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9xdWVyeS1lbmdpbmUtcmhlbC1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9pbnRyb3NwZWN0aW9uLWVuZ2luZS1yaGVsLW9wZW5zc2wtMy4wLnhcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL3ByaXNtYS1mbXQtcmhlbC1vcGVuc3NsLTMuMC54XCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtZGFyd2luLmR5bGliLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1kYXJ3aW4tYXJtNjQuZHlsaWIubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMC54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1kZWJpYW4tb3BlbnNzbC0xLjEueC5zby5ub2RlXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtZGViaWFuLW9wZW5zc2wtMy4wLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWxpbnV4LWFybTY0LW9wZW5zc2wtMS4wLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWxpbnV4LWFybTY0LW9wZW5zc2wtMS4xLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWxpbnV4LWFybTY0LW9wZW5zc2wtMy4wLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLWxpbnV4LW11c2wuc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vbGlicXVlcnlfZW5naW5lLXJoZWwtb3BlbnNzbC0xLjAueC5zby5ub2RlXCIpO1xuaW1wb3J0X3BhdGguZGVmYXVsdC5qb2luKF9fZGlybmFtZSwgXCIuLi9saWJxdWVyeV9lbmdpbmUtcmhlbC1vcGVuc3NsLTEuMS54LnNvLm5vZGVcIik7XG5pbXBvcnRfcGF0aC5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1yaGVsLW9wZW5zc2wtMy4wLnguc28ubm9kZVwiKTtcbmltcG9ydF9wYXRoLmRlZmF1bHQuam9pbihfX2Rpcm5hbWUsIFwiLi4vcXVlcnlfZW5naW5lLXdpbmRvd3MuZGxsLm5vZGVcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9iaW5hcnkvQmluYXJ5RW5naW5lLnRzXG52YXIgaW1wb3J0X2NoYWxrMyA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgaW1wb3J0X2NoaWxkX3Byb2Nlc3MyID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG52YXIgaW1wb3J0X2V2ZW50cyA9IF9fdG9FU00ocmVxdWlyZShcImV2ZW50c1wiKSk7XG52YXIgaW1wb3J0X2V4ZWNhID0gX190b0VTTShyZXF1aXJlX2V4ZWNhKCkpO1xudmFyIGltcG9ydF9mczQgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X25ldCA9IF9fdG9FU00ocmVxdWlyZShcIm5ldFwiKSk7XG52YXIgaW1wb3J0X3BfcmV0cnkgPSBfX3RvRVNNKHJlcXVpcmVfcF9yZXRyeSgpKTtcbnZhciBpbXBvcnRfcGF0aDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJwYXRoXCIpKTtcbnZhciBpbXBvcnRfdXJsID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBpbXBvcnRfdXRpbDQgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9FbmdpbmUudHNcbnZhciBFbmdpbmUgPSBjbGFzcyB7XG59O1xuX19uYW1lKEVuZ2luZSwgXCJFbmdpbmVcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL1ByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNsaWVudFZlcnNpb24yLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uMjtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclwiO1xuICB9XG59O1xuX19uYW1lKFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IsIFwiUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBjbGllbnRWZXJzaW9uMiwgbWV0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjI7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciwgXCJQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvdXRpbHMvbG9nLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGxvZzQpIHtcbiAgaWYgKHR5cGVvZiBsb2c0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGxvZzQ7XG4gIH0gZWxzZSBpZiAoaXNSdXN0RXJyb3IobG9nNCkpIHtcbiAgICByZXR1cm4gZ2V0QmFja3RyYWNlRnJvbVJ1c3RFcnJvcihsb2c0KTtcbiAgfSBlbHNlIGlmIChpc1J1c3RMb2cobG9nNCkpIHtcbiAgICByZXR1cm4gZ2V0QmFja3RyYWNlRnJvbUxvZyhsb2c0KTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobG9nNCk7XG59XG5fX25hbWUoZ2V0TWVzc2FnZSwgXCJnZXRNZXNzYWdlXCIpO1xuZnVuY3Rpb24gZ2V0QmFja3RyYWNlRnJvbUxvZyhsb2c0KSB7XG4gIHZhciBfYTMsIF9iMiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICBpZiAoKF9hMyA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1lc3NhZ2UpIHtcbiAgICBsZXQgc3RyID0gKF9iMiA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm1lc3NhZ2U7XG4gICAgaWYgKChfYyA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZmlsZSkge1xuICAgICAgc3RyICs9IGAgaW4gJHtsb2c0LmZpZWxkcy5maWxlfWA7XG4gICAgICBpZiAoKF9kID0gbG9nNC5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5saW5lKSB7XG4gICAgICAgIHN0ciArPSBgOiR7bG9nNC5maWVsZHMubGluZX1gO1xuICAgICAgfVxuICAgICAgaWYgKChfZSA9IGxvZzQuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY29sdW1uKSB7XG4gICAgICAgIHN0ciArPSBgOiR7bG9nNC5maWVsZHMuY29sdW1ufWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoX2YgPSBsb2c0LmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnJlYXNvbikge1xuICAgICAgc3RyICs9IGBcbiR7KF9nID0gbG9nNC5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5yZWFzb259YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gXCJVbmtub3duIGVycm9yXCI7XG59XG5fX25hbWUoZ2V0QmFja3RyYWNlRnJvbUxvZywgXCJnZXRCYWNrdHJhY2VGcm9tTG9nXCIpO1xuZnVuY3Rpb24gZ2V0QmFja3RyYWNlRnJvbVJ1c3RFcnJvcihlcnIpIHtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGlmIChlcnIuaXNfcGFuaWMpIHtcbiAgICBzdHIgKz0gYFBBTklDYDtcbiAgfVxuICBpZiAoZXJyLmJhY2t0cmFjZSkge1xuICAgIHN0ciArPSBgIGluICR7ZXJyLmJhY2t0cmFjZX1gO1xuICB9XG4gIGlmIChlcnIubWVzc2FnZSkge1xuICAgIHN0ciArPSBgXG4ke2Vyci5tZXNzYWdlfWA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbl9fbmFtZShnZXRCYWNrdHJhY2VGcm9tUnVzdEVycm9yLCBcImdldEJhY2t0cmFjZUZyb21SdXN0RXJyb3JcIik7XG5mdW5jdGlvbiBpc1J1c3RMb2coZSkge1xuICByZXR1cm4gZS50aW1lc3RhbXAgJiYgdHlwZW9mIGUubGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGUudGFyZ2V0ID09PSBcInN0cmluZ1wiO1xufVxuX19uYW1lKGlzUnVzdExvZywgXCJpc1J1c3RMb2dcIik7XG5mdW5jdGlvbiBpc1J1c3RFcnJvckxvZyhlKSB7XG4gIHZhciBfYTMsIF9iMjtcbiAgcmV0dXJuIGlzUnVzdExvZyhlKSAmJiAoZS5sZXZlbCA9PT0gXCJlcnJvclwiIHx8ICgoX2IyID0gKF9hMyA9IGUuZmllbGRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuaW5jbHVkZXMoXCJmYXRhbCBlcnJvclwiKSkpO1xufVxuX19uYW1lKGlzUnVzdEVycm9yTG9nLCBcImlzUnVzdEVycm9yTG9nXCIpO1xuZnVuY3Rpb24gaXNSdXN0RXJyb3IoZSkge1xuICByZXR1cm4gdHlwZW9mIGUuaXNfcGFuaWMgIT09IFwidW5kZWZpbmVkXCI7XG59XG5fX25hbWUoaXNSdXN0RXJyb3IsIFwiaXNSdXN0RXJyb3JcIik7XG5mdW5jdGlvbiBjb252ZXJ0TG9nKHJ1c3RMb2cpIHtcbiAgY29uc3QgaXNRdWVyeSA9IGlzUXVlcnlMb2cocnVzdExvZy5maWVsZHMpO1xuICBjb25zdCBsZXZlbCA9IGlzUXVlcnkgPyBcInF1ZXJ5XCIgOiBydXN0TG9nLmxldmVsLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB7XG4gICAgLi4ucnVzdExvZyxcbiAgICBsZXZlbCxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHJ1c3RMb2cudGltZXN0YW1wKVxuICB9O1xufVxuX19uYW1lKGNvbnZlcnRMb2csIFwiY29udmVydExvZ1wiKTtcbmZ1bmN0aW9uIGlzUXVlcnlMb2coZmllbGRzKSB7XG4gIHJldHVybiBCb29sZWFuKGZpZWxkcy5xdWVyeSk7XG59XG5fX25hbWUoaXNRdWVyeUxvZywgXCJpc1F1ZXJ5TG9nXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy9QcmlzbWFDbGllbnRSdXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRSdXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBjbGllbnRWZXJzaW9uOiBjbGllbnRWZXJzaW9uMiwgbG9nOiBsb2c0LCBlcnJvcjogZXJyb3IyIH0pIHtcbiAgICB2YXIgX19zdXBlciA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9O1xuICAgIGlmIChsb2c0KSB7XG4gICAgICBjb25zdCBiYWNrdHJhY2UgPSBnZXRCYWNrdHJhY2VGcm9tTG9nKGxvZzQpO1xuICAgICAgX19zdXBlcihiYWNrdHJhY2UgIT0gbnVsbCA/IGJhY2t0cmFjZSA6IFwiVW5rbm93biBlcnJvclwiKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yMikge1xuICAgICAgY29uc3QgYmFja3RyYWNlID0gZ2V0QmFja3RyYWNlRnJvbVJ1c3RFcnJvcihlcnJvcjIpO1xuICAgICAgX19zdXBlcihiYWNrdHJhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfX3N1cGVyKGBVbmtub3duIGVycm9yYCk7XG4gICAgfVxuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb24yO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvclwiO1xuICB9XG59O1xuX19uYW1lKFByaXNtYUNsaWVudFJ1c3RFcnJvciwgXCJQcmlzbWFDbGllbnRSdXN0RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL1ByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2xpZW50VmVyc2lvbjIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uMjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvciwgXCJQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvci50c1xudmFyIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2xpZW50VmVyc2lvbjIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uMjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclwiO1xuICB9XG59O1xuX19uYW1lKFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2NvbW1vbi9lcnJvcnMvdXRpbHMvZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsudHNcbnZhciBpbXBvcnRfY2hhbGsyID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciBpbXBvcnRfc3RyaXBfYW5zaSA9IF9fdG9FU00ocmVxdWlyZV9zdHJpcF9hbnNpKCkpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL3V0aWxzL3V0aWwudHNcbnZhciBpbXBvcnRfZnMzID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xudmFyIGltcG9ydF9uZXdfZ2l0aHViX2lzc3VlX3VybCA9IF9fdG9FU00ocmVxdWlyZV9uZXdfZ2l0aHViX2lzc3VlX3VybCgpKTtcbnZhciBkZWJ1ZzMgPSBzcmNfZGVmYXVsdChcInBsdXNYXCIpO1xuZnVuY3Rpb24gcGx1c1goZmlsZSkge1xuICBjb25zdCBzID0gaW1wb3J0X2ZzMy5kZWZhdWx0LnN0YXRTeW5jKGZpbGUpO1xuICBjb25zdCBuZXdNb2RlID0gcy5tb2RlIHwgNjQgfCA4IHwgMTtcbiAgaWYgKHMubW9kZSA9PT0gbmV3TW9kZSkge1xuICAgIGRlYnVnMyhgRXhlY3V0aW9uIHBlcm1pc3Npb25zIG9mICR7ZmlsZX0gYXJlIGZpbmVgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYmFzZTggPSBuZXdNb2RlLnRvU3RyaW5nKDgpLnNsaWNlKC0zKTtcbiAgZGVidWczKGBIYXZlIHRvIGNhbGwgcGx1c1ggb24gJHtmaWxlfWApO1xuICBpbXBvcnRfZnMzLmRlZmF1bHQuY2htb2RTeW5jKGZpbGUsIGJhc2U4KTtcbn1cbl9fbmFtZShwbHVzWCwgXCJwbHVzWFwiKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBsYXRmb3JtVG9FbnZWYWx1ZShwbGF0Zm9ybTMpIHtcbiAgcmV0dXJuIHsgZnJvbUVudlZhcjogbnVsbCwgdmFsdWU6IHBsYXRmb3JtMyB9O1xufVxuX19uYW1lKHRyYW5zZm9ybVBsYXRmb3JtVG9FbnZWYWx1ZSwgXCJ0cmFuc2Zvcm1QbGF0Zm9ybVRvRW52VmFsdWVcIik7XG5mdW5jdGlvbiBmaXhCaW5hcnlUYXJnZXRzKGJpbmFyeVRhcmdldHMsIHBsYXRmb3JtMykge1xuICBiaW5hcnlUYXJnZXRzID0gYmluYXJ5VGFyZ2V0cyB8fCBbXTtcbiAgaWYgKCFiaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlID09PSBcIm5hdGl2ZVwiKSkge1xuICAgIHJldHVybiBbdHJhbnNmb3JtUGxhdGZvcm1Ub0VudlZhbHVlKFwibmF0aXZlXCIpLCAuLi5iaW5hcnlUYXJnZXRzXTtcbiAgfVxuICByZXR1cm4gWy4uLmJpbmFyeVRhcmdldHMsIHRyYW5zZm9ybVBsYXRmb3JtVG9FbnZWYWx1ZShwbGF0Zm9ybTMpXTtcbn1cbl9fbmFtZShmaXhCaW5hcnlUYXJnZXRzLCBcImZpeEJpbmFyeVRhcmdldHNcIik7XG5mdW5jdGlvbiBnZXRHaXRodWJJc3N1ZVVybCh7XG4gIHRpdGxlLFxuICB1c2VyID0gXCJwcmlzbWFcIixcbiAgcmVwbyA9IFwicHJpc21hXCIsXG4gIHRlbXBsYXRlID0gXCJidWdfcmVwb3J0Lm1kXCIsXG4gIGJvZHlcbn0pIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfbmV3X2dpdGh1Yl9pc3N1ZV91cmwuZGVmYXVsdCkoe1xuICAgIHVzZXIsXG4gICAgcmVwbyxcbiAgICB0ZW1wbGF0ZSxcbiAgICB0aXRsZSxcbiAgICBib2R5XG4gIH0pO1xufVxuX19uYW1lKGdldEdpdGh1Yklzc3VlVXJsLCBcImdldEdpdGh1Yklzc3VlVXJsXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy91dGlscy9tYXNrUXVlcnkudHNcbmZ1bmN0aW9uIG1hc2tRdWVyeShxdWVyeTIpIHtcbiAgaWYgKCFxdWVyeTIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gcXVlcnkyLnJlcGxhY2UoL1wiLipcIi9nLCAnXCJYXCInKS5yZXBsYWNlKC9bXFxzOlxcW10oWystXT8oWzAtOV0qWy5dKT9bMC05XSspL2csIChzdWJzdHIpID0+IHtcbiAgICByZXR1cm4gYCR7c3Vic3RyWzBdfTVgO1xuICB9KTtcbn1cbl9fbmFtZShtYXNrUXVlcnksIFwibWFza1F1ZXJ5XCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvY29tbW9uL2Vycm9ycy91dGlscy9ub3JtYWxpemVMb2dzLnRzXG5mdW5jdGlvbiBub3JtYWxpemVMb2dzKGxvZ3MpIHtcbiAgcmV0dXJuIGxvZ3Muc3BsaXQoXCJcXG5cIikubWFwKChsKSA9PiB7XG4gICAgcmV0dXJuIGwucmVwbGFjZSgvXlxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WilcXHMqLywgXCJcIikucmVwbGFjZSgvXFwrXFxkK1xccyptcyQvLCBcIlwiKTtcbiAgfSkuam9pbihcIlxcblwiKTtcbn1cbl9fbmFtZShub3JtYWxpemVMb2dzLCBcIm5vcm1hbGl6ZUxvZ3NcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL3V0aWxzL2dldEVycm9yTWVzc2FnZVdpdGhMaW5rLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2VXaXRoTGluayh7XG4gIHZlcnNpb24sXG4gIHBsYXRmb3JtOiBwbGF0Zm9ybTMsXG4gIHRpdGxlLFxuICBkZXNjcmlwdGlvbixcbiAgZW5naW5lVmVyc2lvbixcbiAgZGF0YWJhc2UsXG4gIHF1ZXJ5OiBxdWVyeTJcbn0pIHtcbiAgdmFyIF9hMywgX2IyO1xuICBjb25zdCBnb3RMb2dzID0gZ2V0TG9ncyg2ZTMgLSAoKF9hMyA9IHF1ZXJ5MiA9PSBudWxsID8gdm9pZCAwIDogcXVlcnkyLmxlbmd0aCkgIT0gbnVsbCA/IF9hMyA6IDApKTtcbiAgY29uc3QgbG9ncyA9IG5vcm1hbGl6ZUxvZ3MoKDAsIGltcG9ydF9zdHJpcF9hbnNpLmRlZmF1bHQpKGdvdExvZ3MpKTtcbiAgY29uc3QgbW9yZUluZm8gPSBkZXNjcmlwdGlvbiA/IGAjIERlc2NyaXB0aW9uXG5cXGBcXGBcXGBcbiR7ZGVzY3JpcHRpb259XG5cXGBcXGBcXGBgIDogXCJcIjtcbiAgY29uc3QgYm9keSA9ICgwLCBpbXBvcnRfc3RyaXBfYW5zaS5kZWZhdWx0KShcbiAgICBgSGkgUHJpc21hIFRlYW0hIE15IFByaXNtYSBDbGllbnQganVzdCBjcmFzaGVkLiBUaGlzIGlzIHRoZSByZXBvcnQ6XG4jIyBWZXJzaW9uc1xuXG58IE5hbWUgICAgICAgICAgICB8IFZlcnNpb24gICAgICAgICAgICB8XG58LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18XG58IE5vZGUgICAgICAgICAgICB8ICR7KF9iMiA9IHByb2Nlc3MudmVyc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5wYWRFbmQoMTkpfXwgXG58IE9TICAgICAgICAgICAgICB8ICR7cGxhdGZvcm0zID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTMucGFkRW5kKDE5KX18XG58IFByaXNtYSBDbGllbnQgICB8ICR7dmVyc2lvbiA9PSBudWxsID8gdm9pZCAwIDogdmVyc2lvbi5wYWRFbmQoMTkpfXxcbnwgUXVlcnkgRW5naW5lICAgIHwgJHtlbmdpbmVWZXJzaW9uID09IG51bGwgPyB2b2lkIDAgOiBlbmdpbmVWZXJzaW9uLnBhZEVuZCgxOSl9fFxufCBEYXRhYmFzZSAgICAgICAgfCAke2RhdGFiYXNlID09IG51bGwgPyB2b2lkIDAgOiBkYXRhYmFzZS5wYWRFbmQoMTkpfXxcblxuJHttb3JlSW5mb31cblxuIyMgTG9nc1xuXFxgXFxgXFxgXG4ke2xvZ3N9XG5cXGBcXGBcXGBcblxuIyMgQ2xpZW50IFNuaXBwZXRcblxcYFxcYFxcYHRzXG4vLyBQTEVBU0UgRklMTCBZT1VSIENPREUgU05JUFBFVCBIRVJFXG5cXGBcXGBcXGBcblxuIyMgU2NoZW1hXG5cXGBcXGBcXGBwcmlzbWFcbi8vIFBMRUFTRSBBREQgWU9VUiBTQ0hFTUEgSEVSRSBJRiBQT1NTSUJMRVxuXFxgXFxgXFxgXG5cbiMjIFByaXNtYSBFbmdpbmUgUXVlcnlcblxcYFxcYFxcYFxuJHtxdWVyeTIgPyBtYXNrUXVlcnkocXVlcnkyKSA6IFwiXCJ9XG5cXGBcXGBcXGBcbmBcbiAgKTtcbiAgY29uc3QgdXJsID0gZ2V0R2l0aHViSXNzdWVVcmwoeyB0aXRsZSwgYm9keSB9KTtcbiAgcmV0dXJuIGAke3RpdGxlfVxuXG5UaGlzIGlzIGEgbm9uLXJlY292ZXJhYmxlIGVycm9yIHdoaWNoIHByb2JhYmx5IGhhcHBlbnMgd2hlbiB0aGUgUHJpc21hIFF1ZXJ5IEVuZ2luZSBoYXMgYSBwYW5pYy5cblxuJHtpbXBvcnRfY2hhbGsyLmRlZmF1bHQudW5kZXJsaW5lKHVybCl9XG5cbklmIHlvdSB3YW50IHRoZSBQcmlzbWEgdGVhbSB0byBsb29rIGludG8gaXQsIHBsZWFzZSBvcGVuIHRoZSBsaW5rIGFib3ZlIFxcdXsxRjY0Rn1cblRvIGluY3JlYXNlIHRoZSBjaGFuY2Ugb2Ygc3VjY2VzcywgcGxlYXNlIHBvc3QgeW91ciBzY2hlbWEgYW5kIGEgc25pcHBldCBvZlxuaG93IHlvdSB1c2VkIFByaXNtYSBDbGllbnQgaW4gdGhlIGlzc3VlLiBcbmA7XG59XG5fX25hbWUoZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmssIFwiZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmtcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL3V0aWxzL3ByaXNtYUdyYXBoUUxUb0pTRXJyb3IudHNcbmZ1bmN0aW9uIHByaXNtYUdyYXBoUUxUb0pTRXJyb3IoZXJyb3IyLCBjbGllbnRWZXJzaW9uMikge1xuICBpZiAoZXJyb3IyLnVzZXJfZmFjaW5nX2Vycm9yLmVycm9yX2NvZGUpIHtcbiAgICByZXR1cm4gbmV3IFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yKFxuICAgICAgZXJyb3IyLnVzZXJfZmFjaW5nX2Vycm9yLm1lc3NhZ2UsXG4gICAgICBlcnJvcjIudXNlcl9mYWNpbmdfZXJyb3IuZXJyb3JfY29kZSxcbiAgICAgIGNsaWVudFZlcnNpb24yLFxuICAgICAgZXJyb3IyLnVzZXJfZmFjaW5nX2Vycm9yLm1ldGFcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihlcnJvcjIuZXJyb3IsIGNsaWVudFZlcnNpb24yKTtcbn1cbl9fbmFtZShwcmlzbWFHcmFwaFFMVG9KU0Vycm9yLCBcInByaXNtYUdyYXBoUUxUb0pTRXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vdXRpbHMvcHJpbnRHZW5lcmF0b3JDb25maWcudHNcbnZhciBpbXBvcnRfaW5kZW50X3N0cmluZzIgPSBfX3RvRVNNKHJlcXVpcmVfaW5kZW50X3N0cmluZygpKTtcbmZ1bmN0aW9uIHByaW50R2VuZXJhdG9yQ29uZmlnKGNvbmZpZzIpIHtcbiAgcmV0dXJuIFN0cmluZyhuZXcgR2VuZXJhdG9yQ29uZmlnQ2xhc3MoY29uZmlnMikpO1xufVxuX19uYW1lKHByaW50R2VuZXJhdG9yQ29uZmlnLCBcInByaW50R2VuZXJhdG9yQ29uZmlnXCIpO1xudmFyIEdlbmVyYXRvckNvbmZpZ0NsYXNzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcyKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcyO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHsgY29uZmlnOiBjb25maWcyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gY29uZmlnMi5wcm92aWRlci5mcm9tRW52VmFyID8gYGVudihcIiR7Y29uZmlnMi5wcm92aWRlci5mcm9tRW52VmFyfVwiKWAgOiBjb25maWcyLnByb3ZpZGVyLnZhbHVlO1xuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBiaW5hcnlUYXJnZXRzOiBnZXRPcmlnaW5hbEJpbmFyeVRhcmdldHNWYWx1ZShjb25maWcyLmJpbmFyeVRhcmdldHMpXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGBnZW5lcmF0b3IgJHtjb25maWcyLm5hbWV9IHtcbiR7KDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nMi5kZWZhdWx0KShwcmludERhdGFtb2RlbE9iamVjdChvYmopLCAyKX1cbn1gO1xuICB9XG59O1xuX19uYW1lKEdlbmVyYXRvckNvbmZpZ0NsYXNzLCBcIkdlbmVyYXRvckNvbmZpZ0NsYXNzXCIpO1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxCaW5hcnlUYXJnZXRzVmFsdWUoYmluYXJ5VGFyZ2V0cykge1xuICBsZXQgdmFsdWU7XG4gIGlmIChiaW5hcnlUYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBiaW5hcnlUYXJnZXRzRnJvbUVudlZhciA9IGJpbmFyeVRhcmdldHMuZmluZCgob2JqZWN0KSA9PiBvYmplY3QuZnJvbUVudlZhciAhPT0gbnVsbCk7XG4gICAgaWYgKGJpbmFyeVRhcmdldHNGcm9tRW52VmFyKSB7XG4gICAgICB2YWx1ZSA9IGBlbnYoXCIke2JpbmFyeVRhcmdldHNGcm9tRW52VmFyLmZyb21FbnZWYXJ9XCIpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBiaW5hcnlUYXJnZXRzLm1hcCgob2JqZWN0KSA9PiBvYmplY3QudmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5fX25hbWUoZ2V0T3JpZ2luYWxCaW5hcnlUYXJnZXRzVmFsdWUsIFwiZ2V0T3JpZ2luYWxCaW5hcnlUYXJnZXRzVmFsdWVcIik7XG5mdW5jdGlvbiBwcmludERhdGFtb2RlbE9iamVjdChvYmopIHtcbiAgY29uc3QgbWF4TGVuZ3RoID0gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG1heDIsIGN1cnIpID0+IE1hdGgubWF4KG1heDIsIGN1cnIubGVuZ3RoKSwgMCk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXkucGFkRW5kKG1heExlbmd0aCl9ID0gJHtuaWNlU3RyaW5naWZ5KHZhbHVlKX1gKS5qb2luKFwiXFxuXCIpO1xufVxuX19uYW1lKHByaW50RGF0YW1vZGVsT2JqZWN0LCBcInByaW50RGF0YW1vZGVsT2JqZWN0XCIpO1xuZnVuY3Rpb24gbmljZVN0cmluZ2lmeSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKF8sIHZhbHVlMikgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUyKSkge1xuICAgICAgICByZXR1cm4gYFske3ZhbHVlMi5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLCBcIil9XWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUyKTtcbiAgICB9KVxuICApO1xufVxuX19uYW1lKG5pY2VTdHJpbmdpZnksIFwibmljZVN0cmluZ2lmeVwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL3Rvb2xzL2J5bGluZS50c1xudmFyIGltcG9ydF9zdHJlYW0gPSBfX3RvRVNNKHJlcXVpcmUoXCJzdHJlYW1cIikpO1xudmFyIGltcG9ydF91dGlsMyA9IF9fdG9FU00ocmVxdWlyZShcInV0aWxcIikpO1xuZnVuY3Rpb24gYnlsaW5lKHJlYWRTdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0cmVhbShyZWFkU3RyZWFtLCBvcHRpb25zKTtcbn1cbl9fbmFtZShieWxpbmUsIFwiYnlsaW5lXCIpO1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtKHJlYWRTdHJlYW0sIG9wdGlvbnMpIHtcbiAgaWYgKHJlYWRTdHJlYW0pIHtcbiAgICByZXR1cm4gY3JlYXRlTGluZVN0cmVhbShyZWFkU3RyZWFtLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJlYW0ob3B0aW9ucyk7XG4gIH1cbn1cbl9fbmFtZShjcmVhdGVTdHJlYW0sIFwiY3JlYXRlU3RyZWFtXCIpO1xuZnVuY3Rpb24gY3JlYXRlTGluZVN0cmVhbShyZWFkU3RyZWFtLCBvcHRpb25zKSB7XG4gIGlmICghcmVhZFN0cmVhbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHJlYWRTdHJlYW1cIik7XG4gIH1cbiAgaWYgKCFyZWFkU3RyZWFtLnJlYWRhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFN0cmVhbSBtdXN0IGJlIHJlYWRhYmxlXCIpO1xuICB9XG4gIGNvbnN0IGxzID0gbmV3IExpbmVTdHJlYW0ob3B0aW9ucyk7XG4gIHJlYWRTdHJlYW0ucGlwZShscyk7XG4gIHJldHVybiBscztcbn1cbl9fbmFtZShjcmVhdGVMaW5lU3RyZWFtLCBcImNyZWF0ZUxpbmVTdHJlYW1cIik7XG5mdW5jdGlvbiBMaW5lU3RyZWFtKG9wdGlvbnMpIHtcbiAgaW1wb3J0X3N0cmVhbS5kZWZhdWx0LlRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcbiAgdGhpcy5fbGluZUJ1ZmZlciA9IFtdO1xuICB0aGlzLl9rZWVwRW1wdHlMaW5lcyA9IG9wdGlvbnMua2VlcEVtcHR5TGluZXMgfHwgZmFsc2U7XG4gIHRoaXMuX2xhc3RDaHVua0VuZGVkV2l0aENSID0gZmFsc2U7XG4gIHRoaXMub24oXCJwaXBlXCIsIGZ1bmN0aW9uKHNyYykge1xuICAgIGlmICghdGhpcy5lbmNvZGluZykge1xuICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIGltcG9ydF9zdHJlYW0uZGVmYXVsdC5SZWFkYWJsZSkge1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gc3JjLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5fX25hbWUoTGluZVN0cmVhbSwgXCJMaW5lU3RyZWFtXCIpO1xuaW1wb3J0X3V0aWwzLmRlZmF1bHQuaW5oZXJpdHMoTGluZVN0cmVhbSwgaW1wb3J0X3N0cmVhbS5kZWZhdWx0LlRyYW5zZm9ybSk7XG5MaW5lU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgXCJ1dGY4XCI7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgaWYgKGVuY29kaW5nID09IFwiYnVmZmVyXCIpIHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9jaHVua0VuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpO1xuICBpZiAodGhpcy5fbGFzdENodW5rRW5kZWRXaXRoQ1IgJiYgY2h1bmtbMF0gPT0gXCJcXG5cIikge1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gIH1cbiAgaWYgKHRoaXMuX2xpbmVCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuX2xpbmVCdWZmZXJbdGhpcy5fbGluZUJ1ZmZlci5sZW5ndGggLSAxXSArPSBsaW5lc1swXTtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICB9XG4gIHRoaXMuX2xhc3RDaHVua0VuZGVkV2l0aENSID0gY2h1bmtbY2h1bmsubGVuZ3RoIC0gMV0gPT0gXCJcXHJcIjtcbiAgdGhpcy5fbGluZUJ1ZmZlciA9IHRoaXMuX2xpbmVCdWZmZXIuY29uY2F0KGxpbmVzKTtcbiAgdGhpcy5fcHVzaEJ1ZmZlcihlbmNvZGluZywgMSwgZG9uZSk7XG59O1xuTGluZVN0cmVhbS5wcm90b3R5cGUuX3B1c2hCdWZmZXIgPSBmdW5jdGlvbihlbmNvZGluZywga2VlcCwgZG9uZSkge1xuICB3aGlsZSAodGhpcy5fbGluZUJ1ZmZlci5sZW5ndGggPiBrZWVwKSB7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuX2xpbmVCdWZmZXIuc2hpZnQoKTtcbiAgICBpZiAodGhpcy5fa2VlcEVtcHR5TGluZXMgfHwgbGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXRoaXMucHVzaCh0aGlzLl9yZWVuY29kZShsaW5lLCBlbmNvZGluZykpKSB7XG4gICAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYyLl9wdXNoQnVmZmVyKGVuY29kaW5nLCBrZWVwLCBkb25lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZG9uZSgpO1xufTtcbkxpbmVTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgdGhpcy5fcHVzaEJ1ZmZlcih0aGlzLl9jaHVua0VuY29kaW5nLCAwLCBkb25lKTtcbn07XG5MaW5lU3RyZWFtLnByb3RvdHlwZS5fcmVlbmNvZGUgPSBmdW5jdGlvbihsaW5lLCBjaHVua0VuY29kaW5nKSB7XG4gIGlmICh0aGlzLmVuY29kaW5nICYmIHRoaXMuZW5jb2RpbmcgIT0gY2h1bmtFbmNvZGluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShsaW5lLCBjaHVua0VuY29kaW5nKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbiAgfSBlbHNlIGlmICh0aGlzLmVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGxpbmUsIGNodW5rRW5jb2RpbmcpO1xuICB9XG59O1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvdG9vbHMvb21pdC50c1xuZnVuY3Rpb24gb21pdChvYmosIGtleXMyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmZpbHRlcigoa2V5KSA9PiAha2V5czIuaW5jbHVkZXMoa2V5KSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuX19uYW1lKG9taXQsIFwib21pdFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zdXBwcmVzcy10cmFjaW5nLmpzXG52YXIgU1VQUFJFU1NfVFJBQ0lOR19LRVkgPSBjcmVhdGVDb250ZXh0S2V5KFwiT3BlblRlbGVtZXRyeSBTREsgQ29udGV4dCBLZXkgU1VQUFJFU1NfVFJBQ0lOR1wiKTtcbmZ1bmN0aW9uIHN1cHByZXNzVHJhY2luZyhjb250ZXh0Mykge1xuICByZXR1cm4gY29udGV4dDMuc2V0VmFsdWUoU1VQUFJFU1NfVFJBQ0lOR19LRVksIHRydWUpO1xufVxuX19uYW1lKHN1cHByZXNzVHJhY2luZywgXCJzdXBwcmVzc1RyYWNpbmdcIik7XG5mdW5jdGlvbiBpc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQzKSB7XG4gIHJldHVybiBjb250ZXh0My5nZXRWYWx1ZShTVVBQUkVTU19UUkFDSU5HX0tFWSkgPT09IHRydWU7XG59XG5fX25hbWUoaXNUcmFjaW5nU3VwcHJlc3NlZCwgXCJpc1RyYWNpbmdTdXBwcmVzc2VkXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2JhZ2dhZ2UvY29uc3RhbnRzLmpzXG52YXIgQkFHR0FHRV9LRVlfUEFJUl9TRVBBUkFUT1IgPSBcIj1cIjtcbnZhciBCQUdHQUdFX1BST1BFUlRJRVNfU0VQQVJBVE9SID0gXCI7XCI7XG52YXIgQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IgPSBcIixcIjtcbnZhciBCQUdHQUdFX0hFQURFUiA9IFwiYmFnZ2FnZVwiO1xudmFyIEJBR0dBR0VfTUFYX05BTUVfVkFMVUVfUEFJUlMgPSAxODA7XG52YXIgQkFHR0FHRV9NQVhfUEVSX05BTUVfVkFMVUVfUEFJUlMgPSA0MDk2O1xudmFyIEJBR0dBR0VfTUFYX1RPVEFMX0xFTkdUSCA9IDgxOTI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vYmFnZ2FnZS91dGlscy5qc1xudmFyIF9fcmVhZCA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVLZXlQYWlycyhrZXlQYWlycykge1xuICByZXR1cm4ga2V5UGFpcnMucmVkdWNlKGZ1bmN0aW9uKGhWYWx1ZSwgY3VycmVudCkge1xuICAgIHZhciB2YWx1ZSA9IFwiXCIgKyBoVmFsdWUgKyAoaFZhbHVlICE9PSBcIlwiID8gQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IgOiBcIlwiKSArIGN1cnJlbnQ7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IEJBR0dBR0VfTUFYX1RPVEFMX0xFTkdUSCA/IGhWYWx1ZSA6IHZhbHVlO1xuICB9LCBcIlwiKTtcbn1cbl9fbmFtZShzZXJpYWxpemVLZXlQYWlycywgXCJzZXJpYWxpemVLZXlQYWlyc1wiKTtcbmZ1bmN0aW9uIGdldEtleVBhaXJzKGJhZ2dhZ2UpIHtcbiAgcmV0dXJuIGJhZ2dhZ2UuZ2V0QWxsRW50cmllcygpLm1hcChmdW5jdGlvbihfYTMpIHtcbiAgICB2YXIgX2IyID0gX19yZWFkKF9hMywgMiksIGtleSA9IF9iMlswXSwgdmFsdWUgPSBfYjJbMV07XG4gICAgdmFyIGVudHJ5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZS52YWx1ZSk7XG4gICAgaWYgKHZhbHVlLm1ldGFkYXRhICE9PSB2b2lkIDApIHtcbiAgICAgIGVudHJ5ICs9IEJBR0dBR0VfUFJPUEVSVElFU19TRVBBUkFUT1IgKyB2YWx1ZS5tZXRhZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH0pO1xufVxuX19uYW1lKGdldEtleVBhaXJzLCBcImdldEtleVBhaXJzXCIpO1xuZnVuY3Rpb24gcGFyc2VQYWlyS2V5VmFsdWUoZW50cnkpIHtcbiAgdmFyIHZhbHVlUHJvcHMgPSBlbnRyeS5zcGxpdChCQUdHQUdFX1BST1BFUlRJRVNfU0VQQVJBVE9SKTtcbiAgaWYgKHZhbHVlUHJvcHMubGVuZ3RoIDw9IDApXG4gICAgcmV0dXJuO1xuICB2YXIga2V5UGFpclBhcnQgPSB2YWx1ZVByb3BzLnNoaWZ0KCk7XG4gIGlmICgha2V5UGFpclBhcnQpXG4gICAgcmV0dXJuO1xuICB2YXIga2V5UGFpciA9IGtleVBhaXJQYXJ0LnNwbGl0KEJBR0dBR0VfS0VZX1BBSVJfU0VQQVJBVE9SKTtcbiAgaWYgKGtleVBhaXIubGVuZ3RoICE9PSAyKVxuICAgIHJldHVybjtcbiAgdmFyIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXlQYWlyWzBdLnRyaW0oKSk7XG4gIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXlQYWlyWzFdLnRyaW0oKSk7XG4gIHZhciBtZXRhZGF0YTtcbiAgaWYgKHZhbHVlUHJvcHMubGVuZ3RoID4gMCkge1xuICAgIG1ldGFkYXRhID0gYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nKHZhbHVlUHJvcHMuam9pbihCQUdHQUdFX1BST1BFUlRJRVNfU0VQQVJBVE9SKSk7XG4gIH1cbiAgcmV0dXJuIHsga2V5LCB2YWx1ZSwgbWV0YWRhdGEgfTtcbn1cbl9fbmFtZShwYXJzZVBhaXJLZXlWYWx1ZSwgXCJwYXJzZVBhaXJLZXlWYWx1ZVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9iYWdnYWdlL3Byb3BhZ2F0aW9uL1czQ0JhZ2dhZ2VQcm9wYWdhdG9yLmpzXG52YXIgVzNDQmFnZ2FnZVByb3BhZ2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVzNDQmFnZ2FnZVByb3BhZ2F0b3IyKCkge1xuICB9XG4gIF9fbmFtZShXM0NCYWdnYWdlUHJvcGFnYXRvcjIsIFwiVzNDQmFnZ2FnZVByb3BhZ2F0b3JcIik7XG4gIFczQ0JhZ2dhZ2VQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIHZhciBiYWdnYWdlID0gcHJvcGFnYXRpb24uZ2V0QmFnZ2FnZShjb250ZXh0Myk7XG4gICAgaWYgKCFiYWdnYWdlIHx8IGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDMpKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBrZXlQYWlycyA9IGdldEtleVBhaXJzKGJhZ2dhZ2UpLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7XG4gICAgICByZXR1cm4gcGFpci5sZW5ndGggPD0gQkFHR0FHRV9NQVhfUEVSX05BTUVfVkFMVUVfUEFJUlM7XG4gICAgfSkuc2xpY2UoMCwgQkFHR0FHRV9NQVhfTkFNRV9WQUxVRV9QQUlSUyk7XG4gICAgdmFyIGhlYWRlclZhbHVlID0gc2VyaWFsaXplS2V5UGFpcnMoa2V5UGFpcnMpO1xuICAgIGlmIChoZWFkZXJWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIEJBR0dBR0VfSEVBREVSLCBoZWFkZXJWYWx1ZSk7XG4gICAgfVxuICB9O1xuICBXM0NCYWdnYWdlUHJvcGFnYXRvcjIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MywgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgdmFyIGhlYWRlclZhbHVlID0gZ2V0dGVyLmdldChjYXJyaWVyLCBCQUdHQUdFX0hFQURFUik7XG4gICAgdmFyIGJhZ2dhZ2VTdHJpbmcgPSBBcnJheS5pc0FycmF5KGhlYWRlclZhbHVlKSA/IGhlYWRlclZhbHVlLmpvaW4oQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IpIDogaGVhZGVyVmFsdWU7XG4gICAgaWYgKCFiYWdnYWdlU3RyaW5nKVxuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIHZhciBiYWdnYWdlID0ge307XG4gICAgaWYgKGJhZ2dhZ2VTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29udGV4dDM7XG4gICAgfVxuICAgIHZhciBwYWlycyA9IGJhZ2dhZ2VTdHJpbmcuc3BsaXQoQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IpO1xuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHZhciBrZXlQYWlyID0gcGFyc2VQYWlyS2V5VmFsdWUoZW50cnkpO1xuICAgICAgaWYgKGtleVBhaXIpIHtcbiAgICAgICAgdmFyIGJhZ2dhZ2VFbnRyeSA9IHsgdmFsdWU6IGtleVBhaXIudmFsdWUgfTtcbiAgICAgICAgaWYgKGtleVBhaXIubWV0YWRhdGEpIHtcbiAgICAgICAgICBiYWdnYWdlRW50cnkubWV0YWRhdGEgPSBrZXlQYWlyLm1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGJhZ2dhZ2Vba2V5UGFpci5rZXldID0gYmFnZ2FnZUVudHJ5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZW50cmllcyhiYWdnYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb250ZXh0MztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UoY29udGV4dDMsIHByb3BhZ2F0aW9uLmNyZWF0ZUJhZ2dhZ2UoYmFnZ2FnZSkpO1xuICB9O1xuICBXM0NCYWdnYWdlUHJvcGFnYXRvcjIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbQkFHR0FHRV9IRUFERVJdO1xuICB9O1xuICByZXR1cm4gVzNDQmFnZ2FnZVByb3BhZ2F0b3IyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9hdHRyaWJ1dGVzLmpzXG52YXIgX192YWx1ZXMgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkMiA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZV8xLCBfYTM7XG4gIHZhciBvdXQgPSB7fTtcbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYjIgPSBfX3ZhbHVlcyhPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSksIF9jID0gX2IyLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IyLm5leHQoKSkge1xuICAgICAgdmFyIF9kID0gX19yZWFkMihfYy52YWx1ZSwgMiksIGtleSA9IF9kWzBdLCB2YWwgPSBfZFsxXTtcbiAgICAgIGlmICghaXNBdHRyaWJ1dGVLZXkoa2V5KSkge1xuICAgICAgICBkaWFnMi53YXJuKFwiSW52YWxpZCBhdHRyaWJ1dGUga2V5OiBcIiArIGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0dHJpYnV0ZVZhbHVlKHZhbCkpIHtcbiAgICAgICAgZGlhZzIud2FybihcIkludmFsaWQgYXR0cmlidXRlIHZhbHVlIHNldCBmb3Iga2V5OiBcIiArIGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBvdXRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0W2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgIF9hMy5jYWxsKF9iMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzEpXG4gICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbl9fbmFtZShzYW5pdGl6ZUF0dHJpYnV0ZXMsIFwic2FuaXRpemVBdHRyaWJ1dGVzXCIpO1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVLZXkoa2V5KSB7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5sZW5ndGggPiAwO1xufVxuX19uYW1lKGlzQXR0cmlidXRlS2V5LCBcImlzQXR0cmlidXRlS2V5XCIpO1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVWYWx1ZSh2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBpc0hvbW9nZW5lb3VzQXR0cmlidXRlVmFsdWVBcnJheSh2YWwpO1xuICB9XG4gIHJldHVybiBpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUodmFsKTtcbn1cbl9fbmFtZShpc0F0dHJpYnV0ZVZhbHVlLCBcImlzQXR0cmlidXRlVmFsdWVcIik7XG5mdW5jdGlvbiBpc0hvbW9nZW5lb3VzQXR0cmlidXRlVmFsdWVBcnJheShhcnIpIHtcbiAgdmFyIGVfMiwgX2EzO1xuICB2YXIgdHlwZTtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBhcnJfMSA9IF9fdmFsdWVzKGFyciksIGFycl8xXzEgPSBhcnJfMS5uZXh0KCk7ICFhcnJfMV8xLmRvbmU7IGFycl8xXzEgPSBhcnJfMS5uZXh0KCkpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gYXJyXzFfMS52YWx1ZTtcbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUoZWxlbWVudCkpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZW9mIGVsZW1lbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSB0eXBlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJyXzFfMSAmJiAhYXJyXzFfMS5kb25lICYmIChfYTMgPSBhcnJfMS5yZXR1cm4pKVxuICAgICAgICBfYTMuY2FsbChhcnJfMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzIpXG4gICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5fX25hbWUoaXNIb21vZ2VuZW91c0F0dHJpYnV0ZVZhbHVlQXJyYXksIFwiaXNIb21vZ2VuZW91c0F0dHJpYnV0ZVZhbHVlQXJyYXlcIik7XG5mdW5jdGlvbiBpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUodmFsKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbl9fbmFtZShpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUsIFwiaXNWYWxpZFByaW1pdGl2ZUF0dHJpYnV0ZVZhbHVlXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9sb2dnaW5nLWVycm9yLWhhbmRsZXIuanNcbmZ1bmN0aW9uIGxvZ2dpbmdFcnJvckhhbmRsZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbihleCkge1xuICAgIGRpYWcyLmVycm9yKHN0cmluZ2lmeUV4Y2VwdGlvbihleCkpO1xuICB9O1xufVxuX19uYW1lKGxvZ2dpbmdFcnJvckhhbmRsZXIsIFwibG9nZ2luZ0Vycm9ySGFuZGxlclwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUV4Y2VwdGlvbihleCkge1xuICBpZiAodHlwZW9mIGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGV4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShmbGF0dGVuRXhjZXB0aW9uKGV4KSk7XG4gIH1cbn1cbl9fbmFtZShzdHJpbmdpZnlFeGNlcHRpb24sIFwic3RyaW5naWZ5RXhjZXB0aW9uXCIpO1xuZnVuY3Rpb24gZmxhdHRlbkV4Y2VwdGlvbihleCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBjdXJyZW50ID0gZXg7XG4gIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIGlmIChyZXN1bHRbcHJvcGVydHlOYW1lXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHZhbHVlID0gY3VycmVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUoZmxhdHRlbkV4Y2VwdGlvbiwgXCJmbGF0dGVuRXhjZXB0aW9uXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9nbG9iYWwtZXJyb3ItaGFuZGxlci5qc1xudmFyIGRlbGVnYXRlSGFuZGxlciA9IGxvZ2dpbmdFcnJvckhhbmRsZXIoKTtcbmZ1bmN0aW9uIGdsb2JhbEVycm9ySGFuZGxlcihleCkge1xuICB0cnkge1xuICAgIGRlbGVnYXRlSGFuZGxlcihleCk7XG4gIH0gY2F0Y2ggKF9hMykge1xuICB9XG59XG5fX25hbWUoZ2xvYmFsRXJyb3JIYW5kbGVyLCBcImdsb2JhbEVycm9ySGFuZGxlclwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2Vudmlyb25tZW50LmpzXG52YXIgb3MyID0gX190b0VTTShyZXF1aXJlKFwib3NcIikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3NhbXBsaW5nLmpzXG52YXIgVHJhY2VzU2FtcGxlclZhbHVlcztcbihmdW5jdGlvbihUcmFjZXNTYW1wbGVyVmFsdWVzMikge1xuICBUcmFjZXNTYW1wbGVyVmFsdWVzMltcIkFsd2F5c09mZlwiXSA9IFwiYWx3YXlzX29mZlwiO1xuICBUcmFjZXNTYW1wbGVyVmFsdWVzMltcIkFsd2F5c09uXCJdID0gXCJhbHdheXNfb25cIjtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJQYXJlbnRCYXNlZEFsd2F5c09mZlwiXSA9IFwicGFyZW50YmFzZWRfYWx3YXlzX29mZlwiO1xuICBUcmFjZXNTYW1wbGVyVmFsdWVzMltcIlBhcmVudEJhc2VkQWx3YXlzT25cIl0gPSBcInBhcmVudGJhc2VkX2Fsd2F5c19vblwiO1xuICBUcmFjZXNTYW1wbGVyVmFsdWVzMltcIlBhcmVudEJhc2VkVHJhY2VJZFJhdGlvXCJdID0gXCJwYXJlbnRiYXNlZF90cmFjZWlkcmF0aW9cIjtcbiAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJUcmFjZUlkUmF0aW9cIl0gPSBcInRyYWNlaWRyYXRpb1wiO1xufSkoVHJhY2VzU2FtcGxlclZhbHVlcyB8fCAoVHJhY2VzU2FtcGxlclZhbHVlcyA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vYnJvd3Nlci9nbG9iYWxUaGlzLmpzXG52YXIgX2dsb2JhbFRoaXMyID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB7fTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9lbnZpcm9ubWVudC5qc1xudmFyIERFRkFVTFRfTElTVF9TRVBBUkFUT1IgPSBcIixcIjtcbnZhciBFTlZJUk9OTUVOVF9OVU1CRVJTX0tFWVMgPSBbXG4gIFwiT1RFTF9CU1BfRVhQT1JUX1RJTUVPVVRcIixcbiAgXCJPVEVMX0JTUF9NQVhfRVhQT1JUX0JBVENIX1NJWkVcIixcbiAgXCJPVEVMX0JTUF9NQVhfUVVFVUVfU0laRVwiLFxuICBcIk9URUxfQlNQX1NDSEVEVUxFX0RFTEFZXCIsXG4gIFwiT1RFTF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUXCIsXG4gIFwiT1RFTF9BVFRSSUJVVEVfQ09VTlRfTElNSVRcIixcbiAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVFwiLFxuICBcIk9URUxfU1BBTl9BVFRSSUJVVEVfQ09VTlRfTElNSVRcIixcbiAgXCJPVEVMX1NQQU5fRVZFTlRfQ09VTlRfTElNSVRcIixcbiAgXCJPVEVMX1NQQU5fTElOS19DT1VOVF9MSU1JVFwiLFxuICBcIk9URUxfRVhQT1JURVJfT1RMUF9USU1FT1VUXCIsXG4gIFwiT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19USU1FT1VUXCIsXG4gIFwiT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfVElNRU9VVFwiLFxuICBcIk9URUxfRVhQT1JURVJfSkFFR0VSX0FHRU5UX1BPUlRcIlxuXTtcbmZ1bmN0aW9uIGlzRW52VmFyQU51bWJlcihrZXkpIHtcbiAgcmV0dXJuIEVOVklST05NRU5UX05VTUJFUlNfS0VZUy5pbmRleE9mKGtleSkgPiAtMTtcbn1cbl9fbmFtZShpc0VudlZhckFOdW1iZXIsIFwiaXNFbnZWYXJBTnVtYmVyXCIpO1xudmFyIEVOVklST05NRU5UX0xJU1RTX0tFWVMgPSBbXG4gIFwiT1RFTF9OT19QQVRDSF9NT0RVTEVTXCIsXG4gIFwiT1RFTF9QUk9QQUdBVE9SU1wiXG5dO1xuZnVuY3Rpb24gaXNFbnZWYXJBTGlzdChrZXkpIHtcbiAgcmV0dXJuIEVOVklST05NRU5UX0xJU1RTX0tFWVMuaW5kZXhPZihrZXkpID4gLTE7XG59XG5fX25hbWUoaXNFbnZWYXJBTGlzdCwgXCJpc0VudlZhckFMaXN0XCIpO1xudmFyIERFRkFVTFRfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCA9IEluZmluaXR5O1xudmFyIERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlUID0gMTI4O1xudmFyIERFRkFVTFRfRU5WSVJPTk1FTlQgPSB7XG4gIENPTlRBSU5FUl9OQU1FOiBcIlwiLFxuICBFQ1NfQ09OVEFJTkVSX01FVEFEQVRBX1VSSV9WNDogXCJcIixcbiAgRUNTX0NPTlRBSU5FUl9NRVRBREFUQV9VUkk6IFwiXCIsXG4gIEhPU1ROQU1FOiBcIlwiLFxuICBLVUJFUk5FVEVTX1NFUlZJQ0VfSE9TVDogXCJcIixcbiAgTkFNRVNQQUNFOiBcIlwiLFxuICBPVEVMX0JTUF9FWFBPUlRfVElNRU9VVDogM2U0LFxuICBPVEVMX0JTUF9NQVhfRVhQT1JUX0JBVENIX1NJWkU6IDUxMixcbiAgT1RFTF9CU1BfTUFYX1FVRVVFX1NJWkU6IDIwNDgsXG4gIE9URUxfQlNQX1NDSEVEVUxFX0RFTEFZOiA1ZTMsXG4gIE9URUxfRVhQT1JURVJfSkFFR0VSX0FHRU5UX0hPU1Q6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfSkFFR0VSX0FHRU5UX1BPUlQ6IDY4MzIsXG4gIE9URUxfRVhQT1JURVJfSkFFR0VSX0VORFBPSU5UOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9QQVNTV09SRDogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9KQUVHRVJfVVNFUjogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0VORFBPSU5UOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0VORFBPSU5UOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19FTkRQT0lOVDogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX0hFQURFUlM6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfSEVBREVSUzogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfSEVBREVSUzogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX1RJTUVPVVQ6IDFlNCxcbiAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19USU1FT1VUOiAxZTQsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX1RJTUVPVVQ6IDFlNCxcbiAgT1RFTF9FWFBPUlRFUl9aSVBLSU5fRU5EUE9JTlQ6IFwiaHR0cDovL2xvY2FsaG9zdDo5NDExL2FwaS92Mi9zcGFuc1wiLFxuICBPVEVMX0xPR19MRVZFTDogRGlhZ0xvZ0xldmVsLklORk8sXG4gIE9URUxfTk9fUEFUQ0hfTU9EVUxFUzogW10sXG4gIE9URUxfUFJPUEFHQVRPUlM6IFtcInRyYWNlY29udGV4dFwiLCBcImJhZ2dhZ2VcIl0sXG4gIE9URUxfUkVTT1VSQ0VfQVRUUklCVVRFUzogXCJcIixcbiAgT1RFTF9TRVJWSUNFX05BTUU6IFwiXCIsXG4gIE9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlULFxuICBPVEVMX0FUVFJJQlVURV9DT1VOVF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfQ09VTlRfTElNSVQsXG4gIE9URUxfU1BBTl9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUOiBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQsXG4gIE9URUxfU1BBTl9BVFRSSUJVVEVfQ09VTlRfTElNSVQ6IERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlULFxuICBPVEVMX1NQQU5fRVZFTlRfQ09VTlRfTElNSVQ6IDEyOCxcbiAgT1RFTF9TUEFOX0xJTktfQ09VTlRfTElNSVQ6IDEyOCxcbiAgT1RFTF9UUkFDRVNfRVhQT1JURVI6IFwibm9uZVwiLFxuICBPVEVMX1RSQUNFU19TQU1QTEVSOiBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkQWx3YXlzT24sXG4gIE9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfSU5TRUNVUkU6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfSU5TRUNVUkU6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0lOU0VDVVJFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfQ0VSVElGSUNBVEU6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ0VSVElGSUNBVEU6IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0NFUlRJRklDQVRFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfQ09NUFJFU1NJT046IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ09NUFJFU1NJT046IFwiXCIsXG4gIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0NPTVBSRVNTSU9OOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfQ0xJRU5UX0tFWTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19DTElFTlRfS0VZOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19DTElFTlRfS0VZOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfQ0xJRU5UX0NFUlRJRklDQVRFOiBcIlwiLFxuICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0NMSUVOVF9DRVJUSUZJQ0FURTogXCJcIixcbiAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfQ0xJRU5UX0NFUlRJRklDQVRFOiBcIlwiXG59O1xuZnVuY3Rpb24gcGFyc2VOdW1iZXIobmFtZSwgZW52aXJvbm1lbnQsIHZhbHVlcywgbWluMiwgbWF4Mikge1xuICBpZiAobWluMiA9PT0gdm9pZCAwKSB7XG4gICAgbWluMiA9IC1JbmZpbml0eTtcbiAgfVxuICBpZiAobWF4MiA9PT0gdm9pZCAwKSB7XG4gICAgbWF4MiA9IEluZmluaXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWVzW25hbWVdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyKHZhbHVlc1tuYW1lXSk7XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA8IG1pbjIpIHtcbiAgICAgICAgZW52aXJvbm1lbnRbbmFtZV0gPSBtaW4yO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heDIpIHtcbiAgICAgICAgZW52aXJvbm1lbnRbbmFtZV0gPSBtYXgyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52aXJvbm1lbnRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbl9fbmFtZShwYXJzZU51bWJlciwgXCJwYXJzZU51bWJlclwiKTtcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nTGlzdChuYW1lLCBvdXRwdXQsIGlucHV0LCBzZXBhcmF0b3IpIHtcbiAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VwYXJhdG9yID0gREVGQVVMVF9MSVNUX1NFUEFSQVRPUjtcbiAgfVxuICB2YXIgZ2l2ZW5WYWx1ZSA9IGlucHV0W25hbWVdO1xuICBpZiAodHlwZW9mIGdpdmVuVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvdXRwdXRbbmFtZV0gPSBnaXZlblZhbHVlLnNwbGl0KHNlcGFyYXRvcikubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnRyaW0oKTtcbiAgICB9KTtcbiAgfVxufVxuX19uYW1lKHBhcnNlU3RyaW5nTGlzdCwgXCJwYXJzZVN0cmluZ0xpc3RcIik7XG52YXIgbG9nTGV2ZWxNYXAgPSB7XG4gIEFMTDogRGlhZ0xvZ0xldmVsLkFMTCxcbiAgVkVSQk9TRTogRGlhZ0xvZ0xldmVsLlZFUkJPU0UsXG4gIERFQlVHOiBEaWFnTG9nTGV2ZWwuREVCVUcsXG4gIElORk86IERpYWdMb2dMZXZlbC5JTkZPLFxuICBXQVJOOiBEaWFnTG9nTGV2ZWwuV0FSTixcbiAgRVJST1I6IERpYWdMb2dMZXZlbC5FUlJPUixcbiAgTk9ORTogRGlhZ0xvZ0xldmVsLk5PTkVcbn07XG5mdW5jdGlvbiBzZXRMb2dMZXZlbEZyb21FbnYoa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIHRoZUxldmVsID0gbG9nTGV2ZWxNYXBbdmFsdWUudG9VcHBlckNhc2UoKV07XG4gICAgaWYgKHRoZUxldmVsICE9IG51bGwpIHtcbiAgICAgIGVudmlyb25tZW50W2tleV0gPSB0aGVMZXZlbDtcbiAgICB9XG4gIH1cbn1cbl9fbmFtZShzZXRMb2dMZXZlbEZyb21FbnYsIFwic2V0TG9nTGV2ZWxGcm9tRW52XCIpO1xuZnVuY3Rpb24gcGFyc2VFbnZpcm9ubWVudCh2YWx1ZXMpIHtcbiAgdmFyIGVudmlyb25tZW50ID0ge307XG4gIGZvciAodmFyIGVudjIgaW4gREVGQVVMVF9FTlZJUk9OTUVOVCkge1xuICAgIHZhciBrZXkgPSBlbnYyO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwiT1RFTF9MT0dfTEVWRUxcIjpcbiAgICAgICAgc2V0TG9nTGV2ZWxGcm9tRW52KGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzRW52VmFyQU51bWJlcihrZXkpKSB7XG4gICAgICAgICAgcGFyc2VOdW1iZXIoa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0VudlZhckFMaXN0KGtleSkpIHtcbiAgICAgICAgICBwYXJzZVN0cmluZ0xpc3Qoa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbnZpcm9ubWVudFtrZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudmlyb25tZW50O1xufVxuX19uYW1lKHBhcnNlRW52aXJvbm1lbnQsIFwicGFyc2VFbnZpcm9ubWVudFwiKTtcbmZ1bmN0aW9uIGdldEVudldpdGhvdXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiID8gcGFyc2VFbnZpcm9ubWVudChwcm9jZXNzLmVudikgOiBwYXJzZUVudmlyb25tZW50KF9nbG9iYWxUaGlzMik7XG59XG5fX25hbWUoZ2V0RW52V2l0aG91dERlZmF1bHRzLCBcImdldEVudldpdGhvdXREZWZhdWx0c1wiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2Vudmlyb25tZW50LmpzXG5mdW5jdGlvbiBnZXRFbnYoKSB7XG4gIHZhciBwcm9jZXNzRW52ID0gcGFyc2VFbnZpcm9ubWVudChwcm9jZXNzLmVudik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICBIT1NUTkFNRTogb3MyLmhvc3RuYW1lKClcbiAgfSwgREVGQVVMVF9FTlZJUk9OTUVOVCwgcHJvY2Vzc0Vudik7XG59XG5fX25hbWUoZ2V0RW52LCBcImdldEVudlwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2dsb2JhbFRoaXMuanNcbnZhciBfZ2xvYmFsVGhpczMgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMgOiBnbG9iYWw7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9oZXgtdG8tYmFzZTY0LmpzXG52YXIgYnVmOCA9IEJ1ZmZlci5hbGxvYyg4KTtcbnZhciBidWYxNiA9IEJ1ZmZlci5hbGxvYygxNik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9SYW5kb21JZEdlbmVyYXRvci5qc1xudmFyIFNQQU5fSURfQllURVMgPSA4O1xudmFyIFRSQUNFX0lEX0JZVEVTID0gMTY7XG52YXIgUmFuZG9tSWRHZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmFuZG9tSWRHZW5lcmF0b3IzKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVUcmFjZUlkID0gZ2V0SWRHZW5lcmF0b3IoVFJBQ0VfSURfQllURVMpO1xuICAgIHRoaXMuZ2VuZXJhdGVTcGFuSWQgPSBnZXRJZEdlbmVyYXRvcihTUEFOX0lEX0JZVEVTKTtcbiAgfVxuICBfX25hbWUoUmFuZG9tSWRHZW5lcmF0b3IzLCBcIlJhbmRvbUlkR2VuZXJhdG9yXCIpO1xuICByZXR1cm4gUmFuZG9tSWRHZW5lcmF0b3IzO1xufSgpO1xudmFyIFNIQVJFRF9CVUZGRVIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoVFJBQ0VfSURfQllURVMpO1xuZnVuY3Rpb24gZ2V0SWRHZW5lcmF0b3IoYnl0ZXMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzIC8gNDsgaSsrKSB7XG4gICAgICBTSEFSRURfQlVGRkVSLndyaXRlVUludDMyQkUoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIDMyKSA+Pj4gMCwgaSAqIDQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgIGlmIChTSEFSRURfQlVGRkVSW2ldID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gYnl0ZXMgLSAxKSB7XG4gICAgICAgIFNIQVJFRF9CVUZGRVJbYnl0ZXMgLSAxXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTSEFSRURfQlVGRkVSLnRvU3RyaW5nKFwiaGV4XCIsIDAsIGJ5dGVzKTtcbiAgfSwgXCJnZW5lcmF0ZUlkXCIpO1xufVxuX19uYW1lKGdldElkR2VuZXJhdG9yLCBcImdldElkR2VuZXJhdG9yXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvcGVyZm9ybWFuY2UuanNcbnZhciBpbXBvcnRfcGVyZl9ob29rcyA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpO1xudmFyIG90cGVyZm9ybWFuY2UgPSBpbXBvcnRfcGVyZl9ob29rcy5wZXJmb3JtYW5jZTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTjIgPSBcIjEuNi4wXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZW1hbnRpYy1jb252ZW50aW9uc0AxLjYuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3RyYWNlL1NlbWFudGljQXR0cmlidXRlcy5qc1xudmFyIFNlbWFudGljQXR0cmlidXRlcyA9IHtcbiAgQVdTX0xBTUJEQV9JTlZPS0VEX0FSTjogXCJhd3MubGFtYmRhLmludm9rZWRfYXJuXCIsXG4gIERCX1NZU1RFTTogXCJkYi5zeXN0ZW1cIixcbiAgREJfQ09OTkVDVElPTl9TVFJJTkc6IFwiZGIuY29ubmVjdGlvbl9zdHJpbmdcIixcbiAgREJfVVNFUjogXCJkYi51c2VyXCIsXG4gIERCX0pEQkNfRFJJVkVSX0NMQVNTTkFNRTogXCJkYi5qZGJjLmRyaXZlcl9jbGFzc25hbWVcIixcbiAgREJfTkFNRTogXCJkYi5uYW1lXCIsXG4gIERCX1NUQVRFTUVOVDogXCJkYi5zdGF0ZW1lbnRcIixcbiAgREJfT1BFUkFUSU9OOiBcImRiLm9wZXJhdGlvblwiLFxuICBEQl9NU1NRTF9JTlNUQU5DRV9OQU1FOiBcImRiLm1zc3FsLmluc3RhbmNlX25hbWVcIixcbiAgREJfQ0FTU0FORFJBX0tFWVNQQUNFOiBcImRiLmNhc3NhbmRyYS5rZXlzcGFjZVwiLFxuICBEQl9DQVNTQU5EUkFfUEFHRV9TSVpFOiBcImRiLmNhc3NhbmRyYS5wYWdlX3NpemVcIixcbiAgREJfQ0FTU0FORFJBX0NPTlNJU1RFTkNZX0xFVkVMOiBcImRiLmNhc3NhbmRyYS5jb25zaXN0ZW5jeV9sZXZlbFwiLFxuICBEQl9DQVNTQU5EUkFfVEFCTEU6IFwiZGIuY2Fzc2FuZHJhLnRhYmxlXCIsXG4gIERCX0NBU1NBTkRSQV9JREVNUE9URU5DRTogXCJkYi5jYXNzYW5kcmEuaWRlbXBvdGVuY2VcIixcbiAgREJfQ0FTU0FORFJBX1NQRUNVTEFUSVZFX0VYRUNVVElPTl9DT1VOVDogXCJkYi5jYXNzYW5kcmEuc3BlY3VsYXRpdmVfZXhlY3V0aW9uX2NvdW50XCIsXG4gIERCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9JRDogXCJkYi5jYXNzYW5kcmEuY29vcmRpbmF0b3IuaWRcIixcbiAgREJfQ0FTU0FORFJBX0NPT1JESU5BVE9SX0RDOiBcImRiLmNhc3NhbmRyYS5jb29yZGluYXRvci5kY1wiLFxuICBEQl9IQkFTRV9OQU1FU1BBQ0U6IFwiZGIuaGJhc2UubmFtZXNwYWNlXCIsXG4gIERCX1JFRElTX0RBVEFCQVNFX0lOREVYOiBcImRiLnJlZGlzLmRhdGFiYXNlX2luZGV4XCIsXG4gIERCX01PTkdPREJfQ09MTEVDVElPTjogXCJkYi5tb25nb2RiLmNvbGxlY3Rpb25cIixcbiAgREJfU1FMX1RBQkxFOiBcImRiLnNxbC50YWJsZVwiLFxuICBFWENFUFRJT05fVFlQRTogXCJleGNlcHRpb24udHlwZVwiLFxuICBFWENFUFRJT05fTUVTU0FHRTogXCJleGNlcHRpb24ubWVzc2FnZVwiLFxuICBFWENFUFRJT05fU1RBQ0tUUkFDRTogXCJleGNlcHRpb24uc3RhY2t0cmFjZVwiLFxuICBFWENFUFRJT05fRVNDQVBFRDogXCJleGNlcHRpb24uZXNjYXBlZFwiLFxuICBGQUFTX1RSSUdHRVI6IFwiZmFhcy50cmlnZ2VyXCIsXG4gIEZBQVNfRVhFQ1VUSU9OOiBcImZhYXMuZXhlY3V0aW9uXCIsXG4gIEZBQVNfRE9DVU1FTlRfQ09MTEVDVElPTjogXCJmYWFzLmRvY3VtZW50LmNvbGxlY3Rpb25cIixcbiAgRkFBU19ET0NVTUVOVF9PUEVSQVRJT046IFwiZmFhcy5kb2N1bWVudC5vcGVyYXRpb25cIixcbiAgRkFBU19ET0NVTUVOVF9USU1FOiBcImZhYXMuZG9jdW1lbnQudGltZVwiLFxuICBGQUFTX0RPQ1VNRU5UX05BTUU6IFwiZmFhcy5kb2N1bWVudC5uYW1lXCIsXG4gIEZBQVNfVElNRTogXCJmYWFzLnRpbWVcIixcbiAgRkFBU19DUk9OOiBcImZhYXMuY3JvblwiLFxuICBGQUFTX0NPTERTVEFSVDogXCJmYWFzLmNvbGRzdGFydFwiLFxuICBGQUFTX0lOVk9LRURfTkFNRTogXCJmYWFzLmludm9rZWRfbmFtZVwiLFxuICBGQUFTX0lOVk9LRURfUFJPVklERVI6IFwiZmFhcy5pbnZva2VkX3Byb3ZpZGVyXCIsXG4gIEZBQVNfSU5WT0tFRF9SRUdJT046IFwiZmFhcy5pbnZva2VkX3JlZ2lvblwiLFxuICBORVRfVFJBTlNQT1JUOiBcIm5ldC50cmFuc3BvcnRcIixcbiAgTkVUX1BFRVJfSVA6IFwibmV0LnBlZXIuaXBcIixcbiAgTkVUX1BFRVJfUE9SVDogXCJuZXQucGVlci5wb3J0XCIsXG4gIE5FVF9QRUVSX05BTUU6IFwibmV0LnBlZXIubmFtZVwiLFxuICBORVRfSE9TVF9JUDogXCJuZXQuaG9zdC5pcFwiLFxuICBORVRfSE9TVF9QT1JUOiBcIm5ldC5ob3N0LnBvcnRcIixcbiAgTkVUX0hPU1RfTkFNRTogXCJuZXQuaG9zdC5uYW1lXCIsXG4gIE5FVF9IT1NUX0NPTk5FQ1RJT05fVFlQRTogXCJuZXQuaG9zdC5jb25uZWN0aW9uLnR5cGVcIixcbiAgTkVUX0hPU1RfQ09OTkVDVElPTl9TVUJUWVBFOiBcIm5ldC5ob3N0LmNvbm5lY3Rpb24uc3VidHlwZVwiLFxuICBORVRfSE9TVF9DQVJSSUVSX05BTUU6IFwibmV0Lmhvc3QuY2Fycmllci5uYW1lXCIsXG4gIE5FVF9IT1NUX0NBUlJJRVJfTUNDOiBcIm5ldC5ob3N0LmNhcnJpZXIubWNjXCIsXG4gIE5FVF9IT1NUX0NBUlJJRVJfTU5DOiBcIm5ldC5ob3N0LmNhcnJpZXIubW5jXCIsXG4gIE5FVF9IT1NUX0NBUlJJRVJfSUNDOiBcIm5ldC5ob3N0LmNhcnJpZXIuaWNjXCIsXG4gIFBFRVJfU0VSVklDRTogXCJwZWVyLnNlcnZpY2VcIixcbiAgRU5EVVNFUl9JRDogXCJlbmR1c2VyLmlkXCIsXG4gIEVORFVTRVJfUk9MRTogXCJlbmR1c2VyLnJvbGVcIixcbiAgRU5EVVNFUl9TQ09QRTogXCJlbmR1c2VyLnNjb3BlXCIsXG4gIFRIUkVBRF9JRDogXCJ0aHJlYWQuaWRcIixcbiAgVEhSRUFEX05BTUU6IFwidGhyZWFkLm5hbWVcIixcbiAgQ09ERV9GVU5DVElPTjogXCJjb2RlLmZ1bmN0aW9uXCIsXG4gIENPREVfTkFNRVNQQUNFOiBcImNvZGUubmFtZXNwYWNlXCIsXG4gIENPREVfRklMRVBBVEg6IFwiY29kZS5maWxlcGF0aFwiLFxuICBDT0RFX0xJTkVOTzogXCJjb2RlLmxpbmVub1wiLFxuICBIVFRQX01FVEhPRDogXCJodHRwLm1ldGhvZFwiLFxuICBIVFRQX1VSTDogXCJodHRwLnVybFwiLFxuICBIVFRQX1RBUkdFVDogXCJodHRwLnRhcmdldFwiLFxuICBIVFRQX0hPU1Q6IFwiaHR0cC5ob3N0XCIsXG4gIEhUVFBfU0NIRU1FOiBcImh0dHAuc2NoZW1lXCIsXG4gIEhUVFBfU1RBVFVTX0NPREU6IFwiaHR0cC5zdGF0dXNfY29kZVwiLFxuICBIVFRQX0ZMQVZPUjogXCJodHRwLmZsYXZvclwiLFxuICBIVFRQX1VTRVJfQUdFTlQ6IFwiaHR0cC51c2VyX2FnZW50XCIsXG4gIEhUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSDogXCJodHRwLnJlcXVlc3RfY29udGVudF9sZW5ndGhcIixcbiAgSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRDogXCJodHRwLnJlcXVlc3RfY29udGVudF9sZW5ndGhfdW5jb21wcmVzc2VkXCIsXG4gIEhUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEg6IFwiaHR0cC5yZXNwb25zZV9jb250ZW50X2xlbmd0aFwiLFxuICBIVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRDogXCJodHRwLnJlc3BvbnNlX2NvbnRlbnRfbGVuZ3RoX3VuY29tcHJlc3NlZFwiLFxuICBIVFRQX1NFUlZFUl9OQU1FOiBcImh0dHAuc2VydmVyX25hbWVcIixcbiAgSFRUUF9ST1VURTogXCJodHRwLnJvdXRlXCIsXG4gIEhUVFBfQ0xJRU5UX0lQOiBcImh0dHAuY2xpZW50X2lwXCIsXG4gIEFXU19EWU5BTU9EQl9UQUJMRV9OQU1FUzogXCJhd3MuZHluYW1vZGIudGFibGVfbmFtZXNcIixcbiAgQVdTX0RZTkFNT0RCX0NPTlNVTUVEX0NBUEFDSVRZOiBcImF3cy5keW5hbW9kYi5jb25zdW1lZF9jYXBhY2l0eVwiLFxuICBBV1NfRFlOQU1PREJfSVRFTV9DT0xMRUNUSU9OX01FVFJJQ1M6IFwiYXdzLmR5bmFtb2RiLml0ZW1fY29sbGVjdGlvbl9tZXRyaWNzXCIsXG4gIEFXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9SRUFEX0NBUEFDSVRZOiBcImF3cy5keW5hbW9kYi5wcm92aXNpb25lZF9yZWFkX2NhcGFjaXR5XCIsXG4gIEFXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9XUklURV9DQVBBQ0lUWTogXCJhd3MuZHluYW1vZGIucHJvdmlzaW9uZWRfd3JpdGVfY2FwYWNpdHlcIixcbiAgQVdTX0RZTkFNT0RCX0NPTlNJU1RFTlRfUkVBRDogXCJhd3MuZHluYW1vZGIuY29uc2lzdGVudF9yZWFkXCIsXG4gIEFXU19EWU5BTU9EQl9QUk9KRUNUSU9OOiBcImF3cy5keW5hbW9kYi5wcm9qZWN0aW9uXCIsXG4gIEFXU19EWU5BTU9EQl9MSU1JVDogXCJhd3MuZHluYW1vZGIubGltaXRcIixcbiAgQVdTX0RZTkFNT0RCX0FUVFJJQlVURVNfVE9fR0VUOiBcImF3cy5keW5hbW9kYi5hdHRyaWJ1dGVzX3RvX2dldFwiLFxuICBBV1NfRFlOQU1PREJfSU5ERVhfTkFNRTogXCJhd3MuZHluYW1vZGIuaW5kZXhfbmFtZVwiLFxuICBBV1NfRFlOQU1PREJfU0VMRUNUOiBcImF3cy5keW5hbW9kYi5zZWxlY3RcIixcbiAgQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhFUzogXCJhd3MuZHluYW1vZGIuZ2xvYmFsX3NlY29uZGFyeV9pbmRleGVzXCIsXG4gIEFXU19EWU5BTU9EQl9MT0NBTF9TRUNPTkRBUllfSU5ERVhFUzogXCJhd3MuZHluYW1vZGIubG9jYWxfc2Vjb25kYXJ5X2luZGV4ZXNcIixcbiAgQVdTX0RZTkFNT0RCX0VYQ0xVU0lWRV9TVEFSVF9UQUJMRTogXCJhd3MuZHluYW1vZGIuZXhjbHVzaXZlX3N0YXJ0X3RhYmxlXCIsXG4gIEFXU19EWU5BTU9EQl9UQUJMRV9DT1VOVDogXCJhd3MuZHluYW1vZGIudGFibGVfY291bnRcIixcbiAgQVdTX0RZTkFNT0RCX1NDQU5fRk9SV0FSRDogXCJhd3MuZHluYW1vZGIuc2Nhbl9mb3J3YXJkXCIsXG4gIEFXU19EWU5BTU9EQl9TRUdNRU5UOiBcImF3cy5keW5hbW9kYi5zZWdtZW50XCIsXG4gIEFXU19EWU5BTU9EQl9UT1RBTF9TRUdNRU5UUzogXCJhd3MuZHluYW1vZGIudG90YWxfc2VnbWVudHNcIixcbiAgQVdTX0RZTkFNT0RCX0NPVU5UOiBcImF3cy5keW5hbW9kYi5jb3VudFwiLFxuICBBV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVDogXCJhd3MuZHluYW1vZGIuc2Nhbm5lZF9jb3VudFwiLFxuICBBV1NfRFlOQU1PREJfQVRUUklCVVRFX0RFRklOSVRJT05TOiBcImF3cy5keW5hbW9kYi5hdHRyaWJ1dGVfZGVmaW5pdGlvbnNcIixcbiAgQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhfVVBEQVRFUzogXCJhd3MuZHluYW1vZGIuZ2xvYmFsX3NlY29uZGFyeV9pbmRleF91cGRhdGVzXCIsXG4gIE1FU1NBR0lOR19TWVNURU06IFwibWVzc2FnaW5nLnN5c3RlbVwiLFxuICBNRVNTQUdJTkdfREVTVElOQVRJT046IFwibWVzc2FnaW5nLmRlc3RpbmF0aW9uXCIsXG4gIE1FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EOiBcIm1lc3NhZ2luZy5kZXN0aW5hdGlvbl9raW5kXCIsXG4gIE1FU1NBR0lOR19URU1QX0RFU1RJTkFUSU9OOiBcIm1lc3NhZ2luZy50ZW1wX2Rlc3RpbmF0aW9uXCIsXG4gIE1FU1NBR0lOR19QUk9UT0NPTDogXCJtZXNzYWdpbmcucHJvdG9jb2xcIixcbiAgTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT046IFwibWVzc2FnaW5nLnByb3RvY29sX3ZlcnNpb25cIixcbiAgTUVTU0FHSU5HX1VSTDogXCJtZXNzYWdpbmcudXJsXCIsXG4gIE1FU1NBR0lOR19NRVNTQUdFX0lEOiBcIm1lc3NhZ2luZy5tZXNzYWdlX2lkXCIsXG4gIE1FU1NBR0lOR19DT05WRVJTQVRJT05fSUQ6IFwibWVzc2FnaW5nLmNvbnZlcnNhdGlvbl9pZFwiLFxuICBNRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVM6IFwibWVzc2FnaW5nLm1lc3NhZ2VfcGF5bG9hZF9zaXplX2J5dGVzXCIsXG4gIE1FU1NBR0lOR19NRVNTQUdFX1BBWUxPQURfQ09NUFJFU1NFRF9TSVpFX0JZVEVTOiBcIm1lc3NhZ2luZy5tZXNzYWdlX3BheWxvYWRfY29tcHJlc3NlZF9zaXplX2J5dGVzXCIsXG4gIE1FU1NBR0lOR19PUEVSQVRJT046IFwibWVzc2FnaW5nLm9wZXJhdGlvblwiLFxuICBNRVNTQUdJTkdfQ09OU1VNRVJfSUQ6IFwibWVzc2FnaW5nLmNvbnN1bWVyX2lkXCIsXG4gIE1FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWTogXCJtZXNzYWdpbmcucmFiYml0bXEucm91dGluZ19rZXlcIixcbiAgTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZOiBcIm1lc3NhZ2luZy5rYWZrYS5tZXNzYWdlX2tleVwiLFxuICBNRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVA6IFwibWVzc2FnaW5nLmthZmthLmNvbnN1bWVyX2dyb3VwXCIsXG4gIE1FU1NBR0lOR19LQUZLQV9DTElFTlRfSUQ6IFwibWVzc2FnaW5nLmthZmthLmNsaWVudF9pZFwiLFxuICBNRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OOiBcIm1lc3NhZ2luZy5rYWZrYS5wYXJ0aXRpb25cIixcbiAgTUVTU0FHSU5HX0tBRktBX1RPTUJTVE9ORTogXCJtZXNzYWdpbmcua2Fma2EudG9tYnN0b25lXCIsXG4gIFJQQ19TWVNURU06IFwicnBjLnN5c3RlbVwiLFxuICBSUENfU0VSVklDRTogXCJycGMuc2VydmljZVwiLFxuICBSUENfTUVUSE9EOiBcInJwYy5tZXRob2RcIixcbiAgUlBDX0dSUENfU1RBVFVTX0NPREU6IFwicnBjLmdycGMuc3RhdHVzX2NvZGVcIixcbiAgUlBDX0pTT05SUENfVkVSU0lPTjogXCJycGMuanNvbnJwYy52ZXJzaW9uXCIsXG4gIFJQQ19KU09OUlBDX1JFUVVFU1RfSUQ6IFwicnBjLmpzb25ycGMucmVxdWVzdF9pZFwiLFxuICBSUENfSlNPTlJQQ19FUlJPUl9DT0RFOiBcInJwYy5qc29ucnBjLmVycm9yX2NvZGVcIixcbiAgUlBDX0pTT05SUENfRVJST1JfTUVTU0FHRTogXCJycGMuanNvbnJwYy5lcnJvcl9tZXNzYWdlXCIsXG4gIE1FU1NBR0VfVFlQRTogXCJtZXNzYWdlLnR5cGVcIixcbiAgTUVTU0FHRV9JRDogXCJtZXNzYWdlLmlkXCIsXG4gIE1FU1NBR0VfQ09NUFJFU1NFRF9TSVpFOiBcIm1lc3NhZ2UuY29tcHJlc3NlZF9zaXplXCIsXG4gIE1FU1NBR0VfVU5DT01QUkVTU0VEX1NJWkU6IFwibWVzc2FnZS51bmNvbXByZXNzZWRfc2l6ZVwiXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2VtYW50aWMtY29udmVudGlvbnNAMS42LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2J1aWxkL2VzbS9yZXNvdXJjZS9TZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5qc1xudmFyIFNlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzID0ge1xuICBDTE9VRF9QUk9WSURFUjogXCJjbG91ZC5wcm92aWRlclwiLFxuICBDTE9VRF9BQ0NPVU5UX0lEOiBcImNsb3VkLmFjY291bnQuaWRcIixcbiAgQ0xPVURfUkVHSU9OOiBcImNsb3VkLnJlZ2lvblwiLFxuICBDTE9VRF9BVkFJTEFCSUxJVFlfWk9ORTogXCJjbG91ZC5hdmFpbGFiaWxpdHlfem9uZVwiLFxuICBDTE9VRF9QTEFURk9STTogXCJjbG91ZC5wbGF0Zm9ybVwiLFxuICBBV1NfRUNTX0NPTlRBSU5FUl9BUk46IFwiYXdzLmVjcy5jb250YWluZXIuYXJuXCIsXG4gIEFXU19FQ1NfQ0xVU1RFUl9BUk46IFwiYXdzLmVjcy5jbHVzdGVyLmFyblwiLFxuICBBV1NfRUNTX0xBVU5DSFRZUEU6IFwiYXdzLmVjcy5sYXVuY2h0eXBlXCIsXG4gIEFXU19FQ1NfVEFTS19BUk46IFwiYXdzLmVjcy50YXNrLmFyblwiLFxuICBBV1NfRUNTX1RBU0tfRkFNSUxZOiBcImF3cy5lY3MudGFzay5mYW1pbHlcIixcbiAgQVdTX0VDU19UQVNLX1JFVklTSU9OOiBcImF3cy5lY3MudGFzay5yZXZpc2lvblwiLFxuICBBV1NfRUtTX0NMVVNURVJfQVJOOiBcImF3cy5la3MuY2x1c3Rlci5hcm5cIixcbiAgQVdTX0xPR19HUk9VUF9OQU1FUzogXCJhd3MubG9nLmdyb3VwLm5hbWVzXCIsXG4gIEFXU19MT0dfR1JPVVBfQVJOUzogXCJhd3MubG9nLmdyb3VwLmFybnNcIixcbiAgQVdTX0xPR19TVFJFQU1fTkFNRVM6IFwiYXdzLmxvZy5zdHJlYW0ubmFtZXNcIixcbiAgQVdTX0xPR19TVFJFQU1fQVJOUzogXCJhd3MubG9nLnN0cmVhbS5hcm5zXCIsXG4gIENPTlRBSU5FUl9OQU1FOiBcImNvbnRhaW5lci5uYW1lXCIsXG4gIENPTlRBSU5FUl9JRDogXCJjb250YWluZXIuaWRcIixcbiAgQ09OVEFJTkVSX1JVTlRJTUU6IFwiY29udGFpbmVyLnJ1bnRpbWVcIixcbiAgQ09OVEFJTkVSX0lNQUdFX05BTUU6IFwiY29udGFpbmVyLmltYWdlLm5hbWVcIixcbiAgQ09OVEFJTkVSX0lNQUdFX1RBRzogXCJjb250YWluZXIuaW1hZ2UudGFnXCIsXG4gIERFUExPWU1FTlRfRU5WSVJPTk1FTlQ6IFwiZGVwbG95bWVudC5lbnZpcm9ubWVudFwiLFxuICBERVZJQ0VfSUQ6IFwiZGV2aWNlLmlkXCIsXG4gIERFVklDRV9NT0RFTF9JREVOVElGSUVSOiBcImRldmljZS5tb2RlbC5pZGVudGlmaWVyXCIsXG4gIERFVklDRV9NT0RFTF9OQU1FOiBcImRldmljZS5tb2RlbC5uYW1lXCIsXG4gIEZBQVNfTkFNRTogXCJmYWFzLm5hbWVcIixcbiAgRkFBU19JRDogXCJmYWFzLmlkXCIsXG4gIEZBQVNfVkVSU0lPTjogXCJmYWFzLnZlcnNpb25cIixcbiAgRkFBU19JTlNUQU5DRTogXCJmYWFzLmluc3RhbmNlXCIsXG4gIEZBQVNfTUFYX01FTU9SWTogXCJmYWFzLm1heF9tZW1vcnlcIixcbiAgSE9TVF9JRDogXCJob3N0LmlkXCIsXG4gIEhPU1RfTkFNRTogXCJob3N0Lm5hbWVcIixcbiAgSE9TVF9UWVBFOiBcImhvc3QudHlwZVwiLFxuICBIT1NUX0FSQ0g6IFwiaG9zdC5hcmNoXCIsXG4gIEhPU1RfSU1BR0VfTkFNRTogXCJob3N0LmltYWdlLm5hbWVcIixcbiAgSE9TVF9JTUFHRV9JRDogXCJob3N0LmltYWdlLmlkXCIsXG4gIEhPU1RfSU1BR0VfVkVSU0lPTjogXCJob3N0LmltYWdlLnZlcnNpb25cIixcbiAgSzhTX0NMVVNURVJfTkFNRTogXCJrOHMuY2x1c3Rlci5uYW1lXCIsXG4gIEs4U19OT0RFX05BTUU6IFwiazhzLm5vZGUubmFtZVwiLFxuICBLOFNfTk9ERV9VSUQ6IFwiazhzLm5vZGUudWlkXCIsXG4gIEs4U19OQU1FU1BBQ0VfTkFNRTogXCJrOHMubmFtZXNwYWNlLm5hbWVcIixcbiAgSzhTX1BPRF9VSUQ6IFwiazhzLnBvZC51aWRcIixcbiAgSzhTX1BPRF9OQU1FOiBcIms4cy5wb2QubmFtZVwiLFxuICBLOFNfQ09OVEFJTkVSX05BTUU6IFwiazhzLmNvbnRhaW5lci5uYW1lXCIsXG4gIEs4U19SRVBMSUNBU0VUX1VJRDogXCJrOHMucmVwbGljYXNldC51aWRcIixcbiAgSzhTX1JFUExJQ0FTRVRfTkFNRTogXCJrOHMucmVwbGljYXNldC5uYW1lXCIsXG4gIEs4U19ERVBMT1lNRU5UX1VJRDogXCJrOHMuZGVwbG95bWVudC51aWRcIixcbiAgSzhTX0RFUExPWU1FTlRfTkFNRTogXCJrOHMuZGVwbG95bWVudC5uYW1lXCIsXG4gIEs4U19TVEFURUZVTFNFVF9VSUQ6IFwiazhzLnN0YXRlZnVsc2V0LnVpZFwiLFxuICBLOFNfU1RBVEVGVUxTRVRfTkFNRTogXCJrOHMuc3RhdGVmdWxzZXQubmFtZVwiLFxuICBLOFNfREFFTU9OU0VUX1VJRDogXCJrOHMuZGFlbW9uc2V0LnVpZFwiLFxuICBLOFNfREFFTU9OU0VUX05BTUU6IFwiazhzLmRhZW1vbnNldC5uYW1lXCIsXG4gIEs4U19KT0JfVUlEOiBcIms4cy5qb2IudWlkXCIsXG4gIEs4U19KT0JfTkFNRTogXCJrOHMuam9iLm5hbWVcIixcbiAgSzhTX0NST05KT0JfVUlEOiBcIms4cy5jcm9uam9iLnVpZFwiLFxuICBLOFNfQ1JPTkpPQl9OQU1FOiBcIms4cy5jcm9uam9iLm5hbWVcIixcbiAgT1NfVFlQRTogXCJvcy50eXBlXCIsXG4gIE9TX0RFU0NSSVBUSU9OOiBcIm9zLmRlc2NyaXB0aW9uXCIsXG4gIE9TX05BTUU6IFwib3MubmFtZVwiLFxuICBPU19WRVJTSU9OOiBcIm9zLnZlcnNpb25cIixcbiAgUFJPQ0VTU19QSUQ6IFwicHJvY2Vzcy5waWRcIixcbiAgUFJPQ0VTU19FWEVDVVRBQkxFX05BTUU6IFwicHJvY2Vzcy5leGVjdXRhYmxlLm5hbWVcIixcbiAgUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEg6IFwicHJvY2Vzcy5leGVjdXRhYmxlLnBhdGhcIixcbiAgUFJPQ0VTU19DT01NQU5EOiBcInByb2Nlc3MuY29tbWFuZFwiLFxuICBQUk9DRVNTX0NPTU1BTkRfTElORTogXCJwcm9jZXNzLmNvbW1hbmRfbGluZVwiLFxuICBQUk9DRVNTX0NPTU1BTkRfQVJHUzogXCJwcm9jZXNzLmNvbW1hbmRfYXJnc1wiLFxuICBQUk9DRVNTX09XTkVSOiBcInByb2Nlc3Mub3duZXJcIixcbiAgUFJPQ0VTU19SVU5USU1FX05BTUU6IFwicHJvY2Vzcy5ydW50aW1lLm5hbWVcIixcbiAgUFJPQ0VTU19SVU5USU1FX1ZFUlNJT046IFwicHJvY2Vzcy5ydW50aW1lLnZlcnNpb25cIixcbiAgUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OOiBcInByb2Nlc3MucnVudGltZS5kZXNjcmlwdGlvblwiLFxuICBTRVJWSUNFX05BTUU6IFwic2VydmljZS5uYW1lXCIsXG4gIFNFUlZJQ0VfTkFNRVNQQUNFOiBcInNlcnZpY2UubmFtZXNwYWNlXCIsXG4gIFNFUlZJQ0VfSU5TVEFOQ0VfSUQ6IFwic2VydmljZS5pbnN0YW5jZS5pZFwiLFxuICBTRVJWSUNFX1ZFUlNJT046IFwic2VydmljZS52ZXJzaW9uXCIsXG4gIFRFTEVNRVRSWV9TREtfTkFNRTogXCJ0ZWxlbWV0cnkuc2RrLm5hbWVcIixcbiAgVEVMRU1FVFJZX1NES19MQU5HVUFHRTogXCJ0ZWxlbWV0cnkuc2RrLmxhbmd1YWdlXCIsXG4gIFRFTEVNRVRSWV9TREtfVkVSU0lPTjogXCJ0ZWxlbWV0cnkuc2RrLnZlcnNpb25cIixcbiAgVEVMRU1FVFJZX0FVVE9fVkVSU0lPTjogXCJ0ZWxlbWV0cnkuYXV0by52ZXJzaW9uXCIsXG4gIFdFQkVOR0lORV9OQU1FOiBcIndlYmVuZ2luZS5uYW1lXCIsXG4gIFdFQkVOR0lORV9WRVJTSU9OOiBcIndlYmVuZ2luZS52ZXJzaW9uXCIsXG4gIFdFQkVOR0lORV9ERVNDUklQVElPTjogXCJ3ZWJlbmdpbmUuZGVzY3JpcHRpb25cIlxufTtcbnZhciBUZWxlbWV0cnlTZGtMYW5ndWFnZVZhbHVlcyA9IHtcbiAgQ1BQOiBcImNwcFwiLFxuICBET1RORVQ6IFwiZG90bmV0XCIsXG4gIEVSTEFORzogXCJlcmxhbmdcIixcbiAgR086IFwiZ29cIixcbiAgSkFWQTogXCJqYXZhXCIsXG4gIE5PREVKUzogXCJub2RlanNcIixcbiAgUEhQOiBcInBocFwiLFxuICBQWVRIT046IFwicHl0aG9uXCIsXG4gIFJVQlk6IFwicnVieVwiLFxuICBXRUJKUzogXCJ3ZWJqc1wiXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvc2RrLWluZm8uanNcbnZhciBfYTI7XG52YXIgU0RLX0lORk8gPSAoX2EyID0ge30sIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX05BTUVdID0gXCJvcGVudGVsZW1ldHJ5XCIsIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX1JVTlRJTUVfTkFNRV0gPSBcIm5vZGVcIiwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfTEFOR1VBR0VdID0gVGVsZW1ldHJ5U2RrTGFuZ3VhZ2VWYWx1ZXMuTk9ERUpTLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19WRVJTSU9OXSA9IFZFUlNJT04yLCBfYTIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvdGltZXItdXRpbC5qc1xuZnVuY3Rpb24gdW5yZWZUaW1lcih0aW1lcikge1xuICB0aW1lci51bnJlZigpO1xufVxuX19uYW1lKHVucmVmVGltZXIsIFwidW5yZWZUaW1lclwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vdGltZS5qc1xudmFyIE5BTk9TRUNPTkRfRElHSVRTID0gOTtcbnZhciBTRUNPTkRfVE9fTkFOT1NFQ09ORFMgPSBNYXRoLnBvdygxMCwgTkFOT1NFQ09ORF9ESUdJVFMpO1xuZnVuY3Rpb24gbnVtYmVyVG9IcnRpbWUoZXBvY2hNaWxsaXMpIHtcbiAgdmFyIGVwb2NoU2Vjb25kcyA9IGVwb2NoTWlsbGlzIC8gMWUzO1xuICB2YXIgc2Vjb25kcyA9IE1hdGgudHJ1bmMoZXBvY2hTZWNvbmRzKTtcbiAgdmFyIG5hbm9zID0gTnVtYmVyKChlcG9jaFNlY29uZHMgLSBzZWNvbmRzKS50b0ZpeGVkKE5BTk9TRUNPTkRfRElHSVRTKSkgKiBTRUNPTkRfVE9fTkFOT1NFQ09ORFM7XG4gIHJldHVybiBbc2Vjb25kcywgbmFub3NdO1xufVxuX19uYW1lKG51bWJlclRvSHJ0aW1lLCBcIm51bWJlclRvSHJ0aW1lXCIpO1xuZnVuY3Rpb24gZ2V0VGltZU9yaWdpbigpIHtcbiAgdmFyIHRpbWVPcmlnaW4gPSBvdHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XG4gIGlmICh0eXBlb2YgdGltZU9yaWdpbiAhPT0gXCJudW1iZXJcIikge1xuICAgIHZhciBwZXJmID0gb3RwZXJmb3JtYW5jZTtcbiAgICB0aW1lT3JpZ2luID0gcGVyZi50aW1pbmcgJiYgcGVyZi50aW1pbmcuZmV0Y2hTdGFydDtcbiAgfVxuICByZXR1cm4gdGltZU9yaWdpbjtcbn1cbl9fbmFtZShnZXRUaW1lT3JpZ2luLCBcImdldFRpbWVPcmlnaW5cIik7XG5mdW5jdGlvbiBoclRpbWUocGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIHRpbWVPcmlnaW4gPSBudW1iZXJUb0hydGltZShnZXRUaW1lT3JpZ2luKCkpO1xuICB2YXIgbm93ID0gbnVtYmVyVG9IcnRpbWUodHlwZW9mIHBlcmZvcm1hbmNlTm93ID09PSBcIm51bWJlclwiID8gcGVyZm9ybWFuY2VOb3cgOiBvdHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgdmFyIHNlY29uZHMgPSB0aW1lT3JpZ2luWzBdICsgbm93WzBdO1xuICB2YXIgbmFub3MgPSB0aW1lT3JpZ2luWzFdICsgbm93WzFdO1xuICBpZiAobmFub3MgPiBTRUNPTkRfVE9fTkFOT1NFQ09ORFMpIHtcbiAgICBuYW5vcyAtPSBTRUNPTkRfVE9fTkFOT1NFQ09ORFM7XG4gICAgc2Vjb25kcyArPSAxO1xuICB9XG4gIHJldHVybiBbc2Vjb25kcywgbmFub3NdO1xufVxuX19uYW1lKGhyVGltZSwgXCJoclRpbWVcIik7XG5mdW5jdGlvbiB0aW1lSW5wdXRUb0hyVGltZSh0aW1lKSB7XG4gIGlmIChpc1RpbWVJbnB1dEhyVGltZSh0aW1lKSkge1xuICAgIHJldHVybiB0aW1lO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHRpbWUgPCBnZXRUaW1lT3JpZ2luKCkpIHtcbiAgICAgIHJldHVybiBoclRpbWUodGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW1iZXJUb0hydGltZSh0aW1lKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbnVtYmVyVG9IcnRpbWUodGltZS5nZXRUaW1lKCkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKTtcbiAgfVxufVxuX19uYW1lKHRpbWVJbnB1dFRvSHJUaW1lLCBcInRpbWVJbnB1dFRvSHJUaW1lXCIpO1xuZnVuY3Rpb24gaHJUaW1lRHVyYXRpb24oc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gIHZhciBzZWNvbmRzID0gZW5kVGltZVswXSAtIHN0YXJ0VGltZVswXTtcbiAgdmFyIG5hbm9zID0gZW5kVGltZVsxXSAtIHN0YXJ0VGltZVsxXTtcbiAgaWYgKG5hbm9zIDwgMCkge1xuICAgIHNlY29uZHMgLT0gMTtcbiAgICBuYW5vcyArPSBTRUNPTkRfVE9fTkFOT1NFQ09ORFM7XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc107XG59XG5fX25hbWUoaHJUaW1lRHVyYXRpb24sIFwiaHJUaW1lRHVyYXRpb25cIik7XG5mdW5jdGlvbiBoclRpbWVUb01pY3Jvc2Vjb25kcyh0aW1lKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHRpbWVbMF0gKiAxZTYgKyB0aW1lWzFdIC8gMWUzKTtcbn1cbl9fbmFtZShoclRpbWVUb01pY3Jvc2Vjb25kcywgXCJoclRpbWVUb01pY3Jvc2Vjb25kc1wiKTtcbmZ1bmN0aW9uIGlzVGltZUlucHV0SHJUaW1lKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZVsxXSA9PT0gXCJudW1iZXJcIjtcbn1cbl9fbmFtZShpc1RpbWVJbnB1dEhyVGltZSwgXCJpc1RpbWVJbnB1dEhyVGltZVwiKTtcbmZ1bmN0aW9uIGlzVGltZUlucHV0KHZhbHVlKSB7XG4gIHJldHVybiBpc1RpbWVJbnB1dEhyVGltZSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cbl9fbmFtZShpc1RpbWVJbnB1dCwgXCJpc1RpbWVJbnB1dFwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9FeHBvcnRSZXN1bHQuanNcbnZhciBFeHBvcnRSZXN1bHRDb2RlO1xuKGZ1bmN0aW9uKEV4cG9ydFJlc3VsdENvZGUyKSB7XG4gIEV4cG9ydFJlc3VsdENvZGUyW0V4cG9ydFJlc3VsdENvZGUyW1wiU1VDQ0VTU1wiXSA9IDBdID0gXCJTVUNDRVNTXCI7XG4gIEV4cG9ydFJlc3VsdENvZGUyW0V4cG9ydFJlc3VsdENvZGUyW1wiRkFJTEVEXCJdID0gMV0gPSBcIkZBSUxFRFwiO1xufSkoRXhwb3J0UmVzdWx0Q29kZSB8fCAoRXhwb3J0UmVzdWx0Q29kZSA9IHt9KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcHJvcGFnYXRpb24vY29tcG9zaXRlLmpzXG52YXIgX192YWx1ZXMyID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIENvbXBvc2l0ZVByb3BhZ2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQ29tcG9zaXRlUHJvcGFnYXRvcjIoY29uZmlnMikge1xuICAgIGlmIChjb25maWcyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbmZpZzIgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9hMztcbiAgICB0aGlzLl9wcm9wYWdhdG9ycyA9IChfYTMgPSBjb25maWcyLnByb3BhZ2F0b3JzKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IFtdO1xuICAgIHRoaXMuX2ZpZWxkcyA9IEFycmF5LmZyb20obmV3IFNldCh0aGlzLl9wcm9wYWdhdG9ycy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBwLmZpZWxkcyA9PT0gXCJmdW5jdGlvblwiID8gcC5maWVsZHMoKSA6IFtdO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4geC5jb25jYXQoeSk7XG4gICAgfSwgW10pKSk7XG4gIH1cbiAgX19uYW1lKENvbXBvc2l0ZVByb3BhZ2F0b3IyLCBcIkNvbXBvc2l0ZVByb3BhZ2F0b3JcIik7XG4gIENvbXBvc2l0ZVByb3BhZ2F0b3IyLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbihjb250ZXh0MywgY2Fycmllciwgc2V0dGVyKSB7XG4gICAgdmFyIGVfMSwgX2EzO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfYjIgPSBfX3ZhbHVlczIodGhpcy5fcHJvcGFnYXRvcnMpLCBfYyA9IF9iMi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iMi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHByb3BhZ2F0b3IgPSBfYy52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9wYWdhdG9yLmluamVjdChjb250ZXh0MywgY2Fycmllciwgc2V0dGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIkZhaWxlZCB0byBpbmplY3Qgd2l0aCBcIiArIHByb3BhZ2F0b3IuY29uc3RydWN0b3IubmFtZSArIFwiLiBFcnI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoX2IyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQ29tcG9zaXRlUHJvcGFnYXRvcjIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MywgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BhZ2F0b3JzLnJlZHVjZShmdW5jdGlvbihjdHgsIHByb3BhZ2F0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdG9yLmV4dHJhY3QoY3R4LCBjYXJyaWVyLCBnZXR0ZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRpYWcyLndhcm4oXCJGYWlsZWQgdG8gaW5qZWN0IHdpdGggXCIgKyBwcm9wYWdhdG9yLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi4gRXJyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHg7XG4gICAgfSwgY29udGV4dDMpO1xuICB9O1xuICBDb21wb3NpdGVQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcy5zbGljZSgpO1xuICB9O1xuICByZXR1cm4gQ29tcG9zaXRlUHJvcGFnYXRvcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vaW50ZXJuYWwvdmFsaWRhdG9ycy5qc1xudmFyIFZBTElEX0tFWV9DSEFSX1JBTkdFMiA9IFwiW18wLTlhLXotKi9dXCI7XG52YXIgVkFMSURfS0VZMiA9IFwiW2Etel1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFMiArIFwiezAsMjU1fVwiO1xudmFyIFZBTElEX1ZFTkRPUl9LRVkyID0gXCJbYS16MC05XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UyICsgXCJ7MCwyNDB9QFthLXpdXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRTIgKyBcInswLDEzfVwiO1xudmFyIFZBTElEX0tFWV9SRUdFWDIgPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgVkFMSURfS0VZMiArIFwifFwiICsgVkFMSURfVkVORE9SX0tFWTIgKyBcIikkXCIpO1xudmFyIFZBTElEX1ZBTFVFX0JBU0VfUkVHRVgyID0gL15bIC1+XXswLDI1NX1bIS1+XSQvO1xudmFyIElOVkFMSURfVkFMVUVfQ09NTUFfRVFVQUxfUkVHRVgyID0gLyx8PS87XG5mdW5jdGlvbiB2YWxpZGF0ZUtleTIoa2V5KSB7XG4gIHJldHVybiBWQUxJRF9LRVlfUkVHRVgyLnRlc3Qoa2V5KTtcbn1cbl9fbmFtZSh2YWxpZGF0ZUtleTIsIFwidmFsaWRhdGVLZXlcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlMih2YWx1ZSkge1xuICByZXR1cm4gVkFMSURfVkFMVUVfQkFTRV9SRUdFWDIudGVzdCh2YWx1ZSkgJiYgIUlOVkFMSURfVkFMVUVfQ09NTUFfRVFVQUxfUkVHRVgyLnRlc3QodmFsdWUpO1xufVxuX19uYW1lKHZhbGlkYXRlVmFsdWUyLCBcInZhbGlkYXRlVmFsdWVcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2UvVHJhY2VTdGF0ZS5qc1xudmFyIE1BWF9UUkFDRV9TVEFURV9JVEVNUzIgPSAzMjtcbnZhciBNQVhfVFJBQ0VfU1RBVEVfTEVOMiA9IDUxMjtcbnZhciBMSVNUX01FTUJFUlNfU0VQQVJBVE9SMiA9IFwiLFwiO1xudmFyIExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUjIgPSBcIj1cIjtcbnZhciBUcmFjZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyYWNlU3RhdGUyKHJhd1RyYWNlU3RhdGUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAocmF3VHJhY2VTdGF0ZSlcbiAgICAgIHRoaXMuX3BhcnNlKHJhd1RyYWNlU3RhdGUpO1xuICB9XG4gIF9fbmFtZShUcmFjZVN0YXRlMiwgXCJUcmFjZVN0YXRlXCIpO1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICBpZiAodHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5oYXMoa2V5KSkge1xuICAgICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gIH07XG4gIFRyYWNlU3RhdGUyLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiB0cmFjZVN0YXRlO1xuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGUuZ2V0KGtleSk7XG4gIH07XG4gIFRyYWNlU3RhdGUyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9rZXlzKCkucmVkdWNlKGZ1bmN0aW9uKGFnZywga2V5KSB7XG4gICAgICBhZ2cucHVzaChrZXkgKyBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIyICsgX3RoaXMuZ2V0KGtleSkpO1xuICAgICAgcmV0dXJuIGFnZztcbiAgICB9LCBbXSkuam9pbihMSVNUX01FTUJFUlNfU0VQQVJBVE9SMik7XG4gIH07XG4gIFRyYWNlU3RhdGUyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbihyYXdUcmFjZVN0YXRlKSB7XG4gICAgaWYgKHJhd1RyYWNlU3RhdGUubGVuZ3RoID4gTUFYX1RSQUNFX1NUQVRFX0xFTjIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IHJhd1RyYWNlU3RhdGUuc3BsaXQoTElTVF9NRU1CRVJTX1NFUEFSQVRPUjIpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24oYWdnLCBwYXJ0KSB7XG4gICAgICB2YXIgbGlzdE1lbWJlciA9IHBhcnQudHJpbSgpO1xuICAgICAgdmFyIGkgPSBsaXN0TWVtYmVyLmluZGV4T2YoTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSMik7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIGtleSA9IGxpc3RNZW1iZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxpc3RNZW1iZXIuc2xpY2UoaSArIDEsIHBhcnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKHZhbGlkYXRlS2V5MihrZXkpICYmIHZhbGlkYXRlVmFsdWUyKHZhbHVlKSkge1xuICAgICAgICAgIGFnZy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhZ2c7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsU3RhdGUuc2l6ZSA+IE1BWF9UUkFDRV9TVEFURV9JVEVNUzIpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsU3RhdGUgPSBuZXcgTWFwKEFycmF5LmZyb20odGhpcy5faW50ZXJuYWxTdGF0ZS5lbnRyaWVzKCkpLnJldmVyc2UoKS5zbGljZSgwLCBNQVhfVFJBQ0VfU1RBVEVfSVRFTVMyKSk7XG4gICAgfVxuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuX2tleXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmtleXMoKSkucmV2ZXJzZSgpO1xuICB9O1xuICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYWNlU3RhdGUgPSBuZXcgVHJhY2VTdGF0ZTIoKTtcbiAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcCh0aGlzLl9pbnRlcm5hbFN0YXRlKTtcbiAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgfTtcbiAgcmV0dXJuIFRyYWNlU3RhdGUyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL1czQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IuanNcbnZhciBUUkFDRV9QQVJFTlRfSEVBREVSID0gXCJ0cmFjZXBhcmVudFwiO1xudmFyIFRSQUNFX1NUQVRFX0hFQURFUiA9IFwidHJhY2VzdGF0ZVwiO1xudmFyIFZFUlNJT04zID0gXCIwMFwiO1xudmFyIFZFUlNJT05fUEFSVCA9IFwiKD8hZmYpW1xcXFxkYS1mXXsyfVwiO1xudmFyIFRSQUNFX0lEX1BBUlQgPSBcIig/IVswXXszMn0pW1xcXFxkYS1mXXszMn1cIjtcbnZhciBQQVJFTlRfSURfUEFSVCA9IFwiKD8hWzBdezE2fSlbXFxcXGRhLWZdezE2fVwiO1xudmFyIEZMQUdTX1BBUlQgPSBcIltcXFxcZGEtZl17Mn1cIjtcbnZhciBUUkFDRV9QQVJFTlRfUkVHRVggPSBuZXcgUmVnRXhwKFwiXlxcXFxzPyhcIiArIFZFUlNJT05fUEFSVCArIFwiKS0oXCIgKyBUUkFDRV9JRF9QQVJUICsgXCIpLShcIiArIFBBUkVOVF9JRF9QQVJUICsgXCIpLShcIiArIEZMQUdTX1BBUlQgKyBcIikoLS4qKT9cXFxccz8kXCIpO1xuZnVuY3Rpb24gcGFyc2VUcmFjZVBhcmVudCh0cmFjZVBhcmVudCkge1xuICB2YXIgbWF0Y2ggPSBUUkFDRV9QQVJFTlRfUkVHRVguZXhlYyh0cmFjZVBhcmVudCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChtYXRjaFsxXSA9PT0gXCIwMFwiICYmIG1hdGNoWzVdKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHRyYWNlSWQ6IG1hdGNoWzJdLFxuICAgIHNwYW5JZDogbWF0Y2hbM10sXG4gICAgdHJhY2VGbGFnczogcGFyc2VJbnQobWF0Y2hbNF0sIDE2KVxuICB9O1xufVxuX19uYW1lKHBhcnNlVHJhY2VQYXJlbnQsIFwicGFyc2VUcmFjZVBhcmVudFwiKTtcbnZhciBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyKCkge1xuICB9XG4gIF9fbmFtZShXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMiwgXCJXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yXCIpO1xuICBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDMsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIHZhciBzcGFuQ29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQzKTtcbiAgICBpZiAoIXNwYW5Db250ZXh0IHx8IGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDMpIHx8ICFpc1NwYW5Db250ZXh0VmFsaWQoc3BhbkNvbnRleHQpKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciB0cmFjZVBhcmVudCA9IFZFUlNJT04zICsgXCItXCIgKyBzcGFuQ29udGV4dC50cmFjZUlkICsgXCItXCIgKyBzcGFuQ29udGV4dC5zcGFuSWQgKyBcIi0wXCIgKyBOdW1iZXIoc3BhbkNvbnRleHQudHJhY2VGbGFncyB8fCBUcmFjZUZsYWdzLk5PTkUpLnRvU3RyaW5nKDE2KTtcbiAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIFRSQUNFX1BBUkVOVF9IRUFERVIsIHRyYWNlUGFyZW50KTtcbiAgICBpZiAoc3BhbkNvbnRleHQudHJhY2VTdGF0ZSkge1xuICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBUUkFDRV9TVEFURV9IRUFERVIsIHNwYW5Db250ZXh0LnRyYWNlU3RhdGUuc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgfTtcbiAgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcjIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MywgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgdmFyIHRyYWNlUGFyZW50SGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBUUkFDRV9QQVJFTlRfSEVBREVSKTtcbiAgICBpZiAoIXRyYWNlUGFyZW50SGVhZGVyKVxuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIHZhciB0cmFjZVBhcmVudCA9IEFycmF5LmlzQXJyYXkodHJhY2VQYXJlbnRIZWFkZXIpID8gdHJhY2VQYXJlbnRIZWFkZXJbMF0gOiB0cmFjZVBhcmVudEhlYWRlcjtcbiAgICBpZiAodHlwZW9mIHRyYWNlUGFyZW50ICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGNvbnRleHQzO1xuICAgIHZhciBzcGFuQ29udGV4dCA9IHBhcnNlVHJhY2VQYXJlbnQodHJhY2VQYXJlbnQpO1xuICAgIGlmICghc3BhbkNvbnRleHQpXG4gICAgICByZXR1cm4gY29udGV4dDM7XG4gICAgc3BhbkNvbnRleHQuaXNSZW1vdGUgPSB0cnVlO1xuICAgIHZhciB0cmFjZVN0YXRlSGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBUUkFDRV9TVEFURV9IRUFERVIpO1xuICAgIGlmICh0cmFjZVN0YXRlSGVhZGVyKSB7XG4gICAgICB2YXIgc3RhdGUgPSBBcnJheS5pc0FycmF5KHRyYWNlU3RhdGVIZWFkZXIpID8gdHJhY2VTdGF0ZUhlYWRlci5qb2luKFwiLFwiKSA6IHRyYWNlU3RhdGVIZWFkZXI7XG4gICAgICBzcGFuQ29udGV4dC50cmFjZVN0YXRlID0gbmV3IFRyYWNlU3RhdGUodHlwZW9mIHN0YXRlID09PSBcInN0cmluZ1wiID8gc3RhdGUgOiB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2Uuc2V0U3BhbkNvbnRleHQoY29udGV4dDMsIHNwYW5Db250ZXh0KTtcbiAgfTtcbiAgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcjIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbVFJBQ0VfUEFSRU5UX0hFQURFUiwgVFJBQ0VfU1RBVEVfSEVBREVSXTtcbiAgfTtcbiAgcmV0dXJuIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3JwYy1tZXRhZGF0YS5qc1xudmFyIFJQQ19NRVRBREFUQV9LRVkgPSBjcmVhdGVDb250ZXh0S2V5KFwiT3BlblRlbGVtZXRyeSBTREsgQ29udGV4dCBLZXkgUlBDX01FVEFEQVRBXCIpO1xudmFyIFJQQ1R5cGU7XG4oZnVuY3Rpb24oUlBDVHlwZTIpIHtcbiAgUlBDVHlwZTJbXCJIVFRQXCJdID0gXCJodHRwXCI7XG59KShSUENUeXBlIHx8IChSUENUeXBlID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zYW1wbGVyL0Fsd2F5c09mZlNhbXBsZXIuanNcbnZhciBBbHdheXNPZmZTYW1wbGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFsd2F5c09mZlNhbXBsZXIzKCkge1xuICB9XG4gIF9fbmFtZShBbHdheXNPZmZTYW1wbGVyMywgXCJBbHdheXNPZmZTYW1wbGVyXCIpO1xuICBBbHdheXNPZmZTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY2lzaW9uOiBTYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkRcbiAgICB9O1xuICB9O1xuICBBbHdheXNPZmZTYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJBbHdheXNPZmZTYW1wbGVyXCI7XG4gIH07XG4gIHJldHVybiBBbHdheXNPZmZTYW1wbGVyMztcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zYW1wbGVyL0Fsd2F5c09uU2FtcGxlci5qc1xudmFyIEFsd2F5c09uU2FtcGxlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBbHdheXNPblNhbXBsZXIzKCkge1xuICB9XG4gIF9fbmFtZShBbHdheXNPblNhbXBsZXIzLCBcIkFsd2F5c09uU2FtcGxlclwiKTtcbiAgQWx3YXlzT25TYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY2lzaW9uOiBTYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRFxuICAgIH07XG4gIH07XG4gIEFsd2F5c09uU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiQWx3YXlzT25TYW1wbGVyXCI7XG4gIH07XG4gIHJldHVybiBBbHdheXNPblNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrY29yZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3NhbXBsZXIvUGFyZW50QmFzZWRTYW1wbGVyLmpzXG52YXIgUGFyZW50QmFzZWRTYW1wbGVyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFBhcmVudEJhc2VkU2FtcGxlcjMoY29uZmlnMikge1xuICAgIHZhciBfYTMsIF9iMiwgX2MsIF9kO1xuICAgIHRoaXMuX3Jvb3QgPSBjb25maWcyLnJvb3Q7XG4gICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICBnbG9iYWxFcnJvckhhbmRsZXIobmV3IEVycm9yKFwiUGFyZW50QmFzZWRTYW1wbGVyIG11c3QgaGF2ZSBhIHJvb3Qgc2FtcGxlciBjb25maWd1cmVkXCIpKTtcbiAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQWx3YXlzT25TYW1wbGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQgPSAoX2EzID0gY29uZmlnMi5yZW1vdGVQYXJlbnRTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IG5ldyBBbHdheXNPblNhbXBsZXIoKTtcbiAgICB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkID0gKF9iMiA9IGNvbmZpZzIucmVtb3RlUGFyZW50Tm90U2FtcGxlZCkgIT09IG51bGwgJiYgX2IyICE9PSB2b2lkIDAgPyBfYjIgOiBuZXcgQWx3YXlzT2ZmU2FtcGxlcigpO1xuICAgIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZCA9IChfYyA9IGNvbmZpZzIubG9jYWxQYXJlbnRTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgQWx3YXlzT25TYW1wbGVyKCk7XG4gICAgdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkID0gKF9kID0gY29uZmlnMi5sb2NhbFBhcmVudE5vdFNhbXBsZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBBbHdheXNPZmZTYW1wbGVyKCk7XG4gIH1cbiAgX19uYW1lKFBhcmVudEJhc2VkU2FtcGxlcjMsIFwiUGFyZW50QmFzZWRTYW1wbGVyXCIpO1xuICBQYXJlbnRCYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbihjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcykge1xuICAgIHZhciBwYXJlbnRDb250ZXh0ID0gdHJhY2UuZ2V0U3BhbkNvbnRleHQoY29udGV4dDMpO1xuICAgIGlmICghcGFyZW50Q29udGV4dCB8fCAhaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudENvbnRleHQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgIH1cbiAgICBpZiAocGFyZW50Q29udGV4dC5pc1JlbW90ZSkge1xuICAgICAgaWYgKHBhcmVudENvbnRleHQudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3RlUGFyZW50U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudENvbnRleHQudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gIH07XG4gIFBhcmVudEJhc2VkU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiUGFyZW50QmFzZWR7cm9vdD1cIiArIHRoaXMuX3Jvb3QudG9TdHJpbmcoKSArIFwiLCByZW1vdGVQYXJlbnRTYW1wbGVkPVwiICsgdGhpcy5fcmVtb3RlUGFyZW50U2FtcGxlZC50b1N0cmluZygpICsgXCIsIHJlbW90ZVBhcmVudE5vdFNhbXBsZWQ9XCIgKyB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgbG9jYWxQYXJlbnRTYW1wbGVkPVwiICsgdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgbG9jYWxQYXJlbnROb3RTYW1wbGVkPVwiICsgdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgfTtcbiAgcmV0dXJuIFBhcmVudEJhc2VkU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9UcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIuanNcbnZhciBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMyhfcmF0aW8pIHtcbiAgICBpZiAoX3JhdGlvID09PSB2b2lkIDApIHtcbiAgICAgIF9yYXRpbyA9IDA7XG4gICAgfVxuICAgIHRoaXMuX3JhdGlvID0gX3JhdGlvO1xuICAgIHRoaXMuX3JhdGlvID0gdGhpcy5fbm9ybWFsaXplKF9yYXRpbyk7XG4gICAgdGhpcy5fdXBwZXJCb3VuZCA9IE1hdGguZmxvb3IodGhpcy5fcmF0aW8gKiA0Mjk0OTY3Mjk1KTtcbiAgfVxuICBfX25hbWUoVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMywgXCJUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXJcIik7XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKGNvbnRleHQzLCB0cmFjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY2lzaW9uOiBpc1ZhbGlkVHJhY2VJZCh0cmFjZUlkKSAmJiB0aGlzLl9hY2N1bXVsYXRlKHRyYWNlSWQpIDwgdGhpcy5fdXBwZXJCb3VuZCA/IFNhbXBsaW5nRGVjaXNpb24uUkVDT1JEX0FORF9TQU1QTEVEIDogU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEXG4gICAgfTtcbiAgfTtcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJUcmFjZUlkUmF0aW9CYXNlZHtcIiArIHRoaXMuX3JhdGlvICsgXCJ9XCI7XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbihyYXRpbykge1xuICAgIGlmICh0eXBlb2YgcmF0aW8gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4ocmF0aW8pKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHJhdGlvID49IDEgPyAxIDogcmF0aW8gPD0gMCA/IDAgOiByYXRpbztcbiAgfTtcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuX2FjY3VtdWxhdGUgPSBmdW5jdGlvbih0cmFjZUlkKSB7XG4gICAgdmFyIGFjY3VtdWxhdGlvbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUlkLmxlbmd0aCAvIDg7IGkrKykge1xuICAgICAgdmFyIHBvcyA9IGkgKiA4O1xuICAgICAgdmFyIHBhcnQgPSBwYXJzZUludCh0cmFjZUlkLnNsaWNlKHBvcywgcG9zICsgOCksIDE2KTtcbiAgICAgIGFjY3VtdWxhdGlvbiA9IChhY2N1bXVsYXRpb24gXiBwYXJ0KSA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdGlvbjtcbiAgfTtcbiAgcmV0dXJuIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvbG9kYXNoLm1lcmdlLmpzXG52YXIgb2JqZWN0VGFnID0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbnZhciBudWxsVGFnID0gXCJbb2JqZWN0IE51bGxdXCI7XG52YXIgdW5kZWZpbmVkVGFnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIjtcbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnMikge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcyKSk7XG4gIH07XG59XG5fX25hbWUob3ZlckFyZywgXCJvdmVyQXJnXCIpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT09IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5fX25hbWUoaXNQbGFpbk9iamVjdCwgXCJpc1BsYWluT2JqZWN0XCIpO1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiO1xufVxuX19uYW1lKGlzT2JqZWN0TGlrZSwgXCJpc09iamVjdExpa2VcIik7XG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiBzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpID8gZ2V0UmF3VGFnKHZhbHVlKSA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cbl9fbmFtZShiYXNlR2V0VGFnLCBcImJhc2VHZXRUYWdcIik7XG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcyID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICB2YXIgdW5tYXNrZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB2b2lkIDA7XG4gICAgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUoZ2V0UmF3VGFnLCBcImdldFJhd1RhZ1wiKTtcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cbl9fbmFtZShvYmplY3RUb1N0cmluZywgXCJvYmplY3RUb1N0cmluZ1wiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2NvcmVAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9tZXJnZS5qc1xudmFyIE1BWF9MRVZFTCA9IDIwO1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG4gIHZhciByZXN1bHQgPSBhcmdzLnNoaWZ0KCk7XG4gIHZhciBvYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHdoaWxlIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgPSBtZXJnZVR3b09iamVjdHMocmVzdWx0LCBhcmdzLnNoaWZ0KCksIDAsIG9iamVjdHMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUobWVyZ2UsIFwibWVyZ2VcIik7XG5mdW5jdGlvbiB0YWtlVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuX19uYW1lKHRha2VWYWx1ZSwgXCJ0YWtlVmFsdWVcIik7XG5mdW5jdGlvbiBtZXJnZVR3b09iamVjdHMob25lLCB0d28sIGxldmVsLCBvYmplY3RzKSB7XG4gIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7XG4gICAgbGV2ZWwgPSAwO1xuICB9XG4gIHZhciByZXN1bHQ7XG4gIGlmIChsZXZlbCA+IE1BWF9MRVZFTCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV2ZWwrKztcbiAgaWYgKGlzUHJpbWl0aXZlKG9uZSkgfHwgaXNQcmltaXRpdmUodHdvKSB8fCBpc0Z1bmN0aW9uKHR3bykpIHtcbiAgICByZXN1bHQgPSB0YWtlVmFsdWUodHdvKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KG9uZSkpIHtcbiAgICByZXN1bHQgPSBvbmUuc2xpY2UoKTtcbiAgICBpZiAoaXNBcnJheSh0d28pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHR3by5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGFrZVZhbHVlKHR3b1tpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodHdvKSkge1xuICAgICAgdmFyIGtleXMyID0gT2JqZWN0LmtleXModHdvKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0ga2V5czIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0YWtlVmFsdWUodHdvW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChvbmUpKSB7XG4gICAgaWYgKGlzT2JqZWN0KHR3bykpIHtcbiAgICAgIGlmICghc2hvdWxkTWVyZ2Uob25lLCB0d28pKSB7XG4gICAgICAgIHJldHVybiB0d287XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvbmUpO1xuICAgICAgdmFyIGtleXMyID0gT2JqZWN0LmtleXModHdvKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0ga2V5czIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgdmFyIHR3b1ZhbHVlID0gdHdvW2tleV07XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh0d29WYWx1ZSkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR3b1ZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdHdvVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvYmoxID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgdmFyIG9iajIgPSB0d29WYWx1ZTtcbiAgICAgICAgICBpZiAod2FzT2JqZWN0UmVmZXJlbmNlZChvbmUsIGtleSwgb2JqZWN0cykgfHwgd2FzT2JqZWN0UmVmZXJlbmNlZCh0d28sIGtleSwgb2JqZWN0cykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9iajEpICYmIGlzT2JqZWN0KG9iajIpKSB7XG4gICAgICAgICAgICAgIHZhciBhcnIxID0gb2JqZWN0cy5nZXQob2JqMSkgfHwgW107XG4gICAgICAgICAgICAgIHZhciBhcnIyID0gb2JqZWN0cy5nZXQob2JqMikgfHwgW107XG4gICAgICAgICAgICAgIGFycjEucHVzaCh7IG9iajogb25lLCBrZXkgfSk7XG4gICAgICAgICAgICAgIGFycjIucHVzaCh7IG9iajogdHdvLCBrZXkgfSk7XG4gICAgICAgICAgICAgIG9iamVjdHMuc2V0KG9iajEsIGFycjEpO1xuICAgICAgICAgICAgICBvYmplY3RzLnNldChvYmoyLCBhcnIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VUd29PYmplY3RzKHJlc3VsdFtrZXldLCB0d29WYWx1ZSwgbGV2ZWwsIG9iamVjdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0d287XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUobWVyZ2VUd29PYmplY3RzLCBcIm1lcmdlVHdvT2JqZWN0c1wiKTtcbmZ1bmN0aW9uIHdhc09iamVjdFJlZmVyZW5jZWQob2JqLCBrZXksIG9iamVjdHMpIHtcbiAgdmFyIGFyciA9IG9iamVjdHMuZ2V0KG9ialtrZXldKSB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIGluZm8yID0gYXJyW2ldO1xuICAgIGlmIChpbmZvMi5rZXkgPT09IGtleSAmJiBpbmZvMi5vYmogPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbl9fbmFtZSh3YXNPYmplY3RSZWZlcmVuY2VkLCBcIndhc09iamVjdFJlZmVyZW5jZWRcIik7XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbl9fbmFtZShpc0FycmF5LCBcImlzQXJyYXlcIik7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbl9fbmFtZShpc0Z1bmN0aW9uLCBcImlzRnVuY3Rpb25cIik7XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gIWlzUHJpbWl0aXZlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbl9fbmFtZShpc09iamVjdCwgXCJpc09iamVjdFwiKTtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB2YWx1ZSA9PT0gbnVsbDtcbn1cbl9fbmFtZShpc1ByaW1pdGl2ZSwgXCJpc1ByaW1pdGl2ZVwiKTtcbmZ1bmN0aW9uIHNob3VsZE1lcmdlKG9uZSwgdHdvKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvbmUpIHx8ICFpc1BsYWluT2JqZWN0KHR3bykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5fX25hbWUoc2hvdWxkTWVyZ2UsIFwic2hvdWxkTWVyZ2VcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvcHJvbWlzZS5qc1xudmFyIERlZmVycmVkID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIERlZmVycmVkMigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbiAgX19uYW1lKERlZmVycmVkMiwgXCJEZWZlcnJlZFwiKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmVycmVkMi5wcm90b3R5cGUsIFwicHJvbWlzZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBEZWZlcnJlZDIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9yZXNvbHZlKHZhbCk7XG4gIH07XG4gIERlZmVycmVkMi5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgdGhpcy5fcmVqZWN0KGVycik7XG4gIH07XG4gIHJldHVybiBEZWZlcnJlZDI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvY2FsbGJhY2suanNcbnZhciBfX3JlYWQzID0gZnVuY3Rpb24obywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSlcbiAgICByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBlID0geyBlcnJvcjogZXJyb3IyIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSlcbiAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5MyA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgQmluZE9uY2VGdXR1cmUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmluZE9uY2VGdXR1cmUyKF9jYWxsYmFjaywgX3RoYXQpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IF9jYWxsYmFjaztcbiAgICB0aGlzLl90aGF0ID0gX3RoYXQ7XG4gICAgdGhpcy5faXNDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICB9XG4gIF9fbmFtZShCaW5kT25jZUZ1dHVyZTIsIFwiQmluZE9uY2VGdXR1cmVcIik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCaW5kT25jZUZ1dHVyZTIucHJvdG90eXBlLCBcImlzQ2FsbGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FsbGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZE9uY2VGdXR1cmUyLnByb3RvdHlwZSwgXCJwcm9taXNlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmVycmVkLnByb21pc2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIEJpbmRPbmNlRnV0dXJlMi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYTM7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNDYWxsZWQpIHtcbiAgICAgIHRoaXMuX2lzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgoX2EzID0gdGhpcy5fY2FsbGJhY2spLmNhbGwuYXBwbHkoX2EzLCBfX3NwcmVhZEFycmF5MyhbdGhpcy5fdGhhdF0sIF9fcmVhZDMoYXJncyksIGZhbHNlKSkpLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9kZWZlcnJlZC5yZXNvbHZlKHZhbCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcbiAgcmV0dXJuIEJpbmRPbmNlRnV0dXJlMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2VudW1zLmpzXG52YXIgRXhjZXB0aW9uRXZlbnROYW1lID0gXCJleGNlcHRpb25cIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL1NwYW4uanNcbnZhciBfX3ZhbHVlczMgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkNCA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG52YXIgU3BhbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTcGFuMyhwYXJlbnRUcmFjZXIsIGNvbnRleHQzLCBzcGFuTmFtZSwgc3BhbkNvbnRleHQsIGtpbmQsIHBhcmVudFNwYW5JZCwgbGlua3MsIHN0YXJ0VGltZSkge1xuICAgIGlmIChsaW5rcyA9PT0gdm9pZCAwKSB7XG4gICAgICBsaW5rcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoc3RhcnRUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGhyVGltZSgpO1xuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmxpbmtzID0gW107XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IHtcbiAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLlVOU0VUXG4gICAgfTtcbiAgICB0aGlzLmVuZFRpbWUgPSBbMCwgMF07XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IFstMSwgLTFdO1xuICAgIHRoaXMubmFtZSA9IHNwYW5OYW1lO1xuICAgIHRoaXMuX3NwYW5Db250ZXh0ID0gc3BhbkNvbnRleHQ7XG4gICAgdGhpcy5wYXJlbnRTcGFuSWQgPSBwYXJlbnRTcGFuSWQ7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgdGhpcy5zdGFydFRpbWUgPSB0aW1lSW5wdXRUb0hyVGltZShzdGFydFRpbWUpO1xuICAgIHRoaXMucmVzb3VyY2UgPSBwYXJlbnRUcmFjZXIucmVzb3VyY2U7XG4gICAgdGhpcy5pbnN0cnVtZW50YXRpb25MaWJyYXJ5ID0gcGFyZW50VHJhY2VyLmluc3RydW1lbnRhdGlvbkxpYnJhcnk7XG4gICAgdGhpcy5fc3BhbkxpbWl0cyA9IHBhcmVudFRyYWNlci5nZXRTcGFuTGltaXRzKCk7XG4gICAgdGhpcy5fc3BhblByb2Nlc3NvciA9IHBhcmVudFRyYWNlci5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yKCk7XG4gICAgdGhpcy5fc3BhblByb2Nlc3Nvci5vblN0YXJ0KHRoaXMsIGNvbnRleHQzKTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0ID0gdGhpcy5fc3BhbkxpbWl0cy5hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0IHx8IDA7XG4gIH1cbiAgX19uYW1lKFNwYW4zLCBcIlNwYW5cIik7XG4gIFNwYW4zLnByb3RvdHlwZS5zcGFuQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGFuQ29udGV4dDtcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0aGlzLl9pc1NwYW5FbmRlZCgpKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRpYWcyLndhcm4oXCJJbnZhbGlkIGF0dHJpYnV0ZSBrZXk6IFwiICsga2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIWlzQXR0cmlidXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICBkaWFnMi53YXJuKFwiSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWUgc2V0IGZvciBrZXk6IFwiICsga2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5sZW5ndGggPj0gdGhpcy5fc3BhbkxpbWl0cy5hdHRyaWJ1dGVDb3VudExpbWl0ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSB0aGlzLl90cnVuY2F0ZVRvU2l6ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFNwYW4zLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgIHZhciBlXzEsIF9hMztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXMzKE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZDQoX2MudmFsdWUsIDIpLCBrID0gX2RbMF0sIHYgPSBfZFsxXTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaywgdik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoX2IyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlc09yU3RhcnRUaW1lLCBzdGFydFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNTcGFuRW5kZWQoKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLl9zcGFuTGltaXRzLmV2ZW50Q291bnRMaW1pdCA9PT0gMCkge1xuICAgICAgZGlhZzIud2FybihcIk5vIGV2ZW50cyBhbGxvd2VkLlwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID49IHRoaXMuX3NwYW5MaW1pdHMuZXZlbnRDb3VudExpbWl0KSB7XG4gICAgICBkaWFnMi53YXJuKFwiRHJvcHBpbmcgZXh0cmEgZXZlbnRzLlwiKTtcbiAgICAgIHRoaXMuZXZlbnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChpc1RpbWVJbnB1dChhdHRyaWJ1dGVzT3JTdGFydFRpbWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0VGltZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzdGFydFRpbWUgPSBhdHRyaWJ1dGVzT3JTdGFydFRpbWU7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzT3JTdGFydFRpbWUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RhcnRUaW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzdGFydFRpbWUgPSBoclRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzYW5pdGl6ZUF0dHJpYnV0ZXMoYXR0cmlidXRlc09yU3RhcnRUaW1lKTtcbiAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgdGltZTogdGltZUlucHV0VG9IclRpbWUoc3RhcnRUaW1lKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBTcGFuMy5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLnVwZGF0ZU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBTcGFuMy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZW5kVGltZSkge1xuICAgIGlmIChlbmRUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGVuZFRpbWUgPSBoclRpbWUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpIHtcbiAgICAgIGRpYWcyLmVycm9yKFwiWW91IGNhbiBvbmx5IGNhbGwgZW5kKCkgb24gYSBzcGFuIG9uY2UuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgdGhpcy5lbmRUaW1lID0gdGltZUlucHV0VG9IclRpbWUoZW5kVGltZSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBoclRpbWVEdXJhdGlvbih0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lKTtcbiAgICBpZiAodGhpcy5fZHVyYXRpb25bMF0gPCAwKSB7XG4gICAgICBkaWFnMi53YXJuKFwiSW5jb25zaXN0ZW50IHN0YXJ0IGFuZCBlbmQgdGltZSwgc3RhcnRUaW1lID4gZW5kVGltZVwiLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lKTtcbiAgICB9XG4gICAgdGhpcy5fc3BhblByb2Nlc3Nvci5vbkVuZCh0aGlzKTtcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZGVkID09PSBmYWxzZTtcbiAgfTtcbiAgU3BhbjMucHJvdG90eXBlLnJlY29yZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGV4Y2VwdGlvbiwgdGltZSkge1xuICAgIGlmICh0aW1lID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWUgPSBoclRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGV4Y2VwdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX01FU1NBR0VdID0gZXhjZXB0aW9uO1xuICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAoZXhjZXB0aW9uLmNvZGUpIHtcbiAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX1RZUEVdID0gZXhjZXB0aW9uLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uLm5hbWUpIHtcbiAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX1RZUEVdID0gZXhjZXB0aW9uLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uLm1lc3NhZ2UpIHtcbiAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX01FU1NBR0VdID0gZXhjZXB0aW9uLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uLnN0YWNrKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9TVEFDS1RSQUNFXSA9IGV4Y2VwdGlvbi5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9UWVBFXSB8fCBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5FWENFUFRJT05fTUVTU0FHRV0pIHtcbiAgICAgIHRoaXMuYWRkRXZlbnQoRXhjZXB0aW9uRXZlbnROYW1lLCBhdHRyaWJ1dGVzLCB0aW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlhZzIud2FybihcIkZhaWxlZCB0byByZWNvcmQgYW4gZXhjZXB0aW9uIFwiICsgZXhjZXB0aW9uKTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGFuMy5wcm90b3R5cGUsIFwiZHVyYXRpb25cIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGFuMy5wcm90b3R5cGUsIFwiZW5kZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5kZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFNwYW4zLnByb3RvdHlwZS5faXNTcGFuRW5kZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgIGRpYWcyLndhcm4oXCJDYW4gbm90IGV4ZWN1dGUgdGhlIG9wZXJhdGlvbiBvbiBlbmRlZCBTcGFuIHt0cmFjZUlkOiBcIiArIHRoaXMuX3NwYW5Db250ZXh0LnRyYWNlSWQgKyBcIiwgc3BhbklkOiBcIiArIHRoaXMuX3NwYW5Db250ZXh0LnNwYW5JZCArIFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VuZGVkO1xuICB9O1xuICBTcGFuMy5wcm90b3R5cGUuX3RydW5jYXRlVG9MaW1pdFV0aWwgPSBmdW5jdGlvbih2YWx1ZSwgbGltaXQpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoMCwgbGltaXQpO1xuICB9O1xuICBTcGFuMy5wcm90b3R5cGUuX3RydW5jYXRlVG9TaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2F0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQ7XG4gICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgIGRpYWcyLndhcm4oXCJBdHRyaWJ1dGUgdmFsdWUgbGltaXQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290IFwiICsgbGltaXQpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJ1bmNhdGVUb0xpbWl0VXRpbCh2YWx1ZSwgbGltaXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gX3RoaXMuX3RydW5jYXRlVG9MaW1pdFV0aWwodmFsLCBsaW1pdCkgOiB2YWw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICByZXR1cm4gU3BhbjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9TYW1wbGVyLmpzXG52YXIgU2FtcGxpbmdEZWNpc2lvbjI7XG4oZnVuY3Rpb24oU2FtcGxpbmdEZWNpc2lvbjMpIHtcbiAgU2FtcGxpbmdEZWNpc2lvbjNbU2FtcGxpbmdEZWNpc2lvbjNbXCJOT1RfUkVDT1JEXCJdID0gMF0gPSBcIk5PVF9SRUNPUkRcIjtcbiAgU2FtcGxpbmdEZWNpc2lvbjNbU2FtcGxpbmdEZWNpc2lvbjNbXCJSRUNPUkRcIl0gPSAxXSA9IFwiUkVDT1JEXCI7XG4gIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiUkVDT1JEX0FORF9TQU1QTEVEXCJdID0gMl0gPSBcIlJFQ09SRF9BTkRfU0FNUExFRFwiO1xufSkoU2FtcGxpbmdEZWNpc2lvbjIgfHwgKFNhbXBsaW5nRGVjaXNpb24yID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3NhbXBsZXIvQWx3YXlzT2ZmU2FtcGxlci5qc1xudmFyIEFsd2F5c09mZlNhbXBsZXIyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFsd2F5c09mZlNhbXBsZXIzKCkge1xuICB9XG4gIF9fbmFtZShBbHdheXNPZmZTYW1wbGVyMywgXCJBbHdheXNPZmZTYW1wbGVyXCIpO1xuICBBbHdheXNPZmZTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY2lzaW9uOiBTYW1wbGluZ0RlY2lzaW9uMi5OT1RfUkVDT1JEXG4gICAgfTtcbiAgfTtcbiAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiQWx3YXlzT2ZmU2FtcGxlclwiO1xuICB9O1xuICByZXR1cm4gQWx3YXlzT2ZmU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL0Fsd2F5c09uU2FtcGxlci5qc1xudmFyIEFsd2F5c09uU2FtcGxlcjIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQWx3YXlzT25TYW1wbGVyMygpIHtcbiAgfVxuICBfX25hbWUoQWx3YXlzT25TYW1wbGVyMywgXCJBbHdheXNPblNhbXBsZXJcIik7XG4gIEFsd2F5c09uU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogU2FtcGxpbmdEZWNpc2lvbjIuUkVDT1JEX0FORF9TQU1QTEVEXG4gICAgfTtcbiAgfTtcbiAgQWx3YXlzT25TYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJBbHdheXNPblNhbXBsZXJcIjtcbiAgfTtcbiAgcmV0dXJuIEFsd2F5c09uU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL1BhcmVudEJhc2VkU2FtcGxlci5qc1xudmFyIFBhcmVudEJhc2VkU2FtcGxlcjIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUGFyZW50QmFzZWRTYW1wbGVyMyhjb25maWcyKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gICAgdGhpcy5fcm9vdCA9IGNvbmZpZzIucm9vdDtcbiAgICBpZiAoIXRoaXMuX3Jvb3QpIHtcbiAgICAgIGdsb2JhbEVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJQYXJlbnRCYXNlZFNhbXBsZXIgbXVzdCBoYXZlIGEgcm9vdCBzYW1wbGVyIGNvbmZpZ3VyZWRcIikpO1xuICAgICAgdGhpcy5fcm9vdCA9IG5ldyBBbHdheXNPblNhbXBsZXIyKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQgPSAoX2EzID0gY29uZmlnMi5yZW1vdGVQYXJlbnRTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IG5ldyBBbHdheXNPblNhbXBsZXIyKCk7XG4gICAgdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZCA9IChfYjIgPSBjb25maWcyLnJlbW90ZVBhcmVudE5vdFNhbXBsZWQpICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogbmV3IEFsd2F5c09mZlNhbXBsZXIyKCk7XG4gICAgdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkID0gKF9jID0gY29uZmlnMi5sb2NhbFBhcmVudFNhbXBsZWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBBbHdheXNPblNhbXBsZXIyKCk7XG4gICAgdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkID0gKF9kID0gY29uZmlnMi5sb2NhbFBhcmVudE5vdFNhbXBsZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBBbHdheXNPZmZTYW1wbGVyMigpO1xuICB9XG4gIF9fbmFtZShQYXJlbnRCYXNlZFNhbXBsZXIzLCBcIlBhcmVudEJhc2VkU2FtcGxlclwiKTtcbiAgUGFyZW50QmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpIHtcbiAgICB2YXIgcGFyZW50Q29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQzKTtcbiAgICBpZiAoIXBhcmVudENvbnRleHQgfHwgIWlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRDb250ZXh0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Quc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudENvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgIGlmIChwYXJlbnRDb250ZXh0LnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb250ZXh0LnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQzLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDMsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICB9O1xuICBQYXJlbnRCYXNlZFNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlBhcmVudEJhc2Vke3Jvb3Q9XCIgKyB0aGlzLl9yb290LnRvU3RyaW5nKCkgKyBcIiwgcmVtb3RlUGFyZW50U2FtcGxlZD1cIiArIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCByZW1vdGVQYXJlbnROb3RTYW1wbGVkPVwiICsgdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZC50b1N0cmluZygpICsgXCIsIGxvY2FsUGFyZW50U2FtcGxlZD1cIiArIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZC50b1N0cmluZygpICsgXCIsIGxvY2FsUGFyZW50Tm90U2FtcGxlZD1cIiArIHRoaXMuX2xvY2FsUGFyZW50Tm90U2FtcGxlZC50b1N0cmluZygpICsgXCJ9XCI7XG4gIH07XG4gIHJldHVybiBQYXJlbnRCYXNlZFNhbXBsZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vc2FtcGxlci9UcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIuanNcbnZhciBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMoX3JhdGlvKSB7XG4gICAgaWYgKF9yYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICBfcmF0aW8gPSAwO1xuICAgIH1cbiAgICB0aGlzLl9yYXRpbyA9IF9yYXRpbztcbiAgICB0aGlzLl9yYXRpbyA9IHRoaXMuX25vcm1hbGl6ZShfcmF0aW8pO1xuICAgIHRoaXMuX3VwcGVyQm91bmQgPSBNYXRoLmZsb29yKHRoaXMuX3JhdGlvICogNDI5NDk2NzI5NSk7XG4gIH1cbiAgX19uYW1lKFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMsIFwiVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyXCIpO1xuICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbihjb250ZXh0MywgdHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNpc2lvbjogaXNWYWxpZFRyYWNlSWQodHJhY2VJZCkgJiYgdGhpcy5fYWNjdW11bGF0ZSh0cmFjZUlkKSA8IHRoaXMuX3VwcGVyQm91bmQgPyBTYW1wbGluZ0RlY2lzaW9uMi5SRUNPUkRfQU5EX1NBTVBMRUQgOiBTYW1wbGluZ0RlY2lzaW9uMi5OT1RfUkVDT1JEXG4gICAgfTtcbiAgfTtcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJUcmFjZUlkUmF0aW9CYXNlZHtcIiArIHRoaXMuX3JhdGlvICsgXCJ9XCI7XG4gIH07XG4gIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbihyYXRpbykge1xuICAgIGlmICh0eXBlb2YgcmF0aW8gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4ocmF0aW8pKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHJhdGlvID49IDEgPyAxIDogcmF0aW8gPD0gMCA/IDAgOiByYXRpbztcbiAgfTtcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuX2FjY3VtdWxhdGUgPSBmdW5jdGlvbih0cmFjZUlkKSB7XG4gICAgdmFyIGFjY3VtdWxhdGlvbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUlkLmxlbmd0aCAvIDg7IGkrKykge1xuICAgICAgdmFyIHBvcyA9IGkgKiA4O1xuICAgICAgdmFyIHBhcnQgPSBwYXJzZUludCh0cmFjZUlkLnNsaWNlKHBvcywgcG9zICsgOCksIDE2KTtcbiAgICAgIGFjY3VtdWxhdGlvbiA9IChhY2N1bXVsYXRpb24gXiBwYXJ0KSA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdGlvbjtcbiAgfTtcbiAgcmV0dXJuIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjM7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9jb25maWcuanNcbnZhciBlbnYgPSBnZXRFbnYoKTtcbnZhciBGQUxMQkFDS19PVEVMX1RSQUNFU19TQU1QTEVSID0gVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPbjtcbnZhciBERUZBVUxUX1JBVElPID0gMTtcbmZ1bmN0aW9uIGxvYWREZWZhdWx0Q29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXI6IGJ1aWxkU2FtcGxlckZyb21FbnYoZW52KSxcbiAgICBmb3JjZUZsdXNoVGltZW91dE1pbGxpczogM2U0LFxuICAgIGdlbmVyYWxMaW1pdHM6IHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQ6IGdldEVudigpLk9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgICAgIGF0dHJpYnV0ZUNvdW50TGltaXQ6IGdldEVudigpLk9URUxfQVRUUklCVVRFX0NPVU5UX0xJTUlUXG4gICAgfSxcbiAgICBzcGFuTGltaXRzOiB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0OiBnZXRFbnYoKS5PVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgICAgIGF0dHJpYnV0ZUNvdW50TGltaXQ6IGdldEVudigpLk9URUxfU1BBTl9BVFRSSUJVVEVfQ09VTlRfTElNSVQsXG4gICAgICBsaW5rQ291bnRMaW1pdDogZ2V0RW52KCkuT1RFTF9TUEFOX0xJTktfQ09VTlRfTElNSVQsXG4gICAgICBldmVudENvdW50TGltaXQ6IGdldEVudigpLk9URUxfU1BBTl9FVkVOVF9DT1VOVF9MSU1JVFxuICAgIH1cbiAgfTtcbn1cbl9fbmFtZShsb2FkRGVmYXVsdENvbmZpZywgXCJsb2FkRGVmYXVsdENvbmZpZ1wiKTtcbmZ1bmN0aW9uIGJ1aWxkU2FtcGxlckZyb21FbnYoZW52aXJvbm1lbnQpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSB2b2lkIDApIHtcbiAgICBlbnZpcm9ubWVudCA9IGdldEVudigpO1xuICB9XG4gIHN3aXRjaCAoZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUikge1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPbjpcbiAgICAgIHJldHVybiBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPZmY6XG4gICAgICByZXR1cm4gbmV3IEFsd2F5c09mZlNhbXBsZXIyKCk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkQWx3YXlzT246XG4gICAgICByZXR1cm4gbmV3IFBhcmVudEJhc2VkU2FtcGxlcjIoe1xuICAgICAgICByb290OiBuZXcgQWx3YXlzT25TYW1wbGVyMigpXG4gICAgICB9KTtcbiAgICBjYXNlIFRyYWNlc1NhbXBsZXJWYWx1ZXMuUGFyZW50QmFzZWRBbHdheXNPZmY6XG4gICAgICByZXR1cm4gbmV3IFBhcmVudEJhc2VkU2FtcGxlcjIoe1xuICAgICAgICByb290OiBuZXcgQWx3YXlzT2ZmU2FtcGxlcjIoKVxuICAgICAgfSk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlRyYWNlSWRSYXRpbzpcbiAgICAgIHJldHVybiBuZXcgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMihnZXRTYW1wbGVyUHJvYmFiaWxpdHlGcm9tRW52KGVudmlyb25tZW50KSk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkVHJhY2VJZFJhdGlvOlxuICAgICAgcmV0dXJuIG5ldyBQYXJlbnRCYXNlZFNhbXBsZXIyKHtcbiAgICAgICAgcm9vdDogbmV3IFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjIoZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudihlbnZpcm9ubWVudCkpXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgZGlhZzIuZXJyb3IoJ09URUxfVFJBQ0VTX1NBTVBMRVIgdmFsdWUgXCInICsgZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUiArIFwiIGludmFsaWQsIGRlZmF1bHRpbmcgdG8gXCIgKyBGQUxMQkFDS19PVEVMX1RSQUNFU19TQU1QTEVSICsgJ1wiLicpO1xuICAgICAgcmV0dXJuIG5ldyBBbHdheXNPblNhbXBsZXIyKCk7XG4gIH1cbn1cbl9fbmFtZShidWlsZFNhbXBsZXJGcm9tRW52LCBcImJ1aWxkU2FtcGxlckZyb21FbnZcIik7XG5mdW5jdGlvbiBnZXRTYW1wbGVyUHJvYmFiaWxpdHlGcm9tRW52KGVudmlyb25tZW50KSB7XG4gIGlmIChlbnZpcm9ubWVudC5PVEVMX1RSQUNFU19TQU1QTEVSX0FSRyA9PT0gdm9pZCAwIHx8IGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHID09PSBcIlwiKSB7XG4gICAgZGlhZzIuZXJyb3IoXCJPVEVMX1RSQUNFU19TQU1QTEVSX0FSRyBpcyBibGFuaywgZGVmYXVsdGluZyB0byBcIiArIERFRkFVTFRfUkFUSU8gKyBcIi5cIik7XG4gICAgcmV0dXJuIERFRkFVTFRfUkFUSU87XG4gIH1cbiAgdmFyIHByb2JhYmlsaXR5ID0gTnVtYmVyKGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHKTtcbiAgaWYgKGlzTmFOKHByb2JhYmlsaXR5KSkge1xuICAgIGRpYWcyLmVycm9yKFwiT1RFTF9UUkFDRVNfU0FNUExFUl9BUkc9XCIgKyBlbnZpcm9ubWVudC5PVEVMX1RSQUNFU19TQU1QTEVSX0FSRyArIFwiIHdhcyBnaXZlbiwgYnV0IGl0IGlzIGludmFsaWQsIGRlZmF1bHRpbmcgdG8gXCIgKyBERUZBVUxUX1JBVElPICsgXCIuXCIpO1xuICAgIHJldHVybiBERUZBVUxUX1JBVElPO1xuICB9XG4gIGlmIChwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxKSB7XG4gICAgZGlhZzIuZXJyb3IoXCJPVEVMX1RSQUNFU19TQU1QTEVSX0FSRz1cIiArIGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHICsgXCIgd2FzIGdpdmVuLCBidXQgaXQgaXMgb3V0IG9mIHJhbmdlIChbMC4uMV0pLCBkZWZhdWx0aW5nIHRvIFwiICsgREVGQVVMVF9SQVRJTyArIFwiLlwiKTtcbiAgICByZXR1cm4gREVGQVVMVF9SQVRJTztcbiAgfVxuICByZXR1cm4gcHJvYmFiaWxpdHk7XG59XG5fX25hbWUoZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudiwgXCJnZXRTYW1wbGVyUHJvYmFiaWxpdHlGcm9tRW52XCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vdXRpbGl0eS5qc1xuZnVuY3Rpb24gbWVyZ2VDb25maWcodXNlckNvbmZpZykge1xuICB2YXIgcGVySW5zdGFuY2VEZWZhdWx0cyA9IHtcbiAgICBzYW1wbGVyOiBidWlsZFNhbXBsZXJGcm9tRW52KClcbiAgfTtcbiAgdmFyIERFRkFVTFRfQ09ORklHID0gbG9hZERlZmF1bHRDb25maWcoKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHLCBwZXJJbnN0YW5jZURlZmF1bHRzLCB1c2VyQ29uZmlnKTtcbiAgdGFyZ2V0LmdlbmVyYWxMaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRy5nZW5lcmFsTGltaXRzLCB1c2VyQ29uZmlnLmdlbmVyYWxMaW1pdHMgfHwge30pO1xuICB0YXJnZXQuc3BhbkxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHLnNwYW5MaW1pdHMsIHVzZXJDb25maWcuc3BhbkxpbWl0cyB8fCB7fSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5fX25hbWUobWVyZ2VDb25maWcsIFwibWVyZ2VDb25maWdcIik7XG5mdW5jdGlvbiByZWNvbmZpZ3VyZUxpbWl0cyh1c2VyQ29uZmlnKSB7XG4gIHZhciBfYTMsIF9iMiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gIHZhciBzcGFuTGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgdXNlckNvbmZpZy5zcGFuTGltaXRzKTtcbiAgdmFyIHBhcnNlZEVudkNvbmZpZyA9IGdldEVudldpdGhvdXREZWZhdWx0cygpO1xuICBzcGFuTGltaXRzLmF0dHJpYnV0ZUNvdW50TGltaXQgPSAoX2YgPSAoX2UgPSAoX2QgPSAoX2IyID0gKF9hMyA9IHVzZXJDb25maWcuc3BhbkxpbWl0cykgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMuYXR0cmlidXRlQ291bnRMaW1pdCkgIT09IG51bGwgJiYgX2IyICE9PSB2b2lkIDAgPyBfYjIgOiAoX2MgPSB1c2VyQ29uZmlnLmdlbmVyYWxMaW1pdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hdHRyaWJ1dGVDb3VudExpbWl0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBwYXJzZWRFbnZDb25maWcuT1RFTF9TUEFOX0FUVFJJQlVURV9DT1VOVF9MSU1JVCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogcGFyc2VkRW52Q29uZmlnLk9URUxfQVRUUklCVVRFX0NPVU5UX0xJTUlUKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBERUZBVUxUX0FUVFJJQlVURV9DT1VOVF9MSU1JVDtcbiAgc3BhbkxpbWl0cy5hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0ID0gKF9tID0gKF9sID0gKF9rID0gKF9oID0gKF9nID0gdXNlckNvbmZpZy5zcGFuTGltaXRzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogKF9qID0gdXNlckNvbmZpZy5nZW5lcmFsTGltaXRzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouYXR0cmlidXRlVmFsdWVMZW5ndGhMaW1pdCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcGFyc2VkRW52Q29uZmlnLk9URUxfU1BBTl9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBwYXJzZWRFbnZDb25maWcuT1RFTF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB1c2VyQ29uZmlnLCB7IHNwYW5MaW1pdHMgfSk7XG59XG5fX25hbWUocmVjb25maWd1cmVMaW1pdHMsIFwicmVjb25maWd1cmVMaW1pdHNcIik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZS5qc1xudmFyIEJhdGNoU3BhblByb2Nlc3NvckJhc2UgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIoX2V4cG9ydGVyLCBjb25maWcyKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIgPSBfZXhwb3J0ZXI7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFucyA9IFtdO1xuICAgIHZhciBlbnYyID0gZ2V0RW52KCk7XG4gICAgdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplID0gdHlwZW9mIChjb25maWcyID09PSBudWxsIHx8IGNvbmZpZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZzIubWF4RXhwb3J0QmF0Y2hTaXplKSA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZzIubWF4RXhwb3J0QmF0Y2hTaXplIDogZW52Mi5PVEVMX0JTUF9NQVhfRVhQT1JUX0JBVENIX1NJWkU7XG4gICAgdGhpcy5fbWF4UXVldWVTaXplID0gdHlwZW9mIChjb25maWcyID09PSBudWxsIHx8IGNvbmZpZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZzIubWF4UXVldWVTaXplKSA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZzIubWF4UXVldWVTaXplIDogZW52Mi5PVEVMX0JTUF9NQVhfUVVFVUVfU0laRTtcbiAgICB0aGlzLl9zY2hlZHVsZWREZWxheU1pbGxpcyA9IHR5cGVvZiAoY29uZmlnMiA9PT0gbnVsbCB8fCBjb25maWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcyLnNjaGVkdWxlZERlbGF5TWlsbGlzKSA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZzIuc2NoZWR1bGVkRGVsYXlNaWxsaXMgOiBlbnYyLk9URUxfQlNQX1NDSEVEVUxFX0RFTEFZO1xuICAgIHRoaXMuX2V4cG9ydFRpbWVvdXRNaWxsaXMgPSB0eXBlb2YgKGNvbmZpZzIgPT09IG51bGwgfHwgY29uZmlnMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnMi5leHBvcnRUaW1lb3V0TWlsbGlzKSA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZzIuZXhwb3J0VGltZW91dE1pbGxpcyA6IGVudjIuT1RFTF9CU1BfRVhQT1JUX1RJTUVPVVQ7XG4gICAgdGhpcy5fc2h1dGRvd25PbmNlID0gbmV3IEJpbmRPbmNlRnV0dXJlKHRoaXMuX3NodXRkb3duLCB0aGlzKTtcbiAgfVxuICBfX25hbWUoQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIsIFwiQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZVwiKTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc2h1dGRvd25PbmNlLmlzQ2FsbGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2h1dGRvd25PbmNlLnByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mbHVzaEFsbCgpO1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKF9zcGFuLCBfcGFyZW50Q29udGV4dCkge1xuICB9O1xuICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgaWYgKHRoaXMuX3NodXRkb3duT25jZS5pc0NhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUZsYWdzICYgVHJhY2VGbGFncy5TQU1QTEVEKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hZGRUb0J1ZmZlcihzcGFuKTtcbiAgfTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NodXRkb3duT25jZS5jYWxsKCk7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uU2h1dGRvd24oKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9mbHVzaEFsbCgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2V4cG9ydGVyLnNodXRkb3duKCk7XG4gICAgfSk7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fYWRkVG9CdWZmZXIgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoID49IHRoaXMuX21heFF1ZXVlU2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zLnB1c2goc3Bhbik7XG4gICAgdGhpcy5fbWF5YmVTdGFydFRpbWVyKCk7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fZmx1c2hBbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50MiA9IE1hdGguY2VpbChfdGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggLyBfdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY291bnQyOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goX3RoaXMuX2ZsdXNoT25lQmF0Y2goKSk7XG4gICAgICB9XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLl9mbHVzaE9uZUJhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgaWYgKHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0XCIpKTtcbiAgICAgIH0sIF90aGlzLl9leHBvcnRUaW1lb3V0TWlsbGlzKTtcbiAgICAgIGNvbnRleHQyLndpdGgoc3VwcHJlc3NUcmFjaW5nKGNvbnRleHQyLmFjdGl2ZSgpKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9leHBvcnRlci5leHBvcnQoX3RoaXMuX2ZpbmlzaGVkU3BhbnMuc3BsaWNlKDAsIF90aGlzLl9tYXhFeHBvcnRCYXRjaFNpemUpLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgaWYgKHJlc3VsdC5jb2RlID09PSBFeHBvcnRSZXN1bHRDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KChfYTMgPSByZXN1bHQuZXJyb3IpICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogbmV3IEVycm9yKFwiQmF0Y2hTcGFuUHJvY2Vzc29yOiBzcGFuIGV4cG9ydCBmYWlsZWRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLl9tYXliZVN0YXJ0VGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLl90aW1lciAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9mbHVzaE9uZUJhdGNoKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF90aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgICAgICAgIF90aGlzLl9tYXliZVN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBnbG9iYWxFcnJvckhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLl9zY2hlZHVsZWREZWxheU1pbGxpcyk7XG4gICAgdW5yZWZUaW1lcih0aGlzLl90aW1lcik7XG4gIH07XG4gIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fY2xlYXJUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl90aW1lciAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2V4cG9ydC9CYXRjaFNwYW5Qcm9jZXNzb3IuanNcbnZhciBfX2V4dGVuZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV4dGVuZFN0YXRpY3MgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGQsIGIpIHtcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICB9IHx8IGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiMilcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcCkpXG4gICAgICAgICAgZDJbcF0gPSBiMltwXTtcbiAgICB9O1xuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9LCBcImV4dGVuZFN0YXRpY3NcIik7XG4gIHJldHVybiBmdW5jdGlvbihkLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuICAgIF9fbmFtZShfXywgXCJfX1wiKTtcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG52YXIgQmF0Y2hTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCYXRjaFNwYW5Qcm9jZXNzb3IyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBCYXRjaFNwYW5Qcm9jZXNzb3IyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBfX25hbWUoQmF0Y2hTcGFuUHJvY2Vzc29yMiwgXCJCYXRjaFNwYW5Qcm9jZXNzb3JcIik7XG4gIEJhdGNoU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLm9uU2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgcmV0dXJuIEJhdGNoU3BhblByb2Nlc3NvcjI7XG59KEJhdGNoU3BhblByb2Nlc3NvckJhc2UpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9SYW5kb21JZEdlbmVyYXRvci5qc1xudmFyIFNQQU5fSURfQllURVMyID0gODtcbnZhciBUUkFDRV9JRF9CWVRFUzIgPSAxNjtcbnZhciBSYW5kb21JZEdlbmVyYXRvcjIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmFuZG9tSWRHZW5lcmF0b3IzKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVUcmFjZUlkID0gZ2V0SWRHZW5lcmF0b3IyKFRSQUNFX0lEX0JZVEVTMik7XG4gICAgdGhpcy5nZW5lcmF0ZVNwYW5JZCA9IGdldElkR2VuZXJhdG9yMihTUEFOX0lEX0JZVEVTMik7XG4gIH1cbiAgX19uYW1lKFJhbmRvbUlkR2VuZXJhdG9yMywgXCJSYW5kb21JZEdlbmVyYXRvclwiKTtcbiAgcmV0dXJuIFJhbmRvbUlkR2VuZXJhdG9yMztcbn0oKTtcbnZhciBTSEFSRURfQlVGRkVSMiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShUUkFDRV9JRF9CWVRFUzIpO1xuZnVuY3Rpb24gZ2V0SWRHZW5lcmF0b3IyKGJ5dGVzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcyAvIDQ7IGkrKykge1xuICAgICAgU0hBUkVEX0JVRkZFUjIud3JpdGVVSW50MzJCRShNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgMzIpID4+PiAwLCBpICogNCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgaWYgKFNIQVJFRF9CVUZGRVIyW2ldID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gYnl0ZXMgLSAxKSB7XG4gICAgICAgIFNIQVJFRF9CVUZGRVIyW2J5dGVzIC0gMV0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU0hBUkVEX0JVRkZFUjIudG9TdHJpbmcoXCJoZXhcIiwgMCwgYnl0ZXMpO1xuICB9LCBcImdlbmVyYXRlSWRcIik7XG59XG5fX25hbWUoZ2V0SWRHZW5lcmF0b3IyLCBcImdldElkR2VuZXJhdG9yXCIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vVHJhY2VyLmpzXG52YXIgVHJhY2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyYWNlcjMoaW5zdHJ1bWVudGF0aW9uTGlicmFyeSwgY29uZmlnMiwgX3RyYWNlclByb3ZpZGVyKSB7XG4gICAgdGhpcy5fdHJhY2VyUHJvdmlkZXIgPSBfdHJhY2VyUHJvdmlkZXI7XG4gICAgdmFyIGxvY2FsQ29uZmlnID0gbWVyZ2VDb25maWcoY29uZmlnMik7XG4gICAgdGhpcy5fc2FtcGxlciA9IGxvY2FsQ29uZmlnLnNhbXBsZXI7XG4gICAgdGhpcy5fZ2VuZXJhbExpbWl0cyA9IGxvY2FsQ29uZmlnLmdlbmVyYWxMaW1pdHM7XG4gICAgdGhpcy5fc3BhbkxpbWl0cyA9IGxvY2FsQ29uZmlnLnNwYW5MaW1pdHM7XG4gICAgdGhpcy5faWRHZW5lcmF0b3IgPSBjb25maWcyLmlkR2VuZXJhdG9yIHx8IG5ldyBSYW5kb21JZEdlbmVyYXRvcjIoKTtcbiAgICB0aGlzLnJlc291cmNlID0gX3RyYWNlclByb3ZpZGVyLnJlc291cmNlO1xuICAgIHRoaXMuaW5zdHJ1bWVudGF0aW9uTGlicmFyeSA9IGluc3RydW1lbnRhdGlvbkxpYnJhcnk7XG4gIH1cbiAgX19uYW1lKFRyYWNlcjMsIFwiVHJhY2VyXCIpO1xuICBUcmFjZXIzLnByb3RvdHlwZS5zdGFydFNwYW4gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zLCBjb250ZXh0Mykge1xuICAgIHZhciBfYTMsIF9iMjtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChjb250ZXh0MyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250ZXh0MyA9IGNvbnRleHQyLmFjdGl2ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0MykpIHtcbiAgICAgIGRpYWcyLmRlYnVnKFwiSW5zdHJ1bWVudGF0aW9uIHN1cHByZXNzZWQsIHJldHVybmluZyBOb29wIFNwYW5cIik7XG4gICAgICByZXR1cm4gdHJhY2Uud3JhcFNwYW5Db250ZXh0KElOVkFMSURfU1BBTl9DT05URVhUKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucm9vdCkge1xuICAgICAgY29udGV4dDMgPSB0cmFjZS5kZWxldGVTcGFuKGNvbnRleHQzKTtcbiAgICB9XG4gICAgdmFyIHBhcmVudFNwYW5Db250ZXh0ID0gdHJhY2UuZ2V0U3BhbkNvbnRleHQoY29udGV4dDMpO1xuICAgIHZhciBzcGFuSWQgPSB0aGlzLl9pZEdlbmVyYXRvci5nZW5lcmF0ZVNwYW5JZCgpO1xuICAgIHZhciB0cmFjZUlkO1xuICAgIHZhciB0cmFjZVN0YXRlO1xuICAgIHZhciBwYXJlbnRTcGFuSWQ7XG4gICAgaWYgKCFwYXJlbnRTcGFuQ29udGV4dCB8fCAhdHJhY2UuaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudFNwYW5Db250ZXh0KSkge1xuICAgICAgdHJhY2VJZCA9IHRoaXMuX2lkR2VuZXJhdG9yLmdlbmVyYXRlVHJhY2VJZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjZUlkID0gcGFyZW50U3BhbkNvbnRleHQudHJhY2VJZDtcbiAgICAgIHRyYWNlU3RhdGUgPSBwYXJlbnRTcGFuQ29udGV4dC50cmFjZVN0YXRlO1xuICAgICAgcGFyZW50U3BhbklkID0gcGFyZW50U3BhbkNvbnRleHQuc3BhbklkO1xuICAgIH1cbiAgICB2YXIgc3BhbktpbmQgPSAoX2EzID0gb3B0aW9ucy5raW5kKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IFNwYW5LaW5kLklOVEVSTkFMO1xuICAgIHZhciBsaW5rcyA9ICgoX2IyID0gb3B0aW9ucy5saW5rcykgIT09IG51bGwgJiYgX2IyICE9PSB2b2lkIDAgPyBfYjIgOiBbXSkubWFwKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IGxpbmsuY29udGV4dCxcbiAgICAgICAgYXR0cmlidXRlczogc2FuaXRpemVBdHRyaWJ1dGVzKGxpbmsuYXR0cmlidXRlcylcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzYW5pdGl6ZUF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICB2YXIgc2FtcGxpbmdSZXN1bHQgPSB0aGlzLl9zYW1wbGVyLnNob3VsZFNhbXBsZShjb250ZXh0MywgdHJhY2VJZCwgbmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICB2YXIgdHJhY2VGbGFncyA9IHNhbXBsaW5nUmVzdWx0LmRlY2lzaW9uID09PSBTYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA/IFRyYWNlRmxhZ3MuU0FNUExFRCA6IFRyYWNlRmxhZ3MuTk9ORTtcbiAgICB2YXIgc3BhbkNvbnRleHQgPSB7IHRyYWNlSWQsIHNwYW5JZCwgdHJhY2VGbGFncywgdHJhY2VTdGF0ZSB9O1xuICAgIGlmIChzYW1wbGluZ1Jlc3VsdC5kZWNpc2lvbiA9PT0gU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEKSB7XG4gICAgICBkaWFnMi5kZWJ1ZyhcIlJlY29yZGluZyBpcyBvZmYsIHByb3BhZ2F0aW5nIGNvbnRleHQgaW4gYSBub24tcmVjb3JkaW5nIHNwYW5cIik7XG4gICAgICByZXR1cm4gdHJhY2Uud3JhcFNwYW5Db250ZXh0KHNwYW5Db250ZXh0KTtcbiAgICB9XG4gICAgdmFyIHNwYW4gPSBuZXcgU3Bhbih0aGlzLCBjb250ZXh0MywgbmFtZSwgc3BhbkNvbnRleHQsIHNwYW5LaW5kLCBwYXJlbnRTcGFuSWQsIGxpbmtzLCBvcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgdmFyIGluaXRBdHRyaWJ1dGVzID0gc2FuaXRpemVBdHRyaWJ1dGVzKE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgc2FtcGxpbmdSZXN1bHQuYXR0cmlidXRlcykpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlcyhpbml0QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIHNwYW47XG4gIH07XG4gIFRyYWNlcjMucHJvdG90eXBlLnN0YXJ0QWN0aXZlU3BhbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICB2YXIgb3B0cztcbiAgICB2YXIgY3R4O1xuICAgIHZhciBmbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGZuID0gYXJnMjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIG9wdHMgPSBhcmcyO1xuICAgICAgZm4gPSBhcmczO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0gYXJnMjtcbiAgICAgIGN0eCA9IGFyZzM7XG4gICAgICBmbiA9IGFyZzQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnRDb250ZXh0ID0gY3R4ICE9PSBudWxsICYmIGN0eCAhPT0gdm9pZCAwID8gY3R4IDogY29udGV4dDIuYWN0aXZlKCk7XG4gICAgdmFyIHNwYW4gPSB0aGlzLnN0YXJ0U3BhbihuYW1lLCBvcHRzLCBwYXJlbnRDb250ZXh0KTtcbiAgICB2YXIgY29udGV4dFdpdGhTcGFuU2V0ID0gdHJhY2Uuc2V0U3BhbihwYXJlbnRDb250ZXh0LCBzcGFuKTtcbiAgICByZXR1cm4gY29udGV4dDIud2l0aChjb250ZXh0V2l0aFNwYW5TZXQsIGZuLCB2b2lkIDAsIHNwYW4pO1xuICB9O1xuICBUcmFjZXIzLnByb3RvdHlwZS5nZXRHZW5lcmFsTGltaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlbmVyYWxMaW1pdHM7XG4gIH07XG4gIFRyYWNlcjMucHJvdG90eXBlLmdldFNwYW5MaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhbkxpbWl0cztcbiAgfTtcbiAgVHJhY2VyMy5wcm90b3R5cGUuZ2V0QWN0aXZlU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFjZXJQcm92aWRlci5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yKCk7XG4gIH07XG4gIHJldHVybiBUcmFjZXIzO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2RlZmF1bHQtc2VydmljZS1uYW1lLmpzXG5mdW5jdGlvbiBkZWZhdWx0U2VydmljZU5hbWUoKSB7XG4gIHJldHVybiBcInVua25vd25fc2VydmljZTpcIiArIHByb2Nlc3MuYXJndjA7XG59XG5fX25hbWUoZGVmYXVsdFNlcnZpY2VOYW1lLCBcImRlZmF1bHRTZXJ2aWNlTmFtZVwiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9Ib3N0RGV0ZWN0b3IuanNcbnZhciBpbXBvcnRfb3MyID0gcmVxdWlyZShcIm9zXCIpO1xudmFyIF9fYXdhaXRlciA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAzLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQMyA/IHZhbHVlIDogbmV3IFAzKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9fbmFtZShhZG9wdCwgXCJhZG9wdFwiKTtcbiAgcmV0dXJuIG5ldyAoUDMgfHwgKFAzID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmdWxmaWxsZWQsIFwiZnVsZmlsbGVkXCIpO1xuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlamVjdGVkLCBcInJlamVjdGVkXCIpO1xuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodFswXSAmIDEpXG4gICAgICB0aHJvdyB0WzFdO1xuICAgIHJldHVybiB0WzFdO1xuICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG4gIF9fbmFtZSh2ZXJiLCBcInZlcmJcIik7XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICBpZiAoZilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIHdoaWxlIChfKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBmID0gdCA9IDA7XG4gICAgICB9XG4gICAgaWYgKG9wWzBdICYgNSlcbiAgICAgIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbn07XG52YXIgSG9zdERldGVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEhvc3REZXRlY3RvcjIoKSB7XG4gIH1cbiAgX19uYW1lKEhvc3REZXRlY3RvcjIsIFwiSG9zdERldGVjdG9yXCIpO1xuICBIb3N0RGV0ZWN0b3IyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcztcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX2IyKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSAoX2EzID0ge30sIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5IT1NUX05BTUVdID0gKDAsIGltcG9ydF9vczIuaG9zdG5hbWUpKCksIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5IT1NUX0FSQ0hdID0gdGhpcy5fbm9ybWFsaXplQXJjaCgoMCwgaW1wb3J0X29zMi5hcmNoKSgpKSwgX2EzKTtcbiAgICAgICAgcmV0dXJuIFsyLCBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcyldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIEhvc3REZXRlY3RvcjIucHJvdG90eXBlLl9ub3JtYWxpemVBcmNoID0gZnVuY3Rpb24obm9kZUFyY2hTdHJpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGVBcmNoU3RyaW5nKSB7XG4gICAgICBjYXNlIFwiYXJtXCI6XG4gICAgICAgIHJldHVybiBcImFybTMyXCI7XG4gICAgICBjYXNlIFwicHBjXCI6XG4gICAgICAgIHJldHVybiBcInBwYzMyXCI7XG4gICAgICBjYXNlIFwieDY0XCI6XG4gICAgICAgIHJldHVybiBcImFtZDY0XCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZUFyY2hTdHJpbmc7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSG9zdERldGVjdG9yMjtcbn0oKTtcbnZhciBob3N0RGV0ZWN0b3IgPSBuZXcgSG9zdERldGVjdG9yKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStyZXNvdXJjZXNAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvT1NEZXRlY3Rvci5qc1xudmFyIGltcG9ydF9vczMgPSByZXF1aXJlKFwib3NcIik7XG52YXIgX19hd2FpdGVyMiA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAzLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQMyA/IHZhbHVlIDogbmV3IFAzKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9fbmFtZShhZG9wdCwgXCJhZG9wdFwiKTtcbiAgcmV0dXJuIG5ldyAoUDMgfHwgKFAzID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmdWxmaWxsZWQsIFwiZnVsZmlsbGVkXCIpO1xuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlamVjdGVkLCBcInJlamVjdGVkXCIpO1xuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvcjIgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRbMF0gJiAxKVxuICAgICAgdGhyb3cgdFsxXTtcbiAgICByZXR1cm4gdFsxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBfX25hbWUodmVyYiwgXCJ2ZXJiXCIpO1xuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoXylcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgIHkgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgfVxuICAgIGlmIChvcFswXSAmIDUpXG4gICAgICB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG59O1xudmFyIE9TRGV0ZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gT1NEZXRlY3RvcjIoKSB7XG4gIH1cbiAgX19uYW1lKE9TRGV0ZWN0b3IyLCBcIk9TRGV0ZWN0b3JcIik7XG4gIE9TRGV0ZWN0b3IyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcjIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXM7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yMih0aGlzLCBmdW5jdGlvbihfYjIpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IChfYTMgPSB7fSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLk9TX1RZUEVdID0gdGhpcy5fbm9ybWFsaXplVHlwZSgoMCwgaW1wb3J0X29zMy5wbGF0Zm9ybSkoKSksIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5PU19WRVJTSU9OXSA9ICgwLCBpbXBvcnRfb3MzLnJlbGVhc2UpKCksIF9hMyk7XG4gICAgICAgIHJldHVybiBbMiwgbmV3IFJlc291cmNlKGF0dHJpYnV0ZXMpXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBPU0RldGVjdG9yMi5wcm90b3R5cGUuX25vcm1hbGl6ZVR5cGUgPSBmdW5jdGlvbihub2RlUGxhdGZvcm0pIHtcbiAgICBzd2l0Y2ggKG5vZGVQbGF0Zm9ybSkge1xuICAgICAgY2FzZSBcInN1bm9zXCI6XG4gICAgICAgIHJldHVybiBcInNvbGFyaXNcIjtcbiAgICAgIGNhc2UgXCJ3aW4zMlwiOlxuICAgICAgICByZXR1cm4gXCJ3aW5kb3dzXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZVBsYXRmb3JtO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9TRGV0ZWN0b3IyO1xufSgpO1xudmFyIG9zRGV0ZWN0b3IgPSBuZXcgT1NEZXRlY3RvcigpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9SZXNvdXJjZS5qc1xudmFyIFJlc291cmNlID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlc291cmNlMihhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuICBfX25hbWUoUmVzb3VyY2UyLCBcIlJlc291cmNlXCIpO1xuICBSZXNvdXJjZTIuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUmVzb3VyY2UyLkVNUFRZO1xuICB9O1xuICBSZXNvdXJjZTIuZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZTIoKF9hMyA9IHt9LCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuU0VSVklDRV9OQU1FXSA9IGRlZmF1bHRTZXJ2aWNlTmFtZSgpLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19MQU5HVUFHRV0gPSBTREtfSU5GT1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX0xBTkdVQUdFXSwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfTkFNRV0gPSBTREtfSU5GT1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX05BTUVdLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19WRVJTSU9OXSA9IFNES19JTkZPW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfVkVSU0lPTl0sIF9hMykpO1xuICB9O1xuICBSZXNvdXJjZTIucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIW90aGVyIHx8ICFPYmplY3Qua2V5cyhvdGhlci5hdHRyaWJ1dGVzKS5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB2YXIgbWVyZ2VkQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYXR0cmlidXRlcywgb3RoZXIuYXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZTIobWVyZ2VkQXR0cmlidXRlcyk7XG4gIH07XG4gIFJlc291cmNlMi5FTVBUWSA9IG5ldyBSZXNvdXJjZTIoe30pO1xuICByZXR1cm4gUmVzb3VyY2UyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvQnJvd3NlckRldGVjdG9yLmpzXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAzLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQMyA/IHZhbHVlIDogbmV3IFAzKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9fbmFtZShhZG9wdCwgXCJhZG9wdFwiKTtcbiAgcmV0dXJuIG5ldyAoUDMgfHwgKFAzID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmdWxmaWxsZWQsIFwiZnVsZmlsbGVkXCIpO1xuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlamVjdGVkLCBcInJlamVjdGVkXCIpO1xuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRbMF0gJiAxKVxuICAgICAgdGhyb3cgdFsxXTtcbiAgICByZXR1cm4gdFsxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBfX25hbWUodmVyYiwgXCJ2ZXJiXCIpO1xuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoXylcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgIHkgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgfVxuICAgIGlmIChvcFswXSAmIDUpXG4gICAgICB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG59O1xudmFyIEJyb3dzZXJEZXRlY3RvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBCcm93c2VyRGV0ZWN0b3IyKCkge1xuICB9XG4gIF9fbmFtZShCcm93c2VyRGV0ZWN0b3IyLCBcIkJyb3dzZXJEZXRlY3RvclwiKTtcbiAgQnJvd3NlckRldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oY29uZmlnMikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIzKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0Jyb3dzZXIsIGJyb3dzZXJSZXNvdXJjZTtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IzKHRoaXMsIGZ1bmN0aW9uKF9iMikge1xuICAgICAgICBpc0Jyb3dzZXIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgICAgIHJldHVybiBbMiwgUmVzb3VyY2UuZW1wdHkoKV07XG4gICAgICAgIH1cbiAgICAgICAgYnJvd3NlclJlc291cmNlID0gKF9hMyA9IHt9LCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX05BTUVdID0gXCJicm93c2VyXCIsIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX1JVTlRJTUVfREVTQ1JJUFRJT05dID0gXCJXZWIgQnJvd3NlclwiLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID0gbmF2aWdhdG9yLnVzZXJBZ2VudCwgX2EzKTtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLl9nZXRSZXNvdXJjZUF0dHJpYnV0ZXMoYnJvd3NlclJlc291cmNlLCBjb25maWcyKV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgQnJvd3NlckRldGVjdG9yMi5wcm90b3R5cGUuX2dldFJlc291cmNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGJyb3dzZXJSZXNvdXJjZSwgX2NvbmZpZykge1xuICAgIGlmIChicm93c2VyUmVzb3VyY2VbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID09PSBcIlwiKSB7XG4gICAgICBkaWFnMi5kZWJ1ZyhcIkJyb3dzZXJEZXRlY3RvciBmYWlsZWQ6IFVuYWJsZSB0byBmaW5kIHJlcXVpcmVkIGJyb3dzZXIgcmVzb3VyY2VzLiBcIik7XG4gICAgICByZXR1cm4gUmVzb3VyY2UuZW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZShfX2Fzc2lnbih7fSwgYnJvd3NlclJlc291cmNlKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQnJvd3NlckRldGVjdG9yMjtcbn0oKTtcbnZhciBicm93c2VyRGV0ZWN0b3IgPSBuZXcgQnJvd3NlckRldGVjdG9yKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStyZXNvdXJjZXNAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL2RldGVjdG9ycy9FbnZEZXRlY3Rvci5qc1xudmFyIF9fYXdhaXRlcjQgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQMywgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUDMgPyB2YWx1ZSA6IG5ldyBQMyhmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfX25hbWUoYWRvcHQsIFwiYWRvcHRcIik7XG4gIHJldHVybiBuZXcgKFAzIHx8IChQMyA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZnVsZmlsbGVkLCBcImZ1bGZpbGxlZFwiKTtcbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWplY3RlZCwgXCJyZWplY3RlZFwiKTtcbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3I0ID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0WzBdICYgMSlcbiAgICAgIHRocm93IHRbMV07XG4gICAgcmV0dXJuIHRbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgX19uYW1lKHZlcmIsIFwidmVyYlwiKTtcbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKF8pXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICB5ID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGYgPSB0ID0gMDtcbiAgICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBfX25hbWUoc3RlcCwgXCJzdGVwXCIpO1xufTtcbnZhciBfX3ZhbHVlczQgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkNSA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgZSA9IHsgZXJyb3I6IGVycm9yMiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG52YXIgRW52RGV0ZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRW52RGV0ZWN0b3IyKCkge1xuICAgIHRoaXMuX01BWF9MRU5HVEggPSAyNTU7XG4gICAgdGhpcy5fQ09NTUFfU0VQQVJBVE9SID0gXCIsXCI7XG4gICAgdGhpcy5fTEFCRUxfS0VZX1ZBTFVFX1NQTElUVEVSID0gXCI9XCI7XG4gICAgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX0NIQVJTID0gXCJzaG91bGQgYmUgYSBBU0NJSSBzdHJpbmcgd2l0aCBhIGxlbmd0aCBncmVhdGVyIHRoYW4gMCBhbmQgbm90IGV4Y2VlZCBcIiArIHRoaXMuX01BWF9MRU5HVEggKyBcIiBjaGFyYWN0ZXJzLlwiO1xuICAgIHRoaXMuX0VSUk9SX01FU1NBR0VfSU5WQUxJRF9WQUxVRSA9IFwic2hvdWxkIGJlIGEgQVNDSUkgc3RyaW5nIHdpdGggYSBsZW5ndGggbm90IGV4Y2VlZCBcIiArIHRoaXMuX01BWF9MRU5HVEggKyBcIiBjaGFyYWN0ZXJzLlwiO1xuICB9XG4gIF9fbmFtZShFbnZEZXRlY3RvcjIsIFwiRW52RGV0ZWN0b3JcIik7XG4gIEVudkRldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oX2NvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXI0KHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzLCBlbnYyLCByYXdBdHRyaWJ1dGVzLCBzZXJ2aWNlTmFtZSwgcGFyc2VkQXR0cmlidXRlcztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcjQodGhpcywgZnVuY3Rpb24oX2EzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZW52MiA9IGdldEVudigpO1xuICAgICAgICByYXdBdHRyaWJ1dGVzID0gZW52Mi5PVEVMX1JFU09VUkNFX0FUVFJJQlVURVM7XG4gICAgICAgIHNlcnZpY2VOYW1lID0gZW52Mi5PVEVMX1NFUlZJQ0VfTkFNRTtcbiAgICAgICAgaWYgKHJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IHRoaXMuX3BhcnNlUmVzb3VyY2VBdHRyaWJ1dGVzKHJhd0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBwYXJzZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkaWFnMi5kZWJ1ZyhcIkVudkRldGVjdG9yIGZhaWxlZDogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VydmljZU5hbWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlNFUlZJQ0VfTkFNRV0gPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzIsIG5ldyBSZXNvdXJjZShhdHRyaWJ1dGVzKV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgRW52RGV0ZWN0b3IyLnByb3RvdHlwZS5fcGFyc2VSZXNvdXJjZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihyYXdFbnZBdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGVfMSwgX2EzO1xuICAgIGlmICghcmF3RW52QXR0cmlidXRlcylcbiAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciByYXdBdHRyaWJ1dGVzID0gcmF3RW52QXR0cmlidXRlcy5zcGxpdCh0aGlzLl9DT01NQV9TRVBBUkFUT1IsIC0xKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgcmF3QXR0cmlidXRlc18xID0gX192YWx1ZXM0KHJhd0F0dHJpYnV0ZXMpLCByYXdBdHRyaWJ1dGVzXzFfMSA9IHJhd0F0dHJpYnV0ZXNfMS5uZXh0KCk7ICFyYXdBdHRyaWJ1dGVzXzFfMS5kb25lOyByYXdBdHRyaWJ1dGVzXzFfMSA9IHJhd0F0dHJpYnV0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHJhd0F0dHJpYnV0ZSA9IHJhd0F0dHJpYnV0ZXNfMV8xLnZhbHVlO1xuICAgICAgICB2YXIga2V5VmFsdWVQYWlyID0gcmF3QXR0cmlidXRlLnNwbGl0KHRoaXMuX0xBQkVMX0tFWV9WQUxVRV9TUExJVFRFUiwgLTEpO1xuICAgICAgICBpZiAoa2V5VmFsdWVQYWlyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYjIgPSBfX3JlYWQ1KGtleVZhbHVlUGFpciwgMiksIGtleSA9IF9iMlswXSwgdmFsdWUgPSBfYjJbMV07XG4gICAgICAgIGtleSA9IGtleS50cmltKCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpLnNwbGl0KCdeXCJ8XCIkJykuam9pbihcIlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkQW5kTm90RW1wdHkoa2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJpYnV0ZSBrZXkgXCIgKyB0aGlzLl9FUlJPUl9NRVNTQUdFX0lOVkFMSURfQ0hBUlMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUgdmFsdWUgXCIgKyB0aGlzLl9FUlJPUl9NRVNTQUdFX0lOVkFMSURfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmF3QXR0cmlidXRlc18xXzEgJiYgIXJhd0F0dHJpYnV0ZXNfMV8xLmRvbmUgJiYgKF9hMyA9IHJhd0F0dHJpYnV0ZXNfMS5yZXR1cm4pKVxuICAgICAgICAgIF9hMy5jYWxsKHJhd0F0dHJpYnV0ZXNfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH07XG4gIEVudkRldGVjdG9yMi5wcm90b3R5cGUuX2lzVmFsaWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUubGVuZ3RoIDw9IHRoaXMuX01BWF9MRU5HVEggJiYgdGhpcy5faXNQcmludGFibGVTdHJpbmcobmFtZSk7XG4gIH07XG4gIEVudkRldGVjdG9yMi5wcm90b3R5cGUuX2lzUHJpbnRhYmxlU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaCA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoY2ggPD0gXCIgXCIgfHwgY2ggPj0gXCJ+XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgRW52RGV0ZWN0b3IyLnByb3RvdHlwZS5faXNWYWxpZEFuZE5vdEVtcHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPiAwICYmIHRoaXMuX2lzVmFsaWQoc3RyKTtcbiAgfTtcbiAgcmV0dXJuIEVudkRldGVjdG9yMjtcbn0oKTtcbnZhciBlbnZEZXRlY3RvciA9IG5ldyBFbnZEZXRlY3RvcigpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvUHJvY2Vzc0RldGVjdG9yLmpzXG52YXIgX19hc3NpZ24yID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduMiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcylcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfX2Fzc2lnbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyNSA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAzLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQMyA/IHZhbHVlIDogbmV3IFAzKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9fbmFtZShhZG9wdCwgXCJhZG9wdFwiKTtcbiAgcmV0dXJuIG5ldyAoUDMgfHwgKFAzID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmdWxmaWxsZWQsIFwiZnVsZmlsbGVkXCIpO1xuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlamVjdGVkLCBcInJlamVjdGVkXCIpO1xuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgX19uYW1lKHN0ZXAsIFwic3RlcFwiKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvcjUgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRbMF0gJiAxKVxuICAgICAgdGhyb3cgdFsxXTtcbiAgICByZXR1cm4gdFsxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBfX25hbWUodmVyYiwgXCJ2ZXJiXCIpO1xuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoXylcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgIHkgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgfVxuICAgIGlmIChvcFswXSAmIDUpXG4gICAgICB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIF9fbmFtZShzdGVwLCBcInN0ZXBcIik7XG59O1xudmFyIFByb2Nlc3NEZXRlY3RvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBQcm9jZXNzRGV0ZWN0b3IyKCkge1xuICB9XG4gIF9fbmFtZShQcm9jZXNzRGV0ZWN0b3IyLCBcIlByb2Nlc3NEZXRlY3RvclwiKTtcbiAgUHJvY2Vzc0RldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oY29uZmlnMikge1xuICAgIHJldHVybiBfX2F3YWl0ZXI1KHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9jZXNzUmVzb3VyY2U7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yNSh0aGlzLCBmdW5jdGlvbihfYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFsyLCBSZXNvdXJjZS5lbXB0eSgpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzUmVzb3VyY2UgPSAoX2EzID0ge30sIF9hM1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX1BJRF0gPSBwcm9jZXNzLnBpZCwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfRVhFQ1VUQUJMRV9OQU1FXSA9IHByb2Nlc3MudGl0bGUgfHwgXCJcIiwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfQ09NTUFORF0gPSBwcm9jZXNzLmFyZ3ZbMV0gfHwgXCJcIiwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfQ09NTUFORF9MSU5FXSA9IHByb2Nlc3MuYXJndi5qb2luKFwiIFwiKSB8fCBcIlwiLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLCBfYTNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX05BTUVdID0gXCJub2RlanNcIiwgX2EzW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTl0gPSBcIk5vZGUuanNcIiwgX2EzKTtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLl9nZXRSZXNvdXJjZUF0dHJpYnV0ZXMocHJvY2Vzc1Jlc291cmNlLCBjb25maWcyKV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgUHJvY2Vzc0RldGVjdG9yMi5wcm90b3R5cGUuX2dldFJlc291cmNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHByb2Nlc3NSZXNvdXJjZSwgX2NvbmZpZykge1xuICAgIGlmIChwcm9jZXNzUmVzb3VyY2VbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19FWEVDVVRBQkxFX05BTUVdID09PSBcIlwiIHx8IHByb2Nlc3NSZXNvdXJjZVtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0VYRUNVVEFCTEVfUEFUSF0gPT09IFwiXCIgfHwgcHJvY2Vzc1Jlc291cmNlW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfQ09NTUFORF0gPT09IFwiXCIgfHwgcHJvY2Vzc1Jlc291cmNlW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfQ09NTUFORF9MSU5FXSA9PT0gXCJcIiB8fCBwcm9jZXNzUmVzb3VyY2VbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID09PSBcIlwiKSB7XG4gICAgICBkaWFnMi5kZWJ1ZyhcIlByb2Nlc3NEZXRlY3RvciBmYWlsZWQ6IFVuYWJsZSB0byBmaW5kIHJlcXVpcmVkIHByb2Nlc3MgcmVzb3VyY2VzLiBcIik7XG4gICAgICByZXR1cm4gUmVzb3VyY2UuZW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZShfX2Fzc2lnbjIoe30sIHByb2Nlc3NSZXNvdXJjZSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFByb2Nlc3NEZXRlY3RvcjI7XG59KCk7XG52YXIgcHJvY2Vzc0RldGVjdG9yID0gbmV3IFByb2Nlc3NEZXRlY3RvcigpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vTXVsdGlTcGFuUHJvY2Vzc29yLmpzXG52YXIgX192YWx1ZXM1ID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIE11bHRpU3BhblByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNdWx0aVNwYW5Qcm9jZXNzb3IyKF9zcGFuUHJvY2Vzc29ycykge1xuICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3JzID0gX3NwYW5Qcm9jZXNzb3JzO1xuICB9XG4gIF9fbmFtZShNdWx0aVNwYW5Qcm9jZXNzb3IyLCBcIk11bHRpU3BhblByb2Nlc3NvclwiKTtcbiAgTXVsdGlTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuZm9yY2VGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlXzEsIF9hMztcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXM1KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBzcGFuUHJvY2Vzc29yID0gX2MudmFsdWU7XG4gICAgICAgIHByb21pc2VzLnB1c2goc3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMyA9IF9iMi5yZXR1cm4pKVxuICAgICAgICAgIF9hMy5jYWxsKF9iMik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcjIpIHtcbiAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKGVycm9yMiB8fCBuZXcgRXJyb3IoXCJNdWx0aVNwYW5Qcm9jZXNzb3I6IGZvcmNlRmx1c2ggZmFpbGVkXCIpKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIE11bHRpU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbihzcGFuLCBjb250ZXh0Mykge1xuICAgIHZhciBlXzIsIF9hMztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXM1KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBzcGFuUHJvY2Vzc29yID0gX2MudmFsdWU7XG4gICAgICAgIHNwYW5Qcm9jZXNzb3Iub25TdGFydChzcGFuLCBjb250ZXh0Myk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EzID0gX2IyLnJldHVybikpXG4gICAgICAgICAgX2EzLmNhbGwoX2IyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzIpXG4gICAgICAgICAgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTXVsdGlTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgdmFyIGVfMywgX2EzO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfYjIgPSBfX3ZhbHVlczUodGhpcy5fc3BhblByb2Nlc3NvcnMpLCBfYyA9IF9iMi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iMi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHNwYW5Qcm9jZXNzb3IgPSBfYy52YWx1ZTtcbiAgICAgICAgc3BhblByb2Nlc3Nvci5vbkVuZChzcGFuKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgZV8zID0geyBlcnJvcjogZV8zXzEgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTMgPSBfYjIucmV0dXJuKSlcbiAgICAgICAgICBfYTMuY2FsbChfYjIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMylcbiAgICAgICAgICB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBNdWx0aVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlXzQsIF9hMztcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IyID0gX192YWx1ZXM1KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYjIubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYjIubmV4dCgpKSB7XG4gICAgICAgIHZhciBzcGFuUHJvY2Vzc29yID0gX2MudmFsdWU7XG4gICAgICAgIHByb21pc2VzLnB1c2goc3BhblByb2Nlc3Nvci5zaHV0ZG93bigpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgZV80ID0geyBlcnJvcjogZV80XzEgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTMgPSBfYjIucmV0dXJuKSlcbiAgICAgICAgICBfYTMuY2FsbChfYjIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfNClcbiAgICAgICAgICB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gTXVsdGlTcGFuUHJvY2Vzc29yMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9Ob29wU3BhblByb2Nlc3Nvci5qc1xudmFyIE5vb3BTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE5vb3BTcGFuUHJvY2Vzc29yMigpIHtcbiAgfVxuICBfX25hbWUoTm9vcFNwYW5Qcm9jZXNzb3IyLCBcIk5vb3BTcGFuUHJvY2Vzc29yXCIpO1xuICBOb29wU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbihfc3BhbiwgX2NvbnRleHQpIHtcbiAgfTtcbiAgTm9vcFNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKF9zcGFuKSB7XG4gIH07XG4gIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuZm9yY2VGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcmV0dXJuIE5vb3BTcGFuUHJvY2Vzc29yMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Nkay10cmFjZS1iYXNlQDEuNi4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjEuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL0Jhc2ljVHJhY2VyUHJvdmlkZXIuanNcbnZhciBGb3JjZUZsdXNoU3RhdGU7XG4oZnVuY3Rpb24oRm9yY2VGbHVzaFN0YXRlMikge1xuICBGb3JjZUZsdXNoU3RhdGUyW0ZvcmNlRmx1c2hTdGF0ZTJbXCJyZXNvbHZlZFwiXSA9IDBdID0gXCJyZXNvbHZlZFwiO1xuICBGb3JjZUZsdXNoU3RhdGUyW0ZvcmNlRmx1c2hTdGF0ZTJbXCJ0aW1lb3V0XCJdID0gMV0gPSBcInRpbWVvdXRcIjtcbiAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1wiZXJyb3JcIl0gPSAyXSA9IFwiZXJyb3JcIjtcbiAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1widW5yZXNvbHZlZFwiXSA9IDNdID0gXCJ1bnJlc29sdmVkXCI7XG59KShGb3JjZUZsdXNoU3RhdGUgfHwgKEZvcmNlRmx1c2hTdGF0ZSA9IHt9KSk7XG52YXIgQmFzaWNUcmFjZXJQcm92aWRlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBCYXNpY1RyYWNlclByb3ZpZGVyMihjb25maWcyKSB7XG4gICAgaWYgKGNvbmZpZzIgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnMiA9IHt9O1xuICAgIH1cbiAgICB2YXIgX2EzO1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRTcGFuUHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMuX3RyYWNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHZhciBtZXJnZWRDb25maWcgPSBtZXJnZSh7fSwgbG9hZERlZmF1bHRDb25maWcoKSwgcmVjb25maWd1cmVMaW1pdHMoY29uZmlnMikpO1xuICAgIHRoaXMucmVzb3VyY2UgPSAoX2EzID0gbWVyZ2VkQ29uZmlnLnJlc291cmNlKSAhPT0gbnVsbCAmJiBfYTMgIT09IHZvaWQgMCA/IF9hMyA6IFJlc291cmNlLmVtcHR5KCk7XG4gICAgdGhpcy5yZXNvdXJjZSA9IFJlc291cmNlLmRlZmF1bHQoKS5tZXJnZSh0aGlzLnJlc291cmNlKTtcbiAgICB0aGlzLl9jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBtZXJnZWRDb25maWcsIHtcbiAgICAgIHJlc291cmNlOiB0aGlzLnJlc291cmNlXG4gICAgfSk7XG4gICAgdmFyIGRlZmF1bHRFeHBvcnRlciA9IHRoaXMuX2J1aWxkRXhwb3J0ZXJGcm9tRW52KCk7XG4gICAgaWYgKGRlZmF1bHRFeHBvcnRlciAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgYmF0Y2hQcm9jZXNzb3IgPSBuZXcgQmF0Y2hTcGFuUHJvY2Vzc29yKGRlZmF1bHRFeHBvcnRlcik7XG4gICAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBiYXRjaFByb2Nlc3NvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yID0gbmV3IE5vb3BTcGFuUHJvY2Vzc29yKCk7XG4gICAgfVxuICB9XG4gIF9fbmFtZShCYXNpY1RyYWNlclByb3ZpZGVyMiwgXCJCYXNpY1RyYWNlclByb3ZpZGVyXCIpO1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuZ2V0VHJhY2VyID0gZnVuY3Rpb24obmFtZSwgdmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBuYW1lICsgXCJAXCIgKyAodmVyc2lvbiB8fCBcIlwiKSArIFwiOlwiICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NoZW1hVXJsKSB8fCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuX3RyYWNlcnMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMuX3RyYWNlcnMuc2V0KGtleSwgbmV3IFRyYWNlcih7IG5hbWUsIHZlcnNpb24sIHNjaGVtYVVybDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjaGVtYVVybCB9LCB0aGlzLl9jb25maWcsIHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNlcnMuZ2V0KGtleSk7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5hZGRTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oc3BhblByb2Nlc3Nvcikge1xuICAgIGlmICh0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3Iuc2h1dGRvd24oKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRpYWcyLmVycm9yKFwiRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHNodXRkb3duIGN1cnJlbnQgc3BhbiBwcm9jZXNzb3JcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMucHVzaChzcGFuUHJvY2Vzc29yKTtcbiAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBuZXcgTXVsdGlTcGFuUHJvY2Vzc29yKHRoaXMuX3JlZ2lzdGVyZWRTcGFuUHJvY2Vzc29ycyk7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU3BhblByb2Nlc3NvcjtcbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oY29uZmlnMikge1xuICAgIGlmIChjb25maWcyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbmZpZzIgPSB7fTtcbiAgICB9XG4gICAgdHJhY2Uuc2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIodGhpcyk7XG4gICAgaWYgKGNvbmZpZzIucHJvcGFnYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25maWcyLnByb3BhZ2F0b3IgPSB0aGlzLl9idWlsZFByb3BhZ2F0b3JGcm9tRW52KCk7XG4gICAgfVxuICAgIGlmIChjb25maWcyLmNvbnRleHRNYW5hZ2VyKSB7XG4gICAgICBjb250ZXh0Mi5zZXRHbG9iYWxDb250ZXh0TWFuYWdlcihjb25maWcyLmNvbnRleHRNYW5hZ2VyKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZzIucHJvcGFnYXRvcikge1xuICAgICAgcHJvcGFnYXRpb24uc2V0R2xvYmFsUHJvcGFnYXRvcihjb25maWcyLnByb3BhZ2F0b3IpO1xuICAgIH1cbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX2NvbmZpZy5mb3JjZUZsdXNoVGltZW91dE1pbGxpcztcbiAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMubWFwKGZ1bmN0aW9uKHNwYW5Qcm9jZXNzb3IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHZhciBzdGF0ZTtcbiAgICAgICAgdmFyIHRpbWVvdXRJbnRlcnZhbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgRXJyb3IoXCJTcGFuIHByb2Nlc3NvciBkaWQgbm90IGNvbXBsZXRlZCB3aXRoaW4gdGltZW91dCBwZXJpb2Qgb2YgXCIgKyB0aW1lb3V0ICsgXCIgbXNcIikpO1xuICAgICAgICAgIHN0YXRlID0gRm9yY2VGbHVzaFN0YXRlLnRpbWVvdXQ7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICBzcGFuUHJvY2Vzc29yLmZvcmNlRmx1c2goKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SW50ZXJ2YWwpO1xuICAgICAgICAgIGlmIChzdGF0ZSAhPT0gRm9yY2VGbHVzaFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRm9yY2VGbHVzaFN0YXRlLnJlc29sdmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcjIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEludGVydmFsKTtcbiAgICAgICAgICBzdGF0ZSA9IEZvcmNlRmx1c2hTdGF0ZS5lcnJvcjtcbiAgICAgICAgICByZXNvbHZlKGVycm9yMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gRm9yY2VGbHVzaFN0YXRlLnJlc29sdmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcjIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChbZXJyb3IyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU3BhblByb2Nlc3Nvci5zaHV0ZG93bigpO1xuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuX2dldFByb3BhZ2F0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIF9hMztcbiAgICByZXR1cm4gKF9hMyA9IHRoaXMuY29uc3RydWN0b3IuX3JlZ2lzdGVyZWRQcm9wYWdhdG9ycy5nZXQobmFtZSkpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzKCk7XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5fZ2V0U3BhbkV4cG9ydGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLmNvbnN0cnVjdG9yLl9yZWdpc3RlcmVkRXhwb3J0ZXJzLmdldChuYW1lKSkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMoKTtcbiAgfTtcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9idWlsZFByb3BhZ2F0b3JGcm9tRW52ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgdW5pcXVlUHJvcGFnYXRvck5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGdldEVudigpLk9URUxfUFJPUEFHQVRPUlMpKTtcbiAgICB2YXIgcHJvcGFnYXRvcnMgPSB1bmlxdWVQcm9wYWdhdG9yTmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wYWdhdG9yID0gX3RoaXMuX2dldFByb3BhZ2F0b3IobmFtZSk7XG4gICAgICBpZiAoIXByb3BhZ2F0b3IpIHtcbiAgICAgICAgZGlhZzIud2FybignUHJvcGFnYXRvciBcIicgKyBuYW1lICsgJ1wiIHJlcXVlc3RlZCB0aHJvdWdoIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BhZ2F0b3I7XG4gICAgfSk7XG4gICAgdmFyIHZhbGlkUHJvcGFnYXRvcnMgPSBwcm9wYWdhdG9ycy5yZWR1Y2UoZnVuY3Rpb24obGlzdCwgaXRlbSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuICAgIGlmICh2YWxpZFByb3BhZ2F0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodW5pcXVlUHJvcGFnYXRvck5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHZhbGlkUHJvcGFnYXRvcnNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlUHJvcGFnYXRvcih7XG4gICAgICAgIHByb3BhZ2F0b3JzOiB2YWxpZFByb3BhZ2F0b3JzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5fYnVpbGRFeHBvcnRlckZyb21FbnYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhwb3J0ZXJOYW1lID0gZ2V0RW52KCkuT1RFTF9UUkFDRVNfRVhQT1JURVI7XG4gICAgaWYgKGV4cG9ydGVyTmFtZSA9PT0gXCJub25lXCIpXG4gICAgICByZXR1cm47XG4gICAgdmFyIGV4cG9ydGVyID0gdGhpcy5fZ2V0U3BhbkV4cG9ydGVyKGV4cG9ydGVyTmFtZSk7XG4gICAgaWYgKCFleHBvcnRlcikge1xuICAgICAgZGlhZzIuZXJyb3IoJ0V4cG9ydGVyIFwiJyArIGV4cG9ydGVyTmFtZSArICdcIiByZXF1ZXN0ZWQgdGhyb3VnaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydGVyO1xuICB9O1xuICBCYXNpY1RyYWNlclByb3ZpZGVyMi5fcmVnaXN0ZXJlZFByb3BhZ2F0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcInRyYWNlY29udGV4dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcigpO1xuICAgIH1dLFxuICAgIFtcImJhZ2dhZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFczQ0JhZ2dhZ2VQcm9wYWdhdG9yKCk7XG4gICAgfV1cbiAgXSk7XG4gIEJhc2ljVHJhY2VyUHJvdmlkZXIyLl9yZWdpc3RlcmVkRXhwb3J0ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIEJhc2ljVHJhY2VyUHJvdmlkZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrc2RrLXRyYWNlLWJhc2VAMS42LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuMS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0NvbnNvbGVTcGFuRXhwb3J0ZXIuanNcbnZhciBfX3ZhbHVlczYgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgQ29uc29sZVNwYW5FeHBvcnRlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDb25zb2xlU3BhbkV4cG9ydGVyMigpIHtcbiAgfVxuICBfX25hbWUoQ29uc29sZVNwYW5FeHBvcnRlcjIsIFwiQ29uc29sZVNwYW5FeHBvcnRlclwiKTtcbiAgQ29uc29sZVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLmV4cG9ydCA9IGZ1bmN0aW9uKHNwYW5zLCByZXN1bHRDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9zZW5kU3BhbnMoc3BhbnMsIHJlc3VsdENhbGxiYWNrKTtcbiAgfTtcbiAgQ29uc29sZVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2VuZFNwYW5zKFtdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIENvbnNvbGVTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5fZXhwb3J0SW5mbyA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2VJZDogc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsXG4gICAgICBwYXJlbnRJZDogc3Bhbi5wYXJlbnRTcGFuSWQsXG4gICAgICBuYW1lOiBzcGFuLm5hbWUsXG4gICAgICBpZDogc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCxcbiAgICAgIGtpbmQ6IHNwYW4ua2luZCxcbiAgICAgIHRpbWVzdGFtcDogaHJUaW1lVG9NaWNyb3NlY29uZHMoc3Bhbi5zdGFydFRpbWUpLFxuICAgICAgZHVyYXRpb246IGhyVGltZVRvTWljcm9zZWNvbmRzKHNwYW4uZHVyYXRpb24pLFxuICAgICAgYXR0cmlidXRlczogc3Bhbi5hdHRyaWJ1dGVzLFxuICAgICAgc3RhdHVzOiBzcGFuLnN0YXR1cyxcbiAgICAgIGV2ZW50czogc3Bhbi5ldmVudHMsXG4gICAgICBsaW5rczogc3Bhbi5saW5rc1xuICAgIH07XG4gIH07XG4gIENvbnNvbGVTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5fc2VuZFNwYW5zID0gZnVuY3Rpb24oc3BhbnMsIGRvbmUpIHtcbiAgICB2YXIgZV8xLCBfYTM7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIHNwYW5zXzEgPSBfX3ZhbHVlczYoc3BhbnMpLCBzcGFuc18xXzEgPSBzcGFuc18xLm5leHQoKTsgIXNwYW5zXzFfMS5kb25lOyBzcGFuc18xXzEgPSBzcGFuc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zXzFfMS52YWx1ZTtcbiAgICAgICAgY29uc29sZS5kaXIodGhpcy5fZXhwb3J0SW5mbyhzcGFuKSwgeyBkZXB0aDogMyB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNwYW5zXzFfMSAmJiAhc3BhbnNfMV8xLmRvbmUgJiYgKF9hMyA9IHNwYW5zXzEucmV0dXJuKSlcbiAgICAgICAgICBfYTMuY2FsbChzcGFuc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIGRvbmUoeyBjb2RlOiBFeHBvcnRSZXN1bHRDb2RlLlNVQ0NFU1MgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQ29uc29sZVNwYW5FeHBvcnRlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvSW5NZW1vcnlTcGFuRXhwb3J0ZXIuanNcbnZhciBfX3JlYWQ2ID0gZnVuY3Rpb24obywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSlcbiAgICByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBlID0geyBlcnJvcjogZXJyb3IyIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSlcbiAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5NCA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgSW5NZW1vcnlTcGFuRXhwb3J0ZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gSW5NZW1vcnlTcGFuRXhwb3J0ZXIyKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gIH1cbiAgX19uYW1lKEluTWVtb3J5U3BhbkV4cG9ydGVyMiwgXCJJbk1lbW9yeVNwYW5FeHBvcnRlclwiKTtcbiAgSW5NZW1vcnlTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5leHBvcnQgPSBmdW5jdGlvbihzcGFucywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICh0aGlzLl9zdG9wcGVkKVxuICAgICAgcmV0dXJuIHJlc3VsdENhbGxiYWNrKHtcbiAgICAgICAgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5GQUlMRUQsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoXCJFeHBvcnRlciBoYXMgYmVlbiBzdG9wcGVkXCIpXG4gICAgICB9KTtcbiAgICAoX2EzID0gdGhpcy5fZmluaXNoZWRTcGFucykucHVzaC5hcHBseShfYTMsIF9fc3ByZWFkQXJyYXk0KFtdLCBfX3JlYWQ2KHNwYW5zKSwgZmFsc2UpKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdENhbGxiYWNrKHsgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTIH0pO1xuICAgIH0sIDApO1xuICB9O1xuICBJbk1lbW9yeVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFucyA9IFtdO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgSW5NZW1vcnlTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgfTtcbiAgSW5NZW1vcnlTcGFuRXhwb3J0ZXIyLnByb3RvdHlwZS5nZXRGaW5pc2hlZFNwYW5zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaGVkU3BhbnM7XG4gIH07XG4gIHJldHVybiBJbk1lbW9yeVNwYW5FeHBvcnRlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStzZGstdHJhY2UtYmFzZUAxLjYuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS4xLjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvU2ltcGxlU3BhblByb2Nlc3Nvci5qc1xudmFyIFNpbXBsZVNwYW5Qcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU2ltcGxlU3BhblByb2Nlc3NvcjIoX2V4cG9ydGVyKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIgPSBfZXhwb3J0ZXI7XG4gICAgdGhpcy5fc2h1dGRvd25PbmNlID0gbmV3IEJpbmRPbmNlRnV0dXJlKHRoaXMuX3NodXRkb3duLCB0aGlzKTtcbiAgfVxuICBfX25hbWUoU2ltcGxlU3BhblByb2Nlc3NvcjIsIFwiU2ltcGxlU3BhblByb2Nlc3NvclwiKTtcbiAgU2ltcGxlU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIFNpbXBsZVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oX3NwYW4sIF9wYXJlbnRDb250ZXh0KSB7XG4gIH07XG4gIFNpbXBsZVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9zaHV0ZG93bk9uY2UuaXNDYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dDIud2l0aChzdXBwcmVzc1RyYWNpbmcoY29udGV4dDIuYWN0aXZlKCkpLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9leHBvcnRlci5leHBvcnQoW3NwYW5dLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlICE9PSBFeHBvcnRSZXN1bHRDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICBnbG9iYWxFcnJvckhhbmRsZXIoKF9hMyA9IHJlc3VsdC5lcnJvcikgIT09IG51bGwgJiYgX2EzICE9PSB2b2lkIDAgPyBfYTMgOiBuZXcgRXJyb3IoXCJTaW1wbGVTcGFuUHJvY2Vzc29yOiBzcGFuIGV4cG9ydCBmYWlsZWQgKHN0YXR1cyBcIiArIHJlc3VsdCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBTaW1wbGVTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2h1dGRvd25PbmNlLmNhbGwoKTtcbiAgfTtcbiAgU2ltcGxlU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLl9zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBvcnRlci5zaHV0ZG93bigpO1xuICB9O1xuICByZXR1cm4gU2ltcGxlU3BhblByb2Nlc3NvcjI7XG59KCk7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy90cmFjaW5nL2NyZWF0ZVNwYW4udHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNwYW4oZW5naW5lU3BhbkV2ZW50KSB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCAwKSk7XG4gIGNvbnN0IHRyYWNlciA9IHRyYWNlLmdldFRyYWNlcihcInByaXNtYVwiKTtcbiAgZW5naW5lU3BhbkV2ZW50LnNwYW5zLmZvckVhY2goKGVuZ2luZVNwYW4pID0+IHtcbiAgICB2YXIgX2EzO1xuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0ge1xuICAgICAgdHJhY2VJZDogZW5naW5lU3Bhbi50cmFjZV9pZCxcbiAgICAgIHNwYW5JZDogZW5naW5lU3Bhbi5zcGFuX2lkLFxuICAgICAgdHJhY2VGbGFnczogVHJhY2VGbGFncy5TQU1QTEVEXG4gICAgfTtcbiAgICBjb25zdCBsaW5rcyA9IChfYTMgPSBlbmdpbmVTcGFuLmxpbmtzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1hcCgobGluaykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIHRyYWNlSWQ6IGxpbmsudHJhY2VfaWQsXG4gICAgICAgICAgc3BhbklkOiBsaW5rLnNwYW5faWQsXG4gICAgICAgICAgdHJhY2VGbGFnczogVHJhY2VGbGFncy5TQU1QTEVEXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3BhbiA9IG5ldyBTcGFuKFxuICAgICAgdHJhY2VyLFxuICAgICAgUk9PVF9DT05URVhULFxuICAgICAgZW5naW5lU3Bhbi5uYW1lLFxuICAgICAgc3BhbkNvbnRleHQsXG4gICAgICBTcGFuS2luZC5JTlRFUk5BTCxcbiAgICAgIGVuZ2luZVNwYW4ucGFyZW50X3NwYW5faWQsXG4gICAgICBsaW5rcyxcbiAgICAgIGVuZ2luZVNwYW4uc3RhcnRfdGltZVxuICAgICk7XG4gICAgaWYgKGVuZ2luZVNwYW4uYXR0cmlidXRlcykge1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGVuZ2luZVNwYW4uYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHNwYW4uZW5kKGVuZ2luZVNwYW4uZW5kX3RpbWUpO1xuICB9KTtcbn1cbl9fbmFtZShjcmVhdGVTcGFuLCBcImNyZWF0ZVNwYW5cIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy90cmFjaW5nL2dldFRyYWNlUGFyZW50LnRzXG5mdW5jdGlvbiBnZXRUcmFjZVBhcmVudCh7XG4gIGNvbnRleHQ6IGNvbnRleHQzLFxuICB0cmFjaW5nQ29uZmlnXG59KSB7XG4gIGNvbnN0IHNwYW4gPSB0cmFjZS5nZXRTcGFuQ29udGV4dChjb250ZXh0MyAhPSBudWxsID8gY29udGV4dDMgOiBjb250ZXh0Mi5hY3RpdmUoKSk7XG4gIGlmICgodHJhY2luZ0NvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogdHJhY2luZ0NvbmZpZy5lbmFibGVkKSAmJiAoc3BhbiA9PSBudWxsID8gdm9pZCAwIDogc3Bhbi50cmFjZUZsYWdzKSA9PT0gMSkge1xuICAgIHJldHVybiBgMDAtJHtzcGFuLnRyYWNlSWR9LSR7c3Bhbi5zcGFuSWR9LTAxYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYDAwLTAwLTAwLTAwYDtcbiAgfVxufVxuX19uYW1lKGdldFRyYWNlUGFyZW50LCBcImdldFRyYWNlUGFyZW50XCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvdHJhY2luZy9nZXRUcmFjaW5nQ29uZmlnLnRzXG5mdW5jdGlvbiBnZXRUcmFjaW5nQ29uZmlnKHByZXZpZXdGZWF0dXJlcykge1xuICBjb25zdCBoYXNUcmFjaW5nUHJldmlld0ZlYXR1cmVGbGFnRW5hYmxlZCA9IHByZXZpZXdGZWF0dXJlcy5pbmNsdWRlcyhcInRyYWNpbmdcIik7XG4gIHJldHVybiB7XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihnbG9iYWxUaGlzLlBSSVNNQV9JTlNUUlVNRU5UQVRJT04gJiYgaGFzVHJhY2luZ1ByZXZpZXdGZWF0dXJlRmxhZ0VuYWJsZWQpO1xuICAgIH0sXG4gICAgZ2V0IG1pZGRsZXdhcmUoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihnbG9iYWxUaGlzLlBSSVNNQV9JTlNUUlVNRU5UQVRJT04gJiYgZ2xvYmFsVGhpcy5QUklTTUFfSU5TVFJVTUVOVEFUSU9OLm1pZGRsZXdhcmUpO1xuICAgIH1cbiAgfTtcbn1cbl9fbmFtZShnZXRUcmFjaW5nQ29uZmlnLCBcImdldFRyYWNpbmdDb25maWdcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy90cmFjaW5nL3J1bkluQ2hpbGRTcGFuLnRzXG5hc3luYyBmdW5jdGlvbiBydW5JbkNoaWxkU3BhbihvcHRpb25zLCBjYikge1xuICB2YXIgX2EzO1xuICBpZiAob3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSlcbiAgICByZXR1cm4gY2IoKTtcbiAgY29uc3QgdHJhY2VyID0gdHJhY2UuZ2V0VHJhY2VyKFwicHJpc21hXCIpO1xuICBjb25zdCBjb250ZXh0MyA9IChfYTMgPSBvcHRpb25zLmNvbnRleHQpICE9IG51bGwgPyBfYTMgOiBjb250ZXh0Mi5hY3RpdmUoKTtcbiAgaWYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSkge1xuICAgIGNvbnN0IHNwYW4gPSB0cmFjZXIuc3RhcnRTcGFuKGBwcmlzbWE6Y2xpZW50OiR7b3B0aW9ucy5uYW1lfWAsIG9wdGlvbnMsIGNvbnRleHQzKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGNiKHNwYW4sIGNvbnRleHQzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc3Bhbi5lbmQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4oYHByaXNtYTpjbGllbnQ6JHtvcHRpb25zLm5hbWV9YCwgb3B0aW9ucywgY29udGV4dDMsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYihzcGFuLCBjb250ZXh0Mi5hY3RpdmUoKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNwYW4uZW5kKCk7XG4gICAgfVxuICB9KTtcbn1cbl9fbmFtZShydW5JbkNoaWxkU3BhbiwgXCJydW5JbkNoaWxkU3BhblwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2JpbmFyeS9Db25uZWN0aW9uLnRzXG52YXIgaW1wb3J0X2dldF9zdHJlYW0gPSBfX3RvRVNNKHJlcXVpcmVfZ2V0X3N0cmVhbSgpKTtcbnZhciB1bmRpY2kgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHJlcXVpcmVfdW5kaWNpKCksIFwidW5kaWNpXCIpO1xuZnVuY3Rpb24gYXNzZXJ0SGFzUG9vbChwb29sKSB7XG4gIGlmIChwb29sID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGhhcyBub3QgYmVlbiBvcGVuZWRcIik7XG4gIH1cbn1cbl9fbmFtZShhc3NlcnRIYXNQb29sLCBcImFzc2VydEhhc1Bvb2xcIik7XG52YXIgQ29ubmVjdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG9uSHR0cEVycm9yKHJlc3BvbnNlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgX3Jlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2U7XG4gICAgaWYgKF9yZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIoX3Jlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXNwb25zZTtcbiAgfVxuICBvcGVuKHVybCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9wb29sKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3Bvb2wgPSBuZXcgKHVuZGljaSgpKS5Qb29sKHVybCwge1xuICAgICAgY29ubmVjdGlvbnM6IDFlMyxcbiAgICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQ6IDZlNSxcbiAgICAgIGhlYWRlcnNUaW1lb3V0OiAwLFxuICAgICAgYm9keVRpbWVvdXQ6IDAsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmF3KG1ldGhvZCwgZW5kcG9pbnQsIGhlYWRlcnMsIGJvZHksIHBhcnNlUmVzcG9uc2UgPSB0cnVlKSB7XG4gICAgYXNzZXJ0SGFzUG9vbCh0aGlzLl9wb29sKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Bvb2wucmVxdWVzdCh7XG4gICAgICBwYXRoOiBlbmRwb2ludCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBib2R5XG4gICAgfSk7XG4gICAgY29uc3QgYm9keVN0cmluZyA9IGF3YWl0ICgwLCBpbXBvcnRfZ2V0X3N0cmVhbS5kZWZhdWx0KShyZXNwb25zZS5ib2R5KTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBkYXRhOiBwYXJzZVJlc3BvbnNlID8gSlNPTi5wYXJzZShib2R5U3RyaW5nKSA6IGJvZHlTdHJpbmdcbiAgICB9O1xuICB9XG4gIHBvc3QoZW5kcG9pbnQsIGJvZHksIGhlYWRlcnMsIHBhcnNlUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gdGhpcy5yYXcoXCJQT1NUXCIsIGVuZHBvaW50LCBoZWFkZXJzLCBib2R5LCBwYXJzZVJlc3BvbnNlKTtcbiAgfVxuICBnZXQocGF0aDcsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yYXcoXCJHRVRcIiwgcGF0aDcsIGhlYWRlcnMpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICB0aGlzLl9wb29sLmNsb3NlKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9wb29sID0gdm9pZCAwO1xuICB9XG59O1xuX19uYW1lKENvbm5lY3Rpb24sIFwiQ29ubmVjdGlvblwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2JpbmFyeS9CaW5hcnlFbmdpbmUudHNcbnZhciBkZWJ1ZzQgPSBzcmNfZGVmYXVsdChcInByaXNtYTplbmdpbmVcIik7XG52YXIgZXhpc3RzMiA9ICgwLCBpbXBvcnRfdXRpbDQucHJvbWlzaWZ5KShpbXBvcnRfZnM0LmRlZmF1bHQuZXhpc3RzKTtcbnZhciBsb2dnZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCguLi5hcmdzKSA9PiB7XG59LCBcImxvZ2dlclwiKTtcbnZhciBrbm93blBsYXRmb3JtcyA9IFsuLi5wbGF0Zm9ybXMsIFwibmF0aXZlXCJdO1xudmFyIGVuZ2luZXMgPSBbXTtcbnZhciBzb2NrZXRQYXRocyA9IFtdO1xudmFyIE1BWF9TVEFSVFMgPSBwcm9jZXNzLmVudi5QUklTTUFfQ0xJRU5UX05PX1JFVFJZID8gMSA6IDI7XG52YXIgTUFYX1JFUVVFU1RfUkVUUklFUyA9IHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfTk9fUkVUUlkgPyAxIDogMjtcbnZhciBCaW5hcnlFbmdpbmUgPSBjbGFzcyBleHRlbmRzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjd2QsXG4gICAgZGF0YW1vZGVsUGF0aCxcbiAgICBwcmlzbWFQYXRoLFxuICAgIGdlbmVyYXRvcixcbiAgICBkYXRhc291cmNlcyxcbiAgICBzaG93Q29sb3JzLFxuICAgIGxvZ0xldmVsLFxuICAgIGxvZ1F1ZXJpZXMsXG4gICAgZW52OiBlbnYyLFxuICAgIGZsYWdzLFxuICAgIGNsaWVudFZlcnNpb246IGNsaWVudFZlcnNpb24yLFxuICAgIHByZXZpZXdGZWF0dXJlcyxcbiAgICBlbmdpbmVFbmRwb2ludCxcbiAgICBlbmFibGVEZWJ1Z0xvZ3MsXG4gICAgYWxsb3dUcmlnZ2VyUGFuaWMsXG4gICAgZGlybmFtZTogZGlybmFtZTIsXG4gICAgYWN0aXZlUHJvdmlkZXIsXG4gICAgdHJhY2luZ0NvbmZpZ1xuICB9KSB7XG4gICAgdmFyIF9hMztcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RhcnRDb3VudCA9IDA7XG4gICAgdGhpcy5wcmV2aWV3RmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLnN0ZGVyckxvZ3MgPSBcIlwiO1xuICAgIHRoaXMuaGFuZGxlUmVxdWVzdEVycm9yID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoZXJyb3IyLCBncmFjZWZ1bCA9IGZhbHNlKSA9PiB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICBkZWJ1ZzQoeyBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgaWYgKHRoaXMuc3RhcnRQcm9taXNlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhcnRQcm9taXNlO1xuICAgICAgfVxuICAgICAgdGhpcy50aHJvd0FzeW5jRXJyb3JJZkV4aXN0cygpO1xuICAgICAgaWYgKChfYTMgPSB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5pc0NhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMudGhyb3dBc3luY0Vycm9ySWZFeGlzdHMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IyLmNvZGUgPT09IFwiRUNPTk5SRVNFVFwiIHx8IGVycm9yMi5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiIHx8IGVycm9yMi5jb2RlID09PSBcIlVORF9FUlJfQ0xPU0VEXCIgfHwgZXJyb3IyLmNvZGUgPT09IFwiVU5EX0VSUl9TT0NLRVRcIiB8fCBlcnJvcjIuY29kZSA9PT0gXCJVTkRfRVJSX0RFU1RST1lFRFwiIHx8IGVycm9yMi5jb2RlID09PSBcIlVORF9FUlJfQUJPUlRFRFwiIHx8IGVycm9yMi5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJjbGllbnQgaXMgZGVzdHJveWVkXCIpIHx8IGVycm9yMi5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJvdGhlciBzaWRlIGNsb3NlZFwiKSB8fCBlcnJvcjIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidGhlIGNsaWVudCBpcyBjbG9zZWRcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsS2lsbFNpZ25hbFJlY2VpdmVkICYmICEoKF9iMiA9IHRoaXMuY2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY29ubmVjdGVkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKFxuICAgICAgICAgICAgYFRoZSBOb2RlLmpzIHByb2Nlc3MgYWxyZWFkeSByZWNlaXZlZCBhICR7dGhpcy5nbG9iYWxLaWxsU2lnbmFsUmVjZWl2ZWR9IHNpZ25hbCwgdGhlcmVmb3JlIHRoZSBQcmlzbWEgcXVlcnkgZW5naW5lIGV4aXRlZFxuYW5kIHlvdXIgcmVxdWVzdCBjYW4ndCBiZSBwcm9jZXNzZWQuXG5Zb3UgcHJvYmFibHkgaGF2ZSBzb21lIG9wZW4gaGFuZGxlIHRoYXQgcHJldmVudHMgeW91ciBwcm9jZXNzIGZyb20gZXhpdGluZy5cbkl0IGNvdWxkIGJlIGFuIG9wZW4gaHR0cCBzZXJ2ZXIgb3Igc3RyZWFtIHRoYXQgZGlkbid0IGNsb3NlIHlldC5cbldlIHJlY29tbWVuZCB1c2luZyB0aGUgXFxgd3Rmbm9kZVxcYCBwYWNrYWdlIHRvIGRlYnVnIG9wZW4gaGFuZGxlcy5gLFxuICAgICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXN5bmNFcnJvcklmRXhpc3RzKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Q291bnQgPiBNQVhfU1RBUlRTKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDUwKSk7XG4gICAgICAgICAgICB0aGlzLnRocm93QXN5bmNFcnJvcklmRXhpc3RzKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXJ5IGVuZ2luZSBpcyB0cnlpbmcgdG8gcmVzdGFydCwgYnV0IGNhbid0LlxuUGxlYXNlIGxvb2sgaW50byB0aGUgbG9ncyBvciB0dXJuIG9uIHRoZSBlbnYgdmFyIERFQlVHPSogdG8gZGVidWcgdGhlIGNvbnN0YW50bHkgcmVzdGFydGluZyBxdWVyeSBlbmdpbmUuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZ3JhY2VmdWwpIHtcbiAgICAgICAgdGhpcy50aHJvd0FzeW5jRXJyb3JJZkV4aXN0cyh0cnVlKTtcbiAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFwiaGFuZGxlUmVxdWVzdEVycm9yXCIpO1xuICAgIHRoaXMuZGlybmFtZSA9IGRpcm5hbWUyO1xuICAgIHRoaXMuZW52ID0gZW52MjtcbiAgICB0aGlzLmN3ZCA9IHRoaXMucmVzb2x2ZUN3ZChjd2QpO1xuICAgIHRoaXMuZW5hYmxlRGVidWdMb2dzID0gZW5hYmxlRGVidWdMb2dzICE9IG51bGwgPyBlbmFibGVEZWJ1Z0xvZ3MgOiBmYWxzZTtcbiAgICB0aGlzLmFsbG93VHJpZ2dlclBhbmljID0gYWxsb3dUcmlnZ2VyUGFuaWMgIT0gbnVsbCA/IGFsbG93VHJpZ2dlclBhbmljIDogZmFsc2U7XG4gICAgdGhpcy5kYXRhbW9kZWxQYXRoID0gZGF0YW1vZGVsUGF0aDtcbiAgICB0aGlzLnByaXNtYVBhdGggPSAoX2EzID0gcHJvY2Vzcy5lbnYuUFJJU01BX1FVRVJZX0VOR0lORV9CSU5BUlkpICE9IG51bGwgPyBfYTMgOiBwcmlzbWFQYXRoO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMuZGF0YXNvdXJjZXMgPSBkYXRhc291cmNlcztcbiAgICB0aGlzLnRyYWNpbmdDb25maWcgPSB0cmFjaW5nQ29uZmlnO1xuICAgIHRoaXMubG9nRW1pdHRlciA9IG5ldyBpbXBvcnRfZXZlbnRzLmRlZmF1bHQoKTtcbiAgICB0aGlzLmxvZ0VtaXR0ZXIub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgfSk7XG4gICAgdGhpcy5zaG93Q29sb3JzID0gc2hvd0NvbG9ycyAhPSBudWxsID8gc2hvd0NvbG9ycyA6IGZhbHNlO1xuICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbDtcbiAgICB0aGlzLmxvZ1F1ZXJpZXMgPSBsb2dRdWVyaWVzICE9IG51bGwgPyBsb2dRdWVyaWVzIDogZmFsc2U7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzICE9IG51bGwgPyBmbGFncyA6IFtdO1xuICAgIHRoaXMucHJldmlld0ZlYXR1cmVzID0gcHJldmlld0ZlYXR1cmVzICE9IG51bGwgPyBwcmV2aWV3RmVhdHVyZXMgOiBbXTtcbiAgICB0aGlzLmFjdGl2ZVByb3ZpZGVyID0gYWN0aXZlUHJvdmlkZXI7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oKTtcbiAgICBpbml0SG9va3MoKTtcbiAgICBjb25zdCByZW1vdmVkRmxhZ3MgPSBbXG4gICAgICBcIm1pZGRsZXdhcmVzXCIsXG4gICAgICBcImFnZ3JlZ2F0ZUFwaVwiLFxuICAgICAgXCJkaXN0aW5jdFwiLFxuICAgICAgXCJhZ2dyZWdhdGlvbnNcIixcbiAgICAgIFwiaW5zZW5zaXRpdmVGaWx0ZXJzXCIsXG4gICAgICBcImF0b21pY051bWJlck9wZXJhdGlvbnNcIixcbiAgICAgIFwidHJhbnNhY3Rpb25BcGlcIixcbiAgICAgIFwidHJhbnNhY3Rpb25cIixcbiAgICAgIFwiY29ubmVjdE9yQ3JlYXRlXCIsXG4gICAgICBcInVuY2hlY2tlZFNjYWxhcklucHV0c1wiLFxuICAgICAgXCJuYXRpdmVUeXBlc1wiLFxuICAgICAgXCJjcmVhdGVNYW55XCIsXG4gICAgICBcImdyb3VwQnlcIixcbiAgICAgIFwicmVmZXJlbnRpYWxBY3Rpb25zXCIsXG4gICAgICBcIm1pY3Jvc29mdFNxbFNlcnZlclwiXG4gICAgXTtcbiAgICBjb25zdCByZW1vdmVkRmxhZ3NVc2VkID0gdGhpcy5wcmV2aWV3RmVhdHVyZXMuZmlsdGVyKChlKSA9PiByZW1vdmVkRmxhZ3MuaW5jbHVkZXMoZSkpO1xuICAgIGlmIChyZW1vdmVkRmxhZ3NVc2VkLmxlbmd0aCA+IDAgJiYgIXByb2Nlc3MuZW52LlBSSVNNQV9ISURFX1BSRVZJRVdfRkxBR19XQVJOSU5HUykge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ibHVlQnJpZ2h0KFwiaW5mb1wiKX0gVGhlIHByZXZpZXcgZmxhZ3MgXFxgJHtyZW1vdmVkRmxhZ3NVc2VkLmpvaW4oXG4gICAgICAgICAgXCJgLCBgXCJcbiAgICAgICAgKX1cXGAgd2VyZSByZW1vdmVkLCB5b3UgY2FuIG5vdyBzYWZlbHkgcmVtb3ZlIHRoZW0gZnJvbSB5b3VyIHNjaGVtYS5wcmlzbWEuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wcmV2aWV3RmVhdHVyZXMgPSB0aGlzLnByZXZpZXdGZWF0dXJlcy5maWx0ZXIoKGUpID0+ICFyZW1vdmVkRmxhZ3MuaW5jbHVkZXMoZSkpO1xuICAgIHRoaXMuZW5naW5lRW5kcG9pbnQgPSBlbmdpbmVFbmRwb2ludDtcbiAgICBpZiAoZW5naW5lRW5kcG9pbnQpIHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBpbXBvcnRfdXJsLlVSTChlbmdpbmVFbmRwb2ludCk7XG4gICAgICB0aGlzLnBvcnQgPSBOdW1iZXIodXJsLnBvcnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wbGF0Zm9ybSkge1xuICAgICAgaWYgKCFrbm93blBsYXRmb3Jtcy5pbmNsdWRlcyh0aGlzLnBsYXRmb3JtKSAmJiAhaW1wb3J0X2ZzNC5kZWZhdWx0LmV4aXN0c1N5bmModGhpcy5wbGF0Zm9ybSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgICAgYFVua25vd24gJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQucmVkKFwiUFJJU01BX1FVRVJZX0VOR0lORV9CSU5BUllcIil9ICR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnJlZEJyaWdodC5ib2xkKFxuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybVxuICAgICAgICAgICl9LiBQb3NzaWJsZSBiaW5hcnlUYXJnZXRzOiAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ncmVlbkJyaWdodChcbiAgICAgICAgICAgIGtub3duUGxhdGZvcm1zLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICl9IG9yIGEgcGF0aCB0byB0aGUgcXVlcnkgZW5naW5lIGJpbmFyeS5cbllvdSBtYXkgaGF2ZSB0byBydW4gJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJwcmlzbWEgZ2VuZXJhdGVcIil9IGZvciB5b3VyIGNoYW5nZXMgdG8gdGFrZSBlZmZlY3QuYCxcbiAgICAgICAgICB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCB0aGlzLmdldFBsYXRmb3JtKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuYWJsZURlYnVnTG9ncykge1xuICAgICAgc3JjX2RlZmF1bHQuZW5hYmxlKFwiKlwiKTtcbiAgICB9XG4gICAgZW5naW5lcy5wdXNoKHRoaXMpO1xuICAgIHRoaXMuY2hlY2tGb3JUb29NYW55RW5naW5lcygpO1xuICB9XG4gIHNldEVycm9yKGVycikge1xuICAgIHZhciBfYTM7XG4gICAgaWYgKGlzUnVzdEVycm9yKGVycikpIHtcbiAgICAgIHRoaXMubGFzdFJ1c3RFcnJvciA9IGVycjtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIG5ldyBQcmlzbWFDbGllbnRSdXN0RXJyb3Ioe1xuICAgICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvbixcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKGVyci5pc19wYW5pYykge1xuICAgICAgICB0aGlzLmhhbmRsZVBhbmljKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1J1c3RFcnJvckxvZyhlcnIpKSB7XG4gICAgICB0aGlzLmxhc3RFcnJvckxvZyA9IGVycjtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIG5ldyBQcmlzbWFDbGllbnRSdXN0RXJyb3Ioe1xuICAgICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvbixcbiAgICAgICAgICBsb2c6IGVyclxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmICgoKF9hMyA9IGVyci5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubWVzc2FnZSkgPT09IFwiUEFOSUNcIikge1xuICAgICAgICB0aGlzLmhhbmRsZVBhbmljKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tGb3JUb29NYW55RW5naW5lcygpIHtcbiAgICBpZiAoZW5naW5lcy5sZW5ndGggPj0gMTApIHtcbiAgICAgIGNvbnN0IHJ1bm5pbmdFbmdpbmVzID0gZW5naW5lcy5maWx0ZXIoKGUpID0+IGUuY2hpbGQpO1xuICAgICAgaWYgKHJ1bm5pbmdFbmdpbmVzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC55ZWxsb3coXCJ3YXJuKHByaXNtYS1jbGllbnQpXCIpfSBUaGVyZSBhcmUgYWxyZWFkeSAxMCBpbnN0YW5jZXMgb2YgUHJpc21hIENsaWVudCBhY3RpdmVseSBydW5uaW5nLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUN3ZChjd2QpIHtcbiAgICBpZiAoY3dkICYmIGltcG9ydF9mczQuZGVmYXVsdC5leGlzdHNTeW5jKGN3ZCkgJiYgaW1wb3J0X2ZzNC5kZWZhdWx0LmxzdGF0U3luYyhjd2QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiBjd2Q7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmN3ZCgpO1xuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChldmVudCA9PT0gXCJiZWZvcmVFeGl0XCIpIHtcbiAgICAgIHRoaXMuYmVmb3JlRXhpdExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBlbWl0RXhpdCgpIHtcbiAgICBpZiAodGhpcy5iZWZvcmVFeGl0TGlzdGVuZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlRXhpdExpc3RlbmVyKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFBsYXRmb3JtKCkge1xuICAgIGlmICh0aGlzLnBsYXRmb3JtUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGxhdGZvcm1Qcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnBsYXRmb3JtUHJvbWlzZSA9IGdldFBsYXRmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXMucGxhdGZvcm1Qcm9taXNlO1xuICB9XG4gIGdldFF1ZXJ5RW5naW5lUGF0aChwbGF0Zm9ybTMsIHByZWZpeCA9IF9fZGlybmFtZSkge1xuICAgIGxldCBxdWVyeUVuZ2luZVBhdGggPSBpbXBvcnRfcGF0aDIuZGVmYXVsdC5qb2luKHByZWZpeCwgYHF1ZXJ5LWVuZ2luZS0ke3BsYXRmb3JtM31gKTtcbiAgICBpZiAocGxhdGZvcm0zID09PSBcIndpbmRvd3NcIikge1xuICAgICAgcXVlcnlFbmdpbmVQYXRoID0gYCR7cXVlcnlFbmdpbmVQYXRofS5leGVgO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlFbmdpbmVQYXRoO1xuICB9XG4gIGhhbmRsZVBhbmljKCkge1xuICAgIHZhciBfYTM7XG4gICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgIHRoaXMuc3RvcFByb21pc2UgPSBraWxsUHJvY2Vzc0FuZFdhaXQodGhpcy5jaGlsZCk7XG4gICAgfVxuICAgIGlmICgoX2EzID0gdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FuY2VsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzb2x2ZVByaXNtYVBhdGgoKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYztcbiAgICBjb25zdCBzZWFyY2hlZExvY2F0aW9ucyA9IFtdO1xuICAgIGxldCBlbmdpbmVQYXRoO1xuICAgIGlmICh0aGlzLnByaXNtYVBhdGgpIHtcbiAgICAgIHJldHVybiB7IHByaXNtYVBhdGg6IHRoaXMucHJpc21hUGF0aCwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCB0aGlzLmdldFBsYXRmb3JtKCk7XG4gICAgaWYgKHRoaXMucGxhdGZvcm0gJiYgdGhpcy5wbGF0Zm9ybSAhPT0gcGxhdGZvcm0pIHtcbiAgICAgIHRoaXMuaW5jb3JyZWN0bHlQaW5uZWRCaW5hcnlUYXJnZXQgPSB0aGlzLnBsYXRmb3JtO1xuICAgIH1cbiAgICB0aGlzLnBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybSB8fCBwbGF0Zm9ybTtcbiAgICBpZiAoX19maWxlbmFtZS5pbmNsdWRlcyhcIkJpbmFyeUVuZ2luZVwiKSkge1xuICAgICAgZW5naW5lUGF0aCA9IHRoaXMuZ2V0UXVlcnlFbmdpbmVQYXRoKHRoaXMucGxhdGZvcm0sIGdldEVuZ2luZXNQYXRoKCkpO1xuICAgICAgcmV0dXJuIHsgcHJpc21hUGF0aDogZW5naW5lUGF0aCwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoTG9jYXRpb25zID0gW1xuICAgICAgZXZhbChgcmVxdWlyZSgncGF0aCcpLmpvaW4oX19kaXJuYW1lLCAnLi4vLi4vLi4vLnByaXNtYS9jbGllbnQnKWApLFxuICAgICAgKF9jID0gKF9iMiA9IChfYTMgPSB0aGlzLmdlbmVyYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIudmFsdWUpICE9IG51bGwgPyBfYyA6IGV2YWwoXCJfX2Rpcm5hbWVcIiksXG4gICAgICBpbXBvcnRfcGF0aDIuZGVmYXVsdC5qb2luKGV2YWwoXCJfX2Rpcm5hbWVcIiksIFwiLi5cIiksXG4gICAgICBpbXBvcnRfcGF0aDIuZGVmYXVsdC5kaXJuYW1lKHRoaXMuZGF0YW1vZGVsUGF0aCksXG4gICAgICB0aGlzLmN3ZCxcbiAgICAgIFwiL3RtcC9wcmlzbWEtZW5naW5lc1wiXG4gICAgXTtcbiAgICBpZiAodGhpcy5kaXJuYW1lKSB7XG4gICAgICBzZWFyY2hMb2NhdGlvbnMucHVzaCh0aGlzLmRpcm5hbWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxvY2F0aW9uIG9mIHNlYXJjaExvY2F0aW9ucykge1xuICAgICAgc2VhcmNoZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICBkZWJ1ZzQoYFNlYXJjaCBmb3IgUXVlcnkgRW5naW5lIGluICR7bG9jYXRpb259YCk7XG4gICAgICBlbmdpbmVQYXRoID0gdGhpcy5nZXRRdWVyeUVuZ2luZVBhdGgodGhpcy5wbGF0Zm9ybSwgbG9jYXRpb24pO1xuICAgICAgaWYgKGltcG9ydF9mczQuZGVmYXVsdC5leGlzdHNTeW5jKGVuZ2luZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiB7IHByaXNtYVBhdGg6IGVuZ2luZVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgICB9XG4gICAgfVxuICAgIGVuZ2luZVBhdGggPSB0aGlzLmdldFF1ZXJ5RW5naW5lUGF0aCh0aGlzLnBsYXRmb3JtKTtcbiAgICByZXR1cm4geyBwcmlzbWFQYXRoOiBlbmdpbmVQYXRoICE9IG51bGwgPyBlbmdpbmVQYXRoIDogXCJcIiwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgfVxuICBhc3luYyBnZXRQcmlzbWFQYXRoKCkge1xuICAgIGNvbnN0IHsgcHJpc21hUGF0aCwgc2VhcmNoZWRMb2NhdGlvbnM6IHNlYXJjaGVkTG9jYXRpb25zMiB9ID0gYXdhaXQgdGhpcy5yZXNvbHZlUHJpc21hUGF0aCgpO1xuICAgIGNvbnN0IHBsYXRmb3JtMyA9IGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm0oKTtcbiAgICBpZiAoIWF3YWl0IGV4aXN0czIocHJpc21hUGF0aCkpIHtcbiAgICAgIGNvbnN0IHBpbm5lZFN0ciA9IHRoaXMuaW5jb3JyZWN0bHlQaW5uZWRCaW5hcnlUYXJnZXQgPyBgXG5Zb3UgaW5jb3JyZWN0bHkgcGlubmVkIGl0IHRvICR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnJlZEJyaWdodC5ib2xkKGAke3RoaXMuaW5jb3JyZWN0bHlQaW5uZWRCaW5hcnlUYXJnZXR9YCl9XG5gIDogXCJcIjtcbiAgICAgIGxldCBlcnJvclRleHQgPSBgUXVlcnkgZW5naW5lIGJpbmFyeSBmb3IgY3VycmVudCBwbGF0Zm9ybSBcIiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmJvbGQoXG4gICAgICAgIHBsYXRmb3JtM1xuICAgICAgKX1cIiBjb3VsZCBub3QgYmUgZm91bmQuJHtwaW5uZWRTdHJ9XG5UaGlzIHByb2JhYmx5IGhhcHBlbnMsIGJlY2F1c2UgeW91IGJ1aWx0IFByaXNtYSBDbGllbnQgb24gYSBkaWZmZXJlbnQgcGxhdGZvcm0uXG4oUHJpc21hIENsaWVudCBsb29rZWQgaW4gXCIke2ltcG9ydF9jaGFsazMuZGVmYXVsdC51bmRlcmxpbmUocHJpc21hUGF0aCl9XCIpXG5cblNlYXJjaGVkIExvY2F0aW9uczpcblxuJHtzZWFyY2hlZExvY2F0aW9uczIubWFwKChmKSA9PiB7XG4gICAgICAgIGxldCBtc2cgPSBgICAke2Z9YDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHID09PSBcIm5vZGUtZW5naW5lLXNlYXJjaC1sb2NhdGlvbnNcIiAmJiBpbXBvcnRfZnM0LmRlZmF1bHQuZXhpc3RzU3luYyhmKSkge1xuICAgICAgICAgIGNvbnN0IGRpciA9IGltcG9ydF9mczQuZGVmYXVsdC5yZWFkZGlyU3luYyhmKTtcbiAgICAgICAgICBtc2cgKz0gZGlyLm1hcCgoZCkgPT4gYCAgICAke2R9YCkuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgfSkuam9pbihcIlxcblwiICsgKHByb2Nlc3MuZW52LkRFQlVHID09PSBcIm5vZGUtZW5naW5lLXNlYXJjaC1sb2NhdGlvbnNcIiA/IFwiXFxuXCIgOiBcIlwiKSl9XG5gO1xuICAgICAgaWYgKHRoaXMuZ2VuZXJhdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlID09PSB0aGlzLnBsYXRmb3JtKSB8fCB0aGlzLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlID09PSBcIm5hdGl2ZVwiKSkge1xuICAgICAgICAgIGVycm9yVGV4dCArPSBgXG5Zb3UgYWxyZWFkeSBhZGRlZCB0aGUgcGxhdGZvcm0ke3RoaXMuZ2VuZXJhdG9yLmJpbmFyeVRhcmdldHMubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn0gJHt0aGlzLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLm1hcCgodCkgPT4gYFwiJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuYm9sZCh0LnZhbHVlKX1cImApLmpvaW4oXCIsIFwiKX0gdG8gdGhlIFwiJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQudW5kZXJsaW5lKFwiZ2VuZXJhdG9yXCIpfVwiIGJsb2NrXG5pbiB0aGUgXCJzY2hlbWEucHJpc21hXCIgZmlsZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvcixcbmJ1dCBzb21ldGhpbmcgd2VudCB3cm9uZy4gVGhhdCdzIHN1Ym9wdGltYWwuXG5cblBsZWFzZSBjcmVhdGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzL25ld2A7XG4gICAgICAgICAgZXJyb3JUZXh0ICs9IGBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yVGV4dCArPSBgXG5cblRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgYWRkIHRoZSBwbGF0Zm9ybSBcIiR7dGhpcy5wbGF0Zm9ybX1cIiB0byB0aGUgXCIke2ltcG9ydF9jaGFsazMuZGVmYXVsdC51bmRlcmxpbmUoXG4gICAgICAgICAgICBcImJpbmFyeVRhcmdldHNcIlxuICAgICAgICAgICl9XCIgYXR0cmlidXRlIGluIHRoZSBcIiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnVuZGVybGluZShcImdlbmVyYXRvclwiKX1cIiBibG9jayBpbiB0aGUgXCJzY2hlbWEucHJpc21hXCIgZmlsZTpcbiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmdyZWVuQnJpZ2h0KHRoaXMuZ2V0Rml4ZWRHZW5lcmF0b3IoKSl9XG5cblRoZW4gcnVuIFwiJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJwcmlzbWEgZ2VuZXJhdGVcIil9XCIgZm9yIHlvdXIgY2hhbmdlcyB0byB0YWtlIGVmZmVjdC5cblJlYWQgbW9yZSBhYm91dCBkZXBsb3lpbmcgUHJpc21hIENsaWVudDogaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvcmA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yVGV4dCArPSBgXG5cblJlYWQgbW9yZSBhYm91dCBkZXBsb3lpbmcgUHJpc21hIENsaWVudDogaHR0cHM6Ly9wcmlzLmx5L2QvY2xpZW50LWdlbmVyYXRvclxuYDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGVycm9yVGV4dCwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5jb3JyZWN0bHlQaW5uZWRCaW5hcnlUYXJnZXQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYCR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LnllbGxvdyhcIldhcm5pbmc6XCIpfSBZb3UgcGlubmVkIHRoZSBwbGF0Zm9ybSAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ib2xkKFxuICAgICAgICB0aGlzLmluY29ycmVjdGx5UGlubmVkQmluYXJ5VGFyZ2V0XG4gICAgICApfSwgYnV0IFByaXNtYSBDbGllbnQgZGV0ZWN0cyAke2ltcG9ydF9jaGFsazMuZGVmYXVsdC5ib2xkKGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm0oKSl9LlxuVGhpcyBtZWFucyB5b3Ugc2hvdWxkIHZlcnkgbGlrZWx5IHBpbiB0aGUgcGxhdGZvcm0gJHtpbXBvcnRfY2hhbGszLmRlZmF1bHQuZ3JlZW5CcmlnaHQoYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybSgpKX0gaW5zdGVhZC5cbiR7aW1wb3J0X2NoYWxrMy5kZWZhdWx0LmRpbShcIkluIGNhc2Ugd2UncmUgbWlzdGFrZW4sIHBsZWFzZSByZXBvcnQgdGhpcyB0byB1cyBcXHV7MUY2NEZ9LlwiKX1gKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09IFwid2luMzJcIikge1xuICAgICAgcGx1c1gocHJpc21hUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBwcmlzbWFQYXRoO1xuICB9XG4gIGdldEZpeGVkR2VuZXJhdG9yKCkge1xuICAgIGNvbnN0IGZpeGVkR2VuZXJhdG9yID0ge1xuICAgICAgLi4udGhpcy5nZW5lcmF0b3IsXG4gICAgICBiaW5hcnlUYXJnZXRzOiBmaXhCaW5hcnlUYXJnZXRzKHRoaXMuZ2VuZXJhdG9yLmJpbmFyeVRhcmdldHMsIHRoaXMucGxhdGZvcm0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJpbnRHZW5lcmF0b3JDb25maWcoZml4ZWRHZW5lcmF0b3IpO1xuICB9XG4gIHByaW50RGF0YXNvdXJjZXMoKSB7XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZXMpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGFzb3VyY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiW11cIjtcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5zdG9wUHJvbWlzZSkge1xuICAgICAgYXdhaXQgdGhpcy5zdG9wUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0UHJvbWlzZSkge1xuICAgICAgICB0aGlzLnN0YXJ0Q291bnQrKztcbiAgICAgICAgdGhpcy5zdGFydFByb21pc2UgPSB0aGlzLmludGVybmFsU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuc3RhcnRQcm9taXNlO1xuICAgICAgaWYgKCF0aGlzLmNoaWxkICYmICF0aGlzLmVuZ2luZUVuZHBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKFxuICAgICAgICAgIGBDYW4ndCBwZXJmb3JtIHJlcXVlc3QsIGFzIHRoZSBFbmdpbmUgaGFzIGFscmVhZHkgYmVlbiBzdG9wcGVkYCxcbiAgICAgICAgICB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCBcInN0YXJ0Rm5cIik7XG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICBuYW1lOiBcImNvbm5lY3RcIixcbiAgICAgIGVuYWJsZWQ6IHRoaXMudHJhY2luZ0NvbmZpZy5lbmFibGVkICYmICF0aGlzLnN0YXJ0UHJvbWlzZVxuICAgIH07XG4gICAgcmV0dXJuIHJ1bkluQ2hpbGRTcGFuKHNwYW5PcHRpb25zLCBzdGFydEZuKTtcbiAgfVxuICBnZXRFbmdpbmVFbnZWYXJzKCkge1xuICAgIHZhciBfYTMsIF9iMjtcbiAgICBjb25zdCBlbnYyID0ge1xuICAgICAgUFJJU01BX0RNTF9QQVRIOiB0aGlzLmRhdGFtb2RlbFBhdGhcbiAgICB9O1xuICAgIGlmICh0aGlzLmxvZ1F1ZXJpZXMgfHwgdGhpcy5sb2dMZXZlbCA9PT0gXCJpbmZvXCIpIHtcbiAgICAgIGlmICh0aGlzLmxvZ1F1ZXJpZXMpIHtcbiAgICAgICAgZW52Mi5MT0dfUVVFUklFUyA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhc291cmNlcykge1xuICAgICAgZW52Mi5PVkVSV1JJVEVfREFUQVNPVVJDRVMgPSB0aGlzLnByaW50RGF0YXNvdXJjZXMoKTtcbiAgICB9XG4gICAgaWYgKCFwcm9jZXNzLmVudi5OT19DT0xPUiAmJiB0aGlzLnNob3dDb2xvcnMpIHtcbiAgICAgIGVudjIuQ0xJQ09MT1JfRk9SQ0UgPSBcIjFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuZW52LFxuICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAuLi5lbnYyLFxuICAgICAgUlVTVF9CQUNLVFJBQ0U6IChfYTMgPSBwcm9jZXNzLmVudi5SVVNUX0JBQ0tUUkFDRSkgIT0gbnVsbCA/IF9hMyA6IFwiMVwiLFxuICAgICAgUlVTVF9MT0c6IChfYjIgPSBwcm9jZXNzLmVudi5SVVNUX0xPRykgIT0gbnVsbCA/IF9iMiA6IFwiaW5mb1wiXG4gICAgfTtcbiAgfVxuICBpbnRlcm5hbFN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2EzLCBfYjIsIF9jO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHByb2Nlc3MubmV4dFRpY2socikpO1xuICAgICAgaWYgKHRoaXMuc3RvcFByb21pc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9wUHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZ2luZUVuZHBvaW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9wZW4odGhpcy5lbmdpbmVFbmRwb2ludCk7XG4gICAgICAgICAgYXdhaXQgKDAsIGltcG9ydF9wX3JldHJ5LmRlZmF1bHQpKCgpID0+IHRoaXMuY29ubmVjdGlvbi5nZXQoXCIvc3RhdHVzXCIpLCB7XG4gICAgICAgICAgICByZXRyaWVzOiAxMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCgoX2EzID0gdGhpcy5jaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb25uZWN0ZWQpIHx8IHRoaXMuY2hpbGQgJiYgISgoX2IyID0gdGhpcy5jaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5raWxsZWQpKSB7XG4gICAgICAgICAgZGVidWc0KGBUaGVyZSBpcyBhIGNoaWxkIHRoYXQgc3RpbGwgcnVucyBhbmQgd2Ugd2FudCB0byBzdGFydCBhZ2FpbmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFJ1c3RFcnJvciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3JMb2cgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubGFzdFBhbmljID0gdm9pZCAwO1xuICAgICAgICBsb2dnZXIoXCJzdGFydGluICYgcmVzZXR0aW5cIik7XG4gICAgICAgIHRoaXMuZ2xvYmFsS2lsbFNpZ25hbFJlY2VpdmVkID0gdm9pZCAwO1xuICAgICAgICBkZWJ1ZzQoeyBjd2Q6IHRoaXMuY3dkIH0pO1xuICAgICAgICBjb25zdCBwcmlzbWFQYXRoID0gYXdhaXQgdGhpcy5nZXRQcmlzbWFQYXRoKCk7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxGbGFnID0gdGhpcy5hbGxvd1RyaWdnZXJQYW5pYyA/IFtcIi0tZGVidWdcIl0gOiBbXTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBbXG4gICAgICAgICAgXCItLWVuYWJsZS1yYXctcXVlcmllc1wiLFxuICAgICAgICAgIFwiLS1lbmFibGUtbWV0cmljc1wiLFxuICAgICAgICAgIFwiLS1lbmFibGUtb3Blbi10ZWxlbWV0cnlcIixcbiAgICAgICAgICAuLi50aGlzLmZsYWdzLFxuICAgICAgICAgIC4uLmFkZGl0aW9uYWxGbGFnXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMucG9ydCA9IGF3YWl0IHRoaXMuZ2V0RnJlZVBvcnQoKTtcbiAgICAgICAgZmxhZ3MucHVzaChcIi0tcG9ydFwiLCBTdHJpbmcodGhpcy5wb3J0KSk7XG4gICAgICAgIGRlYnVnNCh7IGZsYWdzIH0pO1xuICAgICAgICBjb25zdCBlbnYyID0gdGhpcy5nZXRFbmdpbmVFbnZWYXJzKCk7XG4gICAgICAgIHRoaXMuY2hpbGQgPSAoMCwgaW1wb3J0X2NoaWxkX3Byb2Nlc3MyLnNwYXduKShwcmlzbWFQYXRoLCBmbGFncywge1xuICAgICAgICAgIGVudjogZW52MixcbiAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgICAgIHN0ZGlvOiBbXCJpZ25vcmVcIiwgXCJwaXBlXCIsIFwicGlwZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgYnlsaW5lKHRoaXMuY2hpbGQuc3RkZXJyKS5vbihcImRhdGFcIiwgKG1zZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBTdHJpbmcobXNnKTtcbiAgICAgICAgICBkZWJ1ZzQoXCJzdGRlcnJcIiwgZGF0YSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uLmlzX3BhbmljICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIGRlYnVnNChqc29uKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGpzb24ubWVzc2FnZSwgdGhpcy5jbGllbnRWZXJzaW9uLCBqc29uLmVycm9yX2NvZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5pbmNsdWRlcyhcIlByaW50aW5nIHRvIHN0ZGVyclwiKSAmJiAhZGF0YS5pbmNsdWRlcyhcIkxpc3RlbmluZyBvbiBcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGRlcnJMb2dzICs9IFwiXFxuXCIgKyBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJ5bGluZSh0aGlzLmNoaWxkLnN0ZG91dCkub24oXCJkYXRhXCIsIChtc2cpID0+IHtcbiAgICAgICAgICB2YXIgX2E0LCBfYjM7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IFN0cmluZyhtc2cpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGRlYnVnNChcInN0ZG91dFwiLCBnZXRNZXNzYWdlKGpzb24pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQgJiYganNvbi5sZXZlbCA9PT0gXCJJTkZPXCIgJiYganNvbi50YXJnZXQgPT09IFwicXVlcnlfZW5naW5lOjpzZXJ2ZXJcIiAmJiAoKF9iMyA9IChfYTQgPSBqc29uLmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IzLnN0YXJ0c1dpdGgoXCJTdGFydGVkIHF1ZXJ5IGVuZ2luZSBodHRwIHNlcnZlclwiKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9wZW4oYGh0dHA6Ly8xMjcuMC4wLjE6JHt0aGlzLnBvcnR9YCk7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi5pc19wYW5pYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICBpZiAoanNvbi5zcGFuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2luZ0NvbmZpZy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICB2b2lkIGNyZWF0ZVNwYW4oanNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBsb2c0ID0gY29udmVydExvZyhqc29uKTtcbiAgICAgICAgICAgICAgY29uc3QgbG9nSXNSdXN0RXJyb3JMb2cgPSBpc1J1c3RFcnJvckxvZyhsb2c0KTtcbiAgICAgICAgICAgICAgaWYgKGxvZ0lzUnVzdEVycm9yTG9nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihsb2c0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChsb2c0LmxldmVsLCBsb2c0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZzQoZSwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZC5vbihcImV4aXRcIiwgKGNvZGUpID0+IHtcbiAgICAgICAgICB2YXIgX2E0O1xuICAgICAgICAgIGxvZ2dlcihcInJlbW92aW5nIHN0YXJ0UHJvbWlzZVwiKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAodGhpcy5lbmdpbmVTdG9wRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lU3RvcERlZmVycmVkLnJlc29sdmUoY29kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgIGlmIChjb2RlICE9PSAwICYmIHRoaXMuZW5naW5lU3RhcnREZWZlcnJlZCAmJiB0aGlzLnN0YXJ0Q291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICBsZXQgbXNnID0gdGhpcy5zdGRlcnJMb2dzO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFJ1c3RFcnJvcikge1xuICAgICAgICAgICAgICBtc2cgPSBnZXRNZXNzYWdlKHRoaXMubGFzdFJ1c3RFcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdEVycm9yTG9nKSB7XG4gICAgICAgICAgICAgIG1zZyA9IGdldE1lc3NhZ2UodGhpcy5sYXN0RXJyb3JMb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZXJyID0gbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgYFF1ZXJ5IGVuZ2luZSBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1cbmAgKyBtc2csXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChfYTQgPSB0aGlzLmNoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LnNpZ25hbENvZGUpIHtcbiAgICAgICAgICAgICAgZXJyID0gbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgYFF1ZXJ5IGVuZ2luZSBwcm9jZXNzIGtpbGxlZCB3aXRoIHNpZ25hbCAke3RoaXMuY2hpbGQuc2lnbmFsQ29kZX0gZm9yIHVua25vd24gcmVhc29uLlxuTWFrZSBzdXJlIHRoYXQgdGhlIGVuZ2luZSBiaW5hcnkgYXQgJHtwcmlzbWFQYXRofSBpcyBub3QgY29ycnVwdC5cbmAgKyBtc2csXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnIgPSBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihtc2csIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZ2luZVN0YXJ0RGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5sYXN0UnVzdEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlID09PSAxMjYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXJyb3Ioe1xuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHRhcmdldDogXCJleGl0XCIsXG4gICAgICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZG4ndCBzdGFydCBxdWVyeSBlbmdpbmUgYXMgaXQncyBub3QgZXhlY3V0YWJsZSBvbiB0aGlzIG9wZXJhdGluZyBzeXN0ZW0uXG5Zb3UgdmVyeSBsaWtlbHkgaGF2ZSB0aGUgd3JvbmcgXCJiaW5hcnlUYXJnZXRcIiBkZWZpbmVkIGluIHRoZSBzY2hlbWEucHJpc21hIGZpbGUuYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoaWxkLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBiYWNrdHJhY2U6IFwiQ291bGQgbm90IHN0YXJ0IHF1ZXJ5IGVuZ2luZVwiLFxuICAgICAgICAgICAgaXNfcGFuaWM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoaWxkLm9uKFwiY2xvc2VcIiwgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICAgIHZhciBfYTQ7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IG51bGwgJiYgc2lnbmFsID09PSBcIlNJR0FCUlRcIiAmJiB0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcjIgPSBuZXcgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsoXCJQYW5pYyBpbiBRdWVyeSBFbmdpbmUgd2l0aCBTSUdBQlJUIHNpZ25hbFwiKSxcbiAgICAgICAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJlcnJvclwiLCBlcnJvcjIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMjU1ICYmIHNpZ25hbCA9PT0gbnVsbCAmJiAoKF9hNCA9IHRoaXMubGFzdEVycm9yTG9nKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LmZpZWxkcy5tZXNzYWdlKSA9PT0gXCJQQU5JQ1wiICYmICF0aGlzLmxhc3RQYW5pYykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IyID0gbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKFxuICAgICAgICAgICAgICB0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKFxuICAgICAgICAgICAgICAgIGAke3RoaXMubGFzdEVycm9yTG9nLmZpZWxkcy5tZXNzYWdlfTogJHt0aGlzLmxhc3RFcnJvckxvZy5maWVsZHMucmVhc29ufSBpbiAke3RoaXMubGFzdEVycm9yTG9nLmZpZWxkcy5maWxlfToke3RoaXMubGFzdEVycm9yTG9nLmZpZWxkcy5saW5lfToke3RoaXMubGFzdEVycm9yTG9nLmZpZWxkcy5jb2x1bW59YFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNldEVycm9yKGVycm9yMik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubGFzdFJ1c3RFcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoZ2V0TWVzc2FnZSh0aGlzLmxhc3RSdXN0RXJyb3IpLCB0aGlzLmNsaWVudFZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3JMb2cpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGdldE1lc3NhZ2UodGhpcy5sYXN0RXJyb3JMb2cpLCB0aGlzLmNsaWVudFZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0MikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmVTdGFydERlZmVycmVkID0geyByZXNvbHZlOiByZXNvbHZlMiwgcmVqZWN0OiByZWplY3QyIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIChfYyA9IHRoaXMuY2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5raWxsKCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHZvaWQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5naW5lVmVyc2lvbiA9IGF3YWl0IHRoaXMudmVyc2lvbih0cnVlKTtcbiAgICAgICAgICAgIGRlYnVnNChgQ2xpZW50IFZlcnNpb246ICR7dGhpcy5jbGllbnRWZXJzaW9ufWApO1xuICAgICAgICAgICAgZGVidWc0KGBFbmdpbmUgVmVyc2lvbjogJHtlbmdpbmVWZXJzaW9ufWApO1xuICAgICAgICAgICAgZGVidWc0KGBBY3RpdmUgcHJvdmlkZXI6ICR7dGhpcy5hY3RpdmVQcm92aWRlcn1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZzQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLnN0b3BQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBzdG9wKCkge1xuICAgIGNvbnN0IHN0b3BGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0b3BQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuc3RvcFByb21pc2UgPSB0aGlzLl9zdG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdG9wUHJvbWlzZTtcbiAgICB9LCBcInN0b3BGblwiKTtcbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgIG5hbWU6IFwiZGlzY29ubmVjdFwiLFxuICAgICAgZW5hYmxlZDogdGhpcy50cmFjaW5nQ29uZmlnLmVuYWJsZWRcbiAgICB9O1xuICAgIHJldHVybiBydW5JbkNoaWxkU3BhbihzcGFuT3B0aW9ucywgc3RvcEZuKTtcbiAgfVxuICBhc3luYyBfc3RvcCgpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICh0aGlzLnN0YXJ0UHJvbWlzZSkge1xuICAgICAgYXdhaXQgdGhpcy5zdGFydFByb21pc2U7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBwcm9jZXNzLm5leHRUaWNrKHJlc29sdmUpKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdldENvbmZpZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgbGV0IHN0b3BDaGlsZFByb21pc2U7XG4gICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgIGRlYnVnNChgU3RvcHBpbmcgUHJpc21hIGVuZ2luZTRgKTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0UHJvbWlzZSkge1xuICAgICAgICBkZWJ1ZzQoYFdhaXRpbmcgZm9yIHN0YXJ0IHByb21pc2VgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydFByb21pc2U7XG4gICAgICB9XG4gICAgICBkZWJ1ZzQoYERvbmUgd2FpdGluZyBmb3Igc3RhcnQgcHJvbWlzZWApO1xuICAgICAgc3RvcENoaWxkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5lbmdpbmVTdG9wRGVmZXJyZWQgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIChfYTMgPSB0aGlzLmNoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmtpbGwoKTtcbiAgICAgIHRoaXMuY2hpbGQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzdG9wQ2hpbGRQcm9taXNlKSB7XG4gICAgICBhd2FpdCBzdG9wQ2hpbGRQcm9taXNlO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gcHJvY2Vzcy5uZXh0VGljayhyKSk7XG4gICAgdGhpcy5zdGFydFByb21pc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmdpbmVTdG9wRGVmZXJyZWQgPSB2b2lkIDA7XG4gIH1cbiAga2lsbChzaWduYWwpIHtcbiAgICB2YXIgX2EzO1xuICAgIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZSA9IHZvaWQgMDtcbiAgICB0aGlzLmdsb2JhbEtpbGxTaWduYWxSZWNlaXZlZCA9IHNpZ25hbDtcbiAgICAoX2EzID0gdGhpcy5jaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5raWxsKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbiAgZ2V0RnJlZVBvcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IGltcG9ydF9uZXQuZGVmYXVsdC5jcmVhdGVTZXJ2ZXIoKHMpID0+IHMuZW5kKFwiXCIpKTtcbiAgICAgIHNlcnZlci51bnJlZigpO1xuICAgICAgc2VydmVyLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgIHNlcnZlci5saXN0ZW4oMCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gc2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgY29uc3QgcG9ydCA9IHR5cGVvZiBhZGRyZXNzID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQoYWRkcmVzcy5zcGxpdChcIjpcIikuc2xpY2UoLTEpWzBdLCAxMCkgOiBhZGRyZXNzLnBvcnQ7XG4gICAgICAgIHNlcnZlci5jbG9zZSgoZSkgPT4ge1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29uZmlnKCkge1xuICAgIGlmICghdGhpcy5nZXRDb25maWdQcm9taXNlKSB7XG4gICAgICB0aGlzLmdldENvbmZpZ1Byb21pc2UgPSB0aGlzLl9nZXRDb25maWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUHJvbWlzZTtcbiAgfVxuICBhc3luYyBfZ2V0Q29uZmlnKCkge1xuICAgIGNvbnN0IHByaXNtYVBhdGggPSBhd2FpdCB0aGlzLmdldFByaXNtYVBhdGgoKTtcbiAgICBjb25zdCBlbnYyID0gYXdhaXQgdGhpcy5nZXRFbmdpbmVFbnZWYXJzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIGltcG9ydF9leGVjYS5kZWZhdWx0KShwcmlzbWFQYXRoLCBbXCJjbGlcIiwgXCJnZXQtY29uZmlnXCJdLCB7XG4gICAgICBlbnY6IG9taXQoZW52MiwgW1wiUE9SVFwiXSksXG4gICAgICBjd2Q6IHRoaXMuY3dkXG4gICAgfSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzdWx0LnN0ZG91dCk7XG4gIH1cbiAgYXN5bmMgZ2V0RG1tZigpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RG1tZlByb21pc2UpIHtcbiAgICAgIHRoaXMuZ2V0RG1tZlByb21pc2UgPSB0aGlzLl9nZXREbW1mKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldERtbWZQcm9taXNlO1xuICB9XG4gIGFzeW5jIF9nZXREbW1mKCkge1xuICAgIGNvbnN0IHByaXNtYVBhdGggPSBhd2FpdCB0aGlzLmdldFByaXNtYVBhdGgoKTtcbiAgICBjb25zdCBlbnYyID0gYXdhaXQgdGhpcy5nZXRFbmdpbmVFbnZWYXJzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIGltcG9ydF9leGVjYS5kZWZhdWx0KShwcmlzbWFQYXRoLCBbXCItLWVuYWJsZS1yYXctcXVlcmllc1wiLCBcImNsaVwiLCBcImRtbWZcIl0sIHtcbiAgICAgIGVudjogb21pdChlbnYyLCBbXCJQT1JUXCJdKSxcbiAgICAgIGN3ZDogdGhpcy5jd2RcbiAgICB9KTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXN1bHQuc3Rkb3V0KTtcbiAgfVxuICBhc3luYyB2ZXJzaW9uKGZvcmNlUnVuID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uUHJvbWlzZSAmJiAhZm9yY2VSdW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnNpb25Qcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gdGhpcy5pbnRlcm5hbFZlcnNpb24oKTtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uUHJvbWlzZTtcbiAgfVxuICBhc3luYyBpbnRlcm5hbFZlcnNpb24oKSB7XG4gICAgY29uc3QgcHJpc21hUGF0aCA9IGF3YWl0IHRoaXMuZ2V0UHJpc21hUGF0aCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBpbXBvcnRfZXhlY2EuZGVmYXVsdCkocHJpc21hUGF0aCwgW1wiLS12ZXJzaW9uXCJdKTtcbiAgICB0aGlzLmxhc3RWZXJzaW9uID0gcmVzdWx0LnN0ZG91dDtcbiAgICByZXR1cm4gdGhpcy5sYXN0VmVyc2lvbjtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHF1ZXJ5MiwgaGVhZGVycyA9IHt9LCBudW1UcnkgPSAxKSB7XG4gICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgIHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlID0gdGhpcy5jb25uZWN0aW9uLnBvc3QoXCIvXCIsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5MiksIHJ1bnRpbWVIZWFkZXJzVG9IdHRwSGVhZGVycyhoZWFkZXJzKSk7XG4gICAgdGhpcy5sYXN0UXVlcnkgPSBxdWVyeTI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgaGVhZGVyczogaGVhZGVyczIgfSA9IGF3YWl0IHRoaXMuY3VycmVudFJlcXVlc3RQcm9taXNlO1xuICAgICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICAgIGlmIChkYXRhLmVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBwcmlzbWFHcmFwaFFMVG9KU0Vycm9yKGRhdGEuZXJyb3JzWzBdLCB0aGlzLmNsaWVudFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKEpTT04uc3RyaW5naWZ5KGRhdGEuZXJyb3JzKSwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBwYXJzZUludChoZWFkZXJzMltcIngtZWxhcHNlZFwiXSkgLyAxZTM7XG4gICAgICBpZiAodGhpcy5zdGFydENvdW50ID4gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UgPSB2b2lkIDA7XG4gICAgICByZXR1cm4geyBkYXRhLCBlbGFwc2VkIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyKFwicmVxIC0gZVwiLCBlKTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlUmVxdWVzdEVycm9yKGUsIG51bVRyeSA8PSBNQVhfUkVRVUVTVF9SRVRSSUVTKTtcbiAgICAgIGlmIChudW1UcnkgPD0gTUFYX1JFUVVFU1RfUkVUUklFUykge1xuICAgICAgICBsb2dnZXIoXCJ0cnlpbmcgYSByZXRyeSBub3dcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QocXVlcnkyLCBoZWFkZXJzLCBudW1UcnkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdEJhdGNoKHF1ZXJpZXMsIGhlYWRlcnMgPSB7fSwgdHJhbnNhY3Rpb24gPSBmYWxzZSwgbnVtVHJ5ID0gMSkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICBjb25zdCByZXF1ZXN0MiA9IHtcbiAgICAgIGJhdGNoOiBxdWVyaWVzLm1hcCgocXVlcnkyKSA9PiAoeyBxdWVyeTogcXVlcnkyLCB2YXJpYWJsZXM6IHt9IH0pKSxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgfTtcbiAgICB0aGlzLmxhc3RRdWVyeSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QyKTtcbiAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0UHJvbWlzZSA9IHRoaXMuY29ubmVjdGlvbi5wb3N0KFwiL1wiLCB0aGlzLmxhc3RRdWVyeSwgcnVudGltZUhlYWRlcnNUb0h0dHBIZWFkZXJzKGhlYWRlcnMpKTtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UmVxdWVzdFByb21pc2UudGhlbigoeyBkYXRhLCBoZWFkZXJzOiBoZWFkZXJzMiB9KSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gcGFyc2VJbnQoaGVhZGVyczJbXCJ4LWVsYXBzZWRcIl0pIC8gMWUzO1xuICAgICAgY29uc3QgeyBiYXRjaFJlc3VsdCwgZXJyb3JzIH0gPSBkYXRhO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmF0Y2hSZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBiYXRjaFJlc3VsdC5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBwcmlzbWFHcmFwaFFMVG9KU0Vycm9yKGRhdGEuZXJyb3JzWzBdLCB0aGlzLmNsaWVudFZlcnNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogcmVzdWx0LFxuICAgICAgICAgICAgZWxhcHNlZFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcHJpc21hR3JhcGhRTFRvSlNFcnJvcihkYXRhLmVycm9yc1swXSwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgaXNFcnJvcjIgPSBhd2FpdCB0aGlzLmhhbmRsZVJlcXVlc3RFcnJvcihlLCBudW1UcnkgPCAzKTtcbiAgICAgIGlmICghaXNFcnJvcjIpIHtcbiAgICAgICAgaWYgKG51bVRyeSA8PSBNQVhfUkVRVUVTVF9SRVRSSUVTKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEJhdGNoKHF1ZXJpZXMsIGhlYWRlcnMsIHRyYW5zYWN0aW9uLCBudW1UcnkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgaXNFcnJvcjI7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdHJhbnNhY3Rpb24oYWN0aW9uLCBoZWFkZXJzLCBhcmcyKSB7XG4gICAgdmFyIF9hMywgX2IyO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICBpZiAoYWN0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGNvbnN0IGpzb25PcHRpb25zID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtYXhfd2FpdDogKF9hMyA9IGFyZzIgPT0gbnVsbCA/IHZvaWQgMCA6IGFyZzIubWF4V2FpdCkgIT0gbnVsbCA/IF9hMyA6IDJlMyxcbiAgICAgICAgdGltZW91dDogKF9iMiA9IGFyZzIgPT0gbnVsbCA/IHZvaWQgMCA6IGFyZzIudGltZW91dCkgIT0gbnVsbCA/IF9iMiA6IDVlMyxcbiAgICAgICAgaXNvbGF0aW9uX2xldmVsOiBhcmcyID09IG51bGwgPyB2b2lkIDAgOiBhcmcyLmlzb2xhdGlvbkxldmVsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IENvbm5lY3Rpb24ub25IdHRwRXJyb3IoXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5wb3N0KFwiL3RyYW5zYWN0aW9uL3N0YXJ0XCIsIGpzb25PcHRpb25zLCBydW50aW1lSGVhZGVyc1RvSHR0cEhlYWRlcnMoaGVhZGVycykpLFxuICAgICAgICB0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwiY29tbWl0XCIpIHtcbiAgICAgIGF3YWl0IENvbm5lY3Rpb24ub25IdHRwRXJyb3IodGhpcy5jb25uZWN0aW9uLnBvc3QoYC90cmFuc2FjdGlvbi8ke2FyZzIuaWR9L2NvbW1pdGApLCB0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXIpO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJvbGxiYWNrXCIpIHtcbiAgICAgIGF3YWl0IENvbm5lY3Rpb24ub25IdHRwRXJyb3IodGhpcy5jb25uZWN0aW9uLnBvc3QoYC90cmFuc2FjdGlvbi8ke2FyZzIuaWR9L3JvbGxiYWNrYCksIHRyYW5zYWN0aW9uSHR0cEVycm9ySGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0IGhhc01heFJlc3RhcnRzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0Q291bnQgPj0gTUFYX1NUQVJUUztcbiAgfVxuICB0aHJvd0FzeW5jRXJyb3JJZkV4aXN0cyhmb3JjZVRocm93ID0gZmFsc2UpIHtcbiAgICB2YXIgX2EzLCBfYjI7XG4gICAgbG9nZ2VyKFwidGhyb3dBc3luY0Vycm9ySWZFeGlzdHNcIiwgdGhpcy5zdGFydENvdW50LCB0aGlzLmhhc01heFJlc3RhcnRzKTtcbiAgICBpZiAodGhpcy5sYXN0UnVzdEVycm9yKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IoXG4gICAgICAgIHRoaXMuZ2V0RXJyb3JNZXNzYWdlV2l0aExpbmsoZ2V0TWVzc2FnZSh0aGlzLmxhc3RSdXN0RXJyb3IpKSxcbiAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMubGFzdFJ1c3RFcnJvci5pc19wYW5pYykge1xuICAgICAgICB0aGlzLmxhc3RQYW5pYyA9IGVycjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc01heFJlc3RhcnRzIHx8IGZvcmNlVGhyb3cpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0RXJyb3JMb2cgJiYgaXNSdXN0RXJyb3JMb2codGhpcy5sYXN0RXJyb3JMb2cpKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihcbiAgICAgICAgdGhpcy5nZXRFcnJvck1lc3NhZ2VXaXRoTGluayhnZXRNZXNzYWdlKHRoaXMubGFzdEVycm9yTG9nKSksXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgKTtcbiAgICAgIGlmICgoKF9iMiA9IChfYTMgPSB0aGlzLmxhc3RFcnJvckxvZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIubWVzc2FnZSkgPT09IFwiUEFOSUNcIikge1xuICAgICAgICB0aGlzLmxhc3RQYW5pYyA9IGVycjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc01heFJlc3RhcnRzIHx8IGZvcmNlVGhyb3cpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFcnJvck1lc3NhZ2VXaXRoTGluayh0aXRsZSkge1xuICAgIHJldHVybiBnZXRFcnJvck1lc3NhZ2VXaXRoTGluayh7XG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHRpdGxlLFxuICAgICAgdmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uLFxuICAgICAgZW5naW5lVmVyc2lvbjogdGhpcy5sYXN0VmVyc2lvbixcbiAgICAgIGRhdGFiYXNlOiB0aGlzLmxhc3RBY3RpdmVQcm92aWRlcixcbiAgICAgIHF1ZXJ5OiB0aGlzLmxhc3RRdWVyeVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIG1ldHJpY3MoeyBmb3JtYXQ6IGZvcm1hdDIsIGdsb2JhbExhYmVscyB9KSB7XG4gICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgIGNvbnN0IHBhcnNlUmVzcG9uc2UgPSBmb3JtYXQyID09PSBcImpzb25cIjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5wb3N0KFxuICAgICAgYC9tZXRyaWNzP2Zvcm1hdD0ke2VuY29kZVVSSUNvbXBvbmVudChmb3JtYXQyKX1gLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoZ2xvYmFsTGFiZWxzKSxcbiAgICAgIG51bGwsXG4gICAgICBwYXJzZVJlc3BvbnNlXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxufTtcbl9fbmFtZShCaW5hcnlFbmdpbmUsIFwiQmluYXJ5RW5naW5lXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocSkge1xuICByZXR1cm4gYHtcInZhcmlhYmxlc1wiOnt9LFwicXVlcnlcIjoke0pTT04uc3RyaW5naWZ5KHEpfX1gO1xufVxuX19uYW1lKHN0cmluZ2lmeVF1ZXJ5LCBcInN0cmluZ2lmeVF1ZXJ5XCIpO1xuZnVuY3Rpb24gaG9va1Byb2Nlc3MoaGFuZGxlciwgZXhpdCA9IGZhbHNlKSB7XG4gIHByb2Nlc3Mub25jZShoYW5kbGVyLCBhc3luYyAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBlbmdpbmUgb2YgZW5naW5lcykge1xuICAgICAgYXdhaXQgZW5naW5lLmVtaXRFeGl0KCk7XG4gICAgICBlbmdpbmUua2lsbChoYW5kbGVyKTtcbiAgICB9XG4gICAgZW5naW5lcy5zcGxpY2UoMCwgZW5naW5lcy5sZW5ndGgpO1xuICAgIGlmIChzb2NrZXRQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldFBhdGggb2Ygc29ja2V0UGF0aHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbXBvcnRfZnM0LmRlZmF1bHQudW5saW5rU3luYyhzb2NrZXRQYXRoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleGl0ICYmIHByb2Nlc3MubGlzdGVuZXJDb3VudChoYW5kbGVyKSA9PT0gMCkge1xuICAgICAgcHJvY2Vzcy5leGl0KCk7XG4gICAgfVxuICB9KTtcbn1cbl9fbmFtZShob29rUHJvY2VzcywgXCJob29rUHJvY2Vzc1wiKTtcbnZhciBob29rc0luaXRpYWxpemVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0SG9va3MoKSB7XG4gIGlmICghaG9va3NJbml0aWFsaXplZCkge1xuICAgIGhvb2tQcm9jZXNzKFwiYmVmb3JlRXhpdFwiKTtcbiAgICBob29rUHJvY2VzcyhcImV4aXRcIik7XG4gICAgaG9va1Byb2Nlc3MoXCJTSUdJTlRcIiwgdHJ1ZSk7XG4gICAgaG9va1Byb2Nlc3MoXCJTSUdVU1IyXCIsIHRydWUpO1xuICAgIGhvb2tQcm9jZXNzKFwiU0lHVEVSTVwiLCB0cnVlKTtcbiAgICBob29rc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxufVxuX19uYW1lKGluaXRIb29rcywgXCJpbml0SG9va3NcIik7XG5mdW5jdGlvbiB0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXIocmVzdWx0KSB7XG4gIHRocm93IHJlc3VsdC5kYXRhO1xufVxuX19uYW1lKHRyYW5zYWN0aW9uSHR0cEVycm9ySGFuZGxlciwgXCJ0cmFuc2FjdGlvbkh0dHBFcnJvckhhbmRsZXJcIik7XG5mdW5jdGlvbiBydW50aW1lSGVhZGVyc1RvSHR0cEhlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2MsIHJ1bnRpbWVIZWFkZXJLZXkpID0+IHtcbiAgICBsZXQgaHR0cEhlYWRlcktleSA9IHJ1bnRpbWVIZWFkZXJLZXk7XG4gICAgaWYgKHJ1bnRpbWVIZWFkZXJLZXkgPT09IFwidHJhbnNhY3Rpb25JZFwiKSB7XG4gICAgICBodHRwSGVhZGVyS2V5ID0gXCJYLXRyYW5zYWN0aW9uLWlkXCI7XG4gICAgfVxuICAgIGFjY1todHRwSGVhZGVyS2V5XSA9IGhlYWRlcnNbcnVudGltZUhlYWRlcktleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuX19uYW1lKHJ1bnRpbWVIZWFkZXJzVG9IdHRwSGVhZGVycywgXCJydW50aW1lSGVhZGVyc1RvSHR0cEhlYWRlcnNcIik7XG5mdW5jdGlvbiBraWxsUHJvY2Vzc0FuZFdhaXQoY2hpbGRQcm9jZXNzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNoaWxkUHJvY2Vzcy5vbmNlKFwiZXhpdFwiLCByZXNvbHZlKTtcbiAgICBjaGlsZFByb2Nlc3Mua2lsbCgpO1xuICB9KTtcbn1cbl9fbmFtZShraWxsUHJvY2Vzc0FuZFdhaXQsIFwia2lsbFByb2Nlc3NBbmRXYWl0XCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9EYXRhUHJveHlFbmdpbmUudHNcbnZhciBpbXBvcnRfZXZlbnRzMiA9IF9fdG9FU00ocmVxdWlyZShcImV2ZW50c1wiKSk7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9jb21tb24vZXJyb3JzL1ByaXNtYUNsaWVudEVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBpbmZvMi5jbGllbnRWZXJzaW9uO1xuICAgIHRoaXMuY2F1c2UgPSBpbmZvMi5jYXVzZTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRFcnJvciwgXCJQcmlzbWFDbGllbnRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL0RhdGFQcm94eUVycm9yLnRzXG52YXIgRGF0YVByb3h5RXJyb3IgPSBjbGFzcyBleHRlbmRzIFByaXNtYUNsaWVudEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICB2YXIgX2EzO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGluZm8yKTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gKF9hMyA9IGluZm8yLmlzUmV0cnlhYmxlKSAhPSBudWxsID8gX2EzIDogdHJ1ZTtcbiAgfVxufTtcbl9fbmFtZShEYXRhUHJveHlFcnJvciwgXCJEYXRhUHJveHlFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL3V0aWxzL3NldFJldHJ5YWJsZS50c1xuZnVuY3Rpb24gc2V0UmV0cnlhYmxlKGluZm8yLCByZXRyeWFibGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5pbmZvMixcbiAgICBpc1JldHJ5YWJsZTogcmV0cnlhYmxlXG4gIH07XG59XG5fX25hbWUoc2V0UmV0cnlhYmxlLCBcInNldFJldHJ5YWJsZVwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL0ZvcmNlZFJldHJ5RXJyb3IudHNcbnZhciBGb3JjZWRSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yKSB7XG4gICAgc3VwZXIoXCJUaGlzIHJlcXVlc3QgbXVzdCBiZSByZXRyaWVkXCIsIHNldFJldHJ5YWJsZShpbmZvMiwgdHJ1ZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiRm9yY2VkUmV0cnlFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDFcIjtcbiAgfVxufTtcbl9fbmFtZShGb3JjZWRSZXRyeUVycm9yLCBcIkZvcmNlZFJldHJ5RXJyb3JcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L2Vycm9ycy9JbnZhbGlkRGF0YXNvdXJjZUVycm9yLnRzXG52YXIgSW52YWxpZERhdGFzb3VyY2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbmZvMikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHNldFJldHJ5YWJsZShpbmZvMiwgZmFsc2UpKTtcbiAgICB0aGlzLm5hbWUgPSBcIkludmFsaWREYXRhc291cmNlRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDAyXCI7XG4gIH1cbn07XG5fX25hbWUoSW52YWxpZERhdGFzb3VyY2VFcnJvciwgXCJJbnZhbGlkRGF0YXNvdXJjZUVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvTm90SW1wbGVtZW50ZWRZZXRFcnJvci50c1xudmFyIE5vdEltcGxlbWVudGVkWWV0RXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzZXRSZXRyeWFibGUoaW5mbzIsIGZhbHNlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJOb3RJbXBsZW1lbnRlZFlldEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwNFwiO1xuICB9XG59O1xuX19uYW1lKE5vdEltcGxlbWVudGVkWWV0RXJyb3IsIFwiTm90SW1wbGVtZW50ZWRZZXRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL0RhdGFQcm94eUFQSUVycm9yLnRzXG52YXIgRGF0YVByb3h5QVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5mbzIpIHtcbiAgICB2YXIgX2EzO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGluZm8yKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gaW5mbzIucmVzcG9uc2U7XG4gICAgY29uc3QgcmVxdWVzdElkID0gKF9hMyA9IHRoaXMucmVzcG9uc2UuaGVhZGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hM1tcIlByaXNtYS1SZXF1ZXN0LUlkXCJdO1xuICAgIGlmIChyZXF1ZXN0SWQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBgKFRoZSByZXF1ZXN0IGlkIHdhczogJHtyZXF1ZXN0SWR9KWA7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UgKyBcIiBcIiArIG1lc3NhZ2VTdWZmaXg7XG4gICAgfVxuICB9XG59O1xuX19uYW1lKERhdGFQcm94eUFQSUVycm9yLCBcIkRhdGFQcm94eUFQSUVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvU2NoZW1hTWlzc2luZ0Vycm9yLnRzXG52YXIgU2NoZW1hTWlzc2luZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yKSB7XG4gICAgc3VwZXIoXCJTY2hlbWEgbmVlZHMgdG8gYmUgdXBsb2FkZWRcIiwgc2V0UmV0cnlhYmxlKGluZm8yLCB0cnVlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJTY2hlbWFNaXNzaW5nRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDA1XCI7XG4gIH1cbn07XG5fX25hbWUoU2NoZW1hTWlzc2luZ0Vycm9yLCBcIlNjaGVtYU1pc3NpbmdFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL0JhZFJlcXVlc3RFcnJvci50c1xudmFyIEJBRF9SRVFVRVNUX0RFRkFVTFRfTUVTU0FHRSA9IFwiVGhpcyByZXF1ZXN0IGNvdWxkIG5vdCBiZSB1bmRlcnN0b29kIGJ5IHRoZSBzZXJ2ZXJcIjtcbnZhciBCYWRSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5mbzIsIG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8IEJBRF9SRVFVRVNUX0RFRkFVTFRfTUVTU0FHRSwgc2V0UmV0cnlhYmxlKGluZm8yLCBmYWxzZSkpO1xuICAgIHRoaXMubmFtZSA9IFwiQmFkUmVxdWVzdEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwMFwiO1xuICAgIGlmIChjb2RlKVxuICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufTtcbl9fbmFtZShCYWRSZXF1ZXN0RXJyb3IsIFwiQmFkUmVxdWVzdEVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvR2F0ZXdheVRpbWVvdXRFcnJvci50c1xudmFyIEdhdGV3YXlUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5mbzIpIHtcbiAgICBzdXBlcihcIlJlcXVlc3QgdGltZWQgb3V0XCIsIHNldFJldHJ5YWJsZShpbmZvMiwgZmFsc2UpKTtcbiAgICB0aGlzLm5hbWUgPSBcIkdhdGV3YXlUaW1lb3V0RXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDA5XCI7XG4gIH1cbn07XG5fX25hbWUoR2F0ZXdheVRpbWVvdXRFcnJvciwgXCJHYXRld2F5VGltZW91dEVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvTm90Rm91bmRFcnJvci50c1xudmFyIE5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIERhdGFQcm94eUFQSUVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5mbzIpIHtcbiAgICBzdXBlcihcIlJlcXVlc3RlZCByZXNvdXJjZSBkb2VzIG5vdCBleGlzdFwiLCBzZXRSZXRyeWFibGUoaW5mbzIsIGZhbHNlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJOb3RGb3VuZEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwM1wiO1xuICB9XG59O1xuX19uYW1lKE5vdEZvdW5kRXJyb3IsIFwiTm90Rm91bmRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL1NlcnZlckVycm9yLnRzXG52YXIgU0VSVkVSX0VSUk9SX0RFRkFVTFRfTUVTU0FHRSA9IFwiVW5rbm93biBzZXJ2ZXIgZXJyb3JcIjtcbnZhciBTZXJ2ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5QVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpbmZvMiwgbWVzc2FnZSwgbG9ncykge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgU0VSVkVSX0VSUk9SX0RFRkFVTFRfTUVTU0FHRSwgc2V0UmV0cnlhYmxlKGluZm8yLCB0cnVlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXJ2ZXJFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IFwiUDUwMDZcIjtcbiAgICB0aGlzLmxvZ3MgPSBsb2dzO1xuICB9XG59O1xuX19uYW1lKFNlcnZlckVycm9yLCBcIlNlcnZlckVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvVW5hdXRob3JpemVkRXJyb3IudHNcbnZhciBVbmF1dGhvcml6ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5QVBJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpbmZvMikge1xuICAgIHN1cGVyKFwiVW5hdXRob3JpemVkLCBjaGVjayB5b3VyIGNvbm5lY3Rpb24gc3RyaW5nXCIsIHNldFJldHJ5YWJsZShpbmZvMiwgZmFsc2UpKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVuYXV0aG9yaXplZEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gXCJQNTAwN1wiO1xuICB9XG59O1xuX19uYW1lKFVuYXV0aG9yaXplZEVycm9yLCBcIlVuYXV0aG9yaXplZEVycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9lcnJvcnMvVXNhZ2VFeGNlZWRlZEVycm9yLnRzXG52YXIgVXNhZ2VFeGNlZWRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBEYXRhUHJveHlBUElFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZm8yKSB7XG4gICAgc3VwZXIoXCJVc2FnZSBleGNlZWRlZCwgcmV0cnkgYWdhaW4gbGF0ZXJcIiwgc2V0UmV0cnlhYmxlKGluZm8yLCB0cnVlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJVc2FnZUV4Y2VlZGVkRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDA4XCI7XG4gIH1cbn07XG5fX25hbWUoVXNhZ2VFeGNlZWRlZEVycm9yLCBcIlVzYWdlRXhjZWVkZWRFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL3V0aWxzL3Jlc3BvbnNlVG9FcnJvci50c1xuYXN5bmMgZnVuY3Rpb24gcmVzcG9uc2VUb0Vycm9yKHJlc3BvbnNlLCBjbGllbnRWZXJzaW9uMikge1xuICB2YXIgX2EzLCBfYjIsIF9jLCBfZCwgX2U7XG4gIGlmIChyZXNwb25zZS5vaylcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpbmZvMiA9IHsgY2xpZW50VmVyc2lvbjogY2xpZW50VmVyc2lvbjIsIHJlc3BvbnNlIH07XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgIGxldCBrbm93bkVycm9yO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAga25vd25FcnJvciA9IChfYjIgPSAoX2EzID0gYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS5FbmdpbmVOb3RTdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnJlYXNvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5Lbm93bkVuZ2luZVN0YXJ0dXBFcnJvcjtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgfVxuICAgIGlmIChrbm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEVycm9yKGluZm8yLCBrbm93bkVycm9yLm1zZywga25vd25FcnJvci5lcnJvcl9jb2RlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEVycm9yKGluZm8yKTtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IGlzU2NoZW1hTWlzc2luZyA9ICgoX2MgPSBib2R5ID09IG51bGwgPyB2b2lkIDAgOiBib2R5LkVuZ2luZU5vdFN0YXJ0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZWFzb24pID09PSBcIlNjaGVtYU1pc3NpbmdcIjtcbiAgICAgIHJldHVybiBpc1NjaGVtYU1pc3NpbmcgPyBuZXcgU2NoZW1hTWlzc2luZ0Vycm9yKGluZm8yKSA6IG5ldyBOb3RGb3VuZEVycm9yKGluZm8yKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihpbmZvMik7XG4gICAgfVxuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgIHRocm93IG5ldyBVc2FnZUV4Y2VlZGVkRXJyb3IoaW5mbzIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwNCkge1xuICAgIHRocm93IG5ldyBHYXRld2F5VGltZW91dEVycm9yKGluZm8yKTtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGluZm8yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoKF9kID0gYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS5FbmdpbmVOb3RTdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2QucmVhc29uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKGluZm8yLCBib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAoKF9lID0gYm9keSA9PSBudWxsID8gdm9pZCAwIDogYm9keS5FbmdpbmVOb3RTdGFydGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2UucmVhc29uKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uKTtcbiAgICAgIGlmIChrZXlzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IGJvZHkuRW5naW5lTm90U3RhcnRlZC5yZWFzb247XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZWFzb25ba2V5czJbMF1dO1xuICAgICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IoaW5mbzIsIGtleXMyWzBdLCBjb250ZW50LmxvZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IoaW5mbzIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFcnJvcihpbmZvMik7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbl9fbmFtZShyZXNwb25zZVRvRXJyb3IsIFwicmVzcG9uc2VUb0Vycm9yXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS91dGlscy9iYWNrT2ZmLnRzXG52YXIgQkFDS09GRl9JTlRFUlZBTCA9IDUwO1xuZnVuY3Rpb24gYmFja09mZihuKSB7XG4gIGNvbnN0IGJhc2VEZWxheSA9IE1hdGgucG93KDIsIG4pICogQkFDS09GRl9JTlRFUlZBTDtcbiAgY29uc3Qgaml0dGVyID0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBiYXNlRGVsYXkpIC0gTWF0aC5jZWlsKGJhc2VEZWxheSAvIDIpO1xuICBjb25zdCB0b3RhbCA9IGJhc2VEZWxheSArIGppdHRlcjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiBzZXRUaW1lb3V0KCgpID0+IGRvbmUodG90YWwpLCB0b3RhbCkpO1xufVxuX19uYW1lKGJhY2tPZmYsIFwiYmFja09mZlwiKTtcblxuLy8gLi4vZW5naW5lcy9wYWNrYWdlLmpzb25cbnZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG4gIFwiQHByaXNtYS9kZWJ1Z1wiOiBcIndvcmtzcGFjZTo0LjMuMVwiLFxuICBcIkBwcmlzbWEvZW5naW5lcy12ZXJzaW9uXCI6IFwiNC4zLjAtMzIuYzg3NWU0MzYwMGRmZTA0MjQ1MmUwYjg2OGY3YTQ4YjgxN2I5NjQwYlwiLFxuICBcIkBwcmlzbWEvZmV0Y2gtZW5naW5lXCI6IFwid29ya3NwYWNlOjQuMy4xXCIsXG4gIFwiQHByaXNtYS9nZXQtcGxhdGZvcm1cIjogXCJ3b3Jrc3BhY2U6NC4zLjFcIixcbiAgXCJAc3djL2NvcmVcIjogXCIxLjIuMjQyXCIsXG4gIFwiQHN3Yy9qZXN0XCI6IFwiMC4yLjIyXCIsXG4gIFwiQHR5cGVzL2plc3RcIjogXCIyOC4xLjdcIixcbiAgXCJAdHlwZXMvbm9kZVwiOiBcIjE2LjExLjU2XCIsXG4gIGV4ZWNhOiBcIjUuMS4xXCIsXG4gIGplc3Q6IFwiMjguMS4zXCIsXG4gIHR5cGVzY3JpcHQ6IFwiNC44LjJcIlxufTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvZXJyb3JzL05ldHdvcmtFcnJvci50c1xudmFyIFJlcXVlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgRGF0YVByb3h5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbmZvMikge1xuICAgIHN1cGVyKGBDYW5ub3QgZmV0Y2ggZGF0YSBmcm9tIHNlcnZpY2U6XG4ke21lc3NhZ2V9YCwgc2V0UmV0cnlhYmxlKGluZm8yLCB0cnVlKSk7XG4gICAgdGhpcy5uYW1lID0gXCJSZXF1ZXN0RXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBcIlA1MDEwXCI7XG4gIH1cbn07XG5fX25hbWUoUmVxdWVzdEVycm9yLCBcIlJlcXVlc3RFcnJvclwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvdXRpbHMvZ2V0SlNSdW50aW1lTmFtZS50c1xuZnVuY3Rpb24gZ2V0SlNSdW50aW1lTmFtZSgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9XG4gIHJldHVybiBcImJyb3dzZXJcIjtcbn1cbl9fbmFtZShnZXRKU1J1bnRpbWVOYW1lLCBcImdldEpTUnVudGltZU5hbWVcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9kYXRhLXByb3h5L3V0aWxzL3JlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gIHZhciBfYTM7XG4gIGNvbnN0IGNsaWVudFZlcnNpb24yID0gb3B0aW9ucy5jbGllbnRWZXJzaW9uO1xuICBjb25zdCBqc1J1bnRpbWVOYW1lID0gZ2V0SlNSdW50aW1lTmFtZSgpO1xuICB0cnkge1xuICAgIGlmIChqc1J1bnRpbWVOYW1lID09PSBcImJyb3dzZXJcIikge1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCBub2RlRmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gKF9hMyA9IGUubWVzc2FnZSkgIT0gbnVsbCA/IF9hMyA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IobWVzc2FnZSwgeyBjbGllbnRWZXJzaW9uOiBjbGllbnRWZXJzaW9uMiB9KTtcbiAgfVxufVxuX19uYW1lKHJlcXVlc3QsIFwicmVxdWVzdFwiKTtcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVycyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gIH07XG59XG5fX25hbWUoYnVpbGRIZWFkZXJzLCBcImJ1aWxkSGVhZGVyc1wiKTtcbmZ1bmN0aW9uIGJ1aWxkT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMob3B0aW9ucylcbiAgfTtcbn1cbl9fbmFtZShidWlsZE9wdGlvbnMsIFwiYnVpbGRPcHRpb25zXCIpO1xuZnVuY3Rpb24gYnVpbGRSZXNwb25zZShpbmNvbWluZ0RhdGEsIHJlc3BvbnNlKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dDogKCkgPT4gQnVmZmVyLmNvbmNhdChpbmNvbWluZ0RhdGEpLnRvU3RyaW5nKCksXG4gICAganNvbjogKCkgPT4gSlNPTi5wYXJzZShCdWZmZXIuY29uY2F0KGluY29taW5nRGF0YSkudG9TdHJpbmcoKSksXG4gICAgb2s6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPD0gMjk5LFxuICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzXG4gIH07XG59XG5fX25hbWUoYnVpbGRSZXNwb25zZSwgXCJidWlsZFJlc3BvbnNlXCIpO1xuYXN5bmMgZnVuY3Rpb24gbm9kZUZldGNoKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGh0dHBzID0gaW5jbHVkZShcImh0dHBzXCIpO1xuICBjb25zdCBodHRwc09wdGlvbnMgPSBidWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IGluY29taW5nRGF0YSA9IFtdO1xuICBjb25zdCB7IG9yaWdpbiB9ID0gbmV3IFVSTCh1cmwpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBfYTM7XG4gICAgY29uc3QgcmVxdWVzdDIgPSBodHRwcy5yZXF1ZXN0KHVybCwgaHR0cHNPcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgaGVhZGVyczogeyBsb2NhdGlvbiB9IH0gPSByZXNwb25zZTtcbiAgICAgIGlmIChzdGF0dXNDb2RlID49IDMwMSAmJiBzdGF0dXNDb2RlIDw9IDM5OSAmJiBsb2NhdGlvbikge1xuICAgICAgICBpZiAobG9jYXRpb24uc3RhcnRzV2l0aChcImh0dHBcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmVzb2x2ZShub2RlRmV0Y2goYCR7b3JpZ2lufSR7bG9jYXRpb259YCwgb3B0aW9ucykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobm9kZUZldGNoKGxvY2F0aW9uLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IGluY29taW5nRGF0YS5wdXNoKGNodW5rKSk7XG4gICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiByZXNvbHZlKGJ1aWxkUmVzcG9uc2UoaW5jb21pbmdEYXRhLCByZXNwb25zZSkpKTtcbiAgICAgIHJlc3BvbnNlLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICB9KTtcbiAgICByZXF1ZXN0Mi5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgcmVxdWVzdDIuZW5kKChfYTMgPSBvcHRpb25zLmJvZHkpICE9IG51bGwgPyBfYTMgOiBcIlwiKTtcbiAgfSk7XG59XG5fX25hbWUobm9kZUZldGNoLCBcIm5vZGVGZXRjaFwiKTtcbnZhciBpbmNsdWRlID0gdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogKCkgPT4ge1xufTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2RhdGEtcHJveHkvdXRpbHMvZ2V0Q2xpZW50VmVyc2lvbi50c1xudmFyIHNlbXZlclJlZ2V4ID0gL15bMS05XVswLTldKlxcLlswLTldK1xcLlswLTldKyQvO1xudmFyIGRlYnVnNSA9IHNyY19kZWZhdWx0KFwicHJpc21hOmNsaWVudDpkYXRhcHJveHlFbmdpbmVcIik7XG5hc3luYyBmdW5jdGlvbiBfZ2V0Q2xpZW50VmVyc2lvbihjb25maWcyKSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGNvbnN0IGVuZ2luZVZlcnNpb24gPSBkZXZEZXBlbmRlbmNpZXNbXCJAcHJpc21hL2VuZ2luZXMtdmVyc2lvblwiXTtcbiAgY29uc3QgY2xpZW50VmVyc2lvbjIgPSAoX2EzID0gY29uZmlnMi5jbGllbnRWZXJzaW9uKSAhPSBudWxsID8gX2EzIDogXCJ1bmtub3duXCI7XG4gIGlmIChwcm9jZXNzLmVudi5QUklTTUFfQ0xJRU5UX0RBVEFfUFJPWFlfQ0xJRU5UX1ZFUlNJT04pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuUFJJU01BX0NMSUVOVF9EQVRBX1BST1hZX0NMSUVOVF9WRVJTSU9OO1xuICB9XG4gIGNvbnN0IFt2ZXJzaW9uLCBzdWZmaXhdID0gKF9iMiA9IGNsaWVudFZlcnNpb24yID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnRWZXJzaW9uMi5zcGxpdChcIi1cIikpICE9IG51bGwgPyBfYjIgOiBbXTtcbiAgaWYgKHN1ZmZpeCA9PT0gdm9pZCAwICYmIHNlbXZlclJlZ2V4LnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuICBpZiAoc3VmZml4ICE9PSB2b2lkIDAgfHwgY2xpZW50VmVyc2lvbjIgPT09IFwiMC4wLjBcIikge1xuICAgIGNvbnN0IFt2ZXJzaW9uMl0gPSAoX2MgPSBlbmdpbmVWZXJzaW9uLnNwbGl0KFwiLVwiKSkgIT0gbnVsbCA/IF9jIDogW107XG4gICAgY29uc3QgW21ham9yMiwgbWlub3IsIHBhdGNoXSA9IHZlcnNpb24yLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBwa2dVUkwgPSBwcmlzbWFQa2dVUkwoYDw9JHttYWpvcjJ9LiR7bWlub3J9LiR7cGF0Y2h9YCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChwa2dVUkwsIHsgY2xpZW50VmVyc2lvbjogY2xpZW50VmVyc2lvbjIgfSk7XG4gICAgY29uc3QgYm9keUFzVGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgZGVidWc1KFwibGVuZ3RoIG9mIGJvZHkgZmV0Y2hlZCBmcm9tIHVucGtnLmNvbVwiLCBib2R5QXNUZXh0Lmxlbmd0aCk7XG4gICAgbGV0IGJvZHlBc0pzb247XG4gICAgdHJ5IHtcbiAgICAgIGJvZHlBc0pzb24gPSBKU09OLnBhcnNlKGJvZHlBc1RleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJKU09OLnBhcnNlIGVycm9yOiBib2R5IGZldGNoZWQgZnJvbSB1bnBrZy5jb206IFwiLCBib2R5QXNUZXh0KTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBib2R5QXNKc29uW1widmVyc2lvblwiXTtcbiAgfVxuICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRZZXRFcnJvcihcIk9ubHkgYG1ham9yLm1pbm9yLnBhdGNoYCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkIGJ5IFByaXNtYSBEYXRhIFByb3h5LlwiLCB7XG4gICAgY2xpZW50VmVyc2lvbjogY2xpZW50VmVyc2lvbjJcbiAgfSk7XG59XG5fX25hbWUoX2dldENsaWVudFZlcnNpb24sIFwiX2dldENsaWVudFZlcnNpb25cIik7XG5hc3luYyBmdW5jdGlvbiBnZXRDbGllbnRWZXJzaW9uKGNvbmZpZzIpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IF9nZXRDbGllbnRWZXJzaW9uKGNvbmZpZzIpO1xuICBkZWJ1ZzUoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pO1xuICByZXR1cm4gdmVyc2lvbjtcbn1cbl9fbmFtZShnZXRDbGllbnRWZXJzaW9uLCBcImdldENsaWVudFZlcnNpb25cIik7XG5mdW5jdGlvbiBwcmlzbWFQa2dVUkwodmVyc2lvbikge1xuICByZXR1cm4gZW5jb2RlVVJJKGBodHRwczovL3VucGtnLmNvbS9wcmlzbWFAJHt2ZXJzaW9ufS9wYWNrYWdlLmpzb25gKTtcbn1cbl9fbmFtZShwcmlzbWFQa2dVUkwsIFwicHJpc21hUGtnVVJMXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvZGF0YS1wcm94eS9EYXRhUHJveHlFbmdpbmUudHNcbnZhciBNQVhfUkVUUklFUyA9IDEwO1xudmFyIFAyID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgZGVidWc2ID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50OmRhdGFwcm94eUVuZ2luZVwiKTtcbnZhciBEYXRhUHJveHlFbmdpbmUgPSBjbGFzcyBleHRlbmRzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZzIpIHtcbiAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnMjtcbiAgICB0aGlzLmVudiA9IHsgLi4udGhpcy5jb25maWcuZW52LCAuLi5wcm9jZXNzLmVudiB9O1xuICAgIHRoaXMuaW5saW5lU2NoZW1hID0gKF9hMyA9IGNvbmZpZzIuaW5saW5lU2NoZW1hKSAhPSBudWxsID8gX2EzIDogXCJcIjtcbiAgICB0aGlzLmlubGluZURhdGFzb3VyY2VzID0gKF9iMiA9IGNvbmZpZzIuaW5saW5lRGF0YXNvdXJjZXMpICE9IG51bGwgPyBfYjIgOiB7fTtcbiAgICB0aGlzLmlubGluZVNjaGVtYUhhc2ggPSAoX2MgPSBjb25maWcyLmlubGluZVNjaGVtYUhhc2gpICE9IG51bGwgPyBfYyA6IFwiXCI7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gKF9kID0gY29uZmlnMi5jbGllbnRWZXJzaW9uKSAhPSBudWxsID8gX2QgOiBcInVua25vd25cIjtcbiAgICB0aGlzLmxvZ0VtaXR0ZXIgPSBuZXcgaW1wb3J0X2V2ZW50czIuZGVmYXVsdCgpO1xuICAgIHRoaXMubG9nRW1pdHRlci5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICB9KTtcbiAgICBjb25zdCBbaG9zdCwgYXBpS2V5XSA9IHRoaXMuZXh0cmFjdEhvc3RBbmRBcGlLZXkoKTtcbiAgICB0aGlzLnJlbW90ZUNsaWVudFZlcnNpb24gPSBQMi50aGVuKCgpID0+IGdldENsaWVudFZlcnNpb24odGhpcy5jb25maWcpKTtcbiAgICB0aGlzLmhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthcGlLZXl9YCB9O1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgZGVidWc2KFwiaG9zdFwiLCB0aGlzLmhvc3QpO1xuICB9XG4gIHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICB9XG4gIGFzeW5jIHN0b3AoKSB7XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJlZm9yZUV4aXRcIikge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkWWV0RXJyb3IoXCJiZWZvcmVFeGl0IGV2ZW50IGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIsIHtcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVybChzKSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5ob3N0fS8ke2F3YWl0IHRoaXMucmVtb3RlQ2xpZW50VmVyc2lvbn0vJHt0aGlzLmlubGluZVNjaGVtYUhhc2h9LyR7c31gO1xuICB9XG4gIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGFzb3VyY2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBhY3RpdmVQcm92aWRlcjogdGhpcy5jb25maWcuYWN0aXZlUHJvdmlkZXJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIGdldERtbWYoKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkWWV0RXJyb3IoXCJnZXREbW1mIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIsIHtcbiAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwbG9hZFNjaGVtYSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXdhaXQgdGhpcy51cmwoXCJzY2hlbWFcIiksIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuaW5saW5lU2NoZW1hLFxuICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgZGVidWc2KFwic2NoZW1hIHJlc3BvbnNlIHN0YXR1c1wiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBhd2FpdCByZXNwb25zZVRvRXJyb3IocmVzcG9uc2UsIHRoaXMuY2xpZW50VmVyc2lvbik7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJ3YXJuXCIsIHsgbWVzc2FnZTogYEVycm9yIHdoaWxlIHVwbG9hZGluZyBzY2hlbWE6ICR7ZXJyLm1lc3NhZ2V9YCB9KTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJpbmZvXCIsIHtcbiAgICAgICAgbWVzc2FnZTogYFNjaGVtYSAocmUpdXBsb2FkZWQgKGhhc2g6ICR7dGhpcy5pbmxpbmVTY2hlbWFIYXNofSlgXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVxdWVzdChxdWVyeTIsIGhlYWRlcnMsIGF0dGVtcHQgPSAwKSB7XG4gICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJxdWVyeVwiLCB7IHF1ZXJ5OiBxdWVyeTIgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEludGVybmFsKHsgcXVlcnk6IHF1ZXJ5MiwgdmFyaWFibGVzOiB7fSB9LCBoZWFkZXJzLCBhdHRlbXB0KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0QmF0Y2gocXVlcmllcywgaGVhZGVycywgaXNUcmFuc2FjdGlvbiA9IGZhbHNlLCBhdHRlbXB0ID0gMCkge1xuICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwicXVlcnlcIiwge1xuICAgICAgcXVlcnk6IGBCYXRjaCR7aXNUcmFuc2FjdGlvbiA/IFwiIGluIHRyYW5zYWN0aW9uXCIgOiBcIlwifSAoJHtxdWVyaWVzLmxlbmd0aH0pOlxuJHtxdWVyaWVzLmpvaW4oXCJcXG5cIil9YFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBiYXRjaDogcXVlcmllcy5tYXAoKHF1ZXJ5MikgPT4gKHsgcXVlcnk6IHF1ZXJ5MiwgdmFyaWFibGVzOiB7fSB9KSksXG4gICAgICB0cmFuc2FjdGlvbjogaXNUcmFuc2FjdGlvblxuICAgIH07XG4gICAgY29uc3QgeyBiYXRjaFJlc3VsdCB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0SW50ZXJuYWwoYm9keSwgaGVhZGVycywgYXR0ZW1wdCk7XG4gICAgcmV0dXJuIGJhdGNoUmVzdWx0O1xuICB9XG4gIGFzeW5jIHJlcXVlc3RJbnRlcm5hbChib2R5LCBoZWFkZXJzLCBhdHRlbXB0KSB7XG4gICAgdmFyIF9hMztcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJpbmZvXCIsIHtcbiAgICAgICAgbWVzc2FnZTogYENhbGxpbmcgJHthd2FpdCB0aGlzLnVybChcImdyYXBocWxcIil9IChuPSR7YXR0ZW1wdH0pYFxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXdhaXQgdGhpcy51cmwoXCJncmFwaHFsXCIpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uaGVhZGVycywgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBkZWJ1ZzYoXCJncmFwaHFsIHJlc3BvbnNlIHN0YXR1c1wiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgZSA9IGF3YWl0IHJlc3BvbnNlVG9FcnJvcihyZXNwb25zZSwgdGhpcy5jbGllbnRWZXJzaW9uKTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2NoZW1hTWlzc2luZ0Vycm9yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXBsb2FkU2NoZW1hKCk7XG4gICAgICAgIHRocm93IG5ldyBGb3JjZWRSZXRyeUVycm9yKHtcbiAgICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb24sXG4gICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZSlcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoZGF0YS5lcnJvcnMpIHtcbiAgICAgICAgaWYgKGRhdGEuZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRocm93IHByaXNtYUdyYXBoUUxUb0pTRXJyb3IoZGF0YS5lcnJvcnNbMF0sIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcImVycm9yXCIsIHtcbiAgICAgICAgbWVzc2FnZTogYEVycm9yIHdoaWxlIHF1ZXJ5aW5nOiAkeyhfYTMgPSBlLm1lc3NhZ2UpICE9IG51bGwgPyBfYTMgOiBcIih1bmtub3duKVwifWBcbiAgICAgIH0pO1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIERhdGFQcm94eUVycm9yKSlcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIGlmICghZS5pc1JldHJ5YWJsZSlcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIGlmIChhdHRlbXB0ID49IE1BWF9SRVRSSUVTKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRm9yY2VkUmV0cnlFcnJvcikge1xuICAgICAgICAgIHRocm93IGUuY2F1c2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJ3YXJuXCIsIHsgbWVzc2FnZTogXCJUaGlzIHJlcXVlc3QgY2FuIGJlIHJldHJpZWRcIiB9KTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gYXdhaXQgYmFja09mZihhdHRlbXB0KTtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwid2FyblwiLCB7IG1lc3NhZ2U6IGBSZXRyeWluZyBhZnRlciAke2RlbGF5fW1zYCB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RJbnRlcm5hbChib2R5LCBoZWFkZXJzLCBhdHRlbXB0ICsgMSk7XG4gICAgfVxuICB9XG4gIHRyYW5zYWN0aW9uKCkge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZFlldEVycm9yKFwiSW50ZXJhY3RpdmUgdHJhbnNhY3Rpb25zIGFyZSBub3QgeWV0IHN1cHBvcnRlZFwiLCB7XG4gICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICB9KTtcbiAgfVxuICBleHRyYWN0SG9zdEFuZEFwaUtleSgpIHtcbiAgICBjb25zdCBkYXRhc291cmNlcyA9IHRoaXMubWVyZ2VPdmVycmlkZGVuRGF0YXNvdXJjZXMoKTtcbiAgICBjb25zdCBtYWluRGF0YXNvdXJjZU5hbWUgPSBPYmplY3Qua2V5cyhkYXRhc291cmNlcylbMF07XG4gICAgY29uc3QgbWFpbkRhdGFzb3VyY2UgPSBkYXRhc291cmNlc1ttYWluRGF0YXNvdXJjZU5hbWVdO1xuICAgIGNvbnN0IGRhdGFQcm94eVVSTCA9IHRoaXMucmVzb2x2ZURhdGFzb3VyY2VVUkwobWFpbkRhdGFzb3VyY2VOYW1lLCBtYWluRGF0YXNvdXJjZSk7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChkYXRhUHJveHlVUkwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YXNvdXJjZUVycm9yKFwiQ291bGQgbm90IHBhcnNlIFVSTCBvZiB0aGUgZGF0YXNvdXJjZVwiLCB7XG4gICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3QsIHNlYXJjaFBhcmFtcyB9ID0gdXJsO1xuICAgIGlmIChwcm90b2NvbCAhPT0gXCJwcmlzbWE6XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YXNvdXJjZUVycm9yKFwiRGF0YXNvdXJjZSBVUkwgbXVzdCB1c2UgcHJpc21hOi8vIHByb3RvY29sIHdoZW4gLS1kYXRhLXByb3h5IGlzIHVzZWRcIiwge1xuICAgICAgICBjbGllbnRWZXJzaW9uOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcGlLZXkgPSBzZWFyY2hQYXJhbXMuZ2V0KFwiYXBpX2tleVwiKTtcbiAgICBpZiAoYXBpS2V5ID09PSBudWxsIHx8IGFwaUtleS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFzb3VyY2VFcnJvcihcIk5vIHZhbGlkIEFQSSBrZXkgZm91bmQgaW4gdGhlIGRhdGFzb3VyY2UgVVJMXCIsIHtcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtob3N0LCBhcGlLZXldO1xuICB9XG4gIG1lcmdlT3ZlcnJpZGRlbkRhdGFzb3VyY2VzKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5kYXRhc291cmNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmxpbmVEYXRhc291cmNlcztcbiAgICB9XG4gICAgY29uc3QgZmluYWxEYXRhc291cmNlcyA9IHsgLi4udGhpcy5pbmxpbmVEYXRhc291cmNlcyB9O1xuICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgb2YgdGhpcy5jb25maWcuZGF0YXNvdXJjZXMpIHtcbiAgICAgIGlmICghdGhpcy5pbmxpbmVEYXRhc291cmNlc1tvdmVycmlkZS5uYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YXNvdXJjZTogJHtvdmVycmlkZS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZmluYWxEYXRhc291cmNlc1tvdmVycmlkZS5uYW1lXSA9IHtcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgZnJvbUVudlZhcjogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogb3ZlcnJpZGUudXJsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmaW5hbERhdGFzb3VyY2VzO1xuICB9XG4gIHJlc29sdmVEYXRhc291cmNlVVJMKG5hbWUsIGRhdGFzb3VyY2UpIHtcbiAgICBpZiAoZGF0YXNvdXJjZS51cmwudmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhc291cmNlLnVybC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGRhdGFzb3VyY2UudXJsLmZyb21FbnZWYXIpIHtcbiAgICAgIGNvbnN0IGVudlZhciA9IGRhdGFzb3VyY2UudXJsLmZyb21FbnZWYXI7XG4gICAgICBjb25zdCBsb2FkZWRFbnZVUkwgPSB0aGlzLmVudltlbnZWYXJdO1xuICAgICAgaWYgKGxvYWRlZEVudlVSTCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YXNvdXJjZUVycm9yKFxuICAgICAgICAgIGBEYXRhc291cmNlIFwiJHtuYW1lfVwiIHJlZmVyZW5jZXMgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgXCIke2VudlZhcn1cIiB0aGF0IGlzIG5vdCBzZXRgLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2FkZWRFbnZVUkw7XG4gICAgfVxuICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YXNvdXJjZUVycm9yKFxuICAgICAgYERhdGFzb3VyY2UgXCIke25hbWV9XCIgc3BlY2lmaWNhdGlvbiBpcyBpbnZhbGlkOiBib3RoIHZhbHVlIGFuZCBmcm9tRW52VmFyIGFyZSBudWxsYCxcbiAgICAgIHtcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBtZXRyaWNzKG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRZZXRFcnJvcihcIk1ldHJpYyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgZm9yIERhdGEgUHJveHlcIiwge1xuICAgICAgY2xpZW50VmVyc2lvbjogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgfSk7XG4gIH1cbn07XG5fX25hbWUoRGF0YVByb3h5RW5naW5lLCBcIkRhdGFQcm94eUVuZ2luZVwiKTtcblxuLy8gLi4vZW5naW5lLWNvcmUvc3JjL2xpYnJhcnkvTGlicmFyeUVuZ2luZS50c1xudmFyIGltcG9ydF9jaGFsazUgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9ldmVudHMzID0gX190b0VTTShyZXF1aXJlKFwiZXZlbnRzXCIpKTtcbnZhciBpbXBvcnRfZnM2ID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvbGlicmFyeS9EZWZhdWx0TGlicmFyeUxvYWRlci50c1xudmFyIGltcG9ydF9jaGFsazQgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9mczUgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X3BhdGgzID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgZGVidWc3ID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50OmxpYnJhcnlFbmdpbmU6bG9hZGVyXCIpO1xudmFyIERlZmF1bHRMaWJyYXJ5TG9hZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcyKSB7XG4gICAgdGhpcy5saWJRdWVyeUVuZ2luZVBhdGggPSBudWxsO1xuICAgIHRoaXMucGxhdGZvcm0gPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnMjtcbiAgfVxuICBhc3luYyBsb2FkTGlicmFyeSgpIHtcbiAgICBpZiAoIXRoaXMubGliUXVlcnlFbmdpbmVQYXRoKSB7XG4gICAgICB0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCA9IGF3YWl0IHRoaXMuZ2V0TGliUXVlcnlFbmdpbmVQYXRoKCk7XG4gICAgfVxuICAgIGRlYnVnNyhgbG9hZEVuZ2luZSB1c2luZyAke3RoaXMubGliUXVlcnlFbmdpbmVQYXRofWApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZXZhbChcInJlcXVpcmVcIikodGhpcy5saWJRdWVyeUVuZ2luZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpbXBvcnRfZnM1LmRlZmF1bHQuZXhpc3RzU3luYyh0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCkpIHtcbiAgICAgICAgaWYgKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoLmVuZHNXaXRoKFwiLm5vZGVcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihcbiAgICAgICAgICAgIGBVbmFibGUgdG8gbG9hZCBOb2RlLUFQSSBMaWJyYXJ5IGZyb20gJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuZGltKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoKX0sIExpYnJhcnkgbWF5IGJlIGNvcnJ1cHRgLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gTm9kZS1BUEkgTGlicmFyeSBidXQgcmVjZWl2ZWQgJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuZGltKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoKX1gLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKFxuICAgICAgICAgIGBVbmFibGUgdG8gbG9hZCBOb2RlLUFQSSBMaWJyYXJ5IGZyb20gJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuZGltKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoKX0sIEl0IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldExpYlF1ZXJ5RW5naW5lUGF0aCgpIHtcbiAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgICBjb25zdCBsaWJQYXRoID0gKF9hMyA9IHByb2Nlc3MuZW52LlBSSVNNQV9RVUVSWV9FTkdJTkVfTElCUkFSWSkgIT0gbnVsbCA/IF9hMyA6IHRoaXMuY29uZmlnLnByaXNtYVBhdGg7XG4gICAgaWYgKGxpYlBhdGggJiYgaW1wb3J0X2ZzNS5kZWZhdWx0LmV4aXN0c1N5bmMobGliUGF0aCkgJiYgbGliUGF0aC5lbmRzV2l0aChcIi5ub2RlXCIpKSB7XG4gICAgICByZXR1cm4gbGliUGF0aDtcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybSA9IChfYjIgPSB0aGlzLnBsYXRmb3JtKSAhPSBudWxsID8gX2IyIDogYXdhaXQgZ2V0UGxhdGZvcm0oKTtcbiAgICBjb25zdCB7IGVuZ2luZVBhdGg6IGVuZ2luZVBhdGgyLCBzZWFyY2hlZExvY2F0aW9uczogc2VhcmNoZWRMb2NhdGlvbnMyIH0gPSBhd2FpdCB0aGlzLnJlc29sdmVFbmdpbmVQYXRoKCk7XG4gICAgaWYgKCFpbXBvcnRfZnM1LmRlZmF1bHQuZXhpc3RzU3luYyhlbmdpbmVQYXRoMikpIHtcbiAgICAgIGNvbnN0IGluY29ycmVjdFBpbm5lZFBsYXRmb3JtRXJyb3JTdHIgPSB0aGlzLnBsYXRmb3JtID8gYFxuWW91IGluY29ycmVjdGx5IHBpbm5lZCBpdCB0byAke2ltcG9ydF9jaGFsazQuZGVmYXVsdC5yZWRCcmlnaHQuYm9sZChgJHt0aGlzLnBsYXRmb3JtfWApfVxuYCA6IFwiXCI7XG4gICAgICBsZXQgZXJyb3JUZXh0ID0gYFF1ZXJ5IGVuZ2luZSBsaWJyYXJ5IGZvciBjdXJyZW50IHBsYXRmb3JtIFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuYm9sZChcbiAgICAgICAgdGhpcy5wbGF0Zm9ybVxuICAgICAgKX1cIiBjb3VsZCBub3QgYmUgZm91bmQuJHtpbmNvcnJlY3RQaW5uZWRQbGF0Zm9ybUVycm9yU3RyfVxuVGhpcyBwcm9iYWJseSBoYXBwZW5zLCBiZWNhdXNlIHlvdSBidWlsdCBQcmlzbWEgQ2xpZW50IG9uIGEgZGlmZmVyZW50IHBsYXRmb3JtLlxuKFByaXNtYSBDbGllbnQgbG9va2VkIGluIFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQudW5kZXJsaW5lKGVuZ2luZVBhdGgyKX1cIilcblxuU2VhcmNoZWQgTG9jYXRpb25zOlxuXG4ke3NlYXJjaGVkTG9jYXRpb25zMi5tYXAoKGYpID0+IHtcbiAgICAgICAgbGV0IG1zZyA9IGAgICR7Zn1gO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcgPT09IFwibm9kZS1lbmdpbmUtc2VhcmNoLWxvY2F0aW9uc1wiICYmIGltcG9ydF9mczUuZGVmYXVsdC5leGlzdHNTeW5jKGYpKSB7XG4gICAgICAgICAgY29uc3QgZGlyID0gaW1wb3J0X2ZzNS5kZWZhdWx0LnJlYWRkaXJTeW5jKGYpO1xuICAgICAgICAgIG1zZyArPSBkaXIubWFwKChkKSA9PiBgICAgICR7ZH1gKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgICB9KS5qb2luKFwiXFxuXCIgKyAocHJvY2Vzcy5lbnYuREVCVUcgPT09IFwibm9kZS1lbmdpbmUtc2VhcmNoLWxvY2F0aW9uc1wiID8gXCJcXG5cIiA6IFwiXCIpKX1cbmA7XG4gICAgICBpZiAodGhpcy5jb25maWcuZ2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSAoX2MgPSB0aGlzLnBsYXRmb3JtKSAhPSBudWxsID8gX2MgOiBhd2FpdCBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZ2VuZXJhdG9yLmJpbmFyeVRhcmdldHMuZmluZCgob2JqZWN0KSA9PiBvYmplY3QudmFsdWUgPT09IHRoaXMucGxhdGZvcm0pIHx8IHRoaXMuY29uZmlnLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmZpbmQoKG9iamVjdCkgPT4gb2JqZWN0LnZhbHVlID09PSBcIm5hdGl2ZVwiKSkge1xuICAgICAgICAgIGVycm9yVGV4dCArPSBgXG5Zb3UgYWxyZWFkeSBhZGRlZCB0aGUgcGxhdGZvcm0ke3RoaXMuY29uZmlnLmdlbmVyYXRvci5iaW5hcnlUYXJnZXRzLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJ9ICR7dGhpcy5jb25maWcuZ2VuZXJhdG9yLmJpbmFyeVRhcmdldHMubWFwKCh0KSA9PiBgXCIke2ltcG9ydF9jaGFsazQuZGVmYXVsdC5ib2xkKHQudmFsdWUpfVwiYCkuam9pbihcIiwgXCIpfSB0byB0aGUgXCIke2ltcG9ydF9jaGFsazQuZGVmYXVsdC51bmRlcmxpbmUoXCJnZW5lcmF0b3JcIil9XCIgYmxvY2tcbmluIHRoZSBcInNjaGVtYS5wcmlzbWFcIiBmaWxlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3ByaXMubHkvZC9jbGllbnQtZ2VuZXJhdG9yLFxuYnV0IHNvbWV0aGluZyB3ZW50IHdyb25nLiBUaGF0J3Mgc3Vib3B0aW1hbC5cblxuUGxlYXNlIGNyZWF0ZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXMvbmV3YDtcbiAgICAgICAgICBlcnJvclRleHQgKz0gYGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JUZXh0ICs9IGBcblxuVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBhZGQgdGhlIHBsYXRmb3JtIFwiJHt0aGlzLnBsYXRmb3JtfVwiIHRvIHRoZSBcIiR7aW1wb3J0X2NoYWxrNC5kZWZhdWx0LnVuZGVybGluZShcbiAgICAgICAgICAgIFwiYmluYXJ5VGFyZ2V0c1wiXG4gICAgICAgICAgKX1cIiBhdHRyaWJ1dGUgaW4gdGhlIFwiJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQudW5kZXJsaW5lKFwiZ2VuZXJhdG9yXCIpfVwiIGJsb2NrIGluIHRoZSBcInNjaGVtYS5wcmlzbWFcIiBmaWxlOlxuJHtpbXBvcnRfY2hhbGs0LmRlZmF1bHQuZ3JlZW5CcmlnaHQodGhpcy5nZXRGaXhlZEdlbmVyYXRvcigpKX1cblxuVGhlbiBydW4gXCIke2ltcG9ydF9jaGFsazQuZGVmYXVsdC5ncmVlbkJyaWdodChcInByaXNtYSBnZW5lcmF0ZVwiKX1cIiBmb3IgeW91ciBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LlxuUmVhZCBtb3JlIGFib3V0IGRlcGxveWluZyBQcmlzbWEgQ2xpZW50OiBodHRwczovL3ByaXMubHkvZC9jbGllbnQtZ2VuZXJhdG9yYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JUZXh0ICs9IGBcblxuUmVhZCBtb3JlIGFib3V0IGRlcGxveWluZyBQcmlzbWEgQ2xpZW50OiBodHRwczovL3ByaXMubHkvZC9jbGllbnQtZ2VuZXJhdG9yXG5gO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoZXJyb3JUZXh0LCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybSA9IChfZCA9IHRoaXMucGxhdGZvcm0pICE9IG51bGwgPyBfZCA6IGF3YWl0IGdldFBsYXRmb3JtKCk7XG4gICAgcmV0dXJuIGVuZ2luZVBhdGgyO1xuICB9XG4gIGFzeW5jIHJlc29sdmVFbmdpbmVQYXRoKCkge1xuICAgIHZhciBfYTMsIF9iMiwgX2MsIF9kO1xuICAgIGNvbnN0IHNlYXJjaGVkTG9jYXRpb25zID0gW107XG4gICAgbGV0IGVuZ2luZVBhdGg7XG4gICAgaWYgKHRoaXMubGliUXVlcnlFbmdpbmVQYXRoKSB7XG4gICAgICByZXR1cm4geyBlbmdpbmVQYXRoOiB0aGlzLmxpYlF1ZXJ5RW5naW5lUGF0aCwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgICB9XG4gICAgdGhpcy5wbGF0Zm9ybSA9IChfYTMgPSB0aGlzLnBsYXRmb3JtKSAhPSBudWxsID8gX2EzIDogYXdhaXQgZ2V0UGxhdGZvcm0oKTtcbiAgICBpZiAoX19maWxlbmFtZS5pbmNsdWRlcyhcIkRlZmF1bHRMaWJyYXJ5TG9hZGVyXCIpKSB7XG4gICAgICBlbmdpbmVQYXRoID0gaW1wb3J0X3BhdGgzLmRlZmF1bHQuam9pbihnZXRFbmdpbmVzUGF0aCgpLCBnZXROb2RlQVBJTmFtZSh0aGlzLnBsYXRmb3JtLCBcImZzXCIpKTtcbiAgICAgIHJldHVybiB7IGVuZ2luZVBhdGgsIHNlYXJjaGVkTG9jYXRpb25zIH07XG4gICAgfVxuICAgIGNvbnN0IGRpcm5hbWUgPSBldmFsKFwiX19kaXJuYW1lXCIpO1xuICAgIGNvbnN0IHNlYXJjaExvY2F0aW9ucyA9IFtcbiAgICAgIGltcG9ydF9wYXRoMy5kZWZhdWx0LnJlc29sdmUoZGlybmFtZSwgXCIuLi8uLi8uLi8ucHJpc21hL2NsaWVudFwiKSxcbiAgICAgIChfZCA9IChfYyA9IChfYjIgPSB0aGlzLmNvbmZpZy5nZW5lcmF0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2MudmFsdWUpICE9IG51bGwgPyBfZCA6IGRpcm5hbWUsXG4gICAgICBpbXBvcnRfcGF0aDMuZGVmYXVsdC5yZXNvbHZlKGRpcm5hbWUsIFwiLi5cIiksXG4gICAgICBpbXBvcnRfcGF0aDMuZGVmYXVsdC5kaXJuYW1lKHRoaXMuY29uZmlnLmRhdGFtb2RlbFBhdGgpLFxuICAgICAgdGhpcy5jb25maWcuY3dkLFxuICAgICAgXCIvdG1wL3ByaXNtYS1lbmdpbmVzXCJcbiAgICBdO1xuICAgIGlmICh0aGlzLmNvbmZpZy5kaXJuYW1lKSB7XG4gICAgICBzZWFyY2hMb2NhdGlvbnMucHVzaCh0aGlzLmNvbmZpZy5kaXJuYW1lKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBzZWFyY2hMb2NhdGlvbnMpIHtcbiAgICAgIHNlYXJjaGVkTG9jYXRpb25zLnB1c2gobG9jYXRpb24pO1xuICAgICAgZGVidWc3KGBTZWFyY2hpbmcgZm9yIFF1ZXJ5IEVuZ2luZSBMaWJyYXJ5IGluICR7bG9jYXRpb259YCk7XG4gICAgICBlbmdpbmVQYXRoID0gaW1wb3J0X3BhdGgzLmRlZmF1bHQuam9pbihsb2NhdGlvbiwgZ2V0Tm9kZUFQSU5hbWUodGhpcy5wbGF0Zm9ybSwgXCJmc1wiKSk7XG4gICAgICBpZiAoaW1wb3J0X2ZzNS5kZWZhdWx0LmV4aXN0c1N5bmMoZW5naW5lUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5naW5lUGF0aCwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZW5naW5lUGF0aCA9IGltcG9ydF9wYXRoMy5kZWZhdWx0LmpvaW4oX19kaXJuYW1lLCBnZXROb2RlQVBJTmFtZSh0aGlzLnBsYXRmb3JtLCBcImZzXCIpKTtcbiAgICByZXR1cm4geyBlbmdpbmVQYXRoOiBlbmdpbmVQYXRoICE9IG51bGwgPyBlbmdpbmVQYXRoIDogXCJcIiwgc2VhcmNoZWRMb2NhdGlvbnMgfTtcbiAgfVxuICBnZXRGaXhlZEdlbmVyYXRvcigpIHtcbiAgICBjb25zdCBmaXhlZEdlbmVyYXRvciA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLmdlbmVyYXRvcixcbiAgICAgIGJpbmFyeVRhcmdldHM6IGZpeEJpbmFyeVRhcmdldHModGhpcy5jb25maWcuZ2VuZXJhdG9yLmJpbmFyeVRhcmdldHMsIHRoaXMucGxhdGZvcm0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJpbnRHZW5lcmF0b3JDb25maWcoZml4ZWRHZW5lcmF0b3IpO1xuICB9XG59O1xuX19uYW1lKERlZmF1bHRMaWJyYXJ5TG9hZGVyLCBcIkRlZmF1bHRMaWJyYXJ5TG9hZGVyXCIpO1xuXG4vLyAuLi9lbmdpbmUtY29yZS9zcmMvbGlicmFyeS9FeGl0SG9va3MudHNcbnZhciBkZWJ1ZzggPSBzcmNfZGVmYXVsdChcInByaXNtYTpjbGllbnQ6bGlicmFyeUVuZ2luZTpleGl0SG9va3NcIik7XG52YXIgRXhpdEhvb2tzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5leHRPd25lcklkID0gMTtcbiAgICB0aGlzLm93bmVyVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuaWRUb0xpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmFyZUhvb2tzSW5zdGFsbGVkID0gZmFsc2U7XG4gIH1cbiAgaW5zdGFsbCgpIHtcbiAgICBpZiAodGhpcy5hcmVIb29rc0luc3RhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluc3RhbGxIb29rKFwiYmVmb3JlRXhpdFwiKTtcbiAgICB0aGlzLmluc3RhbGxIb29rKFwiZXhpdFwiKTtcbiAgICB0aGlzLmluc3RhbGxIb29rKFwiU0lHSU5UXCIsIHRydWUpO1xuICAgIHRoaXMuaW5zdGFsbEhvb2soXCJTSUdVU1IyXCIsIHRydWUpO1xuICAgIHRoaXMuaW5zdGFsbEhvb2soXCJTSUdURVJNXCIsIHRydWUpO1xuICAgIHRoaXMuYXJlSG9va3NJbnN0YWxsZWQgPSB0cnVlO1xuICB9XG4gIHNldExpc3RlbmVyKG93bmVyLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgbGV0IGlkID0gdGhpcy5vd25lclRvSWRNYXAuZ2V0KG93bmVyKTtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgaWQgPSB0aGlzLm5leHRPd25lcklkKys7XG4gICAgICAgIHRoaXMub3duZXJUb0lkTWFwLnNldChvd25lciwgaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5pZFRvTGlzdGVuZXJNYXAuc2V0KGlkLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5vd25lclRvSWRNYXAuZ2V0KG93bmVyKTtcbiAgICAgIGlmIChpZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMub3duZXJUb0lkTWFwLmRlbGV0ZShvd25lcik7XG4gICAgICAgIHRoaXMuaWRUb0xpc3RlbmVyTWFwLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldExpc3RlbmVyKG93bmVyKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLm93bmVyVG9JZE1hcC5nZXQob3duZXIpO1xuICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZFRvTGlzdGVuZXJNYXAuZ2V0KGlkKTtcbiAgfVxuICBpbnN0YWxsSG9vayhldmVudCwgc2hvdWxkRXhpdCA9IGZhbHNlKSB7XG4gICAgcHJvY2Vzcy5vbmNlKGV2ZW50LCBhc3luYyAoY29kZSkgPT4ge1xuICAgICAgZGVidWc4KGBleGl0IGV2ZW50IHJlY2VpdmVkOiAke2V2ZW50fWApO1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmlkVG9MaXN0ZW5lck1hcC52YWx1ZXMoKSkge1xuICAgICAgICBhd2FpdCBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5pZFRvTGlzdGVuZXJNYXAuY2xlYXIoKTtcbiAgICAgIGlmIChzaG91bGRFeGl0ICYmIHByb2Nlc3MubGlzdGVuZXJDb3VudChldmVudCkgPT09IDApIHtcbiAgICAgICAgcHJvY2Vzcy5leGl0KGNvZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuX19uYW1lKEV4aXRIb29rcywgXCJFeGl0SG9va3NcIik7XG5cbi8vIC4uL2VuZ2luZS1jb3JlL3NyYy9saWJyYXJ5L0xpYnJhcnlFbmdpbmUudHNcbnZhciBkZWJ1ZzkgPSBzcmNfZGVmYXVsdChcInByaXNtYTpjbGllbnQ6bGlicmFyeUVuZ2luZVwiKTtcbmZ1bmN0aW9uIGlzUXVlcnlFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnRbXCJpdGVtX3R5cGVcIl0gPT09IFwicXVlcnlcIiAmJiBcInF1ZXJ5XCIgaW4gZXZlbnQ7XG59XG5fX25hbWUoaXNRdWVyeUV2ZW50LCBcImlzUXVlcnlFdmVudFwiKTtcbmZ1bmN0aW9uIGlzUGFuaWNFdmVudChldmVudCkge1xuICBpZiAoXCJsZXZlbFwiIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmxldmVsID09PSBcImVycm9yXCIgJiYgZXZlbnRbXCJtZXNzYWdlXCJdID09PSBcIlBBTklDXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5fX25hbWUoaXNQYW5pY0V2ZW50LCBcImlzUGFuaWNFdmVudFwiKTtcbnZhciBrbm93blBsYXRmb3JtczIgPSBbLi4ucGxhdGZvcm1zLCBcIm5hdGl2ZVwiXTtcbnZhciBlbmdpbmVJbnN0YW5jZUNvdW50ID0gMDtcbnZhciBleGl0SG9va3MgPSBuZXcgRXhpdEhvb2tzKCk7XG52YXIgTGlicmFyeUVuZ2luZSA9IGNsYXNzIGV4dGVuZHMgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoY29uZmlnMiwgbG9hZGVyID0gbmV3IERlZmF1bHRMaWJyYXJ5TG9hZGVyKGNvbmZpZzIpKSB7XG4gICAgdmFyIF9hMywgX2IyO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kYXRhbW9kZWwgPSBpbXBvcnRfZnM2LmRlZmF1bHQucmVhZEZpbGVTeW5jKGNvbmZpZzIuZGF0YW1vZGVsUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZzI7XG4gICAgdGhpcy5saWJyYXJ5U3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubG9nUXVlcmllcyA9IChfYTMgPSBjb25maWcyLmxvZ1F1ZXJpZXMpICE9IG51bGwgPyBfYTMgOiBmYWxzZTtcbiAgICB0aGlzLmxvZ0xldmVsID0gKF9iMiA9IGNvbmZpZzIubG9nTGV2ZWwpICE9IG51bGwgPyBfYjIgOiBcImVycm9yXCI7XG4gICAgdGhpcy5saWJyYXJ5TG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMubG9nRW1pdHRlciA9IG5ldyBpbXBvcnRfZXZlbnRzMy5kZWZhdWx0KCk7XG4gICAgdGhpcy5sb2dFbWl0dGVyLm9uKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICB9KTtcbiAgICB0aGlzLmRhdGFzb3VyY2VPdmVycmlkZXMgPSBjb25maWcyLmRhdGFzb3VyY2VzID8gdGhpcy5jb252ZXJ0RGF0YXNvdXJjZXMoY29uZmlnMi5kYXRhc291cmNlcykgOiB7fTtcbiAgICBpZiAoY29uZmlnMi5lbmFibGVEZWJ1Z0xvZ3MpIHtcbiAgICAgIHRoaXMubG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgfVxuICAgIHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlID0gdGhpcy5pbnN0YW50aWF0ZUxpYnJhcnkoKTtcbiAgICBleGl0SG9va3MuaW5zdGFsbCgpO1xuICAgIHRoaXMuY2hlY2tGb3JUb29NYW55RW5naW5lcygpO1xuICB9XG4gIGdldCBiZWZvcmVFeGl0TGlzdGVuZXIoKSB7XG4gICAgcmV0dXJuIGV4aXRIb29rcy5nZXRMaXN0ZW5lcih0aGlzKTtcbiAgfVxuICBzZXQgYmVmb3JlRXhpdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgZXhpdEhvb2tzLnNldExpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfVxuICBjaGVja0ZvclRvb01hbnlFbmdpbmVzKCkge1xuICAgIGlmIChlbmdpbmVJbnN0YW5jZUNvdW50ID09PSAxMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtpbXBvcnRfY2hhbGs1LmRlZmF1bHQueWVsbG93KFwid2FybihwcmlzbWEtY2xpZW50KVwiKX0gVGhlcmUgYXJlIGFscmVhZHkgMTAgaW5zdGFuY2VzIG9mIFByaXNtYSBDbGllbnQgYWN0aXZlbHkgcnVubmluZy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyB0cmFuc2FjdGlvbihhY3Rpb24sIGhlYWRlcnMsIGFyZzIpIHtcbiAgICB2YXIgX2EzLCBfYjIsIF9jLCBfZCwgX2U7XG4gICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgIGNvbnN0IGhlYWRlclN0ciA9IEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBjb25zdCBqc29uT3B0aW9ucyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbWF4X3dhaXQ6IChfYTMgPSBhcmcyID09IG51bGwgPyB2b2lkIDAgOiBhcmcyLm1heFdhaXQpICE9IG51bGwgPyBfYTMgOiAyZTMsXG4gICAgICAgIHRpbWVvdXQ6IChfYjIgPSBhcmcyID09IG51bGwgPyB2b2lkIDAgOiBhcmcyLnRpbWVvdXQpICE9IG51bGwgPyBfYjIgOiA1ZTMsXG4gICAgICAgIGlzb2xhdGlvbl9sZXZlbDogYXJnMiA9PSBudWxsID8gdm9pZCAwIDogYXJnMi5pc29sYXRpb25MZXZlbFxuICAgICAgfSk7XG4gICAgICByZXN1bHQgPSBhd2FpdCAoKF9jID0gdGhpcy5lbmdpbmUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdGFydFRyYW5zYWN0aW9uKGpzb25PcHRpb25zLCBoZWFkZXJTdHIpKTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJjb21taXRcIikge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgKChfZCA9IHRoaXMuZW5naW5lKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY29tbWl0VHJhbnNhY3Rpb24oYXJnMi5pZCwgaGVhZGVyU3RyKSk7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicm9sbGJhY2tcIikge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgKChfZSA9IHRoaXMuZW5naW5lKSA9PSBudWxsID8gdm9pZCAwIDogX2Uucm9sbGJhY2tUcmFuc2FjdGlvbihhcmcyLmlkLCBoZWFkZXJTdHIpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnBhcnNlRW5naW5lUmVzcG9uc2UocmVzdWx0KTtcbiAgICBpZiAocmVzcG9uc2UuZXJyb3JfY29kZSlcbiAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBpbnN0YW50aWF0ZUxpYnJhcnkoKSB7XG4gICAgZGVidWc5KFwiaW50ZXJuYWxTZXR1cFwiKTtcbiAgICBpZiAodGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgYXdhaXQgaXNOb2RlQVBJU3VwcG9ydGVkKCk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm0oKTtcbiAgICBhd2FpdCB0aGlzLmxvYWRFbmdpbmUoKTtcbiAgICB0aGlzLnZlcnNpb24oKTtcbiAgfVxuICBhc3luYyBnZXRQbGF0Zm9ybSgpIHtcbiAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgIHJldHVybiB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IHBsYXRmb3JtMyA9IGF3YWl0IGdldFBsYXRmb3JtKCk7XG4gICAgaWYgKCFrbm93blBsYXRmb3JtczIuaW5jbHVkZXMocGxhdGZvcm0zKSkge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoXG4gICAgICAgIGBVbmtub3duICR7aW1wb3J0X2NoYWxrNS5kZWZhdWx0LnJlZChcIlBSSVNNQV9RVUVSWV9FTkdJTkVfTElCUkFSWVwiKX0gJHtpbXBvcnRfY2hhbGs1LmRlZmF1bHQucmVkQnJpZ2h0LmJvbGQoXG4gICAgICAgICAgcGxhdGZvcm0zXG4gICAgICAgICl9LiBQb3NzaWJsZSBiaW5hcnlUYXJnZXRzOiAke2ltcG9ydF9jaGFsazUuZGVmYXVsdC5ncmVlbkJyaWdodChcbiAgICAgICAgICBrbm93blBsYXRmb3JtczIuam9pbihcIiwgXCIpXG4gICAgICAgICl9IG9yIGEgcGF0aCB0byB0aGUgcXVlcnkgZW5naW5lIGxpYnJhcnkuXG5Zb3UgbWF5IGhhdmUgdG8gcnVuICR7aW1wb3J0X2NoYWxrNS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFwicHJpc21hIGdlbmVyYXRlXCIpfSBmb3IgeW91ciBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LmAsXG4gICAgICAgIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwbGF0Zm9ybTM7XG4gIH1cbiAgcGFyc2VFbmdpbmVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKGBSZXNwb25zZSBmcm9tIHRoZSBFbmdpbmUgd2FzIGVtcHR5YCwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25maWcyID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICByZXR1cm4gY29uZmlnMjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKGBVbmFibGUgdG8gSlNPTi5wYXJzZSByZXNwb25zZSBmcm9tIGVuZ2luZWAsIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgIH1cbiAgfVxuICBjb252ZXJ0RGF0YXNvdXJjZXMoZGF0YXNvdXJjZXMpIHtcbiAgICBjb25zdCBvYmogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdXJsIH0gb2YgZGF0YXNvdXJjZXMpIHtcbiAgICAgIG9ialtuYW1lXSA9IHVybDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBhc3luYyBsb2FkRW5naW5lKCkge1xuICAgIHZhciBfYTM7XG4gICAgaWYgKCF0aGlzLmVuZ2luZSkge1xuICAgICAgaWYgKCF0aGlzLlF1ZXJ5RW5naW5lQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5saWJyYXJ5ID0gYXdhaXQgdGhpcy5saWJyYXJ5TG9hZGVyLmxvYWRMaWJyYXJ5KCk7XG4gICAgICAgIHRoaXMuUXVlcnlFbmdpbmVDb25zdHJ1Y3RvciA9IHRoaXMubGlicmFyeS5RdWVyeUVuZ2luZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdlYWtUaGlzID0gbmV3IFdlYWtSZWYodGhpcyk7XG4gICAgICAgIHRoaXMuZW5naW5lID0gbmV3IHRoaXMuUXVlcnlFbmdpbmVDb25zdHJ1Y3RvcihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhbW9kZWw6IHRoaXMuZGF0YW1vZGVsLFxuICAgICAgICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgICAgICAgIGxvZ1F1ZXJpZXM6IChfYTMgPSB0aGlzLmNvbmZpZy5sb2dRdWVyaWVzKSAhPSBudWxsID8gX2EzIDogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVFbnZWYXJFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YXNvdXJjZU92ZXJyaWRlczogdGhpcy5kYXRhc291cmNlT3ZlcnJpZGVzLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMubG9nTGV2ZWwsXG4gICAgICAgICAgICBjb25maWdEaXI6IHRoaXMuY29uZmlnLmN3ZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGxvZzQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTQ7XG4gICAgICAgICAgICAoX2E0ID0gd2Vha1RoaXMuZGVyZWYoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hNC5sb2dnZXIobG9nNCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBlbmdpbmVJbnN0YW5jZUNvdW50Kys7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBjb25zdCBlID0gX2U7XG4gICAgICAgIGNvbnN0IGVycm9yMiA9IHRoaXMucGFyc2VJbml0RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcjIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKGVycm9yMi5tZXNzYWdlLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uLCBlcnJvcjIuZXJyb3JfY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nZ2VyKGxvZzQpIHtcbiAgICB2YXIgX2EzO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKGxvZzQpO1xuICAgIGlmICghZXZlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKFwic3BhblwiIGluIGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5jb25maWcudHJhY2luZ0NvbmZpZy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZvaWQgY3JlYXRlU3BhbihldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LmxldmVsID0gKF9hMyA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5sZXZlbC50b0xvd2VyQ2FzZSgpKSAhPSBudWxsID8gX2EzIDogXCJ1bmtub3duXCI7XG4gICAgaWYgKGlzUXVlcnlFdmVudChldmVudCkpIHtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwicXVlcnlcIiwge1xuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHF1ZXJ5OiBldmVudC5xdWVyeSxcbiAgICAgICAgcGFyYW1zOiBldmVudC5wYXJhbXMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIoZXZlbnQuZHVyYXRpb25fbXMpLFxuICAgICAgICB0YXJnZXQ6IGV2ZW50Lm1vZHVsZV9wYXRoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzUGFuaWNFdmVudChldmVudCkpIHtcbiAgICAgIHRoaXMubG9nZ2VyUnVzdFBhbmljID0gbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKFxuICAgICAgICB0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKFxuICAgICAgICAgIGAke2V2ZW50Lm1lc3NhZ2V9OiAke2V2ZW50LnJlYXNvbn0gaW4gJHtldmVudC5maWxlfToke2V2ZW50LmxpbmV9OiR7ZXZlbnQuY29sdW1ufWBcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvblxuICAgICAgKTtcbiAgICAgIHRoaXMubG9nRW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgdGhpcy5sb2dnZXJSdXN0UGFuaWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIuZW1pdChldmVudC5sZXZlbCwge1xuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgIHRhcmdldDogZXZlbnQubW9kdWxlX3BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRFcnJvck1lc3NhZ2VXaXRoTGluayh0aXRsZSkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIGdldEVycm9yTWVzc2FnZVdpdGhMaW5rKHtcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgdGl0bGUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uLFxuICAgICAgZW5naW5lVmVyc2lvbjogKF9hMyA9IHRoaXMudmVyc2lvbkluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29tbWl0LFxuICAgICAgZGF0YWJhc2U6IHRoaXMuY29uZmlnLmFjdGl2ZVByb3ZpZGVyLFxuICAgICAgcXVlcnk6IHRoaXMubGFzdFF1ZXJ5XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VJbml0RXJyb3Ioc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVycm9yMiA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgIHJldHVybiBlcnJvcjI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHBhcnNlUmVxdWVzdEVycm9yKHN0cikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlcnJvcjIgPSBKU09OLnBhcnNlKHN0cik7XG4gICAgICByZXR1cm4gZXJyb3IyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmVmb3JlRXhpdFwiKSB7XG4gICAgICB0aGlzLmJlZm9yZUV4aXRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ0VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgYXdhaXQgdGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2U7XG4gICAgYXdhaXQgdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlO1xuICAgIGlmICh0aGlzLmxpYnJhcnlTdGFydGluZ1Byb21pc2UpIHtcbiAgICAgIGRlYnVnOShgbGlicmFyeSBhbHJlYWR5IHN0YXJ0aW5nLCB0aGlzLmxpYnJhcnlTdGFydGVkOiAke3RoaXMubGlicmFyeVN0YXJ0ZWR9YCk7XG4gICAgICByZXR1cm4gdGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5saWJyYXJ5U3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEZuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgZGVidWc5KFwibGlicmFyeSBzdGFydGluZ1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgdHJhY2VwYXJlbnQ6IGdldFRyYWNlUGFyZW50KHsgdHJhY2luZ0NvbmZpZzogdGhpcy5jb25maWcudHJhY2luZ0NvbmZpZyB9KVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCAoKF9hMyA9IHRoaXMuZW5naW5lKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNvbm5lY3QoSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpKTtcbiAgICAgICAgdGhpcy5saWJyYXJ5U3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGRlYnVnOShcImxpYnJhcnkgc3RhcnRlZFwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjIgPSB0aGlzLnBhcnNlSW5pdEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcjIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IoZXJyb3IyLm1lc3NhZ2UsIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24sIGVycm9yMi5lcnJvcl9jb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH0sIFwic3RhcnRGblwiKTtcbiAgICBjb25zdCBzcGFuQ29uZmlnID0ge1xuICAgICAgbmFtZTogXCJjb25uZWN0XCIsXG4gICAgICBlbmFibGVkOiB0aGlzLmNvbmZpZy50cmFjaW5nQ29uZmlnLmVuYWJsZWRcbiAgICB9O1xuICAgIHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZSA9IHJ1bkluQ2hpbGRTcGFuKHNwYW5Db25maWcsIHN0YXJ0Rm4pO1xuICAgIHJldHVybiB0aGlzLmxpYnJhcnlTdGFydGluZ1Byb21pc2U7XG4gIH1cbiAgYXN5bmMgc3RvcCgpIHtcbiAgICBhd2FpdCB0aGlzLmxpYnJhcnlTdGFydGluZ1Byb21pc2U7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRpbmdRdWVyeVByb21pc2U7XG4gICAgaWYgKHRoaXMubGlicmFyeVN0b3BwaW5nUHJvbWlzZSkge1xuICAgICAgZGVidWc5KFwibGlicmFyeSBpcyBhbHJlYWR5IHN0b3BwaW5nXCIpO1xuICAgICAgcmV0dXJuIHRoaXMubGlicmFyeVN0b3BwaW5nUHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxpYnJhcnlTdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BGbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDUpKTtcbiAgICAgIGRlYnVnOShcImxpYnJhcnkgc3RvcHBpbmdcIik7XG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICB0cmFjZXBhcmVudDogZ2V0VHJhY2VQYXJlbnQoeyB0cmFjaW5nQ29uZmlnOiB0aGlzLmNvbmZpZy50cmFjaW5nQ29uZmlnIH0pXG4gICAgICB9O1xuICAgICAgYXdhaXQgKChfYTMgPSB0aGlzLmVuZ2luZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5kaXNjb25uZWN0KEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpKSk7XG4gICAgICB0aGlzLmxpYnJhcnlTdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgICBkZWJ1ZzkoXCJsaWJyYXJ5IHN0b3BwZWRcIik7XG4gICAgfSwgXCJzdG9wRm5cIik7XG4gICAgY29uc3Qgc3BhbkNvbmZpZyA9IHtcbiAgICAgIG5hbWU6IFwiZGlzY29ubmVjdFwiLFxuICAgICAgZW5hYmxlZDogdGhpcy5jb25maWcudHJhY2luZ0NvbmZpZy5lbmFibGVkXG4gICAgfTtcbiAgICB0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2UgPSBydW5JbkNoaWxkU3BhbihzcGFuQ29uZmlnLCBzdG9wRm4pO1xuICAgIHJldHVybiB0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2U7XG4gIH1cbiAgYXN5bmMgZ2V0Q29uZmlnKCkge1xuICAgIGF3YWl0IHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlO1xuICAgIHJldHVybiB0aGlzLmxpYnJhcnkuZ2V0Q29uZmlnKHtcbiAgICAgIGRhdGFtb2RlbDogdGhpcy5kYXRhbW9kZWwsXG4gICAgICBkYXRhc291cmNlT3ZlcnJpZGVzOiB0aGlzLmRhdGFzb3VyY2VPdmVycmlkZXMsXG4gICAgICBpZ25vcmVFbnZWYXJFcnJvcnM6IHRydWUsXG4gICAgICBlbnY6IHByb2Nlc3MuZW52XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RG1tZigpIHtcbiAgICBhd2FpdCB0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmxpYnJhcnkuZG1tZih0aGlzLmRhdGFtb2RlbCkpO1xuICB9XG4gIHZlcnNpb24oKSB7XG4gICAgdmFyIF9hMywgX2IyLCBfYztcbiAgICB0aGlzLnZlcnNpb25JbmZvID0gKF9hMyA9IHRoaXMubGlicmFyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy52ZXJzaW9uKCk7XG4gICAgcmV0dXJuIChfYyA9IChfYjIgPSB0aGlzLnZlcnNpb25JbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnZlcnNpb24pICE9IG51bGwgPyBfYyA6IFwidW5rbm93blwiO1xuICB9XG4gIGRlYnVnUGFuaWMobWVzc2FnZSkge1xuICAgIHZhciBfYTM7XG4gICAgcmV0dXJuIChfYTMgPSB0aGlzLmxpYnJhcnkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZGVidWdQYW5pYyhtZXNzYWdlKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHF1ZXJ5MiwgaGVhZGVycyA9IHt9LCBudW1UcnkgPSAxKSB7XG4gICAgdmFyIF9hMywgX2IyO1xuICAgIGRlYnVnOShgc2VuZGluZyByZXF1ZXN0LCB0aGlzLmxpYnJhcnlTdGFydGVkOiAke3RoaXMubGlicmFyeVN0YXJ0ZWR9YCk7XG4gICAgY29uc3QgcmVxdWVzdDIgPSB7IHF1ZXJ5OiBxdWVyeTIsIHZhcmlhYmxlczoge30gfTtcbiAgICBjb25zdCBoZWFkZXJTdHIgPSBKU09OLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICBjb25zdCBxdWVyeVN0ciA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QyKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgICAgdGhpcy5leGVjdXRpbmdRdWVyeVByb21pc2UgPSAoX2EzID0gdGhpcy5lbmdpbmUpID09IG51bGwgPyB2b2lkIDAgOiBfYTMucXVlcnkocXVlcnlTdHIsIGhlYWRlclN0ciwgaGVhZGVycy50cmFuc2FjdGlvbklkKTtcbiAgICAgIHRoaXMubGFzdFF1ZXJ5ID0gcXVlcnlTdHI7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKGF3YWl0IHRoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlKTtcbiAgICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgICBpZiAoZGF0YS5lcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5idWlsZFF1ZXJ5RXJyb3IoZGF0YS5lcnJvcnNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKEpTT04uc3RyaW5naWZ5KGRhdGEuZXJyb3JzKSwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9nZ2VyUnVzdFBhbmljKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyUnVzdFBhbmljO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZWxhcHNlZDogMCB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGUuY29kZSA9PT0gXCJHZW5lcmljRmFpbHVyZVwiICYmICgoX2IyID0gZS5tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnN0YXJ0c1dpdGgoXCJQQU5JQzpcIikpKSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcih0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKGUubWVzc2FnZSksIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IyID0gdGhpcy5wYXJzZVJlcXVlc3RFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgaWYgKHR5cGVvZiBlcnJvcjIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKGAke2Vycm9yMi5tZXNzYWdlfVxuJHtlcnJvcjIuYmFja3RyYWNlfWAsIHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyByZXF1ZXN0QmF0Y2gocXVlcmllcywgaGVhZGVycyA9IHt9LCB0cmFuc2FjdGlvbiA9IGZhbHNlLCBudW1UcnkgPSAxKSB7XG4gICAgZGVidWc5KFwicmVxdWVzdEJhdGNoXCIpO1xuICAgIGNvbnN0IHJlcXVlc3QyID0ge1xuICAgICAgYmF0Y2g6IHF1ZXJpZXMubWFwKChxdWVyeTIpID0+ICh7IHF1ZXJ5OiBxdWVyeTIsIHZhcmlhYmxlczoge30gfSkpLFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICB0aGlzLmxhc3RRdWVyeSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QyKTtcbiAgICB0aGlzLmV4ZWN1dGluZ1F1ZXJ5UHJvbWlzZSA9IHRoaXMuZW5naW5lLnF1ZXJ5KHRoaXMubGFzdFF1ZXJ5LCBKU09OLnN0cmluZ2lmeShoZWFkZXJzKSwgaGVhZGVycy50cmFuc2FjdGlvbklkKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGluZ1F1ZXJ5UHJvbWlzZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKHJlc3VsdCk7XG4gICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICBpZiAoZGF0YS5lcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRocm93IHRoaXMuYnVpbGRRdWVyeUVycm9yKGRhdGEuZXJyb3JzWzBdKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKEpTT04uc3RyaW5naWZ5KGRhdGEuZXJyb3JzKSwgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IHsgYmF0Y2hSZXN1bHQsIGVycm9ycyB9ID0gZGF0YTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiYXRjaFJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdC5tYXAoKHJlc3VsdDIpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgaWYgKHJlc3VsdDIuZXJyb3JzKSB7XG4gICAgICAgICAgcmV0dXJuIChfYTMgPSB0aGlzLmxvZ2dlclJ1c3RQYW5pYykgIT0gbnVsbCA/IF9hMyA6IHRoaXMuYnVpbGRRdWVyeUVycm9yKGRhdGEuZXJyb3JzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdDIsXG4gICAgICAgICAgZWxhcHNlZDogMFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzWzBdLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfVxuICB9XG4gIGJ1aWxkUXVlcnlFcnJvcihlcnJvcjIpIHtcbiAgICBpZiAoZXJyb3IyLnVzZXJfZmFjaW5nX2Vycm9yLmlzX3BhbmljKSB7XG4gICAgICByZXR1cm4gbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKFxuICAgICAgICB0aGlzLmdldEVycm9yTWVzc2FnZVdpdGhMaW5rKGVycm9yMi51c2VyX2ZhY2luZ19lcnJvci5tZXNzYWdlKSxcbiAgICAgICAgdGhpcy5jb25maWcuY2xpZW50VmVyc2lvblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXNtYUdyYXBoUUxUb0pTRXJyb3IoZXJyb3IyLCB0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uKTtcbiAgfVxuICBhc3luYyBtZXRyaWNzKG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgY29uc3QgcmVzcG9uc2VTdHJpbmcgPSBhd2FpdCB0aGlzLmVuZ2luZS5tZXRyaWNzKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09IFwicHJvbWV0aGV1c1wiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRW5naW5lUmVzcG9uc2UocmVzcG9uc2VTdHJpbmcpO1xuICB9XG59O1xuX19uYW1lKExpYnJhcnlFbmdpbmUsIFwiTGlicmFyeUVuZ2luZVwiKTtcblxuLy8gLi4vaW50ZXJuYWxzL3NyYy91dGlscy90cnlMb2FkRW52cy50c1xudmFyIGltcG9ydF9jaGFsazYgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIGltcG9ydF9kb3RlbnYgPSBfX3RvRVNNKHJlcXVpcmVfbWFpbjIoKSk7XG52YXIgaW1wb3J0X2ZzNyA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfcGF0aDQgPSBfX3RvRVNNKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxuLy8gLi4vaW50ZXJuYWxzL3NyYy9kb3RlbnZFeHBhbmQudHNcbmZ1bmN0aW9uIGRvdGVudkV4cGFuZChjb25maWcyKSB7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gY29uZmlnMi5pZ25vcmVQcm9jZXNzRW52ID8ge30gOiBwcm9jZXNzLmVudjtcbiAgY29uc3QgaW50ZXJwb2xhdGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlbnZWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBlbnZWYWx1ZS5tYXRjaCgvKC4/XFwkeyg/OlthLXpBLVowLTlfXSspP30pL2cpIHx8IFtdO1xuICAgIHJldHVybiBtYXRjaGVzLnJlZHVjZShmdW5jdGlvbihuZXdFbnYsIG1hdGNoKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IC8oLj8pXFwkeyhbYS16QS1aMC05X10rKT99L2cuZXhlYyhtYXRjaCk7XG4gICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgIHJldHVybiBuZXdFbnY7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJ0c1sxXTtcbiAgICAgIGxldCB2YWx1ZSwgcmVwbGFjZVBhcnQ7XG4gICAgICBpZiAocHJlZml4ID09PSBcIlxcXFxcIikge1xuICAgICAgICByZXBsYWNlUGFydCA9IHBhcnRzWzBdO1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VQYXJ0LnJlcGxhY2UoXCJcXFxcJFwiLCBcIiRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJ0c1syXTtcbiAgICAgICAgcmVwbGFjZVBhcnQgPSBwYXJ0c1swXS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHZhbHVlID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZW52aXJvbm1lbnQsIGtleSkgPyBlbnZpcm9ubWVudFtrZXldIDogY29uZmlnMi5wYXJzZWRba2V5XSB8fCBcIlwiO1xuICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdFbnYucmVwbGFjZShyZXBsYWNlUGFydCwgdmFsdWUpO1xuICAgIH0sIGVudlZhbHVlKTtcbiAgfSwgXCJpbnRlcnBvbGF0ZVwiKTtcbiAgZm9yIChjb25zdCBjb25maWdLZXkgaW4gY29uZmlnMi5wYXJzZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudmlyb25tZW50LCBjb25maWdLZXkpID8gZW52aXJvbm1lbnRbY29uZmlnS2V5XSA6IGNvbmZpZzIucGFyc2VkW2NvbmZpZ0tleV07XG4gICAgY29uZmlnMi5wYXJzZWRbY29uZmlnS2V5XSA9IGludGVycG9sYXRlKHZhbHVlKTtcbiAgfVxuICBmb3IgKGNvbnN0IHByb2Nlc3NLZXkgaW4gY29uZmlnMi5wYXJzZWQpIHtcbiAgICBlbnZpcm9ubWVudFtwcm9jZXNzS2V5XSA9IGNvbmZpZzIucGFyc2VkW3Byb2Nlc3NLZXldO1xuICB9XG4gIHJldHVybiBjb25maWcyO1xufVxuX19uYW1lKGRvdGVudkV4cGFuZCwgXCJkb3RlbnZFeHBhbmRcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvdXRpbHMvdHJ5TG9hZEVudnMudHNcbnZhciBkZWJ1ZzEwID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6dHJ5TG9hZEVudlwiKTtcbmZ1bmN0aW9uIHRyeUxvYWRFbnZzKHtcbiAgcm9vdEVudlBhdGgsXG4gIHNjaGVtYUVudlBhdGhcbn0sIG9wdHMgPSB7XG4gIGNvbmZsaWN0Q2hlY2s6IFwibm9uZVwiXG59KSB7XG4gIHZhciBfYTMsIF9iMjtcbiAgY29uc3Qgcm9vdEVudkluZm8gPSBsb2FkRW52KHJvb3RFbnZQYXRoKTtcbiAgaWYgKG9wdHMuY29uZmxpY3RDaGVjayAhPT0gXCJub25lXCIpIHtcbiAgICBjaGVja0ZvckNvbmZsaWN0cyhyb290RW52SW5mbywgc2NoZW1hRW52UGF0aCwgb3B0cy5jb25mbGljdENoZWNrKTtcbiAgfVxuICBsZXQgc2NoZW1hRW52SW5mbyA9IG51bGw7XG4gIGlmICghcGF0aHNFcXVhbChyb290RW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogcm9vdEVudkluZm8ucGF0aCwgc2NoZW1hRW52UGF0aCkpIHtcbiAgICBzY2hlbWFFbnZJbmZvID0gbG9hZEVudihzY2hlbWFFbnZQYXRoKTtcbiAgfVxuICBpZiAoIXJvb3RFbnZJbmZvICYmICFzY2hlbWFFbnZJbmZvKSB7XG4gICAgZGVidWcxMChcIk5vIEVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWRcIik7XG4gIH1cbiAgaWYgKHNjaGVtYUVudkluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHNjaGVtYUVudkluZm8uZG90ZW52UmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoaW1wb3J0X2NoYWxrNi5kZWZhdWx0LnJlZEJyaWdodC5ib2xkKFwiU2NoZW1hIEVudiBFcnJvcjogXCIpICsgc2NoZW1hRW52SW5mby5kb3RlbnZSZXN1bHQuZXJyb3IpO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2VzID0gW3Jvb3RFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiByb290RW52SW5mby5tZXNzYWdlLCBzY2hlbWFFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiBzY2hlbWFFbnZJbmZvLm1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKFwiXFxuXCIpLFxuICAgIHBhcnNlZDoge1xuICAgICAgLi4uKF9hMyA9IHJvb3RFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiByb290RW52SW5mby5kb3RlbnZSZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMucGFyc2VkLFxuICAgICAgLi4uKF9iMiA9IHNjaGVtYUVudkluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHNjaGVtYUVudkluZm8uZG90ZW52UmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnBhcnNlZFxuICAgIH1cbiAgfTtcbn1cbl9fbmFtZSh0cnlMb2FkRW52cywgXCJ0cnlMb2FkRW52c1wiKTtcbmZ1bmN0aW9uIGNoZWNrRm9yQ29uZmxpY3RzKHJvb3RFbnZJbmZvLCBlbnZQYXRoLCB0eXBlKSB7XG4gIGNvbnN0IHBhcnNlZFJvb3RFbnYgPSByb290RW52SW5mbyA9PSBudWxsID8gdm9pZCAwIDogcm9vdEVudkluZm8uZG90ZW52UmVzdWx0LnBhcnNlZDtcbiAgY29uc3QgYXJlTm90VGhlU2FtZSA9ICFwYXRoc0VxdWFsKHJvb3RFbnZJbmZvID09IG51bGwgPyB2b2lkIDAgOiByb290RW52SW5mby5wYXRoLCBlbnZQYXRoKTtcbiAgaWYgKHBhcnNlZFJvb3RFbnYgJiYgZW52UGF0aCAmJiBhcmVOb3RUaGVTYW1lICYmIGltcG9ydF9mczcuZGVmYXVsdC5leGlzdHNTeW5jKGVudlBhdGgpKSB7XG4gICAgY29uc3QgZW52Q29uZmlnID0gaW1wb3J0X2RvdGVudi5kZWZhdWx0LnBhcnNlKGltcG9ydF9mczcuZGVmYXVsdC5yZWFkRmlsZVN5bmMoZW52UGF0aCkpO1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBlbnZDb25maWcpIHtcbiAgICAgIGlmIChwYXJzZWRSb290RW52W2tdID09PSBlbnZDb25maWdba10pIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVsYXRpdmVSb290RW52UGF0aCA9IGltcG9ydF9wYXRoNC5kZWZhdWx0LnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIHJvb3RFbnZJbmZvLnBhdGgpO1xuICAgICAgY29uc3QgcmVsYXRpdmVFbnZQYXRoID0gaW1wb3J0X3BhdGg0LmRlZmF1bHQucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgZW52UGF0aCk7XG4gICAgICBpZiAodHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlcmUgaXMgYSBjb25mbGljdCBiZXR3ZWVuIGVudiB2YXIke2NvbmZsaWN0cy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSBpbiAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC51bmRlcmxpbmUoXG4gICAgICAgICAgcmVsYXRpdmVSb290RW52UGF0aFxuICAgICAgICApfSBhbmQgJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQudW5kZXJsaW5lKHJlbGF0aXZlRW52UGF0aCl9XG5Db25mbGljdGluZyBlbnYgdmFyczpcbiR7Y29uZmxpY3RzLm1hcCgoY29uZmxpY3QpID0+IGAgICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LmJvbGQoY29uZmxpY3QpfWApLmpvaW4oXCJcXG5cIil9XG5cbldlIHN1Z2dlc3QgdG8gbW92ZSB0aGUgY29udGVudHMgb2YgJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQudW5kZXJsaW5lKHJlbGF0aXZlRW52UGF0aCl9IHRvICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShcbiAgICAgICAgICByZWxhdGl2ZVJvb3RFbnZQYXRoXG4gICAgICAgICl9IHRvIGNvbnNvbGlkYXRlIHlvdXIgZW52IHZhcnMuXG5gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwid2FyblwiKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ29uZmxpY3QgZm9yIGVudiB2YXIke2NvbmZsaWN0cy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSAke2NvbmZsaWN0cy5tYXAoKGMpID0+IGltcG9ydF9jaGFsazYuZGVmYXVsdC5ib2xkKGMpKS5qb2luKFwiLCBcIil9IGluICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShyZWxhdGl2ZVJvb3RFbnZQYXRoKX0gYW5kICR7aW1wb3J0X2NoYWxrNi5kZWZhdWx0LnVuZGVybGluZShyZWxhdGl2ZUVudlBhdGgpfVxuRW52IHZhcnMgZnJvbSAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC51bmRlcmxpbmUocmVsYXRpdmVFbnZQYXRoKX0gb3ZlcndyaXRlIHRoZSBvbmVzIGZyb20gJHtpbXBvcnRfY2hhbGs2LmRlZmF1bHQudW5kZXJsaW5lKHJlbGF0aXZlUm9vdEVudlBhdGgpfVxuICAgICAgYDtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ltcG9ydF9jaGFsazYuZGVmYXVsdC55ZWxsb3coXCJ3YXJuKHByaXNtYSlcIil9ICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbl9fbmFtZShjaGVja0ZvckNvbmZsaWN0cywgXCJjaGVja0ZvckNvbmZsaWN0c1wiKTtcbmZ1bmN0aW9uIGxvYWRFbnYoZW52UGF0aCkge1xuICBpZiAoZXhpc3RzMyhlbnZQYXRoKSkge1xuICAgIGRlYnVnMTAoYEVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQgZnJvbSAke2VudlBhdGh9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvdGVudlJlc3VsdDogZG90ZW52RXhwYW5kKFxuICAgICAgICBpbXBvcnRfZG90ZW52LmRlZmF1bHQuY29uZmlnKHtcbiAgICAgICAgICBwYXRoOiBlbnZQYXRoLFxuICAgICAgICAgIGRlYnVnOiBwcm9jZXNzLmVudi5ET1RFTlZfQ09ORklHX0RFQlVHID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2U6IGltcG9ydF9jaGFsazYuZGVmYXVsdC5kaW0oYEVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQgZnJvbSAke2ltcG9ydF9wYXRoNC5kZWZhdWx0LnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIGVudlBhdGgpfWApLFxuICAgICAgcGF0aDogZW52UGF0aFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcxMChgRW52aXJvbm1lbnQgdmFyaWFibGVzIG5vdCBmb3VuZCBhdCAke2VudlBhdGh9YCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5fX25hbWUobG9hZEVudiwgXCJsb2FkRW52XCIpO1xuZnVuY3Rpb24gcGF0aHNFcXVhbChwYXRoMSwgcGF0aDIyKSB7XG4gIHJldHVybiBwYXRoMSAmJiBwYXRoMjIgJiYgaW1wb3J0X3BhdGg0LmRlZmF1bHQucmVzb2x2ZShwYXRoMSkgPT09IGltcG9ydF9wYXRoNC5kZWZhdWx0LnJlc29sdmUocGF0aDIyKTtcbn1cbl9fbmFtZShwYXRoc0VxdWFsLCBcInBhdGhzRXF1YWxcIik7XG5mdW5jdGlvbiBleGlzdHMzKHApIHtcbiAgcmV0dXJuIEJvb2xlYW4ocCAmJiBpbXBvcnRfZnM3LmRlZmF1bHQuZXhpc3RzU3luYyhwKSk7XG59XG5fX25hbWUoZXhpc3RzMywgXCJleGlzdHNcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvY2xpZW50L2dldENsaWVudEVuZ2luZVR5cGUudHNcbnZhciBERUZBVUxUX0NMSUVOVF9FTkdJTkVfVFlQRSA9IFwibGlicmFyeVwiIC8qIExpYnJhcnkgKi87XG5mdW5jdGlvbiBnZXRDbGllbnRFbmdpbmVUeXBlKGdlbmVyYXRvckNvbmZpZykge1xuICBjb25zdCBlbmdpbmVUeXBlRnJvbUVudlZhciA9IGdldEVuZ2luZVR5cGVGcm9tRW52VmFyKCk7XG4gIGlmIChlbmdpbmVUeXBlRnJvbUVudlZhcilcbiAgICByZXR1cm4gZW5naW5lVHlwZUZyb21FbnZWYXI7XG4gIGlmICgoZ2VuZXJhdG9yQ29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBnZW5lcmF0b3JDb25maWcuY29uZmlnLmVuZ2luZVR5cGUpID09PSBcImxpYnJhcnlcIiAvKiBMaWJyYXJ5ICovKSB7XG4gICAgcmV0dXJuIFwibGlicmFyeVwiIC8qIExpYnJhcnkgKi87XG4gIH0gZWxzZSBpZiAoKGdlbmVyYXRvckNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogZ2VuZXJhdG9yQ29uZmlnLmNvbmZpZy5lbmdpbmVUeXBlKSA9PT0gXCJiaW5hcnlcIiAvKiBCaW5hcnkgKi8pIHtcbiAgICByZXR1cm4gXCJiaW5hcnlcIiAvKiBCaW5hcnkgKi87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQ0xJRU5UX0VOR0lORV9UWVBFO1xuICB9XG59XG5fX25hbWUoZ2V0Q2xpZW50RW5naW5lVHlwZSwgXCJnZXRDbGllbnRFbmdpbmVUeXBlXCIpO1xuZnVuY3Rpb24gZ2V0RW5naW5lVHlwZUZyb21FbnZWYXIoKSB7XG4gIGNvbnN0IGVuZ2luZVR5cGUgPSBwcm9jZXNzLmVudi5QUklTTUFfQ0xJRU5UX0VOR0lORV9UWVBFO1xuICBpZiAoZW5naW5lVHlwZSA9PT0gXCJsaWJyYXJ5XCIgLyogTGlicmFyeSAqLykge1xuICAgIHJldHVybiBcImxpYnJhcnlcIiAvKiBMaWJyYXJ5ICovO1xuICB9IGVsc2UgaWYgKGVuZ2luZVR5cGUgPT09IFwiYmluYXJ5XCIgLyogQmluYXJ5ICovKSB7XG4gICAgcmV0dXJuIFwiYmluYXJ5XCIgLyogQmluYXJ5ICovO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbl9fbmFtZShnZXRFbmdpbmVUeXBlRnJvbUVudlZhciwgXCJnZXRFbmdpbmVUeXBlRnJvbUVudlZhclwiKTtcblxuLy8gLi4vaW50ZXJuYWxzL3NyYy9jbGkvdXRpbHMudHNcbnZhciBpbXBvcnRfYXJnID0gX190b0VTTShyZXF1aXJlX2FyZygpKTtcbnZhciBpbXBvcnRfc3RyaXBfaW5kZW50ID0gX190b0VTTShyZXF1aXJlX3N0cmlwX2luZGVudCgpKTtcbmZ1bmN0aW9uIGlzRXJyb3IocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbl9fbmFtZShpc0Vycm9yLCBcImlzRXJyb3JcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvbG9nZ2VyLnRzXG52YXIgbG9nZ2VyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxvZ2dlcl9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcixcbiAgaW5mbzogKCkgPT4gaW5mbyxcbiAgbG9nOiAoKSA9PiBsb2czLFxuICBxdWVyeTogKCkgPT4gcXVlcnksXG4gIHNob3VsZDogKCkgPT4gc2hvdWxkLFxuICB0YWdzOiAoKSA9PiB0YWdzLFxuICB3YXJuOiAoKSA9PiB3YXJuXG59KTtcbnZhciBpbXBvcnRfY2hhbGs3ID0gX190b0VTTShyZXF1aXJlX3NvdXJjZSgpKTtcbnZhciB0YWdzID0ge1xuICBlcnJvcjogaW1wb3J0X2NoYWxrNy5kZWZhdWx0LnJlZChcInByaXNtYTplcnJvclwiKSxcbiAgd2FybjogaW1wb3J0X2NoYWxrNy5kZWZhdWx0LnllbGxvdyhcInByaXNtYTp3YXJuXCIpLFxuICBpbmZvOiBpbXBvcnRfY2hhbGs3LmRlZmF1bHQuY3lhbihcInByaXNtYTppbmZvXCIpLFxuICBxdWVyeTogaW1wb3J0X2NoYWxrNy5kZWZhdWx0LmJsdWUoXCJwcmlzbWE6cXVlcnlcIilcbn07XG52YXIgc2hvdWxkID0ge1xuICB3YXJuOiAhcHJvY2Vzcy5lbnYuUFJJU01BX0RJU0FCTEVfV0FSTklOR1Ncbn07XG5mdW5jdGlvbiBsb2czKC4uLmRhdGEpIHtcbiAgY29uc29sZS5sb2coLi4uZGF0YSk7XG59XG5fX25hbWUobG9nMywgXCJsb2dcIik7XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gIGlmIChzaG91bGQud2Fybikge1xuICAgIGNvbnNvbGUud2FybihgJHt0YWdzLndhcm59ICR7bWVzc2FnZX1gLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gIH1cbn1cbl9fbmFtZSh3YXJuLCBcIndhcm5cIik7XG5mdW5jdGlvbiBpbmZvKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gIGNvbnNvbGUuaW5mbyhgJHt0YWdzLmluZm99ICR7bWVzc2FnZX1gLCAuLi5vcHRpb25hbFBhcmFtcyk7XG59XG5fX25hbWUoaW5mbywgXCJpbmZvXCIpO1xuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgY29uc29sZS5lcnJvcihgJHt0YWdzLmVycm9yfSAke21lc3NhZ2V9YCwgLi4ub3B0aW9uYWxQYXJhbXMpO1xufVxuX19uYW1lKGVycm9yLCBcImVycm9yXCIpO1xuZnVuY3Rpb24gcXVlcnkobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgY29uc29sZS5sb2coYCR7dGFncy5xdWVyeX0gJHttZXNzYWdlfWAsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbn1cbl9fbmFtZShxdWVyeSwgXCJxdWVyeVwiKTtcblxuLy8gLi4vaW50ZXJuYWxzL3NyYy91dGlscy9hc3NlcnROZXZlci50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoYXJnMiwgZXJyb3JNZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xufVxuX19uYW1lKGFzc2VydE5ldmVyLCBcImFzc2VydE5ldmVyXCIpO1xuXG4vLyAuLi9pbnRlcm5hbHMvc3JjL3V0aWxzL2NhbGxPbmNlLnRzXG5mdW5jdGlvbiBjYWxsT25jZShmbikge1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogcmVzdWx0ID0gZm4oLi4uYXJncyk7XG59XG5fX25hbWUoY2FsbE9uY2UsIFwiY2FsbE9uY2VcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvdXRpbHMva2V5QnkudHNcbnZhciBrZXlCeTIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgIGFjY1tpdGVyYXRlZShjdXJyKV0gPSBjdXJyO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn0sIFwia2V5QnlcIik7XG5cbi8vIC4uL2ludGVybmFscy9zcmMvd2Fybk9uY2UudHNcbnZhciBhbHJlYWR5V2FybmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciB3YXJuT25jZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGtleSwgbWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBpZiAoIWFscmVhZHlXYXJuZWQuaGFzKGtleSkpIHtcbiAgICBhbHJlYWR5V2FybmVkLmFkZChrZXkpO1xuICAgIHdhcm4obWVzc2FnZSwgLi4uYXJncyk7XG4gIH1cbn0sIFwid2Fybk9uY2VcIik7XG5cbi8vIHNyYy9ydW50aW1lL2dldFByaXNtYUNsaWVudC50c1xudmFyIGltcG9ydF9hc3luY19ob29rcyA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbnZhciBpbXBvcnRfZnM5ID0gX190b0VTTShyZXF1aXJlKFwiZnNcIikpO1xudmFyIGltcG9ydF9wYXRoNSA9IF9fdG9FU00ocmVxdWlyZShcInBhdGhcIikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3FsLXRlbXBsYXRlLXRhZ0A1LjAuMy9ub2RlX21vZHVsZXMvc3FsLXRlbXBsYXRlLXRhZy9kaXN0L2luZGV4LmpzXG52YXIgU3FsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyYXdTdHJpbmdzLCByYXdWYWx1ZXMpIHtcbiAgICBpZiAocmF3U3RyaW5ncy5sZW5ndGggLSAxICE9PSByYXdWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAocmF3U3RyaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDEgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJHtyYXdTdHJpbmdzLmxlbmd0aH0gc3RyaW5ncyB0byBoYXZlICR7cmF3U3RyaW5ncy5sZW5ndGggLSAxfSB2YWx1ZXNgKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzTGVuZ3RoID0gcmF3VmFsdWVzLnJlZHVjZSgobGVuLCB2YWx1ZSkgPT4gbGVuICsgKHZhbHVlIGluc3RhbmNlb2YgU3FsID8gdmFsdWUudmFsdWVzLmxlbmd0aCA6IDEpLCAwKTtcbiAgICB0aGlzLnZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXNMZW5ndGgpO1xuICAgIHRoaXMuc3RyaW5ncyA9IG5ldyBBcnJheSh2YWx1ZXNMZW5ndGggKyAxKTtcbiAgICB0aGlzLnN0cmluZ3NbMF0gPSByYXdTdHJpbmdzWzBdO1xuICAgIGxldCBpID0gMCwgcG9zID0gMDtcbiAgICB3aGlsZSAoaSA8IHJhd1ZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gcmF3VmFsdWVzW2krK107XG4gICAgICBjb25zdCByYXdTdHJpbmcgPSByYXdTdHJpbmdzW2ldO1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgU3FsKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nc1twb3NdICs9IGNoaWxkLnN0cmluZ3NbMF07XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZC52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZXNbcG9zKytdID0gY2hpbGQudmFsdWVzW2NoaWxkSW5kZXgrK107XG4gICAgICAgICAgdGhpcy5zdHJpbmdzW3Bvc10gPSBjaGlsZC5zdHJpbmdzW2NoaWxkSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyaW5nc1twb3NdICs9IHJhd1N0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWVzW3BvcysrXSA9IGNoaWxkO1xuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSA9IHJhd1N0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgbGV0IGkgPSAxLCB2YWx1ZSA9IHRoaXMuc3RyaW5nc1swXTtcbiAgICB3aGlsZSAoaSA8IHRoaXMuc3RyaW5ncy5sZW5ndGgpXG4gICAgICB2YWx1ZSArPSBgJCR7aX0ke3RoaXMuc3RyaW5nc1tpKytdfWA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldCBzcWwoKSB7XG4gICAgbGV0IGkgPSAxLCB2YWx1ZSA9IHRoaXMuc3RyaW5nc1swXTtcbiAgICB3aGlsZSAoaSA8IHRoaXMuc3RyaW5ncy5sZW5ndGgpXG4gICAgICB2YWx1ZSArPSBgPyR7dGhpcy5zdHJpbmdzW2krK119YDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgc3FsOiB0aGlzLnNxbCxcbiAgICAgIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgICB9O1xuICB9XG59O1xuX19uYW1lKFNxbCwgXCJTcWxcIik7XG5mdW5jdGlvbiBqb2luKHZhbHVlcywgc2VwYXJhdG9yID0gXCIsXCIsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYGpvaW4oW10pYCB0byBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBtdWx0aXBsZSBlbGVtZW50cywgYnV0IGdvdCBhbiBlbXB0eSBhcnJheVwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFNxbChbcHJlZml4LCAuLi5BcnJheSh2YWx1ZXMubGVuZ3RoIC0gMSkuZmlsbChzZXBhcmF0b3IpLCBzdWZmaXhdLCB2YWx1ZXMpO1xufVxuX19uYW1lKGpvaW4sIFwiam9pblwiKTtcbmZ1bmN0aW9uIHJhdyh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFNxbChbdmFsdWVdLCBbXSk7XG59XG5fX25hbWUocmF3LCBcInJhd1wiKTtcbnZhciBlbXB0eSA9IHJhdyhcIlwiKTtcbmZ1bmN0aW9uIHNxbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTcWwoc3RyaW5ncywgdmFsdWVzKTtcbn1cbl9fbmFtZShzcWwsIFwic3FsXCIpO1xuXG4vLyBzcmMvcnVudGltZS9leHRlcm5hbFRvSW50ZXJuYWxEbW1mLnRzXG52YXIgaW1wb3J0X3BsdXJhbGl6ZSA9IF9fdG9FU00ocmVxdWlyZV9wbHVyYWxpemUoKSk7XG5mdW5jdGlvbiBleHRlcm5hbFRvSW50ZXJuYWxEbW1mKGRvY3VtZW50Mikge1xuICByZXR1cm4ge1xuICAgIC4uLmRvY3VtZW50MixcbiAgICBtYXBwaW5nczogZ2V0TWFwcGluZ3MoZG9jdW1lbnQyLm1hcHBpbmdzLCBkb2N1bWVudDIuZGF0YW1vZGVsKVxuICB9O1xufVxuX19uYW1lKGV4dGVybmFsVG9JbnRlcm5hbERtbWYsIFwiZXh0ZXJuYWxUb0ludGVybmFsRG1tZlwiKTtcbmZ1bmN0aW9uIGdldE1hcHBpbmdzKG1hcHBpbmdzLCBkYXRhbW9kZWwpIHtcbiAgY29uc3QgbW9kZWxPcGVyYXRpb25zID0gbWFwcGluZ3MubW9kZWxPcGVyYXRpb25zLmZpbHRlcigobWFwcGluZykgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0gZGF0YW1vZGVsLm1vZGVscy5maW5kKChtKSA9PiBtLm5hbWUgPT09IG1hcHBpbmcubW9kZWwpO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwcGluZyB3aXRob3V0IG1vZGVsICR7bWFwcGluZy5tb2RlbH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmZpZWxkcy5zb21lKChmKSA9PiBmLmtpbmQgIT09IFwib2JqZWN0XCIpO1xuICB9KS5tYXAoKG1hcHBpbmcpID0+ICh7XG4gICAgbW9kZWw6IG1hcHBpbmcubW9kZWwsXG4gICAgcGx1cmFsOiAoMCwgaW1wb3J0X3BsdXJhbGl6ZS5kZWZhdWx0KShsb3dlckNhc2UobWFwcGluZy5tb2RlbCkpLFxuICAgIGZpbmRVbmlxdWU6IG1hcHBpbmcuZmluZFVuaXF1ZSB8fCBtYXBwaW5nLmZpbmRTaW5nbGUsXG4gICAgZmluZEZpcnN0OiBtYXBwaW5nLmZpbmRGaXJzdCxcbiAgICBmaW5kTWFueTogbWFwcGluZy5maW5kTWFueSxcbiAgICBjcmVhdGU6IG1hcHBpbmcuY3JlYXRlT25lIHx8IG1hcHBpbmcuY3JlYXRlU2luZ2xlIHx8IG1hcHBpbmcuY3JlYXRlLFxuICAgIGNyZWF0ZU1hbnk6IG1hcHBpbmcuY3JlYXRlTWFueSxcbiAgICBkZWxldGU6IG1hcHBpbmcuZGVsZXRlT25lIHx8IG1hcHBpbmcuZGVsZXRlU2luZ2xlIHx8IG1hcHBpbmcuZGVsZXRlLFxuICAgIHVwZGF0ZTogbWFwcGluZy51cGRhdGVPbmUgfHwgbWFwcGluZy51cGRhdGVTaW5nbGUgfHwgbWFwcGluZy51cGRhdGUsXG4gICAgZGVsZXRlTWFueTogbWFwcGluZy5kZWxldGVNYW55LFxuICAgIHVwZGF0ZU1hbnk6IG1hcHBpbmcudXBkYXRlTWFueSxcbiAgICB1cHNlcnQ6IG1hcHBpbmcudXBzZXJ0T25lIHx8IG1hcHBpbmcudXBzZXJ0U2luZ2xlIHx8IG1hcHBpbmcudXBzZXJ0LFxuICAgIGFnZ3JlZ2F0ZTogbWFwcGluZy5hZ2dyZWdhdGUsXG4gICAgZ3JvdXBCeTogbWFwcGluZy5ncm91cEJ5LFxuICAgIGZpbmRSYXc6IG1hcHBpbmcuZmluZFJhdyxcbiAgICBhZ2dyZWdhdGVSYXc6IG1hcHBpbmcuYWdncmVnYXRlUmF3XG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBtb2RlbE9wZXJhdGlvbnMsXG4gICAgb3RoZXJPcGVyYXRpb25zOiBtYXBwaW5ncy5vdGhlck9wZXJhdGlvbnNcbiAgfTtcbn1cbl9fbmFtZShnZXRNYXBwaW5ncywgXCJnZXRNYXBwaW5nc1wiKTtcblxuLy8gc3JjL2dlbmVyYXRpb24vZ2V0RE1NRi50c1xuZnVuY3Rpb24gZ2V0UHJpc21hQ2xpZW50RE1NRihkbW1mKSB7XG4gIHJldHVybiBleHRlcm5hbFRvSW50ZXJuYWxEbW1mKGRtbWYpO1xufVxuX19uYW1lKGdldFByaXNtYUNsaWVudERNTUYsIFwiZ2V0UHJpc21hQ2xpZW50RE1NRlwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY2xpZW50QWN0aW9ucy50c1xudmFyIGNsaWVudE9ubHlBY3Rpb25zID0ge1xuICBmaW5kVW5pcXVlT3JUaHJvdzoge1xuICAgIHdyYXBwZWRBY3Rpb246IERNTUYuTW9kZWxBY3Rpb24uZmluZFVuaXF1ZVxuICB9LFxuICBmaW5kRmlyc3RPclRocm93OiB7XG4gICAgd3JhcHBlZEFjdGlvbjogRE1NRi5Nb2RlbEFjdGlvbi5maW5kRmlyc3RcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERtbWZBY3Rpb25OYW1lKG5hbWUpIHtcbiAgaWYgKGlzQ2xpZW50T25seUFjdGlvbihuYW1lKSkge1xuICAgIHJldHVybiBjbGllbnRPbmx5QWN0aW9uc1tuYW1lXS53cmFwcGVkQWN0aW9uO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuX19uYW1lKGdldERtbWZBY3Rpb25OYW1lLCBcImdldERtbWZBY3Rpb25OYW1lXCIpO1xuZnVuY3Rpb24gaXNDbGllbnRPbmx5QWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNsaWVudE9ubHlBY3Rpb25zLCBhY3Rpb24pO1xufVxuX19uYW1lKGlzQ2xpZW50T25seUFjdGlvbiwgXCJpc0NsaWVudE9ubHlBY3Rpb25cIik7XG52YXIgYWxsQ2xpZW50TW9kZWxBY3Rpb25zID0gT2JqZWN0LmtleXMoRE1NRi5Nb2RlbEFjdGlvbikuY29uY2F0KFxuICBPYmplY3Qua2V5cyhjbGllbnRPbmx5QWN0aW9ucylcbik7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFja3RyYWNlLXBhcnNlckAwLjEuMTAvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtcGFyc2VyL2Rpc3Qvc3RhY2stdHJhY2UtcGFyc2VyLmVzbS5qc1xudmFyIFVOS05PV05fRlVOQ1RJT04gPSBcIjx1bmtub3duPlwiO1xuZnVuY3Rpb24gcGFyc2Uoc3RhY2tTdHJpbmcpIHtcbiAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gIHJldHVybiBsaW5lcy5yZWR1Y2UoZnVuY3Rpb24oc3RhY2ssIGxpbmUpIHtcbiAgICB2YXIgcGFyc2VSZXN1bHQgPSBwYXJzZUNocm9tZShsaW5lKSB8fCBwYXJzZVdpbmpzKGxpbmUpIHx8IHBhcnNlR2Vja28obGluZSkgfHwgcGFyc2VOb2RlKGxpbmUpIHx8IHBhcnNlSlNDKGxpbmUpO1xuICAgIGlmIChwYXJzZVJlc3VsdCkge1xuICAgICAgc3RhY2sucHVzaChwYXJzZVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbiAgfSwgW10pO1xufVxuX19uYW1lKHBhcnNlLCBcInBhcnNlXCIpO1xudmFyIGNocm9tZVJlID0gL15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7XG52YXIgY2hyb21lRXZhbFJlID0gL1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO1xuZnVuY3Rpb24gcGFyc2VDaHJvbWUobGluZSkge1xuICB2YXIgcGFydHMgPSBjaHJvbWVSZS5leGVjKGxpbmUpO1xuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlzTmF0aXZlID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZihcIm5hdGl2ZVwiKSA9PT0gMDtcbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoXCJldmFsXCIpID09PSAwO1xuICB2YXIgc3VibWF0Y2ggPSBjaHJvbWVFdmFsUmUuZXhlYyhwYXJ0c1syXSk7XG4gIGlmIChpc0V2YWwgJiYgc3VibWF0Y2ggIT0gbnVsbCkge1xuICAgIHBhcnRzWzJdID0gc3VibWF0Y2hbMV07XG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsyXTtcbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogIWlzTmF0aXZlID8gcGFydHNbMl0gOiBudWxsLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBpc05hdGl2ZSA/IFtwYXJ0c1syXV0gOiBbXSxcbiAgICBsaW5lTnVtYmVyOiBwYXJ0c1szXSA/ICtwYXJ0c1szXSA6IG51bGwsXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgfTtcbn1cbl9fbmFtZShwYXJzZUNocm9tZSwgXCJwYXJzZUNocm9tZVwiKTtcbnZhciB3aW5qc1JlID0gL15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pPy4rKSApP1xcKD8oKD86ZmlsZXxtcy1hcHB4fGh0dHBzP3x3ZWJwYWNrfGJsb2IpOi4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XG5mdW5jdGlvbiBwYXJzZVdpbmpzKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gd2luanNSZS5leGVjKGxpbmUpO1xuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1syXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5fX25hbWUocGFyc2VXaW5qcywgXCJwYXJzZVdpbmpzXCIpO1xudmFyIGdlY2tvUmUgPSAvXlxccyooLio/KSg/OlxcKCguKj8pXFwpKT8oPzpefEApKCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lfHdlYnBhY2t8cmVzb3VyY2V8XFxbbmF0aXZlKS4qP3xbXkBdKmJ1bmRsZSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pO1xudmFyIGdlY2tvRXZhbFJlID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XG5mdW5jdGlvbiBwYXJzZUdlY2tvKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gZ2Vja29SZS5leGVjKGxpbmUpO1xuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzNdICYmIHBhcnRzWzNdLmluZGV4T2YoXCIgPiBldmFsXCIpID4gLTE7XG4gIHZhciBzdWJtYXRjaCA9IGdlY2tvRXZhbFJlLmV4ZWMocGFydHNbM10pO1xuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcbiAgICBwYXJ0c1szXSA9IHN1Ym1hdGNoWzFdO1xuICAgIHBhcnRzWzRdID0gc3VibWF0Y2hbMl07XG4gICAgcGFydHNbNV0gPSBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbM10sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoXCIsXCIpIDogW10sXG4gICAgbGluZU51bWJlcjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsLFxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXG4gIH07XG59XG5fX25hbWUocGFyc2VHZWNrbywgXCJwYXJzZUdlY2tvXCIpO1xudmFyIGphdmFTY3JpcHRDb3JlUmUgPSAvXlxccyooPzooW15AXSopKD86XFwoKC4qPylcXCkpP0ApPyhcXFMuKj8pOihcXGQrKSg/OjooXFxkKykpP1xccyokL2k7XG5mdW5jdGlvbiBwYXJzZUpTQyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGphdmFTY3JpcHRDb3JlUmUuZXhlYyhsaW5lKTtcbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbM10sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IFtdLFxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1s0XSxcbiAgICBjb2x1bW46IHBhcnRzWzVdID8gK3BhcnRzWzVdIDogbnVsbFxuICB9O1xufVxuX19uYW1lKHBhcnNlSlNDLCBcInBhcnNlSlNDXCIpO1xudmFyIG5vZGVSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcbmZ1bmN0aW9uIHBhcnNlTm9kZShsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IG5vZGVSZS5leGVjKGxpbmUpO1xuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1syXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5fX25hbWUocGFyc2VOb2RlLCBcInBhcnNlTm9kZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvQ2FsbFNpdGUudHNcbnZhciBEaXNhYmxlZENhbGxTaXRlID0gY2xhc3Mge1xuICBnZXRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbl9fbmFtZShEaXNhYmxlZENhbGxTaXRlLCBcIkRpc2FibGVkQ2FsbFNpdGVcIik7XG52YXIgRW5hYmxlZENhbGxTaXRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lcnJvciA9IG5ldyBFcnJvcigpO1xuICB9XG4gIGdldExvY2F0aW9uKCkge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fZXJyb3Iuc3RhY2s7XG4gICAgaWYgKCFzdGFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrRnJhbWVzID0gcGFyc2Uoc3RhY2spO1xuICAgIGNvbnN0IGZyYW1lID0gc3RhY2tGcmFtZXMuZmluZCgodCkgPT4ge1xuICAgICAgcmV0dXJuIHQuZmlsZSAmJiB0LmZpbGUgIT09IFwiPGFub255bW91cz5cIiAmJiAhdC5maWxlLmluY2x1ZGVzKFwiQHByaXNtYVwiKSAmJiAhdC5maWxlLmluY2x1ZGVzKFwiZ2V0UHJpc21hQ2xpZW50XCIpICYmICF0LmZpbGUuc3RhcnRzV2l0aChcImludGVybmFsL1wiKSAmJiAhdC5tZXRob2ROYW1lLmluY2x1ZGVzKFwibmV3IFwiKSAmJiAhdC5tZXRob2ROYW1lLmluY2x1ZGVzKFwiZ2V0Q2FsbFNpdGVcIikgJiYgIXQubWV0aG9kTmFtZS5pbmNsdWRlcyhcIlByb3h5LlwiKSAmJiB0Lm1ldGhvZE5hbWUuc3BsaXQoXCIuXCIpLmxlbmd0aCA8IDQ7XG4gICAgfSk7XG4gICAgaWYgKCFmcmFtZSB8fCAhZnJhbWUuZmlsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWxlTmFtZTogZnJhbWUuZmlsZSxcbiAgICAgIGxpbmVOdW1iZXI6IGZyYW1lLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IGZyYW1lLmNvbHVtblxuICAgIH07XG4gIH1cbn07XG5fX25hbWUoRW5hYmxlZENhbGxTaXRlLCBcIkVuYWJsZWRDYWxsU2l0ZVwiKTtcbmZ1bmN0aW9uIGdldENhbGxTaXRlKGVycm9yRm9ybWF0KSB7XG4gIGlmIChlcnJvckZvcm1hdCA9PT0gXCJtaW5pbWFsXCIpIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ2FsbFNpdGUoKTtcbiAgfVxuICByZXR1cm4gbmV3IEVuYWJsZWRDYWxsU2l0ZSgpO1xufVxuX19uYW1lKGdldENhbGxTaXRlLCBcImdldENhbGxTaXRlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL3JlcXVlc3QvY3JlYXRlUHJpc21hUHJvbWlzZS50c1xuZnVuY3Rpb24gY3JlYXRlUHJpc21hUHJvbWlzZShjYWxsYmFjaykge1xuICBsZXQgcHJvbWlzZTtcbiAgY29uc3QgX2NhbGxiYWNrID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgodHhJZCwgbG9jaykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcHJvbWlzZSAhPSBudWxsID8gcHJvbWlzZSA6IHByb21pc2UgPSBjYWxsYmFjayh0eElkLCBsb2NrKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcjIpO1xuICAgIH1cbiAgfSwgXCJfY2FsbGJhY2tcIik7XG4gIHJldHVybiB7XG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgdHhJZCkge1xuICAgICAgcmV0dXJuIF9jYWxsYmFjayh0eElkLCB2b2lkIDApLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHR4SWQpO1xuICAgIH0sXG4gICAgY2F0Y2gob25SZWplY3RlZCwgdHhJZCkge1xuICAgICAgcmV0dXJuIF9jYWxsYmFjayh0eElkLCB2b2lkIDApLmNhdGNoKG9uUmVqZWN0ZWQsIHR4SWQpO1xuICAgIH0sXG4gICAgZmluYWxseShvbkZpbmFsbHksIHR4SWQpIHtcbiAgICAgIHJldHVybiBfY2FsbGJhY2sodHhJZCwgdm9pZCAwKS5maW5hbGx5KG9uRmluYWxseSwgdHhJZCk7XG4gICAgfSxcbiAgICByZXF1ZXN0VHJhbnNhY3Rpb24odHhJZCwgbG9jaykge1xuICAgICAgY29uc3QgcHJvbWlzZTIgPSBfY2FsbGJhY2sodHhJZCwgbG9jayk7XG4gICAgICBpZiAocHJvbWlzZTIucmVxdWVzdFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlMi5yZXF1ZXN0VHJhbnNhY3Rpb24odHhJZCwgbG9jayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTI7XG4gICAgfSxcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJQcmlzbWFQcm9taXNlXCJcbiAgfTtcbn1cbl9fbmFtZShjcmVhdGVQcmlzbWFQcm9taXNlLCBcImNyZWF0ZVByaXNtYVByb21pc2VcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYWdncmVnYXRlcy91dGlscy9hZ2dyZWdhdGVNYXAudHNcbnZhciBhZ2dyZWdhdGVNYXAgPSB7XG4gIF9hdmc6IHRydWUsXG4gIF9jb3VudDogdHJ1ZSxcbiAgX3N1bTogdHJ1ZSxcbiAgX21pbjogdHJ1ZSxcbiAgX21heDogdHJ1ZVxufTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9hZ2dyZWdhdGVzL2FnZ3JlZ2F0ZS50c1xuZnVuY3Rpb24gZGVzdWdhclVzZXJBcmdzKHVzZXJBcmdzKSB7XG4gIGNvbnN0IF91c2VyQXJncyA9IGRlc3VnYXJDb3VudEluVXNlckFyZ3ModXNlckFyZ3MpO1xuICBjb25zdCB1c2VyQXJnc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhfdXNlckFyZ3MpO1xuICByZXR1cm4gdXNlckFyZ3NFbnRyaWVzLnJlZHVjZShcbiAgICAoYWdncmVnYXRlQXJncywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoYWdncmVnYXRlTWFwW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBhZ2dyZWdhdGVBcmdzW1wic2VsZWN0XCJdW2tleV0gPSB7IHNlbGVjdDogdmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZUFyZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZUFyZ3M7XG4gICAgfSxcbiAgICB7IHNlbGVjdDoge30gfVxuICApO1xufVxuX19uYW1lKGRlc3VnYXJVc2VyQXJncywgXCJkZXN1Z2FyVXNlckFyZ3NcIik7XG5mdW5jdGlvbiBkZXN1Z2FyQ291bnRJblVzZXJBcmdzKHVzZXJBcmdzKSB7XG4gIGlmICh0eXBlb2YgdXNlckFyZ3NbXCJfY291bnRcIl0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHsgLi4udXNlckFyZ3MsIF9jb3VudDogeyBfYWxsOiB1c2VyQXJnc1tcIl9jb3VudFwiXSB9IH07XG4gIH1cbiAgcmV0dXJuIHVzZXJBcmdzO1xufVxuX19uYW1lKGRlc3VnYXJDb3VudEluVXNlckFyZ3MsIFwiZGVzdWdhckNvdW50SW5Vc2VyQXJnc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVVucGFja2VyKHVzZXJBcmdzKSB7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdXNlckFyZ3NbXCJfY291bnRcIl0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkYXRhW1wiX2NvdW50XCJdID0gZGF0YVtcIl9jb3VudFwiXVtcIl9hbGxcIl07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xufVxuX19uYW1lKGNyZWF0ZVVucGFja2VyLCBcImNyZWF0ZVVucGFja2VyXCIpO1xuZnVuY3Rpb24gYWdncmVnYXRlKGNsaWVudCwgdXNlckFyZ3MsIG1vZGVsQWN0aW9uKSB7XG4gIGNvbnN0IGFnZ3JlZ2F0ZUFyZ3MgPSBkZXN1Z2FyVXNlckFyZ3ModXNlckFyZ3MgIT0gbnVsbCA/IHVzZXJBcmdzIDoge30pO1xuICBjb25zdCBhZ2dyZWdhdGVVbnBhY2tlciA9IGNyZWF0ZVVucGFja2VyKHVzZXJBcmdzICE9IG51bGwgPyB1c2VyQXJncyA6IHt9KTtcbiAgcmV0dXJuIG1vZGVsQWN0aW9uKHtcbiAgICBhY3Rpb246IFwiYWdncmVnYXRlXCIsXG4gICAgdW5wYWNrZXI6IGFnZ3JlZ2F0ZVVucGFja2VyXG4gIH0pKGFnZ3JlZ2F0ZUFyZ3MpO1xufVxuX19uYW1lKGFnZ3JlZ2F0ZSwgXCJhZ2dyZWdhdGVcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYWdncmVnYXRlcy9jb3VudC50c1xuZnVuY3Rpb24gY291bnQoY2xpZW50LCB1c2VyQXJncywgbW9kZWxBY3Rpb24pIHtcbiAgY29uc3QgeyBzZWxlY3QsIC4uLl91c2VyQXJncyB9ID0gdXNlckFyZ3MgIT0gbnVsbCA/IHVzZXJBcmdzIDoge307XG4gIGlmICh0eXBlb2Ygc2VsZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZShcbiAgICAgIGNsaWVudCxcbiAgICAgIHsgLi4uX3VzZXJBcmdzLCBfY291bnQ6IHNlbGVjdCB9LFxuICAgICAgKHApID0+IG1vZGVsQWN0aW9uKHsgLi4ucCwgYWN0aW9uOiBcImNvdW50XCIsIHVucGFja2VyOiAoZGF0YSkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICByZXR1cm4gKF9hMyA9IHAudW5wYWNrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChwLCBkYXRhKVtcIl9jb3VudFwiXTtcbiAgICAgIH0gfSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhZ2dyZWdhdGUoXG4gICAgICBjbGllbnQsXG4gICAgICB7IC4uLl91c2VyQXJncywgX2NvdW50OiB7IF9hbGw6IHRydWUgfSB9LFxuICAgICAgKHApID0+IG1vZGVsQWN0aW9uKHsgLi4ucCwgYWN0aW9uOiBcImNvdW50XCIsIHVucGFja2VyOiAoZGF0YSkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICByZXR1cm4gKF9hMyA9IHAudW5wYWNrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChwLCBkYXRhKVtcIl9jb3VudFwiXVtcIl9hbGxcIl07XG4gICAgICB9IH0pXG4gICAgKTtcbiAgfVxufVxuX19uYW1lKGNvdW50LCBcImNvdW50XCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FnZ3JlZ2F0ZXMvZ3JvdXBCeS50c1xuZnVuY3Rpb24gZGVzdWdhclVzZXJBcmdzMih1c2VyQXJncykge1xuICBjb25zdCBfdXNlckFyZ3MgPSBkZXN1Z2FyVXNlckFyZ3ModXNlckFyZ3MpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh1c2VyQXJnc1tcImJ5XCJdKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZXJBcmdzW1wiYnlcIl0pIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIF91c2VyQXJnc1tcInNlbGVjdFwiXVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIF91c2VyQXJncztcbn1cbl9fbmFtZShkZXN1Z2FyVXNlckFyZ3MyLCBcImRlc3VnYXJVc2VyQXJnc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVVucGFja2VyMih1c2VyQXJncykge1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIHVzZXJBcmdzW1wiX2NvdW50XCJdID09PSBcImJvb2xlYW5cIikge1xuICAgICAgZGF0YS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgcm93W1wiX2NvdW50XCJdID0gcm93W1wiX2NvdW50XCJdW1wiX2FsbFwiXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn1cbl9fbmFtZShjcmVhdGVVbnBhY2tlcjIsIFwiY3JlYXRlVW5wYWNrZXJcIik7XG5mdW5jdGlvbiBncm91cEJ5KGNsaWVudCwgdXNlckFyZ3MsIG1vZGVsQWN0aW9uKSB7XG4gIGNvbnN0IGdyb3VwQnlBcmdzID0gZGVzdWdhclVzZXJBcmdzMih1c2VyQXJncyAhPSBudWxsID8gdXNlckFyZ3MgOiB7fSk7XG4gIGNvbnN0IGdyb3VwQnlVbnBhY2tlciA9IGNyZWF0ZVVucGFja2VyMih1c2VyQXJncyAhPSBudWxsID8gdXNlckFyZ3MgOiB7fSk7XG4gIHJldHVybiBtb2RlbEFjdGlvbih7XG4gICAgYWN0aW9uOiBcImdyb3VwQnlcIixcbiAgICB1bnBhY2tlcjogZ3JvdXBCeVVucGFja2VyXG4gIH0pKGdyb3VwQnlBcmdzKTtcbn1cbl9fbmFtZShncm91cEJ5LCBcImdyb3VwQnlcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYXBwbHlBZ2dyZWdhdGVzLnRzXG5mdW5jdGlvbiBhcHBseUFnZ3JlZ2F0ZXMoY2xpZW50LCBhY3Rpb24sIG1vZGVsQWN0aW9uKSB7XG4gIGlmIChhY3Rpb24gPT09IFwiYWdncmVnYXRlXCIpXG4gICAgcmV0dXJuICh1c2VyQXJncykgPT4gYWdncmVnYXRlKGNsaWVudCwgdXNlckFyZ3MsIG1vZGVsQWN0aW9uKTtcbiAgaWYgKGFjdGlvbiA9PT0gXCJjb3VudFwiKVxuICAgIHJldHVybiAodXNlckFyZ3MpID0+IGNvdW50KGNsaWVudCwgdXNlckFyZ3MsIG1vZGVsQWN0aW9uKTtcbiAgaWYgKGFjdGlvbiA9PT0gXCJncm91cEJ5XCIpXG4gICAgcmV0dXJuICh1c2VyQXJncykgPT4gZ3JvdXBCeShjbGllbnQsIHVzZXJBcmdzLCBtb2RlbEFjdGlvbik7XG4gIHJldHVybiB2b2lkIDA7XG59XG5fX25hbWUoYXBwbHlBZ2dyZWdhdGVzLCBcImFwcGx5QWdncmVnYXRlc1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvcXVlcnkudHNcbnZhciBpbXBvcnRfY2hhbGsxMSA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgaW1wb3J0X2luZGVudF9zdHJpbmc0ID0gX190b0VTTShyZXF1aXJlX2luZGVudF9zdHJpbmcoKSk7XG52YXIgaW1wb3J0X3N0cmlwX2Fuc2kzID0gX190b0VTTShyZXF1aXJlX3N0cmlwX2Fuc2koKSk7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2NyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0LnRzXG52YXIgaW1wb3J0X2NoYWxrOSA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgaW1wb3J0X2luZGVudF9zdHJpbmczID0gX190b0VTTShyZXF1aXJlX2luZGVudF9zdHJpbmcoKSk7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL1NvdXJjZUZpbGVTbGljZS50c1xudmFyIGltcG9ydF9mczggPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG5cbi8vIHNyYy9ydW50aW1lL2hpZ2hsaWdodC90aGVtZS50c1xudmFyIGltcG9ydF9jaGFsazggPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlKCkpO1xudmFyIG9yYW5nZSA9IGltcG9ydF9jaGFsazguZGVmYXVsdC5yZ2IoMjQ2LCAxNDUsIDk1KTtcbnZhciBkYXJrQnJpZ2h0Qmx1ZSA9IGltcG9ydF9jaGFsazguZGVmYXVsdC5yZ2IoMTA3LCAxMzksIDE0MCk7XG52YXIgYmx1ZSA9IGltcG9ydF9jaGFsazguZGVmYXVsdC5jeWFuO1xudmFyIGJyaWdodEJsdWUgPSBpbXBvcnRfY2hhbGs4LmRlZmF1bHQucmdiKDEyNywgMTU1LCAxNTUpO1xudmFyIGlkZW50aXR5ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RyKSA9PiBzdHIsIFwiaWRlbnRpdHlcIik7XG52YXIgdGhlbWUgPSB7XG4gIGtleXdvcmQ6IGJsdWUsXG4gIGVudGl0eTogYmx1ZSxcbiAgdmFsdWU6IGJyaWdodEJsdWUsXG4gIHB1bmN0dWF0aW9uOiBkYXJrQnJpZ2h0Qmx1ZSxcbiAgZGlyZWN0aXZlOiBibHVlLFxuICBmdW5jdGlvbjogYmx1ZSxcbiAgdmFyaWFibGU6IGJyaWdodEJsdWUsXG4gIHN0cmluZzogaW1wb3J0X2NoYWxrOC5kZWZhdWx0LmdyZWVuQnJpZ2h0LFxuICBib29sZWFuOiBvcmFuZ2UsXG4gIG51bWJlcjogaW1wb3J0X2NoYWxrOC5kZWZhdWx0LmN5YW4sXG4gIGNvbW1lbnQ6IGltcG9ydF9jaGFsazguZGVmYXVsdC5ncmV5XG59O1xuXG4vLyBzcmMvcnVudGltZS9oaWdobGlnaHQvcHJpc20udHNcbnZhciBfc2VsZiA9IHt9O1xudmFyIHVuaXF1ZUlkID0gMDtcbnZhciBQcmlzbSA9IHtcbiAgbWFudWFsOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5tYW51YWwsXG4gIGRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcjogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyLFxuICB1dGlsOiB7XG4gICAgZW5jb2RlOiBmdW5jdGlvbih0b2tlbnMpIHtcbiAgICAgIGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICBjb25zdCBhbnlUb2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4oYW55VG9rZW5zLnR5cGUsIFByaXNtLnV0aWwuZW5jb2RlKGFueVRva2Vucy5jb250ZW50KSwgYW55VG9rZW5zLmFsaWFzKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKFByaXNtLnV0aWwuZW5jb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoL1xcdTAwYTAvZywgXCIgXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgfSxcbiAgICBvYmpJZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAoIW9ialtcIl9faWRcIl0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgXCJfX2lkXCIsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW1wiX19pZFwiXTtcbiAgICB9LFxuICAgIGNsb25lOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGRlZXBDbG9uZShvLCB2aXNpdGVkKSB7XG4gICAgICBsZXQgY2xvbmUyLCBpZCwgdHlwZSA9IFByaXNtLnV0aWwudHlwZShvKTtcbiAgICAgIHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICBpZCA9IFByaXNtLnV0aWwub2JqSWQobyk7XG4gICAgICAgICAgaWYgKHZpc2l0ZWRbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRlZFtpZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb25lMiA9IHt9O1xuICAgICAgICAgIHZpc2l0ZWRbaWRdID0gY2xvbmUyO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgY2xvbmUyW2tleV0gPSBkZWVwQ2xvbmUob1trZXldLCB2aXNpdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNsb25lMjtcbiAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgaWQgPSBQcmlzbS51dGlsLm9iaklkKG8pO1xuICAgICAgICAgIGlmICh2aXNpdGVkW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRbaWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9uZTIgPSBbXTtcbiAgICAgICAgICB2aXNpdGVkW2lkXSA9IGNsb25lMjtcbiAgICAgICAgICBvLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgY2xvbmUyW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjbG9uZTI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgfSwgXCJkZWVwQ2xvbmVcIilcbiAgfSxcbiAgbGFuZ3VhZ2VzOiB7XG4gICAgZXh0ZW5kOiBmdW5jdGlvbihpZCwgcmVkZWYpIHtcbiAgICAgIGNvbnN0IGxhbmcgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlc1tpZF0pO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVkZWYpIHtcbiAgICAgICAgbGFuZ1trZXldID0gcmVkZWZba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG4gICAgICByb290ID0gcm9vdCB8fCBQcmlzbS5sYW5ndWFnZXM7XG4gICAgICBjb25zdCBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuICAgICAgY29uc3QgcmV0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIGluIGdyYW1tYXIpIHtcbiAgICAgICAgaWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWluc2VydC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZCA9IHJvb3RbaW5zaWRlXTtcbiAgICAgIHJvb3RbaW5zaWRlXSA9IHJldDtcbiAgICAgIFByaXNtLmxhbmd1YWdlcy5ERlMoUHJpc20ubGFuZ3VhZ2VzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gb2xkICYmIGtleSAhPSBpbnNpZGUpIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSByZXQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIERGUzogLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbiBERlMobywgY2FsbGJhY2ssIHR5cGUsIHZpc2l0ZWQpIHtcbiAgICAgIHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuICAgICAgY29uc3Qgb2JqSWQgPSBQcmlzbS51dGlsLm9iaklkO1xuICAgICAgZm9yIChjb25zdCBpIGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBvW2ldLCBwcm9wZXJ0eVR5cGUgPSBQcmlzbS51dGlsLnR5cGUocHJvcGVydHkpO1xuICAgICAgICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09IFwiT2JqZWN0XCIgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuICAgICAgICAgICAgdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcbiAgICAgICAgICAgIERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlUeXBlID09PSBcIkFycmF5XCIgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuICAgICAgICAgICAgdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcbiAgICAgICAgICAgIERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFwiREZTXCIpXG4gIH0sXG4gIHBsdWdpbnM6IHt9LFxuICBoaWdobGlnaHQ6IGZ1bmN0aW9uKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgY29uc3QgZW52MiA9IHtcbiAgICAgIGNvZGU6IHRleHQsXG4gICAgICBncmFtbWFyLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuICAgIFByaXNtLmhvb2tzLnJ1bihcImJlZm9yZS10b2tlbml6ZVwiLCBlbnYyKTtcbiAgICBlbnYyLnRva2VucyA9IFByaXNtLnRva2VuaXplKGVudjIuY29kZSwgZW52Mi5ncmFtbWFyKTtcbiAgICBQcmlzbS5ob29rcy5ydW4oXCJhZnRlci10b2tlbml6ZVwiLCBlbnYyKTtcbiAgICByZXR1cm4gVG9rZW4uc3RyaW5naWZ5KFByaXNtLnV0aWwuZW5jb2RlKGVudjIudG9rZW5zKSwgZW52Mi5sYW5ndWFnZSk7XG4gIH0sXG4gIG1hdGNoR3JhbW1hcjogZnVuY3Rpb24odGV4dCwgc3RyYXJyLCBncmFtbWFyLCBpbmRleCwgc3RhcnRQb3MsIG9uZXNob3QsIHRhcmdldCkge1xuICAgIGZvciAoY29uc3QgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgaWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuICAgICAgcGF0dGVybnMgPSBQcmlzbS51dGlsLnR5cGUocGF0dGVybnMpID09PSBcIkFycmF5XCIgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gcGF0dGVybnNbal0sIGluc2lkZSA9IHBhdHRlcm4uaW5zaWRlLCBsb29rYmVoaW5kID0gISFwYXR0ZXJuLmxvb2tiZWhpbmQsIGdyZWVkeSA9ICEhcGF0dGVybi5ncmVlZHksIGxvb2tiZWhpbmRMZW5ndGggPSAwLCBhbGlhcyA9IHBhdHRlcm4uYWxpYXM7XG4gICAgICAgIGlmIChncmVlZHkgJiYgIXBhdHRlcm4ucGF0dGVybi5nbG9iYWwpIHtcbiAgICAgICAgICBjb25zdCBmbGFncyA9IHBhdHRlcm4ucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW11eV0qJC8pWzBdO1xuICAgICAgICAgIHBhdHRlcm4ucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4uc291cmNlLCBmbGFncyArIFwiZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCwgcG9zID0gc3RhcnRQb3M7IGkgPCBzdHJhcnIubGVuZ3RoOyBwb3MgKz0gc3RyYXJyW2ldLmxlbmd0aCwgKytpKSB7XG4gICAgICAgICAgbGV0IHN0ciA9IHN0cmFycltpXTtcbiAgICAgICAgICBpZiAoc3RyYXJyLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChncmVlZHkgJiYgaSAhPSBzdHJhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyb20gPSBtYXRjaC5pbmRleCArIChsb29rYmVoaW5kID8gbWF0Y2hbMV0ubGVuZ3RoIDogMCksIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsIGsgPSBpLCBwID0gcG9zO1xuICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gc3RyYXJyLmxlbmd0aDsgayA8IGxlbiAmJiAocCA8IHRvIHx8ICFzdHJhcnJba10udHlwZSAmJiAhc3RyYXJyW2sgLSAxXS5ncmVlZHkpOyArK2spIHtcbiAgICAgICAgICAgICAgcCArPSBzdHJhcnJba10ubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJhcnJbaV0gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbE51bSA9IGsgLSBpO1xuICAgICAgICAgICAgc3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuICAgICAgICAgICAgbWF0Y2guaW5kZXggLT0gcG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSwgZGVsTnVtID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG9uZXNob3QpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvb2tiZWhpbmQpIHtcbiAgICAgICAgICAgIGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmcm9tID0gbWF0Y2guaW5kZXggKyBsb29rYmVoaW5kTGVuZ3RoLCBtYXRjaCA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpLCB0byA9IGZyb20gKyBtYXRjaC5sZW5ndGgsIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKSwgYWZ0ZXIgPSBzdHIuc2xpY2UodG8pO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbaSwgZGVsTnVtXTtcbiAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBwb3MgKz0gYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgICAgIGFyZ3MucHVzaChiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB3cmFwcGVkID0gbmV3IFRva2VuKHRva2VuLCBpbnNpZGUgPyBQcmlzbS50b2tlbml6ZShtYXRjaCwgaW5zaWRlKSA6IG1hdGNoLCBhbGlhcywgbWF0Y2gsIGdyZWVkeSk7XG4gICAgICAgICAgYXJncy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuICAgICAgICAgIGlmIChkZWxOdW0gIT0gMSlcbiAgICAgICAgICAgIFByaXNtLm1hdGNoR3JhbW1hcih0ZXh0LCBzdHJhcnIsIGdyYW1tYXIsIGksIHBvcywgdHJ1ZSwgdG9rZW4pO1xuICAgICAgICAgIGlmIChvbmVzaG90KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHRva2VuaXplOiBmdW5jdGlvbih0ZXh0LCBncmFtbWFyKSB7XG4gICAgY29uc3Qgc3RyYXJyID0gW3RleHRdO1xuICAgIGNvbnN0IHJlc3QgPSBncmFtbWFyLnJlc3Q7XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gaW4gcmVzdCkge1xuICAgICAgICBncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICB9XG4gICAgUHJpc20ubWF0Y2hHcmFtbWFyKHRleHQsIHN0cmFyciwgZ3JhbW1hciwgMCwgMCwgZmFsc2UpO1xuICAgIHJldHVybiBzdHJhcnI7XG4gIH0sXG4gIGhvb2tzOiB7XG4gICAgYWxsOiB7fSxcbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBob29rcyA9IFByaXNtLmhvb2tzLmFsbDtcbiAgICAgIGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG4gICAgICBob29rc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHJ1bjogZnVuY3Rpb24obmFtZSwgZW52Mikge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gUHJpc20uaG9va3MuYWxsW25hbWVdO1xuICAgICAgaWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyBjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdOyApIHtcbiAgICAgICAgY2FsbGJhY2soZW52Mik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBUb2tlblxufTtcblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcbiAgY29tbWVudDogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIF0sXG4gIHN0cmluZzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gIFwiY2xhc3MtbmFtZVwiOiB7XG4gICAgcGF0dGVybjogLygoPzpcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyspfCg/OmNhdGNoXFxzK1xcKCkpW1xcdy5cXFxcXSsvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC9bLlxcXFxdL1xuICAgIH1cbiAgfSxcbiAga2V5d29yZDogL1xcYig/OmlmfGVsc2V8d2hpbGV8ZG98Zm9yfHJldHVybnxpbnxpbnN0YW5jZW9mfGZ1bmN0aW9ufG5ld3x0cnl8dGhyb3d8Y2F0Y2h8ZmluYWxseXxudWxsfGJyZWFrfGNvbnRpbnVlKVxcYi8sXG4gIGJvb2xlYW46IC9cXGIoPzp0cnVlfGZhbHNlKVxcYi8sXG4gIGZ1bmN0aW9uOiAvXFx3Kyg/PVxcKCkvLFxuICBudW1iZXI6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrXFwuP1xcZCp8XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcbiAgb3BlcmF0b3I6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCp8XFwvfH58XFxefCUvLFxuICBwdW5jdHVhdGlvbjogL1t7fVtcXF07KCksLjpdL1xufTtcblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZChcImNsaWtlXCIsIHtcbiAgXCJjbGFzcy1uYW1lXCI6IFtcbiAgICBQcmlzbS5sYW5ndWFnZXMuY2xpa2VbXCJjbGFzcy1uYW1lXCJdLFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSlbXyRBLVpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFwuKD86cHJvdG90eXBlfGNvbnN0cnVjdG9yKSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1cbiAgXSxcbiAga2V5d29yZDogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86Xnx9KVxccyopKD86Y2F0Y2h8ZmluYWxseSlcXGIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteLl0pXFxiKD86YXN8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1cbiAgXSxcbiAgbnVtYmVyOiAvXFxiKD86KD86MFt4WF0oPzpbXFxkQS1GYS1mXSg/Ol9bXFxkQS1GYS1mXSk/KSt8MFtiQl0oPzpbMDFdKD86X1swMV0pPykrfDBbb09dKD86WzAtN10oPzpfWzAtN10pPykrKW4/fCg/OlxcZCg/Ol9cXGQpPykrbnxOYU58SW5maW5pdHkpXFxifCg/OlxcYig/OlxcZCg/Ol9cXGQpPykrXFwuPyg/OlxcZCg/Ol9cXGQpPykqfFxcQlxcLig/OlxcZCg/Ol9cXGQpPykrKSg/OltFZV1bKy1dPyg/OlxcZCg/Ol9cXGQpPykrKT8vLFxuICBmdW5jdGlvbjogL1tfJGEtekEtWlxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcbiAgb3BlcmF0b3I6IC8tWy09XT98XFwrWys9XT98IT0/PT98PDw/PT98Pj4/Pj89P3w9KD86PT0/fD4pP3wmWyY9XT98XFx8W3w9XT98XFwqXFwqPz0/fFxcLz0/fH58XFxePT98JT0/fFxcP3xcXC57M30vXG59KTtcblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0W1wiY2xhc3MtbmFtZVwiXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8bmV3KVxccyspW1xcdy5cXFxcXSsvO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImphdmFzY3JpcHRcIiwgXCJrZXl3b3JkXCIsIHtcbiAgcmVnZXg6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXSlcXHMqKVxcLyhcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZ2lteXVzXXswLDZ9KD89XFxzKigkfFtcXHJcXG4sLjt9KVxcXV0pKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgXCJmdW5jdGlvbi12YXJpYWJsZVwiOiB7XG4gICAgcGF0dGVybjogL1tfJGEtekEtWlxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFtfJGEtekEtWlxceEEwLVxcdUZGRkZdWyRcXHdcXHhBMC1cXHVGRkZGXSopXFxzKj0+KSkvLFxuICAgIGFsaWFzOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAgcGFyYW1ldGVyOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogLyhmdW5jdGlvbig/OlxccytbXyRBLVphLXpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKV18XFwoW14oKV0qXFwpKSs/KD89XFxzKlxcKSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9bXyRhLXpcXHhBMC1cXHVGRkZGXVskXFx3XFx4QTAtXFx1RkZGRl0qKD89XFxzKj0+KS9pLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXXxcXChbXigpXSpcXCkpKz8oPz1cXHMqXFwpXFxzKj0+KS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86W18kQS1aYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKlxccyopXFwoXFxzKikoPyFcXHMpKD86W14oKV18XFwoW14oKV0qXFwpKSs/KD89XFxzKlxcKVxccypcXHspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgfVxuICBdLFxuICBjb25zdGFudDogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoXCJzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xufVxuUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG5QcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoXCJqYXZhc2NyaXB0XCIsIHtcbiAga2V5d29yZDogL1xcYig/OmFic3RyYWN0fGFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29uc3RydWN0b3J8Y29udGludWV8ZGVidWdnZXJ8ZGVjbGFyZXxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8aXN8a2V5b2Z8bGV0fG1vZHVsZXxuYW1lc3BhY2V8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmVhZG9ubHl8cmV0dXJufHJlcXVpcmV8c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICBidWlsdGluOiAvXFxiKD86c3RyaW5nfEZ1bmN0aW9ufGFueXxudW1iZXJ8Ym9vbGVhbnxBcnJheXxzeW1ib2x8Y29uc29sZXxQcm9taXNlfHVua25vd258bmV2ZXIpXFxiL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMudHMgPSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdDtcbmZ1bmN0aW9uIFRva2VuKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyLCBncmVlZHkpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICB0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8IFwiXCIpLmxlbmd0aCB8IDA7XG4gIHRoaXMuZ3JlZWR5ID0gISFncmVlZHk7XG59XG5fX25hbWUoVG9rZW4sIFwiVG9rZW5cIik7XG5Ub2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbihvLCBsYW5ndWFnZSkge1xuICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBvO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgcmV0dXJuIG8ubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBUb2tlbi5zdHJpbmdpZnkoZWxlbWVudCwgbGFuZ3VhZ2UpO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH1cbiAgcmV0dXJuIGdldENvbG9yRm9yU3ludGF4S2luZChvLnR5cGUpKG8uY29udGVudCk7XG59O1xuZnVuY3Rpb24gZ2V0Q29sb3JGb3JTeW50YXhLaW5kKHN5bnRheEtpbmQpIHtcbiAgcmV0dXJuIHRoZW1lW3N5bnRheEtpbmRdIHx8IGlkZW50aXR5O1xufVxuX19uYW1lKGdldENvbG9yRm9yU3ludGF4S2luZCwgXCJnZXRDb2xvckZvclN5bnRheEtpbmRcIik7XG5cbi8vIHNyYy9ydW50aW1lL2hpZ2hsaWdodC9oaWdobGlnaHQudHNcbmZ1bmN0aW9uIGhpZ2hsaWdodFRTKHN0cikge1xuICByZXR1cm4gaGlnaGxpZ2h0KHN0ciwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xufVxuX19uYW1lKGhpZ2hsaWdodFRTLCBcImhpZ2hsaWdodFRTXCIpO1xuZnVuY3Rpb24gaGlnaGxpZ2h0KHN0ciwgZ3JhbW1hcikge1xuICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShzdHIsIGdyYW1tYXIpO1xuICByZXR1cm4gdG9rZW5zLm1hcCgodCkgPT4gVG9rZW4uc3RyaW5naWZ5KHQpKS5qb2luKFwiXCIpO1xufVxuX19uYW1lKGhpZ2hsaWdodCwgXCJoaWdobGlnaHRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2RlZGVudC50c1xudmFyIGltcG9ydF9zdHJpcF9pbmRlbnQyID0gX190b0VTTShyZXF1aXJlX3N0cmlwX2luZGVudCgpKTtcbmZ1bmN0aW9uIGRlZGVudDIoc3RyKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3N0cmlwX2luZGVudDIuZGVmYXVsdCkoc3RyKTtcbn1cbl9fbmFtZShkZWRlbnQyLCBcImRlZGVudFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvU291cmNlRmlsZVNsaWNlLnRzXG52YXIgU291cmNlRmlsZVNsaWNlID0gY2xhc3Mge1xuICBzdGF0aWMgcmVhZChmaWxlUGF0aCkge1xuICAgIGxldCBjb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gaW1wb3J0X2ZzOC5kZWZhdWx0LnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFNvdXJjZUZpbGVTbGljZS5mcm9tQ29udGVudChjb250ZW50KTtcbiAgfVxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHJldHVybiBuZXcgU291cmNlRmlsZVNsaWNlKDEsIGxpbmVzKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihmaXJzdExpbmUsIGxpbmVzKSB7XG4gICAgdGhpcy5maXJzdExpbmVOdW1iZXIgPSBmaXJzdExpbmU7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICB9XG4gIGdldCBsYXN0TGluZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdExpbmVOdW1iZXIgKyB0aGlzLmxpbmVzLmxlbmd0aCAtIDE7XG4gIH1cbiAgbWFwTGluZUF0KGxpbmVOdW1iZXIsIG1hcEZuKSB7XG4gICAgaWYgKGxpbmVOdW1iZXIgPCB0aGlzLmZpcnN0TGluZU51bWJlciB8fCBsaW5lTnVtYmVyID4gdGhpcy5saW5lcy5sZW5ndGggKyB0aGlzLmZpcnN0TGluZU51bWJlcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGlkeCA9IGxpbmVOdW1iZXIgLSB0aGlzLmZpcnN0TGluZU51bWJlcjtcbiAgICBjb25zdCBuZXdMaW5lcyA9IFsuLi50aGlzLmxpbmVzXTtcbiAgICBuZXdMaW5lc1tpZHhdID0gbWFwRm4obmV3TGluZXNbaWR4XSk7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VGaWxlU2xpY2UodGhpcy5maXJzdExpbmVOdW1iZXIsIG5ld0xpbmVzKTtcbiAgfVxuICBtYXBMaW5lcyhtYXBGbikge1xuICAgIHJldHVybiBuZXcgU291cmNlRmlsZVNsaWNlKFxuICAgICAgdGhpcy5maXJzdExpbmVOdW1iZXIsXG4gICAgICB0aGlzLmxpbmVzLm1hcCgobGluZSwgaSkgPT4gbWFwRm4obGluZSwgdGhpcy5maXJzdExpbmVOdW1iZXIgKyBpKSlcbiAgICApO1xuICB9XG4gIGxpbmVBdChsaW5lTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZXNbbGluZU51bWJlciAtIHRoaXMuZmlyc3RMaW5lTnVtYmVyXTtcbiAgfVxuICBwcmVwZW5kU3ltYm9sQXQoYXRMaW5lLCBzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBMaW5lcygobGluZSwgbGluZU51bWJlcikgPT4ge1xuICAgICAgaWYgKGxpbmVOdW1iZXIgPT09IGF0TGluZSkge1xuICAgICAgICByZXR1cm4gYCR7c3RyfSAke2xpbmV9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgICAke2xpbmV9YDtcbiAgICB9KTtcbiAgfVxuICBzbGljZShmcm9tTGluZSwgdG9MaW5lKSB7XG4gICAgY29uc3Qgc2xpY2VkTGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKGZyb21MaW5lIC0gMSwgdG9MaW5lKS5qb2luKFwiXFxuXCIpO1xuICAgIHJldHVybiBuZXcgU291cmNlRmlsZVNsaWNlKGZyb21MaW5lLCBkZWRlbnQyKHNsaWNlZExpbmVzKS5zcGxpdChcIlxcblwiKSk7XG4gIH1cbiAgaGlnaGxpZ2h0KCkge1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0VFModGhpcy50b1N0cmluZygpKTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZUZpbGVTbGljZSh0aGlzLmZpcnN0TGluZU51bWJlciwgaGlnaGxpZ2h0ZWQuc3BsaXQoXCJcXG5cIikpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVzLmpvaW4oXCJcXG5cIik7XG4gIH1cbn07XG5fX25hbWUoU291cmNlRmlsZVNsaWNlLCBcIlNvdXJjZUZpbGVTbGljZVwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHQudHNcbnZhciBjb2xvcnNFbmFibGVkID0ge1xuICByZWQ6IChzdHIpID0+IGltcG9ydF9jaGFsazkuZGVmYXVsdC5yZWQoc3RyKSxcbiAgZ3JheTogKHN0cikgPT4gaW1wb3J0X2NoYWxrOS5kZWZhdWx0LmdyYXkoc3RyKSxcbiAgZGltOiAoc3RyKSA9PiBpbXBvcnRfY2hhbGs5LmRlZmF1bHQuZGltKHN0ciksXG4gIGJvbGQ6IChzdHIpID0+IGltcG9ydF9jaGFsazkuZGVmYXVsdC5ib2xkKHN0ciksXG4gIHVuZGVybGluZTogKHN0cikgPT4gaW1wb3J0X2NoYWxrOS5kZWZhdWx0LnVuZGVybGluZShzdHIpLFxuICBoaWdobGlnaHRTb3VyY2U6IChzb3VyY2UpID0+IHNvdXJjZS5oaWdobGlnaHQoKVxufTtcbnZhciBjb2xvcnNEaXNhYmxlZCA9IHtcbiAgcmVkOiAoc3RyKSA9PiBzdHIsXG4gIGdyYXk6IChzdHIpID0+IHN0cixcbiAgZGltOiAoc3RyKSA9PiBzdHIsXG4gIGJvbGQ6IChzdHIpID0+IHN0cixcbiAgdW5kZXJsaW5lOiAoc3RyKSA9PiBzdHIsXG4gIGhpZ2hsaWdodFNvdXJjZTogKHNvdXJjZSkgPT4gc291cmNlXG59O1xuZnVuY3Rpb24gZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKHsgY2FsbHNpdGUsIG1lc3NhZ2UsIG9yaWdpbmFsTWV0aG9kLCBpc1BhbmljLCBjYWxsQXJndW1lbnRzIH0sIGNvbG9ycykge1xuICB2YXIgX2EzO1xuICBjb25zdCB0ZW1wbGF0ZVBhcmFtZXRlcnMgPSB7XG4gICAgZnVuY3Rpb25OYW1lOiBgcHJpc21hLiR7b3JpZ2luYWxNZXRob2R9KClgLFxuICAgIG1lc3NhZ2UsXG4gICAgaXNQYW5pYzogaXNQYW5pYyAhPSBudWxsID8gaXNQYW5pYyA6IGZhbHNlLFxuICAgIGNhbGxBcmd1bWVudHNcbiAgfTtcbiAgaWYgKCFjYWxsc2l0ZSB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlUGFyYW1ldGVycztcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlUGFyYW1ldGVycztcbiAgfVxuICBjb25zdCBjYWxsTG9jYXRpb24gPSBjYWxsc2l0ZS5nZXRMb2NhdGlvbigpO1xuICBpZiAoIWNhbGxMb2NhdGlvbiB8fCAhY2FsbExvY2F0aW9uLmxpbmVOdW1iZXIgfHwgIWNhbGxMb2NhdGlvbi5jb2x1bW5OdW1iZXIpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVQYXJhbWV0ZXJzO1xuICB9XG4gIGNvbnN0IGNvbnRleHRGaXJzdExpbmUgPSBNYXRoLm1heCgxLCBjYWxsTG9jYXRpb24ubGluZU51bWJlciAtIDMpO1xuICBsZXQgc291cmNlID0gKF9hMyA9IFNvdXJjZUZpbGVTbGljZS5yZWFkKGNhbGxMb2NhdGlvbi5maWxlTmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuc2xpY2UoY29udGV4dEZpcnN0TGluZSwgY2FsbExvY2F0aW9uLmxpbmVOdW1iZXIpO1xuICBpZiAoc291cmNlKSB7XG4gICAgY29uc3QgaW52b2NhdGlvbkxpbmUgPSBzb3VyY2UubGluZUF0KGNhbGxMb2NhdGlvbi5saW5lTnVtYmVyKTtcbiAgICBjb25zdCBpbnZvY2F0aW9uTGluZUluZGVudCA9IGdldEluZGVudChpbnZvY2F0aW9uTGluZSk7XG4gICAgY29uc3QgaW52b2NhdGlvbkNhbGxDb2RlID0gZmluZFByaXNtYUFjdGlvbkNhbGwoaW52b2NhdGlvbkxpbmUpO1xuICAgIGlmICghaW52b2NhdGlvbkNhbGxDb2RlKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICB0ZW1wbGF0ZVBhcmFtZXRlcnMuZnVuY3Rpb25OYW1lID0gYCR7aW52b2NhdGlvbkNhbGxDb2RlLmNvZGV9KWA7XG4gICAgdGVtcGxhdGVQYXJhbWV0ZXJzLmxvY2F0aW9uID0gY2FsbExvY2F0aW9uO1xuICAgIGlmICghaXNQYW5pYykge1xuICAgICAgc291cmNlID0gc291cmNlLm1hcExpbmVBdChjYWxsTG9jYXRpb24ubGluZU51bWJlciwgKGxpbmUpID0+IGxpbmUuc2xpY2UoMCwgaW52b2NhdGlvbkNhbGxDb2RlLm9wZW5pbmdCcmFjZUluZGV4KSk7XG4gICAgfVxuICAgIHNvdXJjZSA9IGNvbG9ycy5oaWdobGlnaHRTb3VyY2Uoc291cmNlKTtcbiAgICBjb25zdCBudW1iZXJDb2x1bW5XaWR0aCA9IFN0cmluZyhzb3VyY2UubGFzdExpbmVOdW1iZXIpLmxlbmd0aDtcbiAgICB0ZW1wbGF0ZVBhcmFtZXRlcnMuY29udGV4dExpbmVzID0gc291cmNlLm1hcExpbmVzKChsaW5lLCBsaW5lTnVtYmVyKSA9PiBjb2xvcnMuZ3JheShTdHJpbmcobGluZU51bWJlcikucGFkU3RhcnQobnVtYmVyQ29sdW1uV2lkdGgpKSArIFwiIFwiICsgbGluZSkubWFwTGluZXMoKGxpbmUpID0+IGNvbG9ycy5kaW0obGluZSkpLnByZXBlbmRTeW1ib2xBdChjYWxsTG9jYXRpb24ubGluZU51bWJlciwgY29sb3JzLmJvbGQoY29sb3JzLnJlZChcIlxcdTIxOTJcIikpKTtcbiAgICBpZiAoY2FsbEFyZ3VtZW50cykge1xuICAgICAgbGV0IGluZGVudFZhbHVlID0gaW52b2NhdGlvbkxpbmVJbmRlbnQgKyBudW1iZXJDb2x1bW5XaWR0aCArIDE7XG4gICAgICBpbmRlbnRWYWx1ZSArPSAyO1xuICAgICAgdGVtcGxhdGVQYXJhbWV0ZXJzLmNhbGxBcmd1bWVudHMgPSAoMCwgaW1wb3J0X2luZGVudF9zdHJpbmczLmRlZmF1bHQpKGNhbGxBcmd1bWVudHMsIGluZGVudFZhbHVlKS5zbGljZShpbmRlbnRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZW1wbGF0ZVBhcmFtZXRlcnM7XG59XG5fX25hbWUoZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzLCBcImdldFRlbXBsYXRlUGFyYW1ldGVyc1wiKTtcbmZ1bmN0aW9uIGZpbmRQcmlzbWFBY3Rpb25DYWxsKHN0cikge1xuICBjb25zdCBhbGxBY3Rpb25zID0gYWxsQ2xpZW50TW9kZWxBY3Rpb25zLmpvaW4oXCJ8XCIpO1xuICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKFN0cmluZy5yYXdgXFxTKygke2FsbEFjdGlvbnN9KVxcKGApO1xuICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cik7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBtYXRjaFswXSxcbiAgICAgIG9wZW5pbmdCcmFjZUluZGV4OiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5fX25hbWUoZmluZFByaXNtYUFjdGlvbkNhbGwsIFwiZmluZFByaXNtYUFjdGlvbkNhbGxcIik7XG5mdW5jdGlvbiBnZXRJbmRlbnQobGluZSkge1xuICBsZXQgc3BhY2VDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lLmNoYXJBdChpKSAhPT0gXCIgXCIpIHtcbiAgICAgIHJldHVybiBzcGFjZUNvdW50O1xuICAgIH1cbiAgICBzcGFjZUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIHNwYWNlQ291bnQ7XG59XG5fX25hbWUoZ2V0SW5kZW50LCBcImdldEluZGVudFwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yTWVzc2FnZSh7IGZ1bmN0aW9uTmFtZSwgbG9jYXRpb24sIG1lc3NhZ2UsIGlzUGFuaWMsIGNvbnRleHRMaW5lcywgY2FsbEFyZ3VtZW50cyB9LCBjb2xvcnMpIHtcbiAgY29uc3QgbGluZXMgPSBbXCJcIl07XG4gIGNvbnN0IGludHJvU3VmZml4ID0gbG9jYXRpb24gPyBcIiBpblwiIDogXCI6XCI7XG4gIGlmIChpc1BhbmljKSB7XG4gICAgbGluZXMucHVzaChjb2xvcnMucmVkKGBPb3BzLCBhbiB1bmtub3duIGVycm9yIG9jY3VyZWQhIFRoaXMgaXMgJHtjb2xvcnMuYm9sZChcIm9uIHVzXCIpfSwgeW91IGRpZCBub3RoaW5nIHdyb25nLmApKTtcbiAgICBsaW5lcy5wdXNoKGNvbG9ycy5yZWQoYEl0IG9jY3VyZWQgaW4gdGhlICR7Y29sb3JzLmJvbGQoYFxcYCR7ZnVuY3Rpb25OYW1lfVxcYGApfSBpbnZvY2F0aW9uJHtpbnRyb1N1ZmZpeH1gKSk7XG4gIH0gZWxzZSB7XG4gICAgbGluZXMucHVzaChjb2xvcnMucmVkKGBJbnZhbGlkICR7Y29sb3JzLmJvbGQoYFxcYCR7ZnVuY3Rpb25OYW1lfVxcYGApfSBpbnZvY2F0aW9uJHtpbnRyb1N1ZmZpeH1gKSk7XG4gIH1cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgbGluZXMucHVzaChjb2xvcnMudW5kZXJsaW5lKHN0cmluZ2lmeUxvY2F0aW9uSW5GaWxlKGxvY2F0aW9uKSkpO1xuICB9XG4gIGlmIChjb250ZXh0TGluZXMpIHtcbiAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgIGNvbnN0IGNvbnRleHRMaW5lUGFydHMgPSBbY29udGV4dExpbmVzLnRvU3RyaW5nKCldO1xuICAgIGlmIChjYWxsQXJndW1lbnRzKSB7XG4gICAgICBjb250ZXh0TGluZVBhcnRzLnB1c2goY2FsbEFyZ3VtZW50cyk7XG4gICAgICBjb250ZXh0TGluZVBhcnRzLnB1c2goY29sb3JzLmRpbShcIilcIikpO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKGNvbnRleHRMaW5lUGFydHMuam9pbihcIlwiKSk7XG4gICAgaWYgKGNhbGxBcmd1bWVudHMpIHtcbiAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgaWYgKGNhbGxBcmd1bWVudHMpIHtcbiAgICAgIGxpbmVzLnB1c2goY2FsbEFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGxpbmVzLnB1c2goXCJcIik7XG4gIH1cbiAgbGluZXMucHVzaChtZXNzYWdlKTtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5fX25hbWUoc3RyaW5naWZ5RXJyb3JNZXNzYWdlLCBcInN0cmluZ2lmeUVycm9yTWVzc2FnZVwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUxvY2F0aW9uSW5GaWxlKGxvY2F0aW9uKSB7XG4gIGNvbnN0IHBhcnRzID0gW2xvY2F0aW9uLmZpbGVOYW1lXTtcbiAgaWYgKGxvY2F0aW9uLmxpbmVOdW1iZXIpIHtcbiAgICBwYXJ0cy5wdXNoKFN0cmluZyhsb2NhdGlvbi5saW5lTnVtYmVyKSk7XG4gIH1cbiAgaWYgKGxvY2F0aW9uLmNvbHVtbk51bWJlcikge1xuICAgIHBhcnRzLnB1c2goU3RyaW5nKGxvY2F0aW9uLmNvbHVtbk51bWJlcikpO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiOlwiKTtcbn1cbl9fbmFtZShzdHJpbmdpZnlMb2NhdGlvbkluRmlsZSwgXCJzdHJpbmdpZnlMb2NhdGlvbkluRmlsZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWVzc2FnZVdpdGhDb250ZXh0KGFyZ3MpIHtcbiAgY29uc3QgY29sb3JzID0gYXJncy5zaG93Q29sb3JzID8gY29sb3JzRW5hYmxlZCA6IGNvbG9yc0Rpc2FibGVkO1xuICBjb25zdCB0ZW1wbGF0ZVBhcmFtZXRlcnMgPSBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoYXJncywgY29sb3JzKTtcbiAgcmV0dXJuIHN0cmluZ2lmeUVycm9yTWVzc2FnZSh0ZW1wbGF0ZVBhcmFtZXRlcnMsIGNvbG9ycyk7XG59XG5fX25hbWUoY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHQsIFwiY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2RlZXAtZXh0ZW5kLnRzXG5mdW5jdGlvbiBpc1NwZWNpZmljVmFsdWUodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIgfHwgdmFsIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWwgaW5zdGFuY2VvZiBSZWdFeHAgPyB0cnVlIDogZmFsc2U7XG59XG5fX25hbWUoaXNTcGVjaWZpY1ZhbHVlLCBcImlzU3BlY2lmaWNWYWx1ZVwiKTtcbmZ1bmN0aW9uIGNsb25lU3BlY2lmaWNWYWx1ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIGNvbnN0IHggPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2ModmFsLmxlbmd0aCkgOiBuZXcgQnVmZmVyKHZhbC5sZW5ndGgpO1xuICAgIHZhbC5jb3B5KHgpO1xuICAgIHJldHVybiB4O1xuICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodmFsLmdldFRpbWUoKSk7XG4gIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpdHVhdGlvblwiKTtcbiAgfVxufVxuX19uYW1lKGNsb25lU3BlY2lmaWNWYWx1ZSwgXCJjbG9uZVNwZWNpZmljVmFsdWVcIik7XG5mdW5jdGlvbiBkZWVwQ2xvbmVBcnJheShhcnIpIHtcbiAgY29uc3QgY2xvbmUyID0gW107XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGNsb25lMltpbmRleF0gPSBkZWVwQ2xvbmVBcnJheShpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTcGVjaWZpY1ZhbHVlKGl0ZW0pKSB7XG4gICAgICAgIGNsb25lMltpbmRleF0gPSBjbG9uZVNwZWNpZmljVmFsdWUoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZTJbaW5kZXhdID0gZGVlcEV4dGVuZCh7fSwgaXRlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lMltpbmRleF0gPSBpdGVtO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9uZTI7XG59XG5fX25hbWUoZGVlcENsb25lQXJyYXksIFwiZGVlcENsb25lQXJyYXlcIik7XG5mdW5jdGlvbiBzYWZlR2V0UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcGVydHkgPT09IFwiX19wcm90b19fXCIgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xufVxuX19uYW1lKHNhZmVHZXRQcm9wZXJ0eSwgXCJzYWZlR2V0UHJvcGVydHlcIik7XG52YXIgZGVlcEV4dGVuZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24odGFyZ2V0LCAuLi5hcmdzKSB7XG4gIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBsZXQgdmFsLCBzcmM7XG4gIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgc3JjID0gc2FmZUdldFByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICAgIHZhbCA9IHNhZmVHZXRQcm9wZXJ0eShvYmosIGtleSk7XG4gICAgICBpZiAodmFsID09PSB0YXJnZXQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwib2JqZWN0XCIgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gZGVlcENsb25lQXJyYXkodmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGlzU3BlY2lmaWNWYWx1ZSh2YWwpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmVTcGVjaWZpY1ZhbHVlKHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjICE9PSBcIm9iamVjdFwiIHx8IHNyYyA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwRXh0ZW5kKHt9LCB2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gZGVlcEV4dGVuZChzcmMsIHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufSwgXCJkZWVwRXh0ZW5kXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9kZWVwLXNldC50c1xudmFyIGtleXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChrcykgPT4gQXJyYXkuaXNBcnJheShrcykgPyBrcyA6IGtzLnNwbGl0KFwiLlwiKSwgXCJrZXlzXCIpO1xudmFyIGRlZXBHZXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvLCBrcCkgPT4ga2V5cyhrcCkucmVkdWNlKChvMiwgaykgPT4gbzIgJiYgbzJba10sIG8pLCBcImRlZXBHZXRcIik7XG52YXIgZGVlcFNldCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG8sIGtwLCB2KSA9PiBrZXlzKGtwKS5yZWR1Y2VSaWdodCgodjIsIGssIGksIGtzKSA9PiBPYmplY3QuYXNzaWduKHt9LCBkZWVwR2V0KG8sIGtzLnNsaWNlKDAsIGkpKSwgeyBba106IHYyIH0pLCB2KSwgXCJkZWVwU2V0XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9maWx0ZXJPYmplY3QudHNcbmZ1bmN0aW9uIGZpbHRlck9iamVjdChvYmosIGNiKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iai5oYXNPd25Qcm9wZXJ0eSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBuZXdPYmogPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGNiKGtleSwgdmFsdWUpKSB7XG4gICAgICBuZXdPYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuX19uYW1lKGZpbHRlck9iamVjdCwgXCJmaWx0ZXJPYmplY3RcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2ZsYXRNYXAudHNcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5KTtcbn1cbl9fbmFtZShmbGF0dGVuLCBcImZsYXR0ZW5cIik7XG5mdW5jdGlvbiBmbGF0TWFwKGFycmF5LCBjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmbGF0dGVuKGFycmF5Lm1hcChjYWxsYmFja0ZuLCB0aGlzQXJnKSk7XG59XG5fX25hbWUoZmxhdE1hcCwgXCJmbGF0TWFwXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9pc09iamVjdC50c1xudmFyIG5vdFJlYWxseU9iamVjdHMgPSB7XG4gIFwiW29iamVjdCBEYXRlXVwiOiB0cnVlLFxuICBcIltvYmplY3QgVWludDhBcnJheV1cIjogdHJ1ZSxcbiAgXCJbb2JqZWN0IERlY2ltYWxdXCI6IHRydWVcbn07XG5mdW5jdGlvbiBpc09iamVjdDIodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFub3RSZWFsbHlPYmplY3RzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuX19uYW1lKGlzT2JqZWN0MiwgXCJpc09iamVjdFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvb21pdC50c1xuZnVuY3Rpb24gb21pdDIob2JqZWN0LCBwYXRoNykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgcGF0aHMgPSBBcnJheS5pc0FycmF5KHBhdGg3KSA/IHBhdGg3IDogW3BhdGg3XTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiAhcGF0aHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbl9fbmFtZShvbWl0MiwgXCJvbWl0XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9wcmludEpzb25FcnJvcnMudHNcbnZhciBpbXBvcnRfY2hhbGsxMCA9IF9fdG9FU00ocmVxdWlyZV9zb3VyY2UoKSk7XG52YXIgaW1wb3J0X3N0cmlwX2Fuc2kyID0gX190b0VTTShyZXF1aXJlX3N0cmlwX2Fuc2koKSk7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL3N0cmluZ2lmeU9iamVjdC50c1xudmFyIGlzUmVnZXhwID0gcmVxdWlyZV9pc19yZWdleHAoKTtcbnZhciBpc09iaiA9IHJlcXVpcmVfaXNfb2JqKCk7XG52YXIgZ2V0T3duRW51bVByb3BTeW1ib2xzID0gcmVxdWlyZV9saWIoKS5kZWZhdWx0O1xudmFyIHN0cmluZ2lmeU9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGlucHV0LCBvcHRpb25zLCBwYWQpID0+IHtcbiAgY29uc3Qgc2VlbiA9IFtdO1xuICByZXR1cm4gKC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0MihpbnB1dDIsIG9wdGlvbnMyID0ge30sIHBhZDIgPSBcIlwiLCBwYXRoNyA9IFtdKSB7XG4gICAgb3B0aW9uczIuaW5kZW50ID0gb3B0aW9uczIuaW5kZW50IHx8IFwiXHRcIjtcbiAgICBsZXQgdG9rZW5zO1xuICAgIGlmIChvcHRpb25zMi5pbmxpbmVDaGFyYWN0ZXJMaW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB0b2tlbnMgPSB7XG4gICAgICAgIG5ld0xpbmU6IFwiXFxuXCIsXG4gICAgICAgIG5ld0xpbmVPclNwYWNlOiBcIlxcblwiLFxuICAgICAgICBwYWQ6IHBhZDIsXG4gICAgICAgIGluZGVudDogcGFkMiArIG9wdGlvbnMyLmluZGVudFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5zID0ge1xuICAgICAgICBuZXdMaW5lOiBcIkBAX19TVFJJTkdJRllfT0JKRUNUX05FV19MSU5FX19AQFwiLFxuICAgICAgICBuZXdMaW5lT3JTcGFjZTogXCJAQF9fU1RSSU5HSUZZX09CSkVDVF9ORVdfTElORV9PUl9TUEFDRV9fQEBcIixcbiAgICAgICAgcGFkOiBcIkBAX19TVFJJTkdJRllfT0JKRUNUX1BBRF9fQEBcIixcbiAgICAgICAgaW5kZW50OiBcIkBAX19TVFJJTkdJRllfT0JKRUNUX0lOREVOVF9fQEBcIlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhwYW5kV2hpdGVTcGFjZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0cmluZykgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMyLmlubGluZUNoYXJhY3RlckxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZUxpbmVkID0gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0b2tlbnMubmV3TGluZSwgXCJnXCIpLCBcIlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLm5ld0xpbmVPclNwYWNlLCBcImdcIiksIFwiIFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLnBhZCArIFwifFwiICsgdG9rZW5zLmluZGVudCwgXCJnXCIpLCBcIlwiKTtcbiAgICAgIGlmIChvbmVMaW5lZC5sZW5ndGggPD0gb3B0aW9uczIuaW5saW5lQ2hhcmFjdGVyTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIG9uZUxpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLm5ld0xpbmUgKyBcInxcIiArIHRva2Vucy5uZXdMaW5lT3JTcGFjZSwgXCJnXCIpLCBcIlxcblwiKS5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLnBhZCwgXCJnXCIpLCBwYWQyKS5yZXBsYWNlKG5ldyBSZWdFeHAodG9rZW5zLmluZGVudCwgXCJnXCIpLCBwYWQyICsgb3B0aW9uczIuaW5kZW50KTtcbiAgICB9LCBcImV4cGFuZFdoaXRlU3BhY2VcIik7XG4gICAgaWYgKHNlZW4uaW5kZXhPZihpbnB1dDIpICE9PSAtMSkge1xuICAgICAgcmV0dXJuICdcIltDaXJjdWxhcl1cIic7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQyKSkge1xuICAgICAgcmV0dXJuIGBCdWZmZXIoJHtCdWZmZXIubGVuZ3RofSlgO1xuICAgIH1cbiAgICBpZiAoaW5wdXQyID09PSBudWxsIHx8IGlucHV0MiA9PT0gdm9pZCAwIHx8IHR5cGVvZiBpbnB1dDIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGlucHV0MiA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGlucHV0MiA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBpbnB1dDIgPT09IFwic3ltYm9sXCIgfHwgaW5wdXQyIGluc3RhbmNlb2YgT2JqZWN0RW51bVZhbHVlIHx8IGlzUmVnZXhwKGlucHV0MikpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQyKTtcbiAgICB9XG4gICAgaWYgKGlucHV0MiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBgbmV3IERhdGUoJyR7aW5wdXQyLnRvSVNPU3RyaW5nKCl9JylgO1xuICAgIH1cbiAgICBpZiAoaW5wdXQyIGluc3RhbmNlb2YgRmllbGRSZWZJbXBsKSB7XG4gICAgICByZXR1cm4gYHByaXNtYS4ke2xvd2VyQ2FzZShpbnB1dDIubW9kZWxOYW1lKX0uZmllbGRzLiR7aW5wdXQyLm5hbWV9YDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQyKSkge1xuICAgICAgaWYgKGlucHV0Mi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiW11cIjtcbiAgICAgIH1cbiAgICAgIHNlZW4ucHVzaChpbnB1dDIpO1xuICAgICAgY29uc3QgcmV0ID0gXCJbXCIgKyB0b2tlbnMubmV3TGluZSArIGlucHV0Mi5tYXAoKGVsLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGVvbCA9IGlucHV0Mi5sZW5ndGggLSAxID09PSBpID8gdG9rZW5zLm5ld0xpbmUgOiBcIixcIiArIHRva2Vucy5uZXdMaW5lT3JTcGFjZTtcbiAgICAgICAgbGV0IHZhbHVlID0gc3RyaW5naWZ5T2JqZWN0MihlbCwgb3B0aW9uczIsIHBhZDIgKyBvcHRpb25zMi5pbmRlbnQsIFsuLi5wYXRoNywgaV0pO1xuICAgICAgICBpZiAob3B0aW9uczIudHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMyLnRyYW5zZm9ybVZhbHVlKGlucHV0MiwgaSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnMuaW5kZW50ICsgdmFsdWUgKyBlb2w7XG4gICAgICB9KS5qb2luKFwiXCIpICsgdG9rZW5zLnBhZCArIFwiXVwiO1xuICAgICAgc2Vlbi5wb3AoKTtcbiAgICAgIHJldHVybiBleHBhbmRXaGl0ZVNwYWNlKHJldCk7XG4gICAgfVxuICAgIGlmIChpc09iaihpbnB1dDIpKSB7XG4gICAgICBsZXQgb2JqS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0MikuY29uY2F0KGdldE93bkVudW1Qcm9wU3ltYm9scyhpbnB1dDIpKTtcbiAgICAgIGlmIChvcHRpb25zMi5maWx0ZXIpIHtcbiAgICAgICAgb2JqS2V5cyA9IG9iaktleXMuZmlsdGVyKChlbCkgPT4gb3B0aW9uczIuZmlsdGVyKGlucHV0MiwgZWwpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmpLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJ7fVwiO1xuICAgICAgfVxuICAgICAgc2Vlbi5wdXNoKGlucHV0Mik7XG4gICAgICBjb25zdCByZXQgPSBcIntcIiArIHRva2Vucy5uZXdMaW5lICsgb2JqS2V5cy5tYXAoKGVsLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGVvbCA9IG9iaktleXMubGVuZ3RoIC0gMSA9PT0gaSA/IHRva2Vucy5uZXdMaW5lIDogXCIsXCIgKyB0b2tlbnMubmV3TGluZU9yU3BhY2U7XG4gICAgICAgIGNvbnN0IGlzU3ltYm9sID0gdHlwZW9mIGVsID09PSBcInN5bWJvbFwiO1xuICAgICAgICBjb25zdCBpc0NsYXNzaWMgPSAhaXNTeW1ib2wgJiYgL15bYS16JF9dW2EteiRfMC05XSokL2kudGVzdChlbCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGlzU3ltYm9sIHx8IGlzQ2xhc3NpYyA/IGVsIDogc3RyaW5naWZ5T2JqZWN0MihlbCwgb3B0aW9uczIsIHZvaWQgMCwgWy4uLnBhdGg3LCBlbF0pO1xuICAgICAgICBsZXQgdmFsdWUgPSBzdHJpbmdpZnlPYmplY3QyKGlucHV0MltlbF0sIG9wdGlvbnMyLCBwYWQyICsgb3B0aW9uczIuaW5kZW50LCBbLi4ucGF0aDcsIGVsXSk7XG4gICAgICAgIGlmIChvcHRpb25zMi50cmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9uczIudHJhbnNmb3JtVmFsdWUoaW5wdXQyLCBlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lID0gdG9rZW5zLmluZGVudCArIFN0cmluZyhrZXkpICsgXCI6IFwiICsgdmFsdWUgKyBlb2w7XG4gICAgICAgIGlmIChvcHRpb25zMi50cmFuc2Zvcm1MaW5lKSB7XG4gICAgICAgICAgbGluZSA9IG9wdGlvbnMyLnRyYW5zZm9ybUxpbmUoe1xuICAgICAgICAgICAgb2JqOiBpbnB1dDIsXG4gICAgICAgICAgICBpbmRlbnQ6IHRva2Vucy5pbmRlbnQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzdHJpbmdpZmllZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dDJbZWxdLFxuICAgICAgICAgICAgZW9sLFxuICAgICAgICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgICAgICAgcGF0aDogcGF0aDcuY29uY2F0KGtleSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH0pLmpvaW4oXCJcIikgKyB0b2tlbnMucGFkICsgXCJ9XCI7XG4gICAgICBzZWVuLnBvcCgpO1xuICAgICAgcmV0dXJuIGV4cGFuZFdoaXRlU3BhY2UocmV0KTtcbiAgICB9XG4gICAgaW5wdXQyID0gU3RyaW5nKGlucHV0MikucmVwbGFjZSgvW1xcclxcbl0vZywgKHgpID0+IHggPT09IFwiXFxuXCIgPyBcIlxcXFxuXCIgOiBcIlxcXFxyXCIpO1xuICAgIGlmIChvcHRpb25zMi5zaW5nbGVRdW90ZXMgPT09IGZhbHNlKSB7XG4gICAgICBpbnB1dDIgPSBpbnB1dDIucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICAgICAgcmV0dXJuIGBcIiR7aW5wdXQyfVwiYDtcbiAgICB9XG4gICAgaW5wdXQyID0gaW5wdXQyLnJlcGxhY2UoL1xcXFw/Jy9nLCBcIlxcXFwnXCIpO1xuICAgIHJldHVybiBgJyR7aW5wdXQyfSdgO1xuICB9LCBcInN0cmluZ2lmeU9iamVjdFwiKSkoaW5wdXQsIG9wdGlvbnMsIHBhZCk7XG59LCBcInN0cmluZ2lmeU9iamVjdFwiKTtcbnZhciBzdHJpbmdpZnlPYmplY3RfZGVmYXVsdCA9IHN0cmluZ2lmeU9iamVjdDtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvcHJpbnRKc29uRXJyb3JzLnRzXG52YXIgRElNX1RPS0VOID0gXCJAQF9fRElNX1BPSU5URVJfX0BAXCI7XG5mdW5jdGlvbiBwcmludEpzb25XaXRoRXJyb3JzKHsgYXN0LCBrZXlQYXRocywgdmFsdWVQYXRocywgbWlzc2luZ0l0ZW1zIH0pIHtcbiAgbGV0IG9iaiA9IGFzdDtcbiAgZm9yIChjb25zdCB7IHBhdGg6IHBhdGg3LCB0eXBlIH0gb2YgbWlzc2luZ0l0ZW1zKSB7XG4gICAgb2JqID0gZGVlcFNldChvYmosIHBhdGg3LCB0eXBlKTtcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0X2RlZmF1bHQob2JqLCB7XG4gICAgaW5kZW50OiBcIiAgXCIsXG4gICAgdHJhbnNmb3JtTGluZTogKHsgaW5kZW50OiBpbmRlbnQ0LCBrZXksIHZhbHVlLCBzdHJpbmdpZmllZFZhbHVlLCBlb2wsIHBhdGg6IHBhdGg3IH0pID0+IHtcbiAgICAgIGNvbnN0IGRvdHRlZFBhdGggPSBwYXRoNy5qb2luKFwiLlwiKTtcbiAgICAgIGNvbnN0IGtleUVycm9yID0ga2V5UGF0aHMuaW5jbHVkZXMoZG90dGVkUGF0aCk7XG4gICAgICBjb25zdCB2YWx1ZUVycm9yID0gdmFsdWVQYXRocy5pbmNsdWRlcyhkb3R0ZWRQYXRoKTtcbiAgICAgIGNvbnN0IG1pc3NpbmdJdGVtID0gbWlzc2luZ0l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0ucGF0aCA9PT0gZG90dGVkUGF0aCk7XG4gICAgICBsZXQgdmFsdWVTdHIgPSBzdHJpbmdpZmllZFZhbHVlO1xuICAgICAgaWYgKG1pc3NpbmdJdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZVN0ciA9IHZhbHVlU3RyLnNsaWNlKDEsIHZhbHVlU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUmVxdWlyZWRTdHIgPSBtaXNzaW5nSXRlbS5pc1JlcXVpcmVkID8gXCJcIiA6IFwiP1wiO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBtaXNzaW5nSXRlbS5pc1JlcXVpcmVkID8gXCIrXCIgOiBcIj9cIjtcbiAgICAgICAgY29uc3QgY29sb3IgPSBtaXNzaW5nSXRlbS5pc1JlcXVpcmVkID8gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5ncmVlbkJyaWdodCA6IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZ3JlZW47XG4gICAgICAgIGxldCBvdXRwdXQgPSBjb2xvcihwcmVmaXhMaW5lcyhrZXkgKyBpc1JlcXVpcmVkU3RyICsgXCI6IFwiICsgdmFsdWVTdHIgKyBlb2wsIGluZGVudDQsIHByZWZpeCkpO1xuICAgICAgICBpZiAoIW1pc3NpbmdJdGVtLmlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBvdXRwdXQgPSBpbXBvcnRfY2hhbGsxMC5kZWZhdWx0LmRpbShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc09uTWlzc2luZ0l0ZW1QYXRoID0gbWlzc2luZ0l0ZW1zLnNvbWUoKGl0ZW0pID0+IGRvdHRlZFBhdGguc3RhcnRzV2l0aChpdGVtLnBhdGgpKTtcbiAgICAgICAgY29uc3QgaXNPcHRpb25hbCA9IGtleVtrZXkubGVuZ3RoIC0gMl0gPT09IFwiP1wiO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgIGtleSA9IGtleS5zbGljZSgxLCBrZXkubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWVTdHIgPSB2YWx1ZVN0ci5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUsIGluZGV4LCBhcnIpID0+IGluZGV4ID09PSBhcnIubGVuZ3RoIC0gMSA/IGxpbmUgKyBESU1fVE9LRU4gOiBsaW5lKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09uTWlzc2luZ0l0ZW1QYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlU3RyID0gdmFsdWVTdHIuc2xpY2UoMSwgdmFsdWVTdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgaWYgKCFpc09wdGlvbmFsKSB7XG4gICAgICAgICAgICB2YWx1ZVN0ciA9IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuYm9sZCh2YWx1ZVN0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSAmJiAhdmFsdWVFcnJvciAmJiAhaXNPbk1pc3NpbmdJdGVtUGF0aCkge1xuICAgICAgICAgIHZhbHVlU3RyID0gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5kaW0odmFsdWVTdHIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVN0ciA9IGtleUVycm9yID8gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5yZWRCcmlnaHQoa2V5KSA6IGtleTtcbiAgICAgICAgdmFsdWVTdHIgPSB2YWx1ZUVycm9yID8gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5yZWRCcmlnaHQodmFsdWVTdHIpIDogdmFsdWVTdHI7XG4gICAgICAgIGxldCBvdXRwdXQgPSBpbmRlbnQ0ICsga2V5U3RyICsgXCI6IFwiICsgdmFsdWVTdHIgKyAoaXNPbk1pc3NpbmdJdGVtUGF0aCA/IGVvbCA6IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZGltKGVvbCkpO1xuICAgICAgICBpZiAoa2V5RXJyb3IgfHwgdmFsdWVFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gb3V0cHV0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IFN0cmluZyhrZXkpLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBrZXlTY3JpYmJsZXMgPSBrZXlFcnJvciA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQucmVkQnJpZ2h0KFwiflwiLnJlcGVhdChrZXlMZW5ndGgpKSA6IFwiIFwiLnJlcGVhdChrZXlMZW5ndGgpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlTGVuZ3RoID0gdmFsdWVFcnJvciA/IGdldFZhbHVlTGVuZ3RoKGluZGVudDQsIGtleSwgdmFsdWUsIHN0cmluZ2lmaWVkVmFsdWUpIDogMDtcbiAgICAgICAgICBjb25zdCBoaWRlVmFsdWVTY3JpYmJsZXMgPSB2YWx1ZUVycm9yICYmIGlzUmVuZGVyZWRBc09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgY29uc3QgdmFsdWVTY3JpYmJsZXMgPSB2YWx1ZUVycm9yID8gXCIgIFwiICsgaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5yZWRCcmlnaHQoXCJ+XCIucmVwZWF0KHZhbHVlTGVuZ3RoKSkgOiBcIlwiO1xuICAgICAgICAgIGlmIChrZXlTY3JpYmJsZXMgJiYga2V5U2NyaWJibGVzLmxlbmd0aCA+IDAgJiYgIWhpZGVWYWx1ZVNjcmliYmxlcykge1xuICAgICAgICAgICAgbGluZXMuc3BsaWNlKDEsIDAsIGluZGVudDQgKyBrZXlTY3JpYmJsZXMgKyB2YWx1ZVNjcmliYmxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlTY3JpYmJsZXMgJiYga2V5U2NyaWJibGVzLmxlbmd0aCA+IDAgJiYgaGlkZVZhbHVlU2NyaWJibGVzKSB7XG4gICAgICAgICAgICBsaW5lcy5zcGxpY2UobGluZXMubGVuZ3RoIC0gMSwgMCwgaW5kZW50NC5zbGljZSgwLCBpbmRlbnQ0Lmxlbmd0aCAtIDIpICsgdmFsdWVTY3JpYmJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbl9fbmFtZShwcmludEpzb25XaXRoRXJyb3JzLCBcInByaW50SnNvbldpdGhFcnJvcnNcIik7XG5mdW5jdGlvbiBnZXRWYWx1ZUxlbmd0aChpbmRlbnQ0LCBrZXksIHZhbHVlLCBzdHJpbmdpZmllZFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiA0O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoICsgMjtcbiAgfVxuICBpZiAoaXNSZW5kZXJlZEFzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBNYXRoLmFicyhnZXRMb25nZXN0TGluZShgJHtrZXl9OiAkeygwLCBpbXBvcnRfc3RyaXBfYW5zaTIuZGVmYXVsdCkoc3RyaW5naWZpZWRWYWx1ZSl9YCkgLSBpbmRlbnQ0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoO1xufVxuX19uYW1lKGdldFZhbHVlTGVuZ3RoLCBcImdldFZhbHVlTGVuZ3RoXCIpO1xuZnVuY3Rpb24gaXNSZW5kZXJlZEFzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdEVudW1WYWx1ZSk7XG59XG5fX25hbWUoaXNSZW5kZXJlZEFzT2JqZWN0LCBcImlzUmVuZGVyZWRBc09iamVjdFwiKTtcbmZ1bmN0aW9uIGdldExvbmdlc3RMaW5lKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KFwiXFxuXCIpLnJlZHVjZSgobWF4MiwgY3VycikgPT4gY3Vyci5sZW5ndGggPiBtYXgyID8gY3Vyci5sZW5ndGggOiBtYXgyLCAwKTtcbn1cbl9fbmFtZShnZXRMb25nZXN0TGluZSwgXCJnZXRMb25nZXN0TGluZVwiKTtcbmZ1bmN0aW9uIHByZWZpeExpbmVzKHN0ciwgaW5kZW50NCwgcHJlZml4KSB7XG4gIHJldHVybiBzdHIuc3BsaXQoXCJcXG5cIikubWFwKFxuICAgIChsaW5lLCBpbmRleCwgYXJyKSA9PiBpbmRleCA9PT0gMCA/IHByZWZpeCArIGluZGVudDQuc2xpY2UoMSkgKyBsaW5lIDogaW5kZXggPCBhcnIubGVuZ3RoIC0gMSA/IHByZWZpeCArIGxpbmUuc2xpY2UoMSkgOiBsaW5lXG4gICkubWFwKChsaW5lKSA9PiB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfc3RyaXBfYW5zaTIuZGVmYXVsdCkobGluZSkuaW5jbHVkZXMoRElNX1RPS0VOKSA/IGltcG9ydF9jaGFsazEwLmRlZmF1bHQuZGltKGxpbmUucmVwbGFjZShESU1fVE9LRU4sIFwiXCIpKSA6IGxpbmUuaW5jbHVkZXMoXCI/XCIpID8gaW1wb3J0X2NoYWxrMTAuZGVmYXVsdC5kaW0obGluZSkgOiBsaW5lO1xuICB9KS5qb2luKFwiXFxuXCIpO1xufVxuX19uYW1lKHByZWZpeExpbmVzLCBcInByZWZpeExpbmVzXCIpO1xuXG4vLyBzcmMvcnVudGltZS9xdWVyeS50c1xudmFyIHRhYiA9IDI7XG52YXIgRG9jdW1lbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5wcmludEZpZWxkRXJyb3IgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IGVycm9yOiBlcnJvcjIgfSwgbWlzc2luZ0l0ZW1zLCBtaW5pbWFsKSA9PiB7XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiZW1wdHlTZWxlY3RcIikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gbWluaW1hbCA/IFwiXCIgOiBgIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBsaXN0ZWQgaW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0LmRpbShcImdyZWVuXCIpfS5gO1xuICAgICAgICByZXR1cm4gYFRoZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KFwiYHNlbGVjdGBcIil9IHN0YXRlbWVudCBmb3IgdHlwZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcbiAgICAgICAgICBnZXRPdXRwdXRUeXBlTmFtZShlcnJvcjIuZmllbGQub3V0cHV0VHlwZS50eXBlKVxuICAgICAgICApfSBtdXN0IG5vdCBiZSBlbXB0eS4ke2FkZGl0aW9uYWx9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJlbXB0eUluY2x1ZGVcIikge1xuICAgICAgICBpZiAobWlzc2luZ0l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgICBnZXRPdXRwdXRUeXBlTmFtZShlcnJvcjIuZmllbGQub3V0cHV0VHlwZS50eXBlKVxuICAgICAgICAgICl9IGRvZXMgbm90IGhhdmUgYW55IHJlbGF0aW9uIGFuZCB0aGVyZWZvcmUgY2FuJ3QgaGF2ZSBhbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KFwiYGluY2x1ZGVgXCIpfSBzdGF0ZW1lbnQuYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gbWluaW1hbCA/IFwiXCIgOiBgIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBsaXN0ZWQgaW4gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0LmRpbShcImdyZWVuXCIpfS5gO1xuICAgICAgICByZXR1cm4gYFRoZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KFwiYGluY2x1ZGVgXCIpfSBzdGF0ZW1lbnQgZm9yIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgZ2V0T3V0cHV0VHlwZU5hbWUoZXJyb3IyLmZpZWxkLm91dHB1dFR5cGUudHlwZSlcbiAgICAgICAgKX0gbXVzdCBub3QgYmUgZW1wdHkuJHthZGRpdGlvbmFsfWA7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwibm9UcnVlU2VsZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGBUaGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcImBzZWxlY3RgXCIpfSBzdGF0ZW1lbnQgZm9yIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgZ2V0T3V0cHV0VHlwZU5hbWUoZXJyb3IyLmZpZWxkLm91dHB1dFR5cGUudHlwZSlcbiAgICAgICAgKX0gbmVlZHMgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXCJhdCBsZWFzdCBvbmUgdHJ1dGh5IHZhbHVlXCIpfS5gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImluY2x1ZGVBbmRTZWxlY3RcIikge1xuICAgICAgICByZXR1cm4gYFBsZWFzZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcImVpdGhlclwiKX0gdXNlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcImBpbmNsdWRlYFwiKX0gb3IgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFxuICAgICAgICAgIFwiYHNlbGVjdGBcIlxuICAgICAgICApfSwgYnV0ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoXCJub3QgYm90aFwiKX0gYXQgdGhlIHNhbWUgdGltZS5gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImludmFsaWRGaWVsZE5hbWVcIikge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBlcnJvcjIuaXNJbmNsdWRlID8gXCJpbmNsdWRlXCIgOiBcInNlbGVjdFwiO1xuICAgICAgICBjb25zdCB3b3JkaW5nID0gZXJyb3IyLmlzSW5jbHVkZVNjYWxhciA/IFwiSW52YWxpZCBzY2FsYXJcIiA6IFwiVW5rbm93blwiO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gbWluaW1hbCA/IFwiXCIgOiBlcnJvcjIuaXNJbmNsdWRlICYmIG1pc3NpbmdJdGVtcy5sZW5ndGggPT09IDAgPyBgXG5UaGlzIG1vZGVsIGhhcyBubyByZWxhdGlvbnMsIHNvIHlvdSBjYW4ndCB1c2UgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcImluY2x1ZGVcIil9IHdpdGggaXQuYCA6IGAgQXZhaWxhYmxlIG9wdGlvbnMgYXJlIGxpc3RlZCBpbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQuZGltKFwiZ3JlZW5cIil9LmA7XG4gICAgICAgIGxldCBzdHIgPSBgJHt3b3JkaW5nfSBmaWVsZCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KGBcXGAke2Vycm9yMi5wcm92aWRlZE5hbWV9XFxgYCl9IGZvciAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcbiAgICAgICAgICBzdGF0ZW1lbnRcbiAgICAgICAgKX0gc3RhdGVtZW50IG9uIG1vZGVsICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkLndoaXRlKGVycm9yMi5tb2RlbE5hbWUpfS4ke2FkZGl0aW9uYWx9YDtcbiAgICAgICAgaWYgKGVycm9yMi5kaWRZb3VNZWFuKSB7XG4gICAgICAgICAgc3RyICs9IGAgRGlkIHlvdSBtZWFuICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChgXFxgJHtlcnJvcjIuZGlkWW91TWVhbn1cXGBgKX0/YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IyLmlzSW5jbHVkZVNjYWxhcikge1xuICAgICAgICAgIHN0ciArPSBgXG5Ob3RlLCB0aGF0ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFwiaW5jbHVkZVwiKX0gc3RhdGVtZW50cyBvbmx5IGFjY2VwdCByZWxhdGlvbiBmaWVsZHMuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImludmFsaWRGaWVsZFR5cGVcIikge1xuICAgICAgICBjb25zdCBzdHIgPSBgSW52YWxpZCB2YWx1ZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KFxuICAgICAgICAgIGAke3N0cmluZ2lmeU9iamVjdF9kZWZhdWx0KGVycm9yMi5wcm92aWRlZFZhbHVlKX1gXG4gICAgICAgICl9IG9mIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChnZXRHcmFwaFFMVHlwZShlcnJvcjIucHJvdmlkZWRWYWx1ZSwgdm9pZCAwKSl9IGZvciBmaWVsZCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcbiAgICAgICAgICBgJHtlcnJvcjIuZmllbGROYW1lfWBcbiAgICAgICAgKX0gb24gbW9kZWwgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQud2hpdGUoZXJyb3IyLm1vZGVsTmFtZSl9LiBFeHBlY3RlZCBlaXRoZXIgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFxuICAgICAgICAgIFwidHJ1ZVwiXG4gICAgICAgICl9IG9yICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcImZhbHNlXCIpfS5gO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LCBcInByaW50RmllbGRFcnJvclwiKTtcbiAgICB0aGlzLnByaW50QXJnRXJyb3IgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IGVycm9yOiBlcnJvcjIsIHBhdGg6IHBhdGg3LCBpZCB9LCBoYXNNaXNzaW5nSXRlbXMsIG1pbmltYWwpID0+IHtcbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJpbnZhbGlkTmFtZVwiKSB7XG4gICAgICAgIGxldCBzdHIgPSBgVW5rbm93biBhcmcgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChgXFxgJHtlcnJvcjIucHJvdmlkZWROYW1lfVxcYGApfSBpbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChcbiAgICAgICAgICBwYXRoNy5qb2luKFwiLlwiKVxuICAgICAgICApfSBmb3IgdHlwZSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChlcnJvcjIub3V0cHV0VHlwZSA/IGVycm9yMi5vdXRwdXRUeXBlLm5hbWUgOiBnZXRJbnB1dFR5cGVOYW1lKGVycm9yMi5vcmlnaW5hbFR5cGUpKX0uYDtcbiAgICAgICAgaWYgKGVycm9yMi5kaWRZb3VNZWFuRmllbGQpIHtcbiAgICAgICAgICBzdHIgKz0gYFxuXFx1MjE5MiBEaWQgeW91IGZvcmdldCB0byB3cmFwIGl0IHdpdGggXFxgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KFwic2VsZWN0XCIpfVxcYD8gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmRpbShcbiAgICAgICAgICAgIFwiZS5nLiBcIiArIGltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoYHsgc2VsZWN0OiB7ICR7ZXJyb3IyLnByb3ZpZGVkTmFtZX06ICR7ZXJyb3IyLnByb3ZpZGVkVmFsdWV9IH0gfWApXG4gICAgICAgICAgKX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yMi5kaWRZb3VNZWFuQXJnKSB7XG4gICAgICAgICAgc3RyICs9IGAgRGlkIHlvdSBtZWFuIFxcYCR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChlcnJvcjIuZGlkWW91TWVhbkFyZyl9XFxgP2A7XG4gICAgICAgICAgaWYgKCFoYXNNaXNzaW5nSXRlbXMgJiYgIW1pbmltYWwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oXCJBdmFpbGFibGUgYXJnczpcIil9XG5gICsgc3RyaW5naWZ5SW5wdXRUeXBlKGVycm9yMi5vcmlnaW5hbFR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZXJyb3IyLm9yaWdpbmFsVHlwZS5maWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCBUaGUgZmllbGQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoZXJyb3IyLm9yaWdpbmFsVHlwZS5uYW1lKX0gaGFzIG5vIGFyZ3VtZW50cy5gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWhhc01pc3NpbmdJdGVtcyAmJiAhbWluaW1hbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgQXZhaWxhYmxlIGFyZ3M6XG5cbmAgKyBzdHJpbmdpZnlJbnB1dFR5cGUoZXJyb3IyLm9yaWdpbmFsVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiaW52YWxpZFR5cGVcIikge1xuICAgICAgICBsZXQgdmFsdWVTdHIgPSBzdHJpbmdpZnlPYmplY3RfZGVmYXVsdChlcnJvcjIucHJvdmlkZWRWYWx1ZSwgeyBpbmRlbnQ6IFwiICBcIiB9KTtcbiAgICAgICAgY29uc3QgbXVsdGlsaW5lVmFsdWUgPSB2YWx1ZVN0ci5zcGxpdChcIlxcblwiKS5sZW5ndGggPiAxO1xuICAgICAgICBpZiAobXVsdGlsaW5lVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZVN0ciA9IGBcbiR7dmFsdWVTdHJ9XG5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIikge1xuICAgICAgICAgIHJldHVybiBgQXJndW1lbnQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoZXJyb3IyLmFyZ05hbWUpfTogUHJvdmlkZWQgdmFsdWUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodCh2YWx1ZVN0cil9JHttdWx0aWxpbmVWYWx1ZSA/IFwiXCIgOiBcIiBcIn1vZiB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5yZWRCcmlnaHQoZ2V0R3JhcGhRTFR5cGUoZXJyb3IyLnByb3ZpZGVkVmFsdWUpKX0gb24gJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgICBgcHJpc21hLiR7dGhpcy5jaGlsZHJlblswXS5uYW1lfWBcbiAgICAgICAgICApfSBpcyBub3QgYSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXG4gICAgICAgICAgICB3cmFwV2l0aExpc3QoXG4gICAgICAgICAgICAgIHN0cmluZ2lmeUdyYXBoUUxUeXBlKGVycm9yMi5yZXF1aXJlZFR5cGUuYmVzdEZpdHRpbmdUeXBlLnR5cGUpLFxuICAgICAgICAgICAgICBlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS5pc0xpc3RcbiAgICAgICAgICAgIClcbiAgICAgICAgICApfS5cblxcdTIxOTIgUG9zc2libGUgdmFsdWVzOiAke2Vycm9yMi5yZXF1aXJlZFR5cGUuYmVzdEZpdHRpbmdUeXBlLnR5cGUudmFsdWVzLm1hcCgodikgPT4gaW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChgJHtzdHJpbmdpZnlHcmFwaFFMVHlwZShlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS50eXBlKX0uJHt2fWApKS5qb2luKFwiLCBcIil9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZVN0ciA9IFwiLlwiO1xuICAgICAgICBpZiAoaXNJbnB1dEFyZ1R5cGUoZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUudHlwZSkpIHtcbiAgICAgICAgICB0eXBlU3RyID0gXCI6XFxuXCIgKyBzdHJpbmdpZnlJbnB1dFR5cGUoZXJyb3IyLnJlcXVpcmVkVHlwZS5iZXN0Rml0dGluZ1R5cGUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4cGVjdGVkID0gYCR7ZXJyb3IyLnJlcXVpcmVkVHlwZS5pbnB1dFR5cGUubWFwKFxuICAgICAgICAgICh0KSA9PiBpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KHdyYXBXaXRoTGlzdChzdHJpbmdpZnlHcmFwaFFMVHlwZSh0LnR5cGUpLCBlcnJvcjIucmVxdWlyZWRUeXBlLmJlc3RGaXR0aW5nVHlwZS5pc0xpc3QpKVxuICAgICAgICApLmpvaW4oXCIgb3IgXCIpfSR7dHlwZVN0cn1gO1xuICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBlcnJvcjIucmVxdWlyZWRUeXBlLmlucHV0VHlwZS5sZW5ndGggPT09IDIgJiYgZXJyb3IyLnJlcXVpcmVkVHlwZS5pbnB1dFR5cGUuZmluZCgodCkgPT4gaXNJbnB1dEFyZ1R5cGUodC50eXBlKSkgfHwgbnVsbDtcbiAgICAgICAgaWYgKGlucHV0VHlwZSkge1xuICAgICAgICAgIGV4cGVjdGVkICs9IGBcbmAgKyBzdHJpbmdpZnlJbnB1dFR5cGUoaW5wdXRUeXBlLnR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQXJndW1lbnQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoZXJyb3IyLmFyZ05hbWUpfTogR290IGludmFsaWQgdmFsdWUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodCh2YWx1ZVN0cil9JHttdWx0aWxpbmVWYWx1ZSA/IFwiXCIgOiBcIiBcIn1vbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChgcHJpc21hLiR7dGhpcy5jaGlsZHJlblswXS5uYW1lfWApfS4gUHJvdmlkZWQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LnJlZEJyaWdodChcbiAgICAgICAgICBnZXRHcmFwaFFMVHlwZShlcnJvcjIucHJvdmlkZWRWYWx1ZSlcbiAgICAgICAgKX0sIGV4cGVjdGVkICR7ZXhwZWN0ZWR9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIudHlwZSA9PT0gXCJpbnZhbGlkTnVsbEFyZ1wiKSB7XG4gICAgICAgIGNvbnN0IGZvclN0ciA9IHBhdGg3Lmxlbmd0aCA9PT0gMSAmJiBwYXRoN1swXSA9PT0gZXJyb3IyLm5hbWUgPyBcIlwiIDogYCBmb3IgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoYCR7cGF0aDcuam9pbihcIi5cIil9YCl9YDtcbiAgICAgICAgY29uc3QgdW5kZWZpbmVkVGlwID0gYCBQbGVhc2UgdXNlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkLmdyZWVuQnJpZ2h0KFwidW5kZWZpbmVkXCIpfSBpbnN0ZWFkLmA7XG4gICAgICAgIHJldHVybiBgQXJndW1lbnQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuQnJpZ2h0KGVycm9yMi5uYW1lKX0ke2ZvclN0cn0gbXVzdCBub3QgYmUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXCJudWxsXCIpfS4ke3VuZGVmaW5lZFRpcH1gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcIm1pc3NpbmdBcmdcIikge1xuICAgICAgICBjb25zdCBmb3JTdHIgPSBwYXRoNy5sZW5ndGggPT09IDEgJiYgcGF0aDdbMF0gPT09IGVycm9yMi5taXNzaW5nTmFtZSA/IFwiXCIgOiBgIGZvciAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChgJHtwYXRoNy5qb2luKFwiLlwiKX1gKX1gO1xuICAgICAgICByZXR1cm4gYEFyZ3VtZW50ICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChlcnJvcjIubWlzc2luZ05hbWUpfSR7Zm9yU3RyfSBpcyBtaXNzaW5nLmA7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyLnR5cGUgPT09IFwiYXRMZWFzdE9uZVwiKSB7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWwgPSBtaW5pbWFsID8gXCJcIiA6IGAgQXZhaWxhYmxlIGFyZ3MgYXJlIGxpc3RlZCBpbiAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltLmdyZWVuKFwiZ3JlZW5cIil9LmA7XG4gICAgICAgIHJldHVybiBgQXJndW1lbnQgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQocGF0aDcuam9pbihcIi5cIikpfSBvZiB0eXBlICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ib2xkKFxuICAgICAgICAgIGVycm9yMi5pbnB1dFR5cGUubmFtZVxuICAgICAgICApfSBuZWVkcyAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZ3JlZW5CcmlnaHQoXCJhdCBsZWFzdCBvbmVcIil9IGFyZ3VtZW50LiR7YWRkaXRpb25hbH1gO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMi50eXBlID09PSBcImF0TW9zdE9uZVwiKSB7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWwgPSBtaW5pbWFsID8gXCJcIiA6IGAgUGxlYXNlIGNob29zZSBvbmUuICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oXCJBdmFpbGFibGUgYXJnczpcIil9IFxuJHtzdHJpbmdpZnlJbnB1dFR5cGUoZXJyb3IyLmlucHV0VHlwZSwgdHJ1ZSl9YDtcbiAgICAgICAgcmV0dXJuIGBBcmd1bWVudCAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuYm9sZChwYXRoNy5qb2luKFwiLlwiKSl9IG9mIHR5cGUgJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmJvbGQoXG4gICAgICAgICAgZXJyb3IyLmlucHV0VHlwZS5uYW1lXG4gICAgICAgICl9IG5lZWRzICR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5ncmVlbkJyaWdodChcImV4YWN0bHkgb25lXCIpfSBhcmd1bWVudCwgYnV0IHlvdSBwcm92aWRlZCAke2Vycm9yMi5wcm92aWRlZEtleXMubWFwKChrZXkpID0+IGltcG9ydF9jaGFsazExLmRlZmF1bHQucmVkQnJpZ2h0KGtleSkpLmpvaW4oXCIgYW5kIFwiKX0uJHthZGRpdGlvbmFsfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sIFwicHJpbnRBcmdFcnJvclwiKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiRG9jdW1lbnRcIjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy50eXBlfSB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzQuZGVmYXVsdCkodGhpcy5jaGlsZHJlbi5tYXAoU3RyaW5nKS5qb2luKFwiXFxuXCIpLCB0YWIpfVxufWA7XG4gIH1cbiAgdmFsaWRhdGUoc2VsZWN0LCBpc1RvcExldmVsUXVlcnkgPSBmYWxzZSwgb3JpZ2luYWxNZXRob2QsIGVycm9yRm9ybWF0LCB2YWxpZGF0aW9uQ2FsbHNpdGUpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICBzZWxlY3QgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgaW52YWxpZENoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5oYXNJbnZhbGlkQ2hpbGQgfHwgY2hpbGQuaGFzSW52YWxpZEFyZyk7XG4gICAgaWYgKGludmFsaWRDaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSBbXTtcbiAgICBjb25zdCBhcmdFcnJvcnMgPSBbXTtcbiAgICBjb25zdCBwcmVmaXggPSBzZWxlY3QgJiYgc2VsZWN0LnNlbGVjdCA/IFwic2VsZWN0XCIgOiBzZWxlY3QuaW5jbHVkZSA/IFwiaW5jbHVkZVwiIDogdm9pZCAwO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW52YWxpZENoaWxkcmVuKSB7XG4gICAgICBjb25zdCBlcnJvcnMgPSBjaGlsZC5jb2xsZWN0RXJyb3JzKHByZWZpeCk7XG4gICAgICBmaWVsZEVycm9ycy5wdXNoKFxuICAgICAgICAuLi5lcnJvcnMuZmllbGRFcnJvcnMubWFwKChlKSA9PiAoe1xuICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgcGF0aDogaXNUb3BMZXZlbFF1ZXJ5ID8gZS5wYXRoIDogZS5wYXRoLnNsaWNlKDEpXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICAgIGFyZ0Vycm9ycy5wdXNoKFxuICAgICAgICAuLi5lcnJvcnMuYXJnRXJyb3JzLm1hcCgoZSkgPT4gKHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIHBhdGg6IGlzVG9wTGV2ZWxRdWVyeSA/IGUucGF0aCA6IGUucGF0aC5zbGljZSgxKVxuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHRvcExldmVsUXVlcnlOYW1lID0gdGhpcy5jaGlsZHJlblswXS5uYW1lO1xuICAgIGNvbnN0IHF1ZXJ5TmFtZSA9IGlzVG9wTGV2ZWxRdWVyeSA/IHRoaXMudHlwZSA6IHRvcExldmVsUXVlcnlOYW1lO1xuICAgIGNvbnN0IGtleVBhdGhzID0gW107XG4gICAgY29uc3QgdmFsdWVQYXRocyA9IFtdO1xuICAgIGNvbnN0IG1pc3NpbmdJdGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmllbGRFcnJvciBvZiBmaWVsZEVycm9ycykge1xuICAgICAgY29uc3QgcGF0aDcgPSB0aGlzLm5vcm1hbGl6ZVBhdGgoZmllbGRFcnJvci5wYXRoLCBzZWxlY3QpLmpvaW4oXCIuXCIpO1xuICAgICAgaWYgKGZpZWxkRXJyb3IuZXJyb3IudHlwZSA9PT0gXCJpbnZhbGlkRmllbGROYW1lXCIpIHtcbiAgICAgICAga2V5UGF0aHMucHVzaChwYXRoNyk7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGZpZWxkRXJyb3IuZXJyb3Iub3V0cHV0VHlwZTtcbiAgICAgICAgY29uc3QgeyBpc0luY2x1ZGUgfSA9IGZpZWxkRXJyb3IuZXJyb3I7XG4gICAgICAgIGZpZWxkVHlwZS5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gaXNJbmNsdWRlID8gZmllbGQub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiIDogdHJ1ZSkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICBjb25zdCBzcGxpdHRlZFBhdGggPSBwYXRoNy5zcGxpdChcIi5cIik7XG4gICAgICAgICAgbWlzc2luZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogYCR7c3BsaXR0ZWRQYXRoLnNsaWNlKDAsIHNwbGl0dGVkUGF0aC5sZW5ndGggLSAxKS5qb2luKFwiLlwiKX0uJHtmaWVsZC5uYW1lfWAsXG4gICAgICAgICAgICB0eXBlOiBcInRydWVcIixcbiAgICAgICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChmaWVsZEVycm9yLmVycm9yLnR5cGUgPT09IFwiaW5jbHVkZUFuZFNlbGVjdFwiKSB7XG4gICAgICAgIGtleVBhdGhzLnB1c2goXCJzZWxlY3RcIik7XG4gICAgICAgIGtleVBhdGhzLnB1c2goXCJpbmNsdWRlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVQYXRocy5wdXNoKHBhdGg3KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZEVycm9yLmVycm9yLnR5cGUgPT09IFwiZW1wdHlTZWxlY3RcIiB8fCBmaWVsZEVycm9yLmVycm9yLnR5cGUgPT09IFwibm9UcnVlU2VsZWN0XCIgfHwgZmllbGRFcnJvci5lcnJvci50eXBlID09PSBcImVtcHR5SW5jbHVkZVwiKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdFBhdGhBcnJheSA9IHRoaXMubm9ybWFsaXplUGF0aChmaWVsZEVycm9yLnBhdGgsIHNlbGVjdCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdFBhdGggPSBzZWxlY3RQYXRoQXJyYXkuc2xpY2UoMCwgc2VsZWN0UGF0aEFycmF5Lmxlbmd0aCAtIDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZEVycm9yLmVycm9yLmZpZWxkLm91dHB1dFR5cGUudHlwZTtcbiAgICAgICAgKF9hMyA9IGZpZWxkVHlwZS5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuZmlsdGVyKFxuICAgICAgICAgIChmaWVsZCkgPT4gZmllbGRFcnJvci5lcnJvci50eXBlID09PSBcImVtcHR5SW5jbHVkZVwiID8gZmllbGQub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiIDogdHJ1ZVxuICAgICAgICApLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgbWlzc2luZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogYCR7c2VsZWN0UGF0aH0uJHtmaWVsZC5uYW1lfWAsXG4gICAgICAgICAgICB0eXBlOiBcInRydWVcIixcbiAgICAgICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFyZ0Vycm9yIG9mIGFyZ0Vycm9ycykge1xuICAgICAgY29uc3QgcGF0aDcgPSB0aGlzLm5vcm1hbGl6ZVBhdGgoYXJnRXJyb3IucGF0aCwgc2VsZWN0KS5qb2luKFwiLlwiKTtcbiAgICAgIGlmIChhcmdFcnJvci5lcnJvci50eXBlID09PSBcImludmFsaWROYW1lXCIpIHtcbiAgICAgICAga2V5UGF0aHMucHVzaChwYXRoNyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ0Vycm9yLmVycm9yLnR5cGUgIT09IFwibWlzc2luZ0FyZ1wiICYmIGFyZ0Vycm9yLmVycm9yLnR5cGUgIT09IFwiYXRMZWFzdE9uZVwiKSB7XG4gICAgICAgIHZhbHVlUGF0aHMucHVzaChwYXRoNyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ0Vycm9yLmVycm9yLnR5cGUgPT09IFwibWlzc2luZ0FyZ1wiKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhcmdFcnJvci5lcnJvci5taXNzaW5nQXJnLmlucHV0VHlwZXMubGVuZ3RoID09PSAxID8gYXJnRXJyb3IuZXJyb3IubWlzc2luZ0FyZy5pbnB1dFR5cGVzWzBdLnR5cGUgOiBhcmdFcnJvci5lcnJvci5taXNzaW5nQXJnLmlucHV0VHlwZXMubWFwKCh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRUeXBlTmFtZSA9IGdldElucHV0VHlwZU5hbWUodC50eXBlKTtcbiAgICAgICAgICBpZiAoaW5wdXRUeXBlTmFtZSA9PT0gXCJOdWxsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQuaXNMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRUeXBlTmFtZSArIFwiW11cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0VHlwZU5hbWU7XG4gICAgICAgIH0pLmpvaW4oXCIgfCBcIik7XG4gICAgICAgIG1pc3NpbmdJdGVtcy5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwYXRoNyxcbiAgICAgICAgICB0eXBlOiBpbnB1dFR5cGVUb0pzb24odHlwZSwgdHJ1ZSwgcGF0aDcuc3BsaXQoXCJ3aGVyZS5cIikubGVuZ3RoID09PSAyKSxcbiAgICAgICAgICBpc1JlcXVpcmVkOiBhcmdFcnJvci5lcnJvci5taXNzaW5nQXJnLmlzUmVxdWlyZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckVycm9yU3RyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY2FsbHNpdGUpID0+IHtcbiAgICAgIGNvbnN0IGhhc1JlcXVpcmVkTWlzc2luZ0FyZ3NFcnJvcnMgPSBhcmdFcnJvcnMuc29tZShcbiAgICAgICAgKGUpID0+IGUuZXJyb3IudHlwZSA9PT0gXCJtaXNzaW5nQXJnXCIgJiYgZS5lcnJvci5taXNzaW5nQXJnLmlzUmVxdWlyZWRcbiAgICAgICk7XG4gICAgICBjb25zdCBoYXNPcHRpb25hbE1pc3NpbmdBcmdzRXJyb3JzID0gQm9vbGVhbihcbiAgICAgICAgYXJnRXJyb3JzLmZpbmQoKGUpID0+IGUuZXJyb3IudHlwZSA9PT0gXCJtaXNzaW5nQXJnXCIgJiYgIWUuZXJyb3IubWlzc2luZ0FyZy5pc1JlcXVpcmVkKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGhhc01pc3NpbmdBcmdzRXJyb3JzID0gaGFzT3B0aW9uYWxNaXNzaW5nQXJnc0Vycm9ycyB8fCBoYXNSZXF1aXJlZE1pc3NpbmdBcmdzRXJyb3JzO1xuICAgICAgbGV0IG1pc3NpbmdBcmdzTGVnZW5kID0gXCJcIjtcbiAgICAgIGlmIChoYXNSZXF1aXJlZE1pc3NpbmdBcmdzRXJyb3JzKSB7XG4gICAgICAgIG1pc3NpbmdBcmdzTGVnZW5kICs9IGBcbiR7aW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oXCJOb3RlOiBMaW5lcyB3aXRoIFwiKX0ke2ltcG9ydF9jaGFsazExLmRlZmF1bHQucmVzZXQuZ3JlZW5CcmlnaHQoXCIrXCIpfSAke2ltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKFxuICAgICAgICAgIFwiYXJlIHJlcXVpcmVkXCJcbiAgICAgICAgKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGhhc09wdGlvbmFsTWlzc2luZ0FyZ3NFcnJvcnMpIHtcbiAgICAgICAgaWYgKG1pc3NpbmdBcmdzTGVnZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIG1pc3NpbmdBcmdzTGVnZW5kID0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUmVxdWlyZWRNaXNzaW5nQXJnc0Vycm9ycykge1xuICAgICAgICAgIG1pc3NpbmdBcmdzTGVnZW5kICs9IGltcG9ydF9jaGFsazExLmRlZmF1bHQuZGltKGAsIGxpbmVzIHdpdGggJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuKFwiP1wiKX0gYXJlIG9wdGlvbmFsYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWlzc2luZ0FyZ3NMZWdlbmQgKz0gaW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oYE5vdGU6IExpbmVzIHdpdGggJHtpbXBvcnRfY2hhbGsxMS5kZWZhdWx0LmdyZWVuKFwiP1wiKX0gYXJlIG9wdGlvbmFsYCk7XG4gICAgICAgIH1cbiAgICAgICAgbWlzc2luZ0FyZ3NMZWdlbmQgKz0gaW1wb3J0X2NoYWxrMTEuZGVmYXVsdC5kaW0oXCIuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVsZXZhbnRBcmdFcnJvcnMgPSBhcmdFcnJvcnMuZmlsdGVyKChlKSA9PiBlLmVycm9yLnR5cGUgIT09IFwibWlzc2luZ0FyZ1wiIHx8IGUuZXJyb3IubWlzc2luZ0FyZy5pc1JlcXVpcmVkKTtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2VzID0gcmVsZXZhbnRBcmdFcnJvcnMubWFwKChlKSA9PiB0aGlzLnByaW50QXJnRXJyb3IoZSwgaGFzTWlzc2luZ0FyZ3NFcnJvcnMsIGVycm9yRm9ybWF0ID09PSBcIm1pbmltYWxcIikpLmpvaW4oXCJcXG5cIik7XG4gICAgICBlcnJvck1lc3NhZ2VzICs9IGBcbiR7ZmllbGRFcnJvcnMubWFwKChlKSA9PiB0aGlzLnByaW50RmllbGRFcnJvcihlLCBtaXNzaW5nSXRlbXMsIGVycm9yRm9ybWF0ID09PSBcIm1pbmltYWxcIikpLmpvaW4oXCJcXG5cIil9YDtcbiAgICAgIGlmIChlcnJvckZvcm1hdCA9PT0gXCJtaW5pbWFsXCIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfc3RyaXBfYW5zaTMuZGVmYXVsdCkoZXJyb3JNZXNzYWdlcyk7XG4gICAgICB9XG4gICAgICBsZXQgcHJpbnRKc29uQXJncyA9IHtcbiAgICAgICAgYXN0OiBpc1RvcExldmVsUXVlcnkgPyB7IFt0b3BMZXZlbFF1ZXJ5TmFtZV06IHNlbGVjdCB9IDogc2VsZWN0LFxuICAgICAgICBrZXlQYXRocyxcbiAgICAgICAgdmFsdWVQYXRocyxcbiAgICAgICAgbWlzc2luZ0l0ZW1zXG4gICAgICB9O1xuICAgICAgaWYgKG9yaWdpbmFsTWV0aG9kID09IG51bGwgPyB2b2lkIDAgOiBvcmlnaW5hbE1ldGhvZC5lbmRzV2l0aChcImFnZ3JlZ2F0ZVwiKSkge1xuICAgICAgICBwcmludEpzb25BcmdzID0gdHJhbnNmb3JtQWdncmVnYXRlUHJpbnRKc29uQXJncyhwcmludEpzb25BcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yU3RyID0gY3JlYXRlRXJyb3JNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICBjYWxsc2l0ZSxcbiAgICAgICAgb3JpZ2luYWxNZXRob2Q6IG9yaWdpbmFsTWV0aG9kIHx8IHF1ZXJ5TmFtZSxcbiAgICAgICAgc2hvd0NvbG9yczogZXJyb3JGb3JtYXQgJiYgZXJyb3JGb3JtYXQgPT09IFwicHJldHR5XCIsXG4gICAgICAgIGNhbGxBcmd1bWVudHM6IHByaW50SnNvbldpdGhFcnJvcnMocHJpbnRKc29uQXJncyksXG4gICAgICAgIG1lc3NhZ2U6IGAke2Vycm9yTWVzc2FnZXN9JHttaXNzaW5nQXJnc0xlZ2VuZH1cbmBcbiAgICAgIH0pO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PX0NPTE9SIHx8IGVycm9yRm9ybWF0ID09PSBcImNvbG9ybGVzc1wiKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW1wb3J0X3N0cmlwX2Fuc2kzLmRlZmF1bHQpKGVycm9yU3RyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvclN0cjtcbiAgICB9LCBcInJlbmRlckVycm9yU3RyXCIpO1xuICAgIGNvbnN0IGVycm9yMiA9IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IocmVuZGVyRXJyb3JTdHIodmFsaWRhdGlvbkNhbGxzaXRlKSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yMiwgXCJyZW5kZXJcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yU3RyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yMjtcbiAgfVxuICBub3JtYWxpemVQYXRoKGlucHV0UGF0aCwgc2VsZWN0KSB7XG4gICAgY29uc3QgcGF0aDcgPSBpbnB1dFBhdGguc2xpY2UoKTtcbiAgICBjb25zdCBuZXdQYXRoID0gW107XG4gICAgbGV0IGtleTtcbiAgICBsZXQgcG9pbnRlciA9IHNlbGVjdDtcbiAgICB3aGlsZSAoKGtleSA9IHBhdGg3LnNoaWZ0KCkpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludGVyKSAmJiBrZXkgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgIGlmICghcG9pbnRlcltrZXldKSB7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIuaW5jbHVkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgJiYgcG9pbnRlcltrZXldKSB7XG4gICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW2tleV07XG4gICAgICB9XG4gICAgICBuZXdQYXRoLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH1cbn07XG5fX25hbWUoRG9jdW1lbnQsIFwiRG9jdW1lbnRcIik7XG52YXIgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3JcIjtcbiAgfVxufTtcbl9fbmFtZShQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IsIFwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCIpO1xudmFyIFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlICsgYFxuUmVhZCBtb3JlIGF0IGh0dHBzOi8vcHJpcy5seS9kL2NsaWVudC1jb25zdHJ1Y3RvcmApO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvclwiO1xuICB9XG59O1xuX19uYW1lKFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yLCBcIlByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yXCIpO1xudmFyIEZpZWxkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGFyZ3MsIGNoaWxkcmVuLCBlcnJvcjogZXJyb3IyLCBzY2hlbWFGaWVsZCB9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmVycm9yID0gZXJyb3IyO1xuICAgIHRoaXMuc2NoZW1hRmllbGQgPSBzY2hlbWFGaWVsZDtcbiAgICB0aGlzLmhhc0ludmFsaWRDaGlsZCA9IGNoaWxkcmVuID8gY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IEJvb2xlYW4oY2hpbGQuZXJyb3IgfHwgY2hpbGQuaGFzSW52YWxpZEFyZyB8fCBjaGlsZC5oYXNJbnZhbGlkQ2hpbGQpKSA6IGZhbHNlO1xuICAgIHRoaXMuaGFzSW52YWxpZEFyZyA9IGFyZ3MgPyBhcmdzLmhhc0ludmFsaWRBcmcgOiBmYWxzZTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiRmllbGRcIjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5uYW1lO1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyICsgXCIgIyBJTlZBTElEX0ZJRUxEXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmFyZ3MgJiYgdGhpcy5hcmdzLmFyZ3MgJiYgdGhpcy5hcmdzLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoaXMuYXJncy5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdHIgKz0gYCgke3RoaXMuYXJncy50b1N0cmluZygpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGAoXG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzQuZGVmYXVsdCkodGhpcy5hcmdzLnRvU3RyaW5nKCksIHRhYil9XG4pYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHN0ciArPSBgIHtcbiR7KDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nNC5kZWZhdWx0KSh0aGlzLmNoaWxkcmVuLm1hcChTdHJpbmcpLmpvaW4oXCJcXG5cIiksIHRhYil9XG59YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBjb2xsZWN0RXJyb3JzKHByZWZpeCA9IFwic2VsZWN0XCIpIHtcbiAgICBjb25zdCBmaWVsZEVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGFyZ0Vycm9ycyA9IFtdO1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICBmaWVsZEVycm9ycy5wdXNoKHtcbiAgICAgICAgcGF0aDogW3RoaXMubmFtZV0sXG4gICAgICAgIGVycm9yOiB0aGlzLmVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBjaGlsZC5jb2xsZWN0RXJyb3JzKHByZWZpeCk7XG4gICAgICAgIGZpZWxkRXJyb3JzLnB1c2goXG4gICAgICAgICAgLi4uZXJyb3JzLmZpZWxkRXJyb3JzLm1hcCgoZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICBwYXRoOiBbdGhpcy5uYW1lLCBwcmVmaXgsIC4uLmUucGF0aF1cbiAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICAgICAgYXJnRXJyb3JzLnB1c2goXG4gICAgICAgICAgLi4uZXJyb3JzLmFyZ0Vycm9ycy5tYXAoKGUpID0+ICh7XG4gICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgcGF0aDogW3RoaXMubmFtZSwgcHJlZml4LCAuLi5lLnBhdGhdXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgIGFyZ0Vycm9ycy5wdXNoKC4uLnRoaXMuYXJncy5jb2xsZWN0RXJyb3JzKCkubWFwKChlKSA9PiAoeyAuLi5lLCBwYXRoOiBbdGhpcy5uYW1lLCAuLi5lLnBhdGhdIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWVsZEVycm9ycyxcbiAgICAgIGFyZ0Vycm9yc1xuICAgIH07XG4gIH1cbn07XG5fX25hbWUoRmllbGQsIFwiRmllbGRcIik7XG52YXIgQXJncyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncyA9IFtdKSB7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmhhc0ludmFsaWRBcmcgPSBhcmdzID8gYXJncy5zb21lKChhcmcyKSA9PiBCb29sZWFuKGFyZzIuaGFzRXJyb3IpKSA6IGZhbHNlO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJBcmdzXCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5hcmdzLm1hcCgoYXJnMikgPT4gYXJnMi50b1N0cmluZygpKS5maWx0ZXIoKGEpID0+IGEpLmpvaW4oXCJcXG5cIil9YDtcbiAgfVxuICBjb2xsZWN0RXJyb3JzKCkge1xuICAgIGlmICghdGhpcy5oYXNJbnZhbGlkQXJnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBmbGF0TWFwKHRoaXMuYXJncywgKGFyZzIpID0+IGFyZzIuY29sbGVjdEVycm9ycygpKTtcbiAgfVxufTtcbl9fbmFtZShBcmdzLCBcIkFyZ3NcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIGlucHV0VHlwZSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmllbGRSZWZJbXBsKSB7XG4gICAgcmV0dXJuIGB7IF9yZWY6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUubmFtZSl9fWA7XG4gIH1cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBCaWdJbnRdXCIpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIChpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS50eXBlKSA9PT0gXCJzdHJpbmdcIiAmJiBpbnB1dFR5cGUudHlwZSA9PT0gXCJKc29uXCIpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnZhbHVlcyAmJiB2YWx1ZS5fX3ByaXNtYVJhd1BhcmFtYXRlcnNfXykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLnZhbHVlcyk7XG4gICAgfVxuICAgIGlmICgoaW5wdXRUeXBlID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dFR5cGUuaXNMaXN0KSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLm1hcCgobykgPT4gSlNPTi5zdHJpbmdpZnkobykpKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKGRlY2ltYWxfZGVmYXVsdC5pc0RlY2ltYWwodmFsdWUpIHx8IChpbnB1dFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0VHlwZS50eXBlKSA9PT0gXCJEZWNpbWFsXCIgJiYgaXNEZWNpbWFsSnNMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlEZWNpbWFsSnNMaWtlKHZhbHVlKTtcbiAgfVxuICBpZiAoKGlucHV0VHlwZSA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRUeXBlLmxvY2F0aW9uKSA9PT0gXCJlbnVtVHlwZXNcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgWyR7dmFsdWUuam9pbihcIiwgXCIpfV1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKTtcbn1cbl9fbmFtZShzdHJpbmdpZnksIFwic3RyaW5naWZ5XCIpO1xudmFyIEFyZzIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsga2V5LCB2YWx1ZSwgaXNFbnVtID0gZmFsc2UsIGVycm9yOiBlcnJvcjIsIHNjaGVtYUFyZywgaW5wdXRUeXBlIH0pIHtcbiAgICB0aGlzLmlucHV0VHlwZSA9IGlucHV0VHlwZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBPYmplY3RFbnVtVmFsdWUgPyB2YWx1ZS5fZ2V0TmFtZSgpIDogdmFsdWU7XG4gICAgdGhpcy5pc0VudW0gPSBpc0VudW07XG4gICAgdGhpcy5lcnJvciA9IGVycm9yMjtcbiAgICB0aGlzLnNjaGVtYUFyZyA9IHNjaGVtYUFyZztcbiAgICB0aGlzLmlzTnVsbGFibGUgPSAoc2NoZW1hQXJnID09IG51bGwgPyB2b2lkIDAgOiBzY2hlbWFBcmcuaW5wdXRUeXBlcy5yZWR1Y2UoKGlzTnVsbGFibGUpID0+IGlzTnVsbGFibGUgJiYgc2NoZW1hQXJnLmlzTnVsbGFibGUsIHRydWUpKSB8fCBmYWxzZTtcbiAgICB0aGlzLmhhc0Vycm9yID0gQm9vbGVhbihlcnJvcjIpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEFyZ3MgPyB2YWx1ZS5oYXNJbnZhbGlkQXJnIDogZmFsc2UpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLnNvbWUoKHYpID0+IHYgaW5zdGFuY2VvZiBBcmdzID8gdi5oYXNJbnZhbGlkQXJnIDogZmFsc2UpO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJBcmdcIjtcbiAgfVxuICBfdG9TdHJpbmcodmFsdWUsIGtleSkge1xuICAgIHZhciBfYTM7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJncykge1xuICAgICAgcmV0dXJuIGAke2tleX06IHtcbiR7KDAsIGltcG9ydF9pbmRlbnRfc3RyaW5nNC5kZWZhdWx0KSh2YWx1ZS50b1N0cmluZygpLCAyKX1cbn1gO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICgoKF9hMyA9IHRoaXMuaW5wdXRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnR5cGUpID09PSBcIkpzb25cIikge1xuICAgICAgICByZXR1cm4gYCR7a2V5fTogJHtzdHJpbmdpZnkodmFsdWUsIHRoaXMuaW5wdXRUeXBlKX1gO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTY2FsYXIgPSAhdmFsdWUuc29tZSgodikgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIpO1xuICAgICAgcmV0dXJuIGAke2tleX06IFske2lzU2NhbGFyID8gXCJcIiA6IFwiXFxuXCJ9JHsoMCwgaW1wb3J0X2luZGVudF9zdHJpbmc0LmRlZmF1bHQpKFxuICAgICAgICB2YWx1ZS5tYXAoKG5lc3RlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKG5lc3RlZFZhbHVlIGluc3RhbmNlb2YgQXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGB7XG4keygwLCBpbXBvcnRfaW5kZW50X3N0cmluZzQuZGVmYXVsdCkobmVzdGVkVmFsdWUudG9TdHJpbmcoKSwgdGFiKX1cbn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KG5lc3RlZFZhbHVlLCB0aGlzLmlucHV0VHlwZSk7XG4gICAgICAgIH0pLmpvaW4oYCwke2lzU2NhbGFyID8gXCIgXCIgOiBcIlxcblwifWApLFxuICAgICAgICBpc1NjYWxhciA/IDAgOiB0YWJcbiAgICAgICl9JHtpc1NjYWxhciA/IFwiXCIgOiBcIlxcblwifV1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fTogJHtzdHJpbmdpZnkodmFsdWUsIHRoaXMuaW5wdXRUeXBlKX1gO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLnZhbHVlLCB0aGlzLmtleSk7XG4gIH1cbiAgY29sbGVjdEVycm9ycygpIHtcbiAgICB2YXIgX2EzO1xuICAgIGlmICghdGhpcy5oYXNFcnJvcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgY29uc3QgaWQgPSB0eXBlb2YgKChfYTMgPSB0aGlzLmlucHV0VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy50eXBlKSA9PT0gXCJvYmplY3RcIiA/IGAke3RoaXMuaW5wdXRUeXBlLnR5cGUubmFtZX0ke3RoaXMuaW5wdXRUeXBlLmlzTGlzdCA/IFwiW11cIiA6IFwiXCJ9YCA6IHZvaWQgMDtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXG4gICAgICAgIHBhdGg6IFt0aGlzLmtleV0sXG4gICAgICAgIGlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAuLi5mbGF0TWFwKHRoaXMudmFsdWUsICh2YWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCEodmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwuY29sbGVjdEVycm9ycykpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbC5jb2xsZWN0RXJyb3JzKCkubWFwKChlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5lLCBwYXRoOiBbdGhpcy5rZXksIGluZGV4LCAuLi5lLnBhdGhdIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIEFyZ3MpIHtcbiAgICAgIGVycm9ycy5wdXNoKC4uLnRoaXMudmFsdWUuY29sbGVjdEVycm9ycygpLm1hcCgoZSkgPT4gKHsgLi4uZSwgcGF0aDogW3RoaXMua2V5LCAuLi5lLnBhdGhdIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cbn07XG5fX25hbWUoQXJnMiwgXCJBcmdcIik7XG5mdW5jdGlvbiBtYWtlRG9jdW1lbnQoeyBkbW1mLCByb290VHlwZU5hbWUsIHJvb3RGaWVsZCwgc2VsZWN0LCBtb2RlbE5hbWUgfSkge1xuICBpZiAoIXNlbGVjdCkge1xuICAgIHNlbGVjdCA9IHt9O1xuICB9XG4gIGNvbnN0IHJvb3RUeXBlID0gcm9vdFR5cGVOYW1lID09PSBcInF1ZXJ5XCIgPyBkbW1mLnF1ZXJ5VHlwZSA6IGRtbWYubXV0YXRpb25UeXBlO1xuICBjb25zdCBmYWtlUm9vdEZpZWxkID0ge1xuICAgIGFyZ3M6IFtdLFxuICAgIG91dHB1dFR5cGU6IHtcbiAgICAgIGlzTGlzdDogZmFsc2UsXG4gICAgICB0eXBlOiByb290VHlwZSxcbiAgICAgIGxvY2F0aW9uOiBcIm91dHB1dE9iamVjdFR5cGVzXCJcbiAgICB9LFxuICAgIG5hbWU6IHJvb3RUeXBlTmFtZVxuICB9O1xuICBjb25zdCBjb250ZXh0MyA9IHtcbiAgICBtb2RlbE5hbWVcbiAgfTtcbiAgY29uc3QgY2hpbGRyZW4gPSBzZWxlY3Rpb25Ub0ZpZWxkcyhkbW1mLCB7IFtyb290RmllbGRdOiBzZWxlY3QgfSwgZmFrZVJvb3RGaWVsZCwgW3Jvb3RUeXBlTmFtZV0sIGNvbnRleHQzKTtcbiAgcmV0dXJuIG5ldyBEb2N1bWVudChyb290VHlwZU5hbWUsIGNoaWxkcmVuKTtcbn1cbl9fbmFtZShtYWtlRG9jdW1lbnQsIFwibWFrZURvY3VtZW50XCIpO1xuZnVuY3Rpb24gdHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQyKSB7XG4gIHJldHVybiBkb2N1bWVudDI7XG59XG5fX25hbWUodHJhbnNmb3JtRG9jdW1lbnQsIFwidHJhbnNmb3JtRG9jdW1lbnRcIik7XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0ZpZWxkcyhkbW1mLCBzZWxlY3Rpb24sIHNjaGVtYUZpZWxkLCBwYXRoNywgY29udGV4dDMpIHtcbiAgY29uc3Qgb3V0cHV0VHlwZSA9IHNjaGVtYUZpZWxkLm91dHB1dFR5cGUudHlwZTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHNlbGVjdGlvbikucmVkdWNlKChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IG91dHB1dFR5cGUuZmllbGRNYXAgPyBvdXRwdXRUeXBlLmZpZWxkTWFwW25hbWVdIDogb3V0cHV0VHlwZS5maWVsZHMuZmluZCgoZikgPT4gZi5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICBhY2MucHVzaChcbiAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkRmllbGROYW1lXCIsXG4gICAgICAgICAgICBtb2RlbE5hbWU6IG91dHB1dFR5cGUubmFtZSxcbiAgICAgICAgICAgIHByb3ZpZGVkTmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRpZFlvdU1lYW46IGdldFN1Z2dlc3Rpb24oXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIG91dHB1dFR5cGUuZmllbGRzLm1hcCgoZikgPT4gZi5uYW1lKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG91dHB1dFR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwic2NhbGFyXCIgJiYgZmllbGQuYXJncy5sZW5ndGggPT09IDAgJiYgdHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgYWNjLnB1c2goXG4gICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZEZpZWxkVHlwZVwiLFxuICAgICAgICAgICAgbW9kZWxOYW1lOiBvdXRwdXRUeXBlLm5hbWUsXG4gICAgICAgICAgICBmaWVsZE5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwcm92aWRlZFZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1lZEZpZWxkID0ge1xuICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgIGZpZWxkczogZmllbGQuYXJncyxcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIG1pbk51bUZpZWxkczogbnVsbCxcbiAgICAgICAgbWF4TnVtRmllbGRzOiBudWxsXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcmdzV2l0aG91dEluY2x1ZGVBbmRTZWxlY3QgPSB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBvbWl0Mih2YWx1ZSwgW1wiaW5jbHVkZVwiLCBcInNlbGVjdFwiXSkgOiB2b2lkIDA7XG4gICAgY29uc3QgYXJncyA9IGFyZ3NXaXRob3V0SW5jbHVkZUFuZFNlbGVjdCA/IG9iamVjdFRvQXJncyhcbiAgICAgIGFyZ3NXaXRob3V0SW5jbHVkZUFuZFNlbGVjdCxcbiAgICAgIHRyYW5zZm9ybWVkRmllbGQsXG4gICAgICBjb250ZXh0MyxcbiAgICAgIFtdLFxuICAgICAgdHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiID8gdm9pZCAwIDogZmllbGQub3V0cHV0VHlwZS50eXBlXG4gICAgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBpc1JlbGF0aW9uID0gZmllbGQub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLnNlbGVjdCAmJiB2YWx1ZS5pbmNsdWRlKSB7XG4gICAgICAgIGFjYy5wdXNoKFxuICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImluY2x1ZGVcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBuZXcgQXJncygpLFxuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImluY2x1ZGVBbmRTZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgIGZpZWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmluY2x1ZGUpIHtcbiAgICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZS5pbmNsdWRlKTtcbiAgICAgICAgaWYgKGtleXMyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGFjYy5wdXNoKFxuICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJpbmNsdWRlXCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBuZXcgQXJncygpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbXB0eUluY2x1ZGVcIixcbiAgICAgICAgICAgICAgICAgICAgZmllbGRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRPdXRwdXRUeXBlID0gZmllbGQub3V0cHV0VHlwZS50eXBlO1xuICAgICAgICAgIGNvbnN0IGFsbG93ZWRLZXlzID0gZmllbGRPdXRwdXRUeXBlLmZpZWxkcy5maWx0ZXIoKGYpID0+IGYub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiKS5tYXAoKGYpID0+IGYubmFtZSk7XG4gICAgICAgICAgY29uc3QgaW52YWxpZEtleXMgPSBrZXlzMi5maWx0ZXIoKGtleSkgPT4gIWFsbG93ZWRLZXlzLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgIGlmIChpbnZhbGlkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICAgICAgLi4uaW52YWxpZEtleXMubWFwKFxuICAgICAgICAgICAgICAgIChpbnZhbGlkS2V5KSA9PiBuZXcgRmllbGQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogaW52YWxpZEtleSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogaW52YWxpZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBuZXcgQXJncygpLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRGaWVsZE5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsTmFtZTogZmllbGRPdXRwdXRUeXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUeXBlOiBmaWVsZE91dHB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE5hbWU6IGludmFsaWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRZb3VNZWFuOiBnZXRTdWdnZXN0aW9uKGludmFsaWRLZXksIGFsbG93ZWRLZXlzKSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luY2x1ZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luY2x1ZGVTY2FsYXI6IGZpZWxkT3V0cHV0VHlwZS5maWVsZHMuc29tZSgoZikgPT4gZi5uYW1lID09PSBpbnZhbGlkS2V5KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuc2VsZWN0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXModmFsdWUuc2VsZWN0KTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICAgIG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBuZXcgQXJncygpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbXB0eVNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRydXRoeVZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoKHYpID0+IHYpO1xuICAgICAgICBpZiAodHJ1dGh5VmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGFjYy5wdXNoKFxuICAgICAgICAgICAgbmV3IEZpZWxkKHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICBuZXcgRmllbGQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IG5ldyBBcmdzKCksXG4gICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5vVHJ1ZVNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTZWxlY3Rpb24gPSBpc1JlbGF0aW9uID8gZ2V0RGVmYXVsdFNlbGVjdGlvbihkbW1mLCBmaWVsZC5vdXRwdXRUeXBlLnR5cGUpIDogbnVsbDtcbiAgICBsZXQgc2VsZWN0ID0gZGVmYXVsdFNlbGVjdGlvbjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5zZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0ID0gdmFsdWUuc2VsZWN0O1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmNsdWRlKSB7XG4gICAgICAgIHNlbGVjdCA9IGRlZXBFeHRlbmQoZGVmYXVsdFNlbGVjdGlvbiwgdmFsdWUuaW5jbHVkZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmJ5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUuYnkpICYmIGZpZWxkLm91dHB1dFR5cGUubmFtZXNwYWNlID09PSBcInByaXNtYVwiICYmIGZpZWxkLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwib3V0cHV0T2JqZWN0VHlwZXNcIiAmJiBpc0dyb3VwQnlPdXRwdXROYW1lKGZpZWxkLm91dHB1dFR5cGUudHlwZS5uYW1lKSkge1xuICAgICAgICBzZWxlY3QgPSBieVRvU2VsZWN0KHZhbHVlLmJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBzZWxlY3QgIT09IGZhbHNlICYmIGlzUmVsYXRpb24gPyBzZWxlY3Rpb25Ub0ZpZWxkcyhkbW1mLCBzZWxlY3QsIGZpZWxkLCBbLi4ucGF0aDcsIG5hbWVdLCBjb250ZXh0MykgOiB2b2lkIDA7XG4gICAgYWNjLnB1c2gobmV3IEZpZWxkKHsgbmFtZSwgYXJncywgY2hpbGRyZW4sIHNjaGVtYUZpZWxkOiBmaWVsZCB9KSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufVxuX19uYW1lKHNlbGVjdGlvblRvRmllbGRzLCBcInNlbGVjdGlvblRvRmllbGRzXCIpO1xuZnVuY3Rpb24gYnlUb1NlbGVjdChieSkge1xuICBjb25zdCBvYmogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBiIG9mIGJ5KSB7XG4gICAgb2JqW2JdID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuX19uYW1lKGJ5VG9TZWxlY3QsIFwiYnlUb1NlbGVjdFwiKTtcbmZ1bmN0aW9uIGdldERlZmF1bHRTZWxlY3Rpb24oZG1tZiwgb3V0cHV0VHlwZSkge1xuICBjb25zdCBhY2MgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBmIG9mIG91dHB1dFR5cGUuZmllbGRzKSB7XG4gICAgaWYgKGRtbWYudHlwZU1hcFtmLm91dHB1dFR5cGUudHlwZS5uYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICBhY2NbZi5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChmLm91dHB1dFR5cGUubG9jYXRpb24gPT09IFwic2NhbGFyXCIgfHwgZi5vdXRwdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiKSB7XG4gICAgICBhY2NbZi5uYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBhY2M7XG59XG5fX25hbWUoZ2V0RGVmYXVsdFNlbGVjdGlvbiwgXCJnZXREZWZhdWx0U2VsZWN0aW9uXCIpO1xuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVBcmcoa2V5LCB2YWx1ZSwgYXJnMiwgYmVzdEZpdHRpbmdUeXBlKSB7XG4gIGNvbnN0IGFycmcgPSBuZXcgQXJnMih7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGlzRW51bTogYmVzdEZpdHRpbmdUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiLFxuICAgIGlucHV0VHlwZTogYmVzdEZpdHRpbmdUeXBlLFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBcImludmFsaWRUeXBlXCIsXG4gICAgICBwcm92aWRlZFZhbHVlOiB2YWx1ZSxcbiAgICAgIGFyZ05hbWU6IGtleSxcbiAgICAgIHJlcXVpcmVkVHlwZToge1xuICAgICAgICBpbnB1dFR5cGU6IGFyZzIuaW5wdXRUeXBlcyxcbiAgICAgICAgYmVzdEZpdHRpbmdUeXBlXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycmc7XG59XG5fX25hbWUoZ2V0SW52YWxpZFR5cGVBcmcsIFwiZ2V0SW52YWxpZFR5cGVBcmdcIik7XG5mdW5jdGlvbiBoYXNDb3JyZWN0U2NhbGFyVHlwZSh2YWx1ZSwgaW5wdXRUeXBlLCBjb250ZXh0Mykge1xuICBjb25zdCB7IGlzTGlzdCB9ID0gaW5wdXRUeXBlO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRFeHBlY3RlZFR5cGUoaW5wdXRUeXBlLCBjb250ZXh0Myk7XG4gIGNvbnN0IGdyYXBoUUxUeXBlID0gZ2V0R3JhcGhRTFR5cGUodmFsdWUsIGlucHV0VHlwZSk7XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzTGlzdCAmJiBncmFwaFFMVHlwZSA9PT0gXCJMaXN0PD5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFwiSnNvblwiICYmIGdyYXBoUUxUeXBlICE9PSBcIlN5bWJvbFwiICYmICEodmFsdWUgaW5zdGFuY2VvZiBPYmplY3RFbnVtVmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBGaWVsZFJlZkltcGwpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkludFwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJCaWdJbnRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEludD5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxCaWdJbnQ+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxCaWdJbnQgfCBJbnQ+XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8QmlnSW50PlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8SW50IHwgQmlnSW50PlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PEJpZ0ludD5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgoZ3JhcGhRTFR5cGUgPT09IFwiSW50XCIgfHwgZ3JhcGhRTFR5cGUgPT09IFwiRmxvYXRcIikgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkRlY2ltYWxcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1ZhbGlkRGVjaW1hbExpc3RJbnB1dChncmFwaFFMVHlwZSwgdmFsdWUpICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PERlY2ltYWw+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiRGF0ZVRpbWVcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxEYXRlVGltZT5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxTdHJpbmc+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiVVVJRFwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PFVVSUQ+XCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIlN0cmluZ1wiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJJRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PElEPlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PEpzb24+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkxpc3Q8U3RyaW5nPlwiICYmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PFN0cmluZyB8IFVVSUQ+XCIgfHwgZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxVVUlEIHwgU3RyaW5nPlwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJJbnRcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiRmxvYXRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJMaXN0PEludD5cIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTGlzdDxGbG9hdD5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChncmFwaFFMVHlwZSA9PT0gXCJJbnRcIiAmJiBleHBlY3RlZFR5cGUgPT09IFwiTG9uZ1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8SW50PlwiICYmIGV4cGVjdGVkVHlwZSA9PT0gXCJMaXN0PExvbmc+XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZ3JhcGhRTFR5cGUgPT09IFwiU3RyaW5nXCIgJiYgZXhwZWN0ZWRUeXBlID09PSBcIkRlY2ltYWxcIiAmJiBpc0RlY2ltYWxTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuX19uYW1lKGhhc0NvcnJlY3RTY2FsYXJUeXBlLCBcImhhc0NvcnJlY3RTY2FsYXJUeXBlXCIpO1xuZnVuY3Rpb24gZ2V0RXhwZWN0ZWRUeXBlKGlucHV0VHlwZSwgY29udGV4dDMsIGlzTGlzdCA9IGlucHV0VHlwZS5pc0xpc3QpIHtcbiAgbGV0IHR5cGUgPSBzdHJpbmdpZnlHcmFwaFFMVHlwZShpbnB1dFR5cGUudHlwZSk7XG4gIGlmIChpbnB1dFR5cGUubG9jYXRpb24gPT09IFwiZmllbGRSZWZUeXBlc1wiICYmIGNvbnRleHQzLm1vZGVsTmFtZSkge1xuICAgIHR5cGUgKz0gYDwke2NvbnRleHQzLm1vZGVsTmFtZX0+YDtcbiAgfVxuICByZXR1cm4gd3JhcFdpdGhMaXN0KHR5cGUsIGlzTGlzdCk7XG59XG5fX25hbWUoZ2V0RXhwZWN0ZWRUeXBlLCBcImdldEV4cGVjdGVkVHlwZVwiKTtcbnZhciBjbGVhbk9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9iaikgPT4gZmlsdGVyT2JqZWN0KG9iaiwgKGssIHYpID0+IHYgIT09IHZvaWQgMCksIFwiY2xlYW5PYmplY3RcIik7XG5mdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbExpc3RJbnB1dChncmFwaFFMVHlwZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8SW50PlwiIHx8IGdyYXBoUUxUeXBlID09PSBcIkxpc3Q8RmxvYXQ+XCIgfHwgZ3JhcGhRTFR5cGUgPT09IFwiTGlzdDxTdHJpbmc+XCIgJiYgdmFsdWUuZXZlcnkoaXNEZWNpbWFsU3RyaW5nKTtcbn1cbl9fbmFtZShpc1ZhbGlkRGVjaW1hbExpc3RJbnB1dCwgXCJpc1ZhbGlkRGVjaW1hbExpc3RJbnB1dFwiKTtcbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gL15cXC0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaS50ZXN0KHZhbHVlKTtcbn1cbl9fbmFtZShpc0RlY2ltYWxTdHJpbmcsIFwiaXNEZWNpbWFsU3RyaW5nXCIpO1xuZnVuY3Rpb24gdmFsdWVUb0FyZyhrZXksIHZhbHVlLCBhcmcyLCBjb250ZXh0Mykge1xuICBsZXQgbWF5YmVBcmcgPSBudWxsO1xuICBjb25zdCBhcmdzV2l0aEVycm9ycyA9IFtdO1xuICBmb3IgKGNvbnN0IGlucHV0VHlwZSBvZiBhcmcyLmlucHV0VHlwZXMpIHtcbiAgICBtYXliZUFyZyA9IHRyeUluZmVyQXJncyhrZXksIHZhbHVlLCBhcmcyLCBpbnB1dFR5cGUsIGNvbnRleHQzKTtcbiAgICBpZiAoKG1heWJlQXJnID09IG51bGwgPyB2b2lkIDAgOiBtYXliZUFyZy5jb2xsZWN0RXJyb3JzKCkubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG1heWJlQXJnO1xuICAgIH1cbiAgICBpZiAobWF5YmVBcmcgJiYgKG1heWJlQXJnID09IG51bGwgPyB2b2lkIDAgOiBtYXliZUFyZy5jb2xsZWN0RXJyb3JzKCkpKSB7XG4gICAgICBjb25zdCBhcmdFcnJvcnMgPSBtYXliZUFyZyA9PSBudWxsID8gdm9pZCAwIDogbWF5YmVBcmcuY29sbGVjdEVycm9ycygpO1xuICAgICAgaWYgKGFyZ0Vycm9ycyAmJiBhcmdFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmdzV2l0aEVycm9ycy5wdXNoKHsgYXJnOiBtYXliZUFyZywgZXJyb3JzOiBhcmdFcnJvcnMgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgobWF5YmVBcmcgPT0gbnVsbCA/IHZvaWQgMCA6IG1heWJlQXJnLmhhc0Vycm9yKSAmJiBhcmdzV2l0aEVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYXJnc1dpdGhTY29yZXMgPSBhcmdzV2l0aEVycm9ycy5tYXAoKHsgYXJnOiBhcmczLCBlcnJvcnMgfSkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JTY29yZXMgPSBlcnJvcnMubWFwKChlKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDE7XG4gICAgICAgIGlmIChlLmVycm9yLnR5cGUgPT09IFwiaW52YWxpZFR5cGVcIikge1xuICAgICAgICAgIHNjb3JlID0gMiAqIE1hdGguZXhwKGdldERlcHRoKGUuZXJyb3IucHJvdmlkZWRWYWx1ZSkpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZyhlLnBhdGgubGVuZ3RoKTtcbiAgICAgICAgaWYgKGUuZXJyb3IudHlwZSA9PT0gXCJtaXNzaW5nQXJnXCIpIHtcbiAgICAgICAgICBpZiAoYXJnMy5pbnB1dFR5cGUgJiYgaXNJbnB1dEFyZ1R5cGUoYXJnMy5pbnB1dFR5cGUudHlwZSkgJiYgYXJnMy5pbnB1dFR5cGUudHlwZS5uYW1lLmluY2x1ZGVzKFwiVW5jaGVja2VkXCIpKSB7XG4gICAgICAgICAgICBzY29yZSAqPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5lcnJvci50eXBlID09PSBcImludmFsaWROYW1lXCIpIHtcbiAgICAgICAgICBpZiAoaXNJbnB1dEFyZ1R5cGUoZS5lcnJvci5vcmlnaW5hbFR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoZS5lcnJvci5vcmlnaW5hbFR5cGUubmFtZS5pbmNsdWRlcyhcIlVuY2hlY2tlZFwiKSkge1xuICAgICAgICAgICAgICBzY29yZSAqPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjb3JlOiBlcnJvcnMubGVuZ3RoICsgc3VtMihlcnJvclNjb3JlcyksXG4gICAgICAgIGFyZzogYXJnMyxcbiAgICAgICAgZXJyb3JzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGFyZ3NXaXRoU2NvcmVzLnNvcnQoKGEsIGIpID0+IGEuc2NvcmUgPCBiLnNjb3JlID8gLTEgOiAxKTtcbiAgICByZXR1cm4gYXJnc1dpdGhTY29yZXNbMF0uYXJnO1xuICB9XG4gIHJldHVybiBtYXliZUFyZztcbn1cbl9fbmFtZSh2YWx1ZVRvQXJnLCBcInZhbHVlVG9BcmdcIik7XG5mdW5jdGlvbiBnZXREZXB0aChvYmplY3QpIHtcbiAgbGV0IGxldmVsID0gMTtcbiAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBsZXZlbDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iamVjdFtrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IGdldERlcHRoKG9iamVjdFtrZXldKSArIDE7XG4gICAgICBsZXZlbCA9IE1hdGgubWF4KGRlcHRoLCBsZXZlbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZXZlbDtcbn1cbl9fbmFtZShnZXREZXB0aCwgXCJnZXREZXB0aFwiKTtcbmZ1bmN0aW9uIHN1bTIobikge1xuICByZXR1cm4gbi5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3VyciwgMCk7XG59XG5fX25hbWUoc3VtMiwgXCJzdW1cIik7XG5mdW5jdGlvbiB0cnlJbmZlckFyZ3Moa2V5LCB2YWx1ZSwgYXJnMiwgaW5wdXRUeXBlLCBjb250ZXh0Mykge1xuICB2YXIgX2EzLCBfYjIsIF9jLCBfZDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICghYXJnMi5pc1JlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmcyKHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgaXNFbnVtOiBpbnB1dFR5cGUubG9jYXRpb24gPT09IFwiZW51bVR5cGVzXCIsXG4gICAgICBpbnB1dFR5cGUsXG4gICAgICBlcnJvcjoge1xuICAgICAgICB0eXBlOiBcIm1pc3NpbmdBcmdcIixcbiAgICAgICAgbWlzc2luZ05hbWU6IGtleSxcbiAgICAgICAgbWlzc2luZ0FyZzogYXJnMixcbiAgICAgICAgYXRMZWFzdE9uZTogZmFsc2UsXG4gICAgICAgIGF0TW9zdE9uZTogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IGlzTnVsbGFibGUsIGlzUmVxdWlyZWQgfSA9IGFyZzI7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiAhaXNOdWxsYWJsZSAmJiAhaXNSZXF1aXJlZCkge1xuICAgIGNvbnN0IGlzQXRMZWFzdE9uZSA9IGlzSW5wdXRBcmdUeXBlKGlucHV0VHlwZS50eXBlKSA/IGlucHV0VHlwZS50eXBlLmNvbnN0cmFpbnRzLm1pbk51bUZpZWxkcyAhPT0gbnVsbCAmJiBpbnB1dFR5cGUudHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMgPiAwIDogZmFsc2U7XG4gICAgaWYgKCFpc0F0TGVhc3RPbmUpIHtcbiAgICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzRW51bTogaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiLFxuICAgICAgICBpbnB1dFR5cGUsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgdHlwZTogXCJpbnZhbGlkTnVsbEFyZ1wiLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICBpbnZhbGlkVHlwZTogYXJnMi5pbnB1dFR5cGVzLFxuICAgICAgICAgIGF0TGVhc3RPbmU6IGZhbHNlLFxuICAgICAgICAgIGF0TW9zdE9uZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICghaW5wdXRUeXBlLmlzTGlzdCkge1xuICAgIGlmIChpc0lucHV0QXJnVHlwZShpbnB1dFR5cGUudHlwZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImlucHV0T2JqZWN0VHlwZXNcIiAmJiAhaXNPYmplY3QyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZFR5cGVBcmcoa2V5LCB2YWx1ZSwgYXJnMiwgaW5wdXRUeXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGNsZWFuT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgbGV0IGVycm9yMjtcbiAgICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWwgfHwge30pO1xuICAgICAgICBjb25zdCBudW1LZXlzID0ga2V5czIubGVuZ3RoO1xuICAgICAgICBpZiAobnVtS2V5cyA9PT0gMCAmJiB0eXBlb2YgaW5wdXRUeXBlLnR5cGUuY29uc3RyYWludHMubWluTnVtRmllbGRzID09PSBcIm51bWJlclwiICYmIGlucHV0VHlwZS50eXBlLmNvbnN0cmFpbnRzLm1pbk51bUZpZWxkcyA+IDApIHtcbiAgICAgICAgICBlcnJvcjIgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImF0TGVhc3RPbmVcIixcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGlucHV0VHlwZTogaW5wdXRUeXBlLnR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG51bUtleXMgPiAxICYmIHR5cGVvZiBpbnB1dFR5cGUudHlwZS5jb25zdHJhaW50cy5tYXhOdW1GaWVsZHMgPT09IFwibnVtYmVyXCIgJiYgaW5wdXRUeXBlLnR5cGUuY29uc3RyYWludHMubWF4TnVtRmllbGRzIDwgMikge1xuICAgICAgICAgIGVycm9yMiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXRNb3N0T25lXCIsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBpbnB1dFR5cGU6IGlucHV0VHlwZS50eXBlLFxuICAgICAgICAgICAgcHJvdmlkZWRLZXlzOiBrZXlzMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcmcyKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbCA9PT0gbnVsbCA/IG51bGwgOiBvYmplY3RUb0FyZ3ModmFsLCBpbnB1dFR5cGUudHlwZSwgY29udGV4dDMsIGFyZzIuaW5wdXRUeXBlcyksXG4gICAgICAgICAgaXNFbnVtOiBpbnB1dFR5cGUubG9jYXRpb24gPT09IFwiZW51bVR5cGVzXCIsXG4gICAgICAgICAgZXJyb3I6IGVycm9yMixcbiAgICAgICAgICBpbnB1dFR5cGUsXG4gICAgICAgICAgc2NoZW1hQXJnOiBhcmcyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NhbGFyVG9Bcmcoa2V5LCB2YWx1ZSwgYXJnMiwgaW5wdXRUeXBlLCBjb250ZXh0Myk7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgaW5wdXRUeXBlLmlzTGlzdCkge1xuICAgIGlmIChrZXkgIT09IFwidXBkYXRlTWFueVwiKSB7XG4gICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dFR5cGUubG9jYXRpb24gPT09IFwiZW51bVR5cGVzXCIgfHwgaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcInNjYWxhclwiKSB7XG4gICAgcmV0dXJuIHNjYWxhclRvQXJnKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSwgY29udGV4dDMpO1xuICB9XG4gIGNvbnN0IGFyZ0lucHV0VHlwZSA9IGlucHV0VHlwZS50eXBlO1xuICBjb25zdCBoYXNBdExlYXN0T25lRXJyb3IgPSB0eXBlb2YgKChfYTMgPSBhcmdJbnB1dFR5cGUuY29uc3RyYWludHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubWluTnVtRmllbGRzKSA9PT0gXCJudW1iZXJcIiAmJiAoKF9iMiA9IGFyZ0lucHV0VHlwZS5jb25zdHJhaW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5taW5OdW1GaWVsZHMpID4gMCA/IEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLnNvbWUoKHYpID0+ICF2IHx8IE9iamVjdC5rZXlzKGNsZWFuT2JqZWN0KHYpKS5sZW5ndGggPT09IDApIDogZmFsc2U7XG4gIGxldCBlcnIgPSBoYXNBdExlYXN0T25lRXJyb3IgPyB7XG4gICAgaW5wdXRUeXBlOiBhcmdJbnB1dFR5cGUsXG4gICAga2V5LFxuICAgIHR5cGU6IFwiYXRMZWFzdE9uZVwiXG4gIH0gOiB2b2lkIDA7XG4gIGlmICghZXJyKSB7XG4gICAgY29uc3QgaGFzT25lT2ZFcnJvciA9IHR5cGVvZiAoKF9jID0gYXJnSW5wdXRUeXBlLmNvbnN0cmFpbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWF4TnVtRmllbGRzKSA9PT0gXCJudW1iZXJcIiAmJiAoKF9kID0gYXJnSW5wdXRUeXBlLmNvbnN0cmFpbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2QubWF4TnVtRmllbGRzKSA8IDIgPyBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5maW5kKCh2KSA9PiAhdiB8fCBPYmplY3Qua2V5cyhjbGVhbk9iamVjdCh2KSkubGVuZ3RoICE9PSAxKSA6IGZhbHNlO1xuICAgIGlmIChoYXNPbmVPZkVycm9yKSB7XG4gICAgICBlcnIgPSB7XG4gICAgICAgIGlucHV0VHlwZTogYXJnSW5wdXRUeXBlLFxuICAgICAgICBrZXksXG4gICAgICAgIHR5cGU6IFwiYXRNb3N0T25lXCIsXG4gICAgICAgIHByb3ZpZGVkS2V5czogT2JqZWN0LmtleXMoaGFzT25lT2ZFcnJvcilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5lc3RlZEFyZ0lucHV0VHlwZSBvZiBhcmcyLmlucHV0VHlwZXMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBvYmplY3RUb0FyZ3ModmFsdWUsIG5lc3RlZEFyZ0lucHV0VHlwZS50eXBlLCBjb250ZXh0Myk7XG4gICAgICBpZiAoYXJncy5jb2xsZWN0RXJyb3JzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlOiBhcmdzLFxuICAgICAgICAgIGlzRW51bTogZmFsc2UsXG4gICAgICAgICAgc2NoZW1hQXJnOiBhcmcyLFxuICAgICAgICAgIGlucHV0VHlwZTogbmVzdGVkQXJnSW5wdXRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEFyZzIoe1xuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUubWFwKCh2KSA9PiB7XG4gICAgICBpZiAoaW5wdXRUeXBlLmlzTGlzdCAmJiB0eXBlb2YgdiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdiAhPT0gXCJvYmplY3RcIiB8fCAhdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRUeXBlQXJnKGtleSwgdiwgYXJnMiwgaW5wdXRUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RUb0FyZ3ModiwgYXJnSW5wdXRUeXBlLCBjb250ZXh0Myk7XG4gICAgfSksXG4gICAgaXNFbnVtOiBmYWxzZSxcbiAgICBpbnB1dFR5cGUsXG4gICAgc2NoZW1hQXJnOiBhcmcyLFxuICAgIGVycm9yOiBlcnJcbiAgfSk7XG59XG5fX25hbWUodHJ5SW5mZXJBcmdzLCBcInRyeUluZmVyQXJnc1wiKTtcbmZ1bmN0aW9uIGlzSW5wdXRBcmdUeXBlKGFyZ1R5cGUpIHtcbiAgaWYgKHR5cGVvZiBhcmdUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhcmdUeXBlLCBcInZhbHVlc1wiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbl9fbmFtZShpc0lucHV0QXJnVHlwZSwgXCJpc0lucHV0QXJnVHlwZVwiKTtcbmZ1bmN0aW9uIHNjYWxhclRvQXJnKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSwgY29udGV4dDMpIHtcbiAgaWYgKGhhc0NvcnJlY3RTY2FsYXJUeXBlKHZhbHVlLCBpbnB1dFR5cGUsIGNvbnRleHQzKSkge1xuICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzRW51bTogaW5wdXRUeXBlLmxvY2F0aW9uID09PSBcImVudW1UeXBlc1wiLFxuICAgICAgc2NoZW1hQXJnOiBhcmcyLFxuICAgICAgaW5wdXRUeXBlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdldEludmFsaWRUeXBlQXJnKGtleSwgdmFsdWUsIGFyZzIsIGlucHV0VHlwZSk7XG59XG5fX25hbWUoc2NhbGFyVG9BcmcsIFwic2NhbGFyVG9BcmdcIik7XG5mdW5jdGlvbiBvYmplY3RUb0FyZ3MoaW5pdGlhbE9iaiwgaW5wdXRUeXBlLCBjb250ZXh0MywgcG9zc2liaWxpdGllcywgb3V0cHV0VHlwZSkge1xuICB2YXIgX2EzO1xuICBpZiAoKF9hMyA9IGlucHV0VHlwZS5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnNvdXJjZSkge1xuICAgIGNvbnRleHQzID0geyBtb2RlbE5hbWU6IGlucHV0VHlwZS5tZXRhLnNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IG9iaiA9IGNsZWFuT2JqZWN0KGluaXRpYWxPYmopO1xuICBjb25zdCB7IGZpZWxkczogYXJncywgZmllbGRNYXAgfSA9IGlucHV0VHlwZTtcbiAgY29uc3QgcmVxdWlyZWRBcmdzID0gYXJncy5tYXAoKGFyZzIpID0+IFthcmcyLm5hbWUsIHZvaWQgMF0pO1xuICBjb25zdCBvYmpFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqIHx8IHt9KTtcbiAgY29uc3QgZW50cmllcyA9IHVuaW9uQnkob2JqRW50cmllcywgcmVxdWlyZWRBcmdzLCAoYSkgPT4gYVswXSk7XG4gIGNvbnN0IGFyZ3NMaXN0ID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2FyZ05hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IHNjaGVtYUFyZyA9IGZpZWxkTWFwID8gZmllbGRNYXBbYXJnTmFtZV0gOiBhcmdzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gYXJnTmFtZSk7XG4gICAgaWYgKCFzY2hlbWFBcmcpIHtcbiAgICAgIGNvbnN0IGRpZFlvdU1lYW5GaWVsZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgJiYgb3V0cHV0VHlwZSAmJiBvdXRwdXRUeXBlLmZpZWxkcy5zb21lKChmKSA9PiBmLm5hbWUgPT09IGFyZ05hbWUpID8gYXJnTmFtZSA6IG51bGw7XG4gICAgICBhY2MucHVzaChcbiAgICAgICAgbmV3IEFyZzIoe1xuICAgICAgICAgIGtleTogYXJnTmFtZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkTmFtZVwiLFxuICAgICAgICAgICAgcHJvdmlkZWROYW1lOiBhcmdOYW1lLFxuICAgICAgICAgICAgcHJvdmlkZWRWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkaWRZb3VNZWFuRmllbGQsXG4gICAgICAgICAgICBkaWRZb3VNZWFuQXJnOiAhZGlkWW91TWVhbkZpZWxkICYmIGdldFN1Z2dlc3Rpb24oYXJnTmFtZSwgWy4uLmFyZ3MubWFwKChhKSA9PiBhLm5hbWUpLCBcInNlbGVjdFwiXSkgfHwgdm9pZCAwLFxuICAgICAgICAgICAgb3JpZ2luYWxUeXBlOiBpbnB1dFR5cGUsXG4gICAgICAgICAgICBwb3NzaWJpbGl0aWVzLFxuICAgICAgICAgICAgb3V0cHV0VHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCBhcmcyID0gdmFsdWVUb0FyZyhhcmdOYW1lLCB2YWx1ZSwgc2NoZW1hQXJnLCBjb250ZXh0Myk7XG4gICAgaWYgKGFyZzIpIHtcbiAgICAgIGFjYy5wdXNoKGFyZzIpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIGlmICh0eXBlb2YgaW5wdXRUeXBlLmNvbnN0cmFpbnRzLm1pbk51bUZpZWxkcyA9PT0gXCJudW1iZXJcIiAmJiBvYmpFbnRyaWVzLmxlbmd0aCA8IGlucHV0VHlwZS5jb25zdHJhaW50cy5taW5OdW1GaWVsZHMgfHwgYXJnc0xpc3QuZmluZCgoYXJnMikgPT4ge1xuICAgIHZhciBfYTQsIF9iMjtcbiAgICByZXR1cm4gKChfYTQgPSBhcmcyLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2E0LnR5cGUpID09PSBcIm1pc3NpbmdBcmdcIiB8fCAoKF9iMiA9IGFyZzIuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIudHlwZSkgPT09IFwiYXRMZWFzdE9uZVwiO1xuICB9KSkge1xuICAgIGNvbnN0IG9wdGlvbmFsTWlzc2luZ0FyZ3MgPSBpbnB1dFR5cGUuZmllbGRzLmZpbHRlcihcbiAgICAgIChmaWVsZCkgPT4gIWZpZWxkLmlzUmVxdWlyZWQgJiYgb2JqICYmICh0eXBlb2Ygb2JqW2ZpZWxkLm5hbWVdID09PSBcInVuZGVmaW5lZFwiIHx8IG9ialtmaWVsZC5uYW1lXSA9PT0gbnVsbClcbiAgICApO1xuICAgIGFyZ3NMaXN0LnB1c2goXG4gICAgICAuLi5vcHRpb25hbE1pc3NpbmdBcmdzLm1hcCgoYXJnMikgPT4ge1xuICAgICAgICBjb25zdCBhcmdJbnB1dFR5cGUgPSBhcmcyLmlucHV0VHlwZXNbMF07XG4gICAgICAgIHJldHVybiBuZXcgQXJnMih7XG4gICAgICAgICAga2V5OiBhcmcyLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICBpc0VudW06IGFyZ0lucHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJlbnVtVHlwZXNcIixcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJtaXNzaW5nQXJnXCIsXG4gICAgICAgICAgICBtaXNzaW5nTmFtZTogYXJnMi5uYW1lLFxuICAgICAgICAgICAgbWlzc2luZ0FyZzogYXJnMixcbiAgICAgICAgICAgIGF0TGVhc3RPbmU6IEJvb2xlYW4oaW5wdXRUeXBlLmNvbnN0cmFpbnRzLm1pbk51bUZpZWxkcykgfHwgZmFsc2UsXG4gICAgICAgICAgICBhdE1vc3RPbmU6IGlucHV0VHlwZS5jb25zdHJhaW50cy5tYXhOdW1GaWVsZHMgPT09IDEgfHwgZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0VHlwZTogYXJnSW5wdXRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXcgQXJncyhhcmdzTGlzdCk7XG59XG5fX25hbWUob2JqZWN0VG9BcmdzLCBcIm9iamVjdFRvQXJnc1wiKTtcbmZ1bmN0aW9uIHVucGFjayh7IGRvY3VtZW50OiBkb2N1bWVudDIsIHBhdGg6IHBhdGg3LCBkYXRhIH0pIHtcbiAgY29uc3QgcmVzdWx0ID0gZGVlcEdldChkYXRhLCBwYXRoNyk7XG4gIGlmIChyZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChkb2N1bWVudDIsIHBhdGg3KTtcbiAgcmV0dXJuIG1hcFNjYWxhcnMoeyBmaWVsZCwgZGF0YTogcmVzdWx0IH0pO1xufVxuX19uYW1lKHVucGFjaywgXCJ1bnBhY2tcIik7XG5mdW5jdGlvbiBtYXBTY2FsYXJzKHsgZmllbGQsIGRhdGEgfSkge1xuICB2YXIgX2EzO1xuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgIWZpZWxkLmNoaWxkcmVuIHx8ICFmaWVsZC5zY2hlbWFGaWVsZCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGNvbnN0IGRlc2VyaWFsaXplcnMgPSB7XG4gICAgRGF0ZVRpbWU6ICh2YWx1ZSkgPT4gbmV3IERhdGUodmFsdWUpLFxuICAgIEpzb246ICh2YWx1ZSkgPT4gSlNPTi5wYXJzZSh2YWx1ZSksXG4gICAgQnl0ZXM6ICh2YWx1ZSkgPT4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpLFxuICAgIERlY2ltYWw6ICh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2RlZmF1bHQodmFsdWUpO1xuICAgIH0sXG4gICAgQmlnSW50OiAodmFsdWUpID0+IEJpZ0ludCh2YWx1ZSlcbiAgfTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBmaWVsZC5jaGlsZHJlbikge1xuICAgIGNvbnN0IG91dHB1dFR5cGUgPSAoX2EzID0gY2hpbGQuc2NoZW1hRmllbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMub3V0cHV0VHlwZS50eXBlO1xuICAgIGlmIChvdXRwdXRUeXBlICYmIHR5cGVvZiBvdXRwdXRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXJzW291dHB1dFR5cGVdO1xuICAgICAgaWYgKGRlc2VyaWFsaXplcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeVtjaGlsZC5uYW1lXSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbnRyeVtjaGlsZC5uYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeVtjaGlsZC5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeVtjaGlsZC5uYW1lXSA9IGVudHJ5W2NoaWxkLm5hbWVdLm1hcChkZXNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudHJ5W2NoaWxkLm5hbWVdID0gZGVzZXJpYWxpemVyKGVudHJ5W2NoaWxkLm5hbWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY2hpbGQubmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YVtjaGlsZC5uYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtjaGlsZC5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgZGF0YVtjaGlsZC5uYW1lXSA9IGRhdGFbY2hpbGQubmFtZV0ubWFwKGRlc2VyaWFsaXplcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhW2NoaWxkLm5hbWVdID0gZGVzZXJpYWxpemVyKGRhdGFbY2hpbGQubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hpbGQuc2NoZW1hRmllbGQgJiYgY2hpbGQuc2NoZW1hRmllbGQub3V0cHV0VHlwZS5sb2NhdGlvbiA9PT0gXCJvdXRwdXRPYmplY3RUeXBlc1wiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRhdGEpIHtcbiAgICAgICAgICBtYXBTY2FsYXJzKHsgZmllbGQ6IGNoaWxkLCBkYXRhOiBlbnRyeVtjaGlsZC5uYW1lXSB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwU2NhbGFycyh7IGZpZWxkOiBjaGlsZCwgZGF0YTogZGF0YVtjaGlsZC5uYW1lXSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5fX25hbWUobWFwU2NhbGFycywgXCJtYXBTY2FsYXJzXCIpO1xuZnVuY3Rpb24gZ2V0RmllbGQoZG9jdW1lbnQyLCBwYXRoNykge1xuICBjb25zdCB0b2RvID0gcGF0aDcuc2xpY2UoKTtcbiAgY29uc3QgZmlyc3RFbGVtZW50ID0gdG9kby5zaGlmdCgpO1xuICBsZXQgcG9pbnRlciA9IGRvY3VtZW50Mi5jaGlsZHJlbi5maW5kKChjKSA9PiBjLm5hbWUgPT09IGZpcnN0RWxlbWVudCk7XG4gIGlmICghcG9pbnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgZmllbGQgJHtmaXJzdEVsZW1lbnR9IGluIGRvY3VtZW50ICR7ZG9jdW1lbnQyfWApO1xuICB9XG4gIHdoaWxlICh0b2RvLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBrZXkgPSB0b2RvLnNoaWZ0KCk7XG4gICAgaWYgKCFwb2ludGVyLmNoaWxkcmVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGdldCBjaGlsZHJlbiBmb3IgZmllbGQgJHtwb2ludGVyfSB3aXRoIGNoaWxkICR7a2V5fWApO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IHBvaW50ZXIuY2hpbGRyZW4uZmluZCgoYykgPT4gYy5uYW1lID09PSBrZXkpO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBjaGlsZCAke2tleX0gb2YgZmllbGQgJHtwb2ludGVyfWApO1xuICAgIH1cbiAgICBwb2ludGVyID0gY2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXI7XG59XG5fX25hbWUoZ2V0RmllbGQsIFwiZ2V0RmllbGRcIik7XG5mdW5jdGlvbiByZW1vdmVTZWxlY3RGcm9tUGF0aChwYXRoNykge1xuICByZXR1cm4gcGF0aDcuc3BsaXQoXCIuXCIpLmZpbHRlcigocCkgPT4gcCAhPT0gXCJzZWxlY3RcIikuam9pbihcIi5cIik7XG59XG5fX25hbWUocmVtb3ZlU2VsZWN0RnJvbVBhdGgsIFwicmVtb3ZlU2VsZWN0RnJvbVBhdGhcIik7XG5mdW5jdGlvbiByZW1vdmVTZWxlY3RGcm9tT2JqZWN0KG9iaikge1xuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgY29uc3QgY29weSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgaWYgKGtleSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YktleSBpbiBvYmpbXCJzZWxlY3RcIl0pIHtcbiAgICAgICAgICBjb3B5W3N1YktleV0gPSByZW1vdmVTZWxlY3RGcm9tT2JqZWN0KG9ialtcInNlbGVjdFwiXVtzdWJLZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weVtrZXldID0gcmVtb3ZlU2VsZWN0RnJvbU9iamVjdChvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5fX25hbWUocmVtb3ZlU2VsZWN0RnJvbU9iamVjdCwgXCJyZW1vdmVTZWxlY3RGcm9tT2JqZWN0XCIpO1xuZnVuY3Rpb24gdHJhbnNmb3JtQWdncmVnYXRlUHJpbnRKc29uQXJncyh7XG4gIGFzdCxcbiAga2V5UGF0aHMsXG4gIG1pc3NpbmdJdGVtcyxcbiAgdmFsdWVQYXRoc1xufSkge1xuICBjb25zdCBuZXdLZXlQYXRocyA9IGtleVBhdGhzLm1hcChyZW1vdmVTZWxlY3RGcm9tUGF0aCk7XG4gIGNvbnN0IG5ld1ZhbHVlUGF0aHMgPSB2YWx1ZVBhdGhzLm1hcChyZW1vdmVTZWxlY3RGcm9tUGF0aCk7XG4gIGNvbnN0IG5ld01pc3NpbmdJdGVtcyA9IG1pc3NpbmdJdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgcGF0aDogcmVtb3ZlU2VsZWN0RnJvbVBhdGgoaXRlbS5wYXRoKSxcbiAgICBpc1JlcXVpcmVkOiBpdGVtLmlzUmVxdWlyZWQsXG4gICAgdHlwZTogaXRlbS50eXBlXG4gIH0pKTtcbiAgY29uc3QgbmV3QXN0ID0gcmVtb3ZlU2VsZWN0RnJvbU9iamVjdChhc3QpO1xuICByZXR1cm4ge1xuICAgIGFzdDogbmV3QXN0LFxuICAgIGtleVBhdGhzOiBuZXdLZXlQYXRocyxcbiAgICBtaXNzaW5nSXRlbXM6IG5ld01pc3NpbmdJdGVtcyxcbiAgICB2YWx1ZVBhdGhzOiBuZXdWYWx1ZVBhdGhzXG4gIH07XG59XG5fX25hbWUodHJhbnNmb3JtQWdncmVnYXRlUHJpbnRKc29uQXJncywgXCJ0cmFuc2Zvcm1BZ2dyZWdhdGVQcmludEpzb25BcmdzXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9yZWplY3RPbk5vdEZvdW5kLnRzXG52YXIgTm90Rm91bmRFcnJvcjIgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTm90Rm91bmRFcnJvclwiO1xuICB9XG59O1xuX19uYW1lKE5vdEZvdW5kRXJyb3IyLCBcIk5vdEZvdW5kRXJyb3JcIik7XG5mdW5jdGlvbiBnZXRSZWplY3RPbk5vdEZvdW5kKGFjdGlvbiwgbW9kZWxOYW1lLCBhcmdzLCBjbGllbnRJbnN0YW5jZSkge1xuICBsZXQgcmVqZWN0T25Ob3RGb3VuZDtcbiAgaWYgKGFyZ3MgJiYgdHlwZW9mIGFyZ3MgPT09IFwib2JqZWN0XCIgJiYgXCJyZWplY3RPbk5vdEZvdW5kXCIgaW4gYXJncyAmJiBhcmdzW1wicmVqZWN0T25Ob3RGb3VuZFwiXSAhPT0gdm9pZCAwKSB7XG4gICAgcmVqZWN0T25Ob3RGb3VuZCA9IGFyZ3NbXCJyZWplY3RPbk5vdEZvdW5kXCJdO1xuICAgIGRlbGV0ZSBhcmdzW1wicmVqZWN0T25Ob3RGb3VuZFwiXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2xpZW50SW5zdGFuY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmVqZWN0T25Ob3RGb3VuZCA9IGNsaWVudEluc3RhbmNlO1xuICB9IGVsc2UgaWYgKGNsaWVudEluc3RhbmNlICYmIHR5cGVvZiBjbGllbnRJbnN0YW5jZSA9PT0gXCJvYmplY3RcIiAmJiBhY3Rpb24gaW4gY2xpZW50SW5zdGFuY2UpIHtcbiAgICBjb25zdCByZWplY3RQZXJPcGVyYXRpb24gPSBjbGllbnRJbnN0YW5jZVthY3Rpb25dO1xuICAgIGlmIChyZWplY3RQZXJPcGVyYXRpb24gJiYgdHlwZW9mIHJlamVjdFBlck9wZXJhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKG1vZGVsTmFtZSBpbiByZWplY3RQZXJPcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdFBlck9wZXJhdGlvblttb2RlbE5hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmVqZWN0T25Ob3RGb3VuZCA9IGdldFJlamVjdE9uTm90Rm91bmQoYWN0aW9uLCBtb2RlbE5hbWUsIGFyZ3MsIHJlamVjdFBlck9wZXJhdGlvbik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudEluc3RhbmNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZWplY3RPbk5vdEZvdW5kID0gY2xpZW50SW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0T25Ob3RGb3VuZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiByZWplY3RPbk5vdEZvdW5kO1xufVxuX19uYW1lKGdldFJlamVjdE9uTm90Rm91bmQsIFwiZ2V0UmVqZWN0T25Ob3RGb3VuZFwiKTtcbnZhciBSRUdFWCA9IC8oZmluZFVuaXF1ZXxmaW5kRmlyc3QpLztcbmZ1bmN0aW9uIHRocm93SWZOb3RGb3VuZChkYXRhLCBjbGllbnRNZXRob2QsIHR5cGVOYW1lLCByZWplY3RPbk5vdEZvdW5kKSB7XG4gIGlmIChyZWplY3RPbk5vdEZvdW5kICYmICFkYXRhICYmIFJFR0VYLmV4ZWMoY2xpZW50TWV0aG9kKSkge1xuICAgIGlmICh0eXBlb2YgcmVqZWN0T25Ob3RGb3VuZCA9PT0gXCJib29sZWFuXCIgJiYgcmVqZWN0T25Ob3RGb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IyKGBObyAke3R5cGVOYW1lfSBmb3VuZGApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlamVjdE9uTm90Rm91bmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgcmVqZWN0T25Ob3RGb3VuZChuZXcgTm90Rm91bmRFcnJvcjIoYE5vICR7dHlwZU5hbWV9IGZvdW5kYCkpO1xuICAgIH0gZWxzZSBpZiAoaXNFcnJvcihyZWplY3RPbk5vdEZvdW5kKSkge1xuICAgICAgdGhyb3cgcmVqZWN0T25Ob3RGb3VuZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IyKGBObyAke3R5cGVOYW1lfSBmb3VuZGApO1xuICB9XG59XG5fX25hbWUodGhyb3dJZk5vdEZvdW5kLCBcInRocm93SWZOb3RGb3VuZFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9hcHBseUNsaWVudE9ubHlXcmFwcGVyLnRzXG5mdW5jdGlvbiB3cmFwUmVxdWVzdChwcm9wLCBkbW1mTW9kZWxOYW1lLCByZXF1ZXN0Q2FsbGJhY2spIHtcbiAgaWYgKHByb3AgPT09IFwiZmluZEZpcnN0T3JUaHJvd1wiIHx8IHByb3AgPT09IFwiZmluZFVuaXF1ZU9yVGhyb3dcIikge1xuICAgIHJldHVybiBhcHBseU9yVGhyb3dXcmFwcGVyKGRtbWZNb2RlbE5hbWUsIHJlcXVlc3RDYWxsYmFjayk7XG4gIH1cbiAgYXNzZXJ0TmV2ZXIocHJvcCwgXCJVbmtub3duIHdyYXBwZXIgbmFtZVwiKTtcbn1cbl9fbmFtZSh3cmFwUmVxdWVzdCwgXCJ3cmFwUmVxdWVzdFwiKTtcbmZ1bmN0aW9uIGFwcGx5T3JUaHJvd1dyYXBwZXIoZG1tZk1vZGVsTmFtZSwgcmVxdWVzdENhbGxiYWNrKSB7XG4gIHJldHVybiBhc3luYyAocmVxdWVzdFBhcmFtcykgPT4ge1xuICAgIGlmIChcInJlamVjdE9uTm90Rm91bmRcIiBpbiByZXF1ZXN0UGFyYW1zLmFyZ3MpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVFcnJvck1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgIG9yaWdpbmFsTWV0aG9kOiByZXF1ZXN0UGFyYW1zLmNsaWVudE1ldGhvZCxcbiAgICAgICAgY2FsbHNpdGU6IHJlcXVlc3RQYXJhbXMuY2FsbHNpdGUsXG4gICAgICAgIG1lc3NhZ2U6IFwiJ3JlamVjdE9uTm90Rm91bmQnIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkXCJcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdENhbGxiYWNrKHJlcXVlc3RQYXJhbXMpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yMihgTm8gJHtkbW1mTW9kZWxOYW1lfSBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuX19uYW1lKGFwcGx5T3JUaHJvd1dyYXBwZXIsIFwiYXBwbHlPclRocm93V3JhcHBlclwiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC91dGlscy9kZWZhdWx0UHJveHlIYW5kbGVycy50c1xudmFyIGRlZmF1bHRQcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn07XG5mdW5jdGlvbiBkZWZhdWx0UHJveHlIYW5kbGVycyhvd25LZXlzKSB7XG4gIGNvbnN0IF9vd25LZXlzID0gbmV3IFNldChvd25LZXlzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICgpID0+IGRlZmF1bHRQcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiBfb3duS2V5cy5oYXMocHJvcCksXG4gICAgc2V0OiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIF9vd25LZXlzLmFkZChwcm9wKSAmJiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICB9LFxuICAgIG93bktleXM6ICgpID0+IFsuLi5fb3duS2V5c11cbiAgfTtcbn1cbl9fbmFtZShkZWZhdWx0UHJveHlIYW5kbGVycywgXCJkZWZhdWx0UHJveHlIYW5kbGVyc1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvY29yZS9tb2RlbC9hcHBseUZpZWxkc1Byb3h5LnRzXG5mdW5jdGlvbiBhcHBseUZpZWxkc1Byb3h5KG1vZGVsKSB7XG4gIGNvbnN0IHNjYWxhckZpZWxkc0xpc3QgPSBtb2RlbC5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gIWZpZWxkLnJlbGF0aW9uTmFtZSk7XG4gIGNvbnN0IHNjYWxhckZpZWxkcyA9IGtleUJ5MihzY2FsYXJGaWVsZHNMaXN0LCAoZmllbGQpID0+IGZpZWxkLm5hbWUpO1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0IHx8IHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkbW1mRmllbGQgPSBzY2FsYXJGaWVsZHNbcHJvcF07XG4gICAgICAgIGlmIChkbW1mRmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkUmVmSW1wbChtb2RlbC5uYW1lLCBwcm9wLCBkbW1mRmllbGQudHlwZSwgZG1tZkZpZWxkLmlzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICAuLi5kZWZhdWx0UHJveHlIYW5kbGVycyhPYmplY3Qua2V5cyhzY2FsYXJGaWVsZHMpKVxuICAgIH1cbiAgKTtcbn1cbl9fbmFtZShhcHBseUZpZWxkc1Byb3h5LCBcImFwcGx5RmllbGRzUHJveHlcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYXBwbHlGbHVlbnQudHNcbmZ1bmN0aW9uIGdldE5leHREYXRhUGF0aChmbHVlbnRQcm9wTmFtZSwgcHJldkRhdGFQYXRoKSB7XG4gIGlmIChmbHVlbnRQcm9wTmFtZSA9PT0gdm9pZCAwIHx8IHByZXZEYXRhUGF0aCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbXTtcbiAgcmV0dXJuIFsuLi5wcmV2RGF0YVBhdGgsIFwic2VsZWN0XCIsIGZsdWVudFByb3BOYW1lXTtcbn1cbl9fbmFtZShnZXROZXh0RGF0YVBhdGgsIFwiZ2V0TmV4dERhdGFQYXRoXCIpO1xuZnVuY3Rpb24gZ2V0TmV4dFVzZXJBcmdzKGNhbGxBcmdzLCBwcmV2QXJncywgbmV4dERhdGFQYXRoKSB7XG4gIGlmIChwcmV2QXJncyA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBjYWxsQXJncyAhPSBudWxsID8gY2FsbEFyZ3MgOiB7fTtcbiAgcmV0dXJuIGRlZXBTZXQocHJldkFyZ3MsIG5leHREYXRhUGF0aCwgY2FsbEFyZ3MgfHwgdHJ1ZSk7XG59XG5fX25hbWUoZ2V0TmV4dFVzZXJBcmdzLCBcImdldE5leHRVc2VyQXJnc1wiKTtcbmZ1bmN0aW9uIGFwcGx5Rmx1ZW50KGNsaWVudCwgZG1tZk1vZGVsTmFtZSwgbW9kZWxBY3Rpb24sIGZsdWVudFByb3BOYW1lLCBwcmV2RGF0YVBhdGgsIHByZXZVc2VyQXJncykge1xuICBjb25zdCBkbW1mTW9kZWwgPSBjbGllbnQuX2Jhc2VEbW1mLm1vZGVsTWFwW2RtbWZNb2RlbE5hbWVdO1xuICBjb25zdCBkbW1mTW9kZWxGaWVsZE1hcCA9IGRtbWZNb2RlbC5maWVsZHMucmVkdWNlKFxuICAgIChhY2MsIGZpZWxkKSA9PiAoeyAuLi5hY2MsIFtmaWVsZC5uYW1lXTogZmllbGQgfSksXG4gICAge31cbiAgKTtcbiAgcmV0dXJuICh1c2VyQXJncykgPT4ge1xuICAgIGNvbnN0IGNhbGxzaXRlID0gZ2V0Q2FsbFNpdGUoY2xpZW50Ll9lcnJvckZvcm1hdCk7XG4gICAgY29uc3QgbmV4dERhdGFQYXRoID0gZ2V0TmV4dERhdGFQYXRoKGZsdWVudFByb3BOYW1lLCBwcmV2RGF0YVBhdGgpO1xuICAgIGNvbnN0IG5leHRVc2VyQXJncyA9IGdldE5leHRVc2VyQXJncyh1c2VyQXJncywgcHJldlVzZXJBcmdzLCBuZXh0RGF0YVBhdGgpO1xuICAgIGNvbnN0IHByaXNtYVByb21pc2UgPSBtb2RlbEFjdGlvbih7IGRhdGFQYXRoOiBuZXh0RGF0YVBhdGgsIGNhbGxzaXRlIH0pKG5leHRVc2VyQXJncyk7XG4gICAgY29uc3Qgb3duS2V5cyA9IGdldE93bktleXMoY2xpZW50LCBkbW1mTW9kZWxOYW1lKTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHByaXNtYVByb21pc2UsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCFvd25LZXlzLmluY2x1ZGVzKHByb3ApKVxuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgIGNvbnN0IGRtbWZNb2RlbE5hbWUyID0gZG1tZk1vZGVsRmllbGRNYXBbcHJvcF0udHlwZTtcbiAgICAgICAgY29uc3QgbW9kZWxBcmdzID0gW2RtbWZNb2RlbE5hbWUyLCBtb2RlbEFjdGlvbiwgcHJvcF07XG4gICAgICAgIGNvbnN0IGRhdGFBcmdzID0gW25leHREYXRhUGF0aCwgbmV4dFVzZXJBcmdzXTtcbiAgICAgICAgcmV0dXJuIGFwcGx5Rmx1ZW50KGNsaWVudCwgLi4ubW9kZWxBcmdzLCAuLi5kYXRhQXJncyk7XG4gICAgICB9LFxuICAgICAgLi4uZGVmYXVsdFByb3h5SGFuZGxlcnMoWy4uLm93bktleXMsIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByaXNtYVByb21pc2UpXSlcbiAgICB9KTtcbiAgfTtcbn1cbl9fbmFtZShhcHBseUZsdWVudCwgXCJhcHBseUZsdWVudFwiKTtcbmZ1bmN0aW9uIGdldE93bktleXMoY2xpZW50LCBkbW1mTW9kZWxOYW1lKSB7XG4gIHJldHVybiBjbGllbnQuX2Jhc2VEbW1mLm1vZGVsTWFwW2RtbWZNb2RlbE5hbWVdLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5raW5kID09PSBcIm9iamVjdFwiKS5tYXAoKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTtcbn1cbl9fbmFtZShnZXRPd25LZXlzLCBcImdldE93bktleXNcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvdXRpbHMvZG1tZlRvSlNNb2RlbE5hbWUudHNcbmZ1bmN0aW9uIGRtbWZUb0pTTW9kZWxOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXi4vLCAoc3RyKSA9PiBzdHIudG9Mb3dlckNhc2UoKSk7XG59XG5fX25hbWUoZG1tZlRvSlNNb2RlbE5hbWUsIFwiZG1tZlRvSlNNb2RlbE5hbWVcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvbW9kZWwvYXBwbHlNb2RlbC50c1xudmFyIGZsdWVudFByb3BzID0gW1wiZmluZFVuaXF1ZVwiLCBcImZpbmRGaXJzdFwiLCBcImNyZWF0ZVwiLCBcInVwZGF0ZVwiLCBcInVwc2VydFwiLCBcImRlbGV0ZVwiXTtcbnZhciBhZ2dyZWdhdGVQcm9wcyA9IFtcImFnZ3JlZ2F0ZVwiLCBcImNvdW50XCIsIFwiZ3JvdXBCeVwiXTtcbmZ1bmN0aW9uIGFwcGx5TW9kZWwoY2xpZW50LCBkbW1mTW9kZWxOYW1lKSB7XG4gIHZhciBfYTM7XG4gIGNvbnN0IGpzTW9kZWxOYW1lID0gZG1tZlRvSlNNb2RlbE5hbWUoZG1tZk1vZGVsTmFtZSk7XG4gIGNvbnN0IG1vZGVsID0gY2xpZW50Ll9iYXNlRG1tZi5tb2RlbE1hcFtkbW1mTW9kZWxOYW1lXTtcbiAgY29uc3QgZmllbGRzUHJveHlFbmFibGVkID0gKF9hMyA9IGNsaWVudC5fZW5naW5lQ29uZmlnLnByZXZpZXdGZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5pbmNsdWRlcyhcImZpZWxkUmVmZXJlbmNlXCIpO1xuICBjb25zdCBvd25LZXlzID0gZ2V0T3duS2V5czIoY2xpZW50LCBkbW1mTW9kZWxOYW1lKTtcbiAgY29uc3QgYmFzZU9iamVjdCA9IHt9O1xuICBsZXQgZmllbGRzUHJveHk7XG4gIHJldHVybiBuZXcgUHJveHkoYmFzZU9iamVjdCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wIGluIHRhcmdldCB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzeW1ib2xcIilcbiAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgIGlmIChwcm9wID09PSBcImZpZWxkc1wiICYmIGZpZWxkc1Byb3h5RW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gZmllbGRzUHJveHkgIT0gbnVsbCA/IGZpZWxkc1Byb3h5IDogZmllbGRzUHJveHkgPSBhcHBseUZpZWxkc1Byb3h5KG1vZGVsKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNWYWxpZEFjdGlvbk5hbWUoY2xpZW50LCBkbW1mTW9kZWxOYW1lLCBwcm9wKSlcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIGNvbnN0IGRtbWZBY3Rpb25OYW1lID0gZ2V0RG1tZkFjdGlvbk5hbWUocHJvcCk7XG4gICAgICBsZXQgcmVxdWVzdEZuID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocGFyYW1zKSA9PiBjbGllbnQuX3JlcXVlc3QocGFyYW1zKSwgXCJyZXF1ZXN0Rm5cIik7XG4gICAgICBpZiAoaXNDbGllbnRPbmx5QWN0aW9uKHByb3ApKSB7XG4gICAgICAgIHJlcXVlc3RGbiA9IHdyYXBSZXF1ZXN0KHByb3AsIGRtbWZNb2RlbE5hbWUsIHJlcXVlc3RGbik7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChwYXJhbU92ZXJyaWRlcykgPT4gKHVzZXJBcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxTaXRlID0gZ2V0Q2FsbFNpdGUoY2xpZW50Ll9lcnJvckZvcm1hdCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmlzbWFQcm9taXNlKCh0eElkLCBsb2NrKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHsgYXJnczogdXNlckFyZ3MsIGRhdGFQYXRoOiBbXSB9O1xuICAgICAgICAgIGNvbnN0IGFjdGlvbjIgPSB7IGFjdGlvbjogZG1tZkFjdGlvbk5hbWUsIG1vZGVsOiBkbW1mTW9kZWxOYW1lIH07XG4gICAgICAgICAgY29uc3QgbWV0aG9kID0geyBjbGllbnRNZXRob2Q6IGAke2pzTW9kZWxOYW1lfS4ke3Byb3B9YCwganNNb2RlbE5hbWUgfTtcbiAgICAgICAgICBjb25zdCB0eCA9IHsgcnVuSW5UcmFuc2FjdGlvbjogISF0eElkLCB0cmFuc2FjdGlvbklkOiB0eElkLCBsb2NrIH07XG4gICAgICAgICAgY29uc3QgdHJhY2UyID0geyBjYWxsc2l0ZTogY2FsbFNpdGUgfTtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IC4uLmRhdGEsIC4uLmFjdGlvbjIsIC4uLm1ldGhvZCwgLi4udHgsIC4uLnRyYWNlMiB9O1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0Rm4oeyAuLi5wYXJhbXMsIC4uLnBhcmFtT3ZlcnJpZGVzIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFwiYWN0aW9uXCIpO1xuICAgICAgaWYgKGZsdWVudFByb3BzLmluY2x1ZGVzKGRtbWZBY3Rpb25OYW1lKSkge1xuICAgICAgICByZXR1cm4gYXBwbHlGbHVlbnQoY2xpZW50LCBkbW1mTW9kZWxOYW1lLCBhY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVmFsaWRBZ2dyZWdhdGVOYW1lKHByb3ApKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFnZ3JlZ2F0ZXMoY2xpZW50LCBwcm9wLCBhY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbih7fSk7XG4gICAgfSxcbiAgICAuLi5kZWZhdWx0UHJveHlIYW5kbGVycyhvd25LZXlzKVxuICB9KTtcbn1cbl9fbmFtZShhcHBseU1vZGVsLCBcImFwcGx5TW9kZWxcIik7XG5mdW5jdGlvbiBnZXRPd25LZXlzMihjbGllbnQsIGRtbWZNb2RlbE5hbWUpIHtcbiAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhjbGllbnQuX2Jhc2VEbW1mLm1hcHBpbmdzTWFwW2RtbWZNb2RlbE5hbWVdKSwgXCJjb3VudFwiXS5maWx0ZXIoXG4gICAgKGtleSkgPT4gIVtcIm1vZGVsXCIsIFwicGx1cmFsXCJdLmluY2x1ZGVzKGtleSlcbiAgKTtcbn1cbl9fbmFtZShnZXRPd25LZXlzMiwgXCJnZXRPd25LZXlzXCIpO1xuZnVuY3Rpb24gaXNWYWxpZEFjdGlvbk5hbWUoY2xpZW50LCBkbW1mTW9kZWxOYW1lLCBhY3Rpb24pIHtcbiAgaWYgKGlzQ2xpZW50T25seUFjdGlvbihhY3Rpb24pKSB7XG4gICAgcmV0dXJuIGlzVmFsaWRBY3Rpb25OYW1lKGNsaWVudCwgZG1tZk1vZGVsTmFtZSwgY2xpZW50T25seUFjdGlvbnNbYWN0aW9uXS53cmFwcGVkQWN0aW9uKTtcbiAgfVxuICByZXR1cm4gZ2V0T3duS2V5czIoY2xpZW50LCBkbW1mTW9kZWxOYW1lKS5pbmNsdWRlcyhhY3Rpb24pO1xufVxuX19uYW1lKGlzVmFsaWRBY3Rpb25OYW1lLCBcImlzVmFsaWRBY3Rpb25OYW1lXCIpO1xuZnVuY3Rpb24gaXNWYWxpZEFnZ3JlZ2F0ZU5hbWUoYWN0aW9uKSB7XG4gIHJldHVybiBhZ2dyZWdhdGVQcm9wcy5pbmNsdWRlcyhhY3Rpb24pO1xufVxuX19uYW1lKGlzVmFsaWRBZ2dyZWdhdGVOYW1lLCBcImlzVmFsaWRBZ2dyZWdhdGVOYW1lXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL3V0aWxzL2pzVG9ETU1GTW9kZWxOYW1lLnRzXG5mdW5jdGlvbiBqc1RvRE1NRk1vZGVsTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL14uLywgKHN0cikgPT4gc3RyLnRvVXBwZXJDYXNlKCkpO1xufVxuX19uYW1lKGpzVG9ETU1GTW9kZWxOYW1lLCBcImpzVG9ETU1GTW9kZWxOYW1lXCIpO1xuXG4vLyBzcmMvcnVudGltZS9jb3JlL21vZGVsL2FwcGx5TW9kZWxzLnRzXG5mdW5jdGlvbiBhcHBseU1vZGVscyhjbGllbnQpIHtcbiAgY29uc3QgbW9kZWxDYWNoZSA9IHt9O1xuICBjb25zdCBvd25LZXlzID0gZ2V0T3duS2V5czMoY2xpZW50KTtcbiAgcmV0dXJuIG5ldyBQcm94eShjbGllbnQsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQgfHwgdHlwZW9mIHByb3AgPT09IFwic3ltYm9sXCIpXG4gICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICBjb25zdCBkbW1mTW9kZWxOYW1lID0ganNUb0RNTUZNb2RlbE5hbWUocHJvcCk7XG4gICAgICBpZiAobW9kZWxDYWNoZVtkbW1mTW9kZWxOYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBtb2RlbENhY2hlW2RtbWZNb2RlbE5hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWVudC5fYmFzZURtbWYubW9kZWxNYXBbZG1tZk1vZGVsTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbW9kZWxDYWNoZVtkbW1mTW9kZWxOYW1lXSA9IGFwcGx5TW9kZWwoY2xpZW50LCBkbW1mTW9kZWxOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGllbnQuX2Jhc2VEbW1mLm1vZGVsTWFwW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsQ2FjaGVbZG1tZk1vZGVsTmFtZV0gPSBhcHBseU1vZGVsKGNsaWVudCwgcHJvcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAuLi5kZWZhdWx0UHJveHlIYW5kbGVycyhvd25LZXlzKVxuICB9KTtcbn1cbl9fbmFtZShhcHBseU1vZGVscywgXCJhcHBseU1vZGVsc1wiKTtcbmZ1bmN0aW9uIGdldE93bktleXMzKGNsaWVudCkge1xuICByZXR1cm4gWy4uLk9iamVjdC5rZXlzKGNsaWVudC5fYmFzZURtbWYubW9kZWxNYXApLm1hcChkbW1mVG9KU01vZGVsTmFtZSksIC4uLk9iamVjdC5rZXlzKGNsaWVudCldO1xufVxuX19uYW1lKGdldE93bktleXMzLCBcImdldE93bktleXNcIik7XG5cbi8vIHNyYy9ydW50aW1lL2NvcmUvdHJhbnNhY3Rpb24vdXRpbHMvY3JlYXRlTG9ja0NvdW50UHJvbWlzZS50c1xuZnVuY3Rpb24gZ2V0TG9ja0NvdW50UHJvbWlzZShrbm9jaywgY2IgPSAoKSA9PiB7XG59KSB7XG4gIGxldCByZXNvbHZlO1xuICBjb25zdCBsb2NrID0gbmV3IFByb21pc2UoKHJlcykgPT4gcmVzb2x2ZSA9IHJlcyk7XG4gIHJldHVybiB7XG4gICAgdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgaWYgKC0ta25vY2sgPT09IDApXG4gICAgICAgIHJlc29sdmUoY2IoKSk7XG4gICAgICByZXR1cm4gb25GdWxmaWxsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRnVsZmlsbGVkKGxvY2spO1xuICAgIH1cbiAgfTtcbn1cbl9fbmFtZShnZXRMb2NrQ291bnRQcm9taXNlLCBcImdldExvY2tDb3VudFByb21pc2VcIik7XG5cbi8vIHNyYy9ydW50aW1lL2dldExvZ0xldmVsLnRzXG5mdW5jdGlvbiBnZXRMb2dMZXZlbChsb2c0KSB7XG4gIGlmICh0eXBlb2YgbG9nNCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBsb2c0O1xuICB9XG4gIHJldHVybiBsb2c0LnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gdHlwZW9mIGN1cnIgPT09IFwic3RyaW5nXCIgPyBjdXJyIDogY3Vyci5sZXZlbDtcbiAgICBpZiAoY3VycmVudExldmVsID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICghYWNjKSB7XG4gICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgIH1cbiAgICBpZiAoY3VyciA9PT0gXCJpbmZvXCIgfHwgYWNjID09PSBcImluZm9cIikge1xuICAgICAgcmV0dXJuIFwiaW5mb1wiO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudExldmVsO1xuICB9LCB2b2lkIDApO1xufVxuX19uYW1lKGdldExvZ0xldmVsLCBcImdldExvZ0xldmVsXCIpO1xuXG4vLyBzcmMvcnVudGltZS9tZXJnZUJ5LnRzXG5mdW5jdGlvbiBtZXJnZUJ5KGFycjEsIGFycjIsIGNiKSB7XG4gIGNvbnN0IGdyb3VwZWRBcnIxID0gZ3JvdXBCeTIoYXJyMSwgY2IpO1xuICBjb25zdCBncm91cGVkQXJyMiA9IGdyb3VwQnkyKGFycjIsIGNiKTtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LnZhbHVlcyhncm91cGVkQXJyMikubWFwKCh2YWx1ZSkgPT4gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pO1xuICBjb25zdCBhcnIyS2V5cyA9IE9iamVjdC5rZXlzKGdyb3VwZWRBcnIyKTtcbiAgT2JqZWN0LmVudHJpZXMoZ3JvdXBlZEFycjEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghYXJyMktleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUobWVyZ2VCeSwgXCJtZXJnZUJ5XCIpO1xudmFyIGdyb3VwQnkyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoYXJyLCBjYikgPT4ge1xuICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gY2IoY3Vycik7XG4gICAgaWYgKCFhY2Nba2V5XSkge1xuICAgICAgYWNjW2tleV0gPSBbXTtcbiAgICB9XG4gICAgYWNjW2tleV0ucHVzaChjdXJyKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59LCBcImdyb3VwQnlcIik7XG5cbi8vIHNyYy9ydW50aW1lL01pZGRsZXdhcmVIYW5kbGVyLnRzXG52YXIgTWlkZGxld2FyZUhhbmRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX21pZGRsZXdhcmVzID0gW107XG4gIH1cbiAgdXNlKG1pZGRsZXdhcmUpIHtcbiAgICB0aGlzLl9taWRkbGV3YXJlcy5wdXNoKG1pZGRsZXdhcmUpO1xuICB9XG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLl9taWRkbGV3YXJlc1tpZF07XG4gIH1cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbWlkZGxld2FyZXNbaWRdO1xuICB9XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWlkZGxld2FyZXMubGVuZ3RoO1xuICB9XG59O1xuX19uYW1lKE1pZGRsZXdhcmVIYW5kbGVyLCBcIk1pZGRsZXdhcmVIYW5kbGVyXCIpO1xudmFyIE1pZGRsZXdhcmVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gbmV3IE1pZGRsZXdhcmVIYW5kbGVyKCk7XG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgTWlkZGxld2FyZUhhbmRsZXIoKTtcbiAgfVxufTtcbl9fbmFtZShNaWRkbGV3YXJlcywgXCJNaWRkbGV3YXJlc1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBpbXBvcnRfc3RyaXBfYW5zaTQgPSBfX3RvRVNNKHJlcXVpcmVfc3RyaXBfYW5zaSgpKTtcblxuLy8gc3JjL3J1bnRpbWUvRGF0YUxvYWRlci50c1xudmFyIERhdGFMb2FkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudGlja0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuYmF0Y2hlcyA9IHt9O1xuICB9XG4gIHJlcXVlc3QocmVxdWVzdDIpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5vcHRpb25zLmJhdGNoQnkocmVxdWVzdDIpO1xuICAgIGlmICghaGFzaCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW5nbGVMb2FkZXIocmVxdWVzdDIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYmF0Y2hlc1toYXNoXSkge1xuICAgICAgdGhpcy5iYXRjaGVzW2hhc2hdID0gW107XG4gICAgICBpZiAoIXRoaXMudGlja0FjdGl2ZSkge1xuICAgICAgICB0aGlzLnRpY2tBY3RpdmUgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoQmF0Y2hlcygpO1xuICAgICAgICAgIHRoaXMudGlja0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuYmF0Y2hlc1toYXNoXS5wdXNoKHtcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdDIsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcGF0Y2hCYXRjaGVzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuYmF0Y2hlcykge1xuICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNba2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLmJhdGNoZXNba2V5XTtcbiAgICAgIGlmIChiYXRjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpbmdsZUxvYWRlcihiYXRjaFswXS5yZXF1ZXN0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGJhdGNoWzBdLnJlamVjdChyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXRjaFswXS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGJhdGNoWzBdLnJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYmF0Y2hMb2FkZXIoYmF0Y2gubWFwKChqKSA9PiBqLnJlcXVlc3QpKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBiYXRjaFtpXS5yZWplY3QocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGJhdGNoW2ldLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hbaV0ucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmF0Y2hbaV0ucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJEYXRhTG9hZGVyXCI7XG4gIH1cbn07XG5fX25hbWUoRGF0YUxvYWRlciwgXCJEYXRhTG9hZGVyXCIpO1xuXG4vLyBzcmMvcnVudGltZS9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGRlYnVnMTEgPSBzcmNfZGVmYXVsdChcInByaXNtYTpjbGllbnQ6cmVxdWVzdF9oYW5kbGVyXCIpO1xuZnVuY3Rpb24gZ2V0UmVxdWVzdEluZm8ocmVxdWVzdDIpIHtcbiAgdmFyIF9hMztcbiAgY29uc3QgdHhJZCA9IHJlcXVlc3QyLnRyYW5zYWN0aW9uSWQ7XG4gIGNvbnN0IGluVHggPSByZXF1ZXN0Mi5ydW5JblRyYW5zYWN0aW9uO1xuICBjb25zdCBoZWFkZXJzID0gKF9hMyA9IHJlcXVlc3QyLmhlYWRlcnMpICE9IG51bGwgPyBfYTMgOiB7fTtcbiAgY29uc3QgdHJhY2VwYXJlbnQgPSBnZXRUcmFjZVBhcmVudCh7IHRyYWNpbmdDb25maWc6IHJlcXVlc3QyLnRyYWNpbmdDb25maWcgfSk7XG4gIGNvbnN0IF9pblR4ID0gdHlwZW9mIHR4SWQgPT09IFwibnVtYmVyXCIgJiYgaW5UeCA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IF90eElkID0gdHlwZW9mIHR4SWQgPT09IFwic3RyaW5nXCIgJiYgaW5UeCA/IHR4SWQgOiB2b2lkIDA7XG4gIGlmIChfdHhJZCAhPT0gdm9pZCAwKVxuICAgIGhlYWRlcnMudHJhbnNhY3Rpb25JZCA9IF90eElkO1xuICBpZiAodHJhY2VwYXJlbnQgIT09IHZvaWQgMClcbiAgICBoZWFkZXJzLnRyYWNlcGFyZW50ID0gdHJhY2VwYXJlbnQ7XG4gIHJldHVybiB7IGluVHg6IF9pblR4LCBoZWFkZXJzIH07XG59XG5fX25hbWUoZ2V0UmVxdWVzdEluZm8sIFwiZ2V0UmVxdWVzdEluZm9cIik7XG52YXIgUmVxdWVzdEhhbmRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaG9va3MpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgdGhpcy5kYXRhbG9hZGVyID0gbmV3IERhdGFMb2FkZXIoe1xuICAgICAgYmF0Y2hMb2FkZXI6IChyZXF1ZXN0cykgPT4ge1xuICAgICAgICBjb25zdCBpbmZvMiA9IGdldFJlcXVlc3RJbmZvKHJlcXVlc3RzWzBdKTtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHJlcXVlc3RzLm1hcCgocikgPT4gU3RyaW5nKHIuZG9jdW1lbnQpKTtcbiAgICAgICAgY29uc3QgdHJhY2VwYXJlbnQgPSBnZXRUcmFjZVBhcmVudCh7IGNvbnRleHQ6IHJlcXVlc3RzWzBdLm90ZWxQYXJlbnRDdHgsIHRyYWNpbmdDb25maWc6IGNsaWVudC5fdHJhY2luZ0NvbmZpZyB9KTtcbiAgICAgICAgaWYgKHRyYWNlcGFyZW50KVxuICAgICAgICAgIGluZm8yLmhlYWRlcnMudHJhY2VwYXJlbnQgPSB0cmFjZXBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Ll9lbmdpbmUucmVxdWVzdEJhdGNoKHF1ZXJpZXMsIGluZm8yLmhlYWRlcnMsIGluZm8yLmluVHgpO1xuICAgICAgfSxcbiAgICAgIHNpbmdsZUxvYWRlcjogKHJlcXVlc3QyKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZm8yID0gZ2V0UmVxdWVzdEluZm8ocmVxdWVzdDIpO1xuICAgICAgICBjb25zdCBxdWVyeTIgPSBTdHJpbmcocmVxdWVzdDIuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuX2VuZ2luZS5yZXF1ZXN0KHF1ZXJ5MiwgaW5mbzIuaGVhZGVycyk7XG4gICAgICB9LFxuICAgICAgYmF0Y2hCeTogKHJlcXVlc3QyKSA9PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0Mi50cmFuc2FjdGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGB0cmFuc2FjdGlvbi0ke3JlcXVlc3QyLnRyYW5zYWN0aW9uSWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmF0Y2hGaW5kVW5pcXVlQnkocmVxdWVzdDIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlcXVlc3Qoe1xuICAgIGRvY3VtZW50OiBkb2N1bWVudDIsXG4gICAgZGF0YVBhdGggPSBbXSxcbiAgICByb290RmllbGQsXG4gICAgdHlwZU5hbWUsXG4gICAgaXNMaXN0LFxuICAgIGNhbGxzaXRlLFxuICAgIHJlamVjdE9uTm90Rm91bmQsXG4gICAgY2xpZW50TWV0aG9kLFxuICAgIHJ1bkluVHJhbnNhY3Rpb24sXG4gICAgZW5naW5lSG9vayxcbiAgICBhcmdzLFxuICAgIGhlYWRlcnMsXG4gICAgdHJhbnNhY3Rpb25JZCxcbiAgICB1bnBhY2tlcixcbiAgICBvdGVsUGFyZW50Q3R4LFxuICAgIG90ZWxDaGlsZEN0eFxuICB9KSB7XG4gICAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5iZWZvcmVSZXF1ZXN0KSB7XG4gICAgICBjb25zdCBxdWVyeTIgPSBTdHJpbmcoZG9jdW1lbnQyKTtcbiAgICAgIHRoaXMuaG9va3MuYmVmb3JlUmVxdWVzdCh7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeTIsXG4gICAgICAgIHBhdGg6IGRhdGFQYXRoLFxuICAgICAgICByb290RmllbGQsXG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgICAgICBpc0xpc3QsXG4gICAgICAgIGNsaWVudE1ldGhvZCxcbiAgICAgICAgYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgZGF0YSwgZWxhcHNlZDtcbiAgICAgIGlmIChlbmdpbmVIb29rKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVuZ2luZUhvb2soXG4gICAgICAgICAge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50MixcbiAgICAgICAgICAgIHJ1bkluVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIChwYXJhbXMpID0+IHRoaXMuZGF0YWxvYWRlci5yZXF1ZXN0KHsgLi4ucGFyYW1zLCB0cmFjaW5nQ29uZmlnOiB0aGlzLmNsaWVudC5fdHJhY2luZ0NvbmZpZyB9KVxuICAgICAgICApO1xuICAgICAgICBkYXRhID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIGVsYXBzZWQgPSByZXN1bHQuZWxhcHNlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGF0YWxvYWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgICAgICAgIHJ1bkluVHJhbnNhY3Rpb24sXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICB0cmFuc2FjdGlvbklkLFxuICAgICAgICAgIG90ZWxQYXJlbnRDdHgsXG4gICAgICAgICAgb3RlbENoaWxkQ3R4LFxuICAgICAgICAgIHRyYWNpbmdDb25maWc6IHRoaXMuY2xpZW50Ll90cmFjaW5nQ29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhID0gcmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHQuZGF0YTtcbiAgICAgICAgZWxhcHNlZCA9IHJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcmVzdWx0LmVsYXBzZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bnBhY2tSZXN1bHQgPSB0aGlzLnVucGFjayhkb2N1bWVudDIsIGRhdGEsIGRhdGFQYXRoLCByb290RmllbGQsIHVucGFja2VyKTtcbiAgICAgIHRocm93SWZOb3RGb3VuZCh1bnBhY2tSZXN1bHQsIGNsaWVudE1ldGhvZCwgdHlwZU5hbWUsIHJlamVjdE9uTm90Rm91bmQpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfR0VUX1RJTUUpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogdW5wYWNrUmVzdWx0LCBlbGFwc2VkIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5wYWNrUmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgdGhpcy5oYW5kbGVSZXF1ZXN0RXJyb3IoeyBlcnJvcjogZXJyb3IyLCBjbGllbnRNZXRob2QsIGNhbGxzaXRlIH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVSZXF1ZXN0RXJyb3IoeyBlcnJvcjogZXJyb3IyLCBjbGllbnRNZXRob2QsIGNhbGxzaXRlIH0pIHtcbiAgICBkZWJ1ZzExKGVycm9yMik7XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvcjIubWVzc2FnZTtcbiAgICBpZiAoY2FsbHNpdGUpIHtcbiAgICAgIG1lc3NhZ2UgPSBjcmVhdGVFcnJvck1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgIGNhbGxzaXRlLFxuICAgICAgICBvcmlnaW5hbE1ldGhvZDogY2xpZW50TWV0aG9kLFxuICAgICAgICBpc1BhbmljOiBlcnJvcjIuaXNQYW5pYyxcbiAgICAgICAgc2hvd0NvbG9yczogdGhpcy5jbGllbnQuX2Vycm9yRm9ybWF0ID09PSBcInByZXR0eVwiLFxuICAgICAgICBtZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IHRoaXMuc2FuaXRpemVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGlmIChlcnJvcjIuY29kZSkge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yKG1lc3NhZ2UsIGVycm9yMi5jb2RlLCB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbiwgZXJyb3IyLm1ldGEpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IyLmlzUGFuaWMpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcihtZXNzYWdlLCB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbik7XG4gICAgfSBlbHNlIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcihtZXNzYWdlLCB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbik7XG4gICAgfSBlbHNlIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcihtZXNzYWdlLCB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbik7XG4gICAgfSBlbHNlIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yKG1lc3NhZ2UsIHRoaXMuY2xpZW50Ll9jbGllbnRWZXJzaW9uKTtcbiAgICB9XG4gICAgZXJyb3IyLmNsaWVudFZlcnNpb24gPSB0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbjtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH1cbiAgc2FuaXRpemVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5jbGllbnQuX2Vycm9yRm9ybWF0ICYmIHRoaXMuY2xpZW50Ll9lcnJvckZvcm1hdCAhPT0gXCJwcmV0dHlcIikge1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfc3RyaXBfYW5zaTQuZGVmYXVsdCkobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIHVucGFjayhkb2N1bWVudDIsIGRhdGEsIHBhdGg3LCByb290RmllbGQsIHVucGFja2VyKSB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcbiAgICB9XG4gICAgaWYgKHVucGFja2VyKSB7XG4gICAgICBkYXRhW3Jvb3RGaWVsZF0gPSB1bnBhY2tlcihkYXRhW3Jvb3RGaWVsZF0pO1xuICAgIH1cbiAgICBjb25zdCBnZXRQYXRoID0gW107XG4gICAgaWYgKHJvb3RGaWVsZCkge1xuICAgICAgZ2V0UGF0aC5wdXNoKHJvb3RGaWVsZCk7XG4gICAgfVxuICAgIGdldFBhdGgucHVzaCguLi5wYXRoNy5maWx0ZXIoKHApID0+IHAgIT09IFwic2VsZWN0XCIgJiYgcCAhPT0gXCJpbmNsdWRlXCIpKTtcbiAgICByZXR1cm4gdW5wYWNrKHsgZG9jdW1lbnQ6IGRvY3VtZW50MiwgZGF0YSwgcGF0aDogZ2V0UGF0aCB9KTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUmVxdWVzdEhhbmRsZXJcIjtcbiAgfVxufTtcbl9fbmFtZShSZXF1ZXN0SGFuZGxlciwgXCJSZXF1ZXN0SGFuZGxlclwiKTtcbmZ1bmN0aW9uIGJhdGNoRmluZFVuaXF1ZUJ5KHJlcXVlc3QyKSB7XG4gIHZhciBfYTM7XG4gIGlmICghcmVxdWVzdDIuZG9jdW1lbnQuY2hpbGRyZW5bMF0ubmFtZS5zdGFydHNXaXRoKFwiZmluZFVuaXF1ZVwiKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgYXJncyA9IChfYTMgPSByZXF1ZXN0Mi5kb2N1bWVudC5jaGlsZHJlblswXS5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmFyZ3MubWFwKChhKSA9PiB7XG4gICAgaWYgKGEudmFsdWUgaW5zdGFuY2VvZiBBcmdzKSB7XG4gICAgICByZXR1cm4gYCR7YS5rZXl9LSR7YS52YWx1ZS5hcmdzLm1hcCgoYTIpID0+IGEyLmtleSkuam9pbihcIixcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGEua2V5O1xuICB9KS5qb2luKFwiLFwiKTtcbiAgY29uc3Qgc2VsZWN0aW9uU2V0ID0gcmVxdWVzdDIuZG9jdW1lbnQuY2hpbGRyZW5bMF0uY2hpbGRyZW4uam9pbihcIixcIik7XG4gIHJldHVybiBgJHtyZXF1ZXN0Mi5kb2N1bWVudC5jaGlsZHJlblswXS5uYW1lfXwke2FyZ3N9fCR7c2VsZWN0aW9uU2V0fWA7XG59XG5fX25hbWUoYmF0Y2hGaW5kVW5pcXVlQnksIFwiYmF0Y2hGaW5kVW5pcXVlQnlcIik7XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2NsaWVudFZlcnNpb24udHNcbnZhciBjbGllbnRWZXJzaW9uID0gcmVxdWlyZV9wYWNrYWdlMigpLnZlcnNpb247XG5cbi8vIHNyYy9ydW50aW1lL3V0aWxzL2Rlc2VyaWFsaXplUmF3UmVzdWx0cy50c1xuZnVuY3Rpb24gZGVzZXJpYWxpemVSYXdSZXN1bHRzKHJvd3MpIHtcbiAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHtcbiAgICBjb25zdCBtYXBwZWRSb3cgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyb3cpKSB7XG4gICAgICBtYXBwZWRSb3dba2V5XSA9IGRlc2VyaWFsaXplVmFsdWUocm93W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkUm93O1xuICB9KTtcbn1cbl9fbmFtZShkZXNlcmlhbGl6ZVJhd1Jlc3VsdHMsIFwiZGVzZXJpYWxpemVSYXdSZXN1bHRzXCIpO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh7IHByaXNtYV9fdHlwZTogdHlwZSwgcHJpc21hX192YWx1ZTogdmFsdWUgfSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgY2FzZSBcImRlY2ltYWxcIjpcbiAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9kZWZhdWx0KHZhbHVlKTtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICBjYXNlIFwidGltZVwiOlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGAxOTcwLTAxLTAxVCR7dmFsdWV9WmApO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIHZhbHVlLm1hcChkZXNlcmlhbGl6ZVZhbHVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5fX25hbWUoZGVzZXJpYWxpemVWYWx1ZSwgXCJkZXNlcmlhbGl6ZVZhbHVlXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9tc3NxbFByZXBhcmVkU3RhdGVtZW50LnRzXG52YXIgbXNzcWxQcmVwYXJlZFN0YXRlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHRlbXBsYXRlKSA9PiB7XG4gIHJldHVybiB0ZW1wbGF0ZS5yZWR1Y2UoKGFjYywgc3RyLCBpZHgpID0+IGAke2FjY31AUCR7aWR4fSR7c3RyfWApO1xufSwgXCJtc3NxbFByZXBhcmVkU3RhdGVtZW50XCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9zZXJpYWxpemVSYXdQYXJhbWV0ZXJzLnRzXG5mdW5jdGlvbiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2VyaWFsaXplUmF3UGFyYW1ldGVyc0ludGVybmFsKHBhcmFtZXRlcnMsIFwiZmFzdFwiKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnNJbnRlcm5hbChwYXJhbWV0ZXJzLCBcInNsb3dcIik7XG4gIH1cbn1cbl9fbmFtZShzZXJpYWxpemVSYXdQYXJhbWV0ZXJzLCBcInNlcmlhbGl6ZVJhd1BhcmFtZXRlcnNcIik7XG5mdW5jdGlvbiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzSW50ZXJuYWwocGFyYW1ldGVycywgb2JqZWN0U2VyaWFsaXphdGlvbikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycy5tYXAoKHBhcmFtZXRlcikgPT4gZW5jb2RlUGFyYW1ldGVyKHBhcmFtZXRlciwgb2JqZWN0U2VyaWFsaXphdGlvbikpKTtcbn1cbl9fbmFtZShzZXJpYWxpemVSYXdQYXJhbWV0ZXJzSW50ZXJuYWwsIFwic2VyaWFsaXplUmF3UGFyYW1ldGVyc0ludGVybmFsXCIpO1xuZnVuY3Rpb24gZW5jb2RlUGFyYW1ldGVyKHBhcmFtZXRlciwgb2JqZWN0U2VyaWFsaXphdGlvbikge1xuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJiaWdpbnRcIikge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlzbWFfX3R5cGU6IFwiYmlnaW50XCIsXG4gICAgICBwcmlzbWFfX3ZhbHVlOiBwYXJhbWV0ZXIudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGF0ZShwYXJhbWV0ZXIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaXNtYV9fdHlwZTogXCJkYXRlXCIsXG4gICAgICBwcmlzbWFfX3ZhbHVlOiBwYXJhbWV0ZXIudG9KU09OKClcbiAgICB9O1xuICB9XG4gIGlmIChkZWNpbWFsX2RlZmF1bHQuaXNEZWNpbWFsKHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpc21hX190eXBlOiBcImRlY2ltYWxcIixcbiAgICAgIHByaXNtYV9fdmFsdWU6IHBhcmFtZXRlci50b0pTT04oKVxuICAgIH07XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXJhbWV0ZXIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaXNtYV9fdHlwZTogXCJieXRlc1wiLFxuICAgICAgcHJpc21hX192YWx1ZTogcGFyYW1ldGVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlckxpa2UocGFyYW1ldGVyKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcocGFyYW1ldGVyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlzbWFfX3R5cGU6IFwiYnl0ZXNcIixcbiAgICAgIHByaXNtYV9fdmFsdWU6IEJ1ZmZlci5mcm9tKHBhcmFtZXRlcikudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmIG9iamVjdFNlcmlhbGl6YXRpb24gPT09IFwic2xvd1wiKSB7XG4gICAgcmV0dXJuIHByZXByb2Nlc3NPYmplY3QocGFyYW1ldGVyKTtcbiAgfVxuICByZXR1cm4gcGFyYW1ldGVyO1xufVxuX19uYW1lKGVuY29kZVBhcmFtZXRlciwgXCJlbmNvZGVQYXJhbWV0ZXJcIik7XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIiAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCI7XG59XG5fX25hbWUoaXNEYXRlLCBcImlzRGF0ZVwiKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJMaWtlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiQXJyYXlCdWZmZXJcIiB8fCB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlNoYXJlZEFycmF5QnVmZmVyXCI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuX19uYW1lKGlzQXJyYXlCdWZmZXJMaWtlLCBcImlzQXJyYXlCdWZmZXJMaWtlXCIpO1xuZnVuY3Rpb24gcHJlcHJvY2Vzc09iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBvYmoudG9KU09OKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKHByZXByb2Nlc3NWYWx1ZUluT2JqZWN0KTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIHJlc3VsdFtrZXldID0gcHJlcHJvY2Vzc1ZhbHVlSW5PYmplY3Qob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5fX25hbWUocHJlcHJvY2Vzc09iamVjdCwgXCJwcmVwcm9jZXNzT2JqZWN0XCIpO1xuZnVuY3Rpb24gcHJlcHJvY2Vzc1ZhbHVlSW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBwcmVwcm9jZXNzT2JqZWN0KHZhbHVlKTtcbn1cbl9fbmFtZShwcmVwcm9jZXNzVmFsdWVJbk9iamVjdCwgXCJwcmVwcm9jZXNzVmFsdWVJbk9iamVjdFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvdXRpbHMvdmFsaWRhdGVQcmlzbWFDbGllbnRPcHRpb25zLnRzXG52YXIgaW1wb3J0X2pzX2xldmVuc2h0ZWluMiA9IF9fdG9FU00ocmVxdWlyZV9qc19sZXZlbnNodGVpbigpKTtcbnZhciBrbm93blByb3BlcnRpZXMgPSBbXCJkYXRhc291cmNlc1wiLCBcImVycm9yRm9ybWF0XCIsIFwibG9nXCIsIFwiX19pbnRlcm5hbFwiLCBcInJlamVjdE9uTm90Rm91bmRcIl07XG52YXIgZXJyb3JGb3JtYXRzID0gW1wicHJldHR5XCIsIFwiY29sb3JsZXNzXCIsIFwibWluaW1hbFwiXTtcbnZhciBsb2dMZXZlbHMgPSBbXCJpbmZvXCIsIFwicXVlcnlcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgZGF0YXNvdXJjZXM6IChvcHRpb25zLCBkYXRhc291cmNlTmFtZXMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0gZm9yIFwiZGF0YXNvdXJjZXNcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3JgXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgICAgaWYgKCFkYXRhc291cmNlTmFtZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb25zdCBkaWRZb3VNZWFuID0gZ2V0RGlkWW91TWVhbihrZXksIGRhdGFzb3VyY2VOYW1lcykgfHwgYEF2YWlsYWJsZSBkYXRhc291cmNlczogJHtkYXRhc291cmNlTmFtZXMuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBgVW5rbm93biBkYXRhc291cmNlICR7a2V5fSBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtkaWRZb3VNZWFufWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGZvciBkYXRhc291cmNlIFwiJHtrZXl9XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLlxuSXQgc2hvdWxkIGhhdmUgdGhpcyBmb3JtOiB7IHVybDogXCJDT05ORUNUSU9OX1NUUklOR1wiIH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleTEsIHZhbHVlMV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGtleTEgIT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0gZm9yIGRhdGFzb3VyY2UgXCIke2tleX1cIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuXG5JdCBzaG91bGQgaGF2ZSB0aGlzIGZvcm06IHsgdXJsOiBcIkNPTk5FQ1RJT05fU1RSSU5HXCIgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUxICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkodmFsdWUxKX0gZm9yIGRhdGFzb3VyY2UgXCIke2tleX1cIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuXG5JdCBzaG91bGQgaGF2ZSB0aGlzIGZvcm06IHsgdXJsOiBcIkNPTk5FQ1RJT05fU1RSSU5HXCIgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvckZvcm1hdDogKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGZvciBcImVycm9yRm9ybWF0XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZXJyb3JGb3JtYXRzLmluY2x1ZGVzKG9wdGlvbnMpKSB7XG4gICAgICBjb25zdCBkaWRZb3VNZWFuID0gZ2V0RGlkWW91TWVhbihvcHRpb25zLCBlcnJvckZvcm1hdHMpO1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCBlcnJvckZvcm1hdCAke29wdGlvbnN9IHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke2RpZFlvdU1lYW59YFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGxvZzogKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGZvciBcImxvZ1wiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci5gXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUxvZ0xldmVsKGxldmVsKSB7XG4gICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghbG9nTGV2ZWxzLmluY2x1ZGVzKGxldmVsKSkge1xuICAgICAgICAgIGNvbnN0IGRpZFlvdU1lYW4gPSBnZXREaWRZb3VNZWFuKGxldmVsLCBsb2dMZXZlbHMpO1xuICAgICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIGxvZyBsZXZlbCBcIiR7bGV2ZWx9XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiR7ZGlkWW91TWVhbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodmFsaWRhdGVMb2dMZXZlbCwgXCJ2YWxpZGF0ZUxvZ0xldmVsXCIpO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIHZhbGlkYXRlTG9nTGV2ZWwob3B0aW9uKTtcbiAgICAgIGNvbnN0IGxvZ1ZhbGlkYXRvcnMgPSB7XG4gICAgICAgIGxldmVsOiB2YWxpZGF0ZUxvZ0xldmVsLFxuICAgICAgICBlbWl0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICBjb25zdCBlbWl0cyA9IFtcInN0ZG91dFwiLCBcImV2ZW50XCJdO1xuICAgICAgICAgIGlmICghZW1pdHMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaWRZb3VNZWFuID0gZ2V0RGlkWW91TWVhbih2YWx1ZSwgZW1pdHMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICl9IGZvciBcImVtaXRcIiBpbiBsb2dMZXZlbCBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtkaWRZb3VNZWFufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbiAmJiB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbikpIHtcbiAgICAgICAgICBpZiAobG9nVmFsaWRhdG9yc1trZXldKSB7XG4gICAgICAgICAgICBsb2dWYWxpZGF0b3JzW2tleV0odmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5ICR7a2V5fSBmb3IgXCJsb2dcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3JgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX19pbnRlcm5hbDogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrbm93bktleXMgPSBbXCJkZWJ1Z1wiLCBcImhvb2tzXCIsIFwiZW5naW5lXCIsIFwibWVhc3VyZVBlcmZvcm1hbmNlXCJdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGZvciBcIl9faW50ZXJuYWxcIiB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3JgXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXldIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgaWYgKCFrbm93bktleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb25zdCBkaWRZb3VNZWFuID0gZ2V0RGlkWW91TWVhbihrZXksIGtub3duS2V5cyk7XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IGZvciBcIl9faW50ZXJuYWxcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtkaWRZb3VNZWFufWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlamVjdE9uTm90Rm91bmQ6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvcihcbiAgICAgIGBJbnZhbGlkIHJlamVjdE9uTm90Rm91bmQgZXhwZWN0ZWQgYSBib29sZWFuL0Vycm9yL3tbbW9kZWxOYW1lOiBFcnJvciB8IGJvb2xlYW5dfSBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdmFsdWVcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVByaXNtYUNsaWVudE9wdGlvbnMob3B0aW9ucywgZGF0YXNvdXJjZU5hbWVzKSB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpKSB7XG4gICAgaWYgKCFrbm93blByb3BlcnRpZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc3QgZGlkWW91TWVhbiA9IGdldERpZFlvdU1lYW4oa2V5LCBrbm93blByb3BlcnRpZXMpO1xuICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudENvbnN0cnVjdG9yVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgVW5rbm93biBwcm9wZXJ0eSAke2tleX0gcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiR7ZGlkWW91TWVhbn1gXG4gICAgICApO1xuICAgIH1cbiAgICB2YWxpZGF0b3JzW2tleV0odmFsdWUsIGRhdGFzb3VyY2VOYW1lcyk7XG4gIH1cbn1cbl9fbmFtZSh2YWxpZGF0ZVByaXNtYUNsaWVudE9wdGlvbnMsIFwidmFsaWRhdGVQcmlzbWFDbGllbnRPcHRpb25zXCIpO1xuZnVuY3Rpb24gZ2V0RGlkWW91TWVhbihzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBhbHRlcm5hdGl2ZSA9IGdldEFsdGVybmF0aXZlKHN0ciwgb3B0aW9ucyk7XG4gIGlmICghYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gYCBEaWQgeW91IG1lYW4gXCIke2FsdGVybmF0aXZlfVwiP2A7XG59XG5fX25hbWUoZ2V0RGlkWW91TWVhbiwgXCJnZXREaWRZb3VNZWFuXCIpO1xuZnVuY3Rpb24gZ2V0QWx0ZXJuYXRpdmUoc3RyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG9wdGlvbnNXaXRoRGlzdGFuY2VzID0gb3B0aW9ucy5tYXAoKHZhbHVlKSA9PiAoe1xuICAgIHZhbHVlLFxuICAgIGRpc3RhbmNlOiAoMCwgaW1wb3J0X2pzX2xldmVuc2h0ZWluMi5kZWZhdWx0KShzdHIsIHZhbHVlKVxuICB9KSk7XG4gIG9wdGlvbnNXaXRoRGlzdGFuY2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5kaXN0YW5jZSA8IGIuZGlzdGFuY2UgPyAtMSA6IDE7XG4gIH0pO1xuICBjb25zdCBiZXN0QWx0ZXJuYXRpdmUgPSBvcHRpb25zV2l0aERpc3RhbmNlc1swXTtcbiAgaWYgKGJlc3RBbHRlcm5hdGl2ZS5kaXN0YW5jZSA8IDMpIHtcbiAgICByZXR1cm4gYmVzdEFsdGVybmF0aXZlLnZhbHVlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuX19uYW1lKGdldEFsdGVybmF0aXZlLCBcImdldEFsdGVybmF0aXZlXCIpO1xuXG4vLyBzcmMvcnVudGltZS9nZXRQcmlzbWFDbGllbnQudHNcbnZhciBkZWJ1ZzEyID0gc3JjX2RlZmF1bHQoXCJwcmlzbWE6Y2xpZW50XCIpO1xudmFyIEFMVEVSX1JFID0gL14oXFxzKmFsdGVyXFxzKS9pO1xudHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxUaGlzLk5PREVfQ0xJRU5UID0gdHJ1ZSA6IDA7XG5mdW5jdGlvbiBpc1JlYWRvbmx5QXJyYXkoYXJnMikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcyKTtcbn1cbl9fbmFtZShpc1JlYWRvbmx5QXJyYXksIFwiaXNSZWFkb25seUFycmF5XCIpO1xuZnVuY3Rpb24gY2hlY2tBbHRlcihxdWVyeTIsIHZhbHVlcywgaW52YWxpZENhbGwpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPiAwICYmIEFMVEVSX1JFLmV4ZWMocXVlcnkyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgUnVubmluZyBBTFRFUiB1c2luZyAke2ludmFsaWRDYWxsfSBpcyBub3Qgc3VwcG9ydGVkXG5Vc2luZyB0aGUgZXhhbXBsZSBiZWxvdyB5b3UgY2FuIHN0aWxsIGV4ZWN1dGUgeW91ciBxdWVyeSB3aXRoIFByaXNtYSwgYnV0IHBsZWFzZSBub3RlIHRoYXQgaXQgaXMgdnVsbmVyYWJsZSB0byBTUUwgaW5qZWN0aW9uIGF0dGFja3MgYW5kIHJlcXVpcmVzIHlvdSB0byB0YWtlIGNhcmUgb2YgaW5wdXQgc2FuaXRpemF0aW9uLlxuXG5FeGFtcGxlOlxuICBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdVbnNhZmUoXFxgQUxURVIgVVNFUiBwcmlzbWEgV0lUSCBQQVNTV09SRCAnXFwke3Bhc3N3b3JkfSdcXGApXG5cbk1vcmUgSW5mb3JtYXRpb246IGh0dHBzOi8vcHJpcy5seS9kL2V4ZWN1dGUtcmF3XG5gKTtcbiAgfVxufVxuX19uYW1lKGNoZWNrQWx0ZXIsIFwiY2hlY2tBbHRlclwiKTtcbnZhciBhY3Rpb25PcGVyYXRpb25NYXAgPSB7XG4gIGZpbmRVbmlxdWU6IFwicXVlcnlcIixcbiAgZmluZEZpcnN0OiBcInF1ZXJ5XCIsXG4gIGZpbmRNYW55OiBcInF1ZXJ5XCIsXG4gIGNvdW50OiBcInF1ZXJ5XCIsXG4gIGNyZWF0ZTogXCJtdXRhdGlvblwiLFxuICBjcmVhdGVNYW55OiBcIm11dGF0aW9uXCIsXG4gIHVwZGF0ZTogXCJtdXRhdGlvblwiLFxuICB1cGRhdGVNYW55OiBcIm11dGF0aW9uXCIsXG4gIHVwc2VydDogXCJtdXRhdGlvblwiLFxuICBkZWxldGU6IFwibXV0YXRpb25cIixcbiAgZGVsZXRlTWFueTogXCJtdXRhdGlvblwiLFxuICBleGVjdXRlUmF3OiBcIm11dGF0aW9uXCIsXG4gIHF1ZXJ5UmF3OiBcIm11dGF0aW9uXCIsXG4gIGFnZ3JlZ2F0ZTogXCJxdWVyeVwiLFxuICBncm91cEJ5OiBcInF1ZXJ5XCIsXG4gIHJ1bkNvbW1hbmRSYXc6IFwibXV0YXRpb25cIixcbiAgZmluZFJhdzogXCJxdWVyeVwiLFxuICBhZ2dyZWdhdGVSYXc6IFwicXVlcnlcIlxufTtcbnZhciBUWF9JRCA9IFN5bWJvbC5mb3IoXCJwcmlzbWEuY2xpZW50LnRyYW5zYWN0aW9uLmlkXCIpO1xuZnVuY3Rpb24gZ2V0UHJpc21hQ2xpZW50KGNvbmZpZzIpIHtcbiAgY2xhc3MgUHJpc21hQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zQXJnKSB7XG4gICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IG5ldyBNaWRkbGV3YXJlcygpO1xuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25JZCA9IDE7XG4gICAgICB0aGlzLl9nZXREbW1mID0gY2FsbE9uY2UoYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRtbWYgPSBhd2FpdCB0aGlzLl9lbmdpbmUuZ2V0RG1tZigpO1xuICAgICAgICAgIHJldHVybiBuZXcgRE1NRkhlbHBlcihnZXRQcmlzbWFDbGllbnRETU1GKGRtbWYpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgdGhpcy5fZmV0Y2hlci5oYW5kbGVSZXF1ZXN0RXJyb3IoeyAuLi5wYXJhbXMsIGVycm9yOiBlcnJvcjIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9hMywgX2IyLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgICAgIGlmIChvcHRpb25zQXJnKSB7XG4gICAgICAgIHZhbGlkYXRlUHJpc21hQ2xpZW50T3B0aW9ucyhvcHRpb25zQXJnLCBjb25maWcyLmRhdGFzb3VyY2VOYW1lcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmV2aWV3RmVhdHVyZXMgPSAoX2IyID0gKF9hMyA9IGNvbmZpZzIuZ2VuZXJhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLnByZXZpZXdGZWF0dXJlcykgIT0gbnVsbCA/IF9iMiA6IFtdO1xuICAgICAgdGhpcy5fcmVqZWN0T25Ob3RGb3VuZCA9IG9wdGlvbnNBcmcgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnNBcmcucmVqZWN0T25Ob3RGb3VuZDtcbiAgICAgIHRoaXMuX2NsaWVudFZlcnNpb24gPSAoX2MgPSBjb25maWcyLmNsaWVudFZlcnNpb24pICE9IG51bGwgPyBfYyA6IGNsaWVudFZlcnNpb247XG4gICAgICB0aGlzLl9hY3RpdmVQcm92aWRlciA9IGNvbmZpZzIuYWN0aXZlUHJvdmlkZXI7XG4gICAgICB0aGlzLl9kYXRhUHJveHkgPSBjb25maWcyLmRhdGFQcm94eTtcbiAgICAgIHRoaXMuX3RyYWNpbmdDb25maWcgPSBnZXRUcmFjaW5nQ29uZmlnKHRoaXMuX3ByZXZpZXdGZWF0dXJlcyk7XG4gICAgICB0aGlzLl9jbGllbnRFbmdpbmVUeXBlID0gZ2V0Q2xpZW50RW5naW5lVHlwZShjb25maWcyLmdlbmVyYXRvcik7XG4gICAgICBjb25zdCBlbnZQYXRocyA9IHtcbiAgICAgICAgcm9vdEVudlBhdGg6IGNvbmZpZzIucmVsYXRpdmVFbnZQYXRocy5yb290RW52UGF0aCAmJiBpbXBvcnRfcGF0aDUuZGVmYXVsdC5yZXNvbHZlKGNvbmZpZzIuZGlybmFtZSwgY29uZmlnMi5yZWxhdGl2ZUVudlBhdGhzLnJvb3RFbnZQYXRoKSxcbiAgICAgICAgc2NoZW1hRW52UGF0aDogY29uZmlnMi5yZWxhdGl2ZUVudlBhdGhzLnNjaGVtYUVudlBhdGggJiYgaW1wb3J0X3BhdGg1LmRlZmF1bHQucmVzb2x2ZShjb25maWcyLmRpcm5hbWUsIGNvbmZpZzIucmVsYXRpdmVFbnZQYXRocy5zY2hlbWFFbnZQYXRoKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvYWRlZEVudiA9IHRyeUxvYWRFbnZzKGVudlBhdGhzLCB7IGNvbmZsaWN0Q2hlY2s6IFwibm9uZVwiIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNBcmcgIT0gbnVsbCA/IG9wdGlvbnNBcmcgOiB7fTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWwgPSAoX2QgPSBvcHRpb25zLl9faW50ZXJuYWwpICE9IG51bGwgPyBfZCA6IHt9O1xuICAgICAgICBjb25zdCB1c2VEZWJ1ZyA9IGludGVybmFsLmRlYnVnID09PSB0cnVlO1xuICAgICAgICBpZiAodXNlRGVidWcpIHtcbiAgICAgICAgICBzcmNfZGVmYXVsdC5lbmFibGUoXCJwcmlzbWE6Y2xpZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm5hbC5ob29rcykge1xuICAgICAgICAgIHRoaXMuX2hvb2tzID0gaW50ZXJuYWwuaG9va3M7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN3ZCA9IGltcG9ydF9wYXRoNS5kZWZhdWx0LnJlc29sdmUoY29uZmlnMi5kaXJuYW1lLCBjb25maWcyLnJlbGF0aXZlUGF0aCk7XG4gICAgICAgIGlmICghaW1wb3J0X2ZzOS5kZWZhdWx0LmV4aXN0c1N5bmMoY3dkKSkge1xuICAgICAgICAgIGN3ZCA9IGNvbmZpZzIuZGlybmFtZTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZzEyKFwiZGlybmFtZVwiLCBjb25maWcyLmRpcm5hbWUpO1xuICAgICAgICBkZWJ1ZzEyKFwicmVsYXRpdmVQYXRoXCIsIGNvbmZpZzIucmVsYXRpdmVQYXRoKTtcbiAgICAgICAgZGVidWcxMihcImN3ZFwiLCBjd2QpO1xuICAgICAgICBjb25zdCB0aGVkYXRhc291cmNlcyA9IG9wdGlvbnMuZGF0YXNvdXJjZXMgfHwge307XG4gICAgICAgIGNvbnN0IGlucHV0RGF0YXNvdXJjZXMgPSBPYmplY3QuZW50cmllcyh0aGVkYXRhc291cmNlcykuZmlsdGVyKChbXywgc291cmNlXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLnVybDtcbiAgICAgICAgfSkubWFwKChbbmFtZSwgeyB1cmwgfV0pID0+ICh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB1cmxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBkYXRhc291cmNlcyA9IG1lcmdlQnkoW10sIGlucHV0RGF0YXNvdXJjZXMsIChzb3VyY2UpID0+IHNvdXJjZS5uYW1lKTtcbiAgICAgICAgY29uc3QgZW5naW5lQ29uZmlnID0gaW50ZXJuYWwuZW5naW5lIHx8IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5lcnJvckZvcm1hdCkge1xuICAgICAgICAgIHRoaXMuX2Vycm9yRm9ybWF0ID0gb3B0aW9ucy5lcnJvckZvcm1hdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvckZvcm1hdCA9IFwibWluaW1hbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PX0NPTE9SKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JGb3JtYXQgPSBcImNvbG9ybGVzc1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2Vycm9yRm9ybWF0ID0gXCJjb2xvcmxlc3NcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYXNlRG1tZiA9IG5ldyBCYXNlRE1NRkhlbHBlcihjb25maWcyLmRvY3VtZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFQcm94eSkge1xuICAgICAgICAgIGNvbnN0IHJhd0RtbWYgPSBjb25maWcyLmRvY3VtZW50O1xuICAgICAgICAgIHRoaXMuX2RtbWYgPSBuZXcgRE1NRkhlbHBlcihyYXdEbW1mKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmdpbmVDb25maWcgPSB7XG4gICAgICAgICAgY3dkLFxuICAgICAgICAgIGRpcm5hbWU6IGNvbmZpZzIuZGlybmFtZSxcbiAgICAgICAgICBlbmFibGVEZWJ1Z0xvZ3M6IHVzZURlYnVnLFxuICAgICAgICAgIGFsbG93VHJpZ2dlclBhbmljOiBlbmdpbmVDb25maWcuYWxsb3dUcmlnZ2VyUGFuaWMsXG4gICAgICAgICAgZGF0YW1vZGVsUGF0aDogaW1wb3J0X3BhdGg1LmRlZmF1bHQuam9pbihjb25maWcyLmRpcm5hbWUsIChfZSA9IGNvbmZpZzIuZmlsZW5hbWUpICE9IG51bGwgPyBfZSA6IFwic2NoZW1hLnByaXNtYVwiKSxcbiAgICAgICAgICBwcmlzbWFQYXRoOiAoX2YgPSBlbmdpbmVDb25maWcuYmluYXJ5UGF0aCkgIT0gbnVsbCA/IF9mIDogdm9pZCAwLFxuICAgICAgICAgIGVuZ2luZUVuZHBvaW50OiBlbmdpbmVDb25maWcuZW5kcG9pbnQsXG4gICAgICAgICAgZGF0YXNvdXJjZXMsXG4gICAgICAgICAgZ2VuZXJhdG9yOiBjb25maWcyLmdlbmVyYXRvcixcbiAgICAgICAgICBzaG93Q29sb3JzOiB0aGlzLl9lcnJvckZvcm1hdCA9PT0gXCJwcmV0dHlcIixcbiAgICAgICAgICBsb2dMZXZlbDogb3B0aW9ucy5sb2cgJiYgZ2V0TG9nTGV2ZWwob3B0aW9ucy5sb2cpLFxuICAgICAgICAgIGxvZ1F1ZXJpZXM6IG9wdGlvbnMubG9nICYmIEJvb2xlYW4oXG4gICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2cgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmxvZyA9PT0gXCJxdWVyeVwiIDogb3B0aW9ucy5sb2cuZmluZCgobykgPT4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyBvID09PSBcInF1ZXJ5XCIgOiBvLmxldmVsID09PSBcInF1ZXJ5XCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbnY6IChfaSA9IChfaCA9IGxvYWRlZEVudiA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVkRW52LnBhcnNlZCkgIT0gbnVsbCA/IF9oIDogKF9nID0gY29uZmlnMi5pbmplY3RhYmxlRWRnZUVudikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnBhcnNlZCkgIT0gbnVsbCA/IF9pIDoge30sXG4gICAgICAgICAgZmxhZ3M6IFtdLFxuICAgICAgICAgIGNsaWVudFZlcnNpb246IGNvbmZpZzIuY2xpZW50VmVyc2lvbixcbiAgICAgICAgICBwcmV2aWV3RmVhdHVyZXM6IHRoaXMuX3ByZXZpZXdGZWF0dXJlcyxcbiAgICAgICAgICBhY3RpdmVQcm92aWRlcjogY29uZmlnMi5hY3RpdmVQcm92aWRlcixcbiAgICAgICAgICBpbmxpbmVTY2hlbWE6IGNvbmZpZzIuaW5saW5lU2NoZW1hLFxuICAgICAgICAgIGlubGluZURhdGFzb3VyY2VzOiBjb25maWcyLmlubGluZURhdGFzb3VyY2VzLFxuICAgICAgICAgIGlubGluZVNjaGVtYUhhc2g6IGNvbmZpZzIuaW5saW5lU2NoZW1hSGFzaCxcbiAgICAgICAgICB0cmFjaW5nQ29uZmlnOiB0aGlzLl90cmFjaW5nQ29uZmlnXG4gICAgICAgIH07XG4gICAgICAgIGRlYnVnMTIoXCJjbGllbnRWZXJzaW9uXCIsIGNvbmZpZzIuY2xpZW50VmVyc2lvbik7XG4gICAgICAgIGRlYnVnMTIoXCJjbGllbnRFbmdpbmVUeXBlXCIsIHRoaXMuX2RhdGFQcm94eSA/IFwiZGF0YXByb3h5XCIgOiB0aGlzLl9jbGllbnRFbmdpbmVUeXBlKTtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFQcm94eSkge1xuICAgICAgICAgIGNvbnN0IHJ1bnRpbWUgPSB0cnVlID8gXCJOb2RlLmpzXCIgOiBcImVkZ2VcIjtcbiAgICAgICAgICBkZWJ1ZzEyKGB1c2luZyBEYXRhIFByb3h5IHdpdGggJHtydW50aW1lfSBydW50aW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5naW5lID0gdGhpcy5nZXRFbmdpbmUoKTtcbiAgICAgICAgdm9pZCB0aGlzLl9nZXRBY3RpdmVQcm92aWRlcigpO1xuICAgICAgICB0aGlzLl9mZXRjaGVyID0gbmV3IFJlcXVlc3RIYW5kbGVyKHRoaXMsIHRoaXMuX2hvb2tzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBsb2c0IG9mIG9wdGlvbnMubG9nKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbCA9IHR5cGVvZiBsb2c0ID09PSBcInN0cmluZ1wiID8gbG9nNCA6IGxvZzQuZW1pdCA9PT0gXCJzdGRvdXRcIiA/IGxvZzQubGV2ZWwgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgICAgICAgIHRoaXMuJG9uKGxldmVsLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E0O1xuICAgICAgICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLmxvZyhgJHsoX2E0ID0gbG9nZ2VyX2V4cG9ydHMudGFnc1tsZXZlbF0pICE9IG51bGwgPyBfYTQgOiBcIlwifWAsIGV2ZW50Lm1lc3NhZ2UgfHwgZXZlbnQucXVlcnkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWV0cmljcyA9IG5ldyBNZXRyaWNzQ2xpZW50KHRoaXMuX2VuZ2luZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuY2xpZW50VmVyc2lvbiA9IHRoaXMuX2NsaWVudFZlcnNpb247XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBwbHlNb2RlbHModGhpcyk7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgIHJldHVybiBcIlByaXNtYUNsaWVudFwiO1xuICAgIH1cbiAgICBnZXRFbmdpbmUoKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YVByb3h5ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVByb3h5RW5naW5lKHRoaXMuX2VuZ2luZUNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NsaWVudEVuZ2luZVR5cGUgPT09IFwibGlicmFyeVwiIC8qIExpYnJhcnkgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaWJyYXJ5RW5naW5lKHRoaXMuX2VuZ2luZUNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NsaWVudEVuZ2luZVR5cGUgPT09IFwiYmluYXJ5XCIgLyogQmluYXJ5ICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5RW5naW5lKHRoaXMuX2VuZ2luZUNvbmZpZyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKFwiSW52YWxpZCBjbGllbnQgZW5naW5lIHR5cGUsIHBsZWFzZSB1c2UgYGxpYnJhcnlgIG9yIGBiaW5hcnlgXCIpO1xuICAgIH1cbiAgICAkdXNlKGFyZzAsIGFyZzEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmVzLnF1ZXJ5LnVzZShhcmcwKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gXCJhbGxcIikge1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlcy5xdWVyeS51c2UoYXJnMSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZzAgPT09IFwiZW5naW5lXCIpIHtcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMuZW5naW5lLnVzZShhcmcxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtaWRkbGV3YXJlICR7YXJnMH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgJG9uKGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IFwiYmVmb3JlRXhpdFwiKSB7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5vbihcImJlZm9yZUV4aXRcIiwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5naW5lLm9uKGV2ZW50VHlwZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMywgX2IyLCBfYywgX2Q7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gZXZlbnQuZmllbGRzO1xuICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBldmVudC50aW1lc3RhbXAsXG4gICAgICAgICAgICAgIHF1ZXJ5OiAoX2EzID0gZmllbGRzID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZHMucXVlcnkpICE9IG51bGwgPyBfYTMgOiBldmVudC5xdWVyeSxcbiAgICAgICAgICAgICAgcGFyYW1zOiAoX2IyID0gZmllbGRzID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZHMucGFyYW1zKSAhPSBudWxsID8gX2IyIDogZXZlbnQucGFyYW1zLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogKF9jID0gZmllbGRzID09IG51bGwgPyB2b2lkIDAgOiBmaWVsZHMuZHVyYXRpb25fbXMpICE9IG51bGwgPyBfYyA6IGV2ZW50LmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh7XG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBmaWVsZHMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkcy5tZXNzYWdlKSAhPSBudWxsID8gX2QgOiBldmVudC5tZXNzYWdlLFxuICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgJGNvbm5lY3QoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5naW5lLnN0YXJ0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuY2xpZW50VmVyc2lvbiA9IHRoaXMuX2NsaWVudFZlcnNpb247XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ydW5EaXNjb25uZWN0KCkge1xuICAgICAgYXdhaXQgdGhpcy5fZW5naW5lLnN0b3AoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgIHRoaXMuX2VuZ2luZSA9IHRoaXMuZ2V0RW5naW5lKCk7XG4gICAgICBkZWxldGUgdGhpcy5fZGlzY29ubmVjdGlvblByb21pc2U7XG4gICAgICBkZWxldGUgdGhpcy5fZ2V0Q29uZmlnUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgJGRpc2Nvbm5lY3QoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmdpbmUuc3RvcCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmNsaWVudFZlcnNpb24gPSB0aGlzLl9jbGllbnRWZXJzaW9uO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhUHJveHkpIHtcbiAgICAgICAgICB0aGlzLl9kbW1mID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBY3RpdmVQcm92aWRlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGF3YWl0IHRoaXMuX2VuZ2luZS5nZXRDb25maWcoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlUHJvdmlkZXIgPSBjb25maWdSZXN1bHQuZGF0YXNvdXJjZXNbMF0uYWN0aXZlUHJvdmlkZXI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfVxuICAgICRleGVjdXRlUmF3SW50ZXJuYWwodHhJZCwgbG9jaywgcXVlcnkyLCAuLi52YWx1ZXMpIHtcbiAgICAgIGxldCBxdWVyeVN0cmluZyA9IFwiXCI7XG4gICAgICBsZXQgcGFyYW1ldGVycyA9IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgcXVlcnkyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnkyO1xuICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyh2YWx1ZXMgfHwgW10pLFxuICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQWx0ZXIocXVlcnlTdHJpbmcsIHZhbHVlcywgXCJwcmlzbWEuJGV4ZWN1dGVSYXdVbnNhZmUoPFNRTD4sIFsuLi52YWx1ZXNdKVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkb25seUFycmF5KHF1ZXJ5MikpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9hY3RpdmVQcm92aWRlcikge1xuICAgICAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgICBjYXNlIFwibXlzcWxcIjoge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlJbnN0YW5jZSA9IG5ldyBTcWwocXVlcnkyLCB2YWx1ZXMpO1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeUluc3RhbmNlLnNxbDtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyhxdWVyeUluc3RhbmNlLnZhbHVlcyksXG4gICAgICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjb2Nrcm9hY2hkYlwiOlxuICAgICAgICAgIGNhc2UgXCJwb3N0Z3Jlc3FsXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5SW5zdGFuY2UgPSBuZXcgU3FsKHF1ZXJ5MiwgdmFsdWVzKTtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlJbnN0YW5jZS50ZXh0O1xuICAgICAgICAgICAgY2hlY2tBbHRlcihxdWVyeVN0cmluZywgcXVlcnlJbnN0YW5jZS52YWx1ZXMsIFwicHJpc21hLiRleGVjdXRlUmF3YDxTUUw+YFwiKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyhxdWVyeUluc3RhbmNlLnZhbHVlcyksXG4gICAgICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJzcWxzZXJ2ZXJcIjoge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBtc3NxbFByZXBhcmVkU3RhdGVtZW50KHF1ZXJ5Mik7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnModmFsdWVzKSxcbiAgICAgICAgICAgICAgX19wcmlzbWFSYXdQYXJhbWF0ZXJzX186IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJHt0aGlzLl9hY3RpdmVQcm92aWRlcn0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAkZXhlY3V0ZVJhd2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9hY3RpdmVQcm92aWRlcikge1xuICAgICAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgICBjYXNlIFwibXlzcWxcIjpcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnkyLnNxbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2Nrcm9hY2hkYlwiOlxuICAgICAgICAgIGNhc2UgXCJwb3N0Z3Jlc3FsXCI6XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5Mi50ZXh0O1xuICAgICAgICAgICAgY2hlY2tBbHRlcihxdWVyeVN0cmluZywgcXVlcnkyLnZhbHVlcywgXCJwcmlzbWEuJGV4ZWN1dGVSYXcoc3FsYDxTUUw+YClcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3Fsc2VydmVyXCI6XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IG1zc3FsUHJlcGFyZWRTdGF0ZW1lbnQocXVlcnkyLnN0cmluZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7dGhpcy5fYWN0aXZlUHJvdmlkZXJ9IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJGV4ZWN1dGVSYXdgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyhxdWVyeTIudmFsdWVzKSxcbiAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtZXRlcnMudmFsdWVzKSB7XG4gICAgICAgIGRlYnVnMTIoYHByaXNtYS4kZXhlY3V0ZVJhdygke3F1ZXJ5U3RyaW5nfSwgJHtwYXJhbWV0ZXJzLnZhbHVlc30pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZzEyKGBwcmlzbWEuJGV4ZWN1dGVSYXcoJHtxdWVyeVN0cmluZ30pYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0geyBxdWVyeTogcXVlcnlTdHJpbmcsIHBhcmFtZXRlcnMgfTtcbiAgICAgIGRlYnVnMTIoYFByaXNtYSBDbGllbnQgY2FsbDpgKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgY2xpZW50TWV0aG9kOiBcIiRleGVjdXRlUmF3XCIsXG4gICAgICAgIGRhdGFQYXRoOiBbXSxcbiAgICAgICAgYWN0aW9uOiBcImV4ZWN1dGVSYXdcIixcbiAgICAgICAgY2FsbHNpdGU6IGdldENhbGxTaXRlKHRoaXMuX2Vycm9yRm9ybWF0KSxcbiAgICAgICAgcnVuSW5UcmFuc2FjdGlvbjogISF0eElkLFxuICAgICAgICB0cmFuc2FjdGlvbklkOiB0eElkLFxuICAgICAgICBsb2NrXG4gICAgICB9KTtcbiAgICB9XG4gICAgJGV4ZWN1dGVSYXcocXVlcnkyLCAuLi52YWx1ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVQcmlzbWFQcm9taXNlKCh0eElkLCBsb2NrKSA9PiB7XG4gICAgICAgIGlmIChxdWVyeTIucmF3ICE9PSB2b2lkIDAgfHwgcXVlcnkyLnNxbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGV4ZWN1dGVSYXdJbnRlcm5hbCh0eElkLCBsb2NrLCBxdWVyeTIsIC4uLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcihgXFxgJGV4ZWN1dGVSYXdcXGAgaXMgYSB0YWcgZnVuY3Rpb24sIHBsZWFzZSB1c2UgaXQgbGlrZSB0aGUgZm9sbG93aW5nOlxuXFxgXFxgXFxgXG5jb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdcXGBVUERBVEUgVXNlciBTRVQgY29vbCA9IFxcJHt0cnVlfSBXSEVSRSBlbWFpbCA9IFxcJHsndXNlckBlbWFpbC5jb20nfTtcXGBcblxcYFxcYFxcYFxuXG5PciByZWFkIG91ciBkb2NzIGF0IGh0dHBzOi8vd3d3LnByaXNtYS5pby9kb2NzL2NvbmNlcHRzL2NvbXBvbmVudHMvcHJpc21hLWNsaWVudC9yYXctZGF0YWJhc2UtYWNjZXNzI2V4ZWN1dGVyYXdcbmApO1xuICAgICAgfSk7XG4gICAgfVxuICAgICRleGVjdXRlUmF3VW5zYWZlKHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZXhlY3V0ZVJhd0ludGVybmFsKHR4SWQsIGxvY2ssIHF1ZXJ5MiwgLi4udmFsdWVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkcnVuQ29tbWFuZFJhdyhjb21tYW5kKSB7XG4gICAgICBpZiAoY29uZmlnMi5hY3RpdmVQcm92aWRlciAhPT0gXCJtb25nb2RiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBgVGhlICR7Y29uZmlnMi5hY3RpdmVQcm92aWRlcn0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAkcnVuQ29tbWFuZFJhdy4gVXNlIHRoZSBtb25nb2RiIHByb3ZpZGVyLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVQcmlzbWFQcm9taXNlKCh0eElkLCBsb2NrKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHtcbiAgICAgICAgICBhcmdzOiB7IGNvbW1hbmQgfSxcbiAgICAgICAgICBjbGllbnRNZXRob2Q6IFwiJHJ1bkNvbW1hbmRSYXdcIixcbiAgICAgICAgICBkYXRhUGF0aDogW10sXG4gICAgICAgICAgYWN0aW9uOiBcInJ1bkNvbW1hbmRSYXdcIixcbiAgICAgICAgICBjYWxsc2l0ZTogZ2V0Q2FsbFNpdGUodGhpcy5fZXJyb3JGb3JtYXQpLFxuICAgICAgICAgIHJ1bkluVHJhbnNhY3Rpb246ICEhdHhJZCxcbiAgICAgICAgICB0cmFuc2FjdGlvbklkOiB0eElkLFxuICAgICAgICAgIGxvY2tcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJHF1ZXJ5UmF3SW50ZXJuYWwodHhJZCwgbG9jaywgcXVlcnkyLCAuLi52YWx1ZXMpIHtcbiAgICAgIGxldCBxdWVyeVN0cmluZyA9IFwiXCI7XG4gICAgICBsZXQgcGFyYW1ldGVycyA9IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgcXVlcnkyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnkyO1xuICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyh2YWx1ZXMgfHwgW10pLFxuICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHlBcnJheShxdWVyeTIpKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWN0aXZlUHJvdmlkZXIpIHtcbiAgICAgICAgICBjYXNlIFwic3FsaXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm15c3FsXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5SW5zdGFuY2UgPSBuZXcgU3FsKHF1ZXJ5MiwgdmFsdWVzKTtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlJbnN0YW5jZS5zcWw7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnlJbnN0YW5jZS52YWx1ZXMpLFxuICAgICAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29ja3JvYWNoZGJcIjpcbiAgICAgICAgICBjYXNlIFwicG9zdGdyZXNxbFwiOiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeUluc3RhbmNlID0gbmV3IFNxbChxdWVyeTIsIHZhbHVlcyk7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5SW5zdGFuY2UudGV4dDtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlczogc2VyaWFsaXplUmF3UGFyYW1ldGVycyhxdWVyeUluc3RhbmNlLnZhbHVlcyksXG4gICAgICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJzcWxzZXJ2ZXJcIjoge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlJbnN0YW5jZSA9IG5ldyBTcWwocXVlcnkyLCB2YWx1ZXMpO1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBtc3NxbFByZXBhcmVkU3RhdGVtZW50KHF1ZXJ5SW5zdGFuY2Uuc3RyaW5ncyk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmlhbGl6ZVJhd1BhcmFtZXRlcnMocXVlcnlJbnN0YW5jZS52YWx1ZXMpLFxuICAgICAgICAgICAgICBfX3ByaXNtYVJhd1BhcmFtYXRlcnNfXzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke3RoaXMuX2FjdGl2ZVByb3ZpZGVyfSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICRxdWVyeVJhd2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9hY3RpdmVQcm92aWRlcikge1xuICAgICAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgICBjYXNlIFwibXlzcWxcIjpcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnkyLnNxbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2Nrcm9hY2hkYlwiOlxuICAgICAgICAgIGNhc2UgXCJwb3N0Z3Jlc3FsXCI6XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5Mi50ZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNxbHNlcnZlclwiOlxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBtc3NxbFByZXBhcmVkU3RhdGVtZW50KHF1ZXJ5Mi5zdHJpbmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7dGhpcy5fYWN0aXZlUHJvdmlkZXJ9IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJHF1ZXJ5UmF3YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgdmFsdWVzOiBzZXJpYWxpemVSYXdQYXJhbWV0ZXJzKHF1ZXJ5Mi52YWx1ZXMpLFxuICAgICAgICAgIF9fcHJpc21hUmF3UGFyYW1hdGVyc19fOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1ldGVycy52YWx1ZXMpIHtcbiAgICAgICAgZGVidWcxMihgcHJpc21hLnF1ZXJ5UmF3KCR7cXVlcnlTdHJpbmd9LCAke3BhcmFtZXRlcnMudmFsdWVzfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnMTIoYHByaXNtYS5xdWVyeVJhdygke3F1ZXJ5U3RyaW5nfSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSB7IHF1ZXJ5OiBxdWVyeVN0cmluZywgcGFyYW1ldGVycyB9O1xuICAgICAgZGVidWcxMihgUHJpc21hIENsaWVudCBjYWxsOmApO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Qoe1xuICAgICAgICBhcmdzLFxuICAgICAgICBjbGllbnRNZXRob2Q6IFwiJHF1ZXJ5UmF3XCIsXG4gICAgICAgIGRhdGFQYXRoOiBbXSxcbiAgICAgICAgYWN0aW9uOiBcInF1ZXJ5UmF3XCIsXG4gICAgICAgIGNhbGxzaXRlOiBnZXRDYWxsU2l0ZSh0aGlzLl9lcnJvckZvcm1hdCksXG4gICAgICAgIHJ1bkluVHJhbnNhY3Rpb246ICEhdHhJZCxcbiAgICAgICAgdHJhbnNhY3Rpb25JZDogdHhJZCxcbiAgICAgICAgbG9ja1xuICAgICAgfSkudGhlbihkZXNlcmlhbGl6ZVJhd1Jlc3VsdHMpO1xuICAgIH1cbiAgICAkcXVlcnlSYXcocXVlcnkyLCAuLi52YWx1ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVQcmlzbWFQcm9taXNlKCh0eElkLCBsb2NrKSA9PiB7XG4gICAgICAgIGlmIChxdWVyeTIucmF3ICE9PSB2b2lkIDAgfHwgcXVlcnkyLnNxbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHF1ZXJ5UmF3SW50ZXJuYWwodHhJZCwgbG9jaywgcXVlcnkyLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IoYFxcYCRxdWVyeVJhd1xcYCBpcyBhIHRhZyBmdW5jdGlvbiwgcGxlYXNlIHVzZSBpdCBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cXGBcXGBcXGBcbmNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdcXGBTRUxFQ1QgKiBGUk9NIFVzZXIgV0hFUkUgaWQgPSBcXCR7MX0gT1IgZW1haWwgPSBcXCR7J3VzZXJAZW1haWwuY29tJ307XFxgXG5cXGBcXGBcXGBcblxuT3IgcmVhZCBvdXIgZG9jcyBhdCBodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9jb25jZXB0cy9jb21wb25lbnRzL3ByaXNtYS1jbGllbnQvcmF3LWRhdGFiYXNlLWFjY2VzcyNxdWVyeXJhd1xuYCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJHF1ZXJ5UmF3VW5zYWZlKHF1ZXJ5MiwgLi4udmFsdWVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJpc21hUHJvbWlzZSgodHhJZCwgbG9jaykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcXVlcnlSYXdJbnRlcm5hbCh0eElkLCBsb2NrLCBxdWVyeTIsIC4uLnZhbHVlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19pbnRlcm5hbF90cmlnZ2VyUGFuaWMoZmF0YWwpIHtcbiAgICAgIGlmICghdGhpcy5fZW5naW5lQ29uZmlnLmFsbG93VHJpZ2dlclBhbmljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gb3JkZXIgdG8gdXNlIC5fX2ludGVybmFsX3RyaWdnZXJQYW5pYygpLCBwbGVhc2UgZW5hYmxlIGl0IGxpa2Ugc286XG5uZXcgUHJpc21hQ2xpZW50KHtcbiAgX19pbnRlcm5hbDoge1xuICAgIGVuZ2luZToge1xuICAgICAgYWxsb3dUcmlnZ2VyUGFuaWM6IHRydWVcbiAgICB9XG4gIH1cbn0pYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXJzID0gZmF0YWwgPyB7IFwiWC1ERUJVRy1GQVRBTFwiOiBcIjFcIiB9IDogeyBcIlgtREVCVUctTk9OLUZBVEFMXCI6IFwiMVwiIH07XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh7XG4gICAgICAgIGFjdGlvbjogXCJxdWVyeVJhd1wiLFxuICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgcXVlcnk6IFwiU0VMRUNUIDFcIixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgY2xpZW50TWV0aG9kOiBcInF1ZXJ5UmF3XCIsXG4gICAgICAgIGRhdGFQYXRoOiBbXSxcbiAgICAgICAgcnVuSW5UcmFuc2FjdGlvbjogZmFsc2UsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNhbGxzaXRlOiBnZXRDYWxsU2l0ZSh0aGlzLl9lcnJvckZvcm1hdClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfdHJhbnNhY3Rpb25XaXRoQXJyYXkocHJvbWlzZXMpIHtcbiAgICAgIGNvbnN0IHR4SWQgPSB0aGlzLl90cmFuc2FjdGlvbklkKys7XG4gICAgICBjb25zdCBsb2NrID0gZ2V0TG9ja0NvdW50UHJvbWlzZShwcm9taXNlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBwcm9taXNlcy5tYXAoKHJlcXVlc3QyKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGlmICgocmVxdWVzdDIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcXVlc3QyW1N5bWJvbC50b1N0cmluZ1RhZ10pICE9PSBcIlByaXNtYVByb21pc2VcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5IG5lZWQgdG8gYmUgUHJpc21hIENsaWVudCBwcm9taXNlcy4gSGludDogUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIG5vdCBhd2FpdGluZyB0aGUgUHJpc21hIGNsaWVudCBjYWxscyB5b3UgaW50ZW5kZWQgdG8gcGFzcyBpbiB0aGUgJHRyYW5zYWN0aW9uIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EzID0gcmVxdWVzdDIucmVxdWVzdFRyYW5zYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwocmVxdWVzdDIsIHR4SWQsIGxvY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIH1cbiAgICBhc3luYyBfdHJhbnNhY3Rpb25XaXRoQ2FsbGJhY2soe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgfSkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHsgdHJhY2VwYXJlbnQ6IGdldFRyYWNlUGFyZW50KHsgdHJhY2luZ0NvbmZpZzogdGhpcy5fdHJhY2luZ0NvbmZpZyB9KSB9O1xuICAgICAgY29uc3QgaW5mbzIgPSBhd2FpdCB0aGlzLl9lbmdpbmUudHJhbnNhY3Rpb24oXCJzdGFydFwiLCBoZWFkZXJzLCBvcHRpb25zKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBjYWxsYmFjayh0cmFuc2FjdGlvblByb3h5KHRoaXMsIGluZm8yLmlkKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZ2luZS50cmFuc2FjdGlvbihcImNvbW1pdFwiLCBoZWFkZXJzLCBpbmZvMik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZ2luZS50cmFuc2FjdGlvbihcInJvbGxiYWNrXCIsIGhlYWRlcnMsIGluZm8yKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgICAgICBlLmNsaWVudFZlcnNpb24gPSB0aGlzLl9jbGllbnRWZXJzaW9uO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgJHRyYW5zYWN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBsZXQgY2FsbGJhY2s7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5faGFzUHJldmlld0ZsYWcoXCJpbnRlcmFjdGl2ZVRyYW5zYWN0aW9uc1wiKSkge1xuICAgICAgICBjYWxsYmFjayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gdGhpcy5fdHJhbnNhY3Rpb25XaXRoQ2FsbGJhY2soeyBjYWxsYmFjazogaW5wdXQsIG9wdGlvbnMgfSksIFwiY2FsbGJhY2tcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gdGhpcy5fdHJhbnNhY3Rpb25XaXRoQXJyYXkoaW5wdXQpLCBcImNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IFwidHJhbnNhY3Rpb25cIixcbiAgICAgICAgZW5hYmxlZDogdGhpcy5fdHJhY2luZ0NvbmZpZy5lbmFibGVkLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IG1ldGhvZDogXCIkdHJhbnNhY3Rpb25cIiB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJ1bkluQ2hpbGRTcGFuKHNwYW5PcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0KGludGVybmFsUGFyYW1zKSB7XG4gICAgICBpbnRlcm5hbFBhcmFtcy5vdGVsUGFyZW50Q3R4ID0gY29udGV4dDIuYWN0aXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgYXJnczogaW50ZXJuYWxQYXJhbXMuYXJncyxcbiAgICAgICAgICBkYXRhUGF0aDogaW50ZXJuYWxQYXJhbXMuZGF0YVBhdGgsXG4gICAgICAgICAgcnVuSW5UcmFuc2FjdGlvbjogaW50ZXJuYWxQYXJhbXMucnVuSW5UcmFuc2FjdGlvbixcbiAgICAgICAgICBhY3Rpb246IGludGVybmFsUGFyYW1zLmFjdGlvbixcbiAgICAgICAgICBtb2RlbDogaW50ZXJuYWxQYXJhbXMubW9kZWxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgICAgbWlkZGxld2FyZToge1xuICAgICAgICAgICAgbmFtZTogXCJtaWRkbGV3YXJlXCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0aGlzLl90cmFjaW5nQ29uZmlnLm1pZGRsZXdhcmUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IG1ldGhvZDogXCIkdXNlXCIgfSxcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJvcGVyYXRpb25cIixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX3RyYWNpbmdDb25maWcuZW5hYmxlZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBwYXJhbXMuYWN0aW9uLFxuICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICBuYW1lOiBgJHtwYXJhbXMubW9kZWx9LiR7cGFyYW1zLmFjdGlvbn1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjaGFuZ2VkUGFyYW1zKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dE1pZGRsZXdhcmUgPSB0aGlzLl9taWRkbGV3YXJlcy5xdWVyeS5nZXQoKytpbmRleCk7XG4gICAgICAgICAgaWYgKG5leHRNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuSW5DaGlsZFNwYW4oc3Bhbk9wdGlvbnMubWlkZGxld2FyZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHRNaWRkbGV3YXJlKGNoYW5nZWRQYXJhbXMsIChwKSA9PiAoc3BhbiA9PSBudWxsID8gdm9pZCAwIDogc3Bhbi5lbmQoKSwgY29uc3VtZXIocCkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZVJlcXVlc3QoeyAuLi5pbnRlcm5hbFBhcmFtcywgLi4uY2hhbmdlZFBhcmFtcyB9KTtcbiAgICAgICAgfSwgXCJjb25zdW1lclwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bkluQ2hpbGRTcGFuKHNwYW5PcHRpb25zLm9wZXJhdGlvbiwgKCkgPT4ge1xuICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBhc3luY1JlcyA9IG5ldyBpbXBvcnRfYXN5bmNfaG9va3MuQXN5bmNSZXNvdXJjZShcInByaXNtYS1jbGllbnQtcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybiBhc3luY1Jlcy5ydW5JbkFzeW5jU2NvcGUoKCkgPT4gY29uc3VtZXIocGFyYW1zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb25zdW1lcihwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZS5jbGllbnRWZXJzaW9uID0gdGhpcy5fY2xpZW50VmVyc2lvbjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2V4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgIGFyZ3MsXG4gICAgICBjbGllbnRNZXRob2QsXG4gICAgICBqc01vZGVsTmFtZSxcbiAgICAgIGRhdGFQYXRoLFxuICAgICAgY2FsbHNpdGUsXG4gICAgICBydW5JblRyYW5zYWN0aW9uLFxuICAgICAgYWN0aW9uLFxuICAgICAgbW9kZWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgdHJhbnNhY3Rpb25JZCxcbiAgICAgIGxvY2ssXG4gICAgICB1bnBhY2tlcixcbiAgICAgIG90ZWxQYXJlbnRDdHhcbiAgICB9KSB7XG4gICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICBpZiAodGhpcy5fZG1tZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2RtbWYgPSBhd2FpdCB0aGlzLl9nZXREbW1mKHsgY2xpZW50TWV0aG9kLCBjYWxsc2l0ZSB9KTtcbiAgICAgIH1cbiAgICAgIGxldCByb290RmllbGQ7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBhY3Rpb25PcGVyYXRpb25NYXBbYWN0aW9uXTtcbiAgICAgIGlmIChhY3Rpb24gPT09IFwiZXhlY3V0ZVJhd1wiIHx8IGFjdGlvbiA9PT0gXCJxdWVyeVJhd1wiIHx8IGFjdGlvbiA9PT0gXCJydW5Db21tYW5kUmF3XCIpIHtcbiAgICAgICAgcm9vdEZpZWxkID0gYWN0aW9uO1xuICAgICAgfVxuICAgICAgbGV0IG1hcHBpbmc7XG4gICAgICBpZiAobW9kZWwgIT09IHZvaWQgMCkge1xuICAgICAgICBtYXBwaW5nID0gKF9hMyA9IHRoaXMuX2RtbWYpID09IG51bGwgPyB2b2lkIDAgOiBfYTMubWFwcGluZ3NNYXBbbW9kZWxdO1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBtYXBwaW5nIGZvciBtb2RlbCAke21vZGVsfWApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3RGaWVsZCA9IG1hcHBpbmdbYWN0aW9uID09PSBcImNvdW50XCIgPyBcImFnZ3JlZ2F0ZVwiIDogYWN0aW9uXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24gIT09IFwicXVlcnlcIiAmJiBvcGVyYXRpb24gIT09IFwibXV0YXRpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3BlcmF0aW9uICR7b3BlcmF0aW9ufSBmb3IgYWN0aW9uICR7YWN0aW9ufWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZmllbGQgPSAoX2IyID0gdGhpcy5fZG1tZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5yb290RmllbGRNYXBbcm9vdEZpZWxkXTtcbiAgICAgIGlmIChmaWVsZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgcm9vdEZpZWxkICR7cm9vdEZpZWxkfSBmb3IgYWN0aW9uICR7YWN0aW9ufSBmb3IgbW9kZWwgJHttb2RlbH0gb24gcm9vdFR5cGUgJHtvcGVyYXRpb259YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBpc0xpc3QgfSA9IGZpZWxkLm91dHB1dFR5cGU7XG4gICAgICBjb25zdCB0eXBlTmFtZSA9IGdldE91dHB1dFR5cGVOYW1lKGZpZWxkLm91dHB1dFR5cGUudHlwZSk7XG4gICAgICBjb25zdCByZWplY3RPbk5vdEZvdW5kID0gZ2V0UmVqZWN0T25Ob3RGb3VuZChhY3Rpb24sIHR5cGVOYW1lLCBhcmdzLCB0aGlzLl9yZWplY3RPbk5vdEZvdW5kKTtcbiAgICAgIHdhcm5BYm91dFJlamVjdE9uTm90Rm91bmQocmVqZWN0T25Ob3RGb3VuZCwganNNb2RlbE5hbWUsIGFjdGlvbik7XG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uRm4gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQzID0gbWFrZURvY3VtZW50KHtcbiAgICAgICAgICBkbW1mOiB0aGlzLl9kbW1mLFxuICAgICAgICAgIHJvb3RGaWVsZCxcbiAgICAgICAgICByb290VHlwZU5hbWU6IG9wZXJhdGlvbixcbiAgICAgICAgICBzZWxlY3Q6IGFyZ3MsXG4gICAgICAgICAgbW9kZWxOYW1lOiBtb2RlbFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQzLnZhbGlkYXRlKGFyZ3MsIGZhbHNlLCBjbGllbnRNZXRob2QsIHRoaXMuX2Vycm9yRm9ybWF0LCBjYWxsc2l0ZSk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Eb2N1bWVudChkb2N1bWVudDMpO1xuICAgICAgfSwgXCJzZXJpYWxpemF0aW9uRm5cIik7XG4gICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogXCJzZXJpYWxpemVcIixcbiAgICAgICAgZW5hYmxlZDogdGhpcy5fdHJhY2luZ0NvbmZpZy5lbmFibGVkXG4gICAgICB9O1xuICAgICAgY29uc3QgZG9jdW1lbnQyID0gYXdhaXQgcnVuSW5DaGlsZFNwYW4oc3Bhbk9wdGlvbnMsIHNlcmlhbGl6YXRpb25Gbik7XG4gICAgICBpZiAoc3JjX2RlZmF1bHQuZW5hYmxlZChcInByaXNtYTpjbGllbnRcIikpIHtcbiAgICAgICAgY29uc3QgcXVlcnkyID0gU3RyaW5nKGRvY3VtZW50Mik7XG4gICAgICAgIGRlYnVnMTIoYFByaXNtYSBDbGllbnQgY2FsbDpgKTtcbiAgICAgICAgZGVidWcxMihcbiAgICAgICAgICBgcHJpc21hLiR7Y2xpZW50TWV0aG9kfSgke3ByaW50SnNvbldpdGhFcnJvcnMoe1xuICAgICAgICAgICAgYXN0OiBhcmdzLFxuICAgICAgICAgICAga2V5UGF0aHM6IFtdLFxuICAgICAgICAgICAgdmFsdWVQYXRoczogW10sXG4gICAgICAgICAgICBtaXNzaW5nSXRlbXM6IFtdXG4gICAgICAgICAgfSl9KWBcbiAgICAgICAgKTtcbiAgICAgICAgZGVidWcxMihgR2VuZXJhdGVkIHJlcXVlc3Q6YCk7XG4gICAgICAgIGRlYnVnMTIocXVlcnkyICsgXCJcXG5cIik7XG4gICAgICB9XG4gICAgICBhd2FpdCBsb2NrO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZXIucmVxdWVzdCh7XG4gICAgICAgIGRvY3VtZW50OiBkb2N1bWVudDIsXG4gICAgICAgIGNsaWVudE1ldGhvZCxcbiAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgIGRhdGFQYXRoLFxuICAgICAgICByZWplY3RPbk5vdEZvdW5kLFxuICAgICAgICBpc0xpc3QsXG4gICAgICAgIHJvb3RGaWVsZCxcbiAgICAgICAgY2FsbHNpdGUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGVuZ2luZUhvb2s6IHRoaXMuX21pZGRsZXdhcmVzLmVuZ2luZS5nZXQoMCksXG4gICAgICAgIHJ1bkluVHJhbnNhY3Rpb24sXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgICAgIHVucGFja2VyLFxuICAgICAgICBvdGVsUGFyZW50Q3R4LFxuICAgICAgICBvdGVsQ2hpbGRDdHg6IGNvbnRleHQyLmFjdGl2ZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2V0ICRtZXRyaWNzKCkge1xuICAgICAgaWYgKCF0aGlzLl9oYXNQcmV2aWV3RmxhZyhcIm1ldHJpY3NcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBcImBtZXRyaWNzYCBwcmV2aWV3IGZlYXR1cmUgbXVzdCBiZSBlbmFibGVkIGluIG9yZGVyIHRvIGFjY2VzcyBtZXRyaWNzIEFQSVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbWV0cmljcztcbiAgICB9XG4gICAgX2hhc1ByZXZpZXdGbGFnKGZlYXR1cmUpIHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gISEoKF9hMyA9IHRoaXMuX2VuZ2luZUNvbmZpZy5wcmV2aWV3RmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuaW5jbHVkZXMoZmVhdHVyZSkpO1xuICAgIH1cbiAgfVxuICBfX25hbWUoUHJpc21hQ2xpZW50LCBcIlByaXNtYUNsaWVudFwiKTtcbiAgcmV0dXJuIFByaXNtYUNsaWVudDtcbn1cbl9fbmFtZShnZXRQcmlzbWFDbGllbnQsIFwiZ2V0UHJpc21hQ2xpZW50XCIpO1xudmFyIGZvcmJpZGRlbiA9IFtcIiRjb25uZWN0XCIsIFwiJGRpc2Nvbm5lY3RcIiwgXCIkb25cIiwgXCIkdHJhbnNhY3Rpb25cIiwgXCIkdXNlXCJdO1xuZnVuY3Rpb24gdHJhbnNhY3Rpb25Qcm94eSh0aGluZywgdHhJZCkge1xuICBpZiAodHlwZW9mIHRoaW5nICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiB0aGluZztcbiAgcmV0dXJuIG5ldyBQcm94eSh0aGluZywge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgaWYgKGZvcmJpZGRlbi5pbmNsdWRlcyhwcm9wKSlcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIGlmIChwcm9wID09PSBUWF9JRClcbiAgICAgICAgcmV0dXJuIHR4SWQ7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGlmIChwcm9wID09PSBcInRoZW5cIilcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF0oYXJnc1swXSwgYXJnc1sxXSwgdHhJZCk7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiY2F0Y2hcIilcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF0oYXJnc1swXSwgdHhJZCk7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiZmluYWxseVwiKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXShhcmdzWzBdLCB0eElkKTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Qcm94eSh0YXJnZXRbcHJvcF0oLi4uYXJncyksIHR4SWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uUHJveHkodGFyZ2V0W3Byb3BdLCB0eElkKTtcbiAgICB9XG4gIH0pO1xufVxuX19uYW1lKHRyYW5zYWN0aW9uUHJveHksIFwidHJhbnNhY3Rpb25Qcm94eVwiKTtcbnZhciByZWplY3RPbk5vdEZvdW5kUmVwbGFjZW1lbnRzID0ge1xuICBmaW5kVW5pcXVlOiBcImZpbmRVbmlxdWVPclRocm93XCIsXG4gIGZpbmRGaXJzdDogXCJmaW5kRmlyc3RPclRocm93XCJcbn07XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWplY3RPbk5vdEZvdW5kKHJlamVjdE9uTm90Rm91bmQsIG1vZGVsLCBhY3Rpb24pIHtcbiAgaWYgKHJlamVjdE9uTm90Rm91bmQpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudEFjdGlvbiA9IHJlamVjdE9uTm90Rm91bmRSZXBsYWNlbWVudHNbYWN0aW9uXTtcbiAgICBjb25zdCByZXBsYWNlbWVudENhbGwgPSBtb2RlbCA/IGBwcmlzbWEuJHttb2RlbH0uJHtyZXBsYWNlbWVudEFjdGlvbn1gIDogYHByaXNtYS4ke3JlcGxhY2VtZW50QWN0aW9ufWA7XG4gICAgY29uc3Qga2V5ID0gYHJlamVjdE9uTm90Rm91bmQuJHttb2RlbCAhPSBudWxsID8gbW9kZWwgOiBcIlwifS4ke2FjdGlvbn1gO1xuICAgIHdhcm5PbmNlKFxuICAgICAga2V5LFxuICAgICAgYFxcYHJlamVjdE9uTm90Rm91bmRcXGAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBQcmlzbWEgNS4gUGxlYXNlIHVzZSBcXGAke3JlcGxhY2VtZW50Q2FsbH1cXGAgbWV0aG9kIGluc3RlYWRgXG4gICAgKTtcbiAgfVxufVxuX19uYW1lKHdhcm5BYm91dFJlamVjdE9uTm90Rm91bmQsIFwid2FybkFib3V0UmVqZWN0T25Ob3RGb3VuZFwiKTtcblxuLy8gc3JjL3J1bnRpbWUvc3RyaWN0RW51bS50c1xudmFyIGFsbG93TGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJ0b0pTT05cIixcbiAgXCJhc3ltbWV0cmljTWF0Y2hcIixcbiAgU3ltYm9sLml0ZXJhdG9yLFxuICBTeW1ib2wudG9TdHJpbmdUYWcsXG4gIFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUsXG4gIFN5bWJvbC50b1ByaW1pdGl2ZVxuXSk7XG5mdW5jdGlvbiBtYWtlU3RyaWN0RW51bShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBuZXcgUHJveHkoZGVmaW5pdGlvbiwge1xuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICBpZiAocHJvcGVydHkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgaWYgKGFsbG93TGlzdC5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVudW0gdmFsdWU6ICR7U3RyaW5nKHByb3BlcnR5KX1gKTtcbiAgICB9XG4gIH0pO1xufVxuX19uYW1lKG1ha2VTdHJpY3RFbnVtLCBcIm1ha2VTdHJpY3RFbnVtXCIpO1xuXG4vLyBzcmMvcnVudGltZS91dGlscy9maW5kLnRzXG52YXIgaW1wb3J0X2ZzMTAgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X3BhdGg2ID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgaW1wb3J0X3V0aWw3ID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgcmVhZGRpckFzeW5jID0gKDAsIGltcG9ydF91dGlsNy5wcm9taXNpZnkpKGltcG9ydF9mczEwLmRlZmF1bHQucmVhZGRpcik7XG52YXIgcmVhbHBhdGhBc3luYyA9ICgwLCBpbXBvcnRfdXRpbDcucHJvbWlzaWZ5KShpbXBvcnRfZnMxMC5kZWZhdWx0LnJlYWxwYXRoKTtcbnZhciBzdGF0QXN5bmMgPSAoMCwgaW1wb3J0X3V0aWw3LnByb21pc2lmeSkoaW1wb3J0X2ZzMTAuZGVmYXVsdC5zdGF0KTtcbnZhciByZWFkZGlyU3luYyA9IGltcG9ydF9mczEwLmRlZmF1bHQucmVhZGRpclN5bmM7XG52YXIgcmVhbHBhdGhTeW5jID0gaW1wb3J0X2ZzMTAuZGVmYXVsdC5yZWFscGF0aFN5bmM7XG52YXIgc3RhdFN5bmMgPSBpbXBvcnRfZnMxMC5kZWZhdWx0LnN0YXRTeW5jO1xuZnVuY3Rpb24gZGlyZW50VG9UeXBlKGRpcmVudCkge1xuICByZXR1cm4gZGlyZW50LmlzRmlsZSgpID8gXCJmXCIgOiBkaXJlbnQuaXNEaXJlY3RvcnkoKSA/IFwiZFwiIDogZGlyZW50LmlzU3ltYm9saWNMaW5rKCkgPyBcImxcIiA6IHZvaWQgMDtcbn1cbl9fbmFtZShkaXJlbnRUb1R5cGUsIFwiZGlyZW50VG9UeXBlXCIpO1xuZnVuY3Rpb24gaXNNYXRjaGVkKHN0cmluZywgcmVnZXhzKSB7XG4gIGZvciAoY29uc3QgcmVnZXggb2YgcmVnZXhzKSB7XG4gICAgaWYgKHR5cGVvZiByZWdleCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHN0cmluZy5pbmNsdWRlcyhyZWdleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdleC5leGVjKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5fX25hbWUoaXNNYXRjaGVkLCBcImlzTWF0Y2hlZFwiKTtcbmZ1bmN0aW9uIGZpbmRTeW5jKHJvb3QsIG1hdGNoLCB0eXBlcyA9IFtcImZcIiwgXCJkXCIsIFwibFwiXSwgZGVlcCA9IFtdLCBsaW1pdCA9IEluZmluaXR5LCBoYW5kbGVyID0gKCkgPT4gdHJ1ZSwgZm91bmQgPSBbXSwgc2VlbiA9IHt9KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVhbFJvb3QgPSByZWFscGF0aFN5bmMocm9vdCk7XG4gICAgaWYgKHNlZW5bcmVhbFJvb3RdKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChsaW1pdCAtIGZvdW5kLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChkaXJlbnRUb1R5cGUoc3RhdFN5bmMocmVhbFJvb3QpKSAhPT0gXCJkXCIpIHtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSByZWFkZGlyU3luYyhyb290LCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgc2VlbltyZWFsUm9vdF0gPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgaXRlbU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICBjb25zdCBpdGVtVHlwZSA9IGRpcmVudFRvVHlwZShpdGVtKTtcbiAgICAgIGNvbnN0IGl0ZW1QYXRoID0gaW1wb3J0X3BhdGg2LmRlZmF1bHQuam9pbihyb290LCBpdGVtLm5hbWUpO1xuICAgICAgaWYgKGl0ZW1UeXBlICYmIHR5cGVzLmluY2x1ZGVzKGl0ZW1UeXBlKSkge1xuICAgICAgICBpZiAoaXNNYXRjaGVkKGl0ZW1QYXRoLCBtYXRjaCkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZXIocm9vdCwgaXRlbU5hbWUsIGl0ZW1UeXBlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKGl0ZW1QYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWVwLmluY2x1ZGVzKGl0ZW1UeXBlKSkge1xuICAgICAgICBmaW5kU3luYyhpdGVtUGF0aCwgbWF0Y2gsIHR5cGVzLCBkZWVwLCBsaW1pdCwgaGFuZGxlciwgZm91bmQsIHNlZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbl9fbmFtZShmaW5kU3luYywgXCJmaW5kU3luY1wiKTtcblxuLy8gc3JjL3J1bnRpbWUvd2FybkVudkNvbmZsaWN0cy50c1xuZnVuY3Rpb24gd2FybkVudkNvbmZsaWN0cyhlbnZQYXRocykge1xuICB0cnlMb2FkRW52cyhlbnZQYXRocywgeyBjb25mbGljdENoZWNrOiBcIndhcm5cIiB9KTtcbn1cbl9fbmFtZSh3YXJuRW52Q29uZmxpY3RzLCBcIndhcm5FbnZDb25mbGljdHNcIik7XG5cbi8vIHNyYy9ydW50aW1lL2luZGV4LnRzXG52YXIgZGVjb21wcmVzc0Zyb21CYXNlNjQyID0gbHpTdHJpbmcuZGVjb21wcmVzc0Zyb21CYXNlNjQ7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRE1NRixcbiAgRE1NRkNsYXNzLFxuICBEZWJ1ZyxcbiAgRGVjaW1hbCxcbiAgRW5naW5lLFxuICBNZXRyaWNzQ2xpZW50LFxuICBOb3RGb3VuZEVycm9yLFxuICBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLFxuICBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsXG4gIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcixcbiAgU3FsLFxuICBkZWNvbXByZXNzRnJvbUJhc2U2NCxcbiAgZW1wdHksXG4gIGZpbmRTeW5jLFxuICBnZXRQcmlzbWFDbGllbnQsXG4gIGpvaW4sXG4gIG1ha2VEb2N1bWVudCxcbiAgbWFrZVN0cmljdEVudW0sXG4gIG9iamVjdEVudW1WYWx1ZXMsXG4gIHJhdyxcbiAgc3FsdGFnLFxuICB0cmFuc2Zvcm1Eb2N1bWVudCxcbiAgdW5wYWNrLFxuICB3YXJuRW52Q29uZmxpY3RzXG59KTtcbi8qIVxuICogIGRlY2ltYWwuanMgdjEwLjQuMFxuICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanNcbiAqICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cbiAqICBNSVQgTGljZW5jZVxuICovXG4vKiFcbiAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmUgb2JqZWN0IGV4dGVuZGluZ1xuICogQGF1dGhvciBWaWFjaGVzbGF2IExvdHNtYW5vdiA8bG90c21hbm92ODlAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTggVmlhY2hlc2xhdiBMb3RzbWFub3ZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4gKiBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcbiAqIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuICogSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/runtime/index.js\n");

/***/ }),

/***/ "./async-pages/orders.js":
/*!*******************************!*\
  !*** ./async-pages/orders.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"getStaticProps\": () => (/* binding */ getStaticProps)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/shared/lib/styled-jsx */ \"./node_modules/next/dist/shared/lib/styled-jsx.js\");\n/* harmony import */ var next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"webpack/sharing/consume/default/next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prisma/client */ \"./node_modules/@prisma/client/index.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst Orders = (props)=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-71951eac013e1c14\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"Orders2\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                        lineNumber: 8,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\",\n                        className: \"jsx-71951eac013e1c14\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                        lineNumber: 9,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                lineNumber: 7,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-71951eac013e1c14\" + \" \" + \"hero\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"Orders2\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                        lineNumber: 13,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: \"This is a federated page owned by localhost:3002 Orders\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                        lineNumber: 15,\n                        columnNumber: 7\n                    }, undefined),\n                    \"Data from federated getStaticProps\",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                        className: \"jsx-71951eac013e1c14\",\n                        children: JSON.stringify(props, null, 2)\n                    }, void 0, false, {\n                        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                        lineNumber: 18,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n                lineNumber: 12,\n                columnNumber: 5\n            }, undefined),\n            (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_dist_shared_lib_styled_jsx__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"71951eac013e1c14\",\n                children: \".hero.jsx-71951eac013e1c14{width:100%;color:#333}.title.jsx-71951eac013e1c14{margin:0;width:100%;padding-top:80px;line-height:1.15;font-size:20px}.title.jsx-71951eac013e1c14,.description.jsx-71951eac013e1c14{text-align:center}\"\n            }, void 0, false, void 0, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/aristosmarkogiannakis/Projects/conference/alicante-microfrontends-demo2/orders/async-pages/orders.js\",\n        lineNumber: 6,\n        columnNumber: 3\n    }, undefined);\n};\nconst getStaticProps = async ()=>{\n    const prisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_3__.PrismaClient();\n    console.log(prisma);\n    const orders = await prisma.Order.findMany();\n    console.log(orders);\n    return {\n        props: {\n            orders: orders.map((order)=>{\n                return {\n                    id: order.id,\n                    createdAt: order.createdAt.toString(),\n                    updatedAt: order.updatedAt.toString(),\n                    buyerId: order.buyerId\n                };\n            })\n        },\n        revalidate: 10\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Orders);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3luYy1wYWdlcy9vcmRlcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUE2QjtBQUNlO0FBRTVDLE1BQU1FLE1BQU0sR0FBR0MsQ0FBQUEsS0FBSyxHQUFJO0lBQ3RCLHFCQUNBLDhEQUFDQyxLQUFHOzs7MEJBQ0YsOERBQUNKLGtEQUFJOztrQ0FDSCw4REFBQ0ssT0FBSzs7a0NBQUMsU0FBTzs7Ozs7aUNBQVE7a0NBQ3RCLDhEQUFDQyxNQUFJO3dCQUFDQyxHQUFHLEVBQUMsTUFBTTt3QkFBQ0MsSUFBSSxFQUFDLGNBQWM7Ozs7OztpQ0FBRzs7Ozs7O3lCQUNsQzswQkFFUCw4REFBQ0osS0FBRzswREFBVyxNQUFNOztrQ0FDbkIsOERBQUNLLElBQUU7O2tDQUFDLFNBQU87Ozs7O2lDQUFLO2tDQUVoQiw4REFBQ0MsR0FBQzs7a0NBQUMseURBQXVEOzs7OztpQ0FBSTtvQkFBQSxvQ0FHOUQ7a0NBQUEsOERBQUNDLEtBQUc7O2tDQUFFQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ1YsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7Ozs7O2lDQUFPOzs7Ozs7eUJBQ3ZDOzs7Ozs7Ozs7O2lCQWtCRixDQUNQO0NBQUM7QUFFSyxNQUFNVyxjQUFjLEdBQUcsVUFBWTtJQUN4QyxNQUFNQyxNQUFNLEdBQUcsSUFBSWQsd0RBQVksRUFBRTtJQUVqQ2UsT0FBTyxDQUFDQyxHQUFHLENBQUNGLE1BQU0sQ0FBQyxDQUFDO0lBRXBCLE1BQU1HLE1BQU0sR0FBRyxNQUFNSCxNQUFNLENBQUNJLEtBQUssQ0FBQ0MsUUFBUSxFQUFFO0lBRTVDSixPQUFPLENBQUNDLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDLENBQUM7SUFFcEIsT0FBTztRQUNMZixLQUFLLEVBQUU7WUFBRWUsTUFBTSxFQUFFQSxNQUFNLENBQUNHLEdBQUcsQ0FDekJDLENBQUFBLEtBQUssR0FBSTtnQkFDUCxPQUFPO29CQUNMQyxFQUFFLEVBQUVELEtBQUssQ0FBQ0MsRUFBRTtvQkFDWkMsU0FBUyxFQUFFRixLQUFLLENBQUNFLFNBQVMsQ0FBQ0MsUUFBUSxFQUFFO29CQUNyQ0MsU0FBUyxFQUFFSixLQUFLLENBQUNJLFNBQVMsQ0FBQ0QsUUFBUSxFQUFFO29CQUNyQ0UsT0FBTyxFQUFFTCxLQUFLLENBQUNLLE9BQU87aUJBQ3ZCO2FBRUYsQ0FDRjtTQUFFO1FBQ0hDLFVBQVUsRUFBRSxFQUFFO0tBQ2YsQ0FBQztDQUdILENBQUM7QUFFRixpRUFBZTFCLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29yZGVycy8uL2FzeW5jLXBhZ2VzL29yZGVycy5qcz9kNjE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQge1ByaXNtYUNsaWVudH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xuXG5jb25zdCBPcmRlcnMgPSBwcm9wcyA9PiB7XG4gIHJldHVybiAoXG4gIDxkaXY+XG4gICAgPEhlYWQ+XG4gICAgICA8dGl0bGU+T3JkZXJzMjwvdGl0bGU+XG4gICAgICA8bGluayByZWw9XCJpY29uXCIgaHJlZj1cIi9mYXZpY29uLmljb1wiIC8+XG4gICAgPC9IZWFkPlxuXG4gICAgPGRpdiBjbGFzc05hbWU9XCJoZXJvXCI+XG4gICAgICA8aDE+T3JkZXJzMjwvaDE+XG4gICAgICBcbiAgICAgIDxwPlRoaXMgaXMgYSBmZWRlcmF0ZWQgcGFnZSBvd25lZCBieSBsb2NhbGhvc3Q6MzAwMiBPcmRlcnM8L3A+IFxuXG4gICAgICAgIERhdGEgZnJvbSBmZWRlcmF0ZWQgZ2V0U3RhdGljUHJvcHNcbiAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KHByb3BzLCBudWxsLCAyKX08L3ByZT5cbiAgICA8L2Rpdj5cbiAgICA8c3R5bGUganN4PntgXG4gICAgICAuaGVybyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBjb2xvcjogIzMzMztcbiAgICAgIH1cbiAgICAgIC50aXRsZSB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHBhZGRpbmctdG9wOiA4MHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgfVxuICAgICAgLnRpdGxlLFxuICAgICAgLmRlc2NyaXB0aW9uIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgfVxuICAgIGB9PC9zdHlsZT5cbiAgPC9kaXY+XG4pfTtcblxuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1Byb3BzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCk7XG5cbiAgY29uc29sZS5sb2cocHJpc21hKTtcblxuICBjb25zdCBvcmRlcnMgPSBhd2FpdCBwcmlzbWEuT3JkZXIuZmluZE1hbnkoKTtcblxuICBjb25zb2xlLmxvZyhvcmRlcnMpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHsgb3JkZXJzOiBvcmRlcnMubWFwKFxuICAgICAgb3JkZXIgPT4ge1xuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICBpZDogb3JkZXIuaWQsXG4gICAgICAgICAgY3JlYXRlZEF0OiBvcmRlci5jcmVhdGVkQXQudG9TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9yZGVyLnVwZGF0ZWRBdC50b1N0cmluZygpLFxuICAgICAgICAgIGJ1eWVySWQ6IG9yZGVyLmJ1eWVySWQsXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICkgfSxcbiAgICByZXZhbGlkYXRlOiAxMCxcbiAgfTtcblxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBPcmRlcnM7XG4iXSwibmFtZXMiOlsiSGVhZCIsIlByaXNtYUNsaWVudCIsIk9yZGVycyIsInByb3BzIiwiZGl2IiwidGl0bGUiLCJsaW5rIiwicmVsIiwiaHJlZiIsImgxIiwicCIsInByZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRTdGF0aWNQcm9wcyIsInByaXNtYSIsImNvbnNvbGUiLCJsb2ciLCJvcmRlcnMiLCJPcmRlciIsImZpbmRNYW55IiwibWFwIiwib3JkZXIiLCJpZCIsImNyZWF0ZWRBdCIsInRvU3RyaW5nIiwidXBkYXRlZEF0IiwiYnV5ZXJJZCIsInJldmFsaWRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./async-pages/orders.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/styled-jsx.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/styled-jsx.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! styled-jsx/style */ \"./node_modules/styled-jsx/style.js\"); //# sourceMappingURL=styled-jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc3R5bGVkLWpzeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxrR0FBNEMsQ0FBQyxDQUU3QyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmRlcnMvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc3R5bGVkLWpzeC5qcz80ODkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdzdHlsZWQtanN4L3N0eWxlJyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlZC1qc3guanMubWFwIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/styled-jsx.js\n");

/***/ }),

/***/ "./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 583:\n/***/ (function(module) {\n\n\n\nfunction hash(str) {\n  var hash = 5381,\n      i    = str.length;\n\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nmodule.exports = hash;\n\n\n/***/ }),\n\n/***/ 590:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports.computeId = computeId;\nexports.computeSelector = computeSelector;\n\nvar _stringHash = _interopRequireDefault(__nccwpck_require__(583));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar sanitize = function sanitize(rule) {\n  return rule.replace(/\\/style/gi, '\\\\/style');\n};\n\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */\n\nfunction computeId(baseId, props) {\n  if (!props) {\n    return \"jsx-\" + baseId;\n  }\n\n  var propsToString = String(props);\n  var key = baseId + propsToString;\n\n  if (!cache[key]) {\n    cache[key] = \"jsx-\" + (0, _stringHash[\"default\"])(baseId + \"-\" + propsToString);\n  }\n\n  return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */\n\n\nfunction computeSelector(id, css) {\n  var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g; // Sanitize SSR-ed CSS.\n  // Client side code doesn't need to be sanitized since we use\n  // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n\n  if (typeof window === 'undefined') {\n    css = sanitize(css);\n  }\n\n  var idcss = id + css;\n\n  if (!cache[idcss]) {\n    cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n  }\n\n  return cache[idcss];\n}\n\n/***/ }),\n\n/***/ 503:\n/***/ (function(__unused_webpack_module, exports) {\n\n\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/\nvar isProd = typeof process !== 'undefined' && process.env && \"development\" === 'production';\n\nvar isString = function isString(o) {\n  return Object.prototype.toString.call(o) === '[object String]';\n};\n\nvar StyleSheet = /*#__PURE__*/function () {\n  function StyleSheet(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? 'stylesheet' : _ref$name,\n        _ref$optimizeForSpeed = _ref.optimizeForSpeed,\n        optimizeForSpeed = _ref$optimizeForSpeed === void 0 ? isProd : _ref$optimizeForSpeed,\n        _ref$isBrowser = _ref.isBrowser,\n        isBrowser = _ref$isBrowser === void 0 ? typeof window !== 'undefined' : _ref$isBrowser;\n\n    invariant(isString(name), '`name` must be a string');\n    this._name = name;\n    this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n    invariant(typeof optimizeForSpeed === 'boolean', '`optimizeForSpeed` must be a boolean');\n    this._optimizeForSpeed = optimizeForSpeed;\n    this._isBrowser = isBrowser;\n    this._serverSheet = undefined;\n    this._tags = [];\n    this._injected = false;\n    this._rulesCount = 0;\n    var node = this._isBrowser && document.querySelector('meta[property=\"csp-nonce\"]');\n    this._nonce = node ? node.getAttribute('content') : null;\n  }\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n    invariant(typeof bool === 'boolean', '`setOptimizeForSpeed` accepts a boolean');\n    invariant(this._rulesCount === 0, 'optimizeForSpeed cannot be when rules have already been inserted');\n    this.flush();\n    this._optimizeForSpeed = bool;\n    this.inject();\n  };\n\n  _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n    return this._optimizeForSpeed;\n  };\n\n  _proto.inject = function inject() {\n    var _this = this;\n\n    invariant(!this._injected, 'sheet already injected');\n    this._injected = true;\n\n    if (this._isBrowser && this._optimizeForSpeed) {\n      this._tags[0] = this.makeStyleTag(this._name);\n      this._optimizeForSpeed = 'insertRule' in this.getSheet();\n\n      if (!this._optimizeForSpeed) {\n        if (!isProd) {\n          console.warn('StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.');\n        }\n\n        this.flush();\n        this._injected = true;\n      }\n\n      return;\n    }\n\n    this._serverSheet = {\n      cssRules: [],\n      insertRule: function insertRule(rule, index) {\n        if (typeof index === 'number') {\n          _this._serverSheet.cssRules[index] = {\n            cssText: rule\n          };\n        } else {\n          _this._serverSheet.cssRules.push({\n            cssText: rule\n          });\n        }\n\n        return index;\n      },\n      deleteRule: function deleteRule(index) {\n        _this._serverSheet.cssRules[index] = null;\n      }\n    };\n  };\n\n  _proto.getSheetForTag = function getSheetForTag(tag) {\n    if (tag.sheet) {\n      return tag.sheet;\n    } // this weirdness brought to you by firefox\n\n\n    for (var i = 0; i < document.styleSheets.length; i++) {\n      if (document.styleSheets[i].ownerNode === tag) {\n        return document.styleSheets[i];\n      }\n    }\n  };\n\n  _proto.getSheet = function getSheet() {\n    return this.getSheetForTag(this._tags[this._tags.length - 1]);\n  };\n\n  _proto.insertRule = function insertRule(rule, index) {\n    invariant(isString(rule), '`insertRule` accepts only strings');\n\n    if (!this._isBrowser) {\n      if (typeof index !== 'number') {\n        index = this._serverSheet.cssRules.length;\n      }\n\n      this._serverSheet.insertRule(rule, index);\n\n      return this._rulesCount++;\n    }\n\n    if (this._optimizeForSpeed) {\n      var sheet = this.getSheet();\n\n      if (typeof index !== 'number') {\n        index = sheet.cssRules.length;\n      } // this weirdness for perf, and chrome's weird bug\n      // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n\n\n      try {\n        sheet.insertRule(rule, index);\n      } catch (error) {\n        if (!isProd) {\n          console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n        }\n\n        return -1;\n      }\n    } else {\n      var insertionPoint = this._tags[index];\n\n      this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n    }\n\n    return this._rulesCount++;\n  };\n\n  _proto.replaceRule = function replaceRule(index, rule) {\n    if (this._optimizeForSpeed || !this._isBrowser) {\n      var sheet = this._isBrowser ? this.getSheet() : this._serverSheet;\n\n      if (!rule.trim()) {\n        rule = this._deletedRulePlaceholder;\n      }\n\n      if (!sheet.cssRules[index]) {\n        // @TBD Should we throw an error?\n        return index;\n      }\n\n      sheet.deleteRule(index);\n\n      try {\n        sheet.insertRule(rule, index);\n      } catch (error) {\n        if (!isProd) {\n          console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n        } // In order to preserve the indices we insert a deleteRulePlaceholder\n\n\n        sheet.insertRule(this._deletedRulePlaceholder, index);\n      }\n    } else {\n      var tag = this._tags[index];\n      invariant(tag, \"old rule at index `\" + index + \"` not found\");\n      tag.textContent = rule;\n    }\n\n    return index;\n  };\n\n  _proto.deleteRule = function deleteRule(index) {\n    if (!this._isBrowser) {\n      this._serverSheet.deleteRule(index);\n\n      return;\n    }\n\n    if (this._optimizeForSpeed) {\n      this.replaceRule(index, '');\n    } else {\n      var tag = this._tags[index];\n      invariant(tag, \"rule at index `\" + index + \"` not found\");\n      tag.parentNode.removeChild(tag);\n      this._tags[index] = null;\n    }\n  };\n\n  _proto.flush = function flush() {\n    this._injected = false;\n    this._rulesCount = 0;\n\n    if (this._isBrowser) {\n      this._tags.forEach(function (tag) {\n        return tag && tag.parentNode.removeChild(tag);\n      });\n\n      this._tags = [];\n    } else {\n      // simpler on server\n      this._serverSheet.cssRules = [];\n    }\n  };\n\n  _proto.cssRules = function cssRules() {\n    var _this2 = this;\n\n    if (!this._isBrowser) {\n      return this._serverSheet.cssRules;\n    }\n\n    return this._tags.reduce(function (rules, tag) {\n      if (tag) {\n        rules = rules.concat(Array.prototype.map.call(_this2.getSheetForTag(tag).cssRules, function (rule) {\n          return rule.cssText === _this2._deletedRulePlaceholder ? null : rule;\n        }));\n      } else {\n        rules.push(null);\n      }\n\n      return rules;\n    }, []);\n  };\n\n  _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n    if (cssString) {\n      invariant(isString(cssString), 'makeStyleTag accepts only strings as second parameter');\n    }\n\n    var tag = document.createElement('style');\n    if (this._nonce) tag.setAttribute('nonce', this._nonce);\n    tag.type = 'text/css';\n    tag.setAttribute(\"data-\" + name, '');\n\n    if (cssString) {\n      tag.appendChild(document.createTextNode(cssString));\n    }\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n\n    if (relativeToTag) {\n      head.insertBefore(tag, relativeToTag);\n    } else {\n      head.appendChild(tag);\n    }\n\n    return tag;\n  };\n\n  _createClass(StyleSheet, [{\n    key: \"length\",\n    get: function get() {\n      return this._rulesCount;\n    }\n  }]);\n\n  return StyleSheet;\n}();\n\nexports[\"default\"] = StyleSheet;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(\"StyleSheet: \" + message + \".\");\n  }\n}\n\n/***/ }),\n\n/***/ 449:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports[\"default\"] = JSXStyle;\n\nvar _react = _interopRequireDefault(__nccwpck_require__(522));\n\nvar _stylesheetRegistry = __nccwpck_require__(147);\n\nvar _hash = __nccwpck_require__(590);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = _react[\"default\"].useInsertionEffect || _react[\"default\"].useLayoutEffect;\nvar defaultRegistry = typeof window !== 'undefined' ? (0, _stylesheetRegistry.createStyleRegistry)() : undefined;\n\nfunction JSXStyle(props) {\n  var registry = defaultRegistry ? defaultRegistry : (0, _stylesheetRegistry.useStyleRegistry)(); // If `registry` does not exist, we do nothing here.\n\n  if (!registry) {\n    return null;\n  }\n\n  if (typeof window === 'undefined') {\n    registry.add(props);\n    return null;\n  }\n\n  useInsertionEffect(function () {\n    registry.add(props);\n    return function () {\n      registry.remove(props);\n    }; // props.children can be string[], will be striped since id is identical\n  }, [props.id, String(props.dynamic)]);\n  return null;\n}\n\nJSXStyle.dynamic = function (info) {\n  return info.map(function (tagInfo) {\n    var baseId = tagInfo[0];\n    var props = tagInfo[1];\n    return (0, _hash.computeId)(baseId, props);\n  }).join(' ');\n};\n\n/***/ }),\n\n/***/ 147:\n/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {\n\n\n\nexports.__esModule = true;\nexports.createStyleRegistry = createStyleRegistry;\nexports.StyleRegistry = StyleRegistry;\nexports.useStyleRegistry = useStyleRegistry;\nexports.StyleSheetContext = exports.StyleSheetRegistry = void 0;\n\nvar _react = _interopRequireWildcard(__nccwpck_require__(522));\n\nvar _stylesheet = _interopRequireDefault(__nccwpck_require__(503));\n\nvar _hash = __nccwpck_require__(590);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction mapRulesToStyle(cssRules, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return cssRules.map(function (args) {\n    var id = args[0];\n    var css = args[1];\n    return _react[\"default\"].createElement('style', {\n      id: \"__\" + id,\n      // Avoid warnings upon render with a key\n      key: \"__\" + id,\n      nonce: options.nonce ? options.nonce : undefined,\n      dangerouslySetInnerHTML: {\n        __html: css\n      }\n    });\n  });\n}\n\nvar StyleSheetRegistry = /*#__PURE__*/function () {\n  function StyleSheetRegistry(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$styleSheet = _ref.styleSheet,\n        styleSheet = _ref$styleSheet === void 0 ? null : _ref$styleSheet,\n        _ref$optimizeForSpeed = _ref.optimizeForSpeed,\n        optimizeForSpeed = _ref$optimizeForSpeed === void 0 ? false : _ref$optimizeForSpeed,\n        _ref$isBrowser = _ref.isBrowser,\n        isBrowser = _ref$isBrowser === void 0 ? typeof window !== 'undefined' : _ref$isBrowser;\n\n    this._sheet = styleSheet || new _stylesheet[\"default\"]({\n      name: 'styled-jsx',\n      optimizeForSpeed: optimizeForSpeed\n    });\n\n    this._sheet.inject();\n\n    if (styleSheet && typeof optimizeForSpeed === 'boolean') {\n      this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n\n      this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n    }\n\n    this._isBrowser = isBrowser;\n    this._fromServer = undefined;\n    this._indices = {};\n    this._instancesCounts = {};\n  }\n\n  var _proto = StyleSheetRegistry.prototype;\n\n  _proto.add = function add(props) {\n    var _this = this;\n\n    if (undefined === this._optimizeForSpeed) {\n      this._optimizeForSpeed = Array.isArray(props.children);\n\n      this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n\n      this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n    }\n\n    if (this._isBrowser && !this._fromServer) {\n      this._fromServer = this.selectFromServer();\n      this._instancesCounts = Object.keys(this._fromServer).reduce(function (acc, tagName) {\n        acc[tagName] = 0;\n        return acc;\n      }, {});\n    }\n\n    var _this$getIdAndRules = this.getIdAndRules(props),\n        styleId = _this$getIdAndRules.styleId,\n        rules = _this$getIdAndRules.rules; // Deduping: just increase the instances count.\n\n\n    if (styleId in this._instancesCounts) {\n      this._instancesCounts[styleId] += 1;\n      return;\n    }\n\n    var indices = rules.map(function (rule) {\n      return _this._sheet.insertRule(rule);\n    }) // Filter out invalid rules\n    .filter(function (index) {\n      return index !== -1;\n    });\n    this._indices[styleId] = indices;\n    this._instancesCounts[styleId] = 1;\n  };\n\n  _proto.remove = function remove(props) {\n    var _this2 = this;\n\n    var _this$getIdAndRules2 = this.getIdAndRules(props),\n        styleId = _this$getIdAndRules2.styleId;\n\n    invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n    this._instancesCounts[styleId] -= 1;\n\n    if (this._instancesCounts[styleId] < 1) {\n      var tagFromServer = this._fromServer && this._fromServer[styleId];\n\n      if (tagFromServer) {\n        tagFromServer.parentNode.removeChild(tagFromServer);\n        delete this._fromServer[styleId];\n      } else {\n        this._indices[styleId].forEach(function (index) {\n          return _this2._sheet.deleteRule(index);\n        });\n\n        delete this._indices[styleId];\n      }\n\n      delete this._instancesCounts[styleId];\n    }\n  };\n\n  _proto.update = function update(props, nextProps) {\n    this.add(nextProps);\n    this.remove(props);\n  };\n\n  _proto.flush = function flush() {\n    this._sheet.flush();\n\n    this._sheet.inject();\n\n    this._fromServer = undefined;\n    this._indices = {};\n    this._instancesCounts = {};\n  };\n\n  _proto.cssRules = function cssRules() {\n    var _this3 = this;\n\n    var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function (styleId) {\n      return [styleId, _this3._fromServer[styleId]];\n    }) : [];\n\n    var cssRules = this._sheet.cssRules();\n\n    return fromServer.concat(Object.keys(this._indices).map(function (styleId) {\n      return [styleId, _this3._indices[styleId].map(function (index) {\n        return cssRules[index].cssText;\n      }).join(_this3._optimizeForSpeed ? '' : '\\n')];\n    }) // filter out empty rules\n    .filter(function (rule) {\n      return Boolean(rule[1]);\n    }));\n  };\n\n  _proto.styles = function styles(options) {\n    return mapRulesToStyle(this.cssRules(), options);\n  };\n\n  _proto.getIdAndRules = function getIdAndRules(props) {\n    var css = props.children,\n        dynamic = props.dynamic,\n        id = props.id;\n\n    if (dynamic) {\n      var styleId = (0, _hash.computeId)(id, dynamic);\n      return {\n        styleId: styleId,\n        rules: Array.isArray(css) ? css.map(function (rule) {\n          return (0, _hash.computeSelector)(styleId, rule);\n        }) : [(0, _hash.computeSelector)(styleId, css)]\n      };\n    }\n\n    return {\n      styleId: (0, _hash.computeId)(id),\n      rules: Array.isArray(css) ? css : [css]\n    };\n  }\n  /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */\n  ;\n\n  _proto.selectFromServer = function selectFromServer() {\n    var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n    return elements.reduce(function (acc, element) {\n      var id = element.id.slice(2);\n      acc[id] = element;\n      return acc;\n    }, {});\n  };\n\n  return StyleSheetRegistry;\n}();\n\nexports.StyleSheetRegistry = StyleSheetRegistry;\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n  }\n}\n\nvar StyleSheetContext = (0, _react.createContext)(null);\nexports.StyleSheetContext = StyleSheetContext;\n\nfunction createStyleRegistry() {\n  return new StyleSheetRegistry();\n}\n\nfunction StyleRegistry(_ref2) {\n  var configuredRegistry = _ref2.registry,\n      children = _ref2.children;\n  var rootRegistry = (0, _react.useContext)(StyleSheetContext);\n\n  var _useState = (0, _react.useState)(function () {\n    return rootRegistry || configuredRegistry || createStyleRegistry();\n  }),\n      registry = _useState[0];\n\n  return _react[\"default\"].createElement(StyleSheetContext.Provider, {\n    value: registry\n  }, children);\n}\n\nfunction useStyleRegistry() {\n  return (0, _react.useContext)(StyleSheetContext);\n}\n\n/***/ }),\n\n/***/ 522:\n/***/ (function(module) {\n\nmodule.exports = __webpack_require__(/*! react */ \"react\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat */\n/******/ \t\n/******/ \tif (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + \"/\";\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n!function() {\nvar exports = __webpack_exports__;\n\n\nexports.__esModule = true;\nexports.style = exports.useStyleRegistry = exports.createStyleRegistry = exports.StyleRegistry = void 0;\n\nvar _stylesheetRegistry = __nccwpck_require__(147);\n\nexports.StyleRegistry = _stylesheetRegistry.StyleRegistry;\nexports.createStyleRegistry = _stylesheetRegistry.createStyleRegistry;\nexports.useStyleRegistry = _stylesheetRegistry.useStyleRegistry;\n\nvar _style = _interopRequireDefault(__nccwpck_require__(449));\n\nexports.style = _style[\"default\"];\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n}();\nmodule.exports = __webpack_exports__;\n/******/ })()\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L2luZGV4L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBb0I7O0FBRWxGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QztBQUM5RSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmRlcnMvLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L2luZGV4L2luZGV4LmpzP2IwMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDU4Mzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MSxcbiAgICAgIGkgICAgPSBzdHIubGVuZ3RoO1xuXG4gIHdoaWxlKGkpIHtcbiAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICB9XG5cbiAgLyogSmF2YVNjcmlwdCBkb2VzIGJpdHdpc2Ugb3BlcmF0aW9ucyAobGlrZSBYT1IsIGFib3ZlKSBvbiAzMi1iaXQgc2lnbmVkXG4gICAqIGludGVnZXJzLiBTaW5jZSB3ZSB3YW50IHRoZSByZXN1bHRzIHRvIGJlIGFsd2F5cyBwb3NpdGl2ZSwgY29udmVydCB0aGVcbiAgICogc2lnbmVkIGludCB0byBhbiB1bnNpZ25lZCBieSBkb2luZyBhbiB1bnNpZ25lZCBiaXRzaGlmdC4gKi9cbiAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTkwOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX25jY3dwY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wdXRlSWQgPSBjb21wdXRlSWQ7XG5leHBvcnRzLmNvbXB1dGVTZWxlY3RvciA9IGNvbXB1dGVTZWxlY3RvcjtcblxudmFyIF9zdHJpbmdIYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX25jY3dwY2tfcmVxdWlyZV9fKDU4MykpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIHNhbml0aXplID0gZnVuY3Rpb24gc2FuaXRpemUocnVsZSkge1xuICByZXR1cm4gcnVsZS5yZXBsYWNlKC9cXC9zdHlsZS9naSwgJ1xcXFwvc3R5bGUnKTtcbn07XG5cbnZhciBjYWNoZSA9IHt9O1xuLyoqXG4gKiBjb21wdXRlSWRcbiAqXG4gKiBDb21wdXRlIGFuZCBtZW1vaXplIGEganN4IGlkIGZyb20gYSBiYXNlZElkIGFuZCBvcHRpb25hbGx5IHByb3BzLlxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVJZChiYXNlSWQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm4gXCJqc3gtXCIgKyBiYXNlSWQ7XG4gIH1cblxuICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gIHZhciBrZXkgPSBiYXNlSWQgKyBwcm9wc1RvU3RyaW5nO1xuXG4gIGlmICghY2FjaGVba2V5XSkge1xuICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArICgwLCBfc3RyaW5nSGFzaFtcImRlZmF1bHRcIl0pKGJhc2VJZCArIFwiLVwiICsgcHJvcHNUb1N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVba2V5XTtcbn1cbi8qKlxuICogY29tcHV0ZVNlbGVjdG9yXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBkeW5hbWljIHNlbGVjdG9ycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXB1dGVTZWxlY3RvcihpZCwgY3NzKSB7XG4gIHZhciBzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAgPSAvX19qc3gtc3R5bGUtZHluYW1pYy1zZWxlY3Rvci9nOyAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAvLyBDbGllbnQgc2lkZSBjb2RlIGRvZXNuJ3QgbmVlZCB0byBiZSBzYW5pdGl6ZWQgc2luY2Ugd2UgdXNlXG4gIC8vIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlIChkZXYpIGFuZCB0aGUgQ1NTT00gYXBpIHNoZWV0Lmluc2VydFJ1bGUgKHByb2QpLlxuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyA9IHNhbml0aXplKGNzcyk7XG4gIH1cblxuICB2YXIgaWRjc3MgPSBpZCArIGNzcztcblxuICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgIGNhY2hlW2lkY3NzXSA9IGNzcy5yZXBsYWNlKHNlbGVjdG9QbGFjZWhvbGRlclJlZ2V4cCwgaWQpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qXG5CYXNlZCBvbiBHbGFtb3IncyBzaGVldFxuaHR0cHM6Ly9naXRodWIuY29tL3RocmVlcG9pbnRvbmUvZ2xhbW9yL2Jsb2IvNjY3YjQ4MGQzMWIzNzIxYTkwNTAyMWIyNmUxMjkwY2U5MmNhMjg3OS9zcmMvc2hlZXQuanNcbiovXG52YXIgaXNQcm9kID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIG5hbWUgPSBfcmVmJG5hbWUgPT09IHZvaWQgMCA/ICdzdHlsZXNoZWV0JyA6IF9yZWYkbmFtZSxcbiAgICAgICAgX3JlZiRvcHRpbWl6ZUZvclNwZWVkID0gX3JlZi5vcHRpbWl6ZUZvclNwZWVkLFxuICAgICAgICBvcHRpbWl6ZUZvclNwZWVkID0gX3JlZiRvcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfcmVmJG9wdGltaXplRm9yU3BlZWQsXG4gICAgICAgIF9yZWYkaXNCcm93c2VyID0gX3JlZi5pc0Jyb3dzZXIsXG4gICAgICAgIGlzQnJvd3NlciA9IF9yZWYkaXNCcm93c2VyID09PSB2b2lkIDAgPyB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA6IF9yZWYkaXNCcm93c2VyO1xuXG4gICAgaW52YXJpYW50KGlzU3RyaW5nKG5hbWUpLCAnYG5hbWVgIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgaW52YXJpYW50KHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSAnYm9vbGVhbicsICdgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gb3B0aW1pemVGb3JTcGVlZDtcbiAgICB0aGlzLl9pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG4gICAgdGhpcy5fc2VydmVyU2hlZXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGFncyA9IFtdO1xuICAgIHRoaXMuX2luamVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9pc0Jyb3dzZXIgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICAgIHRoaXMuX25vbmNlID0gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdjb250ZW50JykgOiBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiBib29sID09PSAnYm9vbGVhbicsICdgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW4nKTtcbiAgICBpbnZhcmlhbnQodGhpcy5fcnVsZXNDb3VudCA9PT0gMCwgJ29wdGltaXplRm9yU3BlZWQgY2Fubm90IGJlIHdoZW4gcnVsZXMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWQnKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IGJvb2w7XG4gICAgdGhpcy5pbmplY3QoKTtcbiAgfTtcblxuICBfcHJvdG8uaXNPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gaXNPcHRpbWl6ZUZvclNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICB9O1xuXG4gIF9wcm90by5pbmplY3QgPSBmdW5jdGlvbiBpbmplY3QoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGludmFyaWFudCghdGhpcy5faW5qZWN0ZWQsICdzaGVldCBhbHJlYWR5IGluamVjdGVkJyk7XG4gICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX2lzQnJvd3NlciAmJiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICB0aGlzLl90YWdzWzBdID0gdGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSk7XG4gICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gJ2luc2VydFJ1bGUnIGluIHRoaXMuZ2V0U2hlZXQoKTtcblxuICAgICAgaWYgKCF0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdTdHlsZVNoZWV0OiBvcHRpbWl6ZUZvclNwZWVkIG1vZGUgbm90IHN1cHBvcnRlZCBmYWxsaW5nIGJhY2sgdG8gc3RhbmRhcmQgbW9kZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2VydmVyU2hlZXQgPSB7XG4gICAgICBjc3NSdWxlczogW10sXG4gICAgICBpbnNlcnRSdWxlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzW2luZGV4XSA9IHtcbiAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH0sXG4gICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgaWYgKHRhZy5zaGVldCkge1xuICAgICAgcmV0dXJuIHRhZy5zaGVldDtcbiAgICB9IC8vIHRoaXMgd2VpcmRuZXNzIGJyb3VnaHQgdG8geW91IGJ5IGZpcmVmb3hcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldFNoZWV0ID0gZnVuY3Rpb24gZ2V0U2hlZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSwgaW5kZXgpIHtcbiAgICBpbnZhcmlhbnQoaXNTdHJpbmcocnVsZSksICdgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3MnKTtcblxuICAgIGlmICghdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IHRoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VydmVyU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICB9IC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdHlsZVNoZWV0OiBpbGxlZ2FsIHJ1bGU6IFxcblxcblwiICsgcnVsZSArIFwiXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSB0aGlzLl90YWdzW2luZGV4XTtcblxuICAgICAgdGhpcy5fdGFncy5wdXNoKHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUsIHJ1bGUsIGluc2VydGlvblBvaW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQrKztcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShpbmRleCwgcnVsZSkge1xuICAgIGlmICh0aGlzLl9vcHRpbWl6ZUZvclNwZWVkIHx8ICF0aGlzLl9pc0Jyb3dzZXIpIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMuX2lzQnJvd3NlciA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuXG4gICAgICBpZiAoIXJ1bGUudHJpbSgpKSB7XG4gICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoZWV0LmNzc1J1bGVzW2luZGV4XSkge1xuICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgIH0gLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGluZGljZXMgd2UgaW5zZXJ0IGEgZGVsZXRlUnVsZVBsYWNlaG9sZGVyXG5cblxuICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHRhZywgXCJvbGQgcnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICB0YWcudGV4dENvbnRlbnQgPSBydWxlO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQnJvd3Nlcikge1xuICAgICAgdGhpcy5fc2VydmVyU2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICBpbnZhcmlhbnQodGFnLCBcInJ1bGUgYXQgaW5kZXggYFwiICsgaW5kZXggKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnKTtcbiAgICAgIHRoaXMuX3RhZ3NbaW5kZXhdID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcblxuICAgIGlmICh0aGlzLl9pc0Jyb3dzZXIpIHtcbiAgICAgIHRoaXMuX3RhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHJldHVybiB0YWcgJiYgdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90YWdzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNpbXBsZXIgb24gc2VydmVyXG4gICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcyA9IFtdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY3NzUnVsZXMgPSBmdW5jdGlvbiBjc3NSdWxlcygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICghdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uIChydWxlcywgdGFnKSB7XG4gICAgICBpZiAodGFnKSB7XG4gICAgICAgIHJ1bGVzID0gcnVsZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChfdGhpczIuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpczIuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIgPyBudWxsIDogcnVsZTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICBfcHJvdG8ubWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKG5hbWUsIGNzc1N0cmluZywgcmVsYXRpdmVUb1RhZykge1xuICAgIGlmIChjc3NTdHJpbmcpIHtcbiAgICAgIGludmFyaWFudChpc1N0cmluZyhjc3NTdHJpbmcpLCAnbWFrZVN0eWxlVGFnIGFjY2VwdHMgb25seSBzdHJpbmdzIGFzIHNlY29uZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgdGhpcy5fbm9uY2UpO1xuICAgIHRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsICcnKTtcblxuICAgIGlmIChjc3NTdHJpbmcpIHtcbiAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NTdHJpbmcpKTtcbiAgICB9XG5cbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgIGlmIChyZWxhdGl2ZVRvVGFnKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZSh0YWcsIHJlbGF0aXZlVG9UYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZztcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVTaGVldCwgW3tcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTdHlsZVNoZWV0O1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3R5bGVTaGVldDogXCIgKyBtZXNzYWdlICsgXCIuXCIpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pIHtcblxuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEpTWFN0eWxlO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX25jY3dwY2tfcmVxdWlyZV9fKDUyMikpO1xuXG52YXIgX3N0eWxlc2hlZXRSZWdpc3RyeSA9IF9fbmNjd3Bja19yZXF1aXJlX18oMTQ3KTtcblxudmFyIF9oYXNoID0gX19uY2N3cGNrX3JlcXVpcmVfXyg1OTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gX3JlYWN0W1wiZGVmYXVsdFwiXS51c2VJbnNlcnRpb25FZmZlY3QgfHwgX3JlYWN0W1wiZGVmYXVsdFwiXS51c2VMYXlvdXRFZmZlY3Q7XG52YXIgZGVmYXVsdFJlZ2lzdHJ5ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgX3N0eWxlc2hlZXRSZWdpc3RyeS5jcmVhdGVTdHlsZVJlZ2lzdHJ5KSgpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICB2YXIgcmVnaXN0cnkgPSBkZWZhdWx0UmVnaXN0cnkgPyBkZWZhdWx0UmVnaXN0cnkgOiAoMCwgX3N0eWxlc2hlZXRSZWdpc3RyeS51c2VTdHlsZVJlZ2lzdHJ5KSgpOyAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG5cbiAgaWYgKCFyZWdpc3RyeSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICB9OyAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgfSwgW3Byb3BzLmlkLCBTdHJpbmcocHJvcHMuZHluYW1pYyldKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbiAoaW5mbykge1xuICByZXR1cm4gaW5mby5tYXAoZnVuY3Rpb24gKHRhZ0luZm8pIHtcbiAgICB2YXIgYmFzZUlkID0gdGFnSW5mb1swXTtcbiAgICB2YXIgcHJvcHMgPSB0YWdJbmZvWzFdO1xuICAgIHJldHVybiAoMCwgX2hhc2guY29tcHV0ZUlkKShiYXNlSWQsIHByb3BzKTtcbiAgfSkuam9pbignICcpO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDE0Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXykge1xuXG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlU3R5bGVSZWdpc3RyeSA9IGNyZWF0ZVN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy51c2VTdHlsZVJlZ2lzdHJ5ID0gdXNlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuU3R5bGVTaGVldENvbnRleHQgPSBleHBvcnRzLlN0eWxlU2hlZXRSZWdpc3RyeSA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fbmNjd3Bja19yZXF1aXJlX18oNTIyKSk7XG5cbnZhciBfc3R5bGVzaGVldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX19uY2N3cGNrX3JlcXVpcmVfXyg1MDMpKTtcblxudmFyIF9oYXNoID0gX19uY2N3cGNrX3JlcXVpcmVfXyg1OTApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIG1hcFJ1bGVzVG9TdHlsZShjc3NSdWxlcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGNzc1J1bGVzLm1hcChmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgdmFyIGNzcyA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnc3R5bGUnLCB7XG4gICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBjc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0UmVnaXN0cnkoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHN0eWxlU2hlZXQgPSBfcmVmLnN0eWxlU2hlZXQsXG4gICAgICAgIHN0eWxlU2hlZXQgPSBfcmVmJHN0eWxlU2hlZXQgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHN0eWxlU2hlZXQsXG4gICAgICAgIF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYub3B0aW1pemVGb3JTcGVlZCxcbiAgICAgICAgb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJG9wdGltaXplRm9yU3BlZWQsXG4gICAgICAgIF9yZWYkaXNCcm93c2VyID0gX3JlZi5pc0Jyb3dzZXIsXG4gICAgICAgIGlzQnJvd3NlciA9IF9yZWYkaXNCcm93c2VyID09PSB2b2lkIDAgPyB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA6IF9yZWYkaXNCcm93c2VyO1xuXG4gICAgdGhpcy5fc2hlZXQgPSBzdHlsZVNoZWV0IHx8IG5ldyBfc3R5bGVzaGVldFtcImRlZmF1bHRcIl0oe1xuICAgICAgbmFtZTogJ3N0eWxlZC1qc3gnLFxuICAgICAgb3B0aW1pemVGb3JTcGVlZDogb3B0aW1pemVGb3JTcGVlZFxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2hlZXQuaW5qZWN0KCk7XG5cbiAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKG9wdGltaXplRm9yU3BlZWQpO1xuXG4gICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNCcm93c2VyID0gaXNCcm93c2VyO1xuICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQodGhpcy5fb3B0aW1pemVGb3JTcGVlZCk7XG5cbiAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSB0aGlzLl9zaGVldC5pc09wdGltaXplRm9yU3BlZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCcm93c2VyICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGFnTmFtZSkge1xuICAgICAgICBhY2NbdGFnTmFtZV0gPSAwO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRnZXRJZEFuZFJ1bGVzID0gdGhpcy5nZXRJZEFuZFJ1bGVzKHByb3BzKSxcbiAgICAgICAgc3R5bGVJZCA9IF90aGlzJGdldElkQW5kUnVsZXMuc3R5bGVJZCxcbiAgICAgICAgcnVsZXMgPSBfdGhpcyRnZXRJZEFuZFJ1bGVzLnJ1bGVzOyAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuXG5cbiAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX3NoZWV0Lmluc2VydFJ1bGUocnVsZSk7XG4gICAgfSkgLy8gRmlsdGVyIG91dCBpbnZhbGlkIHJ1bGVzXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gLTE7XG4gICAgfSk7XG4gICAgdGhpcy5faW5kaWNlc1tzdHlsZUlkXSA9IGluZGljZXM7XG4gICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdID0gMTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkZ2V0SWRBbmRSdWxlczIgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLFxuICAgICAgICBzdHlsZUlkID0gX3RoaXMkZ2V0SWRBbmRSdWxlczIuc3R5bGVJZDtcblxuICAgIGludmFyaWFudChzdHlsZUlkIGluIHRoaXMuX2luc3RhbmNlc0NvdW50cywgXCJzdHlsZUlkOiBgXCIgKyBzdHlsZUlkICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcblxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPCAxKSB7XG4gICAgICB2YXIgdGFnRnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgJiYgdGhpcy5fZnJvbVNlcnZlcltzdHlsZUlkXTtcblxuICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgdGFnRnJvbVNlcnZlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZ0Zyb21TZXJ2ZXIpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZnJvbVNlcnZlcltzdHlsZUlkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2luZGljZXNbc3R5bGVJZF07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUocHJvcHMsIG5leHRQcm9wcykge1xuICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgdGhpcy5yZW1vdmUocHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHRoaXMuX3NoZWV0LmZsdXNoKCk7XG5cbiAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcblxuICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICB9O1xuXG4gIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGZyb21TZXJ2ZXIgPSB0aGlzLl9mcm9tU2VydmVyID8gT2JqZWN0LmtleXModGhpcy5fZnJvbVNlcnZlcikubWFwKGZ1bmN0aW9uIChzdHlsZUlkKSB7XG4gICAgICByZXR1cm4gW3N0eWxlSWQsIF90aGlzMy5fZnJvbVNlcnZlcltzdHlsZUlkXV07XG4gICAgfSkgOiBbXTtcblxuICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuX3NoZWV0LmNzc1J1bGVzKCk7XG5cbiAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uIChzdHlsZUlkKSB7XG4gICAgICByZXR1cm4gW3N0eWxlSWQsIF90aGlzMy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjc3NSdWxlc1tpbmRleF0uY3NzVGV4dDtcbiAgICAgIH0pLmpvaW4oX3RoaXMzLl9vcHRpbWl6ZUZvclNwZWVkID8gJycgOiAnXFxuJyldO1xuICAgIH0pIC8vIGZpbHRlciBvdXQgZW1wdHkgcnVsZXNcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihydWxlWzFdKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLnN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICB9O1xuXG4gIF9wcm90by5nZXRJZEFuZFJ1bGVzID0gZnVuY3Rpb24gZ2V0SWRBbmRSdWxlcyhwcm9wcykge1xuICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsXG4gICAgICAgIGlkID0gcHJvcHMuaWQ7XG5cbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgdmFyIHN0eWxlSWQgPSAoMCwgX2hhc2guY29tcHV0ZUlkKShpZCwgZHluYW1pYyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgIHJldHVybiAoMCwgX2hhc2guY29tcHV0ZVNlbGVjdG9yKShzdHlsZUlkLCBydWxlKTtcbiAgICAgICAgfSkgOiBbKDAsIF9oYXNoLmNvbXB1dGVTZWxlY3Rvcikoc3R5bGVJZCwgY3NzKV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlSWQ6ICgwLCBfaGFzaC5jb21wdXRlSWQpKGlkKSxcbiAgICAgIHJ1bGVzOiBBcnJheS5pc0FycmF5KGNzcykgPyBjc3MgOiBbY3NzXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZWxlY3RGcm9tU2VydmVyID0gZnVuY3Rpb24gc2VsZWN0RnJvbVNlcnZlcigpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZWxlbWVudCkge1xuICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcblxuZXhwb3J0cy5TdHlsZVNoZWV0UmVnaXN0cnkgPSBTdHlsZVNoZWV0UmVnaXN0cnk7XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgfVxufVxuXG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAoMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKG51bGwpO1xuZXhwb3J0cy5TdHlsZVNoZWV0Q29udGV4dCA9IFN0eWxlU2hlZXRDb250ZXh0O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkge1xuICByZXR1cm4gbmV3IFN0eWxlU2hlZXRSZWdpc3RyeSgpO1xufVxuXG5mdW5jdGlvbiBTdHlsZVJlZ2lzdHJ5KF9yZWYyKSB7XG4gIHZhciBjb25maWd1cmVkUmVnaXN0cnkgPSBfcmVmMi5yZWdpc3RyeSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW47XG4gIHZhciByb290UmVnaXN0cnkgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKFN0eWxlU2hlZXRDb250ZXh0KTtcblxuICB2YXIgX3VzZVN0YXRlID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByb290UmVnaXN0cnkgfHwgY29uZmlndXJlZFJlZ2lzdHJ5IHx8IGNyZWF0ZVN0eWxlUmVnaXN0cnkoKTtcbiAgfSksXG4gICAgICByZWdpc3RyeSA9IF91c2VTdGF0ZVswXTtcblxuICByZXR1cm4gX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFN0eWxlU2hlZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gdXNlU3R5bGVSZWdpc3RyeSgpIHtcbiAgcmV0dXJuICgwLCBfcmVhY3QudXNlQ29udGV4dCkoU3R5bGVTaGVldENvbnRleHQpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTIyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0dmFyIHRocmV3ID0gdHJ1ZTtcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFx0XHR0aHJldyA9IGZhbHNlO1xuLyoqKioqKi8gXHRcdH0gZmluYWxseSB7XG4vKioqKioqLyBcdFx0XHRpZih0aHJldykgZGVsZXRlIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdGlmICh0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyAhPT0gJ3VuZGVmaW5lZCcpIF9fbmNjd3Bja19yZXF1aXJlX18uYWIgPSBfX2Rpcm5hbWUgKyBcIi9cIjtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG52YXIgZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc3R5bGUgPSBleHBvcnRzLnVzZVN0eWxlUmVnaXN0cnkgPSBleHBvcnRzLmNyZWF0ZVN0eWxlUmVnaXN0cnkgPSBleHBvcnRzLlN0eWxlUmVnaXN0cnkgPSB2b2lkIDA7XG5cbnZhciBfc3R5bGVzaGVldFJlZ2lzdHJ5ID0gX19uY2N3cGNrX3JlcXVpcmVfXygxNDcpO1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBfc3R5bGVzaGVldFJlZ2lzdHJ5LlN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLmNyZWF0ZVN0eWxlUmVnaXN0cnkgPSBfc3R5bGVzaGVldFJlZ2lzdHJ5LmNyZWF0ZVN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLnVzZVN0eWxlUmVnaXN0cnkgPSBfc3R5bGVzaGVldFJlZ2lzdHJ5LnVzZVN0eWxlUmVnaXN0cnk7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fbmNjd3Bja19yZXF1aXJlX18oNDQ5KSk7XG5cbmV4cG9ydHMuc3R5bGUgPSBfc3R5bGVbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/dist/index/index.js\n");

/***/ }),

/***/ "./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index */ \"./node_modules/styled-jsx/dist/index/index.js\").style\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrR0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmRlcnMvLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcz8zNzBiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4Jykuc3R5bGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/style.js\n");

/***/ })

};
;